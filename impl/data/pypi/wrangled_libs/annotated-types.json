{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "environment :: macos x",
    "intended audience :: developers",
    "intended audience :: information technology",
    "license :: osi approved :: mit license",
    "operating system :: posix :: linux",
    "operating system :: unix",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "typing :: typed"
  ],
  "description": "# annotated-types\n\n[![ci](https://github.com/annotated-types/annotated-types/workflows/ci/badge.svg?event=push)](https://github.com/annotated-types/annotated-types/actions?query=event%3apush+branch%3amain+workflow%3aci)\n[![pypi](https://img.shields.io/pypi/v/annotated-types.svg)](https://pypi.python.org/pypi/annotated-types)\n[![versions](https://img.shields.io/pypi/pyversions/annotated-types.svg)](https://github.com/annotated-types/annotated-types)\n[![license](https://img.shields.io/github/license/annotated-types/annotated-types.svg)](https://github.com/annotated-types/annotated-types/blob/main/license)\n\n[pep-593](https://peps.python.org/pep-0593/) added `typing.annotated` as a way of\nadding context-specific metadata to existing types, and specifies that\n`annotated[t, x]` _should_ be treated as `t` by any tool or library without special\nlogic for `x`.\n\nthis package provides metadata objects which can be used to represent common\nconstraints such as upper and lower bounds on scalar values and collection sizes,\na `predicate` marker for runtime checks, and\ndescriptions of how we intend these metadata to be interpreted. in some cases,\nwe also note alternative representations which do not require this package.\n\n## install\n\n```bash\npip install annotated-types\n```\n\n## examples\n\n```python\nfrom typing import annotated\nfrom annotated_types import gt, len, predicate\n\nclass myclass:\n    age: annotated[int, gt(18)]                         # valid: 19, 20, ...\n                                                        # invalid: 17, 18, \"19\", 19.0, ...\n    factors: list[annotated[int, predicate(is_prime)]]  # valid: 2, 3, 5, 7, 11, ...\n                                                        # invalid: 4, 8, -2, 5.0, \"prime\", ...\n\n    my_list: annotated[list[int], len(0, 10)]           # valid: [], [10, 20, 30, 40, 50]\n                                                        # invalid: (1, 2), [\"abc\"], [0] * 20\n```\n\n## documentation\n\n_while `annotated-types` avoids runtime checks for performance, users should not\nconstruct invalid combinations such as `multipleof(\"non-numeric\")` or `annotated[int, len(3)]`.\ndownstream implementors may choose to raise an error, emit a warning, silently ignore\na metadata item, etc., if the metadata objects described below are used with an\nincompatible type - or for any other reason!_\n\n### gt, ge, lt, le\n\nexpress inclusive and/or exclusive bounds on orderable values - which may be numbers,\ndates, times, strings, sets, etc. note that the boundary value need not be of the\nsame type that was annotated, so long as they can be compared: `annotated[int, gt(1.5)]`\nis fine, for example, and implies that the value is an integer x such that `x > 1.5`.\n\nwe suggest that implementors may also interpret `functools.partial(operator.le, 1.5)`\nas being equivalent to `gt(1.5)`, for users who wish to avoid a runtime dependency on\nthe `annotated-types` package.\n\nto be explicit, these types have the following meanings:\n\n* `gt(x)` - value must be \"greater than\" `x` - equivalent to exclusive minimum\n* `ge(x)` - value must be \"greater than or equal\" to `x` - equivalent to inclusive minimum\n* `lt(x)` - value must be \"less than\" `x` - equivalent to exclusive maximum\n* `le(x)` - value must be \"less than or equal\" to `x` - equivalent to inclusive maximum\n\n### interval\n\n`interval(gt, ge, lt, le)` allows you to specify an upper and lower bound with a single\nmetadata object. `none` attributes should be ignored, and non-`none` attributes\ntreated as per the single bounds above.\n\n### multipleof\n\n`multipleof(multiple_of=x)` might be interpreted in two ways:\n\n1. python semantics, implying `value % multiple_of == 0`, or\n2. [jsonschema semantics](https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.2.1),\n   where `int(value / multiple_of) == value / multiple_of`.\n\nwe encourage users to be aware of these two common interpretations and their\ndistinct behaviours, especially since very large or non-integer numbers make\nit easy to cause silent data corruption due to floating-point imprecision.\n\nwe encourage libraries to carefully document which interpretation they implement.\n\n### minlen, maxlen, len\n\n`len()` implies that `min_length <= len(value) <= max_length` - lower and upper bounds are inclusive.\n\nas well as `len()` which can optionally include upper and lower bounds, we also\nprovide `minlen(x)` and `maxlen(y)` which are equivalent to `len(min_length=x)`\nand `len(max_length=y)` respectively.\n\n`len`, `minlen`, and `maxlen` may be used with any type which supports `len(value)`.\n\nexamples of usage:\n\n* `annotated[list, maxlen(10)]` (or `annotated[list, len(max_length=10))`) - list must have a length of 10 or less\n* `annotated[str, maxlen(10)]` - string must have a length of 10 or less\n* `annotated[list, minlen(3))` (or `annotated[list, len(min_length=3))`) - list must have a length of 3 or more\n* `annotated[list, len(4, 6)]` - list must have a length of 4, 5, or 6\n* `annotated[list, len(8, 8)]` - list must have a length of exactly 8\n\n#### changed in v0.4.0\n\n* `min_inclusive` has been renamed to `min_length`, no change in meaning\n* `max_exclusive` has been renamed to `max_length`, upper bound is now **inclusive** instead of **exclusive**\n* the recommendation that slices are interpreted as `len` has been removed due to ambiguity and different semantic\n  meaning of the upper bound in slices vs. `len`\n\nsee [issue #23](https://github.com/annotated-types/annotated-types/issues/23) for discussion.\n\n### timezone\n\n`timezone` can be used with a `datetime` or a `time` to express which timezones\nare allowed. `annotated[datetime, timezone(none)]` must be a naive datetime.\n`timezone[...]` ([literal ellipsis](https://docs.python.org/3/library/constants.html#ellipsis))\nexpresses that any timezone-aware datetime is allowed. you may also pass a specific\ntimezone string or `timezone` object such as `timezone(timezone.utc)` or\n`timezone(\"africa/abidjan\")` to express that you only allow a specific timezone,\nthough we note that this is often a symptom of fragile design.\n\n### predicate\n\n`predicate(func: callable)` expresses that `func(value)` is truthy for valid values.\nusers should prefer the statically inspectable metadata above, but if you need\nthe full power and flexibility of arbitrary runtime predicates... here it is.\n\nwe provide a few predefined predicates for common string constraints:\n\n* `islower = predicate(str.islower)`\n* `isupper = predicate(str.isupper)`\n* `isdigit = predicate(str.isdigit)`\n* `isfinite = predicate(math.isfinite)`\n* `isnotfinite = predicate(not(math.isfinite))`\n* `isnan = predicate(math.isnan)`\n* `isnotnan = predicate(not(math.isnan))`\n* `isinfinite = predicate(math.isinf)`\n* `isnotinfinite = predicate(not(math.isinf))`\n\nsome libraries might have special logic to handle known or understandable predicates,\nfor example by checking for `str.isdigit` and using its presence to both call custom\nlogic to enforce digit-only strings, and customise some generated external schema.\nusers are therefore encouraged to avoid indirection like `lambda s: s.lower()`, in\nfavor of introspectable methods such as `str.lower` or `re.compile(\"pattern\").search`.\n\nto enable basic negation of commonly used predicates like `math.isnan` without introducing introspection that makes it impossible for implementers to introspect the predicate we provide a `not` wrapper that simply negates the predicate in an introspectable manner. several of the predicates listed above are created in this manner.\n\nwe do not specify what behaviour should be expected for predicates that raise\nan exception.  for example `annotated[int, predicate(str.isdigit)]` might silently\nskip invalid constraints, or statically raise an error; or it might try calling it\nand then propogate or discard the resulting\n`typeerror: descriptor 'isdigit' for 'str' objects doesn't apply to a 'int' object`\nexception.  we encourage libraries to document the behaviour they choose.\n\n### doc\n\n`doc()` can be used to add documentation information in `annotated`, for function and method parameters, variables, class attributes, return types, and any place where `annotated` can be used.\n\nit expects a value that can be statically analyzed, as the main use case is for static analysis, editors, documentation generators, and similar tools.\n\nit returns a `docinfo` class with a single attribute `documentation` containing the value passed to `doc()`.\n\nthis is the early adopter's alternative form of the [`typing-doc` proposal](https://github.com/tiangolo/fastapi/blob/typing-doc/typing_doc.md).\n\n### integrating downstream types with `groupedmetadata`\n\nimplementers may choose to provide a convenience wrapper that groups multiple pieces of metadata.\nthis can help reduce verbosity and cognitive overhead for users.\nfor example, an implementer like pydantic might provide a `field` or `meta` type that accepts keyword arguments and transforms these into low-level metadata:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import iterator\nfrom annotated_types import groupedmetadata, ge\n\n@dataclass\nclass field(groupedmetadata):\n    ge: int | none = none\n    description: str | none = none\n\n    def __iter__(self) -> iterator[object]:\n        # iterating over a groupedmetadata object should yield annotated-types\n        # constraint metadata objects which describe it as fully as possible,\n        # and may include other unknown objects too.\n        if self.ge is not none:\n            yield ge(self.ge)\n        if self.description is not none:\n            yield description(self.description)\n```\n\nlibraries consuming annotated-types constraints should check for `groupedmetadata` and unpack it by iterating over the object and treating the results as if they had been \"unpacked\" in the `annotated` type.  the same logic should be applied to the [pep 646 `unpack` type](https://peps.python.org/pep-0646/), so that `annotated[t, field(...)]`, `annotated[t, unpack[field(...)]]` and `annotated[t, *field(...)]` are all treated consistently.\n\nlibraries consuming annotated-types should also ignore any metadata they do not recongize that came from unpacking a `groupedmetadata`, just like they ignore unrecognized metadata in `annotated` itself.\n\nour own `annotated_types.interval` class is a `groupedmetadata` which unpacks itself into `gt`, `lt`, etc., so this is not an abstract concern.  similarly, `annotated_types.len` is a `groupedmetadata` which unpacks itself into `minlen` (optionally) and `maxlen`.\n\n### consuming metadata\n\nwe intend to not be prescriptive as to _how_ the metadata and constraints are used, but as an example of how one might parse constraints from types annotations see our [implementation in `test_main.py`](https://github.com/annotated-types/annotated-types/blob/f59cf6d1b5255a0fe359b93896759a180bec30ae/tests/test_main.py#l94-l103).\n\nit is up to the implementer to determine how this metadata is used.\nyou could use the metadata for runtime type checking, for generating schemas or to generate example data, amongst other use cases.\n\n## design & history\n\nthis package was designed at the pycon 2022 sprints by the maintainers of pydantic\nand hypothesis, with the goal of making it as easy as possible for end-users to\nprovide more informative annotations for use by runtime libraries.\n\nit is deliberately minimal, and following pep-593 allows considerable downstream\ndiscretion in what (if anything!) they choose to support. nonetheless, we expect\nthat staying simple and covering _only_ the most common use-cases will give users\nand maintainers the best experience we can. if you'd like more constraints for your\ntypes - follow our lead, by defining them and documenting them downstream!\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "annotated-types",
  "package_url": "https://pypi.org/project/annotated-types/",
  "project_url": "https://pypi.org/project/annotated-types/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/annotated-types/0.6.0/",
  "requires_dist": [
    "typing-extensions>=4.0.0; python_version < '3.9'"
  ],
  "requires_python": ">=3.8",
  "summary": "reusable constraint types to use with typing.annotated",
  "version": "0.6.0",
  "releases": [],
  "developers": [
    "1755071+adriangb@users.noreply.github.com",
    "s@muelcolvin.com",
    "zac@zhd.dev"
  ],
  "kwds": "annotated_types annotations annotated types pyversions",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_annotated_types",
  "homepage": "",
  "release_count": 7,
  "dependency_ids": [
    "pypi_typing_extensions"
  ]
}