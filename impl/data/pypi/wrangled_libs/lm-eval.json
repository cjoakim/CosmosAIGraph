{
  "classifiers": [
    "development status :: 3 - alpha",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# language model evaluation harness\n\n## overview\n\nthis project provides a unified framework to test generative language models on a large number of different evaluation tasks.\n\n**features:**\n- over 60 standard academic benchmarks for llms, with hundreds of subtasks and variants implemented.\n- support for models loaded via [transformers](https://github.com/huggingface/transformers/) (including quantization via [autogptq](https://github.com/panqiwei/autogptq)), [gpt-neox](https://github.com/eleutherai/gpt-neox), and [megatron-deepspeed](https://github.com/microsoft/megatron-deepspeed/), with a flexible tokenization-agnostic interface.\n- support for commercial apis including [openai](https://openai.com), [goose.ai](https://goose.ai), and [textsynth](https://textsynth.com/).\n- support for evaluation on adapters (e.g. lora) supported in [huggingface's peft library](https://github.com/huggingface/peft).\n- support for local models and benchmarks.\n- evaluation with publicly available prompts ensures reproducibility and comparability between papers.\n- easy support for custom prompts and evaluation metrics.\n\nthe language model evaluation harness is the backend for \ud83e\udd17 hugging face's popular [open llm leaderboard](https://huggingface.co/spaces/huggingfaceh4/open_llm_leaderboard), has been used in [hundreds of papers](https://scholar.google.com/scholar?oi=bibs&hl=en&authuser=2&cites=15052937328817631261,4097184744846514103,17476825572045927382,18443729326628441434,12854182577605049984) is used internally by dozens of companies including nvidia, cohere, nous research, booz allen hamilton, and mosaic ml.\n\n## install\n\nto install the `lm-eval` package from the github repository, run:\n\n```bash\ngit clone https://github.com/eleutherai/lm-evaluation-harness\ncd lm-evaluation-harness\npip install -e .\n```\n\nwe also provide a number of optional dependencies for . extras can be installed via `pip install -e \".[name]\"`\n\n| name          | use                                   |\n| ------------- | ------------------------------------- |\n| anthropic     | for using anthropic's models          |\n| dev           | you probably don't want to use this   |\n| gptq          | for loading models with gptq          |\n| testing       | you probably don't want to use this   |\n| multilingual  | for multilingual tokenizers           |\n| openai        | for using openai's models             |\n| promptsource  | for using promtsource prompts         |\n| sentencepiece | for using the sentencepiece tokenizer |\n| vllm          | for loading models with vllm          |\n| all           | loads all extras                      |\n\n## basic usage\n\n### hugging face `transformers`\n\nto evaluate a model hosted on the [huggingface hub](https://huggingface.co/models) (e.g. gpt-j-6b) on `hellaswag` you can use the following command:\n\n```bash\nlm_eval --model hf \\\n    --model_args pretrained=eleutherai/gpt-j-6b \\\n    --tasks hellaswag \\\n    --device cuda:0 \\\n    --batch_size 8\n```\n\nadditional arguments can be provided to the model constructor using the `--model_args` flag. most notably, this supports the common practice of using the `revisions` feature on the hub to store partially trained checkpoints, or to specify the datatype for running a model:\n\n```bash\nlm_eval --model hf \\\n    --model_args pretrained=eleutherai/pythia-160m,revision=step100000,dtype=\"float\" \\\n    --tasks lambada_openai,hellaswag \\\n    --device cuda:0 \\\n    --batch_size 8\n```\n\nmodels that are loaded via both `transformers.automodelforcausallm` (autoregressive, decoder-only gpt style models) and `transformers.automodelforseq2seqlm` (such as encoder-decoder models like t5) in huggingface are supporteded.\n\nbatch size selection can be automated by setting the  ```--batch_size``` flag to ```auto```. this will perform automatic detection of the largest batch size that will fit on your device. on tasks where there is a large difference between the longest and shortest example, it can be helpful to periodically recompute the largest batch size, to gain a further speedup. to do this, append ```:n``` to above flag to automatically recompute the largest batch size ```n``` times. for example, to recompute the batch size 4 times, the command would be:\n\n```bash\nlm_eval --model hf \\\n    --model_args pretrained=eleutherai/pythia-160m,revision=step100000,dtype=\"float\" \\\n    --tasks lambada_openai,hellaswag \\\n    --device cuda:0 \\\n    --batch_size auto:4\n```\n\nalternatively, you can use `lm-eval` instead of `lm_eval`.\n\n> [!note]\n> just like you can provide a local path to `transformers.automodel`, you can also provide a local path to `lm_eval` via `--model_args pretrained=/path/to/model`\n\n#### multi-gpu evaluation with hugging face `accelerate`\n\nto parallelize evaluation of huggingface models across multiple gpus, we leverage the [accelerate \ud83d\ude80](https://github.com/huggingface/accelerate) library as follows:\n\n```\naccelerate launch -m lm_eval --model hf \\\n    --tasks lambada_openai,arc_easy \\\n    --batch_size 16\n```\n\nthis will perform *data-parallel evaluation*: that is, placing a **single full copy** of your model onto each available gpu and *splitting batches across gpus* to evaluate on k gpus k times faster than on one.\n\nif your model is *is too large to be run on a single one of your gpus* then you can use `accelerate` with fully sharded data parallel (fsdp) that splits the weights of the model across your data parallel ranks. to enable this, ensure you select `yes` when asked ```do you want to use fullyshardeddataparallel?``` when running `accelerate config`. to enable memory-efficient loading, select `yes` when asked `do you want each individually wrapped fsdp unit to broadcast module parameters from rank 0 at the start?`. this will ensure only the rank 0 process loads the model and then broadcasts the parameters to the other ranks instead of having each rank load all parameters which can lead to large ram usage spikes around the start of the script that may cause errors.\n\nto pass even more advanced keyword arguments to `accelerate`, we allow for the following arguments as well:\n- `device_map_option`: how to split model weights across available gpus. defaults to \"auto\".\n- `max_memory_per_gpu`: the max gpu memory to use per gpu in loading the model.\n- `max_cpu_memory`: the max amount of cpu memory to use when offloading the model weights to ram.\n- `offload_folder`: a folder where model weights will be offloaded to disk if needed.\n\nto use `accelerate` with the `lm-eval` command, use\n```\naccelerate launch --no_python lm-eval --model ...\n```\n\n### tensor parallel + optimized inference with vllm\n\nwe also support vllm for faster inference on [supported model types](https://docs.vllm.ai/en/latest/models/supported_models.html).\n\n```bash\nlm_eval --model vllm \\\n    --model_args pretrained={model_name},tensor_parallel_size={number of gpus to use},dtype=auto,gpu_memory_utilization=0.8 \\\n    --tasks lambada_openai \\\n    --batch_size auto\n```\nfor a full list of supported vllm configurations, please reference our vllm integration and the vllm documentation.\n\n### model apis and inference servers\n\nour library also supports the evaluation of models served via several commercial apis, and we hope to implement support for the most commonly used performant local/self-hosted inference servers.\n\nto call a hosted model, use:\n\n```bash\nexport openai_api_secret_key=your_key_here\nlm_eval --model openai-completions \\\n    --model_args engine=davinci \\\n    --tasks lambada_openai,hellaswag\n```\n\nnote that for externally hosted models, configs such as `--device` and `--batch_size` should not be used and do not function. just like you can use `--model_args` to pass arbitrary arguments to the model constructor for local models, you can use it to pass arbitrary arguments to the model api for hosted models. see the documentation of the hosting service for information on what arguments they support.\n\n\n| api or inference server     | implemented?                    | `--model <xxx>` name                                                             | models supported:                                                                             | request types:                                           |\n|-----------------------------|---------------------------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|----------------------------------------------------------|\n| openai completions          | :heavy_check_mark:              | `openai`, `openai-completions`, `gooseai`                                        | up to `code-davinci-002`                                                                      | `generate_until`, `loglikelihood`, `loglikelihood_rolling` |\n| openai chatcompletions      | :x: not yet - needs testing!       | n/a                                                                              | [all chatcompletions api models](https://platform.openai.com/docs/guides/gpt)                 | `generate_until` (no logprobs)                             |\n| anthropic                   | :heavy_check_mark:              | `anthropic`                                                                      | [supported anthropic engines](https://docs.anthropic.com/claude/reference/selecting-a-model)  | `generate_until` (no logprobs)                             |\n| gooseai                     | :heavy_check_mark: (not separately maintained)  | `openai`, `openai-completions`, `gooseai` (same interface as openai completions) |                                                                                               | `generate_until`, `loglikelihood`, `loglikelihood_rolling` |\n| textsynth                   | :heavy_check_mark:                   | `textsynth`                                                                      | [all supported engines](https://textsynth.com/documentation.html#engines)                                                                                           | `generate_until`, `loglikelihood`, `loglikelihood_rolling` |\n| cohere                      | [:hourglass: - blocked on cohere api bug](https://github.com/eleutherai/lm-evaluation-harness/pull/395) | n/a                                                                              | [all `cohere.generate()` engines](https://docs.cohere.com/docs/models)                        | `generate_until`, `loglikelihood`, `loglikelihood_rolling` |\n| [llama.cpp](https://github.com/ggerganov/llama.cpp) (via [llama-cpp-python](https://github.com/abetlen/llama-cpp-python))                        | :heavy_check_mark:              | `gguf`, `ggml`                                                                   | [all models supported by llama.cpp](https://github.com/ggerganov/llama.cpp)               | `generate_until`, `loglikelihood`, `loglikelihood_rolling` |\n| vllm                        | :heavy_check_mark:       | `vllm`                                                                           | [most hf causal language models](https://docs.vllm.ai/en/latest/models/supported_models.html) | `generate_until`, `loglikelihood`, `loglikelihood_rolling`                             |\n| your inference server here! | ...                             | ...                                                                              | ...                                                                                           | ...                                                      |                                | ...                                                      |\n\nit is on our roadmap to create task variants designed to enable models which do not serve logprobs/loglikelihoods to be compared with generation performance of open-source models.\n\n### other frameworks\n\na number of other libraries contain scripts for calling the eval harness through their library. these include [gpt-neox](https://github.com/eleutherai/gpt-neox/blob/main/eval_tasks/eval_adapter.py), [megatron-deepspeed](https://github.com/microsoft/megatron-deepspeed/blob/main/examples/moe/readme_evalharness.md), and [mesh-transformer-jax](https://github.com/kingoflolz/mesh-transformer-jax/blob/master/eval_harness.py).\n\n### additional features\n\nif you have a metal compatible mac, you can run the eval harness using the mps back-end by replacing `--device cuda:0` with `--device mps` (requires pytorch version 2.1 or higher).\n\n> [!note]\n> you can inspect what the lm inputs look like by running the following command:\n>\n> ```bash\n> python write_out.py \\\n>     --tasks all_tasks \\\n>     --num_fewshot 5 \\\n>     --num_examples 10 \\\n>     --output_base_path /path/to/output/folder\n> ```\n>\n> this will write out one text file for each task.\n\nto verify the data integrity of the tasks you're performing in addition to running the tasks themselves, you can use the `--check_integrity` flag:\n\n```bash\nlm_eval --model openai \\\n    --model_args engine=davinci \\\n    --tasks lambada_openai,hellaswag \\\n    --check_integrity\n```\n\n## advanced usage tips\n\nfor models loaded with the huggingface  `transformers` library, any arguments provided via `--model_args` get passed to the relevant constructor directly. this means that anything you can do with `automodel` can be done with our library. for example, you can pass a local path via `pretrained=` or use models finetuned with [peft](https://github.com/huggingface/peft) by taking the call you would run to evaluate the base model and add `,peft=path` to the `model_args` argument:\n```bash\nlm_eval --model hf \\\n    --model_args pretrained=eleutherai/gpt-j-6b,parallelize=true,load_in_4bit=true,peft=nomic-ai/gpt4all-j-lora \\\n    --tasks openbookqa,arc_easy,winogrande,hellaswag,arc_challenge,piqa,boolq \\\n    --device cuda:0\n```\n\n[gptq](https://github.com/panqiwei/autogptq) quantized models can be loaded by specifying their file names in `,gptq=name` (or `,gptq=true` for default names) in the `model_args` argument:\n\n```bash\nlm_eval --model hf \\\n    --model_args pretrained=model-name-or-path,gptq=model.safetensors,gptq_use_triton=true \\\n    --tasks hellaswag\n```\n\nwe support wildcards in task names, for example you can run all of the machine-translated lambada tasks via `--task lambada_openai_mt_*`.\n\nto save evaluation results provide an `--output_path`. we also support logging model responses with the `--log_samples` flag for post-hoc analysis.\n\nadditionally, one can provide a directory with `--use_cache` to cache the results of prior runs. this allows you to avoid repeated execution of the same (model, task) pairs for re-scoring.\n\nfor a full list of supported arguments, check out the [interface](https://github.com/eleutherai/lm-evaluation-harness/blob/big-refactor/docs/interface.md) guide in our documentation!\n\n## how to contribute or learn more?\n\nfor more information on the library and how everything fits together, check out all of our [documentation pages](https://github.com/eleutherai/lm-evaluation-harness/tree/big-refactor/docs)! we plan to post a larger roadmap of desired + planned library improvements soon, with more information on how contributors can help.\n\nyou can also ask for help, or discuss new features with the maintainers in the #lm-thunderdome channel of the eleutherai discord! if you've used the library and have had a positive (or negative) experience, we'd love to hear from you!\n\n### implementing new tasks\n\nto implement a new task in the eval harness, see [this guide](./docs/new_task_guide.md).\n\nin general, we following the following priority list for addressing concerns about prompting and other eval details:\n1. if there is widespread agreement among people who train llms, use the agreed upon procedure.\n2. if there is a clear and unambiguous official implementation, use that procedure.\n3. if there is widespread agreement among people who evaluate llms, use the agreed upon procedure.\n4. if there are multiple common implementations but not universal or widespread agreement, use our preferred option among the common implementations. as before, prioritize choosing from among the implementations found in llm training papers.\n\nthese are guidelines and not rules, and can be overruled in special circumstances.\n\nwe try to prioritize agreement with the procedures used by other groups to decrease the harm when people inevitably compare runs across different papers despite our discouragement of the practice. historically, we also prioritized the implementation from \"language models are few shot learners\" as our original goal was specifically to compare results with that paper.\n\n### support\n\nthe best way to get support is to open an issue on this repo or join the eleutherai discord server](https://discord.gg/eleutherai). the `#lm-thunderdome` channel is dedicated to developing this project and the `#release-discussion` channel is for receiving support for our releases.\n\n## cite as\n\n```\n@misc{eval-harness,\n  author       = {gao, leo and tow, jonathan and abbasi, baber and biderman, stella and black, sid and dipofi, anthony and foster, charles and golding, laurence and hsu, jeffrey and le noac'h, alain and li, haonan and mcdonell, kyle and muennighoff, niklas and ociepa, chris and phang, jason and reynolds, laria and schoelkopf, hailey and skowron, aviya and sutawika, lintang and tang, eric and thite, anish and wang, ben and wang, kevin and zou, andy},\n  title        = {a framework for few-shot language model evaluation},\n  month        = sep,\n  year         = 2021,\n  publisher    = {zenodo},\n  version      = {v0.0.1},\n  doi          = {10.5281/zenodo.5371628},\n  url          = {https://doi.org/10.5281/zenodo.5371628}\n}\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "lm-eval",
  "package_url": "https://pypi.org/project/lm-eval/",
  "project_url": "https://pypi.org/project/lm-eval/",
  "project_urls": {
    "Homepage": "https://github.com/EleutherAI/lm-evaluation-harness",
    "Repository": "https://github.com/EleutherAI/lm-evaluation-harness"
  },
  "release_url": "https://pypi.org/project/lm-eval/0.4.0/",
  "requires_dist": [
    "accelerate>=0.21.0",
    "evaluate",
    "datasets>=2.0.0",
    "evaluate>=0.4.0",
    "jsonlines",
    "numexpr",
    "peft>=0.2.0",
    "pybind11>=2.6.2",
    "pytablewriter",
    "rouge-score>=0.0.4",
    "sacrebleu>=1.5.0",
    "scikit-learn>=0.24.1",
    "sqlitedict",
    "torch>=1.8",
    "tqdm-multiprocess",
    "transformers>=4.1",
    "zstandard",
    "black; extra == \"dev\"",
    "flake8; extra == \"dev\"",
    "pre-commit; extra == \"dev\"",
    "pytest; extra == \"dev\"",
    "pytest-cov; extra == \"dev\"",
    "flake8; extra == \"linting\"",
    "pylint; extra == \"linting\"",
    "mypy; extra == \"linting\"",
    "pre-commit; extra == \"linting\"",
    "pytest; extra == \"testing\"",
    "pytest-cov; extra == \"testing\"",
    "pytest-xdist; extra == \"testing\"",
    "nagisa>=0.2.7; extra == \"multilingual\"",
    "jieba>=0.42.1; extra == \"multilingual\"",
    "pycountry; extra == \"multilingual\"",
    "sympy>=1.12; extra == \"math\"",
    "antlr4-python3-runtime==4.11; extra == \"math\"",
    "sentencepiece>=0.1.98; extra == \"sentencepiece\"",
    "protobuf>=4.22.1; extra == \"sentencepiece\"",
    "promptsource>=0.2.3; extra == \"promptsource\"",
    "auto-gptq[triton]>=0.6.0; extra == \"gptq\"",
    "anthropic; extra == \"anthropic\"",
    "openai>=1.3.5; extra == \"openai\"",
    "tiktoken; extra == \"openai\"",
    "vllm; extra == \"vllm\"",
    "lm_eval[dev]; extra == \"all\"",
    "lm_eval[testing]; extra == \"all\"",
    "lm_eval[linting]; extra == \"all\"",
    "lm_eval[multilingual]; extra == \"all\"",
    "lm_eval[sentencepiece]; extra == \"all\"",
    "lm_eval[promptsource]; extra == \"all\"",
    "lm_eval[gptq]; extra == \"all\"",
    "lm_eval[anthropic]; extra == \"all\"",
    "lm_eval[openai]; extra == \"all\"",
    "lm_eval[vllm]; extra == \"all\""
  ],
  "requires_python": ">=3.8",
  "summary": "a framework for evaluating language models",
  "version": "0.4.0",
  "releases": [],
  "developers": [
    "contact@eleuther.ai"
  ],
  "kwds": "implementations tokenizers apis tokenizer benchmarks",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_lm_eval",
  "homepage": "",
  "release_count": 4,
  "dependency_ids": [
    "pypi_accelerate",
    "pypi_anthropic",
    "pypi_antlr4_python3_runtime",
    "pypi_auto_gptq",
    "pypi_black",
    "pypi_datasets",
    "pypi_evaluate",
    "pypi_flake8",
    "pypi_jieba",
    "pypi_jsonlines",
    "pypi_lm_eval",
    "pypi_mypy",
    "pypi_nagisa",
    "pypi_numexpr",
    "pypi_openai",
    "pypi_peft",
    "pypi_pre_commit",
    "pypi_promptsource",
    "pypi_protobuf",
    "pypi_pybind11",
    "pypi_pycountry",
    "pypi_pylint",
    "pypi_pytablewriter",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_xdist",
    "pypi_rouge_score",
    "pypi_sacrebleu",
    "pypi_scikit_learn",
    "pypi_sentencepiece",
    "pypi_sqlitedict",
    "pypi_sympy",
    "pypi_tiktoken",
    "pypi_torch",
    "pypi_tqdm_multiprocess",
    "pypi_transformers",
    "pypi_vllm",
    "pypi_zstandard"
  ]
}