{
  "libtype": "pypi",
  "libname": "array-api-compat",
  "url": "https://data-apis.org/array-api-compat/",
  "html": "<!DOCTYPE html><html lang=\"en-US\">  <head>    <meta charset=\"UTF-8\">    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"><!-- Begin Jekyll SEO tag v2.8.0 --><title>Array API compatibility library | array-api-compat</title><meta name=\"generator\" content=\"Jekyll v3.9.5\" /><meta property=\"og:title\" content=\"Array API compatibility library\" /><meta property=\"og:locale\" content=\"en_US\" /><meta name=\"description\" content=\"Compatibility layer for NumPy to support the Array API\" /><meta property=\"og:description\" content=\"Compatibility layer for NumPy to support the Array API\" /><link rel=\"canonical\" href=\"https://data-apis.org/array-api-compat/\" /><meta property=\"og:url\" content=\"https://data-apis.org/array-api-compat/\" /><meta property=\"og:site_name\" content=\"array-api-compat\" /><meta property=\"og:type\" content=\"website\" /><meta name=\"twitter:card\" content=\"summary\" /><meta property=\"twitter:title\" content=\"Array API compatibility library\" /><script type=\"application/ld+json\">{\"@context\":\"https://schema.org\",\"@type\":\"WebSite\",\"description\":\"Compatibility layer for NumPy to support the Array API\",\"headline\":\"Array API compatibility library\",\"name\":\"array-api-compat\",\"url\":\"https://data-apis.org/array-api-compat/\"}</script><!-- End Jekyll SEO tag -->    <link rel=\"stylesheet\" href=\"/array-api-compat/assets/css/style.css?v=74b7b798244fc0a84404dd14242e246224ec3529\">    <!-- start custom head snippets, customize with your own _includes/head-custom.html file --><!-- Setup Google Analytics --><!-- You can set your favicon here --><!-- link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"/array-api-compat/favicon.ico\" --><!-- end custom head snippets -->  </head>  <body>    <div class=\"container-lg px-3 my-5 markdown-body\">            <h1><a href=\"https://data-apis.org/array-api-compat/\">array-api-compat</a></h1>            <h1 id=\"array-api-compatibility-library\">Array API compatibility library</h1><p>This is a small wrapper around common array libraries that is compatible withthe <a href=\"https://data-apis.org/array-api/latest/\">Array API standard</a>. Currently,NumPy, CuPy, PyTorch, Dask, and JAX are supported. If you want support for other arraylibraries, or if you encounter any issues, please <a href=\"https://github.com/data-apis/array-api-compat/issues\">open anissue</a>.</p><p>Note that some of the functionality in this library is backwards incompatiblewith the corresponding wrapped libraries. The end-goal is to eventually makeeach array library itself fully compatible with the array API, but thisrequires making backwards incompatible changes in many cases, so this willtake some time.</p><p>Currently all libraries here are implemented against the <a href=\"https://data-apis.org/array-api/2022.12/\">2022.12version</a> of the standard.</p><h2 id=\"install\">Install</h2><p><code class=\"language-plaintext highlighter-rouge\">array-api-compat</code> is available on both <a href=\"https://pypi.org/project/array-api-compat/\">PyPI</a></p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>python -m pip install array-api-compat</code></pre></div></div><p>and <a href=\"https://anaconda.org/conda-forge/array-api-compat\">Conda-forge</a></p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>conda install --channel conda-forge array-api-compat</code></pre></div></div><h2 id=\"usage\">Usage</h2><p>The typical usage of this library will be to get the corresponding array APIcompliant namespace from the input arrays using <code class=\"language-plaintext highlighter-rouge\">array_namespace()</code>, like</p><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">your_function</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>    <span class=\"n\">xp</span> <span class=\"o\">=</span> <span class=\"n\">array_api_compat</span><span class=\"p\">.</span><span class=\"n\">array_namespace</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">)</span>    <span class=\"c1\"># Now use xp as the array library namespace</span>    <span class=\"k\">return</span> <span class=\"n\">xp</span><span class=\"p\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">xp</span><span class=\"p\">.</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span></code></pre></div></div><p>If you wish to have library-specific code-paths, you can import thecorresponding wrapped namespace for each library, like</p><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">array_api_compat.numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span></code></pre></div></div><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">array_api_compat.cupy</span> <span class=\"k\">as</span> <span class=\"n\">cp</span></code></pre></div></div><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">array_api_compat.torch</span> <span class=\"k\">as</span> <span class=\"n\">torch</span></code></pre></div></div><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">array_api_compat.dask</span> <span class=\"k\">as</span> <span class=\"n\">da</span></code></pre></div></div><blockquote>  <p>[!NOTE]There is no <code class=\"language-plaintext highlighter-rouge\">array_api_compat.jax</code> submodule. JAX support is containedin JAX itself in the <code class=\"language-plaintext highlighter-rouge\">jax.experimental.array_api</code> module. array-api-compat simplywraps that submodule. The main JAX support in this module consists ofsupporting it in the <a href=\"#helper-functions\">helper functions</a> defined below.</p></blockquote><p>Each will include all the functions from the normal NumPy/CuPy/PyTorch/dask.arraynamespace, except that functions that are part of the array API are wrapped sothat they have the correct array API behavior. In each case, the array objectused will be the same array object from the wrapped library.</p><h2 id=\"difference-between-array_api_compat-and-array_api_strict\">Difference between <code class=\"language-plaintext highlighter-rouge\">array_api_compat</code> and <code class=\"language-plaintext highlighter-rouge\">array_api_strict</code></h2><p><code class=\"language-plaintext highlighter-rouge\">array_api_strict</code> is a strict minimal implementation of the array API standard, formerlyknown as <code class=\"language-plaintext highlighter-rouge\">numpy.array_api</code> (see<a href=\"https://numpy.org/neps/nep-0047-array-api-standard.html\">NEP 47</a>). Forexample, <code class=\"language-plaintext highlighter-rouge\">array_api_strict</code> does not include any functions that are not part ofthe array API specification, and will explicitly disallow behaviors that arenot required by the spec (e.g., <a href=\"https://data-apis.org/array-api/latest/API_specification/type_promotion.html\">cross-kind typepromotions</a>).(<code class=\"language-plaintext highlighter-rouge\">cupy.array_api</code> is similar to <code class=\"language-plaintext highlighter-rouge\">array_api_strict</code>)</p><p><code class=\"language-plaintext highlighter-rouge\">array_api_compat</code>, on the other hand, is just an extension of thecorresponding array library namespaces with changes needed to be compliantwith the array API. It includes all additional library functions not mentionedin the spec, and allows any library behaviors not explicitly disallowed by it,such as cross-kind casting.</p><p>In particular, unlike <code class=\"language-plaintext highlighter-rouge\">array_api_strict</code>, this package does not use a separate<code class=\"language-plaintext highlighter-rouge\">Array</code> object, but rather just uses the corresponding array library arrayobjects (<code class=\"language-plaintext highlighter-rouge\">numpy.ndarray</code>, <code class=\"language-plaintext highlighter-rouge\">cupy.ndarray</code>, <code class=\"language-plaintext highlighter-rouge\">torch.Tensor</code>, etc.) directly. Thisis because those are the objects that are going to be passed as inputs tofunctions by end users. This does mean that a few behaviors cannot be wrapped(see below), but most of the array API functional, so this does not affectmost things.</p><p>Array consuming library authors coding against the array API may wish to testagainst <code class=\"language-plaintext highlighter-rouge\">array_api_strict</code> to ensure they are not using functionality outsideof the standard, but prefer this implementation for the default behavior forend-users.</p><h2 id=\"helper-functions\">Helper Functions</h2><p>In addition to the wrapped library namespaces and functions in the array APIspecification, there are several helper functions included here that aren\u2019tpart of the specification but which are useful for using the array API:</p><ul>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">is_array_api_obj(x)</code>: Return <code class=\"language-plaintext highlighter-rouge\">True</code> if <code class=\"language-plaintext highlighter-rouge\">x</code> is an array API compatible arrayobject.</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">is_numpy_array(x)</code>, <code class=\"language-plaintext highlighter-rouge\">is_cupy_array(x)</code>, <code class=\"language-plaintext highlighter-rouge\">is_torch_array(x)</code>,<code class=\"language-plaintext highlighter-rouge\">is_dask_array(x)</code>, <code class=\"language-plaintext highlighter-rouge\">is_jax_array(x)</code>: return <code class=\"language-plaintext highlighter-rouge\">True</code> if <code class=\"language-plaintext highlighter-rouge\">x</code> is an array fromthe corresponding library. These functions do not import the underlyinglibrary if it has not already been imported, so they are cheap to use.</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">array_namespace(*xs)</code>: Get the corresponding array API namespace for thearrays <code class=\"language-plaintext highlighter-rouge\">xs</code>. For example, if the arrays are NumPy arrays, the returnednamespace will be <code class=\"language-plaintext highlighter-rouge\">array_api_compat.numpy</code>. Note that this function willalso work for namespaces that aren\u2019t supported by this compat library butwhich do support the array API (i.e., arrays that have the<code class=\"language-plaintext highlighter-rouge\">__array_namespace__</code> attribute).</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">device(x)</code>: Equivalent to<a href=\"https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.device.html\"><code class=\"language-plaintext highlighter-rouge\">x.device</code></a>in the array API specification. Included because <code class=\"language-plaintext highlighter-rouge\">numpy.ndarray</code> does notinclude the <code class=\"language-plaintext highlighter-rouge\">device</code> attribute and this library does not wrap or extend thearray object. Note that for NumPy and dask, <code class=\"language-plaintext highlighter-rouge\">device(x)</code> is always <code class=\"language-plaintext highlighter-rouge\">\"cpu\"</code>.</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">to_device(x, device, /, *, stream=None)</code>: Equivalent to<a href=\"https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.to_device.html\"><code class=\"language-plaintext highlighter-rouge\">x.to_device</code></a>.Included because neither NumPy\u2019s, CuPy\u2019s, Dask\u2019s, nor PyTorch\u2019s array objectsinclude this method. For NumPy, this function effectively does nothing sincethe only supported device is the CPU, but for CuPy, this method supportsCuPy CUDA<a href=\"https://docs.cupy.dev/en/stable/reference/generated/cupy.cuda.Device.html\">Device</a>and<a href=\"https://docs.cupy.dev/en/stable/reference/generated/cupy.cuda.Stream.html\">Stream</a>objects. For PyTorch, this is the same as<a href=\"https://pytorch.org/docs/stable/generated/torch.Tensor.to.html\"><code class=\"language-plaintext highlighter-rouge\">x.to(device)</code></a>(the <code class=\"language-plaintext highlighter-rouge\">stream</code> argument is not supported in PyTorch).</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">size(x)</code>: Equivalent to<a href=\"https://data-apis.org/array-api/latest/API_specification/generated/array_api.array.size.html#array_api.array.size\"><code class=\"language-plaintext highlighter-rouge\">x.size</code></a>,i.e., the number of elements in the array. Included because PyTorch\u2019s<code class=\"language-plaintext highlighter-rouge\">Tensor</code> defines <code class=\"language-plaintext highlighter-rouge\">size</code> as a method which returns the shape, and this cannotbe wrapped because this compat library doesn\u2019t wrap or extend the arrayobjects.</p>  </li></ul><h2 id=\"known-differences-from-the-array-api-specification\">Known Differences from the Array API Specification</h2><p>There are some known differences between this library and the array APIspecification:</p><h3 id=\"numpy-and-cupy\">NumPy and CuPy</h3><ul>  <li>    <p>The array methods <code class=\"language-plaintext highlighter-rouge\">__array_namespace__</code>, <code class=\"language-plaintext highlighter-rouge\">device</code> (for NumPy), <code class=\"language-plaintext highlighter-rouge\">to_device</code>,and <code class=\"language-plaintext highlighter-rouge\">mT</code> are not defined. This reuses <code class=\"language-plaintext highlighter-rouge\">np.ndarray</code> and <code class=\"language-plaintext highlighter-rouge\">cp.ndarray</code> and wedon\u2019t want to monkeypatch or wrap it. The helper functions <code class=\"language-plaintext highlighter-rouge\">device()</code> and<code class=\"language-plaintext highlighter-rouge\">to_device()</code> are provided to work around these missing methods (see above).<code class=\"language-plaintext highlighter-rouge\">x.mT</code> can be replaced with <code class=\"language-plaintext highlighter-rouge\">xp.linalg.matrix_transpose(x)</code>.<code class=\"language-plaintext highlighter-rouge\">array_namespace(x)</code> should be used instead of <code class=\"language-plaintext highlighter-rouge\">x.__array_namespace__</code>.</p>  </li>  <li>    <p>Value-based casting for scalars will be in effect unless explicitly disabledwith the environment variable <code class=\"language-plaintext highlighter-rouge\">NPY_PROMOTION_STATE=weak</code> or<code class=\"language-plaintext highlighter-rouge\">np._set_promotion_state('weak')</code> (requires NumPy 1.24 or newer, see <a href=\"https://numpy.org/neps/nep-0050-scalar-promotion.html\">NEP50</a> andhttps://github.com/numpy/numpy/issues/22341)</p>  </li>  <li>    <p><code class=\"language-plaintext highlighter-rouge\">asarray()</code> does not support <code class=\"language-plaintext highlighter-rouge\">copy=False</code>.</p>  </li>  <li>    <p>Functions which are not wrapped may not have the same type annotationsas the spec.</p>  </li>  <li>    <p>Functions which are not wrapped may not use positional-only arguments.</p>  </li></ul><p>The minimum supported NumPy version is 1.21. However, this older version ofNumPy has a few issues:</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">unique_*</code> will not compare nans as unequal.</li>  <li><code class=\"language-plaintext highlighter-rouge\">finfo()</code> has no <code class=\"language-plaintext highlighter-rouge\">smallest_normal</code>.</li>  <li>No <code class=\"language-plaintext highlighter-rouge\">from_dlpack</code> or <code class=\"language-plaintext highlighter-rouge\">__dlpack__</code>.</li>  <li><code class=\"language-plaintext highlighter-rouge\">argmax()</code> and <code class=\"language-plaintext highlighter-rouge\">argmin()</code> do not have <code class=\"language-plaintext highlighter-rouge\">keepdims</code>.</li>  <li><code class=\"language-plaintext highlighter-rouge\">qr()</code> doesn\u2019t support matrix stacks.</li>  <li><code class=\"language-plaintext highlighter-rouge\">asarray()</code> doesn\u2019t support <code class=\"language-plaintext highlighter-rouge\">copy=True</code> (as noted above, <code class=\"language-plaintext highlighter-rouge\">copy=False</code> is notsupported even in the latest NumPy).</li>  <li>Type promotion behavior will be value based for 0-D arrays (and there is no<code class=\"language-plaintext highlighter-rouge\">NPY_PROMOTION_STATE=weak</code> to disable this).</li></ul><p>If any of these are an issue, it is recommended to bump your minimum NumPyversion.</p><h3 id=\"pytorch\">PyTorch</h3><ul>  <li>    <p>Like NumPy/CuPy, we do not wrap the <code class=\"language-plaintext highlighter-rouge\">torch.Tensor</code> object. It is missing the<code class=\"language-plaintext highlighter-rouge\">__array_namespace__</code> and <code class=\"language-plaintext highlighter-rouge\">to_device</code> methods, so the corresponding helperfunctions <code class=\"language-plaintext highlighter-rouge\">array_namespace()</code> and <code class=\"language-plaintext highlighter-rouge\">to_device()</code> in this library should beused instead (see above).</p>  </li>  <li>    <p>The <code class=\"language-plaintext highlighter-rouge\">x.size</code> attribute on <code class=\"language-plaintext highlighter-rouge\">torch.Tensor</code> is a function that behavesdifferently from<a href=\"https://data-apis.org/array-api/draft/API_specification/generated/array_api.array.size.html\"><code class=\"language-plaintext highlighter-rouge\">x.size</code></a>in the spec. Use the <code class=\"language-plaintext highlighter-rouge\">size(x)</code> helper function as a portable workaround (seeabove).</p>  </li>  <li>    <p>PyTorch does not have unsigned integer types other than <code class=\"language-plaintext highlighter-rouge\">uint8</code>, and noattempt is made to implement them here.</p>  </li>  <li>    <p>PyTorch has type promotion semantics that differ from the array APIspecification for 0-D tensor objects. The array functions in this wrapperlibrary do work around this, but the operators on the Tensor object do not,as no operators or methods on the Tensor object are modified. If this is aconcern, use the functional form instead of the operator form, e.g., <code class=\"language-plaintext highlighter-rouge\">add(x,y)</code> instead of <code class=\"language-plaintext highlighter-rouge\">x + y</code>.</p>  </li>  <li>    <p><a href=\"https://data-apis.org/array-api/latest/API_specification/generated/array_api.unique_all.html#array_api.unique_all\"><code class=\"language-plaintext highlighter-rouge\">unique_all()</code></a>is not implemented, due to the fact that <code class=\"language-plaintext highlighter-rouge\">torch.unique</code> does not supportreturning the <code class=\"language-plaintext highlighter-rouge\">indices</code> array. The other<a href=\"https://data-apis.org/array-api/latest/API_specification/set_functions.html\"><code class=\"language-plaintext highlighter-rouge\">unique_*</code></a>functions are implemented.</p>  </li>  <li>    <p>Slices do not support negative steps.</p>  </li>  <li>    <p><a href=\"https://data-apis.org/array-api/latest/API_specification/generated/array_api.std.html#array_api.std\"><code class=\"language-plaintext highlighter-rouge\">std()</code></a>and<a href=\"https://data-apis.org/array-api/latest/API_specification/generated/array_api.var.html#array_api.var\"><code class=\"language-plaintext highlighter-rouge\">var()</code></a>do not support floating-point <code class=\"language-plaintext highlighter-rouge\">correction</code>.</p>  </li>  <li>    <p>The <code class=\"language-plaintext highlighter-rouge\">stream</code> argument of the <code class=\"language-plaintext highlighter-rouge\">to_device()</code> helper (see above) is notsupported.</p>  </li>  <li>    <p>As with NumPy, type annotations and positional-only arguments may notexactly match the spec for functions that are not wrapped at all.</p>  </li></ul><p>The minimum supported PyTorch version is 1.13.</p><h3 id=\"jax\">JAX</h3><p>Unlike the other libraries supported here, JAX array API support is containedentirely in the JAX library. The JAX array API support is tracked athttps://github.com/google/jax/issues/18353.</p><h2 id=\"dask\">Dask</h2><p>If you\u2019re using dask with numpy, many of the same limitations that apply to numpywill also apply to dask. Besides those differences, other limitations include missingsort functionality (no <code class=\"language-plaintext highlighter-rouge\">sort</code> or <code class=\"language-plaintext highlighter-rouge\">argsort</code>), and limited support for the optional <code class=\"language-plaintext highlighter-rouge\">linalg</code>and <code class=\"language-plaintext highlighter-rouge\">fft</code> extensions.</p><p>In particular, the <code class=\"language-plaintext highlighter-rouge\">fft</code> namespace is not compliant with the array API spec. Any functionsthat you find under the <code class=\"language-plaintext highlighter-rouge\">fft</code> namespace are the original, unwrapped functions under <a href=\"https://docs.dask.org/en/latest/array-api.html#fast-fourier-transforms\"><code class=\"language-plaintext highlighter-rouge\">dask.array.fft</code></a>, which may or may not be Array API compliant. Use at your own risk!</p><p>For <code class=\"language-plaintext highlighter-rouge\">linalg</code>, several methods are missing, for example:</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">cross</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">det</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">eigh</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">eigvalsh</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">matrix_power</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">pinv</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">slogdet</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">matrix_norm</code></li>  <li><code class=\"language-plaintext highlighter-rouge\">matrix_rank</code>Other methods may only be partially implemented or return incorrect results at times.</li></ul><p>The minimum supported Dask version is 2023.12.0.</p><h2 id=\"vendoring\">Vendoring</h2><p>This library supports vendoring as an installation method. To vendor thelibrary, simply copy <code class=\"language-plaintext highlighter-rouge\">array_api_compat</code> into the appropriate place in thelibrary, like</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp -R array_api_compat/ mylib/vendored/array_api_compat</code></pre></div></div><p>You may also rename it to something else if you like (nowhere in the codereferences the name \u201carray_api_compat\u201d).</p><p>Alternatively, the library may be installed as dependency on PyPI.</p><h2 id=\"implementation-notes\">Implementation Notes</h2><p>As noted before, the goal of this library is to reuse the NumPy and CuPy arrayobjects, rather than wrapping or extending them. This means that the functionsneed to accept and return <code class=\"language-plaintext highlighter-rouge\">np.ndarray</code> for NumPy and <code class=\"language-plaintext highlighter-rouge\">cp.ndarray</code> for CuPy.</p><p>Each namespace (<code class=\"language-plaintext highlighter-rouge\">array_api_compat.numpy</code>, <code class=\"language-plaintext highlighter-rouge\">array_api_compat.cupy</code>, and<code class=\"language-plaintext highlighter-rouge\">array_api_compat.torch</code>) is populated with the normal library namespace (like<code class=\"language-plaintext highlighter-rouge\">from numpy import *</code>). Then specific functions are replaced with wrappedvariants.</p><p>Since NumPy and CuPy are nearly identical in behavior, most wrapping logic canbe shared between them. Wrapped functions that have the same logic betweenNumPy and CuPy are in <code class=\"language-plaintext highlighter-rouge\">array_api_compat/common/</code>.These functions are defined like</p><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># In array_api_compat/common/_aliases.py</span><span class=\"k\">def</span> <span class=\"nf\">acos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"n\">xp</span><span class=\"p\">):</span>    <span class=\"k\">return</span> <span class=\"n\">xp</span><span class=\"p\">.</span><span class=\"n\">arccos</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span></code></pre></div></div><p>The <code class=\"language-plaintext highlighter-rouge\">xp</code> argument refers to the original array namespace (either <code class=\"language-plaintext highlighter-rouge\">numpy</code> or<code class=\"language-plaintext highlighter-rouge\">cupy</code>). Then in the specific <code class=\"language-plaintext highlighter-rouge\">array_api_compat/numpy/</code> and<code class=\"language-plaintext highlighter-rouge\">array_api_compat/cupy/</code> namespaces, the <code class=\"language-plaintext highlighter-rouge\">@get_xp</code> decorator is applied tothese functions, which automatically removes the <code class=\"language-plaintext highlighter-rouge\">xp</code> argument from thefunction signature and replaces it with the corresponding array library, like</p><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># In array_api_compat/numpy/_aliases.py</span><span class=\"kn\">from</span> <span class=\"nn\">..common</span> <span class=\"kn\">import</span> <span class=\"n\">_aliases</span><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"n\">np</span><span class=\"n\">acos</span> <span class=\"o\">=</span> <span class=\"n\">get_xp</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"p\">)(</span><span class=\"n\">_aliases</span><span class=\"p\">.</span><span class=\"n\">acos</span><span class=\"p\">)</span></code></pre></div></div><p>This <code class=\"language-plaintext highlighter-rouge\">acos</code> now has the signature <code class=\"language-plaintext highlighter-rouge\">acos(x, /)</code> and calls <code class=\"language-plaintext highlighter-rouge\">numpy.arccos</code>.</p><p>Similarly, for CuPy:</p><div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># In array_api_compat/cupy/_aliases.py</span><span class=\"kn\">from</span> <span class=\"nn\">..common</span> <span class=\"kn\">import</span> <span class=\"n\">_aliases</span><span class=\"kn\">import</span> <span class=\"nn\">cupy</span> <span class=\"k\">as</span> <span class=\"n\">cp</span><span class=\"n\">acos</span> <span class=\"o\">=</span> <span class=\"n\">get_xp</span><span class=\"p\">(</span><span class=\"n\">cp</span><span class=\"p\">)(</span><span class=\"n\">_aliases</span><span class=\"p\">.</span><span class=\"n\">acos</span><span class=\"p\">)</span></code></pre></div></div><p>Since NumPy and CuPy are nearly identical in their behaviors, this allowswriting the wrapping logic for both libraries only once.</p><p>PyTorch uses a similar layout in <code class=\"language-plaintext highlighter-rouge\">array_api_compat/torch/</code>, but it differsenough from NumPy/CuPy that very few common wrappers for those libraries arereused.</p><p>See https://numpy.org/doc/stable/reference/array_api.html for a full list ofchanges from the base NumPy (the differences for CuPy are nearly identical). Acorresponding document does not yet exist for PyTorch, but you can examine thevarious comments in the<a href=\"https://github.com/data-apis/array-api-compat/blob/main/array_api_compat/torch/_aliases.py\">implementation</a>to see what functions and behaviors have been wrapped.</p><h2 id=\"releasing\">Releasing</h2><p>To release, first note that CuPy must be tested manually (it isn\u2019t tested onCI). Use the script</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>./test_cupy.sh</code></pre></div></div><p>on a machine with a CUDA GPU.</p><p>Once you are ready to release, create a PR with a release branch, so that youcan verify that CI is passing. You must edit</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>array_api_compat/__init__.py</code></pre></div></div><p>and update the version (the version is not computed from the tag because thatwould break vendorability). You should also edit</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CHANGELOG.md</code></pre></div></div><p>with the changes for the release.</p><p>Then create a tag</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git tag -a &lt;version&gt;</code></pre></div></div><p>and push it to GitHub</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push origin &lt;version&gt;</code></pre></div></div><p>Check that the <code class=\"language-plaintext highlighter-rouge\">publish distributions</code> action works. Note that this actionwill run even if the other CI fails, so you must make sure that CI is passing<em>before</em> tagging.</p><p>This does mean you can ignore CI failures, but ideally you should fix anyfailures or update the <code class=\"language-plaintext highlighter-rouge\">*-xfails.txt</code> files before tagging, so that CI and thecupy tests pass. Otherwise it will be hard to tell what things are breaking inthe future. It\u2019s also a good idea to remove any xpasses from those files (butbe aware that some xfails are from flaky failures, so unless you know theunderlying issue has been fixed, a xpass test is probably still xfail).</p>            <div class=\"footer border-top border-gray-light mt-5 pt-3 text-right text-gray\">        This site is open source. <a href=\"https://github.com/data-apis/array-api-compat/edit/main/README.md\">Improve this page</a>.      </div>          </div>    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js\" integrity=\"sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=\" crossorigin=\"anonymous\"></script>    <script>anchors.add();</script>  </body></html>",
  "embeddings": []
}