{
  "libtype": "pypi",
  "libname": "dash-ag-grid",
  "url": "https://dash.plotly.com/dash-ag-grid",
  "html": "<!DOCTYPE html><html><head>    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">      <meta charset=\"UTF-8\">      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">    <title>Dash AG Grid | Dash for Python Documentation | Plotly</title>        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">    <meta name=\"description\" content=\"How to install Dash AG Grid, a high-performance and highly customizable component based on AG Grid.\">    <meta name=\"google-site-verification\" content=\"EgLBLquJuqD_NR96F-pKLhTy9ZKQlWIoQlexW_OVKrM\" />    <title>Dash AG Grid | Dash for Python Documentation | Plotly</title>    <link rel=\"icon\" type=\"image/x-icon\" href=\"/assets/favicon.ico?m=1709327477.0\">    <link href=\"https://esm.sh/@markprompt/css@0.18.0?css\" rel=\"stylesheet\" />    <link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/ddk-all.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/bootstrap_build.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/fa-ddk.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/assets/ag-grid-examples-css.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/azure.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/base.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/daq.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/dashbio.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/ddk.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/dosis.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/loading.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/local-css-example.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/markprompt_override.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/open-sans.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/override.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/percy.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/table.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/tabs-styled-with-classes.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/typography.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/docs.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/gallery-style.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/react-resizable.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/report.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/font-awesome/css/fontawesome.min.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/font-awesome/css/solid.min.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/highlight/styles/default.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/highlight/styles/dm-mono.css?m=1709327477.0\">    <!-- Google Tag Manager Tag --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N6T2RXG');</script>    <style type=\"text/css\">.placeholder-content{will-change:transform;animation:placeHolderShimmer 1s linear infinite forwards;-webkit-backface-visibility:hidden;background:#e6e6e6;background:linear-gradient(90deg,#eee 8%,#ddd 18%,#eee 33%);background-size:800px 104px;height:100%;position:relative}.placeholder-content *{color:transparent!important;opacity:0}@keyframes placeHolderShimmer{0%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:-468px 0;opacity:.7}45%{opacity:.8}75%{opacity:1}100%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:468px 0;opacity:.7}}@keyframes placeholderAnimate{0%{background-position:-650px 0}100%{background-position:650px 0}}.preload{position:fixed;top:0;left:0;right:0;bottom:0;transition:all ease .3s;z-index:99999;background-color:#fff}.preload *{box-sizing:border-box}.preload .pre-sidebar{position:absolute;top:0;left:0;bottom:0;width:300px;background-color:#fafafa}.preload .pre-content{position:absolute;top:0;left:300px;bottom:0;right:0;padding:0 0 0 90px;z-index:999;background-color:#fff}.preload .pre-brand{padding:35px 10px 20px 20px;display:flex;align-items:center;justify-content:space-between}.preload .pre-logo{width:100px;height:30px;flex-shrink:0;border-radius:6px}.preload .pre-switch{display:inline-flex !important;justify-content:flex-end;}.preload .pre-switch .pre-dot{flex-shrink:0;width:20px;height:20px;border-radius:20px;margin:0px !important;}.preload .pre-switch .pre-large{width:45px;height:20px;border-radius:20px;flex-shrink:0;margin:0 6px}.preload .pre-search{height:38px;width:223px;margin:10px 0 40px 36px;border-radius:30px}.preload .pre-line{width:100px;height:15px;margin:0 0 30px 30px;border-radius:3px}.preload .pre-line1{width:125px}.preload .pre-line2{width:135px}.preload .pre-line3{width:145px}.preload .pre-line4{width:245px}.preload .pre-line5{width:225px}.preload .pre-line6{width:235px}.preload .pre-line7{width:150px}.preload .pre-line8{width:180px}.preload .pre-line9{width:190px}.preload .pre-line10{width:120px}.preload .pre-menu{padding:20px 20px 0 0;text-align:right}.preload .pre-menu div{width:100px;display:inline-block;height:20px;border-radius:2px;margin:0 0 0 30px}.preload .pre-wrap{max-width:850px}.preload .pre-headline{height:30px;width:400px;margin:100px 0 70px 2px;border-radius:2px}.preload .pre-subhead{height:23px;width:180px;margin:0 0 28px 0;border-radius:2px}.preload .pre-subhead2{margin:70px 0 28px 0}.preload .pre-box-row{display:flex;flex-wrap:wrap;margin:0 -16px}.preload .pre-box-col{width:33.333%;margin:0 0 20px 0;padding:0 16px}.preload .pre-box{height:112px;width:100%;border-radius:2px}</style></head><body>  <div class=\"preload\">    <div class=\"pre-wrap\">      <div class=\"pre-sidebar\">        <div class=\"pre-brand\">          <div class=\"pre-logo placeholder-content\">          </div>        </div>        <div class=\"pre-search placeholder-content\">        </div>        <div class=\"pre-line pre-line1 placeholder-content\">        </div>        <div class=\"pre-line pre-line2 placeholder-content\">        </div>        <div class=\"pre-line pre-line3 placeholder-content\">        </div>        <div class=\"pre-line pre-line4 placeholder-content\">        </div>        <div class=\"pre-line pre-line5 placeholder-content\">        </div>        <div class=\"pre-line pre-line6 placeholder-content\">        </div>        <div class=\"pre-line pre-line7 placeholder-content\">        </div>        <div class=\"pre-line pre-line8 placeholder-content\">        </div>        <div class=\"pre-line pre-line9 placeholder-content\">        </div>        <div class=\"pre-line pre-line10 placeholder-content\">        </div>      </div>      <div class=\"pre-content\">        <div class=\"pre-menu\">          <div class=\" placeholder-content\">          </div>          <div class=\"pre-switch\">            <div class=\"pre-dot placeholder-content\">            </div>            <div class=\"pre-large placeholder-content\">            </div>            <div class=\"pre-dot placeholder-content\">          </div>          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>        </div>        <div class=\"pre-wrap\">          <div class=\"pre-headline placeholder-content\">          </div>          <div class=\"pre-subhead placeholder-content\">          </div>          <div class=\"pre-box-row\">            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>          </div>          <div class=\"pre-subhead pre-subhead2 placeholder-content\">          </div>          <div class=\"pre-box-row\">            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>          </div>        </div>      </div>    </div>  </div>    <!-- Google Tag Manager Tag --><noscript><iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-N6T2RXG\"height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe></noscript>    <div id=\"react-entry-point\">        <div class=\"ssr-dash-core-components-markdown\"><h1 id=\"dash-ag-grid\"><img alt=\"\" src=\"/assets/images/language_icons/python_50px.svg\" /> Dash AG Grid</h1><p>&lt;iframe&gt;<br />&lt;iframe&gt;</p><p>Dash AG Grid is a high-performance and highly customizable component that wraps <a href=\"https://www.ag-grid.com/\">AG Grid</a>,<br />designed for creating rich datagrids.</p><h2 id=\"installation\">Installation</h2><p>To install Dash AG Grid, in your terminal run:</p><pre><code class=\"shell\">pip install dash-ag-grid</code></pre><p>These docs are using Dash AG Grid version 31.0.0, which uses AG Grid version 31.0.3.</p><p>To learn the basics of Dash AG Grid, see the <a href=\"/dash-ag-grid/getting-started\">Getting Started</a><br />guide.</p><h2 id=\"table-of-contents\">Table of Contents</h2><blockquote><p>The first four pages below will help you get started with Dash AG Grid. The remaining pages contain additional<br />examples, with sections broken down by different grid features, for example, columns, rows, and pagination. Many of<br />the examples and explanations come directly from the <a href=\"https://www.ag-grid.com/archive/31.0.3/react-data-grid/\">official AG Grid docs</a> and<br />have been updated to apply to Dash AG Grid. Consult the AG Grid docs for additional explanations and examples that you<br />can convert to use with Dash AG Grid. The AG Grid<br />docs <a href=\"https://github.com/ag-grid/ag-grid/blob/latest/LICENSE.txt\">are MIT licensed</a> and the content is<br />available <a href=\"https://github.com/ag-grid/ag-grid/tree/latest/grid-packages/ag-grid-docs\">here in the AG Grid GitHub repo</a>.</p></blockquote><p><a href=\"/dash-ag-grid/migration-guide\">Migration Guide</a> \u2014 If you&rsquo;ve previously used the Dash Enterprise version of Dash AG Grid (1.x) or the open source versions 2.x, learn how to update your apps to use the 31.x versions.</p><p><a href=\"/dash-ag-grid/getting-started\">Getting Started</a> \u2014 Get up and running with Dash AG Grid and learn the basics of creating grids, including creating and configuring columns and headers, and using grids with callbacks.</p><p><a href=\"/dash-ag-grid/javascript-and-the-grid\">JavaScript and Dash AG Grid</a> \u2014 Learn how to create custom JavaScript functions and components for your grid.</p><p><a href=\"/dash-ag-grid/reference\">Reference</a> \u2014 Reference documentation for Dash AG Grid.</p><h3 id=\"columns\">Columns</h3><p><a href=\"/dash-ag-grid/column-definitions\">Column Definitions</a> \u2014 Column definitions and the different ways to define them for a grid.</p><p><a href=\"/dash-ag-grid/updating-column-definitions\">Updating Column Definitions</a> \u2014 How to update column definitions after they&rsquo;ve been initially set.</p><p><a href=\"/dash-ag-grid/column-state\">Column State</a> \u2014 How to work with the state of columns in a grid.</p><p><a href=\"/dash-ag-grid/column-headers\">Column Headers</a> \u2014 Configuring headers for a column and how to enable sorting and filtering for a column.</p><p><a href=\"/dash-ag-grid/column-groups\">Column Groups</a> \u2014 Having multiple levels of columns in your grid&rsquo;s headers.</p><p><a href=\"/dash-ag-grid/column-sizing\">Column Sizing</a> \u2014 Sizing the grid&rsquo;s columns.</p><p><a href=\"/dash-ag-grid/column-moving\">Column Moving</a> \u2014 Moving the grid&rsquo;s columns, including examples of locking columns and moving animation.</p><p><a href=\"/dash-ag-grid/cell-data-types\">Cell Data Types</a> \u2014 How to use cell data types in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/column-pinning\">Column Pinning</a> \u2014 Pin columns to the left and right and lock pinning.</p><p><a href=\"/dash-ag-grid/column-spanning\">Column Spanning</a> \u2014 Configure the width of columns in the grid.</p><h3 id=\"rows\">Rows</h3><p><a href=\"/dash-ag-grid/row-ids\">Row IDs</a> \u2014 How the grid assigns IDs.</p><p><a href=\"/dash-ag-grid/row-sorting\">Row Sorting</a> \u2014 How to enable and use sorting in the grid.</p><p><a href=\"/dash-ag-grid/row-spanning\">Row Spanning</a> \u2014 Cells spanning multiple rows.</p><p><a href=\"/dash-ag-grid/full-width-rows\">Full Width Rows</a> \u2014 How to create full width rows.</p><p><a href=\"/dash-ag-grid/row-pinning\">Row Pinning</a> \u2014 Pin rows to always appear at the start or end of a grid.</p><p><a href=\"/dash-ag-grid/row-height\">Row Height</a> \u2014 Configure the height of grid rows.</p><p><a href=\"/dash-ag-grid/row-dragging\">Row Dragging</a> \u2014 Rearrange rows in the grid.</p><p><a href=\"/dash-ag-grid/row-dragging-external-dropzone\">Row Dragging - External Dropzone</a> \u2014 Drag and drop rows in an external dropzone (including grid to grid).</p><h3 id=\"layout-and-style\">Layout and Style</h3><p><a href=\"/dash-ag-grid/styling-themes\">Themes</a> \u2014 How to use themes with your grid.</p><p><a href=\"/dash-ag-grid/styling-color-font\">Styling Color and Font</a> \u2014 Update the fonts and colors of text in the grid.</p><p><a href=\"/dash-ag-grid/styling-selections\">Styling Selections</a> \u2014 Control how selected rows and cells appear.</p><p><a href=\"/dash-ag-grid/styling-headers\">Styling Headers</a> \u2014 Style grid header cells and column groups.</p><p><a href=\"/dash-ag-grid/styling-borders\">Styling Borders</a> \u2014 Control the style of borders around rows, cells and UI elements.</p><p><a href=\"/dash-ag-grid/compactness\">Compactness</a> \u2014 Add more white space or pack more data into the UI.</p><p><a href=\"/dash-ag-grid/custom-icons-global\">Custom Icons at Global Level</a> \u2014 Provide custom icons at global level.</p><p><a href=\"/dash-ag-grid/styling-inputs\">Styling Inputs and Widgets</a> \u2014 Styling text inputs, checkboxes, toggle buttons and range sliders.</p><p><a href=\"/dash-ag-grid/styling-popups\">Styling Menus and Popups</a> \u2014 Style UI elements that float above the main UI, including menus.</p><p><a href=\"/dash-ag-grid/styling-rows\">Styling Rows</a> \u2014 Styling the grid&rsquo;s rows, including conditional styling.</p><p><a href=\"/dash-ag-grid/styling-cells\">Styling Cells</a> \u2014 Styling cells, including conditional styling.</p><p><a href=\"/dash-ag-grid/custom-icons-grid\">Custom Icons at Grid and Column Level</a> \u2014 Provide custom icons at grid/column level.</p><p><a href=\"/dash-ag-grid/grid-size\">Grid Size</a> \u2014 Configuring the size of the grid.</p><p><a href=\"/dash-ag-grid/printing\">Printing</a> \u2014 Use the grid&rsquo;s print layout feature to create printer-friendly grids.</p><h3 id=\"clientserver-side-data\">Client/Server-Side Data</h3><p><a href=\"/dash-ag-grid/row-models\">Row Model Overview</a> \u2014 An overview of row models.</p><p><a href=\"/dash-ag-grid/client-side\">Client-Side Row Model</a> \u2014 Client-Side row model in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/infinite-row-model\">Infinite Row Model (Server-Side)</a> \u2014 Using the grid&rsquo;s infinite row model.</p><h3 id=\"selection\">Selection</h3><p><a href=\"/dash-ag-grid/cell-selection\">Cell Selection</a> \u2014 Trigger callbacks by clicking on a cell and disable cell focus.</p><p><a href=\"/dash-ag-grid/text-selection\">Cell Text Selection</a> \u2014 Enabling regular text selection.</p><p><a href=\"/dash-ag-grid/row-selection\">Row Selection</a> \u2014 Row selections in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/checkbox-row-selection\">Row Selection With Checkboxes</a> \u2014 Adding checkboxes to a grid for row selection.</p><h3 id=\"filtering\">Filtering</h3><p><a href=\"/dash-ag-grid/filtering-overview\">Filtering Overview</a> \u2014 Overview of filtering in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/column-filters\">Column Filters - Overview</a> \u2014 Filters applied to a grid&rsquo;s data at the column level.</p><p><a href=\"/dash-ag-grid/text-filters\">Column Filters - Text Filters</a> \u2014 Filter string values.</p><p><a href=\"/dash-ag-grid/number-filters\">Column Filters - Number Filters</a> \u2014 Filter number values.</p><p><a href=\"/dash-ag-grid/date-filters\">Column Filters - Date Filters</a> \u2014 Filter date values.</p><p><a href=\"/dash-ag-grid/filter-conditions\">Column Filters - Filter Conditions</a> \u2014 Filter Conditions in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/applying-filters\">Column Filters - Applying Filters</a> \u2014 Applying Filters in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/floating-filters\">Column Filters - Floating Filters</a> \u2014 Filters that appear under the column headers.</p><p><a href=\"/dash-ag-grid/callback-filters\">Filter Model &amp; Dash Callbacks</a> \u2014 Capturing the state of filters to use in a Dash callback.</p><p><a href=\"/dash-ag-grid/quick-filters\">Quick Filters</a> \u2014 Apply a quick filter that filters across the row.</p><p><a href=\"/dash-ag-grid/external-filter\">External Filter</a> \u2014 Apply an external filter that filters across the row.</p><h3 id=\"rendering\">Rendering</h3><p><a href=\"/dash-ag-grid/change-cell-renderers\">Change Cell Renderers</a> \u2014 Cell renderers for animating changes to data.</p><p><a href=\"/dash-ag-grid/checkbox-cell-renderer\">Checkbox Cell Renderer</a> \u2014 Checkbox renderer in Dash AG Grid.</p><p><a href=\"/dash-ag-grid/value-getters\">Value Getters</a> \u2014 Use value getters as an alternative to field columns to get data.</p><p><a href=\"/dash-ag-grid/value-formatters\">Value Formatters</a> \u2014 Customize how values are displayed.</p><p><a href=\"/dash-ag-grid/d3-value-formatters\">D3 Value Formatters</a> \u2014 Use the <code>d3-format</code> library for formatting values.</p><p><a href=\"/dash-ag-grid/custom-functions-value-formatters\">Custom Function Value Formatters</a> \u2014 Creating your own functions to format values.</p><h3 id=\"editing\">Editing</h3><p><a href=\"/dash-ag-grid/cell-editing\">Cell Editing</a> \u2014 Enabling cell editing for a column.</p><p><a href=\"/dash-ag-grid/editing-and-callbacks\">Editing and Callbacks</a> \u2014 Access edited data in a callback.</p><p><a href=\"/dash-ag-grid/start-stop-editing\">Start/Stop Cell Editing</a> \u2014 Different ways that cell editing can be started and stopped.</p><p><a href=\"/dash-ag-grid/parsing-values\">Parsing Values</a> \u2014 Parsing values after editing.</p><p><a href=\"/dash-ag-grid/saving-values\">Saving Values</a> \u2014 Value Setters provides an alternative to using field for setting the data.</p><p><a href=\"/dash-ag-grid/cell-editors\">Cell Editors</a> \u2014 Add cell editors within cells to take care of edit operations.</p><p><a href=\"/dash-ag-grid/provided-cell-editors\">Provided Cell Editors</a> \u2014 Cell editors available to use with the grid.</p><p><a href=\"/dash-ag-grid/undo-redo-edits\">Undo and Redo Cell Edits</a> \u2014 Allow users to undo / redo their cell edits.</p><p><a href=\"/dash-ag-grid/editing-full-row\">Full Row Editing</a> \u2014 Make all cells in a row editable at the same time.</p><h3 id=\"import-and-export\">Import and Export</h3><p><a href=\"/dash-ag-grid/export-data-csv\">Export Data to CSV</a> \u2014 Export grid data to a CSV file.</p><p><a href=\"/dash-ag-grid/clipboard\">Copying to the Clipboard</a> \u2014 Copying from the grid using <code>dcc.Clipboard</code> and regular text selection.</p><h3 id=\"components\">Components</h3><p><a href=\"/dash-ag-grid/cell-renderer-components\">Cell Renderer Components</a> \u2014 Use cell renderers to render something other than a string in a grid cell.</p><p><a href=\"/dash-ag-grid/markdown-component\">Markdown Component</a> \u2014 Use the Markdown component included with Dash AG Grid.</p><p><a href=\"/dash-ag-grid/cell-editor-components\">Cell Editor Components</a> \u2014 Use custom components as cell editors.</p><p><a href=\"/dash-ag-grid/many-renderer-components\">Many Renderer Components One Column</a> \u2014 Use different renderers for different rows in the same column.</p><p><a href=\"/dash-ag-grid/row-menu\">Row Menu</a> \u2014 Use the Row Menu component included with Dash AG Grid.</p><p><a href=\"/dash-ag-grid/tooltips\">Tooltips</a> \u2014 Add tooltips to column headers and cells.</p><p><a href=\"/dash-ag-grid/overlay-component\">Overlay Component</a> \u2014 Provide custom loading messages to the grid.</p><h3 id=\"scrolling-and-pagination\">Scrolling and Pagination</h3><p><a href=\"/dash-ag-grid/pagination\">Pagination</a> \u2014 Set a grid to use pagination instead of vertical scroll.</p><p><a href=\"/dash-ag-grid/aligned-grids\">Aligned Grids</a> \u2014 Align the columns in two or more grids.</p><p><a href=\"/dash-ag-grid/infinite-scroll\">Infinite Scroll</a> \u2014 Lazy-load rows in the grid using infinite scroll.</p><p><a href=\"/dash-ag-grid/scrolling-performance\">Scrolling Performance</a> \u2014 Improve The Grid Scrolling Performance.</p><p><a href=\"/dash-ag-grid/scroll-to\">Scroll To</a> \u2014 Scroll to a specific position in the grid.</p><h3 id=\"persistence\">Persistence</h3><p><a href=\"/dash-ag-grid/persistence\">Persistence</a> \u2014 Persist selected rows and filters when a page is refreshed.</p><h3 id=\"enterprise\">Enterprise</h3><p><a href=\"/dash-ag-grid/enterprise-ag-grid\">Using AG Grid Enterprise</a> \u2014 Using an AG Grid license key with Dash AG Grid for enterprise features.</p><p><a href=\"/dash-ag-grid/enterprise-sparklines\">Sparklines</a> \u2014 Mini charts you can add to your grid.</p><p><a href=\"/dash-ag-grid/enterprise-master-detail\">Master Detail</a> \u2014 Expandable rows for your grid.</p><p><a href=\"/dash-ag-grid/enterprise-group-cell-renderer\">Group Cell Renderer</a> \u2014 Configuring group cell renderers for your grid.</p><p><a href=\"/dash-ag-grid/enterprise-row-aggregation\">Row Aggregation with Conditional Formatting</a> \u2014 Apply row aggregation with conditional formatting to your grid.</p><p><a href=\"/dash-ag-grid/enterprise-aggregation-custom-functions\">Aggregation with Custom Functions</a> \u2014 Write custom functions to use with your grid.</p><p><a href=\"/dash-ag-grid/enterprise-row-grouping\">Row Groupings</a> \u2014 Configuring row grouping for your grid.</p><p><a href=\"/dash-ag-grid/enterprise-sidebar\">Sidebar</a> \u2014 Add a sidebar with columns and/or filters to your grid.</p><p><a href=\"/dash-ag-grid/enterprise-pivot\">Pivot</a> \u2014 Turn a column&rsquo;s values into columns with pivot.</p><p><a href=\"/dash-ag-grid/enterprise-tree-data\">Tree Data</a> \u2014  Display data with parent-child relationships.</p><p><a href=\"dash-ag-grid/enterprise-set-filter-overview\">Set Filter -  Overview</a> \u2014 Enabling Set Filter which works like Excel, providing checkboxes to select values from a set.</p><p><a href=\"/dash-ag-grid/enterprise-set-filter-list\">Set Filter - Filter List</a> \u2014  Manage the Set Filter List values through custom sorting and formatting.</p><p><a href=\"/dash-ag-grid/enterprise-set-filter-data-updates\">Set Filter -  Data Updates</a> \u2014 Describes how changing data through Cell Editing and the application Updating Data impacts the Set Filter&rsquo;s values.</p><p><a href=\"/dash-ag-grid/enterprise-set-filter-excel-mode\"> Set Filter - Excel Mode</a> \u2014 How to enable Excel Mode to provide your users with an Excel-like experience with Set Filters.</p><h3 id=\"more-examples\">More Examples</h3><p><a href=\"/dash-ag-grid/virtual-row-data\">Virtual Row Data</a> \u2014 Get Virtual Row Data.</p><p><a href=\"/dash-ag-grid/crossfilter\">Crossfilter</a> \u2014 Crossfilter between Grid and Plots.</p></div>    </div>    <footer>        <script id=\"_dash-config\" type=\"application/json\">{\"url_base_pathname\":null,\"requests_pathname_prefix\":\"\\u002f\",\"ui\":false,\"props_check\":false,\"show_undo_redo\":false,\"suppress_callback_exceptions\":true,\"update_title\":null,\"children_props\":{\"dash_core_components\":{\"Checklist\":[\"options[].label\"],\"Clipboard\":[],\"ConfirmDialog\":[],\"ConfirmDialogProvider\":[],\"DatePickerRange\":[],\"DatePickerSingle\":[],\"Download\":[],\"Dropdown\":[\"options[].label\"],\"Geolocation\":[],\"Graph\":[],\"Input\":[],\"Interval\":[],\"Link\":[],\"Loading\":[],\"Location\":[],\"LogoutButton\":[],\"Markdown\":[],\"RadioItems\":[\"options[].label\"],\"RangeSlider\":[],\"Slider\":[],\"Store\":[],\"Tab\":[],\"Tabs\":[],\"Textarea\":[],\"Tooltip\":[],\"Upload\":[]},\"dash_html_components\":{\"A\":[],\"Abbr\":[],\"Acronym\":[],\"Address\":[],\"Area\":[],\"Article\":[],\"Aside\":[],\"Audio\":[],\"B\":[],\"Base\":[],\"Basefont\":[],\"Bdi\":[],\"Bdo\":[],\"Big\":[],\"Blink\":[],\"Blockquote\":[],\"Br\":[],\"Button\":[],\"Canvas\":[],\"Caption\":[],\"Center\":[],\"Cite\":[],\"Code\":[],\"Col\":[],\"Colgroup\":[],\"Content\":[],\"Data\":[],\"Datalist\":[],\"Dd\":[],\"Del\":[],\"Details\":[],\"Dfn\":[],\"Dialog\":[],\"Div\":[],\"Dl\":[],\"Dt\":[],\"Em\":[],\"Embed\":[],\"Fieldset\":[],\"Figcaption\":[],\"Figure\":[],\"Font\":[],\"Footer\":[],\"Form\":[],\"Frame\":[],\"Frameset\":[],\"H1\":[],\"H2\":[],\"H3\":[],\"H4\":[],\"H5\":[],\"H6\":[],\"Header\":[],\"Hgroup\":[],\"Hr\":[],\"I\":[],\"Iframe\":[],\"Img\":[],\"Ins\":[],\"Kbd\":[],\"Keygen\":[],\"Label\":[],\"Legend\":[],\"Li\":[],\"Link\":[],\"Main\":[],\"MapEl\":[],\"Mark\":[],\"Marquee\":[],\"Meta\":[],\"Meter\":[],\"Nav\":[],\"Nobr\":[],\"Noscript\":[],\"ObjectEl\":[],\"Ol\":[],\"Optgroup\":[],\"Option\":[],\"Output\":[],\"P\":[],\"Param\":[],\"Picture\":[],\"Plaintext\":[],\"Pre\":[],\"Progress\":[],\"Q\":[],\"Rb\":[],\"Rp\":[],\"Rt\":[],\"Rtc\":[],\"Ruby\":[],\"S\":[],\"Samp\":[],\"Script\":[],\"Section\":[],\"Select\":[],\"Shadow\":[],\"Slot\":[],\"Small\":[],\"Source\":[],\"Spacer\":[],\"Span\":[],\"Strike\":[],\"Strong\":[],\"Sub\":[],\"Summary\":[],\"Sup\":[],\"Table\":[],\"Tbody\":[],\"Td\":[],\"Template\":[],\"Textarea\":[],\"Tfoot\":[],\"Th\":[],\"Thead\":[],\"Time\":[],\"Title\":[],\"Tr\":[],\"Track\":[],\"U\":[],\"Ul\":[],\"Var\":[],\"Video\":[],\"Wbr\":[],\"Xmp\":[]},\"dash_table\":{\"DataTable\":[]},\"dash_design_kit\":{\"App\":[],\"Block\":[],\"Card\":[],\"CardFooter\":[],\"CardHeader\":[],\"CollapsibleMenu\":[\"title\"],\"ControlCard\":[],\"ControlItem\":[],\"DataCard\":[],\"DataTable\":[],\"Footer\":[\"tags\"],\"FullScreen\":[\"cardRef\"],\"Graph\":[\"insights.title\",\"insights_conversation[].answer\"],\"Header\":[],\"Hero\":[\"tags\",\"primary_controls\",\"secondary_controls\"],\"Icon\":[],\"Logo\":[],\"Menu\":[],\"Modal\":[\"cardRef\"],\"Notification\":[],\"Page\":[],\"PageFooter\":[],\"PageHeader\":[],\"Report\":[],\"Row\":[],\"SectionTitle\":[],\"Sidebar\":[],\"SidebarCompanion\":[],\"Tag\":[],\"Title\":[],\"_CopyText\":null},\"dash_bootstrap_components\":{\"Accordion\":[],\"AccordionItem\":[],\"Alert\":[],\"Badge\":[],\"Breadcrumb\":[],\"Button\":[],\"ButtonGroup\":[],\"Card\":[],\"CardBody\":[],\"CardFooter\":[],\"CardGroup\":[],\"CardHeader\":[],\"CardImg\":[],\"CardImgOverlay\":[],\"CardLink\":[],\"Carousel\":[],\"Collapse\":[],\"DropdownMenu\":[\"label\"],\"DropdownMenuItem\":[],\"Fade\":[],\"Form\":[],\"FormFeedback\":[],\"FormFloating\":[],\"FormText\":[],\"Label\":[],\"Checkbox\":[\"label\"],\"Checklist\":[\"options[].label\"],\"Input\":[],\"InputGroup\":[],\"InputGroupText\":[],\"RadioButton\":[\"label\"],\"RadioItems\":[\"options[].label\"],\"Select\":[],\"Switch\":[\"label\"],\"Textarea\":[],\"Col\":[],\"Container\":[],\"Row\":[],\"Stack\":[],\"ListGroup\":[],\"ListGroupItem\":[],\"Modal\":[],\"ModalBody\":[],\"ModalFooter\":[],\"ModalHeader\":[],\"ModalTitle\":[],\"Nav\":[],\"NavItem\":[],\"NavLink\":[],\"Navbar\":[],\"NavbarBrand\":[],\"NavbarSimple\":[\"brand\"],\"NavbarToggler\":[],\"Offcanvas\":[\"title\"],\"Pagination\":[],\"Placeholder\":[],\"Popover\":[],\"PopoverBody\":[],\"PopoverHeader\":[],\"Progress\":[],\"Spinner\":[],\"Table\":[],\"Tab\":[],\"Tabs\":[],\"Toast\":[\"header\"],\"Tooltip\":[]},\"dash_user_guide_components\":{\"PageMenu\":[],\"Sidebar\":[]},\"dash_bio\":{\"AlignmentChart\":null,\"Circos\":null,\"FornaContainer\":null,\"Ideogram\":null,\"Igv\":null,\"Jsme\":null,\"Molecule2dViewer\":null,\"Molecule3dViewer\":null,\"NeedlePlot\":null,\"NglMoleculeViewer\":null,\"OncoPrint\":null,\"Pileup\":null,\"SequenceViewer\":null,\"Speck\":null},\"dash_cytoscape\":{\"Cytoscape\":null},\"dash_embedded\":{\"ConsumerContext\":[],\"ConsumerFunction\":[]},\"dash_ag_grid\":{\"AgGrid\":[]},\"components\":{\"Header\":[],\"NavLinks\":[],\"QuickSettings\":[],\"ShareDialog\":[]},\"dash_iconify\":{\"DashIconify\":null},\"dash_mantine_components\":{\"Accordion\":[\"chevron\"],\"AccordionControl\":[\"chevron\",\"icon\"],\"AccordionItem\":[],\"AccordionMultiple\":[\"chevron\"],\"AccordionPanel\":[],\"AppShell\":[\"navbar\",\"aside\",\"header\",\"footer\"],\"Aside\":[],\"Footer\":[],\"Header\":[],\"Navbar\":[],\"Avatar\":[],\"AvatarGroup\":[],\"Button\":[\"leftIcon\",\"rightIcon\"],\"ButtonGroup\":[],\"Card\":[],\"CardSection\":[],\"Checkbox\":[\"label\"],\"CheckboxGroup\":[\"label\",\"description\",\"error\"],\"Chip\":[],\"ChipGroup\":[],\"HoverCard\":[],\"HoverCardDropdown\":[],\"HoverCardTarget\":[],\"BackgroundImage\":[],\"Image\":[\"placeholder\",\"caption\"],\"List\":[\"icon\"],\"ListItem\":[\"icon\"],\"Menu\":[],\"MenuDivider\":[],\"MenuDropdown\":[],\"MenuItem\":[\"icon\",\"rightSection\"],\"MenuLabel\":[],\"MenuTarget\":[],\"Radio\":[\"label\"],\"RadioGroup\":[\"label\",\"description\",\"error\"],\"MultiSelect\":[\"nothingFound\",\"label\",\"description\",\"error\",\"icon\",\"rightSection\"],\"Select\":[\"nothingFound\",\"label\",\"description\",\"error\",\"icon\",\"rightSection\"],\"RangeSlider\":[\"marks[].label\",\"thumbChildren\"],\"Slider\":[\"marks[].label\",\"thumbChildren\"],\"Stepper\":[\"completedIcon\",\"progressIcon\"],\"StepperCompleted\":[],\"StepperStep\":[\"icon\",\"completedIcon\",\"progressIcon\",\"label\",\"description\"],\"Tab\":[\"rightSection\",\"icon\"],\"Tabs\":[],\"TabsList\":[],\"TabsPanel\":[],\"JsonInput\":[\"validationError\",\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"NumberInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"PasswordInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"TextInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"Textarea\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"Timeline\":[],\"TimelineItem\":[\"title\",\"bullet\"],\"FloatingTooltip\":[\"label\"],\"Tooltip\":[\"label\"],\"ActionIcon\":[],\"Affix\":[],\"Alert\":[\"title\",\"icon\"],\"Anchor\":[],\"Badge\":[\"leftSection\",\"rightSection\"],\"Blockquote\":[\"icon\",\"cite\"],\"Breadcrumbs\":[\"separator\"],\"Burger\":[],\"Center\":[],\"Code\":[],\"Col\":[],\"ColorPicker\":[],\"Container\":[],\"Divider\":[\"label\"],\"Drawer\":[\"title\"],\"Grid\":[],\"Group\":[],\"Highlight\":[],\"Indicator\":[\"label\"],\"Kbd\":[],\"Loader\":[],\"LoadingOverlay\":[\"loader\"],\"MantineProvider\":[],\"Mark\":[],\"MediaQuery\":[],\"Modal\":[\"title\"],\"NavLink\":[\"label\",\"description\",\"icon\",\"rightSection\"],\"Pagination\":[],\"Paper\":[],\"Prism\":[],\"Progress\":[\"sections[].tooltip\"],\"RingProgress\":[\"label\",\"sections[].tooltip\"],\"ScrollArea\":[],\"SegmentedControl\":[],\"SimpleGrid\":[],\"Skeleton\":[],\"Space\":[],\"Spoiler\":[],\"Stack\":[],\"Switch\":[\"label\",\"offLabel\",\"onLabel\",\"thumbIcon\"],\"Table\":[],\"Text\":[],\"ThemeIcon\":[],\"Title\":[],\"TransferList\":[],\"DatePicker\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"DateRangePicker\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"TimeInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"DemoSegmentedControl\":[],\"DemoSlider\":[],\"Notification\":[\"icon\",\"title\",\"message\"],\"NotificationsProvider\":[]},\"dash_canvas\":{\"DashCanvas\":null},\"dash_player\":{\"DashPlayer\":[]},\"dash_vtk\":{\"Algorithm\":null,\"Calculator\":null,\"CellData\":null,\"DataArray\":null,\"FieldData\":null,\"GeometryRepresentation\":null,\"GlyphRepresentation\":null,\"ImageData\":null,\"Mesh\":null,\"PointCloudRepresentation\":null,\"PointData\":null,\"PolyData\":null,\"Reader\":null,\"ShareDataSet\":null,\"SliceRepresentation\":null,\"View\":null,\"Volume\":null,\"VolumeController\":null,\"VolumeDataRepresentation\":null,\"VolumeRepresentation\":null},\"dash_vega_components\":{\"Vega\":[]}},\"serve_locally\":true}</script>        <script src=\"/_dash-component-suites/dash/deps/polyfill@7.v2_15_0m1709327518.12.1.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/react@16.v2_15_0m1709327518.14.0.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/react-dom@16.v2_15_0m1709327518.14.0.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/prop-types@15.v2_15_0m1709327518.8.1.min.js\"></script><script src=\"/_dash-component-suites/dash_design_kit/dash_design_kit.v1_10_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_daq/dash_daq.v0_5_0m1709327515.min.js\"></script><script src=\"/_dash-component-suites/dash_bootstrap_components/_components/dash_bootstrap_components.v1_5_0m1709327513.min.js\"></script><script src=\"/_dash-component-suites/dash_user_guide_components/dash_user_guide_components.v0_0_8m1709327477.min.js\"></script><script src=\"/_dash-component-suites/dash_bio/bundle.v1_0_2m1709327509.js\"></script><script src=\"/_dash-component-suites/dash_cytoscape/dash_cytoscape.v0_2_0m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_embedded/dash_embedded.v2_7_0m1709327520.min.js\"></script><script src=\"/_dash-component-suites/dash_ag_grid/dash_ag_grid.v31_0_0m1709327512.min.js\"></script><script src=\"/_dash-component-suites/dash_enterprise_libraries/dash_renderer/dash_renderer/dash_renderer.v1_1_0m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_enterprise_libraries/components/components/components.v1_1_0m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_iconify/dash_iconify.v0_1_2m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_mantine_components/dash_mantine_components.v0_12_1m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_canvas/dash_canvas.v0_1_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_player/dash_player.v1_1_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_vtk/dash_vtk.v0_0_9m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_vega_components/dash_vega_components.v0_8_0devm1709327518.min.js\"></script><script src=\"/assets/clientside_example.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridClientsideCallbacks.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridComponentFunctions.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridFunctions.js?m=1709327477.0\"></script><script src=\"/assets/loading.js?m=1709327478.0\"></script><script src=\"/assets/tooltip.js?m=1709327478.0\"></script><script src=\"/assets/dash-design-kit/print-handler.js?m=1709327554.0\"></script><script src=\"/_dash-component-suites/dash/dash-renderer/build/dash_renderer.v2_15_0m1709327517.min.js\"></script><script src=\"/_dash-component-suites/dash/dcc/async-markdown.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/dcc/dash_core_components.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/dcc/dash_core_components-shared.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/html/dash_html_components.v2_0_16m1709327518.min.js\"></script><script src=\"/_dash-component-suites/dash/dash_table/bundle.v5_2_9m1709327517.js\"></script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9b23397fa4d6430b1216471d79a04c4b\"] =     function(){        console.log(dash_clientside.callback_context);        const triggered_id = dash_clientside.callback_context.triggered_id;        return \"triggered id: \" + triggered_id    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"ec11c9ccf34e0f96b162e9b47e54bb54\"] =     function () {                     var printContents = document.getElementById('grid-print-area').innerHTML;         var originalContents = document.body.innerHTML;         document.body.innerHTML = printContents;         window.print();         document.body.innerHTML = originalContents;               location.reload()                                      return window.dash_clientside.no_update    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c68d712a9cfa59d0b000a0950f687e5f\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer1) window._slicer_slicer1 = {};            let private_state = window._slicer_slicer1;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"57e6fbe4bdf13b209addea6f23cf0ca0\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer1) window._slicer_slicer1 = {};            let private_state = window._slicer_slicer1;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer1-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"0bba8ae99f6075e92a2fd156897a54a1\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer2) window._slicer_slicer2 = {};            let private_state = window._slicer_slicer2;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"028dc7f444313744b07134cb8cec421a\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer2) window._slicer_slicer2 = {};            let private_state = window._slicer_slicer2;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer2-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c4ff0d7cabb1720d6259fcf465dbac6d\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer3) window._slicer_slicer3 = {};            let private_state = window._slicer_slicer3;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9227fe57c4a565dbcf8caa3e6608b68b\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer3) window._slicer_slicer3 = {};            let private_state = window._slicer_slicer3;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer3-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"1c59926d9fc28df84b9726d49ca31aa5\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer4) window._slicer_slicer4 = {};            let private_state = window._slicer_slicer4;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f9c881fde82e3997c3cbf5cd5ce113b4\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer4) window._slicer_slicer4 = {};            let private_state = window._slicer_slicer4;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer4-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9cabb076d11534d2070aaa0f9b21c669\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer5) window._slicer_slicer5 = {};            let private_state = window._slicer_slicer5;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a9f1f38c2210c56952ab32639b940da3\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer5) window._slicer_slicer5 = {};            let private_state = window._slicer_slicer5;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer5-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"35b9b18168ee414534aeabab6384ece9\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer6) window._slicer_slicer6 = {};            let private_state = window._slicer_slicer6;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a0410a4f15683e04a7953ff7171d6322\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer6) window._slicer_slicer6 = {};            let private_state = window._slicer_slicer6;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer6-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"27b81951a337a3d83b9ce234413b9537\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer7) window._slicer_slicer7 = {};            let private_state = window._slicer_slicer7;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"fed84ee9b4fc95d53195903d1c09d104\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer7) window._slicer_slicer7 = {};            let private_state = window._slicer_slicer7;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer7-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"737b17422cfe7391f1bcd969e8d43b81\"] =     function(title, path, params, hash, refreshPage) {        // trigger a pagemenu rerender and set the document title        window.history.replaceState(null, null, path + params + hash);        if (title) { document.title = title; }        return [\"\", path, refreshPage];    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"1de45535074f9ee92c79a2354a307227\"] =     function(refreshPage) {    if (refreshPage===true) {        window.location.reload();    }    return \"\";    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"fd1b4f76c8ff11908312c46c223af06a\"] =     function(figure, scale) {        if(figure === undefined) {            return {'data': [], 'layout': {}};        }        const fig = Object.assign({}, figure, {            'layout': {                ...figure.layout,                'yaxis': {                    ...figure.layout.yaxis, type: scale                }             }        });        return fig;    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a78481a4f6c719909e97053e789187ab\"] =     async function(value) {    const response = await fetch(value);    const data = await response.json();    return data;    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"6acc23bd4fd7c6ce7608cc6fe7b7202c\"] =     function(data, scale) {        return {            'data': data,            'layout': {                 'yaxis': {'type': scale}             }        }    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"441278594b1bf51cecc22b131679c5ad\"] =     function show_tooltip(hoverData) {        if(!hoverData) {            return [false, dash_clientside.no_update];        }        var pt = hoverData.points[0];        return [true, pt.bbox];    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"44390b7a6fa5102bd9f74b36a1c0fa9f\"] = async function (changedCell, forceRefresh) {        gridApi = await dash_ag_grid.getApiAsync('styling-cells-other-col')        forceRefresh.length != 0 && gridApi.refreshCells({force: true, columns: ['employee']})        return window.dash_clientside.no_update        };</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"578761413470259ceb606b75a880ed53\"] = function (rowId) {        if (rowId) {            grid = dash_ag_grid.getApi(\"grid-scroll-to-pagination\")                    rowIndex = grid.getRowNode(rowId).rowIndex                    pageTarget = Math.floor(rowIndex / grid.paginationGetPageSize())            grid.paginationGoToPage(pageTarget)        }        return {\"rowId\": rowId.toString()}    };</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c49927592154cdef683f73b893ca3711\"] = function (rowId) {        if (rowId) {            grid = dash_ag_grid.getApi(\"grid-scroll-to-group\")            grid.setRowNodeExpanded(grid.getRowNode(rowId), true, true)        }        return {\"rowId\": rowId.toString()}    };</script>        <script id=\"_dash-renderer\" type=\"application/javascript\">var renderer = new DashRenderer();</script>    </footer>    <div id=\"markprompt\" />    <script>  window.onUsersnapCXLoad = function(api) {    api.init();  }  var script = document.createElement('script');  script.defer = 1;  script.src = 'https://widget.usersnap.com/global/load/c591243c-ea62-42c1-9af3-a1829dfb78cc?onload=onUsersnapCXLoad';  document.getElementsByTagName('head')[0].appendChild(script);</script>          <script type=\"module\">        // References URL link formatter        const getHref = (result) => {          var path = result.file.path;          // If the source is not plotly.com/python, then it should be a relative path          if (!path.startsWith(\"https://plotly.com/python\")) {            var urlObject = new URL(path);            path = urlObject.pathname;          }          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.id) {            path = (path + \"#\" + result.meta.leadHeading.id);          }          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.value) {            path =  (path + \"#\" + result.meta.leadHeading.slug);          }          return path;        };        const getLabel = (reference) => {         var label = reference.meta?.leadHeading?.value || reference.file?.title;          label = label.replace(/[^\\x00-\\x7F]/g, \"\");          while (label.includes(\"plotly-logomark\")) {              label = label.replace(\"plotly-logomark\", \"\");          }          return label;        };        const setCookie = (name, value, days) => {         const expires = new Date();         expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);         document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;        };        const getCookie = (name) => {            const cookies = document.cookie.split(';');            for (let i = 0; i < cookies.length; i++) {                const cookie = cookies[i].trim();                if (cookie.startsWith(name + '=')) {                    return cookie.substring(name.length + 1);                }            }        return null;        };        const getUniqueID = () => {            const storedID = getCookie(\"plotly-chatbot-cookie\");            if (storedID) {                return storedID;            } else {                const newID = generateUniqueID();                setCookie(\"plotly-chatbot-cookie\", newID, 365);                return newID;            }        };        const generateUniqueID = () => {            return Date.now().toString();        };      window.markprompt = {        projectKey: 'pk_0upevf7bcscej8JQMALYiqmXoWQkltw3',        container: '#markprompt',        options: {        sticky: true,        close: { hasIcon: true },          chat: {            systemPrompt: \"- You are an enthusiastic company representative from Plotly who loves to help people!\\- Never give code examples which are not provided in the docs, and don't give code examples in other languages than Python.\",            defaultView: {              message: \"Welcome to Plotly's AI Assistant\",              promptsHeading: 'Popular questions',              prompts: [                'How can I get started with Dash?',                'How can I customize the layout in Dash?',                'How can I change the color of graph labels?',                'How do I move the legend to the top of the graph?',              ],            },              conversationMetadata: {                \"userid\": getUniqueID(),                \"source\": \"dash-docs\",                },            enabled: true,            model: 'gpt-3.5-turbo',            maxTokens: 2000,            errorText: \"Sorry, I'm having some connection issues. Please try again in a few minutes.\",          },          search: {            enabled: false,            getHref: getHref          },          references: {            heading: 'References',            getHref: getHref,            getLabel: getLabel          },          feedback: {            enabled: true          },          trigger: {            buttonLabel: 'Ask AI',            iconSrc: '/assets/markprompt_chat.svg'          },          branding: {            type: 'text'          }        }      }    </script>        <script type=\"module\" src=\"https://esm.sh/@markprompt/web@0.24.0/init\"></script></body></html>",
  "embeddings": []
}