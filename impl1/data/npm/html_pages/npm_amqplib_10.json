{
  "libtype": "npm",
  "libname": "amqplib",
  "url": "http://amqp-node.github.io/amqplib/",
  "html": "<!DOCTYPE html><html>  <head>    <meta charset='utf-8' />    <meta http-equiv=\"X-UA-Compatible\" content=\"chrome=1\" />    <meta name=\"description\" content=\"amqplib : AMQP 0-9-1 library and client for Node.JS\" />    <link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"stylesheets/stylesheet.css\">    <title>amqplib  | AMQP 0-9-1 library and client for Node.JS </title>  </head>  <body>    <!-- HEADER -->    <div id=\"header_wrap\" class=\"outer\">        <header class=\"inner\">          <a id=\"forkme_banner\" href=\"https://github.com/squaremo/amqp.node\">View on GitHub</a>          <h1 id=\"project_title\">amqplib</h1>          <h2 id=\"project_tagline\">AMQP 0-9-1 library and client for Node.JS</h2>            <section id=\"downloads\">              <a class=\"zip_download_link\" href=\"https://github.com/squaremo/amqp.node/zipball/master\">Download this project as a .zip file</a>              <a class=\"tar_download_link\" href=\"https://github.com/squaremo/amqp.node/tarball/master\">Download this project as a tar.gz file</a>            </section>        </header>    </div>    <!-- MAIN CONTENT -->    <div id=\"main_content_wrap\" class=\"outer\">      <section id=\"main_content\" class=\"inner\">        <h1 id=\"amqp-0-9-1-library-and-client-for-nodejs\">AMQP 0-9-1 library and client for Node.JS</h1><p><code class=\"language-plaintext highlighter-rouge\">amqplib</code> implements the machinery needed to make clients for AMQP0-9-1, and includes such a client. Why phrase it that way around?Because AMQP is complicated enough that there are a few different waysof presenting it in API form (e.g., <a href=\"https://github.com/postwait/node-amqp\">node-amqp</a> deals withexchanges and queues as first-class objects, while hiding channels;<a href=\"https://github.com/squaremo/rabbit.js\">rabbit.js</a> deprecates exchanges and queues in favour ofrouting patterns).</p><p>AMQP often seems to be designed to confound client developers; it isnot very cleanly layered and there are consequences to molding it thisway or that in search of a usable API. In <code class=\"language-plaintext highlighter-rouge\">amqplib</code> I have tried toimplement only the necessary machinery of AMQP, in layers as best Ican, without prejudice to any particular client API.</p><table>  <tbody>    <tr>      <td><a href=\"channel_api.html\">Client API reference</a></td>      <td><a href=\"ssl.html\">SSL guide</a></td>    </tr>  </tbody></table><h2 id=\"client-apis\">Client APIs</h2><p>There are two client APIs included here, which are really two stylesof the same API: one uses promises, and one callbacks.</p><p>The client APIs are oriented around <code class=\"language-plaintext highlighter-rouge\">Channel</code> objects (which aresomething like sessions). They expose the protocol fairly directly asmethods on an object. Exchanges and queues are only representedinsofar as they are named (with strings) in arguments to thesemethods.</p><p>Almost all operations are asynchronous RPCs; these methods on<code class=\"language-plaintext highlighter-rouge\">Channel</code> either return promises, or accept callbacks. Some operations(e.g., <code class=\"language-plaintext highlighter-rouge\">#ack</code>) elicit no response from the server, and don\u2019t return apromise or take a callback.</p><p>In general I have made arguments that are mandatory in the protocolinto method arguments in the API, and coalesced optional arguments,properties, and RabbitMQ extensions into a single <code class=\"language-plaintext highlighter-rouge\">options</code> argumentwhich can often be omitted altogether.</p><p>The <a href=\"channel_api.html\">reference</a> has full details of both APIs.</p><h2 id=\"library-overview\">Library overview</h2><p>To be able to get anywhere at all, an AMQP library needs to be able to</p><ul>  <li>parse and serialise frames</li>  <li>maintain connection and channel state</li>  <li>implement the opening and closing handshakes</li></ul><p>In <code class=\"language-plaintext highlighter-rouge\">amqplib</code>, parsing and serialising are dealt with in the modules</p><ul>  <li><code class=\"language-plaintext highlighter-rouge\">codec</code> procedures for parsing and serialising values;</li>  <li><code class=\"language-plaintext highlighter-rouge\">defs</code> generated code for encoding and decoding protocol methods;and,</li>  <li><code class=\"language-plaintext highlighter-rouge\">frame</code> for turning a byte stream into decoded frames andvice-versa.</li></ul><p>Connection state is maintained in a <code class=\"language-plaintext highlighter-rouge\">Connection</code> object (module<code class=\"language-plaintext highlighter-rouge\">connection</code>) and channel state in a <code class=\"language-plaintext highlighter-rouge\">Channel</code> (module <code class=\"language-plaintext highlighter-rouge\">channel</code>);these two modules also implement the opening and closing handshakes.</p><p>The interfaces among these modules is small and mostly mediated withprimitive values; e.g., strings and numbers. A few points of interfacerequire callbacks of the <code class=\"language-plaintext highlighter-rouge\">function(err, ok) {}</code> variety, or in theform of duck-typed objects (e.g., an object with an <code class=\"language-plaintext highlighter-rouge\">#accept</code> method).</p><h2 id=\"troubleshooting\">Troubleshooting</h2><h3 id=\"why-dont-the-publish-sendtoqueue-ack-ackall-nack-nackall-and-reject-channel-methods-return-a-promise\">Why don\u2019t the publish, sendToQueue, ack, ackAll, nack, nackAll and reject channel methods return a promise?</h3><p>Some commands in the amqp protocol require a reply, others do not. When a command does not require a reply, amqplib writes the command to an internal buffer and returns immediately. When a command expects a reply, amqplib will <strong>usually</strong> return a promise which will resolve when the reply is received. The two exceptions are the publish and sendToQueue methods, which when using a confirm channel do expect a reply, but still do not return a promise. This is because they return a boolean to indicate whether the internal buffer is full and that the client should back off until a drain event is emitted from the channel.</p><h3 id=\"why-does-amqplib-crash-my-application\">Why does amqplib crash my application?</h3><p>Error events are a special type of event in Node.js applications, which if unhandled will cause the node process to exit. The connection and channel objects emit error events when something bad happens. Your code needs to handle these events if you don\u2019t want your application to crash.</p><div class=\"language-js highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">const</span> <span class=\"nx\">connection</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">amqplib</span><span class=\"p\">.</span><span class=\"nx\">connect</span><span class=\"p\">();</span><span class=\"nx\">connection</span><span class=\"p\">.</span><span class=\"nx\">on</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">error</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"c1\">// recover or exit</span><span class=\"p\">});</span><span class=\"kd\">const</span> <span class=\"nx\">channel</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"nx\">connection</span><span class=\"p\">.</span><span class=\"nx\">createChannel</span><span class=\"p\">();</span><span class=\"nx\">channel</span><span class=\"p\">.</span><span class=\"nx\">on</span><span class=\"p\">(</span><span class=\"dl\">'</span><span class=\"s1\">error</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"p\">{</span>  <span class=\"c1\">// recover or exit</span><span class=\"p\">})</span><span class=\"nx\">l</span></code></pre></div></div><h3 id=\"how-do-i-recover-from-a-connection-or-channel-error\">How do I recover from a connection or channel error?</h3><p>To recover from a channel error your code must listen for the channel error event, create a new channel and restablish any consumers. To recover from a connection error your code must listen for the connection error event, reconnect, create the necessary channels and restablish any consumers. You may also wish to handle to the connection \u2018close\u2019 event which will be emitted if the server shutsdown gracefully AND following a connection error.</p><h3 id=\"why-do-i-get-a-frame-size-exceeds-frame-max-error\">Why do I get a \u201cFrame size exceeds frame max\u201d error?</h3><p>This is typically because you\u2019ve connected to a server that doesn\u2019t use the amqp 0.9.1 protocol. Sometimes people are trying to connect to an amqp 1.0 broker, other times they have accidentally connected to an HTTP server by specifying the wrong port, or that they were not aware was running. It can also be because you\u2019ve used <code class=\"language-plaintext highlighter-rouge\">amqp://</code> rather than <code class=\"language-plaintext highlighter-rouge\">amqps://</code> when connecting over SSL. A related problem can occur when receiving a message with an oversized header, in which case you can try increasing the maximum frame size via the <code class=\"language-plaintext highlighter-rouge\">frameMax</code> connection parameter.</p><h3 id=\"how-do-i-flush-messages--why-are-messages-not-sent\">How do I flush messages? / Why are messages not sent?</h3><p>When you publish a message using channel.publish or channel.sendToQueue it is written to an internal buffer associated with the channel. Under the hood, amqplib loops through each of the channel buffers, sending the messages to the server. Messages will be written as fast as possible and the buffers do not need to be flushed, however if you close the connection or your application exits while there are still messages in the buffer, they will be lost. Be sure to explicity close the channel and wait for the returned promise to resolve, or supplied callback to be invoked before closing the connection or terminating your application.</p><h3 id=\"why-do-i-get-econnreset\">Why do I get ECONNRESET?</h3><p>ECONNRESET means that the server (or something between the client and the server) closed the connection without warning. This may occur during the initial handshake if the connection parameters you supply are invalid, or after successful connection if the server is killed, or if the network is unstable, or if you connect to the server through a load balancer / firewall and it decides to drop the connection, or if the client application is overloaded and cannot send commands to the server before the heartbeat timeout expires. Typically an ECONNRESET does not indicate a problem with amqplib, but a configuration or networking issue in your environment.</p><h3 id=\"why-do-i-get-error-channel-ended-no-reply-will-be-forthcoming\">Why do I get Error: Channel ended, no reply will be forthcoming?</h3><p>Many amqp commands require a reply. If the channel ends before the reply is received then the outstanding promise / callback will fail with this error. This can occur when the client does not wait for all operations to complete and/or does not prevent new operations from starting while the application is shutting down.</p><h3 id=\"debugging-tips\">Debugging Tips</h3><ol>  <li>Use <a href=\"https://www.rabbitmq.com/amqp-wireshark.html\">Wireshark</a> to inspect the communication between your application and the broker.</li>  <li>Use <a href=\"https://nodejs.org/en/docs/guides/debugging-getting-started/\">Node\u2019s debugger</a> combined with your IDE or Chrome.</li>  <li>Set a very long heartbeat (or disable them completely) to prevent heartbeat errors while stepping through the code.</li>  <li>Use a <a href=\"https://hub.docker.com/_/rabbitmq\">RabbitMQ Docker Container</a> to simulate network errors.</li></ol>      </section>    </div>    <!-- FOOTER  -->    <div id=\"footer_wrap\" class=\"outer\">      <footer class=\"inner\">        <p>amqplib is maintained by          <a href=\"https://github.com/squaremo\">Michael Bridgen</a></p>        <p class=\"copyright\">Copyright 2013, 2014 Michael Bridgen</p>        <p>Published with <a href=\"http://pages.github.com\">GitHub Pages</a></p>      </footer>    </div>      </body></html>",
  "embeddings": []
}