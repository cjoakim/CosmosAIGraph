{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu library or lesser general public license (lgpl)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.13",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: scientific/engineering :: gis"
  ],
  "description": "introduction\n============\n\n.. inclusion-marker-do-not-remove\n\npygeoif provides a `geojson-like protocol <https://gist.github.com/2217756>`_\nfor geo-spatial (gis) vector data.\n\nother python programs and packages that you may have heard of that\nimplement this protocol:\n\n* `arcpy <https://www.esri.com/about/newsroom/arcuser/geojson/>`_\n* `descartes <https://docs.descarteslabs.com/>`_\n* `pysal <http://pysal.geodacenter.org/>`_\n* `shapely <https://github.com/toblerity/shapely>`_\n* `pyshp <https://pypi.python.org/pypi/pyshp>`_\n* `geopandas <https://geopandas.org/>`_\n* `karta <https://github.com/fortyninemaps/karta>`_\n* `mapnik <https://github.com/mapnik/mapnik>`_\n\nwhen you want to write your own geospatial library with support\nfor this protocol you may use pygeoif as a starting point and build\nyour functionality on top of it. it has no requirements outside the\npython standard library and is therefore easy to integrate into your\nproject. it is tested on `cpython <https://python.org>`_ and\n`pypy <https://www.pypy.org/>`_, but it should work on alternative\npython implementations (that implement the language specification *>=3.8*) as well.\n\nyou may think of pygeoif as a 'shapely ultralight' which lets you\nconstruct geometries and perform **very** basic operations like\nreading and writing geometries from/to wkt, constructing line strings\nout of points, polygons from linear rings, multi polygons from\npolygons, etc. it was inspired by shapely and implements the\ngeometries in a way that when you are familiar with pygeoif,\nyou will feel right at home with shapely or the other way round.\n\nit was written to provide clean and python only geometries for fastkml_\n\n.. image:: https://github.com/cleder/pygeoif/actions/workflows/run-all-tests.yml/badge.svg?branch=main\n    :target: https://github.com/cleder/pygeoif/actions/workflows/run-all-tests.yml\n    :alt: github actions\n\n.. image:: https://readthedocs.org/projects/pygeoif/badge/?version=latest\n    :target: https://pygeoif.readthedocs.io/en/latest/?badge=latest\n    :alt: documentation status\n\n.. image:: https://codecov.io/gh/cleder/pygeoif/branch/main/graph/badge.svg?token=2efiwbxs9x\n    :target: https://codecov.io/gh/cleder/pygeoif\n    :alt: codecov\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/psf/\n    :alt: black\n\n.. image:: https://img.shields.io/badge/type%20checker-mypy-blue\n    :target: http://mypy-lang.org/\n    :alt: mypy\n\n.. image:: https://www.openhub.net/p/pygeoif/widgets/project_thin_badge.gif\n    :target: https://www.openhub.net/p/pygeoif/\n    :alt: openhub\n\n.. image:: https://www.codefactor.io/repository/github/cleder/pygeoif/badge/main\n   :target: https://www.codefactor.io/repository/github/cleder/pygeoif/overview/main\n   :alt: codefactor\n\n.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit\n   :target: https://github.com/pre-commit/pre-commit\n   :alt: pre-commit\n\n.. image:: https://img.shields.io/pypi/pyversions/pygeoif.svg\n    :target: https://pypi.python.org/pypi/pygeoif/\n    :alt: supported python versions\n\n.. image:: https://img.shields.io/pypi/implementation/pygeoif.svg\n    :target: https://pypi.python.org/pypi/pygeoif/\n    :alt: supported python implementations\n\ninstallation\n------------\n\nyou can install pygeoif from pypi using pip::\n\n    pip install pygeoif\n\n\nexample\n========\n\n    >>> from pygeoif import geometry\n    >>> p = geometry.point(1,1)\n    >>> p.__geo_interface__\n    {'type': 'point', 'bbox': (1, 1, 1, 1), 'coordinates': (1, 1)}\n    >>> print(p)\n    point (1 1)\n    >>> p\n    point(1, 1)\n    >>> l = geometry.linestring([(0.0, 0.0), (1.0, 1.0)])\n    >>> l.bounds\n    (0.0, 0.0, 1.0, 1.0)\n    >>> print(l)\n    linestring (0.0 0.0, 1.0 1.0)\n\n\nyou find more examples in the\n`tests <https://github.com/cleder/pygeoif/tree/main/pygeoif/tests>`_\ndirectory which cover every aspect of pygeoif or in fastkml_.\n\nclasses\n========\n\nall classes implement the attribute:\n\n* ``__geo_interface__``: as discussed above, an interface to geojson_.\n\nall geometry classes implement the attributes:\n\n* ``geom_type``: returns a string specifying the geometry type of the object\n* ``bounds``: returns a (minx, miny, maxx, maxy) tuple that bounds the object.\n* ``wkt``: returns the 'well known text' representation of the object\n\nfor two-dimensional geometries the following methods are implemented:\n\n* ``convex_hull``: returns a representation of the smallest convex polygon containing\n  all the points in the object unless the number of points in the object is less than three.\n  for two points, the convex hull collapses to a linestring; for 1, a point.\n  for three dimensional objects only their projection in the xy plane is taken into consideration.\n  empty objects without coordinates return ``none`` for the convex_hull.\n\n\npoint\n-----\na zero dimensional geometry\n\na point has zero length and zero area. a point cannot be empty.\n\nattributes\n~~~~~~~~~~~\nx, y, z : float\n    coordinate values\n\nexample\n~~~~~~~~\n\n      >>> from pygeoif import point\n      >>> p = point(1.0, -1.0)\n      >>> print(p)\n      point (1.0 -1.0)\n      >>> p.y\n      -1.0\n      >>> p.x\n      1.0\n\n\n\nlinestring\n-----------\n\na one-dimensional figure comprising one or more line segments\n\na linestring has non-zero length and zero area. it may approximate a curve\nand need not be straight. unlike a linearring, a linestring is not closed.\n\nattributes\n~~~~~~~~~~~\ngeoms : sequence\n    a sequence of points\n\nlinearring\n-----------\n\na closed one-dimensional geometry comprising one or more line segments\n\na linearring that crosses itself or touches itself at a single point is\ninvalid and operations on it may fail.\n\na linearring is self closing.\n\n\npolygon\n--------\n\na two-dimensional figure bounded by a linear ring\n\na polygon has a non-zero area. it may have one or more negative-space\n\"holes\" which are also bounded by linear rings. if any rings cross each\nother, the geometry is invalid and operations on it may fail.\n\nattributes\n~~~~~~~~~~~\n\nexterior : linearring\n    the ring which bounds the positive space of the polygon.\ninteriors : sequence\n    a sequence of rings which bound all existing holes.\nmaybe_valid: boolean\n    when a polygon has obvious problems such as self crossing\n    lines or holes that are outside the exterior bounds this will\n    return false. even if this returns true the geometry may still be invalid,\n    but if this returns false you do have a problem.\n\nmultipoint\n----------\na collection of one or more points.\n\nattributes\n~~~~~~~~~~~\n\ngeoms : sequence\n    a sequence of points.\n\nmultilinestring\n----------------\na collection of one or more line strings.\n\na multilinestring has non-zero length and zero area.\n\nattributes\n~~~~~~~~~~~\n\ngeoms : sequence\n    a sequence of linestrings\n\nmultipolygon\n-------------\n\na collection of one or more polygons.\n\nattributes\n~~~~~~~~~~~~~\ngeoms : sequence\n    a sequence of `polygon` instances\n\n\ngeometrycollection\n-------------------\na heterogenous collection of geometries (points, linestrings, linearrings\nand polygons).\n\nattributes\n~~~~~~~~~~~\ngeoms : sequence\n    a sequence of geometry instances\n\nplease note:\n``geometrycollection`` isn't supported by the shapefile or geojson_ format.\nand this sub-class isn't generally supported by ordinary gis sw (viewers and so on).\nso it's very rarely used in the real gis professional world.\n\nexample\n~~~~~~~~\n\n    >>> from pygeoif import geometry\n    >>> p = geometry.point(1.0, -1.0)\n    >>> p2 = geometry.point(1.0, -1.0)\n    >>> geoms = [p, p2]\n    >>> c = geometry.geometrycollection(geoms)\n    >>> [geom for geom in geoms]\n    [point(1.0, -1.0), point(1.0, -1.0)]\n\nfeature\n-------\naggregates a geometry instance with associated user-defined properties.\n\nattributes\n~~~~~~~~~~~\ngeometry : object\n    a geometry instance\nproperties : dict\n    a dictionary linking field keys with values associated with with geometry instance\n\nexample\n~~~~~~~~\n      >>> from pygeoif import point, feature\n      >>> p = point(1.0, -1.0)\n      >>> props = {'name': 'sample point', 'other': 'other data'}\n      >>> a = feature(p, props)\n      >>> a.properties\n      {'name': 'sample point', 'other': 'other data'}\n      >>> a.properties['name']\n      'sample point'\n\nfeaturecollection\n-----------------\na heterogenous collection of features\n\nattributes\n~~~~~~~~~~~\nfeatures: sequence\n    a sequence of feature instances\n\nexample\n~~~~~~~~\n\n    >>> from pygeoif import point, feature, featurecollection\n    >>> p = point(1.0, -1.0)\n    >>> props = {'name': 'sample point', 'other': 'other data'}\n    >>> a = feature(p, props)\n    >>> p2 = point(1.0, -1.0)\n    >>> props2 = {'name': 'sample point2', 'other': 'other data2'}\n    >>> b = feature(p2, props2)\n    >>> features = [a, b]\n    >>> c = featurecollection(features)\n    >>> [feature for feature in c]\n    [feature(point(1.0, -1.0), {'name': 'sample point', 'other': 'other data'},...]\n\nfunctions\n=========\n\nshape\n--------\n\ncreate a pygeoif feature from an object that provides the ``__geo_interface__``\nor any geojson_ compatible dictionary.\n\n    >>> from shapely.geometry import point\n    >>> from pygeoif import geometry, shape\n    >>> shape(point(0,0))\n    point(0.0, 0.0)\n\n\nfrom_wkt\n---------\n\ncreate a geometry from its wkt representation\n\n    >>> from pygeoif import from_wkt\n    >>> p = from_wkt('point (0 1)')\n    >>> print(p)\n    point (0.0 1.0)\n\n\nsigned_area\n------------\n\nreturn the signed area enclosed by a ring.\na value >= 0 indicates a counter-clockwise oriented ring.\n\n\norient\n-------\nreturns a copy of a polygon with exteriors and interiors in the right orientation.\n\nif ccw is true than the exterior will be in counterclockwise orientation\nand the interiors will be in clockwise orientation, or\nthe other way round when ccw is false.\n\n\nbox\n---\nreturn a rectangular polygon with configurable normal vector.\n\n\nmapping\n-------\n\nreturn the ``__geo_interface__`` dictionary.\n\n\ndevelopment\n===========\n\nclone this repository, create a virtualenv with python 3.8 or later with\n``python3 -m venv .venv`` and activate it with ``source .venv/bin/activate``.\n\nthen install the requirements with ``pip install -e \".[dev]\"``.\n\npre-commit\n----------\n\ninstall the ``pre-commit`` hook with::\n\n    pip install pre-commit\n    pre-commit install\n\nand check the code with::\n\n    pre-commit run --all-files\n\ntesting\n-------\n\nrun the unit and static tests with::\n\n    pytest tests\n    pytest --doctest-glob=\"readme.rst\"\n    black pygeoif\n    ruff pygeoif\n    flake8 pygeoif\n    mypy pygeoif\n\n\n\nacknowledgments\n================\n\nthe tests were improved with mutmut_ which discovered some nasty edge cases.\n\n.. _mutmut: https://github.com/boxed/mutmut\n.. _geojson: https://geojson.org/\n.. _fastkml: http://pypi.python.org/pypi/fastkml/\n",
  "docs_url": null,
  "keywords": "gis,spatial,wkt",
  "license": "lgpl",
  "name": "pygeoif",
  "package_url": "https://pypi.org/project/pygeoif/",
  "project_url": "https://pypi.org/project/pygeoif/",
  "project_urls": {
    "Changelog": "https://github.com/cleder/pygeoif/blob/develop/docs/HISTORY.rst",
    "Documentation": "https://pygeoif.readthedocs.io/",
    "Homepage": "https://github.com/cleder/pygeoif/"
  },
  "release_url": "https://pypi.org/project/pygeoif/1.2.0/",
  "requires_dist": [
    "typing-extensions",
    "lizard ; extra == 'complexity'",
    "radon ; extra == 'complexity'",
    "pre-commit ; extra == 'dev'",
    "pygeoif[complexity] ; extra == 'dev'",
    "pygeoif[linting] ; extra == 'dev'",
    "pygeoif[tests] ; extra == 'dev'",
    "pygeoif[typing] ; extra == 'dev'",
    "black ; extra == 'linting'",
    "flake8 ; extra == 'linting'",
    "flake8-cognitive-complexity ; extra == 'linting'",
    "flake8-comments ; extra == 'linting'",
    "flake8-complex-f-strings ; extra == 'linting'",
    "flake8-continuation ; extra == 'linting'",
    "flake8-docstrings ; extra == 'linting'",
    "flake8-dunder-all ; extra == 'linting'",
    "flake8-encodings ; extra == 'linting'",
    "flake8-expression-complexity ; extra == 'linting'",
    "flake8-function-order ; extra == 'linting'",
    "flake8-length ; extra == 'linting'",
    "flake8-pep3101 ; extra == 'linting'",
    "flake8-rst-docstrings ; extra == 'linting'",
    "flake8-string-format ; extra == 'linting'",
    "flake8-super ; extra == 'linting'",
    "flake8-typing-imports ; extra == 'linting'",
    "flake8-use-fstring ; extra == 'linting'",
    "ruff ; extra == 'linting'",
    "yamllint ; extra == 'linting'",
    "pytest ; extra == 'tests'",
    "pytest-cov ; extra == 'tests'",
    "mypy ; extra == 'typing'"
  ],
  "requires_python": ">=3.7",
  "summary": "a basic implementation of the __geo_interface__",
  "version": "1.2.0",
  "releases": [],
  "developers": [
    "christian.ledermann@gmail.com"
  ],
  "kwds": "geojson geojson_ _geojson pyshp geopandas",
  "license_kwds": "lgpl",
  "libtype": "pypi",
  "id": "pypi_pygeoif",
  "homepage": "",
  "release_count": 22,
  "dependency_ids": [
    "pypi_black",
    "pypi_flake8",
    "pypi_flake8_cognitive_complexity",
    "pypi_flake8_comments",
    "pypi_flake8_complex_f_strings",
    "pypi_flake8_continuation",
    "pypi_flake8_docstrings",
    "pypi_flake8_dunder_all",
    "pypi_flake8_encodings",
    "pypi_flake8_expression_complexity",
    "pypi_flake8_function_order",
    "pypi_flake8_length",
    "pypi_flake8_pep3101",
    "pypi_flake8_rst_docstrings",
    "pypi_flake8_string_format",
    "pypi_flake8_super",
    "pypi_flake8_typing_imports",
    "pypi_flake8_use_fstring",
    "pypi_lizard",
    "pypi_mypy",
    "pypi_pre_commit",
    "pypi_pygeoif",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_radon",
    "pypi_ruff",
    "pypi_typing_extensions",
    "pypi_yamllint"
  ]
}