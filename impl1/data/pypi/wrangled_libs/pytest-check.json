{
  "classifiers": [
    "framework :: pytest",
    "license :: osi approved :: mit license"
  ],
  "description": "# pytest-check\n\na pytest plugin that allows multiple failures per test.\n\n----\n\nnormally, a test function will fail and stop running with the first failed `assert`.\nthat's totally fine for tons of kinds of software tests.\nhowever, there are times where you'd like to check more than one thing, and you'd really like to know the results of each check, even if one of them fails.\n\n`pytest-check` allows multiple failed \"checks\" per test function, so you can see the whole picture of what's going wrong.\n\n## installation\n\nfrom pypi:\n\n```\n$ pip install pytest-check\n```\n\nfrom conda (conda-forge):\n```\n$ conda install -c conda-forge pytest-check\n```\n\n## example\n\nquick example of where you might want multiple checks:\n\n```python\nimport httpx\nfrom pytest_check import check\n\ndef test_httpx_get():\n    r = httpx.get('https://www.example.org/')\n    # bail if bad status code\n    assert r.status_code == 200\n    # but if we get to here\n    # then check everything else without stopping\n    with check:\n        assert r.is_redirect is false\n    with check:\n        assert r.encoding == 'utf-8'\n    with check:\n        assert 'example domain' in r.text\n```\n\n## import vs fixture\n\nthe example above used import: `from pytest_check import check`.\n\nyou can also grab `check` as a fixture with no import:\n\n```python\ndef test_httpx_get(check):\n    r = httpx.get('https://www.example.org/')\n    ...\n    with check:\n        assert r.is_redirect == false\n    ...\n```\n\n## validation functions\n\n`check` also helper functions for common checks. \nthese methods do not need to be inside of a `with check:` block.\n\n- **check.equal** - *a == b*\n- **check.not_equal** - *a != b*\n- **check.is_** - *a is b*\n- **check.is_not** - *a is not b*\n- **check.is_true** - *bool(x) is true*\n- **check.is_false** - *bool(x) is false*\n- **check.is_none** - *x is none*\n- **check.is_not_none** - *x is not none*\n- **check.is_in** - *a in b*\n- **check.is_not_in** - *a not in b*\n- **check.is_instance** - *isinstance(a, b)*\n- **check.is_not_instance** - *not isinstance(a, b)*\n- **check.almost_equal** - *a == pytest.approx(b, rel, abs)* see at: [pytest.approx](https://docs.pytest.org/en/latest/reference.html#pytest-approx)\n- **check.not_almost_equal** - *a != pytest.approx(b, rel, abs)* see at: [pytest.approx](https://docs.pytest.org/en/latest/reference.html#pytest-approx)\n- **check.greater** - *a > b*\n- **check.greater_equal** - *a >= b*\n- **check.less** - *a < b*\n- **check.less_equal** - *a <= b*\n- **check.between** - *a < b < c*\n- **check.raises** - *func raises given exception* similar to [pytest.raises](https://docs.pytest.org/en/latest/reference/reference.html#pytest-raises)\n\nthe httpx example can be rewritten with helper functions:\n\n```python\ndef test_httpx_get_with_helpers():\n    r = httpx.get('https://www.example.org/')\n    assert r.status_code == 200\n    check.is_false(r.is_redirect)\n    check.equal(r.encoding, 'utf-8')\n    check.is_in('example domain', r.text)\n```\n\nwhich you use is personal preference.\n\n## defining your own check functions\n\nthe `@check.check_func` decorator allows you to wrap any test helper that has an assert\nstatement in it to be a non-blocking assert function.\n\n\n```python\nfrom pytest_check import check\n\n@check.check_func\ndef is_four(a):\n    assert a == 4\n\ndef test_all_four():\n    is_four(1)\n    is_four(2)\n    is_four(3)\n    is_four(4)\n```\n\n## using raises as a context manager\n\n`raises` is used as context manager, much like `pytest.raises`. the main difference being that a failure to raise the right exception won't stop the execution of the test method.\n\n\n```python\nfrom pytest_check import check\n\ndef test_raises():\n    with check.raises(assertionerror):\n        x = 3\n        assert 1 < x < 4\n```\n\n## pseudo-tracebacks\n\nwith `check`, tests can have multiple failures per test.\nthis would possibly make for extensive output if we include the full traceback for\nevery failure.\nto make the output a little more concise, `pytest-check` implements a shorter version, which we call pseudo-tracebacks.\n\nfor example, take this test:\n\n```python\ndef test_example():\n    a = 1\n    b = 2\n    c = [2, 4, 6]\n    check.greater(a, b)\n    check.less_equal(b, a)\n    check.is_in(a, c, \"is 1 in the list\")\n    check.is_not_in(b, c, \"make sure 2 isn't in list\")\n```\n\nthis will result in:\n\n```\n=================================== failures ===================================\n_________________________________ test_example _________________________________\nfailure:\nassert 1 > 2\n  test_check.py, line 14, in test_example() -> check.greater(a, b)\nfailure:\nassert 2 <= 1\n  test_check.py, line 15, in test_example() -> check.less_equal(b, a)\nfailure: is 1 in the list\nassert 1 in [2, 4, 6]\n  test_check.py, line 16, in test_example() -> check.is_in(a, c, \"is 1 in the list\")\nfailure: make sure 2 isn't in list\nassert 2 not in [2, 4, 6]\n  test_check.py, line 17, in test_example() -> check.is_not_in(b, c, \"make sure 2 isn't in list\")\n------------------------------------------------------------\nfailed checks: 4\n=========================== 1 failed in 0.11 seconds ===========================\n```\n\n## red output\n\nthe failures will also be red, unless you turn that off with pytests `--color=no`.\n\n## no output\n\nyou can turn off the failure reports with pytests `--tb=no`.\n\n## stop on fail (maxfail behavior)\n\nsetting `-x` or `--maxfail=1` will cause this plugin to abort testing after the first failed check.\n\nsetting `-maxfail=2` or greater will turn off any handling of maxfail within this plugin and the behavior is controlled by pytest.\n\nin other words, the `maxfail` count is counting tests, not checks.\nthe exception is the case of `1`, where we want to stop on the very first failed check.\n\n## any_failures()\n\nuse `any_failures()` to see if there are any failures.  \none use case is to make a block of checks conditional on not failing in a previous set of checks:\n\n```python\nfrom pytest_check import check\n\ndef test_with_groups_of_checks():\n    # always check these\n    check.equal(1, 1)\n    check.equal(2, 3)\n    if not check.any_failures():\n        # only check these if the above passed\n        check.equal(1, 2)\n        check.equal(2, 2)\n```\n\n## speedups\n\nif you have lots of check failures, your tests may not run as fast as you want.\nthere are a few ways to speed things up.\n\n* `--check-max-tb=5` - only first 5 failures per test will include pseudo-tracebacks (rest without them).\n    * the example shows `5` but any number can be used.\n    * pytest-check uses custom traceback code i'm calling a pseudo-traceback.\n    * this is visually shorter than normal assert tracebacks.\n    * internally, it uses introspection, which can be slow.\n    * allowing a limited number of pseudo-tracebacks speeds things up quite a bit.\n    * default is 1. \n        * set a large number, e.g: 1000, if you want pseudo-tracebacks for all failures\n\n* `--check-max-report=10` - limit reported failures per test.\n    * the example shows `10` but any number can be used.\n    * the test will still have the total nuber of failures reported.\n    * default is no maximum.\n\n* `--check-max-fail=20` - stop the test after this many check failures.\n    * this is useful if your code under test is slow-ish and you want to bail early.\n    * default is no maximum.\n\n* any of these can be used on their own, or combined.\n\n* recommendation:\n    * leave the default, equivelant to `--check-max-tb=1`.\n    * if excessive output is annoying, set `--check-max-report=10` or some tolerable number.\n\n## local speedups\n\nthe flags above are global settings, and apply to every test in the test run.  \n\nlocally, you can set these values per test.\n\nfrom `examples/test_example_speedup_funcs.py`:\n\n```python\ndef test_max_tb():\n    check.set_max_tb(2)\n    for i in range(1, 11):\n        check.equal(i, 100)\n\ndef test_max_report():\n    check.set_max_report(5)\n    for i in range(1, 11):\n        check.equal(i, 100)\n\ndef test_max_fail():\n    check.set_max_fail(5)\n    for i in range(1, 11):\n        check.equal(i, 100)\n```\n\n## contributing\n\ncontributions are very welcome. tests can be run with [tox](https://tox.readthedocs.io/en/latest/).\ntest coverage is now 100%. please make sure to keep it at 100%.\nif you have an awesome pull request and need help with getting coverage back up, let me know.\n\n\n## license\n\ndistributed under the terms of the [mit](http://opensource.org/licenses/mit) license, \"pytest-check\" is free and open source software\n\n## issues\n\nif you encounter any problems, please [file an issue](https://github.com/okken/pytest-check/issues) along with a detailed description.\n\n## changelog\n\nsee [changelog.md](https://github.com/okken/pytest-check/blob/main/changelog.md)\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "pytest-check",
  "package_url": "https://pypi.org/project/pytest-check/",
  "project_url": "https://pypi.org/project/pytest-check/",
  "project_urls": {
    "Home": "https://github.com/okken/pytest-check"
  },
  "release_url": "https://pypi.org/project/pytest-check/2.2.2/",
  "requires_dist": [
    "pytest"
  ],
  "requires_python": ">=3.7",
  "summary": "a pytest plugin that allows multiple failures per test.",
  "version": "2.2.2",
  "releases": [],
  "developers": [
    "brian_okken"
  ],
  "kwds": "pytest_check test_check test_httpx_get test_with_groups_of_checks test_max_fail",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pytest_check",
  "homepage": "",
  "release_count": 43,
  "dependency_ids": [
    "pypi_pytest"
  ]
}