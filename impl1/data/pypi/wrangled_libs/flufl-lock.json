{
  "classifiers": [
    "development status :: 5 - production/stable",
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "==========\nflufl.lock\n==========\n\nnfs-safe file locking with timeouts for posix and windows.\n\nthe ``flufl.lock`` library provides an nfs-safe file-based locking algorithm\ninfluenced by the gnu/linux ``open(2)`` manpage, under the description of the\n``o_excl`` option.\n\n    [...] o_excl is broken on nfs file systems, programs which rely on it\n    for performing locking tasks will contain a race condition.  the\n    solution for performing atomic file locking using a lockfile is to\n    create a unique file on the same fs (e.g., incorporating hostname and\n    pid), use link(2) to make a link to the lockfile.  if link() returns\n    0, the lock is successful.  otherwise, use stat(2) on the unique file\n    to check if its link count has increased to 2, in which case the lock\n    is also successful.\n\nthe assumption made here is that there will be no *outside interference*,\ne.g. no agent external to this code will ever ``link()`` to the specific lock\nfiles used.\n\nlock objects support lock-breaking so that you can't wedge a process forever.\nthis is especially helpful in a web environment, but may not be appropriate\nfor all applications.\n\nlocks have a *lifetime*, which is the maximum length of time the process\nexpects to retain the lock.  it is important to pick a good number here\nbecause other processes will not break an existing lock until the expected\nlifetime has expired.  too long and other processes will hang; too short and\nyou'll end up trampling on existing process locks -- and possibly corrupting\ndata.  in a distributed (nfs) environment, you also need to make sure that\nyour clocks are properly synchronized.\n\n\nauthor\n======\n\n``flufl.lock`` is copyright (c) 2007-2023 barry warsaw <barry@python.org>\n\nlicensed under the terms of the apache license version 2.0.  see the license\nfile for details.\n\n\nproject details\n===============\n\n * project home: https://gitlab.com/warsaw/flufl.lock\n * report bugs at: https://gitlab.com/warsaw/flufl.lock/issues\n * code hosting: https://gitlab.com/warsaw/flufl.lock.git\n * documentation: https://flufllock.readthedocs.io/\n * pypi: https://pypi.python.org/pypi/flufl.lock\n",
  "docs_url": null,
  "keywords": "locking locks lock",
  "license": "apache-2.0",
  "name": "flufl.lock",
  "package_url": "https://pypi.org/project/flufl.lock/",
  "project_url": "https://pypi.org/project/flufl.lock/",
  "project_urls": {
    "Bug tracker": "https://gitlab.com/warsaw/flufl.lock/issues",
    "Documentation": "https://flufllock.readthedocs.io",
    "Home page": "https://flufllock.readthedocs.io",
    "Source code": "https://gitlab.com/warsaw/flufl.lock.git"
  },
  "release_url": "https://pypi.org/project/flufl.lock/8.0.2/",
  "requires_dist": [
    "atpublic",
    "psutil"
  ],
  "requires_python": ">=3.8",
  "summary": "nfs-safe file locking with timeouts for posix and windows",
  "version": "8.0.2",
  "releases": [],
  "developers": [
    "barry@python.org"
  ],
  "kwds": "lockfile locking locks nfs lock",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_flufl.lock",
  "homepage": "",
  "release_count": 29,
  "dependency_ids": [
    "pypi_atpublic",
    "pypi_psutil"
  ]
}