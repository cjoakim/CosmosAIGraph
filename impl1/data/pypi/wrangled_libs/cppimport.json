{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "operating system :: posix",
    "programming language :: c++",
    "programming language :: python :: 3",
    "topic :: software development"
  ],
  "description": "# cppimport - import c++ directly from python! \n\n<p align=center>\n    <a target=\"_blank\" href=\"https://www.python.org/downloads/\" title=\"python version\"><img src=\"https://img.shields.io/badge/python-%3e=_3.7-green.svg\"></a>\n    <a target=\"_blank\" href=\"https://pypi.org/project/cppimport/\" title=\"pypi version\"><img src=\"https://img.shields.io/pypi/v/cppimport?logo=pypi\"></a>\n    <a target=\"_blank\" href=\"https://pypi.org/project/cppimport/\" title=\"pypi\"><img src=\"https://img.shields.io/pypi/dm/cppimport\"></a>\n    <a target=\"_blank\" href=\"license\" title=\"license: mit\"><img src=\"https://img.shields.io/badge/license-mit-blue.svg\"></a>\n    <a target=\"_blank\" href=\"https://github.com/tbenthompson/cppimport/actions\" title=\"test status\"><img src=\"https://github.com/tbenthompson/cppimport/actions/workflows/test.yml/badge.svg\"></a>\n    <a target=\"_blank\" href=\"https://codecov.io/gh/tbenthompson/cppimport\" title=\"code coverage\"><img src=\"https://codecov.io/gh/tbenthompson/cppimport/branch/main/graph/badge.svg?token=gwpx62xmt5\"/></a>\n</a>\n\n</p>\n\n## contributing and architecture\n\nsee [contributing.md](contributing.md) for details on the internals of `cppimport` and how to get involved in development.\n\n## installation\n\ninstall with `pip install cppimport`.\n\n## a quick example\n\nsave the c++ code below as `somecode.cpp`.\n```c++\n// cppimport\n#include <pybind11/pybind11.h>\n\nnamespace py = pybind11;\n\nint square(int x) {\n    return x * x;\n}\n\npybind11_module(somecode, m) {\n    m.def(\"square\", &square);\n}\n/*\n<%\nsetup_pybind11(cfg)\n%>\n*/\n```\n\nthen open a python interpreter and import the c++ extension:\n```python\n>>> import cppimport.import_hook\n>>> import somecode #this will pause for a moment to compile the module\n>>> somecode.square(9)\n81\n```\n\nhurray, you've called some c++ code from python using a combination of `cppimport` and [`pybind11`](https://github.com/pybind/pybind11).  \n\ni'm a big fan of the workflow that this enables, where you can edit both c++ files and python and recompilation happens transparently! it's also handy for quickly whipping together an optimized version of a slow python function.\n\n## an explanation \n\nokay, now that i've hopefully convinced you on how exciting this is, let's get into the details of how to do this yourself. first, the comment at top is essential to opt in to cppimport. don't forget this! (see below for an explanation of why this is necessary.)\n```c++\n// cppimport\n```\n\nthe bulk of the file is a generic, simple [pybind11](https://github.com/pybind/pybind11) extension. we include the `pybind11` headers, then define a simple function that squares `x`, then export that function as part of a python extension called `somecode`.\n\nfinally at the end of the file, there's a section i'll call the \"configuration block\":\n```\n<%\nsetup_pybind11(cfg)\n%>\n```\nthis region surrounded by `<%` and `%>` is a [mako](https://www.makotemplates.org/) code block. the region is evaluated as python code during the build process and provides configuration info like compiler and linker flags to the cppimport build system. \n\nnote that because of the mako pre-processing, the comments around the configuration block may be omitted.  putting the configuration block at the end of the file, while optional, ensures that line numbers remain correct in compilation error messages.\n\n## building for production\nin production deployments you usually don't want to include a c/c++ compiler, all the sources and compile at runtime. therefore, a simple cli utility for pre-compiling all source files is provided. this utility may, for example, be used in ci/cd pipelines. \n\nusage is as simple as\n\n```commandline\npython -m cppimport build\n```\n\nthis will build all `*.c` and `*.cpp` files in the current directory (and it's subdirectories) if they are eligible to be imported (i.e. contain the `// cppimport` comment in the first line).\n\nalternatively, you may specifiy one or more root directories or source files to be built:\n\n```commandline\npython -m cppimport build ./my/directory/ ./my/single/file.cpp\n```\n_note: when specifying a path to a file, the header check (`// cppimport`) is skipped for that file._\n\n### fine-tuning for production\nto further improve startup performance for production builds, you can opt-in to skip the checksum and compiled binary existence checks during importing by either setting the environment variable `cppimport_release_mode` to `true` or setting the configuration from within python:\n```python\ncppimport.settings['release_mode'] = true\n```\n**warning:** make sure to have all binaries pre-compiled when in release mode, as importing any missing ones will cause exceptions. \n\n## frequently asked questions\n\n### what's actually going on?\n\nsometimes python just isn't fast enough. or you have existing code in a c or c++ library. so, you write a python *extension module*, a library of compiled code. i recommend [pybind11](https://github.com/pybind/pybind11) for c++ to python bindings or [cffi](https://cffi.readthedocs.io/en/latest/) for c to python bindings. i've done this a lot over the years. but, i discovered that my productivity is slower when my development process goes from *edit -> test* in just python to *edit -> compile -> test* in python plus c++. so, `cppimport` combines the process of compiling and importing an extension in python so that you can just run `import foobar` and not have to worry about multiple steps. internally, `cppimport` looks for a file `foobar.cpp`. assuming one is found, it's run through the mako templating system to gather compiler options, then it's compiled and loaded as an extension module.\n\n### does cppimport recompile every time a module is imported? \nno! compilation should only happen the first time the module is imported. the c++ source is compared with a checksum on each import to determine if any relevant file has changed. additional dependencies (e.g. header files!) can be tracked by adding to the mako header:\n```python\ncfg['dependencies'] = ['file1.h', 'file2.h']\n```\nthe checksum is computed by simply appending the contents of the extension c++ file together with the files in `cfg['sources']` and `cfg['dependencies']`. \n\n### how can i set compiler or linker args?\n\nstandard distutils configuration options are valid:\n\n```python\ncfg['extra_link_args'] = ['...']\ncfg['extra_compile_args'] = ['...']\ncfg['libraries'] = ['...']\ncfg['include_dirs'] = ['...']\n```\n\nfor example, to use c++11, add:\n```python\ncfg['extra_compile_args'] = ['-std=c++11']\n```\n\n### how can i split my extension across multiple source files?\n\nin the configuration block: \n```python\ncfg['sources'] = ['extra_source1.cpp', 'extra_source2.cpp']\n```\n\n### cppimport isn't doing what i want, can i get more verbose output?\n`cppimport` uses the standard python logging tools. please add logging handlers to either the root logger or the `\"cppimport\"` logger. for example, to output all debug level log messages:\n\n```python\nroot_logger = logging.getlogger()\nroot_logger.setlevel(logging.debug)\n\nhandler = logging.streamhandler(sys.stdout)\nhandler.setlevel(logging.debug)\nformatter = logging.formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\nhandler.setformatter(formatter)\nroot_logger.addhandler(handler)\n```\n\n### how can i force a rebuild even when the checksum matches?\n\nset:\n```python\ncppimport.settings['force_rebuild'] = true\n```\n\nand if this is a common occurence, i would love to hear your use case and why the combination of the checksum, `cfg['dependencies']` and `cfg['sources']` is insufficient!\n\nnote that `force_rebuild` does not work when importing the module concurrently.\n\n### can i import my model concurrently?\n\nit's safe to use `cppimport` to import a module concurrently using multiple threads, processes or even machines!\n\nbefore building a module, `cppimport` obtains a lockfile preventing other processors from building it at the same time - this prevents clashes that can lead to failure.\nother processes will wait maximum 10 mins until the first process has built the module and load it. if your module does not build within 10 mins then it will timeout.\nyou can increase the timeout time in the settings:\n\n```python\ncppimport.settings['lock_timeout'] = 10*60 # 10 mins\n```\n\nyou should not use `force_rebuild` when importing concurrently.\n\n### how can i get information about filepaths in the configuration block?\nthe module name is available as the `fullname` variable and the c++ module file is available as `filepath`.\nfor example,\n```\n<%\nmodule_dir = os.path.dirname(filepath)\n%>\n```\n\n### how can i make compilation faster? \n\nin single file extensions, this is a fundamental issue with c++. heavily templated code is often quite slow to compile. \n\nif your extension has multiple source files using the `cfg['sources']` capability, then you might be hoping for some kind of incremental compilation. for the uninitiated, incremental compilation involves only recompiling those source files that have changed. unfortunately this isn't possible because cppimport is built on top of the setuptools and distutils and these standard library components do not support incremental compilation. \n\ni recommend following the suggestions on [this so answer](http://stackoverflow.com/questions/11013851/speeding-up-build-process-with-distutils). that is:\n\n1. use `ccache` to reduce the cost of rebuilds\n2. enable parallel compilation. this can be done with `cfg['parallel'] = true` in the c++ file's configuration header.\n\nas a further thought, if your extension has many source files and you're hoping to do incremental compiles, that probably indicates that you've outgrown `cppimport` and should consider using a more complete build system like cmake.\n\n### why does the import hook need \"cppimport\" on the first line of the .cpp file?\nmodifying the python import system is a global modification and thus affects all imports from any other package. as a result, when i first implemented `cppimport`, other packages (e.g. `scipy`) suddenly started breaking because import statements internal to those packages were importing c or c++ files instead of the modules they were intended to import. to avoid this failure mode, the import hook uses an \"opt in\" system where c and c++ files can specify they are meant to be used with cppimport by having a comment on the first line that includes the text \"cppimport\". \n\nas an alternative to the import hook, you can use `imp` or `imp_from_filepath`. the `cppimport.imp` and `cppimport.imp_from_filepath` performs exactly the same operation as the import hook but in a slightly more explicit way:\n```\nfoobar = cppimport.imp(\"foobar\")\nfoobar = cppimport.imp_from_filepath(\"src/foobar.cpp\")\n```\nby default, these explicit function do not require the \"cppimport\" keyword on the first line of the c++ source file. \n\n### windows?\nthe ci system does not run on windows. a pr would be welcome adding further windows support. i've used `cppimport` with mingw-w64 and python 3.6 and had good success. i've also had reports that `cppimport` works on windows with python 3.6 and visual c++ 2015 build tools. the main challenge is making sure that distutils is aware of your available compilers. try out the suggestion [here](https://stackoverflow.com/questions/3297254/how-to-use-mingws-gcc-compiler-when-installing-python-package-using-pip).\n\n## cppimport uses the mit license",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "cppimport",
  "package_url": "https://pypi.org/project/cppimport/",
  "project_url": "https://pypi.org/project/cppimport/",
  "project_urls": {
    "Homepage": "https://github.com/tbenthompson/cppimport"
  },
  "release_url": "https://pypi.org/project/cppimport/22.8.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "import c++ files directly from python!",
  "version": "22.8.2",
  "releases": [],
  "developers": [
    "t.ben.thompson@gmail.com"
  ],
  "kwds": "cppimport cppimport_release_mode pypi pybind11 pybind",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_cppimport",
  "homepage": "https://github.com/tbenthompson/cppimport",
  "release_count": 33,
  "dependency_ids": []
}