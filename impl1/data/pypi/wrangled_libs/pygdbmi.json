{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "<h1 align=\"center\">\npygdbmi - get structured output from gdb's machine interface\n</h1>\n\n<p align=\"center\">\n\n<a href=\"https://github.com/cs01/pygdbmi/actions\">\n<img src=\"https://github.com/cs01/pygdbmi/workflows/tests/badge.svg?branch=master\" alt=\"test status\" /></a>\n\n<a href=\"https://badge.fury.io/py/pygdbmi\">\n<img src=\"https://badge.fury.io/py/pygdbmi.svg\" alt=\"pypi version\"/></a>\n\n</p>\n\n**documentation** [https://cs01.github.io/pygdbmi](https://cs01.github.io/pygdbmi)\n\n**source code** [https://github.com/cs01/pygdbmi](https://github.com/cs01/pygdbmi)\n\n---\n\npython (**py**) [**gdb**](https://www.gnu.org/software/gdb/) machine interface [(**mi**)](https://sourceware.org/gdb/onlinedocs/gdb/gdb_002fmi.html)\n\n> gdb/mi is a line based machine oriented text interface to gdb and is activated by specifying using the --interpreter command line option (see mode options). it is specifically intended to support the development of systems which use the debugger as just one small component of a larger system.\n\n## what's in the box?\n\n1.  a function to parse gdb machine interface string output and return structured data types (python dicts) that are json serializable. useful for writing the backend to a gdb frontend. for example, [gdbgui](https://github.com/cs01/gdbgui) uses pygdbmi on the backend.\n2.  a python class to control and interact with gdb as a subprocess\n\nto get [machine interface](https://sourceware.org/gdb/onlinedocs/gdb/gdb_002fmi.html) output from gdb, run gdb with the `--interpreter=mi2` flag like so:\n\n```\ngdb --interpreter=mi2\n```\n\n## installation\n\n    pip install pygdbmi\n\n## compatibility\n\n### operating systems\n\ncross platform support for linux, macos and windows\n\n- linux/unix\n\n  ubuntu 14.04 and 16.04 have been tested to work. other versions likely work as well.\n\n- macos\n\n  note: the error `please check gdb is codesigned - see taskgated(8)` can be fixed by codesigning gdb with [these instructions](http://andresabino.com/2015/04/14/codesign-gdb-on-mac-os-x-yosemite-10-10-2/). if the error is not fixed, please [create an issue in github](https://github.com/cs01/pygdbmi/issues).\n\n- windows\n\n  windows 10 has been tested to work with mingw and cygwin.\n\n### gdb versions\n\n- gdb 7.6+ has been tested. older versions may work as well.\n\n## examples\n\ngdb mi defines a syntax for its output that is suitable for machine readability and scripting: [example output](https://sourceware.org/gdb/onlinedocs/gdb/gdb_002fmi-simple-examples.html#gdb_002fmi-simple-examples):\n\n```\n-> -break-insert main\n<- ^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\",\nenabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",\nfullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],\ntimes=\"0\"}\n<- (gdb)\n```\n\nuse `pygdbmi.gdbmiparser.parse_response` to turn that string output into a json serializable dictionary\n\n```python\nfrom pygdbmi import gdbmiparser\nfrom pprint import pprint\nresponse = gdbmiparser.parse_response('^done,bkpt={number=\"1\",type=\"breakpoint\",disp=\"keep\", enabled=\"y\",addr=\"0x08048564\",func=\"main\",file=\"myprog.c\",fullname=\"/home/myprog.c\",line=\"68\",thread-groups=[\"i1\"],times=\"0\"')\npprint(response)\npprint(response)\n# prints:\n# {'message': 'done',\n#  'payload': {'bkpt': {'addr': '0x08048564',\n#                       'disp': 'keep',\n#                       'enabled': 'y',\n#                       'file': 'myprog.c',\n#                       'fullname': '/home/myprog.c',\n#                       'func': 'main',\n#                       'line': '68',\n#                       'number': '1',\n#                       'thread-groups': ['i1'],\n#                       'times': '0',\n#                       'type': 'breakpoint'}},\n#  'token': none,\n#  'type': 'result'}\n```\n\n## programmatic control over gdb\n\nbut how do you get the gdb output into python in the first place? if you want, `pygdbmi` also has a class to control gdb as subprocess. you can write commands, and get structured output back:\n\n```python\nfrom pygdbmi.gdbcontroller import gdbcontroller\nfrom pprint import pprint\n\n# start gdb process\ngdbmi = gdbcontroller()\nprint(gdbmi.command)  # print actual command run as subprocess\n# load binary a.out and get structured response\nresponse = gdbmi.write('-file-exec-file a.out')\npprint(response)\n# prints:\n# [{'message': 'thread-group-added',\n#   'payload': {'id': 'i1'},\n#   'stream': 'stdout',\n#   'token': none,\n#   'type': 'notify'},\n#  {'message': 'done',\n#   'payload': none,\n#   'stream': 'stdout',\n#   'token': none,\n#   'type': 'result'}]\n```\n\nnow do whatever you want with gdb. all gdb commands, as well as gdb [machine interface commands](<(https://sourceware.org/gdb/onlinedocs/gdb/gdb_002fmi-input-syntax.html#gdb_002fmi-input-syntax)>) are acceptable. gdb mi commands give better structured output that is machine readable, rather than gdb console output. mi commands begin with a `-`.\n\n```python\nresponse = gdbmi.write('-break-insert main')  # machine interface (mi) commands start with a '-'\nresponse = gdbmi.write('break main')  # normal gdb commands work too, but the return value is slightly different\nresponse = gdbmi.write('-exec-run')\nresponse = gdbmi.write('run')\nresponse = gdbmi.write('-exec-next', timeout_sec=0.1)  # the wait time can be modified from the default of 1 second\nresponse = gdbmi.write('next')\nresponse = gdbmi.write('next', raise_error_on_timeout=false)\nresponse = gdbmi.write('next', raise_error_on_timeout=true, timeout_sec=0.01)\nresponse = gdbmi.write('-exec-continue')\nresponse = gdbmi.send_signal_to_gdb('sigkill')  # name of signal is okay\nresponse = gdbmi.send_signal_to_gdb(2)  # value of signal is okay too\nresponse = gdbmi.interrupt_gdb()  # sends sigint to gdb\nresponse = gdbmi.write('continue')\nresponse = gdbmi.exit()\n```\n\n## parsed output format\n\neach parsed gdb response consists of a list of dictionaries. each dictionary has keys `message`, `payload`, `token`, and `type`.\n\n- `message` contains a textual message from gdb, which is not always present. when missing, this is `none`.\n- `payload` contains the content of gdb's output, which can contain any of the following: `dictionary`, `list`, `string`. this too is not always present, and can be `none` depending on the response.\n- `token` if an input command was prefixed with a (optional) token then the corresponding output for that command will also be prefixed by that same token. this field is only present for pygdbmi output types `nofity` and `result`. when missing, this is `none`.\n\nthe `type` is defined based on gdb's various [mi output record types](<(https://sourceware.org/gdb/onlinedocs/gdb/gdb_002fmi-output-records.html#gdb_002fmi-output-records)>), and can be\n\n- `result` - the result of a gdb command, such as `done`, `running`, `error`, etc.\n- `notify` - additional async changes that have occurred, such as breakpoint modified\n- `console` - textual responses to cli commands\n- `log` - debugging messages from gdb's internals\n- `output` - output from target\n- `target` - output from remote target\n- `done` - when gdb has finished its output\n\n## contributing\n\ndocumentation fixes, bug fixes, performance improvements, and functional improvements are welcome. you may want to create an issue before beginning work to make sure i am interested in merging it to the master branch.\n\npygdbmi uses [nox](https://github.com/theacodes/nox) for automation.\n\nsee available tasks with\n\n```\nnox -l\n```\n\nrun tests and lint with\n\n```\nnox -s tests\nnox -s lint\n```\n\npositional arguments passed to `nox -s tests` are passed directly to `pytest`. for instance, to run only the parse tests use\n\n```\nnox -s tests -- tests/test_gdbmiparser.py\n```\n\nsee [`pytest`'s documentation](https://docs.pytest.org/) for more details on how to run tests.\n\nto format code using the correct settings use\n\n```\nnox -s format\n```\n\nor, to format only specified files, use\n\n```\nnox -s format -- example.py pygdbmi/iomanager.py\n```\n\n### making a release\n\nonly maintainers of the [pygdbmi package on pypi](https://pypi.org/project/pygdbmi/) can make a release.\n\nin the following steps, replace these strings with the correct values:\n\n- `<remote>` is the name of the remote for the main pygdbmi repository (for instance, `origin`)\n- `<version>` is the version number chosen in step 2.\n\nto make a release:\n\n1. checkout the `master` branch and pull from the main repository with `git pull <remote> master`\n2. decide the version number for the new release; we follow\n   [semantic versioning](https://semver.org/) but prefixing the version with `0.`: given a version\n   number _0.second.third.fourth_, increment the:\n   - _second_ component when you make incompatible api changes\n   - _third_ component when you add functionality in a backwards compatible manner\n   - _fourth_ component when you make backwards compatible bug fixes\n3. update `changelog.md` to list the chosen version number instead of `## dev`\n4. update `__version__` in `pygdbmi/__init__.py` to the chosen version number\n5. create a branch, for instance using `git checkout -b before-release-<version>`\n6. commit your changes, for instance using `git commit -a -m 'bump version to <version> for release'`\n7. check that the docs look fine by serving them locally with `nox -s serve_docs`\n8. push the branch, for instance with `git push --set-upstream <remote> before-release-<version>`\n9. if tests pass on the pr you created, you can merge into `master`\n10. go to the [new release page](https://github.com/cs01/pygdbmi/releases/new) and prepare the\n    release:\n    - add a tag in the form `v<version>` (for example `v0.1.2.3`)\n    - set the title to `pygdbmi v<version>` (for example `pygdbmi v0.1.2.3`)\n    - copy and paste the section for the new release only from `changelog.md` excluding the line\n      with the version number\n    - press \u201cpublish release\u201d\n10. publish the release to pypi with `nox -s publish`\n11. publish the docs with `nox -s publish_docs`\n11. verify that the [pypi page for pygdbmi](https://pypi.org/project/pygdbmi/) looks correct\n12. verify that the [published docs](https://cs01.github.io/pygdbmi/) look correct\n13. prepare for changes for the next release by adding something like this above the previous\n    entries in `changelog.md` (where `<version+1>` is `<version>` with the last digit increaded\n    by 1):\n\n    ```\n    ## <version+1>.dev0\n\n    - *replace this line with new entries*\n    ```\n\n14. create a branch for the changes with `git checkout -b after-release-<version>`\n15. commit the change with `git commit -m 'prepare for work on the next release' changelog.md`\n16. push the branch with `git push --set-upstream <remote> after-release-<version>`\n17. if tests pass, merge into `master`\n\n## similar projects\n\n- [tsgdbmi](https://github.com/guyutongxue/tsgdbmi) a port of pygdbmi to typescript\n- [danielzfranklin/gdbmi](https://github.com/danielzfranklin/gdbmi) a port of pygdbmi to rust\n\n## projects using pygdbmi\n\n- [gdbgui](https://github.com/cs01/gdbgui) implements a browser-based frontend to gdb, using pygdbmi on the backend\n- [pince](https://github.com/korcankaraokcu/pince) is a gdb frontend that aims to provide a reverse engineering tool and a reusable library focused on games. it uses pygdbmi to parse gdb/mi based output for some functions\n- [avatar\u00b2](https://github.com/avatartwo/avatar2) is an orchestration framework for reversing and analysing firmware of embedded devices. it utilizes pygdbmi for internal communication to different analysis targets.\n- [udb](https://undo.io/udb) is a proprietary time-travel debugger for c and c++ based on gdb. it uses pygdbmi in its extensive test suite to parse the debugger's output.\n- know of another project? create a pr and add it here.\n\n## authors\n\n- [chad smith](https://github.com/cs01) (main author and creator).\n- [marco barisione](http://www.barisione.org/) (co-maintainer).\n- [the community](https://github.com/cs01/pygdbmi/graphs/contributors). thanks especially to @mariusmue, @bobthekingofegypt, @mouuff, and @felipesere.\n",
  "docs_url": null,
  "keywords": "gdb,python,machine-interface,parse,frontend",
  "license": "mit",
  "name": "pygdbmi",
  "package_url": "https://pypi.org/project/pygdbmi/",
  "project_url": "https://pypi.org/project/pygdbmi/",
  "project_urls": {
    "Homepage": "https://github.com/cs01/pygdbmi"
  },
  "release_url": "https://pypi.org/project/pygdbmi/0.11.0.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "parse gdb machine interface output with python",
  "version": "0.11.0.0",
  "releases": [],
  "developers": [
    "chad_smith",
    "grassfedcode@gmail.com"
  ],
  "kwds": "pygdbmi test_gdbmiparser gdbmiparser gdbmi tsgdbmi",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pygdbmi",
  "homepage": "https://github.com/cs01/pygdbmi",
  "release_count": 29,
  "dependency_ids": []
}