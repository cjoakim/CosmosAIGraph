{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v3 or later (lgplv3+)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries"
  ],
  "description": "introduction\n============\nthis module provides a collection of decorators that makes it easy to\nwrite software using contracts.\n\ncontracts are a debugging and verification tool.  they are declarative\nstatements about what states a program must be in to be considered\n\"correct\" at runtime.  they are similar to assertions, and are verified\nautomatically at various well-defined points in the program.  contracts can\nbe specified on functions and on classes.\n\ncontracts serve as a form of documentation and a way of formally\nspecifying program behavior.  good practice often includes writing all of\nthe contracts first, with these contract specifying the exact expected\nstate before and after each function or method call and the things that\nshould always be true for a given class of object.\n\ncontracts consist of two parts: a description and a condition.  the\ndescription is simply a human-readable string that describes what the\ncontract is testing, while the condition is a single function that tests\nthat condition.  the condition is executed automatically and passed certain\narguments (which vary depending on the type of contract), and must return\na boolean value: true if the condition has been met, and false otherwise.\n\nlegacy python support\n=====================\nthis module supports versions of python >= 3.5; that is, versions with\nsupport for \"async def\" functions.  there is a branch of this module that\nis kept compatible to the greatest possible degree for versions of python\nearlier than 3.5 (including python 2.7).\n\nthe python 2 and <= 3.5 branch is available at\nhttps://github.com/deadpixi/contracts/tree/python2\n\nthis legacy-compatible version is also distributed on pypi along the 0.5.x\nbranch; this branch will kept compatible with newer versions to the greatest\nextent possible.\n\nthat branch is a drop-in replacement for this module and includes all\nfunctionality except support for \"async def\" functions.\n\npreconditions and postconditions\n================================\ncontracts on functions consist of preconditions and postconditions.\na precondition is declared using the `requires` decorator, and describes\nwhat must be true upon entrance to the function. the condition function\nis passed an arguments object, which as as its attributes the arguments\nto the decorated function:\n\n    >>> @require(\"`i` must be an integer\", lambda args: isinstance(args.i, int))\n    ... @require(\"`j` must be an integer\", lambda args: isinstance(args.j, int))\n    ... def add2(i, j):\n    ...   return i + j\n\nnote that an arbitrary number of preconditions can be stacked on top of\neach other.\n\nthese decorators have declared that the types of both arguments must be\nintegers.  calling the `add2` function with the correct types of arguments\nworks:\n\n    >>> add2(1, 2)\n    3\n\nbut calling with incorrect argument types (violating the contract) fails\nwith a preconditionerror (a subtype of assertionerror):\n\n    >>> add2(\"foo\", 2)\n    traceback (most recent call last):\n    preconditionerror: `i` must be an integer\n\nfunctions can also have postconditions, specified using the `ensure`\ndecorator.  postconditions describe what must be true after the function\nhas successfully returned.  like the `require` decorator, the `ensure`\ndecorator is passed an argument object.  it is also passed an additional\nargument, which is the result of the function invocation.  for example:\n\n    >>> @require(\"`i` must be a positive integer\",\n    ...          lambda args: isinstance(args.i, int) and args.i > 0)\n    ... @require(\"`j` must be a positive integer\",\n    ...          lambda args: isinstance(args.j, int) and args.j > 0)\n    ... @ensure(\"the result must be greater than either `i` or `j`\",\n    ...         lambda args, result: result > args.i and result > args.j)\n    ... def add2(i, j):\n    ...     if i == 7:\n    ...        i = -7 # intentionally broken for purposes of example\n    ...     return i + j\n\nwe can now call the function and ensure that everything is working correctly:\n\n    >>> add2(1, 3)\n    4\n\nexcept that the function is broken in unexpected ways:\n\n    >>> add2(7, 4)\n    traceback (most recent call last):\n    postconditionerror: the result must be greater than either `i` or `j`\n\nthe function specifying the condition doesn't have to be a lambda; it can be\nany function, and pre- and postconditions don't have to actually reference\nthe arguments or results of the function at all.  they can simply check\nthe function's environments and effects:\n\n    >>> names = set()\n    >>> def exists_in_database(x):\n    ...   return x in names\n    >>> @require(\"`name` must be a string\", lambda args: isinstance(args.name, str))\n    ... @require(\"`name` must not already be in the database\",\n    ...          lambda args: not exists_in_database(args.name.strip()))\n    ... @ensure(\"the normalized version of the name must be added to the database\",\n    ...         lambda args, result: exists_in_database(args.name.strip()))\n    ... def add_to_database(name):\n    ...     if name not in names and name != \"rob\": # intentionally broken\n    ...         names.add(name.strip())\n\n    >>> add_to_database(\"james\")\n    >>> add_to_database(\"marvin\")\n    >>> add_to_database(\"marvin\")\n    traceback (most recent call last):\n    preconditionerror: `name` must not already be in the database\n    >>> add_to_database(\"rob\")\n    traceback (most recent call last):\n    postconditionerror: the normalized version of the name must be added to the database\n\nall of the various calling conventions of python are supported:\n\n    >>> @require(\"`a` is an integer\", lambda args: isinstance(args.a, int))\n    ... @require(\"`b` is a string\", lambda args: isinstance(args.b, str))\n    ... @require(\"every member of `c` should be a boolean\",\n    ...          lambda args: all(isinstance(x, bool) for x in args.c))\n    ... def func(a, b=\"foo\", *c):\n    ...     pass\n\n    >>> func(1, \"foo\", true, true, false)\n    >>> func(b=\"foo\", a=7)\n    >>> args = {\"a\": 8, \"b\": \"foo\"}\n    >>> func(**args)\n    >>> args = (1, \"foo\", true, true, false)\n    >>> func(*args)\n    >>> args = {\"a\": 9}\n    >>> func(**args)\n    >>> func(10)\n\na common contract is to validate the types of arguments. to that end,\nthere is an additional decorator, `types`, that can be used\nto validate arguments' types:\n\n    >>> class exampleclass:\n    ...     pass\n\n    >>> @types(a=int, b=str, c=(type(none), exampleclass)) # or types.nonetype, if you prefer\n    ... @require(\"a must be nonzero\", lambda args: args.a != 0)\n    ... def func(a, b, c=38):\n    ...     return \" \".join(str(x) for x in [a, b])\n\n    >>> func(1, \"foo\", exampleclass())\n    '1 foo'\n\n    >>> func(1.0, \"foo\", exampleclass) # invalid type for `a`\n    traceback (most recent call last):\n    preconditionerror: the types of arguments must be valid\n\n    >>> func(1, \"foo\") # invalid type (the default) for `c`\n    traceback (most recent call last):\n    preconditionerror: the types of arguments must be valid\n\ncontracts on classes\n====================\nthe `require` and `ensure` decorators can be used on class methods too,\nnot just bare functions:\n\n    >>> class foo:\n    ...     @require(\"`name` should be nonempty\", lambda args: len(args.name) > 0)\n    ...     def __init__(self, name):\n    ...         self.name = name\n\n    >>> foo = foo()\n    traceback (most recent call last):\n    typeerror: __init__ missing required positional argument: 'name'\n\n    >>> foo = foo(\"\")\n    traceback (most recent call last):\n    preconditionerror: `name` should be nonempty\n\nclasses may also have an additional sort of contract specified over them:\nthe invariant.  an invariant, created using the `invariant` decorator,\nspecifies a condition that must always be true for instances of that class.\nin this case, \"always\" means \"before invocation of any method and after\nits return\" -- methods are allowed to violate invariants so long as they\nare restored prior to return.\n\ninvariant contracts are passed a single variable, a reference to the\ninstance of the class. for example:\n\n    >>> @invariant(\"inner list can never be empty\", lambda self: len(self.lst) > 0)\n    ... @invariant(\"inner list must consist only of integers\",\n    ...            lambda self: all(isinstance(x, int) for x in self.lst))\n    ... class nonemptylist:\n    ...     @require(\"initial list must be a list\", lambda args: isinstance(args.initial, list))\n    ...     @require(\"initial list cannot be empty\", lambda args: len(args.initial) > 0)\n    ...     @ensure(\"the list instance variable is equal to the given argument\",\n    ...             lambda args, result: args.self.lst == args.initial)\n    ...     @ensure(\"the list instance variable is not an alias to the given argument\",\n    ...             lambda args, result: args.self.lst is not args.initial)\n    ...     def __init__(self, initial):\n    ...         self.lst = initial[:]\n    ...\n    ...     def get(self, i):\n    ...         return self.lst[i]\n    ...\n    ...     def pop(self):\n    ...         self.lst.pop()\n    ...\n    ...     def as_string(self):\n    ...         # build up a string representation using the `get` method,\n    ...         # to illustrate methods calling methods with invariants.\n    ...         return \",\".join(str(self.get(i)) for i in range(0, len(self.lst)))\n\n    >>> nl = nonemptylist([1,2,3])\n    >>> nl.pop()\n    >>> nl.pop()\n    >>> nl.pop()\n    traceback (most recent call last):\n    postconditionerror: inner list can never be empty\n\n    >>> nl = nonemptylist([\"a\", \"b\", \"c\"])\n    traceback (most recent call last):\n    postconditionerror: inner list must consist only of integers\n\nviolations of invariants are ignored in the following situations:\n\n    - before calls to __init__ and __new__ (since the object is still\n      being initialized)\n\n    - before and after calls to any method whose name begins with \"__\",\n      except for methods implementing arithmetic and comparison operations\n      and container type emulation (because such methods are private and\n      expected to manipulate the object's inner state, plus things get hairy\n      with certain applications of `__getattr(ibute)?__`)\n\n    - before and after calls to methods added from outside the initial\n      class definition (because invariants are processed only at class\n      definition time)\n\n    - before and after calls to classmethods, since they apply to the class\n      as a whole and not any particular instance\n\nfor example:\n\n    >>> @invariant(\"`always` should be true\", lambda self: self.always)\n    ... class foo:\n    ...     always = true\n    ...\n    ...     def get_always(self):\n    ...         return self.always\n    ...\n    ...     @classmethod\n    ...     def break_everything(cls):\n    ...         cls.always = false\n\n    >>> x = foo()\n    >>> x.get_always()\n    true\n    >>> x.break_everything()\n    >>> x.get_always()\n    traceback (most recent call last):\n    preconditionerror: `always` should be true\n\nalso note that if a method invokes another method on the same object,\nall of the invariants will be tested again:\n\n    >>> nl = nonemptylist([1,2,3])\n    >>> nl.as_string() == '1,2,3'\n    true\n\ntransforming data in contracts\n==============================\nin general, you should avoid transforming data inside a contract; contracts\nthemselves are supposed to be side-effect-free.\n\nhowever, this is not always possible in python.\n\ntake, for example, iterables passed as arguments. we might want to verify\nthat a given set of properties hold for every item in the iterable. the\nobvious solution would be to do something like this:\n\n    >>> @require(\"every item in `l` must be > 0\", lambda args: all(x > 0 for x in args.l))\n    ... def my_func(l):\n    ...     return sum(l)\n\nthis works well in most situations:\n\n    >>> my_func([1, 2, 3])\n    6\n    >>> my_func([0, -1, 2])\n    traceback (most recent call last):\n    preconditionerror: every item in `l` must be > 0\n\nbut it fails in the case of a generator:\n\n    >>> def iota(n):\n    ...     for i in range(1, n):\n    ...         yield i\n\n    >>> sum(iota(5))\n    10\n    >>> my_func(iota(5))\n    0\n\nthe call to `my_func` has a result of 0 because the generator was consumed\ninside the `all` call inside the contract. obviously, this is problematic.\n\nsadly, there is no generic solution to this problem. in a statically-typed\nlanguage, the compiler can verify that some properties of infinite lists\n(though not all of them, and what exactly depends on the type system).\n\nwe get around that limitation here using an additional decorator, called\n`transform` that transforms the arguments to a function, and a function\ncalled `rewrite` that rewrites argument tuples.\n\nfor example:\n\n    >>> @transform(lambda args: rewrite(args, l=list(args.l)))\n    ... @require(\"every item in `l` must be > 0\", lambda args: all(x > 0 for x in args.l))\n    ... def my_func(l):\n    ...     return sum(l)\n    >>> my_func(iota(5))\n    10\n\nnote that this does not completely solve the problem of infinite sequences,\nbut it does allow for verification of any desired prefix of such a sequence.\n\nthis works for class methods too, of course:\n\n    >>> class testclass:\n    ...     @transform(lambda args: rewrite(args, l=list(args.l)))\n    ...     @require(\"every item in `l` must be > 0\", lambda args: all(x > 0 for x in args.l))\n    ...     def my_func(self, l):\n    ...         return sum(l)\n    >>> testclass().my_func(iota(5))\n    10\n\ncontracts on asynchronous functions (aka coroutine functions)\n=============================================================\ncontracts can be placed on coroutines (that is, async functions):\n\n    >>> import asyncio\n    >>> @require(\"`a` is an integer\", lambda args: isinstance(args.a, int))\n    ... @require(\"`b` is a string\", lambda args: isinstance(args.b, str))\n    ... @require(\"every member of `c` should be a boolean\",\n    ...          lambda args: all(isinstance(x, bool) for x in args.c))\n    ... async def func(a, b=\"foo\", *c):\n    ...     await asyncio.sleep(1)\n\n    >>> asyncio.get_event_loop().run_until_complete(\n    ...     func( 1, \"foo\", true, true, false))\n\npredicates functions themselves cannot be coroutines, as this could\ninfluence the run loop:\n\n    >>> async def coropred_aisint(e):\n    ...     await asyncio.sleep(1)\n    ...     return isinstance(getattr(e, 'a'), int)\n    >>> @require(\"`a` is an integer\", coropred_aisint)\n    ... @require(\"`b` is a string\", lambda args: isinstance(args.b, str))\n    ... @require(\"every member of `c` should be a boolean\",\n    ...          lambda args: all(isinstance(x, bool) for x in args.c))\n    ... async def func(a, b=\"foo\", *c):\n    ...     await asyncio.sleep(1)\n    traceback (most recent call last):\n    assertionerror: contract predicates cannot be coroutines\n\ncontracts and debugging\n=======================\ncontracts are a documentation and testing tool; they are not intended\nto be used to validate user input or implement program logic.  indeed,\nrunning python with `__debug__` set to false (e.g. by calling the python\nintrepreter with the \"-o\" option) disables contracts.\n\ntesting this module\n===================\nthis module has embedded doctests that are run with the module is invoked\nfrom the command line.  simply run the module directly to run the tests.\n\ncontact information and licensing\n=================================\nthis module has a home page at `github <https://github.com/deadpixi/contracts>`_.\n\nthis module was written by rob king (jking@deadpixi.com).\n\nthis program is free software: you can redistribute it and/or modify\nit under the terms of the gnu lesser general public license as published by\nthe free software foundation, either version 3 of the license, or\n(at your option) any later version.\n\nthis program is distributed in the hope that it will be useful,\nbut without any warranty; without even the implied warranty of\nmerchantability or fitness for a particular purpose.  see the\ngnu lesser general public license for more details.\n\nyou should have received a copy of the gnu lesser general public license\nalong with this program.  if not, see <http://www.gnu.org/licenses/>.",
  "docs_url": null,
  "keywords": "",
  "license": "https://www.gnu.org/licenses/lgpl.txt",
  "name": "dpcontracts",
  "package_url": "https://pypi.org/project/dpcontracts/",
  "project_url": "https://pypi.org/project/dpcontracts/",
  "project_urls": {
    "Homepage": "https://github.com/deadpixi/contracts"
  },
  "release_url": "https://pypi.org/project/dpcontracts/0.6.0/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "a simple implementation of contracts for python.",
  "version": "0.6.0",
  "releases": [],
  "developers": [
    "jking@deadpixi.com",
    "rob_king"
  ],
  "kwds": "python python2 contracts documentation module",
  "license_kwds": "https://www.gnu.org/licenses/lgpl.txt",
  "libtype": "pypi",
  "id": "pypi_dpcontracts",
  "homepage": "https://github.com/deadpixi/contracts",
  "release_count": 5,
  "dependency_ids": []
}