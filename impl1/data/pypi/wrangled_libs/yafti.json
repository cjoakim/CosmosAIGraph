{
  "classifiers": [
    "environment :: x11 applications :: gtk",
    "framework :: asyncio",
    "intended audience :: end users/desktop",
    "license :: other/proprietary license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.11",
    "topic :: system :: software distribution"
  ],
  "description": "# yet another first time installer\n\nthis application is responsible for installing flatpaks on first boot after a user finishes installation. \nit is intended as a replacement for custom zenity dialogs. \n\n## project goals\n\n* config file driven via json/yaml\n* support for arbitrary pre and post-install commands\n* configuration driven screens\n* screen independent state management with ability to set defaults\n* extensible with drop-in python classes / plugins to extend functionality\n\n## core features\n\nthese are goals for each feature of the first time installer:\n\n### title screen\n\nthe title screen will be comprised of three primary elements. an image/icon, a header/primary text, and a paragraph description text.\n\n```\n\n         icon\n      title text\n\n  this is a description\n  to accompany the title\n  screen.\n```\n\n### packages screen\n\ndisplay several groups of packages to install, allow for expansion of each group to individually select discrete packages or toggle the entire group on/off.\n\neg:\n```\ncore                [/] >\ngaming              [/] >\noffice              [/] >\n```\n\nexpanding core would reveal\n\n```\ncore                [/] v\n  firefox           [x]\n  calculator        [x]\n  text editor       [x]\n  clocks            [x]\n  fonts             [x]\ngaming              [/] >\noffice              [/] >\n```\n\nthe application then installs the flatpaks. plugins for other packages systems may/can be developed.\n\n### configuration\n\n```yaml\ntitle: ublue first boot\nproperties:\n  mode: \"run-on-change\"\n  path: \"~/.config/yafti/last-run\"\nactions:\n  pre:\n  - run: /full/path/to/bin --with --params\n  - run: /another/command run\n  - yafti.plugin.flatpak:\n      install: org.gnome.calculator\n  post:\n  - run: /run/these/commands --after --all --screens\nscreens:\n  first-screen:\n    source: yafti.screen.title\n    values:\n      title: \"that was pretty cool\"\n      icon: \"/path/to/icon\"\n      description: |\n        time to play overwatch\n  applications:\n    source: yafti.screen.package\n    values:\n      title: package installation\n      show_terminal: true\n      package_manager: yafti.plugin.flatpak\n      groups:\n        core:\n          description: all the good stuff\n          packages:\n          - calculator: org.gnome.calculator\n          - firefox: org.mozilla.firefox\n        gaming:\n          description: games games games\n          packages:\n          - steam: com.valvesoftware.steam\n          - games: org.gnome.games\n        office:\n          description: all the work stuff\n          packages:\n          - libreoffice: org.libreoffice.libreoffice\n          - calendar: org.gnome.calendar\n  final-screen:\n    source: yafti.screen.title\n    values:\n      title: \"all done\"\n      icon: \"/path/to/icon\"\n      description: |\n        thanks for installing, join the community, next steps\n```\n\n## development\n\nthis project uses poetry and python 3.11. make sure you have python 3.11 and [poetry installed](https://python-poetry.org/docs/). checkout the repository and navigate to root project directory.\n\n### prerequisites\n\nif you're on a ublue / immutable os, you'll need to run these and the poetry install in a toolbox.\n\n```\nsudo dnf install python3-devel cairo-devel gobject-introspection-devel cairo-gobject-devel\npoetry install\n```\n\n### running\n\n```\npoetry run python -m yafti tests/example.yml\n```\n\nthis will launch the yafti window.\n\n#### running from a containerfile\n\none of yafti's main use cases is to be used in containerfiles to handle installation of flatpaks on first boot.\nadd this to your containerfile to add yafti to your image:\n\n    run pip install --prefix=/usr yafti\n    \nadditionally, you need a script to copy over the .desktop file to the user's home directory:\n- [example firstboot script](https://github.com/ublue-os/bluefin/blob/main/etc/profile.d/bluefin-firstboot.sh)\n- [example firstboot .desktop file](https://github.com/ublue-os/bluefin/blob/main/etc/skel.d/.config/autostart/bluefin-firstboot.desktop)\n\nthen add a file in `/etc/yafti.yml` with your customizations. check the [example file](https://github.com/ublue-os/yafti/blob/main/tests/example.yml) for ideas. \n\n### testing\n\nthis project uses pytest, black, isort, and ruff for testing and linting.\n\n```\npoetry run pytest --cov=yafti --cov-report=term-missing\npoetry run black yafti\npoetry run isort yafti\npoetry run ruff yafti\n```\n\n## contributing\n\nthis project follows a fork and pull request syle of contribution.\n\n### creating a fork\n\njust head over to the github page and [click the \"fork\" button](https://help.github.com/articles/fork-a-repo). once you've done that, you can use your favorite git client to clone your repo or just head straight to the command line:\n\n```shell\n# clone your fork to your local machine\ngit clone git@github.com:username/forked-project.git\n```\n\n### keeping your fork up to date\n\nwhile this isn't an absolutely necessary step, if you plan on doing anything more than just a tiny quick fix, you'll want to make sure you keep your fork up to date by tracking the original \"upstream\" repo that you forked. you can do this by using [the github ui](https://help.github.com/articles/syncing-a-fork) or locally by adding this repo as an upstream.\n\n```shell\n# add 'upstream' repo to list of remotes\ngit remote add upstream https://github.com/ublue-os/yafti.git\n\n# verify the new remote named 'upstream'\ngit remote -v\n```\n\nwhenever you want to update your fork with the latest upstream changes, you'll need to first fetch the upstream repo's branches and latest commits to bring them into your repository:\n\n```shell\n# fetch from upstream remote\ngit fetch upstream\n\n# view all branches, including those from upstream\ngit branch -va\n```\n\nnow, checkout your own main branch and merge the upstream repo's main branch:\n\n```shell\n# checkout your main branch and merge upstream\ngit checkout main\ngit merge --ff-only upstream/main\n```\n\nif there are no unique commits on the local main branch, git will simply perform a fast-forward. however, if you have been making changes on main (in the vast majority of cases you probably shouldn't be - [see the next section](#doing-your-work), you may have to deal with conflicts. when doing so, be careful to respect the changes made upstream.\n\nnow, your local main branch is up-to-date with everything modified upstream.\n\n### doing your work\n\n#### create a branch\n\nwhenever you begin work on a new feature or bugfix, it's important that you create a new branch. not only is it proper git workflow, but it also keeps your changes organized and separated from the main branch so that you can easily submit and manage multiple pull requests for every task you complete.\n\nto create a new branch and start working on it:\n\n```shell\n# checkout the main branch - you want your new branch to come from main\ngit checkout main\n\n# create a new branch named newfeature (give your branch its own simple informative name)\ngit checkbout -b newfeature\n```\n\nnow, go to town hacking away and making whatever changes you want to.\n\n#### commit messages\n\nwe use [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) and enforce them with a bot to keep the changelogs tidy:\n\n```\nchore: add oyster build script\ndocs: explain hat wobble\nfeat: add beta sequence\nfix: remove broken confirmation message\nrefactor: share logic between 4d3d3d3 and flarhgunnstow\nstyle: convert tabs to spaces\ntest: ensure tayne retains clothing\n```\n\nif you have multiple commits, when [submitting your chages](#submitting-a-pull-request), make sure to use a conventional commit style pr title as this project does squash merges and that will be used as your contribution.\n\n### submitting a pull request\n\n#### cleaning up your work\n\nprior to submitting your pull request, you might want to do a few things to clean up your branch and make it as simple as possible for the original repo's maintainer to test, accept, and merge your work.\n\nif any commits have been made to the upstream main branch, you should rebase your feature branch so that merging it will be a simple fast-forward that won't require any conflict resolution work.\n\n```shell\n# fetch upstream main and merge with your repo's main branch\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n\n# if there were any new commits, rebase your feature branch\ngit checkout newfeature\ngit rebase main\n```\n\n#### submitting\n\nonce you've committed and pushed all of your changes to github, go to the page for your fork on github, select your feature branch, and click the pull request button. if you need to make any adjustments to your pull request, just push the updates to github. your pull request will automatically track the changes on your feature branch and update.\n\n### accepting and merging a pull request\n\ntake note that unlike the previous sections which were written from the perspective of someone that created a fork and generated a pull request, this section is written from the perspective of the original repository owner who is handling an incoming pull request. thus, where the \"forker\" was referring to the original repository as `upstream`, we're now looking at it as the owner of that original repository and the standard `origin` remote.\n\n#### checking out and testing pull requests\n\nthere are multiple ways to [check out a pull request locally](https://help.github.com/articles/checking-out-pull-requests-locally). this way uses standard git operations to complete. open up the `.git/config` file and add a new line under `[remote \"origin\"]`:\n\n```\nfetch = +refs/pull/*/head:refs/pull/origin/*\n```\n\nnow you can fetch and checkout any pull request so that you can test them:\n\n```shell\n# fetch all pull request branches\ngit fetch origin\n\n# checkout out a given pull request branch based on its number\ngit checkout -b 9001 pull/origin/9001\n```\n\nkeep in mind that these branches will be read only and you won't be able to push any changes.\n\n#### automatically merging a pull request\nin cases where the merge would be a simple fast-forward, you can automatically do the merge by  clicking the button on the pull request page on github.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "yafti",
  "package_url": "https://pypi.org/project/yafti/",
  "project_url": "https://pypi.org/project/yafti/",
  "project_urls": {
    "Homepage": "https://github.com/ublue-os/yafti",
    "Repository": "https://github.com/ublue-os/yafti"
  },
  "release_url": "https://pypi.org/project/yafti/0.8.0/",
  "requires_dist": [
    "pydantic (==1.10.2)",
    "pygobject (>=3.42.2,<4.0.0)",
    "pyyaml (>=6.0,<7.0)",
    "gbulb (>=0.6.4,<0.7.0)",
    "rich (>=13.3.2,<14.0.0)",
    "typer (>=0.7,<0.10)"
  ],
  "requires_python": ">=3.11,<4.0",
  "summary": "yet another first time installer",
  "version": "0.8.0",
  "releases": [],
  "developers": [
    "marco@ceppi.net",
    "marco_ceppi"
  ],
  "kwds": "packages installer customizations package_manager ui",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_yafti",
  "homepage": "https://github.com/ublue-os/yafti",
  "release_count": 13,
  "dependency_ids": [
    "pypi_gbulb",
    "pypi_pydantic",
    "pypi_pygobject",
    "pypi_pyyaml",
    "pypi_rich",
    "pypi_typer"
  ]
}