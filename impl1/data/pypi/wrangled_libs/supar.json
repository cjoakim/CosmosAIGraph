{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "topic :: scientific/engineering :: artificial intelligence",
    "topic :: text processing :: linguistic"
  ],
  "description": "# supar\n\n[![build](https://github.com/yzhangcs/parser/workflows/build/badge.svg)](https://github.com/yzhangcs/parser/actions)\n[![docs](https://readthedocs.org/projects/parser/badge/?version=latest)](https://parser.readthedocs.io/en/latest)\n[![release](https://img.shields.io/github/v/release/yzhangcs/parser)](https://github.com/yzhangcs/parser/releases)\n[![downloads](https://img.shields.io/github/downloads/yzhangcs/parser/total)](https://pypistats.org/packages/supar)\n[![license](https://img.shields.io/github/license/yzhangcs/parser)](https://github.com/yzhangcs/parser/blob/master/license)\n\na python package designed for structured prediction, including reproductions of many state-of-the-art syntactic/semantic parsers (with pretrained models for more than 19 languages), and\n\n* dependency parser\n  * biaffine ([dozat and manning, 2017](https://openreview.net/forum?id=hk95pk9le))\n  * crf/crf2o ([zhang et al., 2020a](https://aclanthology.org/2020.acl-main.302))\n* constituency parser\n  * crf ([zhang et al., 2020b](https://www.ijcai.org/proceedings/2020/560/))\n* semantic dependency parser\n  * biaffine ([dozat and manning, 2018](https://aclanthology.org/p18-2077))\n  * mfvi/lbp ([wang et al, 2019](https://aclanthology.org/p18-2077))\n\nhighly-parallelized implementations of several well-known structured prediction algorithms.[^1]\n\n* tree\n  * matrixtree ([koo et al., 2007](https://www.aclweb.org/anthology/d07-1015); [ma and hovy, 2017](https://aclanthology.org/i17-1007))\n  * dependencycrf ([eisner et al., 2000](https://www.cs.jhu.edu/~jason/papers/eisner.iwptbook00.pdf); [zhang et al., 2020](https://aclanthology.org/2020.acl-main.302))\n  * dependency2ocrf ([mcdonald et al., 2006](https://www.aclweb.org/anthology/e06-1011); [zhang et al., 2020](https://aclanthology.org/2020.acl-main.302))\n  * constituencycrf ([stern et al. 2017](https://aclanthology.org/p17-1076); [zhang et al., 2020b](https://www.ijcai.org/proceedings/2020/560/))\n* linear chain:\n  * linearchaincrf ([lafferty et al., 2001](http://www.aladdin.cs.cmu.edu/papers/pdfs/y2001/crf.pdf))\n\n## installation\n\n`supar` can be installed via pip:\n```sh\n$ pip install -u supar\n```\nor installing from source is also permitted:\n```sh\n$ pip install -u git+https://github.com/yzhangcs/parser\n```\n\nas a prerequisite, the following requirements should be satisfied:\n* `python`: >= 3.7\n* [`pytorch`](https://github.com/pytorch/pytorch): >= 1.7\n* [`transformers`](https://github.com/huggingface/transformers): >= 4.0\n\n## usage\n\nyou can download the pretrained model and parse sentences with just a few lines of code:\n```py\n>>> from supar import parser\n>>> parser = parser.load('biaffine-dep-en')\n>>> dataset = parser.predict('i saw sarah with a telescope.', lang='en', prob=true, verbose=false)\n```\nby default, we use [`stanza`](https://github.com/stanfordnlp/stanza) internally to tokenize plain texts for parsing.\nyou only need to specify the language code `lang` for tokenization.\n\nthe call to `parser.predict` will return an instance of `supar.utils.dataset` containing the predicted results.\nyou can either access each sentence held in `dataset` or an individual field of all results.\nprobabilities can be returned along with the results if `prob=true`.\n```py\n>>> dataset[0]\n1       i       _       _       _       _       2       nsubj   _       _\n2       saw     _       _       _       _       0       root    _       _\n3       sarah   _       _       _       _       2       dobj    _       _\n4       with    _       _       _       _       2       prep    _       _\n5       a       _       _       _       _       6       det     _       _\n6       telescope       _       _       _       _       4       pobj    _       _\n7       .       _       _       _       _       2       punct   _       _\n\n>>> print(f\"arcs:  {dataset.arcs[0]}\\n\"\n          f\"rels:  {dataset.rels[0]}\\n\"\n          f\"probs: {dataset.probs[0].gather(1,torch.tensor(dataset.arcs[0]).unsqueeze(1)).squeeze(-1)}\")\narcs:  [2, 0, 2, 2, 6, 4, 2]\nrels:  ['nsubj', 'root', 'dobj', 'prep', 'det', 'pobj', 'punct']\nprobs: tensor([1.0000, 0.9999, 0.9966, 0.8944, 1.0000, 1.0000, 0.9999])\n```\n\n`supar` also supports parsing from tokenized sentences or from file.\nfor bilstm-based semantic dependency parsing models, lemmas and pos tags are needed.\n\n```py\n>>> import os\n>>> import tempfile\n>>> dep = parser.load('biaffine-dep-en')\n>>> dep.predict(['i', 'saw', 'sarah', 'with', 'a', 'telescope', '.'], verbose=false)[0]\n1       i       _       _       _       _       2       nsubj   _       _\n2       saw     _       _       _       _       0       root    _       _\n3       sarah   _       _       _       _       2       dobj    _       _\n4       with    _       _       _       _       2       prep    _       _\n5       a       _       _       _       _       6       det     _       _\n6       telescope       _       _       _       _       4       pobj    _       _\n7       .       _       _       _       _       2       punct   _       _\n\n>>> path = os.path.join(tempfile.mkdtemp(), 'data.conllx')\n>>> with open(path, 'w') as f:\n...     f.write('''# text = but i found the location wonderful and the neighbors very kind.\n1\\tbut\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n2\\ti\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n3\\tfound\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n4\\tthe\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n5\\tlocation\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n6\\twonderful\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n7\\tand\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n7.1\\tfound\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n8\\tthe\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n9\\tneighbors\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n10\\tvery\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n11\\tkind\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n12\\t.\\t_\\t_\\t_\\t_\\t_\\t_\\t_\\t_\n\n''')\n...\n>>> dep.predict(path, pred='pred.conllx', verbose=false)[0]\n# text = but i found the location wonderful and the neighbors very kind.\n1       but     _       _       _       _       3       cc      _       _\n2       i       _       _       _       _       3       nsubj   _       _\n3       found   _       _       _       _       0       root    _       _\n4       the     _       _       _       _       5       det     _       _\n5       location        _       _       _       _       6       nsubj   _       _\n6       wonderful       _       _       _       _       3       xcomp   _       _\n7       and     _       _       _       _       6       cc      _       _\n7.1     found   _       _       _       _       _       _       _       _\n8       the     _       _       _       _       9       det     _       _\n9       neighbors       _       _       _       _       11      dep     _       _\n10      very    _       _       _       _       11      advmod  _       _\n11      kind    _       _       _       _       6       conj    _       _\n12      .       _       _       _       _       3       punct   _       _\n\n>>> con = parser.load('crf-con-en')\n>>> con.predict(['i', 'saw', 'sarah', 'with', 'a', 'telescope', '.'], verbose=false)[0].pretty_print()\n              top                       \n               |                         \n               s                        \n  _____________|______________________   \n |             vp                     | \n |    _________|____                  |  \n |   |    |         pp                | \n |   |    |     ____|___              |  \n np  |    np   |        np            | \n |   |    |    |     ___|______       |  \n _   _    _    _    _          _      _ \n |   |    |    |    |          |      |  \n i  saw sarah with  a      telescope  . \n\n>>> sdp = parser.load('biaffine-sdp-en')\n>>> sdp.predict([[('i','i','prp'), ('saw','see','vbd'), ('sarah','sarah','nnp'), ('with','with','in'),\n                  ('a','a','dt'), ('telescope','telescope','nn'), ('.','_','.')]],\n                verbose=false)[0]\n1       i       i       prp     _       _       _       _       2:arg1  _\n2       saw     see     vbd     _       _       _       _       0:root|4:arg1   _\n3       sarah   sarah   nnp     _       _       _       _       2:arg2  _\n4       with    with    in      _       _       _       _       _       _\n5       a       a       dt      _       _       _       _       _       _\n6       telescope       telescope       nn      _       _       _       _       4:arg2|5:bv     _\n7       .       _       .       _       _       _       _       _       _\n\n```\n\n### training\n\nto train a model from scratch, it is preferred to use the command-line option, which is more flexible and customizable.\nbelow is an example of training biaffine dependency parser:\n```sh\n$ python -m supar.cmds.biaffine_dep train -b -d 0 -c biaffine-dep-en -p model -f char\n```\n\nalternatively, `supar` provides some equivalent command entry points registered in [`setup.py`](setup.py):\n`biaffine-dep`, `crf2o-dep`, `crf-con` and `biaffine-sdp`, etc.\n```sh\n$ biaffine-dep train -b -d 0 -c biaffine-dep-en -p model -f char\n```\n\nto accommodate large models, distributed training is also supported:\n```sh\n$ python -m torch.distributed.launch --nproc_per_node=4 --master_port=10000  \\\n    -m supar.cmds.biaffine_dep train -b -c biaffine-dep-en -d 0,1,2,3 -p model -f char\n```\nyou can consult the pytorch [documentation](https://pytorch.org/docs/stable/notes/ddp.html) and [tutorials](https://pytorch.org/tutorials/intermediate/ddp_tutorial.html) for more details.\n\n### evaluation\n\nthe evaluation process resembles prediction:\n```py\n>>> loss, metric = parser.load('biaffine-dep-en').evaluate('ptb/test.conllx', verbose=false)\n>>> print(loss, metric)\n0.24214034126355097 ucm: 60.51% lcm: 50.37% uas: 96.01% las: 94.41%\n```\n\nsee [examples](examples.md) for more instructions on training and evaluation.\n\n## performance\n\n`supar` provides pretrained models for english, chinese and 17 other languages.\nthe tables below list the performance and parsing speed of pretrained models for different tasks.\nall results are tested on the machine with intel(r) xeon(r) cpu e5-2650 v4 @ 2.20ghz and nvidia geforce gtx 1080 ti gpu.\n\n### dependency parsing\n\nenglish and chinese dependency parsing models are trained on ptb and ctb7 respectively.\nfor each parser, we provide pretrained models that take bilstm as encoder.\nwe also provide models trained by finetuning pretrained language models from [huggingface transformers](https://github.com/huggingface/transformers).\nwe use [`robert-large`](https://huggingface.co/roberta-large) for english and [`hfl/chinese-electra-180g-large-discriminator`](https://huggingface.co/hfl/chinese-electra-180g-large-discriminator) for chinese.\nduring evaluation, punctuation is ignored in all metrics for ptb.\n\n| name                      |  uas  |   las | sents/s |\n| ------------------------- | :---: | ----: | :-----: |\n| `biaffine-dep-en`         | 96.01 | 94.41 | 1831.91 |\n| `crf2o-dep-en`            | 96.07 | 94.51 | 531.59  |\n| `biaffine-dep-roberta-en` | 97.33 | 95.86 | 271.80  |\n| `biaffine-dep-zh`         | 88.64 | 85.47 | 1180.57 |\n| `crf2o-dep-zh`            | 89.22 | 86.15 | 237.40  |\n| `biaffine-dep-electra-zh` | 92.45 | 89.55 | 160.56  |\n\nthe multilingual dependency parsing model, named `biaffine-dep-xlmr`, is trained on merged 12 selected treebanks from universal dependencies (ud) v2.3 dataset by finetuning [`xlm-roberta-large`](https://huggingface.co/xlm-roberta-large).\nthe following table lists results of each treebank.\nlanguages are represented by [iso 639-1 language codes](https://en.wikipedia.org/wiki/list_of_iso_639-1_codes).\n\n| language |  uas  |  las  | sents/s |\n| -------- | :---: | :---: | ------: |\n| `bg`     | 96.95 | 94.24 |  343.96 |\n| `ca`     | 95.57 | 94.20 |  184.88 |\n| `cs`     | 95.79 | 93.83 |  245.68 |\n| `de`     | 89.74 | 85.59 |  283.53 |\n| `en`     | 93.37 | 91.27 |  269.16 |\n| `es`     | 94.78 | 93.29 |  192.00 |\n| `fr`     | 94.56 | 91.90 |  219.35 |\n| `it`     | 96.29 | 94.47 |  254.82 |\n| `nl`     | 96.04 | 93.76 |  268.57 |\n| `no`     | 95.64 | 94.45 |  318.00 |\n| `ro`     | 94.59 | 89.79 |  216.45 |\n| `ru`     | 96.37 | 95.24 |  243.56 |\n\n### constituency parsing\n\nwe use ptb and ctb7 datasets to train english and chinese constituency parsing models.\nbelow are the results.\n\n| name                 |   p   |   r   | f<sub>1 | sents/s |\n| -------------------- | :---: | :---: | :-----: | ------: |\n| `crf-con-en`         | 94.16 | 93.98 |  94.07  |  841.88 |\n| `crf-con-roberta-en` | 96.42 | 96.13 |  96.28  |  233.34 |\n| `crf-con-zh`         | 88.82 | 88.42 |  88.62  |  590.05 |\n| `crf-con-electra-zh` | 92.18 | 91.66 |  91.92  |  140.45 |\n\nthe multilingual model `crf-con-xlmr` is trained on spmrl dataset by finetuning [`xlm-roberta-large`](https://huggingface.co/xlm-roberta-large).\nwe follow instructions of [benepar](https://github.com/nikitakit/self-attentive-parser) to preprocess the data.\nfor simplicity, we then directly merge train/dev/test treebanks of all languages in spmrl into big ones to train the model.\nthe results of each treebank are as follows.\n\n| language |   p   |   r   | f<sub>1 | sents/s |\n| -------- | :---: | :---: | :-----: | ------: |\n| `eu`     | 93.40 | 94.19 |  93.79  |  266.96 |\n| `fr`     | 88.77 | 88.84 |  88.81  |  149.34 |\n| `de`     | 93.68 | 92.18 |  92.92  |  200.31 |\n| `he`     | 94.65 | 95.20 |  94.93  |  172.50 |\n| `hu`     | 96.70 | 96.81 |  96.76  |  186.58 |\n| `ko`     | 91.75 | 92.46 |  92.11  |  234.86 |\n| `pl`     | 97.33 | 97.27 |  97.30  |  310.86 |\n| `sv`     | 92.51 | 92.50 |  92.50  |  235.49 |\n\n### semantic dependency parsing\n\nenglish semantic dependency parsing models are trained on [dm data introduced in semeval-2014 task 8](https://catalog.ldc.upenn.edu/ldc2016t10), while chinese models are trained on [news domain data of corpora from semeval-2016 task 9](https://github.com/hit-scir/semeval-2016).\nour data preprocessing steps follow [second_order_sdp](https://github.com/wangxinyu0922/second_order_sdp).\n\n| name                |   p   |   r   | f<sub>1 | sents/s |\n| ------------------- | :---: | :---: | :-----: | ------: |\n| `biaffine-sdp-en`   | 94.35 | 93.12 |  93.73  | 1067.06 |\n| `vi-sdp-en`         | 94.36 | 93.52 |  93.94  |  821.73 |\n| `vi-sdp-roberta-en` | 95.18 | 95.20 |  95.19  |  264.13 |\n| `biaffine-sdp-zh`   | 72.93 | 66.29 |  69.45  |  523.36 |\n| `vi-sdp-zh`         | 72.05 | 67.97 |  69.95  |  411.94 |\n| `vi-sdp-electra-zh` | 73.29 | 70.53 |  71.89  |  139.52 |\n\n## citation\n\nthe crf models for dependency/constituency parsing are our recent works published in acl 2020 and ijcai 2020 respectively.\nif you are interested in them, please cite:\n```bib\n@inproceedings{zhang-etal-2020-efficient,\n  title     = {efficient second-order {t}ree{crf} for neural dependency parsing},\n  author    = {zhang, yu and li, zhenghua and zhang min},\n  booktitle = {proceedings of acl},\n  year      = {2020},\n  url       = {https://www.aclweb.org/anthology/2020.acl-main.302},\n  pages     = {3295--3305}\n}\n\n@inproceedings{zhang-etal-2020-fast,\n  title     = {fast and accurate neural {crf} constituency parsing},\n  author    = {zhang, yu and zhou, houquan and li, zhenghua},\n  booktitle = {proceedings of ijcai},\n  year      = {2020},\n  doi       = {10.24963/ijcai.2020/560},\n  url       = {https://doi.org/10.24963/ijcai.2020/560},\n  pages     = {4046--4053}\n}\n```\n\n[^1]: the implementations of structured distributions and semirings are heavily borrowed from [torchstruct](https://github.com/harvardnlp/pytorch-struct) with some tailoring.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "supar",
  "package_url": "https://pypi.org/project/supar/",
  "project_url": "https://pypi.org/project/supar/",
  "project_urls": {
    "Homepage": "https://github.com/yzhangcs/parser"
  },
  "release_url": "https://pypi.org/project/supar/1.1.4/",
  "requires_dist": [
    "torch (>=1.7.1)",
    "transformers (>=4.0.0)",
    "nltk",
    "stanza",
    "dill",
    "numpy (<1.21.5) ; python_version < \"3.8\"",
    "allennlp ; extra == 'elmo'"
  ],
  "requires_python": ">=3.7",
  "summary": "syntactic/semantic parsing models",
  "version": "1.1.4",
  "releases": [],
  "developers": [
    "yu_zhang",
    "yzhang.cs@outlook.com"
  ],
  "kwds": "parsers parser parse parsing svg",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_supar",
  "homepage": "https://github.com/yzhangcs/parser",
  "release_count": 10,
  "dependency_ids": [
    "pypi_allennlp",
    "pypi_dill",
    "pypi_nltk",
    "pypi_numpy",
    "pypi_stanza",
    "pypi_torch",
    "pypi_transformers"
  ]
}