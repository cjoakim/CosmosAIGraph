{
  "classifiers": [
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": ".. image:: https://github.com/cjrh/aiorun/workflows/python%20application/badge.svg\n    :target: https://github.com/cjrh/aiorun/actions\n\n.. image:: https://coveralls.io/repos/github/cjrh/aiorun/badge.svg?branch=master\n    :target: https://coveralls.io/github/cjrh/aiorun?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/aiorun.svg\n    :target: https://pypi.python.org/pypi/aiorun\n\n.. image:: https://img.shields.io/github/tag/cjrh/aiorun.svg\n    :target: https://img.shields.io/github/tag/cjrh/aiorun.svg\n\n.. image:: https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\n    :target: https://img.shields.io/badge/install-pip%20install%20aiorun-ff69b4.svg\n\n.. image:: https://img.shields.io/pypi/v/aiorun.svg\n    :target: https://pypi.org/project/aiorun/\n\n.. image:: https://img.shields.io/badge/calver-yyyy.mm.minor-22bfda.svg\n    :alt: this project uses calendar-based versioning scheme\n    :target: http://calver.org/\n\n.. image:: https://pepy.tech/badge/aiorun\n    :alt: downloads\n    :target: https://pepy.tech/project/aiorun\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :alt: this project uses the \"black\" style formatter for python code\n    :target: https://github.com/python/black\n\n\n.. contents:: table of contents\n\n\ud83c\udfc3 aiorun\n======================\n\nhere's the big idea (how you use it):\n\n.. code-block:: python\n\n   import asyncio\n   from aiorun import run\n\n   async def main():\n       # put your application code here\n       await asyncio.sleep(1.0)\n\n   if __name__ == '__main__':\n       run(main())\n\nthis package provides a ``run()`` function as the starting point\nof your ``asyncio``-based application. the ``run()`` function will\nrun forever. if you want to shut down when ``main()`` completes, just\ncall ``loop.stop()`` inside it: that will initiate shutdown.\n\n.. warning::\n\n    note that `aiorun.run(coro)` will run **forever**, unlike the standard\n    library's ``asyncio.run()`` helper. you can call `aiorun.run()`\n    without a coroutine parameter, and it will still run forever.\n\n    this is surprising to many people, because they sometimes expect that\n    unhandled exceptions should abort the program, with an exception and\n    a traceback. if you want this behaviour, please see the section on\n    *error handling* further down.\n\n.. warning::\n\n    note that `aiorun.run(coro)` will create a **new event loop instance**\n    every time it is invoked (same as `asyncio.run`). this might cause\n    confusing errors if your code interacts with the default event loop\n    instance provided by the stdlib `asyncio` library. for such situations\n    you can provide the actual loop you're using with\n    `aiorun.run(coro, loop=loop)`. there is more info about this further down.\n\n    however, generally speaking, configuring your own loop and providing\n    it in this way is a code smell. you will find it much easier to\n    reason about your code if you do all your task creation *inside*\n    an async context, such as within an `async def` function, because then\n    there will no ambiguity about which event loop is in play: it will\n    always be the one returned by `asyncio.get_running_loop()`.\n\n\n\ud83e\udd14 why?\n----------------\n\nthe ``run()`` function will handle **everything** that normally needs\nto be done during the shutdown sequence of the application.  all you\nneed to do is write your coroutines and run them.\n\nso what the heck does ``run()`` do exactly?? it does these standard,\nidiomatic actions for asyncio apps:\n\n- creates a ``task`` for the given coroutine (schedules it on the\n  event loop),\n- calls ``loop.run_forever()``,\n- adds default (and smart) signal handlers for both ``sigint``\n  and ``sigterm`` that will stop the loop;\n- and *when* the loop stops (either by signal or called directly), then it will...\n- ...gather all outstanding tasks,\n- cancel them using ``task.cancel()``,\n- resume running the loop until all those tasks are done,\n- wait for the *executor* to complete shutdown, and\n- finally close the loop.\n\nall of this stuff is boilerplate that you will never have to write\nagain. so, if you use ``aiorun`` this is what **you** need to remember:\n\n- spawn all your work from a single, starting coroutine\n- when a shutdown signal is received, **all** currently-pending tasks\n  will have ``cancellederror`` raised internally. it's up to you whether\n  you want to handle this inside each coroutine with\n  a ``try/except`` or not.\n- if you want to protect coros from cancellation, see `shutdown_waits_for()`\n  further down.\n- try to have executor jobs be shortish, since the shutdown process will wait\n  for them to finish. if you need a long-running thread or process tasks, use\n  a dedicated thread/subprocess and set ``daemon=true`` instead.\n\nthere's not much else to know for general use. `aiorun` has a few special\ntools that you might need in unusual circumstances. these are discussed\nnext.\n\n\ud83d\udda5\ufe0f what about tcp server startup?\n-----------------------------------\n\nyou will see in many examples online that for servers, startup happens in\nseveral ``run_until_complete()`` phases before the primary ``run_forever()``\nwhich is the \"main\" running part of the program. how do we handle that with\n*aiorun*?\n\nlet's recreate the `echo client & server <https://docs.python.org/3/library/asyncio-stream.html#tcp-echo-client-using-streams>`_\nexamples from the standard library documentation:\n\n**client:**\n\n.. code-block:: python\n\n    # echo_client.py\n    import asyncio\n    from aiorun import run\n\n    async def tcp_echo_client(message):\n        # same as original!\n        reader, writer = await asyncio.open_connection('127.0.0.1', 8888)\n        print('send: %r' % message)\n        writer.write(message.encode())\n        data = await reader.read(100)\n        print('received: %r' % data.decode())\n        print('close the socket')\n        writer.close()\n        asyncio.get_event_loop().stop()  # exit after one msg like original\n\n    message = 'hello world!'\n    run(tcp_echo_client(message))\n\n**server:**\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run\n\n    async def handle_echo(reader, writer):\n        # same as original!\n        data = await reader.read(100)\n        message = data.decode()\n        addr = writer.get_extra_info('peername')\n        print(\"received %r from %r\" % (message, addr))\n        print(\"send: %r\" % message)\n        writer.write(data)\n        await writer.drain()\n        print(\"close the client socket\")\n        writer.close()\n\n    async def main():\n        server = await asyncio.start_server(handle_echo, '127.0.0.1', 8888)\n        print('serving on {}'.format(server.sockets[0].getsockname()))\n        async with server:\n            await server.serve_forever()\n\n    run(main())\n\nit works the same as the original examples, except you see this\nwhen you hit ``ctrl-c`` on the server instance:\n\n.. code-block:: bash\n\n    $ python echo_server.py\n    running forever.\n    serving on ('127.0.0.1', 8888)\n    received 'hello world!' from ('127.0.0.1', 57198)\n    send: 'hello world!'\n    close the client socket\n    ^cstopping the loop\n    entering shutdown phase.\n    cancelling pending tasks.\n    cancelling task:  <task pending coro=[...snip...]>\n    running pending tasks till complete\n    waiting for executor shutdown.\n    leaving. bye!\n\ntask gathering, cancellation, and executor shutdown all happen\nautomatically.\n\n\ud83d\udc1b error handling\n------------------\n\nunlike the standard library's ``asyncio.run()`` method, ``aiorun.run``\nwill run forever, and does not stop on unhandled exceptions. this is partly\nbecause we predate the standard library method, during the time in which\n``run_forever()`` was actually the recommended api for servers, and partly\nbecause it can *make sense* for long-lived servers to be resilient to\nunhandled exceptions.  for example, if 99% of your api works fine, but the\none new endpoint you just added has a bug: do you really want that one new\nendpoint to crash-loop your deployed service?\n\nnevertheless, not all usages of ``aiorun`` are long-lived servers, so some\nusers would prefer that ``aiorun.run()`` crash on an unhandled exception,\njust like any normal python program.  for this, we have an extra parameter\nthat enables it:\n\n.. code-block:: python\n\n   # stop_demo.py\n   from aiorun import run\n\n   async def main():\n       raise exception('ouch')\n\n   if __name__ == '__main__':\n       run(main(), stop_on_unhandled_errors=true)\n\nthis produces the following output:\n\n.. code-block::\n\n    $ python stop_demo.py\n    unhandled exception; stopping loop.\n    traceback (most recent call last):\n      file \"/opt/project/examples/stop_unhandled.py\", line 9, in <module>\n        run(main(), stop_on_unhandled_errors=true)\n      file \"/opt/project/aiorun.py\", line 294, in run\n        raise pending_exception_to_raise\n      file \"/opt/project/aiorun.py\", line 206, in new_coro\n        await coro\n      file \"/opt/project/examples/stop_unhandled.py\", line 5, in main\n        raise exception(\"ouch\")\n    exception: ouch\n\nerror handling scenarios can get very complex, and i suggest that you\ntry to keep your error handling as simple as possible. nevertheless, sometimes\npeople have special needs that require some complexity, so let's look at a\nfew scenarios where error-handling considerations can be more challenging.\n\n``aiorun.run()`` can also be started without an initial coroutine, in which\ncase any other created tasks still run as normal; in this case exceptions\nstill abort the program if the parameter is supplied:\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run\n\n\n    async def job():\n        raise exception(\"ouch\")\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.create_task(job())\n\n        run(loop=loop, stop_on_unhandled_errors=true)\n\nthe output is the same as the previous program. in this second example,\nwe made a our own loop instance and passed that to ``run()``. it is also possible\nto configure your exception handler on the loop, but if you do this the\n``stop_on_unhandled_errors`` parameter is no longer allowed:\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run\n\n\n    async def job():\n        raise exception(\"ouch\")\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.create_task(job())\n        loop.set_exception_handler(lambda loop, context: \"error\")\n\n        run(loop=loop, stop_on_unhandled_errors=true)\n\nbut this is not allowed:\n\n.. code-block::\n\n    traceback (most recent call last):\n      file \"/opt/project/examples/stop_unhandled_illegal.py\", line 15, in <module>\n        run(loop=loop, stop_on_unhandled_errors=true)\n      file \"/opt/project/aiorun.py\", line 171, in run\n        raise exception(\n    exception: if you provide a loop instance, and you've configured a\n    custom exception handler on it, then the 'stop_on_unhandled_errors'\n    parameter is unavailable (all exceptions will be handled).\n    /usr/local/lib/python3.8/asyncio/base_events.py:633:\n        runtimewarning: coroutine 'job' was never awaited\n\nremember that the parameter ``stop_on_unhandled_errors`` is just a convenience. if you're\ngoing to go to the trouble of making your own loop instance anyway, you can\nstop the loop yourself inside your own exception handler just fine, and\nthen you no longer need to set ``stop_on_unhandled_errors``:\n\n.. code-block:: python\n\n    # custom_stop.py\n    import asyncio\n    from aiorun import run\n\n\n    async def job():\n        raise exception(\"ouch\")\n\n\n    async def other_job():\n        try:\n            await asyncio.sleep(10)\n        except asyncio.cancellederror:\n            print(\"other_job was cancelled!\")\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.create_task(job())\n        loop.create_task(other_job())\n\n        def handler(loop, context):\n            # https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_exception_handler\n            print(f'stopping loop due to error: {context[\"exception\"]} ')\n            loop.stop()\n\n        loop.set_exception_handler(handler=handler)\n\n        run(loop=loop)\n\nin this example, we schedule two jobs on the loop. one of them raises an\nexception, and you can see in the output that the other job was still\ncancelled during shutdown as expected (which is what you expect ``aiorun``\nto do!):\n\n.. code-block::\n\n    $ python custom_stop.py\n    stopping loop due to error: ouch\n    other_job was cancelled!\n\nnote however that in this situation the exception is being *handled* by\nyour custom exception handler, and does not bubble up out of the ``run()``\nlike you saw in earlier examples. if you want to do something with that\nexception, like reraise it or something, you need to capture it inside your\ncustom exception handler and then do something with it, like add it to a list\nthat you check after ``run()`` completes, and then reraise there or something\nsimilar.\n\n\ud83d\udca8 do you like `uvloop <https://github.com/magicstack/uvloop>`_?\n------------------------------------------------------------------\n\n.. code-block:: python\n\n   import asyncio\n   from aiorun import run\n\n   async def main():\n       <snip>\n\n   if __name__ == '__main__':\n       run(main(), use_uvloop=true)\n\nnote that you have to ``pip install uvloop`` yourself.\n\n\ud83d\udee1\ufe0f smart shield for shutdown\n---------------------------------\n\nit's unusual, but sometimes you're going to want a coroutine to not get\ninterrupted by cancellation *during the shutdown sequence*. you'll look in\nthe official docs and find ``asyncio.shield()``.\n\nunfortunately, ``shield()`` doesn't work in shutdown scenarios because\nthe protection offered by ``shield()`` only applies if the specific coroutine\n*inside which* the ``shield()`` is used, gets cancelled directly.\n\nlet me explain: if you do a conventional shutdown sequence (like ``aiorun``\nis doing internally), this is the sequence of steps:\n\n- ``tasks = all_tasks()``, followed by\n- ``[t.cancel() for t in tasks]``, and then\n- ``run_until_complete(gather(*tasks))``\n\nthe way ``shield()`` works internally is it creates a *secret, inner*\ntask\u2014which also gets included in the ``all_tasks()`` call above! thus\nit also receives a cancellation exception just like everything else.\n\ntherefore, we have an alternative version of ``shield()`` that works better for\nus: ``shutdown_waits_for()``. if you've got a coroutine that must **not** be\ncancelled during the shutdown sequence, just wrap it in\n``shutdown_waits_for()``!\n\nhere's an example:\n\n.. code-block:: python\n\n    import asyncio\n    from aiorun import run, shutdown_waits_for\n\n    async def corofn():\n        for i in range(10):\n            print(i)\n            await asyncio.sleep(1)\n        print('done!')\n\n    async def main():\n        try:\n            await shutdown_waits_for(corofn())\n        except asyncio.cancellederror:\n            print('oh noes!')\n\n    run(main())\n\nif you hit ``ctrl-c`` *before* 10 seconds has passed, you will see\n``oh noes!`` printed immediately, and then after 10 seconds (since start),\n``done!`` is printed, and thereafter the program exits.\n\noutput:\n\n.. code-block:: shell\n\n    $ python testshield.py\n    0\n    1\n    2\n    3\n    4\n    ^cstopping the loop\n    oh noes!\n    5\n    6\n    7\n    8\n    9\n    done!\n\nbehind the scenes, ``all_tasks()`` would have been cancelled by ``ctrl-c``,\n*except* ones wrapped in ``shutdown_waits_for()`` calls.  in this respect, it\nis loosely similar to ``asyncio.shield()``, but with special applicability\nto our shutdown scenario in ``aiorun()``.\n\nbe careful with this: the coroutine should still finish up at some point.\nthe main use case for this is short-lived tasks that you don't want to\nwrite explicit cancellation handling.\n\noh, and you can use ``shutdown_waits_for()`` as if it were ``asyncio.shield()``\ntoo. for that use-case it works the same.  if you're using ``aiorun``, there\nis no reason to use ``shield()``.\n\n\ud83d\ude4f windows support\n-------------------------\n\n``aiorun`` also supports windows! kinda. sorta. the root problem with windows,\nfor a thing like ``aiorun`` is that windows doesn't support *signal handling*\nthe way linux or mac os x does. like, at all.\n\nfor linux, ``aiorun`` does \"the right thing\" out of the box for the\n``sigint`` and ``sigterm`` signals; i.e., it will catch them and initiate\na safe shutdown process as described earlier. however, on *windows*, these\nsignals don't work.\n\nthere are two signals that work on windows: the ``ctrl-c`` signal (happens\nwhen you press, unsurprisingly, ``ctrl-c``, and the ``ctrl-break`` signal\nwhich happens when you...well, you get the picture.\n\nthe good news is that, for ``aiorun``, both of these will work. yay! the bad\nnews is that for them to work, you have to run your code in a console\nwindow. boo!\n\nfortunately, it turns out that you can run an asyncio-based process *not*\nattached to a console window, e.g. as a service or a subprocess, *and* have\nit also receive a signal to safely shut down in a controlled way. it turns\nout that it is possible to send a ``ctrl-break`` signal to another process,\nwith no console window involved, but only as long as that process was created\nin a particular way and---here is the drop---this targetted process is a\nchild process of the one sending the signal. yeah, i know, it's a downer.\n\nthere is an example of how to do this in the tests:\n\n.. code-block:: python3\n\n    import subprocess as sp\n\n    proc = sp.popen(\n        ['python', 'app.py'],\n        stdout=sp.pipe,\n        stderr=sp.stdout,\n        creationflags=sp.create_new_process_group\n    )\n    print(proc.pid)\n\nnotice how we print out the process id (``pid``). then you can send that\nprocess the signal from a completely different process, once you know\nthe ``pid``:\n\n.. code-block:: python3\n\n    import os, signal\n\n    os.kill(pid, signal.ctrl_break_event)\n\n(remember, ``os.kill()`` doesn't actually kill, it only sends a signal)\n\n``aiorun`` supports this use-case above, although i'll be pretty surprised\nif anyone actually uses it to manage microservices (does anyone do this?)\n\nso to summarize: ``aiorun`` will do a controlled shutdown if either\n``ctrl-c`` or ``ctrl-break`` is entered via keyboard in a console window\nwith a running instance, or if the ``ctrl-break`` signal is sent to\na *subprocess* that was created with the ``create_new_process_group``\nflag set. `here <https://stackoverflow.com/a/35792192>`_ is a much more\ndetailed explanation of these issues.\n\nfinally, ``uvloop`` is not yet supported on windows so that won't work\neither.\n\nat the very least, ``aiorun`` will, well, *run* on windows \u00af\\\\_(\u30c4)_/\u00af\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "aiorun",
  "package_url": "https://pypi.org/project/aiorun/",
  "project_url": "https://pypi.org/project/aiorun/",
  "project_urls": {
    "Homepage": "https://github.com/cjrh/aiorun"
  },
  "release_url": "https://pypi.org/project/aiorun/2023.7.2/",
  "requires_dist": [
    "pytest ; extra == \"dev\"",
    "pytest-cov ; extra == \"dev\""
  ],
  "requires_python": ">=3.7",
  "summary": "boilerplate for asyncio applications",
  "version": "2023.7.2",
  "releases": [],
  "developers": [
    "caleb.hattingh@gmail.com",
    "caleb_hattingh"
  ],
  "kwds": "aiorun badge shields svg shield",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_aiorun",
  "homepage": "https://github.com/cjrh/aiorun",
  "release_count": 29,
  "dependency_ids": [
    "pypi_pytest",
    "pypi_pytest_cov"
  ]
}