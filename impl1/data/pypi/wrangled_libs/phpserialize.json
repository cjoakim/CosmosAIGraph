{
  "classifiers": [
    "license :: osi approved :: bsd license",
    "programming language :: php",
    "programming language :: python",
    "programming language :: python :: 3"
  ],
  "description": "phpserialize\r\n~~~~~~~~~~~~\r\n\r\na port of the ``serialize`` and ``unserialize`` functions of\r\nphp to python.  this module implements the python serialization\r\ninterface (eg: provides `dumps`, `loads` and similar functions).\r\n\r\nusage\r\n=====\r\n\r\n>>> from phpserialize import *\r\n>>> obj = dumps(\"hello world\")\r\n>>> loads(obj)\r\n'hello world'\r\n\r\ndue to the fact that php doesn't know the concept of lists, lists\r\nare serialized like hash-maps in php.  as a matter of fact the\r\nreverse value of a serialized list is a dict:\r\n\r\n>>> loads(dumps(range(2)))\r\n{0: 0, 1: 1}\r\n\r\nif you want to have a list again, you can use the `dict_to_list`\r\nhelper function:\r\n\r\n>>> dict_to_list(loads(dumps(range(2))))\r\n[0, 1]\r\n\r\nit's also possible to convert into a tuple by using the `dict_to_tuple`\r\nfunction:\r\n\r\n>>> dict_to_tuple(loads(dumps((1, 2, 3))))\r\n(1, 2, 3)\r\n\r\nanother problem are unicode strings.  by default unicode strings are\r\nencoded to 'utf-8' but not decoded on `unserialize`.  the reason for\r\nthis is that phpserialize can't guess if you have binary or text data\r\nin the strings:\r\n\r\n>>> loads(dumps(u'hello w\\xf6rld'))\r\n'hello w\\xc3\\xb6rld'\r\n\r\nif you know that you have only text data of a known charset in the result\r\nyou can decode strings by setting `decode_strings` to true when calling\r\nloads:\r\n\r\n>>> loads(dumps(u'hello w\\xf6rld'), decode_strings=true)\r\nu'hello w\\xf6rld'\r\n\r\ndictionary keys are limited to strings and integers.  `none` is converted\r\ninto an empty string and floats and booleans into integers for php\r\ncompatibility:\r\n\r\n>>> loads(dumps({none: 14, 42.23: 'foo', true: [1, 2, 3]}))\r\n{'': 14, 1: {0: 1, 1: 2, 2: 3}, 42: 'foo'}\r\n\r\nit also provides functions to read from file-like objects:\r\n\r\n>>> from stringio import stringio\r\n>>> stream = stringio('a:2:{i:0;i:1;i:1;i:2;}')\r\n>>> dict_to_list(load(stream))\r\n[1, 2]\r\n\r\nand to write to those:\r\n\r\n>>> stream = stringio()\r\n>>> dump([1, 2], stream)\r\n>>> stream.getvalue()\r\n'a:2:{i:0;i:1;i:1;i:2;}'\r\n\r\nlike `pickle` chaining of objects is supported:\r\n\r\n>>> stream = stringio()\r\n>>> dump([1, 2], stream)\r\n>>> dump(\"foo\", stream)\r\n>>> stream.seek(0)\r\n>>> load(stream)\r\n{0: 1, 1: 2}\r\n>>> load(stream)\r\n'foo'\r\n\r\nthis feature however is not supported in php.  php will only unserialize\r\nthe first object.\r\n\r\narray serialization\r\n===================\r\n\r\nstarting with 1.2 you can provide an array hook to the unserialization\r\nfunctions that are invoked with a list of pairs to return a real array\r\nobject.  by default `dict` is used as array object which however means\r\nthat the information about the order is lost for associative arrays.\r\n\r\nfor example you can pass the ordered dictionary to the unserilization\r\nfunctions:\r\n\r\n>>> from collections import ordereddict\r\n>>> loads('a:2:{s:3:\"foo\";i:1;s:3:\"bar\";i:2;}',\r\n...       array_hook=ordereddict)\r\ncollections.ordereddict([('foo', 1), ('bar', 2)])\r\n\r\nobject serialization\r\n====================\r\n\r\nphp supports serialization of objects.  starting with 1.2 of phpserialize\r\nit is possible to both serialize and unserialize objects.  because class\r\nnames in php and python usually do not map, there is a separate\r\n`object_hook` parameter that is responsible for creating these classes.\r\n\r\nfor a simple test example the `phpserialize.phpobject` class can be used:\r\n\r\n>>> data = 'o:7:\"wp_user\":1:{s:8:\"username\";s:5:\"admin\";}'\r\n>>> user = loads(data, object_hook=phpobject)\r\n>>> user.username\r\n'admin'\r\n>>> user.__name__\r\n'wp_user'\r\n\r\nan object hook is a function that takes the name of the class and a dict\r\nwith the instance data as arguments.  the instance data keys are in php\r\nformat which usually is not what you want.  to convert it into python\r\nidentifiers you can use the `convert_member_dict` function.  for more\r\ninformation about that, have a look at the next section.  here an\r\nexample for a simple object hook:\r\n\r\n>>> class user(object):\r\n...     def __init__(self, username):\r\n...         self.username = username\r\n...\r\n>>> def object_hook(name, d):\r\n...     cls = {'wp_user': user}[name]\r\n...     return cls(**d)\r\n...\r\n>>> user = loads(data, object_hook=object_hook)\r\n>>> user.username\r\n'admin'\r\n\r\nto serialize objects you can use the `object_hook` of the dump functions\r\nand return instances of `phpobject`:\r\n\r\n>>> def object_hook(obj):\r\n...     if isinstance(obj, user):\r\n...         return phpobject('wp_user', {'username': obj.username})\r\n...     raise lookuperror('unknown object')\r\n...\r\n>>> dumps(user, object_hook=object_hook)\r\n'o:7:\"wp_user\":1:{s:8:\"username\";s:5:\"admin\";}'\r\n\r\nphp's object system\r\n===================\r\n\r\nthe php object system is derived from compiled languages such as java\r\nand c#.  attributes can be protected from external access by setting\r\nthem to `protected` or `private`.  this does not only serve the purpose\r\nto encapsulate internals but also to avoid name clashes.\r\n\r\nin php each class in the inheritance chain can have a private variable\r\nwith the same name, without causing clashes.  (this is similar to the\r\npython `__var` name mangling system).\r\n\r\nthis php class::\r\n\r\n    class wp_userbase {\r\n        protected $username;\r\n\r\n        public function __construct($username) {\r\n            $this->username = $username;\r\n        }\r\n    }\r\n\r\n    class wp_user extends wp_userbase {\r\n        private $password;\r\n        public $flag;\r\n\r\n        public function __construct($username, $password) {\r\n            parent::__construct($username);\r\n            $this->password = $password;\r\n            $this->flag = 0;\r\n        }\r\n    }\r\n\r\nis serialized with a member data dict that looks like this:\r\n\r\n>>> data = {\r\n...     ' * username':          'the username',\r\n...     ' wp_user password':    'the password',\r\n...     'flag':                 'the flag'\r\n... }\r\n\r\nbecause this access system does not exist in python, the\r\n`convert_member_dict` can convert this dict:\r\n\r\n>>> d = convert_member_dict(data)\r\n>>> d['username']\r\n'the username'\r\n>>> d['password']\r\n'the password'\r\n\r\nthe `phpobject` class does this conversion on the fly.  what is\r\nserialized is the special `__php_vars__` dict of the class:\r\n\r\n>>> user = phpobject('wp_user', data)\r\n>>> user.username\r\n'the username'\r\n>>> user.username = 'admin'\r\n>>> user.__php_vars__[' * username']\r\n'admin'\r\n\r\nas you can see, reassigning attributes on a php object will try\r\nto change a private or protected attribute with the same name.\r\nsetting an unknown one will create a new public attribute:\r\n\r\n>>> user.is_admin = true\r\n>>> user.__php_vars__['is_admin']\r\ntrue\r\n\r\nto convert the phpobject into a dict, you can use the `_asdict`\r\nmethod:\r\n\r\n>>> d = user._asdict()\r\n>>> d['username']\r\n'admin'\r\n\r\npython 3 notes\r\n==============\r\n\r\nbecause the unicode support in python 3 no longer transparently\r\nhandles bytes and unicode objects we had to change the way the\r\ndecoding works.  on python 3 you most likely want to always\r\ndecode strings.  because this would totally fail on binary data\r\nphpserialize uses the \"surrogateescape\" method to not fail on\r\ninvalid data.  see the documentation in python 3 for more\r\ninformation.\r\n\r\nchangelog\r\n=========\r\n\r\n1.3\r\n    -   added support for python 3\r\n\r\n1.2\r\n    -   added support for object serialization\r\n    -   added support for array hooks\r\n\r\n1.1\r\n    -   added `dict_to_list` and `dict_to_tuple`\r\n    -   added support for unicode\r\n    -   allowed chaining of objects like pickle does",
  "docs_url": null,
  "keywords": "",
  "license": "unknown",
  "name": "phpserialize",
  "package_url": "https://pypi.org/project/phpserialize/",
  "project_url": "https://pypi.org/project/phpserialize/",
  "project_urls": {
    "Download": "UNKNOWN",
    "Homepage": "http://github.com/mitsuhiko/phpserialize"
  },
  "release_url": "https://pypi.org/project/phpserialize/1.3/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "a port of the serialize and unserialize functions of php to python.",
  "version": "1.3",
  "releases": [],
  "developers": [
    "armin.ronacher@active-4.com",
    "armin_ronacher"
  ],
  "kwds": "dict_to_list phpserialize serialized dict_to_tuple serialize",
  "license_kwds": "unknown",
  "libtype": "pypi",
  "id": "pypi_phpserialize",
  "homepage": "http://github.com/mitsuhiko/phpserialize",
  "release_count": 4,
  "dependency_ids": []
}