{
  "classifiers": [
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3"
  ],
  "description": ".. image:: https://api.travis-ci.org/fluxx/exam.png?branch=master\n   :target: http://travis-ci.org/fluxx/exam\n\n####\nexam\n####\n\n.. image:: https://dl.dropbox.com/u/3663715/exam.jpeg\n\nexam is a python toolkit for writing better tests.  it aims to remove a lot of the boiler plate testing code one often writes, while still following python conventions and adhering to the unit testing interface.\n\ninstallation\n------------\n\na simple ``pip install exam`` should do the trick.\n\nrationale\n---------\n\naside from the obvious \"does the code work?\", writings tests has many additional goals and benefits:\n\n1. if written semantically, reading tests can help demonstrate how the code is supposed to work to other developers.\n2. if quick running, tests provide feedback during development that your changes are working or not having an adverse side effects.\n3. if they're easy to write correctly, developers will write more tests and they will be of a higher quality.\n\nunfortunately, the common pattern for writing python unit tests tends to not offer any of these advantages.  often times results in inefficient and unnecessarily obtuse testing code.  additionally, common uses of the `mock` library can often result in repetitive boiler-plate code or inefficiency during test runs.\n\n`exam` aims to improve the state of python test writing by providing a toolkit of useful functionality to make writing quick, correct and useful tests and as painless as possible.\n\nusage\n--------\n\nexam features a collection of useful modules:\n\n``exam.decorators``\n~~~~~~~~~~~~~~~~~~~\n\nexam has some useful decorators to make your tests easier to write and understand.  to utilize the ``@before``, ``@after``, ``@around`` and ``@patcher`` decorators, you must mixin the ``exam.cases.exam`` class into your test case.  it implements the appropriate ``setup()`` and ``teardown()`` methods necessary to make the decorators work.\n\nnote that the ``@fixture`` decorator works without needing to be defined inside of an exam class.  still, it's a best practice to add the ``exam`` mixin to your test cases.\n\nall of the decorators in ``exam.decorators``, as well as the ``exam`` test case are available for import from the main ``exam`` package as well. i.e.:\n\n.. code:: python\n\n    from exam import exam\n    from exam import fixture, before, after, around, patcher\n\n``exam.decorators.fixture``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``@fixture`` decorator turns a method into a property (similar to the ``@property`` decorator, but also memoizes the return value). this lets you reference the property in your tests, i.e. ``self.grounds``, and it will always reference the exact same instance every time.\n\n.. code:: python\n\n    from exam.decorators import fixture\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        @fixture\n        def user(self):\n            return user(name='jeff')\n\n        def test_user_name_is_jeff(self):\n            assert self.user.name == 'jeff'\n\nas you can see, ``self.user`` was used to reference the ``user`` property defined above.\n\nif all your fixture method is doing is constructing a new instance of type or calling a class method, exam provides a shorthand inline ``fixture`` syntax for constructing fixture objects.  simply set a class variable equal to ``fixture(type_or_class_method)`` and exam will automatically call your type or class method.\n\n.. code:: python\n\n    from exam.decorators import fixture\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        user = fixture(user, name='jeff')\n\n        def test_user_name_is_jeff(self):\n            assert self.user.name == 'jeff'\n\nany ``*args`` or ``**kwargs`` passed to ``fixture(type_or_class_method)`` will be passed to the ``type_or_class_method`` when called.\n\n\n``exam.decorators.before``\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``@before`` decorator adds the method to the list of methods which are run as part of the class's ``setup()`` routine.\n\n.. code:: python\n\n    from exam.decorators import before\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        @before\n        def reset_database(self):\n            mydb.reset()\n\n\n``@before`` also hooks works through subclasses - that is to say, if a parent class has a ``@before`` hook in it, and you subclass it and define a 2nd ``@before`` hook in it, both ``@before`` hooks will be called.  exam runs the parent's ``@before`` hook first, then runs the childs'.  also, if your override a `@before` hook in your child class, the overridden method is run when the rest of the child classes `@before` hooks are run.\n\nfor example, with hooks defined as such:\n\n.. code:: python\n\n    from exam.decorators import before\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        @before\n        def reset_database(self):\n            print 'parent reset_db'\n\n        @before\n        def parent_hook(self):\n            print 'parent hook'\n\n\n    class redistest(mytest):\n\n        @before\n        def reset_database(self):\n            print 'child reset_db'\n\n        @before\n        def child_hook(self):\n            print 'child hook'\n\nwhen exam runs these hooks, the output would be:\n\n.. code:: python\n\n    \"prent hook\"\n    \"child reset_db\"\n    \"child hook\"\n\nas you can see even though the parent class defines a ``reset_database``, because the child class overwrote it, the child's version is run instead, and also at the same time as the rest of the child's ``@before`` hooks.\n\n``@before`` hooks can also be constructed with other functions in your test case, decorating actual test methods.  when this strategy is used, exam will run the function ``@before`` is constructed with before running that particular test method.\n\n.. code:: python\n\n    from exam.decorators import before, fixture\n    from exam.cases import exam\n\n    from myapp import user\n\n    class mytest(exam, testcase):\n\n        user = fixture(user)\n\n        @before\n        def create_user(self):\n            self.user.create()\n\n        def confirm_user(self):\n            self.user.confirm()\n\n        @before(confirm_user)\n        def test_confirmed_users_have_no_token(self):\n            self.assertfalse(self.user.token)\n\n        def test_user_display_name_exists(self):\n            self.asserttrue(self.user.display_name)\n\nin the above example, the ``confirm_user`` method is run immediately before the ``test_confirmed_users_have_no_token`` method, but **not** the ``test_user_display_name_exists`` method.  the ``@before`` globally decorated ``create_user`` method still runs before each test method.\n\n``@before`` can also be constructed with multiple functions to call before running the test method:\n\n.. code:: python\n\n    class mytest(exam, testcase):\n\n        @before(func1, func2)\n        def test_does_things(self):\n            does_things()\n\nin the above example, ``func1`` and ``func2`` are called in order before ``test_does_things`` is run.\n\n``exam.decorators.after``\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe compliment to ``@before``, ``@after`` adds the method to the list of methods which are run as part of the class's ``teardown()`` routine. like ``@before``, ``@after`` runs parent class ``@after`` hooks before running ones defined in child classes.\n\n.. code:: python\n\n    from exam.decorators import after\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        @after\n        def remove_temp_files(self):\n            myapp.remove_temp_files()\n\n\n``exam.decorators.around``\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nmethods decorated with ``@around`` act as a context manager around each test method.  in your around method, you're responsible for calling ``yield`` where you want the test case to run:\n\n.. code:: python\n\n    from exam.decorators import around\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        @around\n        def run_in_transaction(self):\n            db.begin_transaction()\n            yield  # run the test\n            db.rollback_transaction()\n\n``@around`` also follows the same parent/child ordering rules as ``@before`` and ``@after``, so parent ``@arounds`` will run (up until the ``yield`` statement), then child ``@around``s will run.  after the test method has finished, however, the rest of the child's ``@around`` will run, and then the parents'.  this is done to preserve the normal behavior of nesting with context managers.\n\n\n``exam.decorators.patcher``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``@patcher`` decorator is shorthand for the following boiler plate code:\n\n.. code:: python\n\n    from mock import patch\n\n     def setup(self):\n         self.stats_patcher = patch('mylib.stats', new=dummy_stats)\n         self.stats = self.stats_patcher.start()\n\n     def teardown(self):\n         self.stats_patcher.stop()\n\noften, manually controlling a patch's start/stop is done to provide a test case property (here, ``self.stats``) for the mock object you are patching with.  this is handy if you want the mock to have default behavior for most tests, but change it slightly for certain ones -- i.e absorb all calls most of the time, but for certain tests have it raise an exception.\n\nusing the ``@patcher`` decorator, the above code can simply be written as:\n\n.. code:: python\n\n    from exam.decorators import patcher\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n       @patcher('mylib.stats')\n       def stats(self):\n           return dummy_stats\n\nexam takes care of starting and stopping the patcher appropriately, as well as constructing the ``patch`` object with the return value from the decorated method.\n\nif you're happy with the default constructed mock object for a patch (``magicmock``), then ``patcher`` can simply be used as an inline as a function inside the class body.  this method still starts and stops the patcher when needed, and returns the constructed ``magicmock`` object, which you can set as a class attribute.  exam will add the ``magicmock`` object to the test case as an instance attribute automatically.\n\n.. code:: python\n\n    from exam.decorators import patcher\n    from exam.cases import exam\n\n    class mytest(exam, testcase):\n\n        logger = patcher('coffee.logger')\n\n\n``exam.decorators.patcher.object``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``patcher.object`` decorator provides the same features as the ``patcher`` decorator, but works with patching attributes of objects (similar to mock's ``mock.patch.object``).  for example, here is how you would use patcher to patch the ``objects`` property of the ``user`` class:\n\n.. code:: python\n\n    from exam.decorators import patcher\n    from exam.cases import exam\n\n    from myapp import user\n\n    class mytest(exam, testcase):\n\n        manager = patcher.object(user, 'objects')\n\nas with the vanilla ``patcher``, in your test case, ``self.manager`` will be the mock object that ``user.objects`` was patched with.\n\n\n``exam.helpers``\n~~~~~~~~~~~~~~~~\n\nthe ``helpers`` module features a collection of helper methods for common testing patterns:\n\n``exam.helpers.track``\n^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``track`` helper is intended to assist in tracking call orders of independent mock objects.  ``track`` is called with kwargs, where the key is the mock name (a string) and the value is the mock object you want to track.  ``track`` returns a newly constructed ``magicmock`` object, with each mock object attached at a attribute named after the mock name.\n\nfor example, below ``track()`` creates a new mock with ``tracker.cool` as the ``cool_mock`` and ``tracker.heat`` as the ``heat_mock``.\n\n.. code:: python\n\n    from exam.helpers import track\n\n    @mock.patch('coffee.roast.heat')\n    @mock.patch('coffee.roast.cool')\n    def test_roasting_heats_then_cools_beans(self, cool_mock, heat_mock):\n        tracker = track(heat=heat_mock, cool=cool_mock)\n        roast.perform()\n        tracker.assert_has_calls([mock.call.heat(), mock.call.cool()])\n\n``exam.helpers.rm_f``\n^^^^^^^^^^^^^^^^^^^^^\n\nthis is a simple helper that just removes all folders and files at a path:\n\n.. code:: python\n\n    from exam.helpers import rm_f\n\n    rm_f('/folder/i/do/not/care/about')\n\n``exam.helpers.mock_import``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nremoves most of the boiler plate code needed to mock imports, which usually consists of making a ``patch.dict`` from ``sys.modules``.  instead, the ``patch_import`` helper can simply be used as a decorator or context manager for when certain modules are imported.\n\n.. code:: python\n\n    from exam.helpers import mock_import\n\n    with mock_import('os.path') as my_os_path:\n        import os.path as imported_os_path\n        assert my_os_path is imported_os_path\n\n``mock_import`` can also be used as a decorator, which passed the mock value to\nthe testing method (like a normal ``@patch``) decorator:\n\n.. code:: python\n\n    from exam.helpers import mock_import\n\n    @mock_import('os.path')\n    def test_method(self):\n        import os.path as imported_os_path\n        assert my_os_path is imported_os_path\n\n``exam.helpers.effect``\n^^^^^^^^^^^^^^^^^^^^^^^\n\nhelper class that is itself callable, whose return values when called are configured via the tuples passed in to the constructor. useful to build ``side_effect`` callables for mock objects. raises typeerror if called with arguments that it was not configured with:\n\n    >>> from exam.objects import call, effect\n    >>> side_effect = effect((call(1), 'with 1'), (call(2), 'with 2'))\n    >>> side_effect(1)\n    'with 1'\n    >>> side_effect(2)\n    'with 2'\n\ncall argument equality is checked via equality (==) of the ``call``` object, which is the 0th item of the configuration tuple passed in to the ``effect`` constructor.  by default, ``call`` objects are just ``mock.call`` objects.\n\nif you would like to customize this behavior, subclass `effect` and redefine your own `call_class` class variable.  i.e.\n\n.. code:: python\n\n    class myeffect(effect):\n        call_class = my_call_class\n\n``exam.mock``\n~~~~~~~~~~~~~\n\nexam has a subclass of the normal ``mock.mock`` object that adds a few more useful methods to your mock objects.  use it in place of a normal ``mock`` object:\n\n.. code:: python\n\n    from exam.mock import mock\n\n    mock_user = mock(spec=user)\n\nthe subclass has the following extra methods:\n\n* ``assert_called()`` - asserts the mock was called at least once.\n* ``assert_not_called()`` - asserts the mock has never been called.\n* ``assert_not_called_with(*args, **kwargs)`` - asserts the mock was not most recently called with the specified ``*args`` and ``**kwargs``.\n* ``assert_not_called_once_with(*args, **kwargs)`` - asserts the mock has only every been called once with the specified ``*args`` and ``**kwargs``.\n* ``assert_not_any_call(*args, **kwargs)`` - asserts the mock has never been called with the specified ``*args`` and ``**kwargs``.\n\n``exam.fixtures``\n~~~~~~~~~~~~~~~~~\n\nhelpful fixtures that you may want to use in your tests:\n\n* ``exam.fixtures.two_px_square_image`` - image data as a string of a 2px square image.\n* ``exam.fixtures.one_px_spacer`` - image data as a string of a 1px square spacer image.\n\n``exam.objects``\n~~~~~~~~~~~~~~~~\n\nuseful objects for use in testing:\n\n``exam.objects.noop`` - callable object that always returns ``none``. no matter how it was called.\n\n``exam.asserts``\n~~~~~~~~~~~~~~~~\n\nthe `asserts` module contains an `assertsmixin` class, which is mixed into the main `exam` test case mixin.  it contains additional asserts beyond the ones in python's `unittest`.\n\n``assertchanges``\n^^^^^^^^^^^^^^^^^\n\nused when you want to assert that a section of code changes a value.  for example, imagine if you had a function that changed a soldier's rank.\n\nto properly test this, you should save that soldier's rank to a temporary variable, then run the function to change the rank, and then finally assert that the rank is the new expected value, as well as **not** the old value:\n\n.. code:: python\n\n    test_changes_rank(self):\n        old_rank = self.soldier.rank\n        promote(self.soldier, 'general')\n        self.assertequal(self.soldier.rank, 'general')\n        self.assertnotequal(self.soldier.rank, old_rank)\n\nchecking the old rank is not the same is the new rank is important.  if, for some reason there is a bug or something to where ``self.soldier`` is created with the rank of ``general``, but ``promote`` is not working, this test would still pass!\n\nto solve this, you can use exam's ``assertchanges``:\n\n.. code:: python\n\n    def test_changes_rank(self):\n        with self.assertchanges(getattr, self.soldier, 'rank', after='general'):\n            promote(self.soldier, 'general')\n\nthis assert is doing a few things.\n\n1. it asserts that the rank once the context is run is the expected ``general``.\n2. it asserts that the context **changes** the value of ``self.soldier.rank``.\n3. it doesn't actually care what the old value of ``self.soldier.rank`` was, as long as it changed when the context was run.\n\nthe definition of ``assertchanges`` is:\n\n.. code:: python\n\n    def assertchanges(thing, *args, **kwargs)\n\n1. you pass it a ``thing``, which which be a callable.\n2. ``assertchanges`` then calls your ``thing`` with any ``*args`` and ``**kwargs`` additionally passed in and captures the value as the \"before\" value.\n3. the context is run, and then the callable is captured again as the \"after\" value.\n4. if before and after are not different, an ``assertionerror`` is raised.\n5. additionally, if the special kwarg ``before`` or ``after`` are passed, those values are extracted and saved.  in this case an ``assertionerror`` can also be raised if the \"before\" and/or \"after\" values provided do not match their extracted values.\n\n``assertdoesnotchange``\n^^^^^^^^^^^^^^^^^^^^^^^\n\nsimilar to ``assertchanges``, ``assertdoesnotchange`` asserts that the code inside the context does not change the value from the callable:\n\n.. code:: python\n\n    def test_does_not_change_rank(self):\n        with self.assertdoesnotchange(getattr, self.soldier, 'rank'):\n            self.soldier.march()\n\nunlike ``assertchanges``, ``assertdoesnotchange`` does not take ``before`` or ``after`` kwargs.  it simply asserts that the value of the callable did not change when the context was run.\n\nlicense\n-------\n\nexam is mit licensed.  please see the ``license`` file for details.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "exam",
  "package_url": "https://pypi.org/project/exam/",
  "project_url": "https://pypi.org/project/exam/",
  "project_urls": {
    "Download": "UNKNOWN",
    "Homepage": "https://github.com/fluxx/exam"
  },
  "release_url": "https://pypi.org/project/exam/0.10.6/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "helpers for better testing.",
  "version": "0.10.6",
  "releases": [],
  "developers": [
    "jeff.pollard@gmail.com",
    "jeff_pollard"
  ],
  "kwds": "tests testing exam test test_does_things",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_exam",
  "homepage": "https://github.com/fluxx/exam",
  "release_count": 24,
  "dependency_ids": []
}