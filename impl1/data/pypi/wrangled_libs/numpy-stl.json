{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "numpy-stl\n==============================================================================\n\n.. image:: https://github.com/wolph/numpy-stl/actions/workflows/main.yml/badge.svg?branch=master\n    :alt: numpy-stl test status \n    :target: https://github.com/wolph/numpy-stl/actions/workflows/main.yml\n\n.. image:: https://ci.appveyor.com/api/projects/status/cbv7ak2i59wf3lpj?svg=true\n    :alt: numpy-stl test status \n    :target: https://ci.appveyor.com/project/wolph/numpy-stl\n\n.. image:: https://badge.fury.io/py/numpy-stl.svg\n    :alt: numpy-stl pypi version \n    :target: https://pypi.python.org/pypi/numpy-stl\n\n.. image:: https://coveralls.io/repos/wolph/numpy-stl/badge.svg?branch=master\n    :alt: numpy-stl code coverage \n    :target: https://coveralls.io/r/wolph/numpy-stl?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/numpy-stl.svg\n\nsimple library to make working with stl files (and 3d objects in general) fast\nand easy.\n\ndue to all operations heavily relying on `numpy` this is one of the fastest\nstl editing libraries for python available.\n\nsecurity contact information\n------------------------------------------------------------------------------\n\nto report a security vulnerability, please use the\n`tidelift security contact <https://tidelift.com/security>`_.\ntidelift will coordinate the fix and disclosure.\n\nissues\n------\n\nif you encounter any issues, make sure you report them `here <https://github.com/wolph/numpy-stl/issues>`_. be sure to search for existing issues however. many issues have been covered before.\nwhile this project uses `numpy` as it's main dependency, it is not in any way affiliated to the `numpy` project or the numfocus organisation.\n\nlinks\n-----\n\n - the source: https://github.com/wolph/numpy-stl\n - project page: https://pypi.python.org/pypi/numpy-stl\n - reporting bugs: https://github.com/wolph/numpy-stl/issues\n - documentation: http://numpy-stl.readthedocs.org/en/latest/\n - my blog: https://wol.ph/\n\nrequirements for installing:\n------------------------------------------------------------------------------\n\n - `numpy`_ any recent version\n - `python-utils`_ version 1.6 or greater\n\ninstallation:\n------------------------------------------------------------------------------\n\n`pip install numpy-stl`\n\ninitial usage:\n------------------------------------------------------------------------------\n\nafter installing the package, you should be able to run the following commands\nsimilar to how you can run `pip`.\n\n.. code-block:: shell\n \n   $ stl2bin your_ascii_stl_file.stl new_binary_stl_file.stl\n   $ stl2ascii your_binary_stl_file.stl new_ascii_stl_file.stl\n   $ stl your_ascii_stl_file.stl new_binary_stl_file.stl\n\ncontributing:\n------------------------------------------------------------------------------\n\ncontributions are always welcome. please view the guidelines to get started:\nhttps://github.com/wolph/numpy-stl/blob/develop/contributing.rst\n\nquickstart\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    import numpy\n    from stl import mesh\n\n    # using an existing stl file:\n    your_mesh = mesh.mesh.from_file('some_file.stl')\n\n    # or creating a new mesh (make sure not to overwrite the `mesh` import by\n    # naming it `mesh`):\n    vertice_count = 100\n    data = numpy.zeros(vertice_count, dtype=mesh.mesh.dtype)\n    your_mesh = mesh.mesh(data, remove_empty_areas=false)\n\n    # the mesh normals (calculated automatically)\n    your_mesh.normals\n    # the mesh vectors\n    your_mesh.v0, your_mesh.v1, your_mesh.v2\n    # accessing individual points (concatenation of v0, v1 and v2 in triplets)\n    assert (your_mesh.points[0][0:3] == your_mesh.v0[0]).all()\n    assert (your_mesh.points[0][3:6] == your_mesh.v1[0]).all()\n    assert (your_mesh.points[0][6:9] == your_mesh.v2[0]).all()\n    assert (your_mesh.points[1][0:3] == your_mesh.v0[1]).all()\n\n    your_mesh.save('new_stl_file.stl')\n\nplotting using `matplotlib`_ is equally easy:\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    from stl import mesh\n    from mpl_toolkits import mplot3d\n    from matplotlib import pyplot\n\n    # create a new plot\n    figure = pyplot.figure()\n    axes = figure.add_subplot(projection='3d')\n\n    # load the stl files and add the vectors to the plot\n    your_mesh = mesh.mesh.from_file('tests/stl_binary/halfdonut.stl')\n    axes.add_collection3d(mplot3d.art3d.poly3dcollection(your_mesh.vectors))\n\n    # auto scale to the mesh size\n    scale = your_mesh.points.flatten()\n    axes.auto_scale_xyz(scale, scale, scale)\n\n    # show the plot to the screen\n    pyplot.show()\n\n.. _numpy: http://numpy.org/\n.. _matplotlib: http://matplotlib.org/\n.. _python-utils: https://github.com/wolph/python-utils\n\nexperimental support for reading 3mf files\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    import pathlib\n    import stl\n\n    path = pathlib.path('tests/3mf/moon.3mf')\n\n    # load the 3mf file\n    for m in stl.mesh.from_3mf_file(path):\n        # do something with the mesh\n        print('mesh', m)\n\nnote that this is still experimental and may not work for all 3mf files.\nadditionally it only allows reading 3mf files, not writing them.\n\nmodifying mesh objects\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    from stl import mesh\n    import math\n    import numpy\n\n    # create 3 faces of a cube\n    data = numpy.zeros(6, dtype=mesh.mesh.dtype)\n\n    # top of the cube\n    data['vectors'][0] = numpy.array([[0, 1, 1],\n                                      [1, 0, 1],\n                                      [0, 0, 1]])\n    data['vectors'][1] = numpy.array([[1, 0, 1],\n                                      [0, 1, 1],\n                                      [1, 1, 1]])\n    # front face\n    data['vectors'][2] = numpy.array([[1, 0, 0],\n                                      [1, 0, 1],\n                                      [1, 1, 0]])\n    data['vectors'][3] = numpy.array([[1, 1, 1],\n                                      [1, 0, 1],\n                                      [1, 1, 0]])\n    # left face\n    data['vectors'][4] = numpy.array([[0, 0, 0],\n                                      [1, 0, 0],\n                                      [1, 0, 1]])\n    data['vectors'][5] = numpy.array([[0, 0, 0],\n                                      [0, 0, 1],\n                                      [1, 0, 1]])\n\n    # since the cube faces are from 0 to 1 we can move it to the middle by\n    # substracting .5\n    data['vectors'] -= .5\n\n    # generate 4 different meshes so we can rotate them later\n    meshes = [mesh.mesh(data.copy()) for _ in range(4)]\n\n    # rotate 90 degrees over the y axis\n    meshes[0].rotate([0.0, 0.5, 0.0], math.radians(90))\n\n    # translate 2 points over the x axis\n    meshes[1].x += 2\n\n    # rotate 90 degrees over the x axis\n    meshes[2].rotate([0.5, 0.0, 0.0], math.radians(90))\n    # translate 2 points over the x and y points\n    meshes[2].x += 2\n    meshes[2].y += 2\n\n    # rotate 90 degrees over the x and y axis\n    meshes[3].rotate([0.5, 0.0, 0.0], math.radians(90))\n    meshes[3].rotate([0.0, 0.5, 0.0], math.radians(90))\n    # translate 2 points over the y axis\n    meshes[3].y += 2\n\n\n    # optionally render the rotated cube faces\n    from matplotlib import pyplot\n    from mpl_toolkits import mplot3d\n\n    # create a new plot\n    figure = pyplot.figure()\n    axes = figure.add_subplot(projection='3d')\n\n    # render the cube faces\n    for m in meshes:\n        axes.add_collection3d(mplot3d.art3d.poly3dcollection(m.vectors))\n\n    # auto scale to the mesh size\n    scale = numpy.concatenate([m.points for m in meshes]).flatten()\n    axes.auto_scale_xyz(scale, scale, scale)\n\n    # show the plot to the screen\n    pyplot.show()\n\nextending mesh objects\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    from stl import mesh\n    import math\n    import numpy\n\n    # create 3 faces of a cube\n    data = numpy.zeros(6, dtype=mesh.mesh.dtype)\n\n    # top of the cube\n    data['vectors'][0] = numpy.array([[0, 1, 1],\n                                      [1, 0, 1],\n                                      [0, 0, 1]])\n    data['vectors'][1] = numpy.array([[1, 0, 1],\n                                      [0, 1, 1],\n                                      [1, 1, 1]])\n    # front face\n    data['vectors'][2] = numpy.array([[1, 0, 0],\n                                      [1, 0, 1],\n                                      [1, 1, 0]])\n    data['vectors'][3] = numpy.array([[1, 1, 1],\n                                      [1, 0, 1],\n                                      [1, 1, 0]])\n    # left face\n    data['vectors'][4] = numpy.array([[0, 0, 0],\n                                      [1, 0, 0],\n                                      [1, 0, 1]])\n    data['vectors'][5] = numpy.array([[0, 0, 0],\n                                      [0, 0, 1],\n                                      [1, 0, 1]])\n\n    # since the cube faces are from 0 to 1 we can move it to the middle by\n    # substracting .5\n    data['vectors'] -= .5\n\n    cube_back = mesh.mesh(data.copy())\n    cube_front = mesh.mesh(data.copy())\n\n    # rotate 90 degrees over the x axis followed by the y axis followed by the\n    # x axis\n    cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))\n    cube_back.rotate([0.0, 0.5, 0.0], math.radians(90))\n    cube_back.rotate([0.5, 0.0, 0.0], math.radians(90))\n\n    cube = mesh.mesh(numpy.concatenate([\n        cube_back.data.copy(),\n        cube_front.data.copy(),\n    ]))\n\n    # optionally render the rotated cube faces\n    from matplotlib import pyplot\n    from mpl_toolkits import mplot3d\n\n    # create a new plot\n    figure = pyplot.figure()\n    axes = figure.add_subplot(projection='3d')\n\n    # render the cube\n    axes.add_collection3d(mplot3d.art3d.poly3dcollection(cube.vectors))\n\n    # auto scale to the mesh size\n    scale = cube_back.points.flatten()\n    axes.auto_scale_xyz(scale, scale, scale)\n\n    # show the plot to the screen\n    pyplot.show()\n\ncreating mesh objects from a list of vertices and faces\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    import numpy as np\n    from stl import mesh\n\n    # define the 8 vertices of the cube\n    vertices = np.array([\\\n        [-1, -1, -1],\n        [+1, -1, -1],\n        [+1, +1, -1],\n        [-1, +1, -1],\n        [-1, -1, +1],\n        [+1, -1, +1],\n        [+1, +1, +1],\n        [-1, +1, +1]])\n    # define the 12 triangles composing the cube\n    faces = np.array([\\\n        [0,3,1],\n        [1,3,2],\n        [0,4,7],\n        [0,7,3],\n        [4,5,6],\n        [4,6,7],\n        [5,1,2],\n        [5,2,6],\n        [2,3,6],\n        [3,7,6],\n        [0,1,5],\n        [0,5,4]])\n\n    # create the mesh\n    cube = mesh.mesh(np.zeros(faces.shape[0], dtype=mesh.mesh.dtype))\n    for i, f in enumerate(faces):\n        for j in range(3):\n            cube.vectors[i][j] = vertices[f[j],:]\n\n    # write the mesh to file \"cube.stl\"\n    cube.save('cube.stl')\n\n\nevaluating mesh properties (volume, center of gravity, inertia)\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    import numpy as np\n    from stl import mesh\n\n    # using an existing closed stl file:\n    your_mesh = mesh.mesh.from_file('some_file.stl')\n\n    volume, cog, inertia = your_mesh.get_mass_properties()\n    print(\"volume                                  = {0}\".format(volume))\n    print(\"position of the center of gravity (cog) = {0}\".format(cog))\n    print(\"inertia matrix at expressed at the cog  = {0}\".format(inertia[0,:]))\n    print(\"                                          {0}\".format(inertia[1,:]))\n    print(\"                                          {0}\".format(inertia[2,:]))\n\ncombining multiple stl files\n------------------------------------------------------------------------------\n\n.. code-block:: python\n\n    import math\n    import stl\n    from stl import mesh\n    import numpy\n\n\n    # find the max dimensions, so we can know the bounding box, getting the height,\n    # width, length (because these are the step size)...\n    def find_mins_maxs(obj):\n        minx = obj.x.min()\n        maxx = obj.x.max()\n        miny = obj.y.min()\n        maxy = obj.y.max()\n        minz = obj.z.min()\n        maxz = obj.z.max()\n        return minx, maxx, miny, maxy, minz, maxz\n\n\n    def translate(_solid, step, padding, multiplier, axis):\n        if 'x' == axis:\n            items = 0, 3, 6\n        elif 'y' == axis:\n            items = 1, 4, 7\n        elif 'z' == axis:\n            items = 2, 5, 8\n        else:\n            raise runtimeerror('unknown axis %r, expected x, y or z' % axis)\n\n        # _solid.points.shape == [:, ((x, y, z), (x, y, z), (x, y, z))]\n        _solid.points[:, items] += (step * multiplier) + (padding * multiplier)\n\n\n    def copy_obj(obj, dims, num_rows, num_cols, num_layers):\n        w, l, h = dims\n        copies = []\n        for layer in range(num_layers):\n            for row in range(num_rows):\n                for col in range(num_cols):\n                    # skip the position where original being copied is\n                    if row == 0 and col == 0 and layer == 0:\n                        continue\n                    _copy = mesh.mesh(obj.data.copy())\n                    # pad the space between objects by 10% of the dimension being\n                    # translated\n                    if col != 0:\n                        translate(_copy, w, w / 10., col, 'x')\n                    if row != 0:\n                        translate(_copy, l, l / 10., row, 'y')\n                    if layer != 0:\n                        translate(_copy, h, h / 10., layer, 'z')\n                    copies.append(_copy)\n        return copies\n\n    # using an existing stl file:\n    main_body = mesh.mesh.from_file('ball_and_socket_simplified_-_main_body.stl')\n\n    # rotate along y\n    main_body.rotate([0.0, 0.5, 0.0], math.radians(90))\n\n    minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(main_body)\n    w1 = maxx - minx\n    l1 = maxy - miny\n    h1 = maxz - minz\n    copies = copy_obj(main_body, (w1, l1, h1), 2, 2, 1)\n\n    # i wanted to add another related stl to the final stl\n    twist_lock = mesh.mesh.from_file('ball_and_socket_simplified_-_twist_lock.stl')\n    minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(twist_lock)\n    w2 = maxx - minx\n    l2 = maxy - miny\n    h2 = maxz - minz\n    translate(twist_lock, w1, w1 / 10., 3, 'x')\n    copies2 = copy_obj(twist_lock, (w2, l2, h2), 2, 2, 1)\n    combined = mesh.mesh(numpy.concatenate([main_body.data, twist_lock.data] +\n                                        [copy.data for copy in copies] +\n                                        [copy.data for copy in copies2]))\n\n    combined.save('combined.stl', mode=stl.mode.ascii)  # save as ascii\n\nknown limitations\n------------------------------------------------------------------------------\n\n - when speedups are enabled the stl name is automatically converted to\n   lowercase.\n",
  "docs_url": "https://pythonhosted.org/numpy-stl/",
  "keywords": "",
  "license": "bsd",
  "name": "numpy-stl",
  "package_url": "https://pypi.org/project/numpy-stl/",
  "project_url": "https://pypi.org/project/numpy-stl/",
  "project_urls": {
    "Homepage": "https://github.com/WoLpH/numpy-stl/"
  },
  "release_url": "https://pypi.org/project/numpy-stl/3.1.1/",
  "requires_dist": [
    "numpy",
    "python-utils >=3.4.5"
  ],
  "requires_python": ">3.6.0",
  "summary": "library to make reading, writing and modifying both binary and ascii stl files easy.",
  "version": "3.1.1",
  "releases": [],
  "developers": [
    "rick_van_hattem",
    "wolph@wol.ph"
  ],
  "kwds": "badge pyversions vertice_count numpy _numpy",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_numpy_stl",
  "homepage": "https://github.com/wolph/numpy-stl/",
  "release_count": 67,
  "dependency_ids": [
    "pypi_numpy",
    "pypi_python_utils"
  ]
}