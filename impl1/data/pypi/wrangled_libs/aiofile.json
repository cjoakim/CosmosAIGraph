{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: end users/desktop",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "natural language :: russian",
    "operating system :: macos :: macos x",
    "operating system :: posix :: linux",
    "programming language :: python",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: software development :: libraries",
    "topic :: system",
    "topic :: system :: operating system"
  ],
  "description": "aiofile\n=======\n\n.. image:: https://github.com/mosquito/aiofile/workflows/tox/badge.svg\n    :target: https://github.com/mosquito/aiofile/actions?query=branch%3amaster\n    :alt: github actions\n\n.. image:: https://img.shields.io/pypi/v/aiofile.svg\n    :target: https://pypi.python.org/pypi/aiofile/\n    :alt: latest version\n\n.. image:: https://img.shields.io/pypi/wheel/aiofile.svg\n    :target: https://pypi.python.org/pypi/aiofile/\n\n.. image:: https://img.shields.io/pypi/pyversions/aiofile.svg\n    :target: https://pypi.python.org/pypi/aiofile/\n\n.. image:: https://img.shields.io/pypi/l/aiofile.svg\n    :target: https://pypi.python.org/pypi/aiofile/\n\n.. image:: https://coveralls.io/repos/github/mosquito/aiofile/badge.svg?branch=master\n    :target: https://coveralls.io/github/mosquito/aiofile?branch=master\n\n\n\nreal asynchronous file operations with asyncio support.\n\n\nstatus\n------\n\ndevelopment - stable\n\n\nfeatures\n--------\n\n* since version 2.0.0 using `caio`_, which contains linux ``libaio`` and two\n  thread-based implementations (c-based and pure-python).\n* aiofile has no internal pointer. you should pass ``offset`` and\n  ``chunk_size`` for each operation or use helpers (reader or writer).\n  the simples way is to use ``async_open`` for creating object with\n  file-like interface.\n* for linux using implementation based on `libaio`_.\n* for posix (macos x and optional linux) using implementation\n  based on `threadpool`_.\n* otherwise using pure-python thread-based implementation.\n* implementation chooses automatically depending on system compatibility.\n\n.. _caio: https://pypi.org/project/caio\n.. _libaio: https://pagure.io/libaio\n.. _threadpool: https://github.com/mbrossard/threadpool/\n\n\nlimitations\n-----------\n\n* linux native aio implementation is not able to open special files.\n  asynchronous operations against special fs like ``/proc/`` ``/sys/`` are not\n  supported by the kernel. it's not a `aiofile`s or `caio` issue.\n  in this cases, you might switch to thread-based implementations\n  (see troubleshooting_ section).\n  however, when used on supported file systems, the linux implementation has a\n  smaller overhead and is preferred but it's not a silver bullet.\n\ncode examples\n-------------\n\nall code examples requires python 3.6+.\n\nhigh-level api\n++++++++++++++\n\n``async_open`` helper\n~~~~~~~~~~~~~~~~~~~~~\n\nhelper mimics python file-like objects, it returns file-like\nobjects with similar but async methods.\n\nsupported methods:\n\n* ``async def read(length = -1)`` - reading chunk from file, when length is\n  ``-1``, will be reading file to the end.\n* ``async def write(data)`` - writing chunk to file\n* ``def seek(offset)`` - setting file pointer position\n* ``def tell()`` - returns current file pointer position\n* ``async def readline(size=-1, newline=\"\\n\")`` - read chunks until\n  newline or eof. since version 3.7.0 ``__aiter__`` returns ``linereader``.\n\n  this method is suboptimal for small lines because it doesn't reuse read buffer.\n  when you want to read file by lines please avoid using ``async_open``\n  use ``linereader`` instead.\n* ``def __aiter__() -> linereader`` - iterator over lines.\n* ``def iter_chunked(chunk_size: int = 32768) -> reader`` - iterator over\n  chunks.\n* ``.file`` property contains aiofile object\n\n\nbasic example:\n\n.. code-block:: python\n    :name: test_basic\n\n    import asyncio\n    from pathlib import path\n    from tempfile import gettempdir\n\n    from aiofile import async_open\n\n    tmp_filename = path(gettempdir()) / \"hello.txt\"\n\n    async def main():\n        async with async_open(tmp_filename, 'w+') as afp:\n            await afp.write(\"hello \")\n            await afp.write(\"world\")\n            afp.seek(0)\n\n            print(await afp.read())\n\n            await afp.write(\"hello from\\nasync world\")\n            print(await afp.readline())\n            print(await afp.readline())\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\nexample without context manager:\n\n.. code-block:: python\n    :name: test_no_context_manager\n\n    import asyncio\n    import atexit\n    import os\n    from tempfile import mktemp\n\n    from aiofile import async_open\n\n\n    tmp_name = mktemp()\n    atexit.register(os.unlink, tmp_name)\n\n\n    async def main():\n        afp = await async_open(tmp_name, \"w\")\n        await afp.write(\"hello\")\n        await afp.close()\n\n\n    asyncio.run(main())\n    assert open(tmp_name, \"r\").read() == \"hello\"\n\n\nconcatenate example program (``cat``):\n\n.. code-block:: python\n\n    import asyncio\n    import sys\n    from argparse import argumentparser\n    from pathlib import path\n\n    from aiofile import async_open\n\n    parser = argumentparser(\n        description=\"read files line by line using asynchronous io api\"\n    )\n    parser.add_argument(\"file_name\", nargs=\"+\", type=path)\n\n    async def main(arguments):\n        for src in arguments.file_name:\n            async with async_open(src, \"r\") as afp:\n                async for line in afp:\n                    sys.stdout.write(line)\n\n\n    asyncio.run(main(parser.parse_args()))\n\n\ncopy file example program (``cp``):\n\n.. code-block:: python\n\n    import asyncio\n    from argparse import argumentparser\n    from pathlib import path\n\n    from aiofile import async_open\n\n    parser = argumentparser(\n        description=\"copying files using asynchronous io api\"\n    )\n    parser.add_argument(\"source\", type=path)\n    parser.add_argument(\"dest\", type=path)\n    parser.add_argument(\"--chunk-size\", type=int, default=65535)\n\n\n    async def main(arguments):\n        async with async_open(arguments.source, \"rb\") as src, \\\n                   async_open(arguments.dest, \"wb\") as dest:\n            async for chunk in src.iter_chunked(arguments.chunk_size):\n                await dest.write(chunk)\n\n\n    asyncio.run(main(parser.parse_args()))\n\n\nexample with opening already open file pointer:\n\n.. code-block:: python\n    :name: test_opened\n\n    import asyncio\n    from typing import io, any\n    from aiofile import async_open\n\n\n    async def main(fp: io[any]):\n        async with async_open(fp) as afp:\n            await afp.write(\"hello from\\nasync world\")\n            print(await afp.readline())\n\n\n    with open(\"test.txt\", \"w+\") as fp:\n        asyncio.run(main(fp))\n\n\nlinux native aio doesn't support reading and writing special files\n(e.g. procfs/sysfs/unix pipes/etc.), so you can perform operations with\nthese files using compatible context objects.\n\n.. code-block:: python\n\n    import asyncio\n    from aiofile import async_open\n    from caio import thread_aio_asyncio\n    from contextlib import asyncexitstack\n\n\n    async def main():\n        async with asyncexitstack() as stack:\n\n            # custom context should be reused\n            ctx = await stack.enter_async_context(\n                thread_aio_asyncio.asynciocontext()\n            )\n\n            # open special file with custom context\n            src = await stack.enter_async_context(\n                async_open(\"/proc/cpuinfo\", \"r\", context=ctx)\n            )\n\n            # open regular file with default context\n            dest = await stack.enter_async_context(\n                async_open(\"/tmp/cpuinfo\", \"w\")\n            )\n\n            # copying file content line by line\n            async for line in src:\n                await dest.write(line)\n\n\n    asyncio.run(main())\n\nlow-level api\n++++++++++++++\n\nthe `aiofile` class is a low-level interface for asynchronous file operations, and the read and write methods accept\nan `offset=0` in bytes at which the operation will be performed.\n\nthis allows you to do many independent io operations on an once open file without moving the virtual carriage.\n\nfor example, you may make 10 concurrent http requests by specifying the `range` header, and asynchronously write\none opened file, while the offsets must either be calculated manually, or use 10 instances of `writer` with\nspecified initial offsets.\n\nin order to provide sequential reading and writing, there is `writer`, `reader` and `linereader`. keep in mind\n`async_open` is not the same as aiofile, it provides a similar interface for file operations, it simulates methods\nlike read or write as it is implemented in the built-in open.\n\n.. code-block:: python\n    :name: test_low_level_api\n\n    import asyncio\n    from aiofile import aiofile\n\n\n    async def main():\n        async with aiofile(\"hello.txt\", 'w+') as afp:\n            payload = \"hello world\\n\"\n\n            await asyncio.gather(\n                *[afp.write(payload, offset=i * len(payload)) for i in range(10)]\n            )\n\n            await afp.fsync()\n\n            assert await afp.read(len(payload) * 10) == payload * 10\n\n    asyncio.run(main())\n\nthe low-level api in fact is just little bit sugared ``caio`` api.\n\n.. code-block:: python\n\n    import asyncio\n    from aiofile import aiofile\n\n\n    async def main():\n        async with aiofile(\"/tmp/hello.txt\", 'w+') as afp:\n            await afp.write(\"hello \")\n            await afp.write(\"world\", offset=7)\n            await afp.fsync()\n\n            print(await afp.read())\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n\n``reader`` and ``writer``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwhen you want to read or write file linearly following example\nmight be helpful.\n\n.. code-block:: python\n\n    import asyncio\n    from aiofile import aiofile, reader, writer\n\n\n    async def main():\n        async with aiofile(\"/tmp/hello.txt\", 'w+') as afp:\n            writer = writer(afp)\n            reader = reader(afp, chunk_size=8)\n\n            await writer(\"hello\")\n            await writer(\" \")\n            await writer(\"world\")\n            await afp.fsync()\n\n            async for chunk in reader:\n                print(chunk)\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n\n\n``linereader`` - read file line by line\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nlinereader is a helper that is very effective when you want to read a file\nlinearly and line by line.\n\nit contains a buffer and will read the fragments of the file chunk by\nchunk into the buffer, where it will try to find lines.\n\nthe default chunk size is 4kb.\n\n.. code-block:: python\n\n    import asyncio\n    from aiofile import aiofile, linereader, writer\n\n\n    async def main():\n        async with aiofile(\"/tmp/hello.txt\", 'w+') as afp:\n            writer = writer(afp)\n\n            await writer(\"hello\")\n            await writer(\" \")\n            await writer(\"world\")\n            await writer(\"\\n\")\n            await writer(\"\\n\")\n            await writer(\"from async world\")\n            await afp.fsync()\n\n            async for line in linereader(afp):\n                print(line)\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n\nwhen you want to read file by lines please avoid to use ``async_open``\nuse ``linereader`` instead.\n\n\nmore examples\n-------------\n\nuseful examples with ``aiofile``\n\nasync csv dict reader\n+++++++++++++++++++++\n\n.. code-block:: python\n\n    import asyncio\n    import io\n    from csv import dictreader\n\n    from aiofile import aiofile, linereader\n\n\n    class asyncdictreader:\n        def __init__(self, afp, **kwargs):\n            self.buffer = io.bytesio()\n            self.file_reader = linereader(\n                afp, line_sep=kwargs.pop('line_sep', '\\n'),\n                chunk_size=kwargs.pop('chunk_size', 4096),\n                offset=kwargs.pop('offset', 0),\n            )\n            self.reader = dictreader(\n                io.textiowrapper(\n                    self.buffer,\n                    encoding=kwargs.pop('encoding', 'utf-8'),\n                    errors=kwargs.pop('errors', 'replace'),\n                ), **kwargs,\n            )\n            self.line_num = 0\n\n        def __aiter__(self):\n            return self\n\n        async def __anext__(self):\n            if self.line_num == 0:\n                header = await self.file_reader.readline()\n                self.buffer.write(header)\n\n            line = await self.file_reader.readline()\n\n            if not line:\n                raise stopasynciteration\n\n            self.buffer.write(line)\n            self.buffer.seek(0)\n\n            try:\n                result = next(self.reader)\n            except stopiteration as e:\n                raise stopasynciteration from e\n\n            self.buffer.seek(0)\n            self.buffer.truncate(0)\n            self.line_num = self.reader.line_num\n\n            return result\n\n\n    async def main():\n        async with aiofile('sample.csv', 'rb') as afp:\n            async for item in asyncdictreader(afp):\n                print(item)\n\n\n    asyncio.run(main())\n\n\n.. _troubleshooting:\n\ntroubleshooting\n---------------\n\nthe caio ``linux`` implementation works normal for modern linux kernel versions\nand file systems. so you may have problems specific for your environment.\nit's not a bug and might be resolved some ways:\n\n1. upgrade the kernel\n2. use compatible file systems\n3. use threads based or pure python implementation.\n\nthe caio since version 0.7.0 contains some ways to do this.\n\n1. in runtime use the environment variable ``caio_impl`` with\npossible values:\n\n* ``linux`` - use native linux kernels aio mechanism\n* ``thread`` - use thread based implementation written in c\n* ``python`` - use pure python implementation\n\n2. file ``default_implementation`` located near ``__init__.py`` in caio\ninstallation path. it's useful for distros package maintainers. this file\nmight contains comments (lines starts with ``#`` symbol) and the first line\nshould be one of ``linux`` ``thread`` or ``python``.\n\n3. you might manually manage contexts:\n\n.. code-block:: python\n\n    import asyncio\n\n    from aiofile import async_open\n    from caio import linux_aio_asyncio, thread_aio_asyncio\n\n\n    async def main():\n        linux_ctx = linux_aio_asyncio.asynciocontext()\n        threads_ctx = thread_aio_asyncio.asynciocontext()\n\n        async with async_open(\"/tmp/test.txt\", \"w\", context=linux_ctx) as afp:\n            await afp.write(\"hello\")\n\n        async with async_open(\"/tmp/test.txt\", \"r\", context=threads_ctx) as afp:\n            print(await afp.read())\n\n\n    asyncio.run(main())\n\n\n",
  "docs_url": null,
  "keywords": "aio,python,asyncio,fileio,io",
  "license": "apache 2",
  "name": "aiofile",
  "package_url": "https://pypi.org/project/aiofile/",
  "project_url": "https://pypi.org/project/aiofile/",
  "project_urls": {
    "Homepage": "http://github.com/mosquito/aiofile"
  },
  "release_url": "https://pypi.org/project/aiofile/3.8.8/",
  "requires_dist": [
    "caio (~=0.9.0)",
    "aiomisc-pytest ; extra == 'develop'",
    "pytest ; extra == 'develop'",
    "pytest-rst ; extra == 'develop'",
    "pytest-cov ; extra == 'develop'",
    "coveralls ; extra == 'develop'"
  ],
  "requires_python": ">=3.7, <4",
  "summary": "asynchronous file operations.",
  "version": "3.8.8",
  "releases": [],
  "developers": [
    "me@mosquito.su"
  ],
  "kwds": "aiofile linux_aio_asyncio pathlib fileio thread_aio_asyncio",
  "license_kwds": "apache 2",
  "libtype": "pypi",
  "id": "pypi_aiofile",
  "homepage": "http://github.com/mosquito/aiofile",
  "release_count": 43,
  "dependency_ids": [
    "pypi_aiomisc_pytest",
    "pypi_caio",
    "pypi_coveralls",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_rst"
  ]
}