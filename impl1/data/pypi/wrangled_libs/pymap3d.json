{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "topic :: scientific/engineering :: gis"
  ],
  "description": "# python 3-d coordinate conversions\n\n[![image](https://zenodo.org/badge/doi/10.5281/zenodo.213676.svg)](https://doi.org/10.5281/zenodo.213676)\n[![image](http://joss.theoj.org/papers/10.21105/joss.00580/status.svg)](https://doi.org/10.21105/joss.00580)\n[![codecov](https://codecov.io/gh/geospace-code/pymap3d/branch/main/graph/badge.svg?token=dfwbw6tknr)](https://codecov.io/gh/geospace-code/pymap3d)\n![actions status](https://github.com/geospace-code/pymap3d/workflows/ci/badge.svg)\n![actions status](https://github.com/geospace-code/pymap3d/workflows/ci_stdlib_only/badge.svg)\n[![image](https://img.shields.io/pypi/pyversions/pymap3d.svg)](https://pypi.python.org/pypi/pymap3d)\n[![pypi download stats](http://pepy.tech/badge/pymap3d)](http://pepy.tech/project/pymap3d)\n\npure python (no prerequistes beyond python itself) 3-d geographic coordinate conversions and geodesy.\napi similar to popular $1000 matlab mapping toolbox routines for python\npymap3d is intended for non-interactive use on massively parallel (hpc) and embedded systems.\n\n[api docs](https://geospace-code.github.io/pymap3d/)\n\nthanks to our [contributors](./.github/contributors.md).\n\n## similar toolboxes in other code languages\n\n* [matlab, gnu octave](https://github.com/geospace-code/matmap3d)\n* [fortran](https://github.com/geospace-code/maptran3d)\n* [rust](https://github.com/gberrante/map_3d)\n\n## prerequisites\n\nnumpy and astropy are optional.\nalgorithms from vallado and meeus are used if astropy is not present.\n\n## install\n\n```sh\npython3 -m pip install pymap3d\n```\n\nor for the latest development code:\n\n```sh\ngit clone https://github.com/geospace-code/pymap3d\n\npip install -e pymap3d\n```\n\none can verify python functionality after installation by:\n\n```sh\npytest pymap3d\n```\n\n## usage\n\nwhere consistent with the definition of the functions, all arguments may\nbe arbitrarily shaped (scalar, n-d array).\n\n```python\nimport pymap3d as pm\n\nx,y,z = pm.geodetic2ecef(lat,lon,alt)\n\naz,el,range = pm.geodetic2aer(lat, lon, alt, observer_lat, observer_lon, 0)\n```\n\n[python](https://www.python.org/dev/peps/pep-0448/)\n[argument unpacking](https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists)\ncan be used for compact function arguments with scalars or arbitrarily\nshaped n-d arrays:\n\n```python\naer = (az,el,slantrange)\nobslla = (obs_lat,obs_lon,obs_alt)\n\nlla = pm.aer2geodetic(*aer,*obslla)\n```\n\nwhere tuple `lla` is comprised of scalar or n-d arrays `(lat,lon,alt)`.\n\nexample scripts are in the [examples](./examples) directory.\n\nnative python float is typically [64 bit](https://docs.python.org/3/library/stdtypes.html#typesnumeric).\nnumpy can select real precision bits: 32, 64, 128, etc.\n\n### functions\n\npopular mapping toolbox functions ported to python include the\nfollowing, where the source coordinate system (before the \"2\") is\nconverted to the desired coordinate system:\n\n```\naer2ecef  aer2enu  aer2geodetic  aer2ned\necef2aer  ecef2enu  ecef2enuv  ecef2geodetic  ecef2ned  ecef2nedv\necef2eci  eci2ecef eci2aer aer2eci geodetic2eci eci2geodetic\nenu2aer  enu2ecef   enu2geodetic\ngeodetic2aer  geodetic2ecef  geodetic2enu  geodetic2ned\nned2aer  ned2ecef   ned2geodetic\nazel2radec radec2azel\nlookatspheroid\ntrack2 departure meanm\nrcurve rsphere\ngeod2geoc geoc2geod\ngeodetic2spherical spherical2geodetic\n```\n\nvincenty functions \"vincenty.vreckon\" and \"vincenty.vdist\" are accessed like:\n\n```python\nimport pymap3d.vincenty as pmv\n\nlat2, lon2 = pmv.vreckon(lat1, lon1, ground_range_m, azimuth_deg)\ndist_m, azimuth_deg = pmv.vdist(lat1, lon1, lat2, lon2)\n```\n\nadditional functions:\n\n* loxodrome_inverse: rhumb line distance and azimuth between ellipsoid points (lat,lon)  akin to matlab `distance('rh', ...)` and `azimuth('rh', ...)`\n* loxodrome_direct\n* geodetic latitude transforms to/from: parametric, authalic, isometric, and more in pymap3d.latitude\n\nabbreviations:\n\n* [aer: azimuth, elevation, range](https://en.wikipedia.org/wiki/spherical_coordinate_system)\n* [ecef: earth-centered, earth-fixed](https://en.wikipedia.org/wiki/ecef)\n* [eci: earth-centered inertial using iers](https://www.iers.org/iers/en/home/home_node.html) via `astropy`\n* [enu: east north up](https://en.wikipedia.org/wiki/axes_conventions#ground_reference_frames:_enu_and_ned)\n* [ned: north east down](https://en.wikipedia.org/wiki/north_east_down)\n* [radec: right ascension, declination](https://en.wikipedia.org/wiki/right_ascension)\n\n### ellipsoid\n\nnumerous functions in pymap3d use an ellipsoid model.\nthe default is wgs84 ellipsoid.\nnumerous other ellipsoids are available in pymap3d.ellipsoid.\n\nprint available ellipsoid models:\n\n```python\nimport pymap3d as pm\n\nprint(pm.ellipsoid.models)\n```\n\nspecify grs80 ellipsoid:\n\n```python\nimport pymap3d as pm\n\nell = pm.ellipsoid.from_name('grs80')\n```\n\n### array vs scalar\n\nuse of pymap3d on embedded systems or other streaming data applications often deal with scalar position data.\nthese data are handled efficiently with the python math stdlib module.\nvector data can be handled via list comprehension.\n\nthose needing multidimensional data with simd and other numpy and/or pypy accelerated performance can do so automatically by installing numpy.\npymap3d seamlessly falls back to python's math module if numpy isn't present.\nto keep the code clean, only scalar data can be used without numpy.\nas noted above, use list comprehension if you need vector data without numpy.\n\n### caveats\n\n* atmospheric effects neglected in all functions not invoking astropy.\n  would need to update code to add these input parameters (just start a github issue to request).\n* planetary perturbations and nutation etc. not fully considered.\n\n## notes\n\nas compared to [pyproj](https://github.com/jswhit/pyproj):\n\n* pymap3d does not require anything beyond pure python for most transforms\n* astronomical conversions are done using (optional) astropy for established accuracy\n* pymap3d api is similar to matlab mapping toolbox, while pyproj's interface is quite distinct\n* pymap3d intrinsically handles local coordinate systems such as enu,\n  while pyproj enu requires some [additional effort](https://github.com/jswhit/pyproj/issues/105).\n* pyproj is oriented towards points on the planet surface, while pymap3d handles points on or above the planet surface equally well, particularly important for airborne vehicles and remote sensing.\n\n### astropy.units.quantity\n\nat this time,\n[astropy.units.quantity](http://docs.astropy.org/en/stable/units/)\nis not supported.\nlet us know if this is of interest.\nimpacts on performance would have to be considered before making quantity a first-class citizen.\nfor now, you can workaround by passing in the `.value` of the variable.\n",
  "docs_url": null,
  "keywords": "coordinate-conversion,geodesy",
  "license": "",
  "name": "pymap3d",
  "package_url": "https://pypi.org/project/pymap3d/",
  "project_url": "https://pypi.org/project/pymap3d/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/pymap3d/3.0.1/",
  "requires_dist": [
    "python-dateutil ; extra == 'core'",
    "numpy (>=1.10.0) ; extra == 'core'",
    "pytest-cov ; extra == 'coverage'",
    "black[jupyter] ; extra == 'format'",
    "isort ; extra == 'format'",
    "astropy ; extra == 'full'",
    "xarray ; extra == 'full'",
    "flake8 ; extra == 'lint'",
    "flake8-bugbear ; extra == 'lint'",
    "flake8-builtins ; extra == 'lint'",
    "flake8-blind-except ; extra == 'lint'",
    "mypy ; extra == 'lint'",
    "types-python-dateutil ; extra == 'lint'",
    "types-requests ; extra == 'lint'",
    "pyproj ; extra == 'proj'",
    "pytest ; extra == 'tests'",
    "pytest-timeout ; extra == 'tests'"
  ],
  "requires_python": ">=3.8",
  "summary": "pure python (no prereqs) coordinate conversions, following convention of several popular matlab routines.",
  "version": "3.0.1",
  "releases": [],
  "developers": [],
  "kwds": "pymap3d geodesy map_3d matmap3d spherical_coordinate_system",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pymap3d",
  "homepage": "",
  "release_count": 57,
  "dependency_ids": [
    "pypi_astropy",
    "pypi_black",
    "pypi_flake8",
    "pypi_flake8_blind_except",
    "pypi_flake8_bugbear",
    "pypi_flake8_builtins",
    "pypi_isort",
    "pypi_mypy",
    "pypi_numpy",
    "pypi_pyproj",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_timeout",
    "pypi_python_dateutil",
    "pypi_types_python_dateutil",
    "pypi_types_requests",
    "pypi_xarray"
  ]
}