{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering"
  ],
  "description": "<a href=\"https://explosion.ai\"><img src=\"https://explosion.ai/assets/img/logo.svg\" width=\"125\" height=\"125\" align=\"right\" /></a>\n\n# catalogue: super lightweight function registries for your library\n\n`catalogue` is a tiny, zero-dependencies library that makes it easy to **add\nfunction (or object) registries** to your code. function registries are helpful\nwhen you have objects that need to be both easily serializable and fully\ncustomizable. instead of passing a function into your object, you pass in an\nidentifier name, which the object can use to lookup the function from the\nregistry. this makes the object easy to serialize, because the name is a simple\nstring. if you instead saved the function, you'd have to use pickle for\nserialization, which has many drawbacks.\n\n[![tests](https://github.com/explosion/catalogue/actions/workflows/tests.yml/badge.svg)](https://github.com/explosion/catalogue/actions/workflows/tests.yml)\n[![current release version](https://img.shields.io/github/v/release/explosion/catalogue.svg?style=flat-square&include_prereleases&logo=github)](https://github.com/explosion/catalogue/releases)\n[![pypi version](https://img.shields.io/pypi/v/catalogue.svg?style=flat-square&logo=pypi&logocolor=white)](https://pypi.org/project/catalogue/)\n[![conda version](https://img.shields.io/conda/vn/conda-forge/catalogue.svg?style=flat-square&logo=conda-forge&logocolor=white)](https://anaconda.org/conda-forge/catalogue)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg?style=flat-square)](https://github.com/ambv/black)\n\n## \u23f3 installation\n\n```bash\npip install catalogue\n```\n\n```bash\nconda install -c conda-forge catalogue\n```\n\n> \u26a0\ufe0f **important note:** `catalogue` v2.0+ is only compatible with python 3.6+.\n> for python 2.7+ compatibility, use `catalogue` v1.x.\n\n## \ud83d\udc69\u200d\ud83d\udcbb usage\n\nlet's imagine you're developing a python package that needs to load data\nsomewhere. you've already implemented some loader functions for the most common\ndata types, but you want to allow the user to easily add their own. using\n`catalogue.create` you can create a new registry under the namespace\n`your_package` &rarr; `loaders`.\n\n```python\n# your package\nimport catalogue\n\nloaders = catalogue.create(\"your_package\", \"loaders\")\n```\n\nthis gives you a `loaders.register` decorator that your users can import and\ndecorate their custom loader functions with.\n\n```python\n# user code\nfrom your_package import loaders\n\n@loaders.register(\"custom_loader\")\ndef custom_loader(data):\n    # load something here...\n    return data\n```\n\nthe decorated function will be registered automatically and in your package,\nyou'll be able to access all loaders by calling `loaders.get_all`.\n\n```python\n# your package\ndef load_data(data, loader_id):\n    print(\"all loaders:\", loaders.get_all()) # {\"custom_loader\": <custom_loader>}\n    loader = loaders.get(loader_id)\n    return loader(data)\n```\n\nthe user can now refer to their custom loader using only its string name\n(`\"custom_loader\"`) and your application will know what to do and will use their\ncustom function.\n\n```python\n# user code\nfrom your_package import load_data\n\nload_data(data, loader_id=\"custom_loader\")\n```\n\n## \u2753 faq\n\n#### but can't the user just pass in the `custom_loader` function directly?\n\nsure, that's the more classic callback approach. instead of a string id,\n`load_data` could also take a function, in which case you wouldn't need a\npackage like this. `catalogue` helps you when you need to produce a serializable\nrecord of which functions were passed in. for instance, you might want to write\na log message, or save a config to load back your object later. with\n`catalogue`, your functions can be parameterized by strings, so logging and\nserialization remains easy \u2013 while still giving you full extensibility.\n\n#### how do i make sure all of the registration decorators have run?\n\ndecorators normally run when modules are imported. relying on this side-effect\ncan sometimes lead to confusion, especially if there's no other reason the\nmodule would be imported. one solution is to use\n[entry points](https://packaging.python.org/specifications/entry-points/).\n\nfor instance, in [spacy](https://spacy.io) we're starting to use function\nregistries to make the pipeline components much more customizable. let's say one\nuser, jo, develops a better tagging model using new machine learning research.\nend-users of jo's package should be able to write\n`spacy.load(\"jo_tagging_model\")`. they shouldn't need to remember to write\n`import jos_tagged_model` first, just to run the function registries as a\nside-effect. with entry points, the registration happens at install time \u2013 so\nyou don't need to rely on the import side-effects.\n\n## \ud83c\udf9b api\n\n### <kbd>function</kbd> `catalogue.create`\n\ncreate a new registry for a given namespace. returns a setter function that can\nbe used as a decorator or called with a name and `func` keyword argument. if\n`entry_points=true` is set, the registry will check for\n[python entry points](https://packaging.python.org/tutorials/packaging-projects/#entry-points)\nadvertised for the given namespace, e.g. the entry point group\n`spacy_architectures` for the namespace `\"spacy\", \"architectures\"`, in\n`registry.get` and `registry.get_all`. this allows other packages to\nauto-register functions.\n\n| argument       | type       | description                                                                                    |\n| -------------- | ---------- | ---------------------------------------------------------------------------------------------- |\n| `*namespace`   | str        | the namespace, e.g. `\"spacy\"` or `\"spacy\", \"architectures\"`.                                   |\n| `entry_points` | bool       | whether to check for entry points of the given namespace and pre-populate the global registry. |\n| **returns**    | `registry` | the `registry` object with methods to register and retrieve functions.                         |\n\n```python\narchitectures = catalogue.create(\"spacy\", \"architectures\")\n\n# use as decorator\n@architectures.register(\"custom_architecture\")\ndef custom_architecture():\n    pass\n\n# use as regular function\narchitectures.register(\"custom_architecture\", func=custom_architecture)\n```\n\n### <kbd>class</kbd> `registry`\n\nthe registry object that can be used to register and retrieve functions. it's\nusually created internally when you call `catalogue.create`.\n\n#### <kbd>method</kbd> `registry.__init__`\n\ninitialize a new registry. if `entry_points=true` is set, the registry will\ncheck for\n[python entry points](https://packaging.python.org/tutorials/packaging-projects/#entry-points)\nadvertised for the given namespace, e.g. the entry point group\n`spacy_architectures` for the namespace `\"spacy\", \"architectures\"`, in\n`registry.get` and `registry.get_all`.\n\n| argument       | type       | description                                                                      |\n| -------------- | ---------- | -------------------------------------------------------------------------------- |\n| `namespace`    | tuple[str] | the namespace, e.g. `\"spacy\"` or `\"spacy\", \"architectures\"`.                     |\n| `entry_points` | bool       | whether to check for entry points of the given namespace in `get` and `get_all`. |\n| **returns**    | `registry` | the newly created object.                                                        |\n\n```python\n# user-facing api\narchitectures = catalogue.create(\"spacy\", \"architectures\")\n# internal api\narchitectures = registry((\"spacy\", \"architectures\"))\n```\n\n#### <kbd>method</kbd> `registry.__contains__`\n\ncheck whether a name is in the registry.\n\n| argument    | type | description                          |\n| ----------- | ---- | ------------------------------------ |\n| `name`      | str  | the name to check.                   |\n| **returns** | bool | whether the name is in the registry. |\n\n```python\narchitectures = catalogue.create(\"spacy\", \"architectures\")\n\n@architectures.register(\"custom_architecture\")\ndef custom_architecture():\n    pass\n\nassert \"custom_architecture\" in architectures\n```\n\n#### <kbd>method</kbd> `registry.__call__`\n\nregister a function in the registry's namespace. can be used as a decorator or\ncalled as a function with the `func` keyword argument supplying the function to\nregister. delegates to `registry.register`.\n\n#### <kbd>method</kbd> `registry.register`\n\nregister a function in the registry's namespace. can be used as a decorator or\ncalled as a function with the `func` keyword argument supplying the function to\nregister.\n\n| argument    | type     | description                                               |\n| ----------- | -------- | --------------------------------------------------------- |\n| `name`      | str      | the name to register under the namespace.                 |\n| `func`      | any      | optional function to register (if not used as decorator). |\n| **returns** | callable | the decorator that takes one argument, the name.          |\n\n```python\narchitectures = catalogue.create(\"spacy\", \"architectures\")\n\n# use as decorator\n@architectures.register(\"custom_architecture\")\ndef custom_architecture():\n    pass\n\n# use as regular function\narchitectures.register(\"custom_architecture\", func=custom_architecture)\n```\n\n#### <kbd>method</kbd> `registry.get`\n\nget a function registered in the namespace.\n\n| argument    | type | description              |\n| ----------- | ---- | ------------------------ |\n| `name`      | str  | the name.                |\n| **returns** | any  | the registered function. |\n\n```python\ncustom_architecture = architectures.get(\"custom_architecture\")\n```\n\n#### <kbd>method</kbd> `registry.get_all`\n\nget all functions in the registry's namespace.\n\n| argument    | type           | description                              |\n| ----------- | -------------- | ---------------------------------------- |\n| **returns** | dict[str, any] | the registered functions, keyed by name. |\n\n```python\nall_architectures = architectures.get_all()\n# {\"custom_architecture\": <custom_architecture>}\n```\n\n#### <kbd>method</kbd> `registry.get_entry_points`\n\nget registered entry points from other packages for this namespace. the name of\nthe entry point group is the namespace joined by `_`.\n\n| argument    | type           | description                             |\n| ----------- | -------------- | --------------------------------------- |\n| **returns** | dict[str, any] | the loaded entry points, keyed by name. |\n\n```python\narchitectures = catalogue.create(\"spacy\", \"architectures\", entry_points=true)\n# will get all entry points of the group \"spacy_architectures\"\nall_entry_points = architectures.get_entry_points()\n```\n\n#### <kbd>method</kbd> `registry.get_entry_point`\n\ncheck if registered entry point is available for a given name in the namespace\nand load it. otherwise, return the default value.\n\n| argument    | type | description                                      |\n| ----------- | ---- | ------------------------------------------------ |\n| `name`      | str  | name of entry point to load.                     |\n| `default`   | any  | the default value to return. defaults to `none`. |\n| **returns** | any  | the loaded entry point or the default value.     |\n\n```python\narchitectures = catalogue.create(\"spacy\", \"architectures\", entry_points=true)\n# will get entry point \"custom_architecture\" of the group \"spacy_architectures\"\ncustom_architecture = architectures.get_entry_point(\"custom_architecture\")\n```\n\n#### <kbd>method</kbd> `registry.find`\n\nfind the information about a registered function, including the module and path\nto the file it's defined in, the line number and the docstring, if available.\n\n| argument    | type                       | description                         |\n| ----------- | -------------------------- | ----------------------------------- |\n| `name`      | str                        | name of the registered function.    |\n| **returns** | dict[str, union[str, int]] | the information about the function. |\n\n```python\nimport catalogue\n\narchitectures = catalogue.create(\"spacy\", \"architectures\", entry_points=true)\n\n@architectures(\"my_architecture\")\ndef my_architecture():\n    \"\"\"this is an architecture\"\"\"\n    pass\n\ninfo = architectures.find(\"my_architecture\")\n# {'module': 'your_package.architectures',\n#  'file': '/path/to/your_package/architectures.py',\n#  'line_no': 5,\n#  'docstring': 'this is an architecture'}\n```\n\n### <kbd>function</kbd> `catalogue.check_exists`\n\ncheck if a namespace exists.\n\n| argument     | type | description                                                  |\n| ------------ | ---- | ------------------------------------------------------------ |\n| `*namespace` | str  | the namespace, e.g. `\"spacy\"` or `\"spacy\", \"architectures\"`. |\n| **returns**  | bool | whether the namespace exists.                                |\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "catalogue",
  "package_url": "https://pypi.org/project/catalogue/",
  "project_url": "https://pypi.org/project/catalogue/",
  "project_urls": {
    "Homepage": "https://github.com/explosion/catalogue"
  },
  "release_url": "https://pypi.org/project/catalogue/2.0.10/",
  "requires_dist": [
    "zipp >=0.5 ; python_version < \"3.8\"",
    "typing-extensions >=3.6.4 ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.6",
  "summary": "super lightweight function registries for your library",
  "version": "2.0.10",
  "releases": [],
  "developers": [
    "contact@explosion.ai",
    "explosion"
  ],
  "kwds": "img svg catalogue logo explosion",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_catalogue",
  "homepage": "https://github.com/explosion/catalogue",
  "release_count": 24,
  "dependency_ids": [
    "pypi_typing_extensions",
    "pypi_zipp"
  ]
}