{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: gnu general public license (gpl)",
    "operating system :: os independent",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "topic :: software development",
    "topic :: text processing :: linguistic",
    "topic :: utilities"
  ],
  "description": "scspell\n=======\n\n.. image:: https://travis-ci.org/myint/scspell.svg?branch=master\n    :target: https://travis-ci.org/myint/scspell\n    :alt: build status\n\n**scspell** is a spell checker for source code. this is an unofficial fork (of\nhttps://launchpad.net/scspell) that runs on both python 2 and 3.\n\n**scspell** does not try to be particularly smart--rather, it does the simplest\nthing that can possibly work:\n\n    1. all alphanumeric strings (strings of letters, numbers, and\n       underscores) are spell-checked tokens.\n    2. each token is split into one or more subtokens. underscores and digits\n       always divide tokens, and capital letters will begin new subtokens. in\n       other words, ``some_variable`` and ``somevariable`` will both generate\n       the subtoken list {``some``, ``variable``}.\n    3. all subtokens longer than three characters are matched against a set of\n       dictionaries, and a match failure prompts the user for action. when\n       matching against the included english dictionary, *prefix matching* is\n       employed; this choice permits the use of truncated words like ``dict``\n       as valid subtokens.\n\nwhen applied to code written in most popular programming languages while using\ntypical naming conventions, this algorithm will usually catch many errors\nwithout an annoying false positive rate.\n\nin an effort to catch more spelling errors, **scspell** is able to check each\nfile against a set of dictionary words selected *specifically for that file*. up\nto three different sub-dictionaries may be searched for any given file:\n\n    1. a natural language dictionary. (**scspell** provides an american\n       english dictionary as the default.)\n    2. a programming language-specific dictionary, intended to contain\n       oddly-spelled keywords and apis associated with that language.\n       (**scspell** provides small default dictionaries for a number of popular\n       programming languages.)\n    3. a file-specific dictionary, intended to contain uncommon strings which\n       are not likely to be found in more than a handful of unique files.\n\nusage\n-----\n\nto begin the spell checker, run ::\n\n    $ scspell source_file1 source_file2 ...\n\nfor each spell check failure, you will see output much like this::\n\n    filename.c:27: unmatched 'somemispeldvaraible' -> {mispeld, varaible}\n\nin other words, the token \"``somemispeldvaraible``\" was found on line 27\nof ``filename.c``, and it contains subtokens \"``mispeld``\" and\n\"``varaible``\" which both failed the spell-checking algorithm. you will\nbe prompted for an action to take:\n\n    (i)gnore\n        skip to the next unmatched token, without taking any action.\n\n    (i)gnore all\n        skip over this token every time it is encountered, for the\n        remainder of this spell check session.\n\n    (r)eplace\n        enter some text to use as a replacement for this token, and replace\n        only the token at this point in the file.\n\n    (r)eplace all\n        enter some text to use as a replacement for this token, and replace\n        every occurrence of the token until the end of the current file.\n\n    (a)dd to dictionary\n        add one or more tokens to one of the dictionaries (see below).\n\n    show (c)ontext\n        print out some lines of context surrounding the unmatched token.\n\nif you accidentally select a replacement operation, enter an empty\nstring to cancel.\n\nif you select the ``(a)dd to dictionary`` option, then you will be\nprompted with the following options for every subtoken:\n\n    (b)ack\n        return to the previous menu, without taking any action.\n\n    (i)gnore\n        skip to the next subtoken, without taking any action.\n\n    add to (p)rogramming language dictionary\n        add this subtoken to the dictionary associated with the\n        programming language of the current file. **scspell** uses the\n        file extension to determine the language, so you will only\n        see this option for files which have an extension.\n\n    add to (f)ile-specific dictionary\n        add this subtoken to the dictionary associated with the\n        current file. you will see this option only for files which\n        have such an embedded id or which have an entry in the file id\n        mapping.  see `creating file ids`_ for details.\n\n    add to (n)ew file-specific dictionary\n        create a new file id for the current file, record the new\n        file id in the file id mapping, and add this subtoken to a new\n        file-specific dictionary associated with that file id.  you will\n        see this option only for files which have neither an embedded id nor\n        an entry in the file id mapping, and only if the ``--relative-to``\n\toption is given.  see `creating file ids`_ for details.\n\n    add to (n)atural language dictionary\n        add this subtoken to the natural language dictionary.\n\nif scspell finds no unknown tokens, it exits with exit status 0.  if\nthere were unknown tokens, it exits with exit status 1.  if it\nterminates in response to a (handled) signal such as a sigint from ^c,\nit exits with exit status 2.\n\n\nspell-checking options\n----------------------\n\n--report-only\\ \n this option causes **scspell** to report to stderr a report of the\n subtokens that it considers to be in error, instead of offering the\n interactive menu described above.  for each subtoken, the report\n includes the filename, line number, and full token.  **scspell** will\n exit with an exit code of 1 if any errors are found, or 0 if the run\n was clean.\n\n the format of the reported errors is different than the interactive\n mode reports them.  with ``--report-only``, the above one would appear\n like this::\n\n    filename.c:27: 'mispeld', 'varaible' were not found in the dictionary (from token 'somemispeldvaraible')\n\n\n--no-c-escapes\\ \n by default, **scspell** treats files as if they contain c-style\n character escapes.  that is, given ``printf(\"hello\\nworld.\")``, it will\n consider the tokens \"``hello``\" and \"``world``\", not \"``nworld``\".\n\n the ``--no-c-escapes`` option causes **scspell** to not treat ``\\`` as a\n special character, for e.g. latex files where you might write\n ``\\alpha\\beta\\gamma\\delta``.  without this option, **scspell** would\n see the tokens \"``lpha``\", \"``eta``\", \"``amma``\", and \"``elta``\".\n\n\ncreating file ids\n-----------------\n\nif you would like **scspell** to be able to uniquely identify a file,\nthus enabling the creation of a file-specific dictionary, then\n**scspell** must be able to find a file id to identify both the file\nan the file-specific dictionary.  there are two ways **scspell** can\nfind the file id:\n\n1. the file id may be embedded directly in the file, using a string of\n   the following form::\n\n      scspell-id: <unique id>\n\n2. an entry in the file id mapping file ties a filename to a file id.\n\nthe unique id must consist only of letters, numbers, underscores, and dashes.\n**scspell** can generate suitable unique id strings using the ``--gen-id`` option::\n\n    $ scspell --gen-id\n    scspell-id: e497803c-523a-11de-ae42-0017f2ee0f37\n\n(most likely you will want to place a file's unique id inside a source code comment.)\n\nduring interactive use, the ``(a)dd to dictionary`` -> ``add to (n)ew\nfile-specific dictionary`` option will create a new file id for the\ncurrent file, and add it to the file id mapping file.\n\n\n--relative-to relative_to\\ \n the filenames stored in the file id mapping are relative paths.  this\n option specifies what they're relative to.  if this option is not\n specified, the file id mapping will not be consulted, and the ``add to (n)ew\n file-specific dictionary`` option will not be offered.\n\n\n\nmanaging file ids\n-----------------\n\nthese options direct **scspell** to manipulate the file id mapping.\n(these can all be accomplished by editing the file id mapping\nmanually).  these have no effect on file ids embedded in files.\n\n--rename-file from_file to_file\n   changes the filename that a file id maps to.  after renaming a file\n   that has a file-specific dictionary and an entry in the file id\n   mapping, you can use this option to have the entry \"follow\" the file.\n\n--delete-files\\ \n   remove filenames from the file id mapping.  if it was the only\n   filename for a given file id, removes the file id from the mapping and\n   its wordlist from the dictionary.\n\n--merge-file-ids from_id to_id\n  combines the file-specific dictionaries referenced by the two file\n  ids.  all words from from_ids list are moved to to_ids.  the from_id\n  file id is removed from the mapping, and any files using it are\n  changed to use to_id.  either from_id or to_id may be given as a filename\n  instead, in which case that file's file id is used for that parameter.\n\n\nsharing a dictionary\n--------------------\n\na team of developers working on the same source tree may wish to share a common\ndictionary. you can permanently set the location of a shared dictionary by\nexecuting ::\n\n    $ scspell --set-dictionary=/path/to/dictionary_file.txt\n\nthe dictionary is formatted as a simple newline-separated list of words, so it\ncan easily be managed by a version control system if desired.\n\nthe current dictionary can be saved to a file by executing ::\n\n    $ scspell --export-dictionary=/path/to/output_file.txt\n\nyou can also override the dictionary location for a single spell check session,\nby using the ``--override-dictionary`` option::\n\n    $ scspell --override-dictionary=/path/to/dictionary_file.txt source_file1 ...\n\n--base-dict base_dict\\\n   a *base dictionary* is consulted for its words, but is not modified\n   at runtime.  by using\n\n    $ scspell --base-dict ~/.dict --override-dictionary proj/.dict source...\n\n   words added at runtime will be added to ``proj/.dict``, and\n   ``~/.dict`` will be left alone.  this way ``proj/.dict`` may be\n   limited only to the words added for ``proj/``.  this may be more\n   convenient when ``proj/.dict`` is committed to source control and\n   shared by many users.\n\n--use-builtin-base-dict\\\n   use the dictionary file shipped with scspell as a base dictionary.\n\n--filter-out-base-dicts\\\n   read the dictionary specified by the normal dictionary selection\n   options, called the ``project dict`` here.  read the base\n   dictionaries specified by the base-dict options.  remove from the\n   project dict all the words from the base dicts, and write the\n   project dict back out.\n\n   this may be useful when a project dict has been generated with an\n   older version of **scspell** that did not support base dicts.\n\n\ninstallation\n------------\n\ninstall **scspell** via pip::\n\n    $ pip install scspell3k\n\nalternatively, download and unpack the source archive, switch to the\narchive root directory, and run the installation script::\n\n    $ python setup.py install\n\non a unix-like system, you may need to use ``sudo`` if installing to a\ndirectory that requires root privileges::\n\n    $ sudo python setup.py install\n\nlicense\n-------\n\n**scspell** is free software, licensed under version 2 of the gnu general\npublic license; see ``copying.txt`` for details.\n\nthe english dictionary distributed with scspell is derived from the\n`scowl word lists <http://wordlist.sourceforge.net>`_ . see\n``scowl-license.txt`` for the myriad licenses that apply to that dictionary.",
  "docs_url": null,
  "keywords": "",
  "license": "gpl 2",
  "name": "scspell3k",
  "package_url": "https://pypi.org/project/scspell3k/",
  "project_url": "https://pypi.org/project/scspell3k/",
  "project_urls": {
    "Homepage": "https://github.com/myint/scspell"
  },
  "release_url": "https://pypi.org/project/scspell3k/2.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a conservative interactive spell checker for source code.",
  "version": "2.2",
  "releases": [],
  "developers": [],
  "kwds": "scspell scspell3k tokens token spell",
  "license_kwds": "gpl 2",
  "libtype": "pypi",
  "id": "pypi_scspell3k",
  "homepage": "https://github.com/myint/scspell",
  "release_count": 10,
  "dependency_ids": []
}