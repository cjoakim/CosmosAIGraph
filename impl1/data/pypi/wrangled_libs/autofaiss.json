{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# autofaiss\n\n[![pypi](https://img.shields.io/pypi/v/autofaiss.svg)](https://pypi.python.org/pypi/autofaiss)\n[![ci](https://github.com/criteo/autofaiss/workflows/continuous%20integration/badge.svg)](https://github.com/criteo/autofaiss/actions?query=workflow%3a%22continuous+integration%22)\n[![open in colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/criteo/autofaiss/blob/master/docs/notebooks/autofaiss_getting_started.ipynb)\n\n**automatically create faiss knn indices with the most optimal similarity search parameters.**\n\nit selects the best indexing parameters to achieve the highest recalls given memory and query speed constraints.\n\n## doc and posts and notebooks\n\nusing [faiss](https://github.com/facebookresearch/faiss) efficient indices, binary search, and heuristics, autofaiss makes it possible to *automatically* build in 3 hours a large (200 million vectors, 1tb) knn index in a low amount of memory (15 gb) with latency in milliseconds (10ms).\n\nget started by running this [colab notebook](https://colab.research.google.com/github/criteo/autofaiss/blob/master/docs/notebooks/autofaiss_getting_started.ipynb), then check the [full documentation](https://criteo.github.io/autofaiss).  \nget some insights on the automatic index selection function with this [colab notebook](https://colab.research.google.com/github/criteo/autofaiss/blob/master/docs/notebooks/autofaiss_index_selection_demo.ipynb).\n\nthen you can check our [multimodal search example](https://colab.research.google.com/github/criteo/autofaiss/blob/master/docs/notebooks/autofaiss_multimodal_search.ipynb) (using openai clip model).\n\nread the [medium post](https://medium.com/criteo-engineering/introducing-autofaiss-an-automatic-k-nearest-neighbor-indexing-library-at-scale-c90842005a11) to learn more about it!\n\n## installation\n\nto install run `pip install autofaiss`\n\nit's probably best to create a virtual env:\n``` bash\npython -m venv .venv/autofaiss_env\nsource .venv/autofaiss_env/bin/activate\npip install -u pip\npip install autofaiss\n```\n\n## using autofaiss in python\n\nif you want to use autofaiss directly from python, check the [api documentation](https://criteo.github.io/autofaiss/api/api.html) and the [examples](examples)\n\nin particular you can use autofaiss with on memory or on disk embeddings collections:\n\n### using in memory numpy arrays\n\nif you have a few embeddings, you can use autofaiss with in memory numpy arrays:\n\n```python\nfrom autofaiss import build_index\nimport numpy as np\n\nembeddings = np.float32(np.random.rand(100, 512))\nindex, index_infos = build_index(embeddings, save_on_disk=false)\n\nquery = np.float32(np.random.rand(1, 512))\n_, i = index.search(query, 1)\nprint(i)\n```\n\n### using numpy arrays saved as .npy files\n\nif you have many embeddings file, it is preferred to save them on disk as .npy files then use autofaiss like this:\n\n```python\nfrom autofaiss import build_index\n\nbuild_index(embeddings=\"embeddings\", index_path=\"my_index_folder/knn.index\",\n            index_infos_path=\"my_index_folder/index_infos.json\", max_index_memory_usage=\"4g\",\n            current_memory_available=\"4g\")\n```\n\n## memory-mapped indices\n\nfaiss makes it possible to use memory-mapped indices. this is useful when you don't need a fast search time (>50ms)\nand still want to reduce the memory footprint to the minimum.\n\nwe provide the should_be_memory_mappable boolean in build_index function to generate memory-mapped indices only.\nnote: only ivf indices can be memory-mapped in faiss, so the output index will be a ivf index.\n\nto load an index in memory mapping mode, use the following code:\n```python\nimport faiss\nfaiss.read_index(\"my_index_folder/knn.index\", faiss.io_flag_mmap | faiss.io_flag_read_only)\n```\n\nyou can have a look to the [examples](examples/memory_mapped_autofaiss.py) to see how to use it.\n\ntechnical note: you can create a direct map on ivf indices with index.make_direct_map() (or directly from the\nbuild_index function by passing the make_direct_map boolean). doing this speeds up a lot\nthe .reconstruct() method, function that gives you the value of one of your vector given its rank.\nhowever, this mapping will be stored in ram... we advise you to create your own direct map in a memory-mapped\nnumpy array and then call .reconstruct_from_offset() with your custom direct_map.\n\n## using autofaiss with pyspark\n\nautofaiss allows you to build indices with spark for the following two use cases:\n- to build a big index in a distributed way\n- given a partitioned dataset of embeddings, building one index per partition in parallel and in a distributed way.\n\nprerequisities:\n\n1. install pyspark: `pip install pyspark`.\n2. prepare your embeddings files (partitioned or not).\n3. create a spark session before calling autofaiss. if no spark session exists, a default session will be creaed with a minimum configuration.\n\n### creating a big index in a distributed way\n\nsee [distributed_autofaiss.md](docs/distributed/distributed_autofaiss.md) for a complete guide.\n\nit is possible to generate an index that would require more memory than what's available. to do so, you can control the number of index splits that will compose your index with `nb_indices_to_keep`.\nfor example, if `nb_indices_to_keep` is 10 and `index_path` is `knn.index`, the final index will be decomposed into 10 smaller indexes:\n - `knn.index01`\n - `knn.index02`\n - `knn.index03`\n - ...\n - `knn.index10`\n\na [concrete example](examples/distributed_autofaiss_n_indices.py) shows how to produce n indices and how to use them.\n\n### creating partitioned indexes\n\ngiven a partitioned dataset of embeddings, it is possible to create one index per partition by calling the method `build_partitioned_indexes`.\n\nsee this [example](examples/partitioned_indexes.py) that shows how to create partitioned indexes.\n\n## using the command line\n\ncreate embeddings\n``` python\nimport os\nimport numpy as np\nembeddings = np.random.rand(1000, 100)\nos.mkdir(\"embeddings\")\nnp.save(\"embeddings/part1.npy\", embeddings)\nos.mkdir(\"my_index_folder\")\n```\n\ngenerate a knn index\n``` bash\nautofaiss build_index --embeddings=\"embeddings\" --index_path=\"my_index_folder/knn.index\" --index_infos_path=\"my_index_folder/index_infos.json\" --metric_type=\"ip\"\n```\n\ntry the index\n``` python\nimport faiss\nimport glob\nimport numpy as np\n\nmy_index = faiss.read_index(glob.glob(\"my_index_folder/*.index\")[0])\n\nquery_vector = np.float32(np.random.rand(1, 100))\nk = 5\ndistances, indices = my_index.search(query_vector, k)\n\nprint(list(zip(distances[0], indices[0])))\n```\n\n## how are indices selected ?\n\nto understand better why indices are selected and what are their characteristics, check the [index selection demo](https://colab.research.google.com/github/criteo/autofaiss/blob/master/docs/notebooks/autofaiss_index_selection_demo.ipynb)\n\n## command quick overview\nquick description of the `autofaiss build_index` command:\n\n*embeddings*        -> source path of the embeddings in numpy.  \n*index_path*                -> destination path of the created index.\n*index_infos_path*          -> destination path of the index infos.\n*save_on_disk*              -> save the index on the disk.\n*metric_type*               -> similarity distance for the queries.  \n\n*index_key*                 -> (optional) describe the index to build.  \n*index_param*               -> (optional) describe the hyperparameters of the index.  \n*current_memory_available*  -> (optional) describe the amount of memory available on the machine.  \n*use_gpu*                   -> (optional) whether to use gpu or not (not tested).  \n\n## command details\n\nthe `autofaiss build_index` command takes the following parameters:\n\n| flag available               |  default     | description                                                                                                                                                                                                                                               |\n|------------------------------|:------------:|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| --embeddings                 | required     | directory (or list of directories) containing your .npy embedding files. if there are several files, they are read in the lexicographical order. this can be a local path or a path in another filesystem e.g. `hdfs://root/...` or `s3://...`                                                                                                        |\n| --index_path                 | required     | destination path of the faiss index on local machine.                                                                                                                                                                                                     |\n| --index_infos_path           | required     | destination path of the faiss index infos on local machine.                                                                                                                                                                                                     |\n| --save_on_disk               | required     | save the index on the disk.                                                                                                                                                                                                     |\n| --file_format                | \"npy\"        | file format of the files in embeddings can be either `npy` for numpy matrix files or `parquet` for parquet serialized tables |\n| --embedding_column_name      | \"embeddings\" | only necessary when file_format=`parquet` in this case this is the name of the column containing the embeddings (one vector per row) |\n| --id_columns                 | none         | can only be used when file_format=`parquet`. in this case these are the names of the columns containing the ids of the vectors, and separate files will be generated to map these ids to indices in the knn index |\n| --ids_path                   | none         | only useful when id_columns is not none and file_format=`parquet`. this will be the path (in any filesystem) where the mapping files ids->vector index will be store in parquet format|\n| --metric_type                |   \"ip\"       | (optional) similarity function used for query: (\"ip\" for inner product, \"l2\" for euclidian distance)                                                                                                                                                                                                            |\n| --max_index_memory_usage     |  \"32gb\"      | (optional) maximum size in gb of the created index, this bound is strict.                                                                                                                        |\n| --current_memory_available   |  \"32gb\"      | (optional) memory available (in gb) on the machine creating the index, having more memory is a boost because it reduces the swipe between ram and disk.                                                                               |\n| --max_index_query_time_ms    |    10        | (optional) bound on the query time for knn search, this bound is approximative.                                                                                                                                   |\n| --min_nearest_neighbors_to_retrieve |    20        | (optional) minimum number of nearest neighbors to retrieve when querying the index. parameter used only during index hyperparameter finetuning step, it is not taken into account to select the indexing algorithm. this parameter has the priority over the max_index_query_time_ms constraint.                                                                                                                                      |\n| --index_key                  |   none       | (optional) if present, the faiss index will be build using this description string in the index_factory, more detail in the [faiss documentation](https://github.com/facebookresearch/faiss/wiki/the-index-factory)\n| --index_param                |   none       | (optional) if present, the faiss index will be set using this description string of hyperparameters, more detail in the [faiss documentation](https://github.com/facebookresearch/faiss/wiki/index-io,-cloning-and-hyper-parameter-tuning) |\n| --use_gpu                    |   false      | (optional) experimental, gpu training can be faster, but this feature is not tested so far.                                                                                                                                         |\n| --nb_cores                   |   none       | (optional) the number of cores to use, by default will use all cores                                                                                                                                         |\n| --make_direct_map            |   false      | (optional) create a direct map allowing reconstruction of embeddings. this is only needed for ivf indices. note that might increase the ram usage (approximately 8gb for 1 billion embeddings).                                                                                                                                         |\n| --should_be_memory_mappable  |   false      | (optional) boolean used to force the index to be selected among indices having an on-disk memory-mapping implementation.                                                                                                                                             |\n| --distributed                |   none       | (optional) if \"pyspark\", create the index using pyspark. otherwise, the index is created on your local machine.|\n| --temporary_indices_folder   |   \"hdfs://root/tmp/distributed_autofaiss_indices\"       | (optional) folder to save the temporary small indices, only used when distributed = \"pyspark\" |\n| --verbose                    |   20         | (optional) set verbosity of logging output: debug=10, info=20, warn=30, error=40, critical=50 |\n| --nb_indices_to_keep         |   1          | (optional) number of indices to keep at most when distributed is \"pyspark\". |\n\n## install from source\n\nfirst, create a virtual env and install dependencies:\n```\npython3 -m venv .env\nsource .env/bin/activate\nmake install\n```\n\n\n`python -m pytest -x -s -v tests -k \"test_get_optimal_hyperparameters\"` to run a specific test\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "autofaiss",
  "package_url": "https://pypi.org/project/autofaiss/",
  "project_url": "https://pypi.org/project/autofaiss/",
  "project_urls": {
    "Homepage": "https://github.com/criteo/autofaiss"
  },
  "release_url": "https://pypi.org/project/autofaiss/2.15.8/",
  "requires_dist": [
    "fire (<0.5.0,>=0.4.0)",
    "numpy (<2,>=1.19.5)",
    "pandas (<2,>=1.1.5)",
    "pyarrow (<13,>=6.0.1)",
    "tqdm (<5,>=4.62.3)",
    "fsspec (>=2022.1.0)",
    "embedding-reader (<2,>=1.5.1)",
    "dataclasses (<1.0.0,>=0.6) ; python_version < \"3.7\"",
    "faiss-cpu (<1.7.3) ; python_version < \"3.7\"",
    "faiss-cpu (<2,>=1) ; python_version >= \"3.7\""
  ],
  "requires_python": "",
  "summary": "# autofaiss",
  "version": "2.15.8",
  "releases": [],
  "developers": [
    "criteo"
  ],
  "kwds": "distributed_autofaiss_n_indices distributed_autofaiss_indices autofaiss_index_selection_demo autofaiss_multimodal_search autofaiss",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_autofaiss",
  "homepage": "https://github.com/criteo/autofaiss",
  "release_count": 66,
  "dependency_ids": [
    "pypi_dataclasses",
    "pypi_embedding_reader",
    "pypi_faiss_cpu",
    "pypi_fire",
    "pypi_fsspec",
    "pypi_numpy",
    "pypi_pandas",
    "pypi_pyarrow",
    "pypi_tqdm"
  ]
}