{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "elasticsearch dsl\n=================\n\nelasticsearch dsl is a high-level library whose aim is to help with writing and\nrunning queries against elasticsearch. it is built on top of the official\nlow-level client (`elasticsearch-py <https://github.com/elastic/elasticsearch-py>`_).\n\nit provides a more convenient and idiomatic way to write and manipulate\nqueries. it stays close to the elasticsearch json dsl, mirroring its\nterminology and structure. it exposes the whole range of the dsl from python\neither directly using defined classes or a queryset-like expressions.\n\nit also provides an optional wrapper for working with documents as python\nobjects: defining mappings, retrieving and saving documents, wrapping the\ndocument data in user-defined classes.\n\nto use the other elasticsearch apis (eg. cluster health) just use the\nunderlying client.\n\ninstallation\n------------\n\n::\n\n  pip install elasticsearch-dsl\n\nexamples\n--------\n\nplease see the `examples\n<https://github.com/elastic/elasticsearch-dsl-py/tree/master/examples>`_\ndirectory to see some complex examples using ``elasticsearch-dsl``.\n\ncompatibility\n-------------\n\nthe library is compatible with all elasticsearch versions since ``2.x`` but you\n**have to use a matching major version**:\n\nfor **elasticsearch 8.0** and later, use the major version 8 (``8.x.y``) of the\nlibrary.\n\nfor **elasticsearch 7.0** and later, use the major version 7 (``7.x.y``) of the\nlibrary.\n\nfor **elasticsearch 6.0** and later, use the major version 6 (``6.x.y``) of the\nlibrary.\n\nfor **elasticsearch 5.0** and later, use the major version 5 (``5.x.y``) of the\nlibrary.\n\nfor **elasticsearch 2.0** and later, use the major version 2 (``2.x.y``) of the\nlibrary.\n\nthe recommended way to set your requirements in your `setup.py` or\n`requirements.txt` is::\n\n    # elasticsearch 8.x\n    elasticsearch-dsl>=8.0.0,<9.0.0\n\n    # elasticsearch 7.x\n    elasticsearch-dsl>=7.0.0,<8.0.0\n\n    # elasticsearch 6.x\n    elasticsearch-dsl>=6.0.0,<7.0.0\n\n    # elasticsearch 5.x\n    elasticsearch-dsl>=5.0.0,<6.0.0\n\n    # elasticsearch 2.x\n    elasticsearch-dsl>=2.0.0,<3.0.0\n\n\nthe development is happening on ``main``, older branches only get bugfix releases\n\nsearch example\n--------------\n\nlet's have a typical search request written directly as a ``dict``:\n\n.. code:: python\n\n    from elasticsearch import elasticsearch\n    client = elasticsearch(\"https://localhost:9200\")\n\n    response = client.search(\n        index=\"my-index\",\n        body={\n          \"query\": {\n            \"bool\": {\n              \"must\": [{\"match\": {\"title\": \"python\"}}],\n              \"must_not\": [{\"match\": {\"description\": \"beta\"}}],\n              \"filter\": [{\"term\": {\"category\": \"search\"}}]\n            }\n          },\n          \"aggs\" : {\n            \"per_tag\": {\n              \"terms\": {\"field\": \"tags\"},\n              \"aggs\": {\n                \"max_lines\": {\"max\": {\"field\": \"lines\"}}\n              }\n            }\n          }\n        }\n    )\n\n    for hit in response['hits']['hits']:\n        print(hit['_score'], hit['_source']['title'])\n\n    for tag in response['aggregations']['per_tag']['buckets']:\n        print(tag['key'], tag['max_lines']['value'])\n\n\n\nthe problem with this approach is that it is very verbose, prone to syntax\nmistakes like incorrect nesting, hard to modify (eg. adding another filter) and\ndefinitely not fun to write.\n\nlet's rewrite the example using the python dsl:\n\n.. code:: python\n\n    from elasticsearch import elasticsearch\n    from elasticsearch_dsl import search\n\n    client = elasticsearch(\"https://localhost:9200\")\n\n    s = search(using=client, index=\"my-index\") \\\n        .filter(\"term\", category=\"search\") \\\n        .query(\"match\", title=\"python\")   \\\n        .exclude(\"match\", description=\"beta\")\n\n    s.aggs.bucket('per_tag', 'terms', field='tags') \\\n        .metric('max_lines', 'max', field='lines')\n\n    response = s.execute()\n\n    for hit in response:\n        print(hit.meta.score, hit.title)\n\n    for tag in response.aggregations.per_tag.buckets:\n        print(tag.key, tag.max_lines.value)\n\nas you see, the library took care of:\n\n- creating appropriate ``query`` objects by name (eq. \"match\")\n- composing queries into a compound ``bool`` query\n- putting the ``term`` query in a filter context of the ``bool`` query\n- providing a convenient access to response data\n- no curly or square brackets everywhere\n\n\npersistence example\n-------------------\n\nlet's have a simple python class representing an article in a blogging system:\n\n.. code:: python\n\n    from datetime import datetime\n    from elasticsearch_dsl import document, date, integer, keyword, text, connections\n\n    # define a default elasticsearch client\n    connections.create_connection(hosts=\"https://localhost:9200\")\n\n    class article(document):\n        title = text(analyzer='snowball', fields={'raw': keyword()})\n        body = text(analyzer='snowball')\n        tags = keyword()\n        published_from = date()\n        lines = integer()\n\n        class index:\n            name = 'blog'\n            settings = {\n              \"number_of_shards\": 2,\n            }\n\n        def save(self, ** kwargs):\n            self.lines = len(self.body.split())\n            return super(article, self).save(** kwargs)\n\n        def is_published(self):\n            return datetime.now() > self.published_from\n\n    # create the mappings in elasticsearch\n    article.init()\n\n    # create and save and article\n    article = article(meta={'id': 42}, title='hello world!', tags=['test'])\n    article.body = ''' looong text '''\n    article.published_from = datetime.now()\n    article.save()\n\n    article = article.get(id=42)\n    print(article.is_published())\n\n    # display cluster health\n    print(connections.get_connection().cluster.health())\n\n\nin this example you can see:\n\n- providing a default connection\n- defining fields with mapping configuration\n- setting index name\n- defining custom methods\n- overriding the built-in ``.save()`` method to hook into the persistence\n  life cycle\n- retrieving and saving the object into elasticsearch\n- accessing the underlying client for other apis\n\nyou can see more in the persistence chapter of the documentation.\n\nmigration from ``elasticsearch-py``\n-----------------------------------\n\nyou don't have to port your entire application to get the benefits of the\npython dsl, you can start gradually by creating a ``search`` object from your\nexisting ``dict``, modifying it using the api and serializing it back to a\n``dict``:\n\n.. code:: python\n\n    body = {...} # insert complicated query here\n\n    # convert to search object\n    s = search.from_dict(body)\n\n    # add some filters, aggregations, queries, ...\n    s.filter(\"term\", tags=\"python\")\n\n    # convert back to dict to plug back into existing code\n    body = s.to_dict()\n\ndevelopment\n-----------\n\nactivate virtual environment (`virtualenvs <http://docs.python-guide.org/en/latest/dev/virtualenvs/>`_):\n\n.. code:: bash\n\n    $ virtualenv venv\n    $ source venv/bin/activate\n\nto install all of the dependencies necessary for development, run:\n\n.. code:: bash\n\n    $ pip install -e '.[develop]'\n\nto run all of the tests for ``elasticsearch-dsl-py``, run:\n\n.. code:: bash\n\n    $ python setup.py test\n\nalternatively, it is possible to use the ``run_tests.py`` script in\n``test_elasticsearch_dsl``, which wraps `pytest\n<http://doc.pytest.org/en/latest/>`_, to run subsets of the test suite. some\nexamples can be seen below:\n\n.. code:: bash\n\n    # run all of the tests in `test_elasticsearch_dsl/test_analysis.py`\n    $ ./run_tests.py test_analysis.py\n\n    # run only the `test_analyzer_serializes_as_name` test.\n    $ ./run_tests.py test_analysis.py::test_analyzer_serializes_as_name\n\n``pytest`` will skip tests from ``test_elasticsearch_dsl/test_integration``\nunless there is an instance of elasticsearch on which a connection can occur.\nby default, the test connection is attempted at ``localhost:9200``, based on\nthe defaults specified in the ``elasticsearch-py`` `connection\n<https://github.com/elastic/elasticsearch-py/blob/master/elasticsearch\n/connection/base.py#l29>`_ class. **because running the integration\ntests will cause destructive changes to the elasticsearch cluster, only run\nthem when the associated cluster is empty.** as such, if the\nelasticsearch instance at ``localhost:9200`` does not meet these requirements,\nit is possible to specify a different test elasticsearch server through the\n``test_es_server`` environment variable.\n\n.. code:: bash\n\n    $ test_es_server=my-test-server:9201 ./run_tests\n\ndocumentation\n-------------\n\ndocumentation is available at https://elasticsearch-dsl.readthedocs.io.\n\ncontribution guide\n------------------\n\nwant to hack on elasticsearch dsl? awesome! we have `contribution-guide <https://github.com/elastic/elasticsearch-dsl-py/blob/master/contributing.rst>`_.\n\nlicense\n-------\n\ncopyright 2013 elasticsearch\n\nlicensed under the apache license, version 2.0 (the \"license\");\nyou may not use this file except in compliance with the license.\nyou may obtain a copy of the license at\n\n    http://www.apache.org/licenses/license-2.0\n\nunless required by applicable law or agreed to in writing, software\ndistributed under the license is distributed on an \"as is\" basis,\nwithout warranties or conditions of any kind, either express or implied.\nsee the license for the specific language governing permissions and\nlimitations under the license.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "elasticsearch-dsl",
  "package_url": "https://pypi.org/project/elasticsearch-dsl/",
  "project_url": "https://pypi.org/project/elasticsearch-dsl/",
  "project_urls": {
    "Homepage": "https://github.com/elasticsearch/elasticsearch-dsl-py"
  },
  "release_url": "https://pypi.org/project/elasticsearch-dsl/8.11.0/",
  "requires_dist": [
    "python-dateutil",
    "elasticsearch <9.0.0,>=8.0.0",
    "pytest ; extra == 'develop'",
    "pytest-cov ; extra == 'develop'",
    "pytest-mock ; extra == 'develop'",
    "pytz ; extra == 'develop'",
    "coverage ; extra == 'develop'",
    "sphinx >2 ; extra == 'develop'",
    "sphinx-rtd-theme >0.5 ; extra == 'develop'"
  ],
  "requires_python": ">=3.7",
  "summary": "python client for elasticsearch",
  "version": "8.11.0",
  "releases": [],
  "developers": [
    "client-libs@elastic.co",
    "elastic_client_library_maintainers"
  ],
  "kwds": "elasticsearch_dsl test_elasticsearch_dsl elasticsearch apis api",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_elasticsearch_dsl",
  "homepage": "https://github.com/elasticsearch/elasticsearch-dsl-py",
  "release_count": 34,
  "dependency_ids": [
    "pypi_coverage",
    "pypi_elasticsearch",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_mock",
    "pypi_python_dateutil",
    "pypi_pytz",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme"
  ]
}