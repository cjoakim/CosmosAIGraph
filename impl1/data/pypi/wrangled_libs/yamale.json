{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "yamale (ya\u00b7ma\u00b7l\u0113)\n=================\n\n| :warning: ensure that your schema definitions come from internal or trusted sources. yamale does not protect against intentionally malicious schemas. |\n|:------------|\n\n<img src=\"https://github.com/23andme/yamale/blob/master/yamale.png?raw=true\" alt=\"yamale\" width=\"400\"/>\n\na schema and validator for yaml.\n\nwhat's yaml? see the current spec [here](http://www.yaml.org/spec/1.2/spec.html) and an introduction\nto the syntax [here](https://github.com/animosity/craftirc/wiki/complete-idiot's-introduction-to-yaml).\n\n[![build status](https://github.com/23andme/yamale/actions/workflows/run-tests.yml/badge.svg)](https://github.com/23andme/yamale/actions/workflows/run-tests.yml)\n[![pypi](https://img.shields.io/pypi/v/yamale.svg)](https://pypi.python.org/pypi/yamale)\n\nrequirements\n------------\n* python 3.6+\n* pyyaml\n* ruamel.yaml (optional)\n\ninstall\n-------\n### pip\n```bash\n$ pip install yamale\n```\n\nnote: some platforms, e.g., mac os, may ship with only python 2 and may not have pip installed.\ninstallation of python 3 should also install pip. to preserve any system dependencies on default\nsoftware, consider installing python 3 as a local package. please note replacing system-provided\npython may disrupt other software. mac os users may wish to investigate macports, homebrew, or\nbuilding python 3 from source; in all three cases, apple's command line tools (clt) for xcode\nmay be required. see also [developers](#developers), below.\n\n### manual\n1. download yamale from: https://github.com/23andme/yamale/archive/master.zip\n2. unzip somewhere temporary\n3. run `python setup.py install` (may have to prepend `sudo`)\n\nusage\n-----\n### command line\nyamale can be run from the command line to validate one or many yaml files. yamale will search the\ndirectory you supply (current directory is default) for yaml files. each yaml file it finds it will\nlook in the same directory as that file for its schema, if there is no schema yamale will keep\nlooking up the directory tree until it finds one. if yamale can not find a schema it will tell you.\n\nusage:\n\n```bash\nusage: yamale [-h] [-s schema] [-n cpu_num] [-p parser] [--no-strict] [path]\n\nvalidate yaml files.\n\npositional arguments:\n  path                  folder to validate. default is current directory.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s schema, --schema schema\n                        filename of schema. default is schema.yaml.\n  -n cpu_num, --cpu-num cpu_num\n                        number of cpus to use. default is 4.\n  -p parser, --parser parser\n                        yaml library to load files. choices are \"ruamel\" or\n                        \"pyyaml\" (default).\n  --no-strict           disable strict mode, unexpected elements in the data\n                        will be accepted.\n```\n\n### api\nthere are several ways to feed yamale schema and data files. the simplest way is to let yamale take\ncare of reading and parsing your yaml files.\n\nall you need to do is supply the files' path:\n```python\n# import yamale and make a schema object:\nimport yamale\nschema = yamale.make_schema('./schema.yaml')\n\n# create a data object\ndata = yamale.make_data('./data.yaml')\n\n# validate data against the schema. throws a valueerror if data is invalid.\nyamale.validate(schema, data)\n```\n\nyou can pass a string of yaml to `make_schema()` and `make_data()` instead of passing a file path\nby using the `content=` parameter:\n\n```python\ndata = yamale.make_data(content=\"\"\"\nname: bill\nage: 26\nheight: 6.2\nawesome: true\n\"\"\")\n```\n\nif `data` is valid, nothing will happen. however, if `data` is invalid yamale will throw a\n`yamaleerror` with a message containing all the invalid nodes:\n```python\ntry:\n    yamale.validate(schema, data)\n    print('validation success! \ud83d\udc4d')\nexcept valueerror as e:\n    print('validation failed!\\n%s' % str(e))\n    exit(1)\n```\nand an array of `validationresult`.\n```python\ntry:\n    yamale.validate(schema, data)\n    print('validation success! \ud83d\udc4d')\nexcept yamaleerror as e:\n    print('validation failed!\\n')\n    for result in e.results:\n        print(\"error validating data '%s' with '%s'\\n\\t\" % (result.data, result.schema))\n        for error in result.errors:\n            print('\\t%s' % error)\n    exit(1)\n```\n\nyou can also specify an optional `parser` if you'd like to use the `ruamel.yaml` (yaml 1.2 support) instead:\n```python\n# import yamale and make a schema object, make sure ruamel.yaml is installed already.\nimport yamale\nschema = yamale.make_schema('./schema.yaml', parser='ruamel')\n\n# create a data object\ndata = yamale.make_data('./data.yaml', parser='ruamel')\n\n# validate data against the schema same as before.\nyamale.validate(schema, data)\n```\n\n### schema\n\n| :warning: ensure that your schema definitions come from internal or trusted sources. yamale does not protect against intentionally malicious schemas. |\n|:------------|\n\nto use yamale you must make a schema. a schema is a valid yaml file with one or more documents\ninside. each node terminates in a string which contains valid yamale syntax. for example, `str()`\nrepresents a [string validator](#validators).\n\na basic schema:\n```yaml\nname: str()\nage: int(max=200)\nheight: num()\nawesome: bool()\n```\n\nand some yaml that validates:\n```yaml\nname: bill\nage: 26\nheight: 6.2\nawesome: true\n```\n\ntake a look at the [examples](#examples) section for more complex schema ideas.\n\n#### includes\nschema files may contain more than one yaml document (nodes separated by `---`). the first document\nfound will be the base schema. any additional documents will be treated as includes. includes allow\nyou to define a valid structure once and use it several times. they also allow you to do recursion.\n\na schema with an include validator:\n```yaml\nperson1: include('person')\nperson2: include('person')\n---\nperson:\n    name: str()\n    age: int()\n```\n\nsome valid yaml:\n```yaml\nperson1:\n    name: bill\n    age: 70\n\nperson2:\n    name: jill\n    age: 20\n```\n\nevery root node not in the first yaml document will be treated like an include:\n```yaml\nperson: include('friend')\ngroup: include('family')\n---\nfriend:\n    name: str()\nfamily:\n    name: str()\n```\n\nis equivalent to:\n```yaml\nperson: include('friend')\ngroup: include('family')\n---\nfriend:\n    name: str()\n---\nfamily:\n    name: str()\n```\n\n##### recursion\nyou can get recursion using the include validator.\n\nthis schema:\n```yaml\nperson: include('human')\n---\nhuman:\n    name: str()\n    age: int()\n    friend: include('human', required=false)\n```\n\nwill validate this data:\n```yaml\nperson:\n    name: bill\n    age: 50\n    friend:\n        name: jill\n        age: 20\n        friend:\n            name: will\n            age: 10\n```\n\n##### adding external includes\nafter you construct a schema you can add extra, external include definitions by calling\n`schema.add_include(dict)`. this method takes a dictionary and adds each key as another include.\n\n### strict mode\nby default yamale will provide errors for extra elements present in lists and maps that are not\ncovered by the schema. with strict mode disabled (using the `--no-strict` command line option),\nadditional elements will not cause any errors. in the api, strict mode can be toggled by passing\nthe strict=true/false flag to the validate function.\n\nit is possible to mix strict and non-strict mode by setting the strict=true/false flag in the\ninclude validator, setting the option only for the included validators.\n\nvalidators\n----------\nhere are all the validators yamale knows about. every validator takes a `required` keyword telling\nyamale whether or not that node must exist. by default every node is required. example: `str(required=false)`\n\nyou can also require that an optional value is not `none` by using the `none` keyword. by default\nyamale will accept `none` as a valid value for a key that's not required. reject `none` values\nwith `none=false` in any validator. example: `str(required=false, none=false)`.\n\nsome validators take keywords and some take arguments, some take both. for instance the `enum()`\nvalidator takes one or more constants as arguments and the `required` keyword:\n`enum('a string', 1, false, required=false)`\n\n### string - `str(min=int, max=int, equals=string, starts_with=string, ends_with=string, matches=regex, exclude=string, ignore_case=false, multiline=false, dotall=false)`\nvalidates strings.\n- keywords\n    - `min`: len(string) >= min\n    - `max`: len(string) <= max\n    - `equals`: string == value (add `ignore_case=true` for case-insensitive checking)\n    - `starts_with`: accepts only strings starting with given value (add `ignore_case=true` for\n      case-insensitive checking)\n    - `matches`: validates the string against a given regex. similar to the `regex()` validator,\n      you can use `ignore_case`, `multiline` and `dotall`)\n    - `ends_with`: accepts only strings ending with given value (add `ignore_case=true` for case-insensitive checking)\n    - `exclude`: rejects strings that contains any character in the excluded value\n    - `ignore_case`: validates strings in a case-insensitive manner.\n    - `multiline`: `^` and `$` in a pattern match at the beginning and end of each line in a string\n       in addition to matching at the beginning and end of the entire string. (a pattern matches\n       at [the beginning of a string](https://docs.python.org/3/library/re.html#re.match) even in\n       multiline mode; see below for a workaround.); only allowed in conjunction with a `matches` keyword.\n    - `dotall`: `.` in a pattern matches newline characters in a validated string in addition to\n      matching every character that *isn't* a newline.; only allowed in conjunction with a `matches` keyword.\n\nexamples:\n- `str(max=10, exclude='?!')`: allows only strings less than 11 characters that don't contain `?` or `!`.\n\n### regex - `regex([patterns], name=string, ignore_case=false, multiline=false, dotall=false)`\nvalidates strings against one or more regular expressions.\n- arguments: one or more python regular expression patterns\n- keywords:\n    - `name`: a friendly description for the patterns.\n    - `ignore_case`: validates strings in a case-insensitive manner.\n    - `multiline`: `^` and `$` in a pattern match at the beginning and end of each line in a string\n       in addition to matching at the beginning and end of the entire string. (a pattern matches\n       at [the beginning of a string](https://docs.python.org/3/library/re.html#re.match) even in\n       multiline mode; see below for a workaround.)\n    - `dotall`: `.` in a pattern matches newline characters in a validated string in addition to\n      matching every character that *isn't* a newline.\n\nexamples:\n- `regex('^[^?!]{,10}$')`: allows only strings less than 11 characters that don't contain `?` or `!`.\n- `regex(r'^(\\d+)(\\s\\1)+$', name='repeated natural')`: allows only strings that contain two or\n  more identical digit sequences, each separated by a whitespace character. non-matching strings\n  like `sugar` are rejected with a message like `'sugar' is not a repeated natural.`\n- `regex('.*^apples$', multiline=true, dotall=true)`: allows the string `apples` as well\n  as multiline strings that contain the line `apples`.\n\n### integer - `int(min=int, max=int)`\nvalidates integers.\n- keywords\n    - `min`: int >= min\n    - `max`: int <= max\n\n### number - `num(min=float, max=float)`\nvalidates integers and floats.\n- keywords\n    - `min`: num >= min\n    - `max`: num <= max\n\n### boolean - `bool()`\nvalidates booleans.\n\n### null - `null()`\nvalidates null values.\n\n### enum - `enum([primitives])`\nvalidates from a list of constants.\n- arguments: constants to test equality with\n\nexamples:\n- `enum('a string', 1, false)`: a value can be either `'a string'`, `1` or `false`\n\n### day - `day(min=date, max=date)`\nvalidates a date in the form of yyyy-mm-dd.\n- keywords\n    - `min`: date >= min\n    - `max`: date <= max\n\nexamples:\n- `day(min='2001-01-01', max='2100-01-01')`: only allows dates between 2001-01-01 and 2100-01-01.\n\n### timestamp - `timestamp(min=time, max=time)`\nvalidates a timestamp in the form of yyyy-mm-dd hh:mm:ss.\n- keywords\n    - `min`: time >= min\n    - `max`: time <= max\n\nexamples:\n- `timestamp(min='2001-01-01 01:00:00', max='2100-01-01 23:00:00')`: only allows times between\n  2001-01-01 01:00:00 and 2100-01-01 23:00:00.\n\n### list - `list([validators], min=int, max=int)`\nvalidates lists. if one or more validators are passed to `list()` only nodes that pass at\nleast one of those validators will be accepted.\n\n- arguments: one or more validators to test values with\n- keywords\n    - `min`: len(list) >= min\n    - `max`: len(list) <= max\n\nexamples:\n- `list()`: validates any list\n- `list(include('custom'), int(), min=4)`: only validates lists that contain the `custom` include\n  or integers and contains a minimum of 4 items.\n\n### map - `map([validators], key=validator, min=int, max=int)`\nvalidates maps. use when you want a node to contain freeform data. similar to `list`, `map` takes\none or more validators to run against the values of its nodes, and only nodes that pass at least\none of those validators will be accepted. by default, only the values of nodes are validated and\nthe keys aren't checked.\n- arguments: one or more validators to test values with\n- keywords\n    - `key`: a validator for the keys of the map.\n    - `min`: len(map) >= min\n    - `max`: len(map) <= max\n\nexamples:\n- `map()`: validates any map\n- `map(str(), int())`: only validates maps whose values are strings or integers.\n- `map(str(), key=int())`: only validates maps whose keys are integers and values are strings. `1: one` would be valid but `'1': one` would not.\n- `map(str(), min=1)`: only validates a non-empty map.\n\n### ip address - `ip()`\nvalidates ipv4 and ipv6 addresses.\n\n- keywords\n    - `version`: 4 or 6; explicitly force ipv4 or ipv6 validation\n\nexamples:\n- `ip()`: allows any valid ipv4 or ipv6 address\n- `ip(version=4)`: allows any valid ipv4 address\n- `ip(version=6)`: allows any valid ipv6 address\n\n### mac address - `mac()`\nvalidates mac addresses.\n\nexamples:\n- `mac()`: allows any valid mac address\n\n### any - `any([validators])`\nvalidates against a union of types. use when a node **must** contain **one and only one** of several types. it is valid\nif at least one of the listed validators is valid. if no validators are given, accept any value.\n- arguments: validators to test values with (if none is given, allow any value; if one or more are given,\none must be present)\n\nexamples:\n- `any(int(), null())`: validates either an integer **or** a null value.\n- `any(num(), include('vector'))`: validates **either** a number **or** an included 'vector' type.\n- `any(str(min=3, max=3),str(min=5, max=5),str(min=7, max=7))`: validates to a string that is exactly 3, 5, or 7 characters long\n- `any()`: allows any value.\n\n### subset - `subset([validators], allow_empty=false)`\nvalidates against a subset of types. unlike the `any` validator, this validators allows **one or more** of several types.\nas such, it *automatically validates against a list*. it is valid if all values can be validated against at least one\nvalidator.\n- arguments: validators to test with (at least one; if none is given, a `valueerror` exception will be raised)\n- keywords:\n    - `allow_empty`: allow the subset to be empty (and is, therefore, also optional). this overrides the `required`\nflag.\n      \nexamples:\n- `subset(int(), str())`: validators against an integer, a string, or a list of either.\n- `subset(int(), str(), allow_empty=true)`: same as above, but allows the empty set and makes the subset optional.\n\n### include - `include(include_name)`\nvalidates included structures. must supply the name of a valid include.\n- arguments: single name of a defined include, surrounded by quotes.\n\nexamples:\n- `include('person')`\n\n### custom validators\nit is also possible to add your own custom validators. this is an advanced topic, but here is an\nexample of adding a `date` validator and using it in a schema as `date()`\n\n```python\nimport yamale\nimport datetime\nfrom yamale.validators import defaultvalidators, validator\n\nclass date(validator):\n    \"\"\" custom date validator \"\"\"\n    tag = 'date'\n\n    def _is_valid(self, value):\n        return isinstance(value, datetime.date)\n\nvalidators = defaultvalidators.copy()  # this is a dictionary\nvalidators[date.tag] = date\nschema = yamale.make_schema('./schema.yaml', validators=validators)\n# then use `schema` as normal\n```\n\nexamples\n--------\n\n| :warning: ensure that your schema definitions come from internal or trusted sources. yamale does not protect against intentionally malicious schemas. |\n|:------------|\n\n### using keywords\n#### schema:\n```yaml\noptional: str(required=false)\noptional_min: int(min=1, required=false)\nmin: num(min=1.5)\nmax: int(max=100)\n```\n#### valid data:\n```yaml\noptional_min: 10\nmin: 1.6\nmax: 100\n```\n\n### includes and recursion\n#### schema:\n```yaml\ncustomera: include('customer')\ncustomerb: include('customer')\nrecursion: include('recurse')\n---\ncustomer:\n    name: str()\n    age: int()\n    custom: include('custom_type')\n\ncustom_type:\n    integer: int()\n\nrecurse:\n    level: int()\n    again: include('recurse', required=false)\n```\n#### valid data:\n```yaml\ncustomera:\n    name: bob\n    age: 900\n    custom:\n        integer: 1\ncustomerb:\n    name: jill\n    age: 1\n    custom:\n        integer: 3\nrecursion:\n    level: 1\n    again:\n        level: 2\n        again:\n            level: 3\n            again:\n                level: 4\n```\n\n### lists\n#### schema:\n```yaml\nlist_with_two_types: list(str(), include('variant'))\nquestions: list(include('question'))\n---\nvariant:\n  rsid: str()\n  name: str()\n\nquestion:\n  choices: list(include('choices'))\n  questions: list(include('question'), required=false)\n\nchoices:\n  id: str()\n```\n#### valid data:\n```yaml\nlist_with_two_types:\n  - 'some'\n  - rsid: 'rs123'\n    name: 'some snp'\n  - 'thing'\n  - rsid: 'rs312'\n    name: 'another snp'\nquestions:\n  - choices:\n      - id: 'id_str'\n      - id: 'id_str1'\n    questions:\n      - choices:\n        - id: 'id_str'\n        - id: 'id_str1'\n```\n\n### the data is a list of items without a keyword at the top level\n#### schema:\n```yaml\nlist(include('human'), min=2, max=2)\n\n---\nhuman:\n  name: str()\n  age: int(max=200)\n  height: num()\n  awesome: bool()\n```\n#### valid data:\n```yaml\n- name: bill\n  age: 26\n  height: 6.2\n  awesome: true\n\n- name: adrian\n  age: 23\n  height: 6.3\n  awesome: true\n```\n\nwriting tests\n-------------\nto validate yaml files when you run your program's tests use yamale's yamaletestcase\n\nexample:\n\n```python\nclass testyaml(yamaletestcase):\n    base_dir = os.path.dirname(os.path.realpath(__file__))\n    schema = 'schema.yaml'\n    yaml = 'data.yaml'\n    # or yaml = ['data-*.yaml', 'some_data.yaml']\n\n    def runtest(self):\n        self.asserttrue(self.validate())\n```\n\n`base_dir`: string path to prepend to all other paths. this is optional.\n\n`schema`: string of path to the schema file to use. one schema file per test case.\n\n`yaml`: string or list of yaml files to validate. accepts globs.\n\ndevelopers\n----------\n### testing\nyamale uses [tox](https://tox.readthedocs.org/en/latest/) to run its tests against multiple python\nversions. to run tests, first checkout yamale, install tox, then run `make test` in yamale's root\ndirectory. you may also have to install the correct python versions to test with as well.\n\nnote on python versions: `tox.ini` specifies the lowest and highest versions of python supported by\nyamale. unless your development environment is configured to support testing against multiple python\nversions, one or more of the test branches may fail. one method of enabling testing against multiple\nversions of python is to install `pyenv` and `tox-pyenv` and to use `pyenv install` and `pyenv local`\nto ensure that tox is able to locate appropriate pythons.\n\n### releasing\nyamale uses github actions to upload new tags to pypi.\nto release a new version:\n\n1. make a commit with the new version number in `yamale/version`.\n1. run tests for good luck.\n1. run `make release`.\n\ngithub actions will take care of the rest.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "yamale",
  "package_url": "https://pypi.org/project/yamale/",
  "project_url": "https://pypi.org/project/yamale/",
  "project_urls": {
    "Homepage": "https://github.com/23andMe/Yamale"
  },
  "release_url": "https://pypi.org/project/yamale/4.0.4/",
  "requires_dist": [
    "pyyaml"
  ],
  "requires_python": ">=3.6",
  "summary": "a schema and validator for yaml.",
  "version": "4.0.4",
  "releases": [],
  "developers": [
    "blopker@23andme.com",
    "bo_lopker"
  ],
  "kwds": "yaml yamale yml yamaletestcase yamaleerror",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_yamale",
  "homepage": "https://github.com/23andme/yamale",
  "release_count": 43,
  "dependency_ids": [
    "pypi_pyyaml"
  ]
}