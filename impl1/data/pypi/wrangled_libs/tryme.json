{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "======================================================================\ntryme - error handling for humans\n======================================================================\n\n\nintroduction\n============\n\ntryme is a module that makes it easier to treat errors as values. additionally,\ntryme helps you handle the absence of a value (none) in a more composable way.\n\nthe entire tryme library is contained in a single file `tryme.py` to\nmake it as easy as possible to drop into an existing project or script.\n\nwhy should i care?\n--------------------\n  \ntreating errors as values makes it easier to retain information related to errors and\nlets us defer error handling until the last possible moment. in contrast, exceptions are\nfundamentally lossy in they by convention contain tracebacks and error messages not values.\nfurther, exceptions abort execution by default and break normal code flow.\n\nhere are a few tasks where we might wish to defer error handling.\n\n* processing multiple operations in batch where one or more operations may fail\n* executing long running operations that require multiple retries\n\ntreating failed operations as values rather than exceptions can simplify conditional logic and\nmake programs more composable.\n  \n*but c'mon exceptions are pythonic*\n\na common convention for handling errors in python is to raise exceptions. there\nis no reason however that this is always the best mechanism to handle errors,\nespecially *expected errors*. the author of this package feels strongly\nthat exceptions are best used to represent exceptional circumstances\nsuch as when undefined behavior is encountered.\n\n\nerror handling strategies\n------------------------------\n\na good error handling strategy retains relevant information and defers side\neffects related to a failure as long as possible to allow upstream code to\ndecide how to handle the failure.\n\nhere are four error handling strategies that i have encountered:\n\n1. return a boolean to indicate success/failure\n2. return a tuple of (err, value) where err represents a possible error and value\n   is well, a value\n3. return a value for success and raise an exception in the case of an error\n4. return a value in case of success and a custom error class that contains information\n   about the failure but is not necessarily a subclass of `exception`\n5. return an instance of success or failure containing a value\n\n\nstrategy #1 return a boolean\n-------------------------------\n\nthe simplest possible strategy is to return a boolean to indicate the success or\nfailure. for a simple example, let's build a trivial program to check if google is accessible.\n\nour first iteration will simply return a boolean to indicate if google is accessible.\n::\n\n  import requests\n\n\n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      return response.ok\n\n  is_accessible = google_is_accessible()\n  if is_accessible:\n      print('it works!')\n  else:\n      print('google is not accessible. no idea why')\n\nawesome! we now can check if google is accessible from our remote location. the big drawback\nis that `google_is_accessible` doesn't tell me what went wrong in case of a failure nor\ndoes give any information to figure that out for myself.\n\n\nstrategy #2 return a tuple of (err, value)\n---------------------------------------------\n\na similar approach is to return a tuple of (err, value) where err indicates if an error\noccurred. this approach is idiomatic in the go programming language.\n::\n\n  import requests\n\n\n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      return response.ok, response\n\n  is_accessible, response = google_is_accessible()\n  if is_accessible:\n      print('it works!')\n  else:\n      print('google is not accessible, received http status %s' % response.status_code)\n\n\nthis is a big improvement! we now can determine what went wrong should we care.\n\nthe main drawback of returning a tuple to indicate errors is that it makes it harder to\ncompose functions. let's extend our simple example to try multiple search engines in case\ngoogle is not accessible.::\n\n  import requests\n\n\n  def duck_duck_go_is_accessible():\n      response = requests.get('http://google.com')\n      return response.ok, response\n\n  \n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      return response.ok, response\n\n      \n  is_accessible, response = google_is_accessible()\n  if is_accessible:\n      print('it works! using google')\n  else:\n      print('google is not accessible, received http status %s. trying duckduckgo'\n            % response.status_code))\n      is_accessible, response = duck_duck_go_is_accessible()\n      if is_accessible:\n           print('it works! using duckduckgo')\n      else:\n           print('duckduckgo is not accessible, received http status %s. out of options'\n                 % response.status_code))\n\nthe conditionals in the above example can be reduced but it is apparent that returning a tuple\nadds more conditional logic to your code.\n\nstrategy #3 raise an exception\n---------------------------------\n\nhere is our example using good old ``try/except``::\n\n  import requests\n\n\n  class googlenotaccessibleerror(exception):\n      pass\n  \n  \n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      if response.ok:\n          return response.ok\n      else:\n          return googlenotaccessibleerror(\n                \"http request to google.com failed with status code %s\" % response.status_code)\n\n   try:\n       is_accessible = google_is_accessible()\n   except googlenotaccessibleerror as e:\n       is_accessible = false\n       print(e.message)\n\nthere are pros and cons to the above. we do get back some useful information about the failure.\nunfortunately, we do not get back the response object so we cannot dig deeper into the response\nto determine the cause of the error. to get the http status code we have search the error message.\n\nanother drawback is that the raised exception is a side effect that we have to\nhandle immediately and cannot be deferred until later. raising an exception also\ngenerates something we don't need, a stacktrace.\n\none big positive here is that we can subclass exception to indicate the particular problem that\noccurred.\n\nstrategy #4 return a custom error in case of failure\n------------------------------------------------------\n\ninstead of raising an exception, you can simply return an `error` in case of\nfailure where error is an object that is an exception or looks a lot like one.\n::\n\n  import requests\n\n\n  class googlenotaccessibleerror():\n\n      def __init__(self, message, response):\n          self.message = message\n          self.response = response\n  \n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      if response.ok:\n          return response.ok\n      else:\n          return googlenotaccessibleerror(\n                \"http request to google.com failed\", response)\n\n   result = google_is_accessible()\n   if result is true:\n       print('it worked!')\n   else:\n       print(result.message)\n       print('http request failed with status code %d' result.value.status_code)\n\nthis is a big improvement! we can quickly determine if google is accessible and have\naccess to all the information in the request. the main drawback to returning a custom\nerror is that each implementation is likely custom. the calling code has\nto know the internals of the returned error class.\n\n\nstrategy #5 return an instance of success or failure containing a value\n-------------------------------------------------------------------------\n\nthis final strategy refines the custom error with standard semantics. as it turns out there\na standard paradigm in the `either class <https://www.ibm.com/developerworks/library/j-ft13/index.html>`_ that is present in clojure, scala, and other languages. this package\nimplements the either class under the name `try` as your dear author believes it\nis a more intuitive name.\n\nthe `try` class has two subclasses, `success` and `failure`. success is used to\ncontain the result of an operation that-you guessed it-succeeded. likewise, failure\ncontains the result of an operation that failed.\n\nhere is the same task using the ``success`` and ``failure``::\n\n  import requests\n  from tryme import success, failure\n\n\n  def google_is_accessible():\n      response = requests.get('http://google.com')\n      if response.ok:\n          return success(response)\n      else:\n          return failure(response)\n\n   result = google_is_accessible()\n   if result.succeeded():\n       print('it worked!')\n   else:\n       response = result.get_failure()\n       print('http request failed with status %d' % response.status_code)\n\nwe noted earlier that an advantage of returning exceptions is that we can subclass\nexception to more specifically indicate the failure. we can do the same with\nsuccess in failure. one obvious omission from our google_is_accessible is\nthat it does not account for a network failure.::\n\n\n  import requests\n  from tryme import success, failure\n\n\n  class connectionfailure(failure):\n      pass\n      \n  \n  def google_is_accessible():\n      try:\n          response = requests.get('http://google.com')\n      except requests.exceptions.connectionerror as e:\n          return connectionfailure(e.message)\n      if response.ok:\n          return success(response)\n      else:\n          return failure(response)\n\n   result = google_is_accessible()\n   if result.succeeded():\n       print('it worked!')\n   elif isinstance(result, connectionfailure):\n       print(result.get_message())\n   else:\n       response = result.get_failure()\n       print('http request failed with status %d' % response.status_code)\n\n\nnote that while we return a custom failure in this case there are many cases where it\nis quite reasonable to raise an exception. as mentioned earlier, exceptions work well\nfor **unexpected** behavior and not expected behavior.\n\nsuccess and failure have some useful helpers for reporting to the terminal.\n\nthe constructors for both success and failure take the optional argument `message`\nto capture a message intended for the end user. the `to_console` method prints the\nmessage to the terminal if it is not none otherwise prints a a string representation\nof the contained value.\n\n* `success.to_console` prints the message if set otherwise prints a string representation of\n  the contained value to stdout\n* `failure.to_console` prints the message if set otherwise prints a string representation of\n  the contained value to stderr\n* `try.raise_for_error` raise an exception if the instance is a failure\n* `try.fail_for_error` if a failure, print the message and exit with a non-zero return code\n\n  \nretrying with style\n---------------------------------------------------\n\nlet's say we want to create a single server using a new cloud computing provider\nnamed highlyvariable inc. highlyvariable can provision our new server in a few\nseconds, several minutes, or occasionally not at all. your dear author has used\ncloud services where the \"not at all\" is not so uncommon an outcome!\n\nlet's create a `server_ready` function that returns a `success` when the server\nis ready, a `failure` when the operation times out. a \"terminal\" state such as\n\"ready\" or \"failed\" will terminate retries immediately whereas a failed will\ncontinue execution of the `server_ready` function until 300 seconds after the\nfunction was first called.\n\nif our new server is not ready after 300 seconds, `server_ready` will return an\ninstance of `failure`.\n\n::\n\n   from tryme import retry, success, failure\n\n   \n   def create_server(name):\n       return {'name': name}\n\n   status_iterator = iter(['preparing', 'preparing', 'preparing', 'ready'])\n\n   \n   def check_instance_status(name):\n       return next(status_iterator)\n\n     \n   @retry\n   def wait_for_server_ready_or_failed(name):\n       status = check_instance_status(name)\n       if status in ['ready', 'failed']:\n           return success(status)\n       else:\n           return failure(status)\n\n           \n   def server_ready(name):\n       # the decorated function will return two values,\n       # the result of wrapped function is updated with start and end times of the\n       # retry loop and the total count of attempts\n       # note that the wrapped value is not modified\n       result = wait_for_server_ready_or_failed(name)\n\n       # a failure here only indicates a timeout\n       if result.failed():\n           return failure(\"server %s not ready after %d seconds and %d attempts\"\n                          % (name, result.elapsed, result.count))\n\n       # unwrap the value to see what really happened\n       status = result.get()\n       if status == 'ready':\n           return success(\"server %s is ready after %d seconds and %d attempts!\"\n                          % (name, result.elapsed, result.count))\n       else:\n           return failure(\"server %s failed after %d seconds!\"\n                          % (name, result.elapsed))\n\n   result = server_ready('jenkins')\n   assert result.succeeded()\n   print(\"server jenkins is ready after %d seconds and %d attempts!\"\n         % (result.elapsed, result.count))\n   \nthere something a little weird about the above example. why did we return\nsuccess when the status was \"failed\"? this is because the return value of\nfailure in the wrapped function is a signal to the `@retry` decorator to\ncontinue retrying until the timeout is reached. as noted earlier, you\ncan subclass success and failure with names that make more sense for your context.\ntryme in fact comes with two subclasses py:class:`stop` and py:class:`again`. let's\nrefactor the previous example to use them.::\n\n   from tryme import retry, success, failure, stop, again\n\n   def create_server(name):\n       return {'name': name}\n\n   status_iterator = iter(['preparing', 'preparing', 'preparing', 'ready'])\n\n   def check_instance_status(name):\n       return next(status_iterator)\n\n   @retry\n   def wait_for_server_ready_or_failed(name):\n       status = check_instance_status(name)\n       if status in ['ready', 'failed']:\n           return stop(status)\n       else:\n           return again(status)\n\n   def server_ready(name):\n       # the decorated function will return two values,\n       # the result of wrapped function is updated with start and end times of the\n       # retry loop and the total count of attempts\n       # note that the wrapped value is not modified\n       result = wait_for_server_ready_or_failed(name)\n\n       # a failure here only indicates a timeout\n       if result.failed():\n           return failure(\"server %s not ready after %d seconds and %d attempts\"\n                          % (name, result.elapsed, result.count))\n\n       # unwrap the value to see what really happened\n       status = result.get()\n       if status == 'ready':\n           return success(\"server %s is ready after %d seconds and %d attempts!\"\n                          % (name, result.elapsed, result.count))\n       else:\n           return failure(\"server %s failed after %d seconds!\"\n                          % (name, result.elapsed))\n\n   result = server_ready('jenkins')\n   assert result.succeeded()\n   print(\"server jenkins is ready after %d seconds and %d attempts!\"\n         % (result.elapsed, result.count))\n       \nutility methods\n--------------------\n       \nthe utility method ``try_out`` executes a callable and wraps a raised exception\nin a failure class. if an exception was not raised, a success is returned\n\n::\n\n  >>> from tryme import try_out\n  >>> result = try_out(lambda: 1 / 0)\n  >>> print(result)  # doctest: +skip\n  failure(zerodivisionerror('integer division or modulo by zero',))\n  >>> exc = result.get_failure()\n  >>> exc # doctest: +skip\n  zerodivisionerror('integer division or modulo by zero',)\n  >>> # the following would fail as it does not catch the correct exception, zerodivisionerror\n  >>> # result = try_out(lambda: 1 / 0, exception=valueerror)\n  >>> result = try_out(lambda: 1 / 1)\n  >>> print(result) # doctest: +skip\n  success(1)\n  >>> result.get() # doctest: +skip\n  1\n\n\n\n\nrequirements\n============\n\n- cpython >= 2.7\n\n\nbackground\n============\n\nthis package is inspired by philip xu's excellent `monad package <https://github.com/pyx/monad>`_.\nit also takes some inspiration from the excellent `vavr <https://vavr.io>`_ library for java and the scala language.\nsee this excellent `tutorial <http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html>`_\non the try utility in scala.\n\npssssh! this package uses *gasp* monads as the core abstraction. *don't tell\nanyone!* they will sick the procedural programming police on your dear author. while this\npackage does have a monad class, it does not provide general purpose\nimplementations of monad, applicative, and functor. further it does not\nattempt to overload common python operators to support function composition. this is\nbecause your dear author is of the opinion that python's syntax is too limited\nto support monadic composition.\n\n\ninstallation\n============\n\ninstall from pypi::\n\n  pip install tryme\n\ninstall from source, download source package, decompress, then ``cd`` into source directory, run::\n\n  make install\n\n\nlicense\n=======\n\nbsd new, see license for details.\n\n\nlinks\n=====\n\ndocumentation:\n  http://tryme.readthedocs.org/\n\nissue tracker:\n  https://github.com/bryanwb/tryme/issues/\n\nsource package @ pypi:\n  https://pypi.python.org/bryanwb/tryme\n\ngit repository @ github:\n  https://github.com/bryanwb/tryme/",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-new",
  "name": "tryme",
  "package_url": "https://pypi.org/project/tryme/",
  "project_url": "https://pypi.org/project/tryme/",
  "project_urls": {
    "Download": "https://github.com/bryanwb/tryme/archive/0.0.5.zip",
    "Homepage": "https://github.com/bryanwb/tryme/"
  },
  "release_url": "https://pypi.org/project/tryme/0.0.5/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "tryme - error handling for humans",
  "version": "0.0.5",
  "releases": [],
  "developers": [
    "bryan.berry@gmail.com",
    "bryan_w"
  ],
  "kwds": "fail_for_error get_failure tryme python raise_for_error",
  "license_kwds": "bsd-new",
  "libtype": "pypi",
  "id": "pypi_tryme",
  "homepage": "https://github.com/bryanwb/tryme/",
  "release_count": 5,
  "dependency_ids": []
}