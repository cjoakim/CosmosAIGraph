{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: european union public licence 1.1 (eupl 1.1)",
    "natural language :: english",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: os independent",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: information analysis",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "\nabout schedula\n**************\n\n**schedula** is a dynamic flow-based programming environment for\npython, that handles automatically the control flow of the program.\nthe control flow generally is represented by a directed acyclic graph\n(dag), where nodes are the operations/functions to be executed and\nedges are the dependencies between them.\n\nthe algorithm of **schedula** dates back to 2014, when a colleague\nasked for a method to automatically populate the missing data of a\ndatabase. the imputation method chosen to complete the database was a\nsystem of interdependent physical formulas - i.e., the inputs of a\nformula are the outputs of other formulas. the current library has\nbeen developed in 2015 to support the design of the co:sub:`2`mpas\n`tool <https://github.com/jrcstu/co2mpas-ta>`_ - a co:sub:`2` vehicle\n`simulator\n<https://jrcstu.github.io/co2mpas/model/?url=https://jrcstu.github.io/co2mpas/model/core/co2mpas_model/calibrate_with_wltp_h.html>`_.\nduring the developing phase, the physical formulas (more than 700)\nwere known on the contrary of the software inputs and outputs.\n\n\nwhy schedula?\n=============\n\nthe design of flow-based programs begins with the definition of the\ncontrol flow graph, and implicitly of its inputs and outputs. if the\nprogram accepts multiple combinations of inputs and outputs, you have\nto design and code all control flow graphs. with normal schedulers, it\ncan be very demanding.\n\nwhile with **schedula**, giving whatever set of inputs, it\nautomatically calculates any of the desired computable outputs,\nchoosing the most appropriate dag from the dataflow execution model.\n\nnote: the dag is determined at runtime and it is extracted using the\n   shortest path from the provided inputs. the path is calculated\n   based on a weighted directed graph (dataflow execution model) with\n   a modified dijkstra algorithm.\n\n**schedula** makes the code easy to debug, to optimize, and to present\nit to a non-it audience through its interactive graphs and charts. it\nprovides the option to run a model asynchronously or in parallel\nmanaging automatically the global interpreter lock (gil), and to\nconvert a model into a web api service.\n\n.. _start-install-core:\n\n\ninstallation\n************\n\nto install it use (with root privileges):\n\n.. code:: console\n\n   $ pip install schedula\n\nor download the last git version and use (with root privileges):\n\n.. code:: console\n\n   $ python setup.py install\n\n.. _end-install-core:\n\n\ninstall extras\n==============\n\nsome additional functionality is enabled installing the following\nextras:\n\n*  ``io``: enables to read/write functions.\n\n*  ``plot``: enables the plot of the dispatcher model and workflow\n   (see ``plot()``).\n\n*  ``web``: enables to build a dispatcher flask app (see ``web()``).\n\n*  ``sphinx``: enables the sphinx extension directives (i.e.,\n   autosummary and dispatcher).\n\n*  ``parallel``: enables the parallel execution of dispatcher model.\n\nto install **schedula** and all extras, do:\n\n.. code:: console\n\n   $ pip install 'schedula[all]'\n\nnote: ``plot`` extra requires **graphviz**. make sure that the directory\n   containing the ``dot`` executable is on your systems\u2019 path. if you\n   have not you can install it from its `download page\n   <https://www.graphviz.org/download/>`_.\n\n\ntutorial\n********\n\nlet\u2019s assume that we want develop a tool to automatically manage the\nsymmetric cryptography. the base idea is to open a file, read its\ncontent, encrypt or decrypt the data and then write them out to a new\nfile. this tutorial shows how to:\n\n   1. `define <#model-definition>`_ and `execute <#dispatching>`_ a\n      dataflow execution model,\n\n   2. `extract <#sub-model-extraction>`_ a sub-model, and\n\n   3. `deploy <#api-server>`_ a web api service.\n\nnote: you can find more examples, on how to use the **schedula** library,\n   into the folder `examples\n   <https://github.com/vinci1it2000/schedula/tree/master/examples>`_.\n\n\nmodel definition\n================\n\nfirst of all we start defining an empty ``dispatcher`` named\n*symmetric_cryptography* that defines the dataflow execution model:\n\n::\n\n   >>> import schedula as sh\n   >>> dsp = sh.dispatcher(name='symmetric_cryptography')\n\nthere are two main ways to get a key, we can either generate a new one\nor use one that has previously been generated. hence, we can define\nthree functions to simply generate, save, and load the key. to\nautomatically populate the model inheriting the arguments names, we\ncan use the decorator ``add_function()`` as follow:\n\n::\n\n   >>> import os.path as osp\n   >>> from cryptography.fernet import fernet\n   >>> @sh.add_function(dsp, outputs=['key'], weight=2)\n   ... def generate_key():\n   ...     return fernet.generate_key().decode()\n   >>> @sh.add_function(dsp)\n   ... def write_key(key_fpath, key):\n   ...     with open(key_fpath, 'w') as f:\n   ...         f.write(key)\n   >>> @sh.add_function(dsp, outputs=['key'], input_domain=osp.isfile)\n   ... def read_key(key_fpath):\n   ...     with open(key_fpath) as f:\n   ...         return f.read()\n\nnote: since python does not come with anything that can encrypt/decrypt\n   files, in this tutorial, we use a third party module named\n   ``cryptography``. to install it execute ``pip install\n   cryptography``.\n\nto encrypt/decrypt a message, you will need a key as previously\ndefined and your data *encrypted* or *decrypted*. therefore, we can\ndefine two functions and add them, as before, to the model:\n\n::\n\n   >>> @sh.add_function(dsp, outputs=['encrypted'])\n   ... def encrypt_message(key, decrypted):\n   ...     return fernet(key.encode()).encrypt(decrypted.encode()).decode()\n   >>> @sh.add_function(dsp, outputs=['decrypted'])\n   ... def decrypt_message(key, encrypted):\n   ...     return fernet(key.encode()).decrypt(encrypted.encode()).decode()\n\nfinally, to read and write the encrypted or decrypted message,\naccording to the functional programming philosophy, we can reuse the\npreviously defined functions ``read_key`` and ``write_key`` changing\nthe model mapping (i.e., *function_id*, *inputs*, and *outputs*). to\nadd to the model, we can simply use the ``add_function`` method as\nfollow:\n\n::\n\n   >>> dsp.add_function(\n   ...     function_id='read_decrypted',\n   ...     function=read_key,\n   ...     inputs=['decrypted_fpath'],\n   ...     outputs=['decrypted']\n   ... )\n   'read_decrypted'\n   >>> dsp.add_function(\n   ...     'read_encrypted', read_key, ['encrypted_fpath'], ['encrypted'],\n   ...     input_domain=osp.isfile\n   ... )\n   'read_encrypted'\n   >>> dsp.add_function(\n   ...     'write_decrypted', write_key, ['decrypted_fpath', 'decrypted'],\n   ...     input_domain=osp.isfile\n   ... )\n   'write_decrypted'\n   >>> dsp.add_function(\n   ...     'write_encrypted', write_key, ['encrypted_fpath', 'encrypted']\n   ... )\n   'write_encrypted'\n\nnote: for more details on how to create a ``dispatcher`` see:\n   ``add_data()``, ``add_func()``, ``add_function()``,\n   ``add_dispatcher()``, ``subdispatch``, ``mapdispatch``,\n   ``subdispatchfunction``, ``subdispatchpipe``, and ``dispatchpipe``.\n\nto inspect and visualize the dataflow execution model, you can simply\nplot the graph as follow:\n\n::\n\n   >>> dsp.plot()  \n\n[graph]\n\ntip: you can explore the diagram by clicking on it.\n\n\ndispatching\n===========\n\nto see the dataflow execution model in action and its workflow to\ngenerate a key, to encrypt a message, and to write the encrypt data,\nyou can simply invoke ``dispatch()`` or ``__call__()`` methods of the\n``dsp``:\n\n>>> import tempfile\n>>> tempdir = tempfile.mkdtemp()\n>>> message = \"secret message\"\n>>> sol = dsp(inputs=dict(\n...     decrypted=message,\n...     encrypted_fpath=osp.join(tempdir, 'data.secret'),\n...     key_fpath=osp.join(tempdir,'key.key')\n... ))\n>>> sol.plot(index=true)  \n\n[graph]\n\nnote: as you can see from the workflow graph (orange nodes), when some\n   function\u2019s inputs does not respect its domain, the dispatcher\n   automatically finds an alternative path to estimate all computable\n   outputs. the same logic applies when there is a function failure.\n\nnow to decrypt the data and verify the message without saving the\ndecrypted message, you just need to execute again the ``dsp`` changing\nthe *inputs* and setting the desired *outputs*. in this way, the\ndispatcher automatically selects and executes only a sub-part of the\ndataflow execution model.\n\n>>> dsp(\n...     inputs=sh.selector(('encrypted_fpath', 'key_fpath'), sol),\n...     outputs=['decrypted']\n... )['decrypted'] == message\ntrue\n\nif you want to visualize the latest workflow of the dispatcher, you\ncan use the ``plot()`` method with the keyword ``workflow=true``:\n\n>>> dsp.plot(workflow=true, index=true)  \n\n[graph]\n",
  "docs_url": null,
  "keywords": "flow-based programming,dataflow,parallel,asynchronous,async,scheduling,dispatch,functional programming,dataflow programming",
  "license": "eupl 1.1+",
  "name": "schedula",
  "package_url": "https://pypi.org/project/schedula/",
  "project_url": "https://pypi.org/project/schedula/",
  "project_urls": {
    "Documentation": "https://schedula.readthedocs.io",
    "Download": "https://github.com/vinci1it2000/schedula/tarball/v1.5.2",
    "Homepage": "https://github.com/vinci1it2000/schedula",
    "Issue tracker": "https://github.com/vinci1it2000/schedula/issues"
  },
  "release_url": "https://pypi.org/project/schedula/1.5.2/",
  "requires_dist": [
    "docutils ; extra == 'form'",
    "Pygments ; extra == 'all'",
    "dill !=0.2.7 ; extra == 'all'",
    "docutils ; extra == 'all'",
    "flask ; extra == 'all'",
    "flask-babel ; extra == 'all'",
    "flask-mail ; extra == 'all'",
    "flask-principal ; extra == 'all'",
    "flask-security-too ; extra == 'all'",
    "flask-sqlalchemy ; extra == 'all'",
    "flask-wtf ; extra == 'all'",
    "graphviz >=0.17 ; extra == 'all'",
    "itsdangerous ; extra == 'all'",
    "jinja2 ; extra == 'all'",
    "multiprocess ; extra == 'all'",
    "regex ; extra == 'all'",
    "requests ; extra == 'all'",
    "rst2txt ; extra == 'all'",
    "sphinx >=7.2 ; extra == 'all'",
    "sqlalchemy ; extra == 'all'",
    "Pygments ; extra == 'dev'",
    "dill !=0.2.7 ; extra == 'dev'",
    "docutils ; extra == 'dev'",
    "flask ; extra == 'dev'",
    "flask-babel ; extra == 'dev'",
    "flask-mail ; extra == 'dev'",
    "flask-principal ; extra == 'dev'",
    "flask-security-too ; extra == 'dev'",
    "flask-sqlalchemy ; extra == 'dev'",
    "flask-wtf ; extra == 'dev'",
    "graphviz >=0.17 ; extra == 'dev'",
    "itsdangerous ; extra == 'dev'",
    "jinja2 ; extra == 'dev'",
    "multiprocess ; extra == 'dev'",
    "regex ; extra == 'dev'",
    "requests ; extra == 'dev'",
    "rst2txt ; extra == 'dev'",
    "sphinx >=7.2 ; extra == 'dev'",
    "sqlalchemy ; extra == 'dev'",
    "wheel ; extra == 'dev'",
    "gitchangelog ; extra == 'dev'",
    "mako ; extra == 'dev'",
    "sphinx-rtd-theme ; extra == 'dev'",
    "setuptools >=36.0.1 ; extra == 'dev'",
    "sphinxcontrib-restbuilder ; extra == 'dev'",
    "coveralls ; extra == 'dev'",
    "polib ; extra == 'dev'",
    "readthedocs-sphinx-ext ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "ddt ; extra == 'dev'",
    "translators ; extra == 'dev'",
    "requests ; extra == 'form'",
    "regex ; extra == 'form'",
    "flask ; extra == 'form'",
    "itsdangerous ; extra == 'form'",
    "rst2txt ; extra == 'form'",
    "flask-sqlalchemy ; extra == 'form'",
    "sqlalchemy ; extra == 'form'",
    "flask-babel ; extra == 'form'",
    "flask-wtf ; extra == 'form'",
    "flask-principal ; extra == 'form'",
    "flask-security-too ; extra == 'form'",
    "flask-mail ; extra == 'form'",
    "dill !=0.2.7 ; extra == 'io'",
    "multiprocess ; extra == 'parallel'",
    "requests ; extra == 'plot'",
    "graphviz >=0.17 ; extra == 'plot'",
    "regex ; extra == 'plot'",
    "flask ; extra == 'plot'",
    "Pygments ; extra == 'plot'",
    "jinja2 ; extra == 'plot'",
    "docutils ; extra == 'plot'",
    "sphinx >=7.2 ; extra == 'sphinx'",
    "requests ; extra == 'sphinx'",
    "graphviz >=0.17 ; extra == 'sphinx'",
    "regex ; extra == 'sphinx'",
    "flask ; extra == 'sphinx'",
    "Pygments ; extra == 'sphinx'",
    "jinja2 ; extra == 'sphinx'",
    "docutils ; extra == 'sphinx'",
    "requests ; extra == 'web'",
    "regex ; extra == 'web'",
    "flask ; extra == 'web'"
  ],
  "requires_python": "",
  "summary": "produce a plan that dispatches calls based on a graph of functions, satisfying data dependencies.",
  "version": "1.5.2",
  "releases": [],
  "developers": [
    "vincenzo_arcidiacono",
    "vinci1it2000@gmail.com"
  ],
  "kwds": "dataflow imputation schedula scheduling programming",
  "license_kwds": "eupl 1.1+",
  "libtype": "pypi",
  "id": "pypi_schedula",
  "homepage": "https://github.com/vinci1it2000/schedula",
  "release_count": 78,
  "dependency_ids": [
    "pypi_coveralls",
    "pypi_ddt",
    "pypi_dill",
    "pypi_docutils",
    "pypi_flask",
    "pypi_flask_babel",
    "pypi_flask_mail",
    "pypi_flask_principal",
    "pypi_flask_security_too",
    "pypi_flask_sqlalchemy",
    "pypi_flask_wtf",
    "pypi_gitchangelog",
    "pypi_graphviz",
    "pypi_itsdangerous",
    "pypi_jinja2",
    "pypi_mako",
    "pypi_multiprocess",
    "pypi_polib",
    "pypi_pygments",
    "pypi_readthedocs_sphinx_ext",
    "pypi_regex",
    "pypi_requests",
    "pypi_rst2txt",
    "pypi_setuptools",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme",
    "pypi_sphinxcontrib_restbuilder",
    "pypi_sqlalchemy",
    "pypi_translators",
    "pypi_twine",
    "pypi_wheel"
  ]
}