{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules",
    "topic :: system :: systems administration :: authentication/directory"
  ],
  "description": "# pykerberos package\n\nthis python package is a high-level wrapper for kerberos (gssapi)\noperations.  the goal is to avoid having to build a module that wraps\nthe entire kerberos.framework, and instead offer a limited set of\nfunctions that do what is needed for client/server kerberos\nauthentication based on <http://www.ietf.org/rfc/rfc4559.txt>.\n\nmuch of the c-code here is adapted from apache's mod_auth_kerb-5.0rc7.\n\n\n## build\n\nin this directory, run:\n\n```\npython setup.py build\n```\n\n## testing\n\nto run the tests in the tests folder, you must have a valid kerberos setup on\nthe test machine. you can use the script .travis.sh as quick and easy way to\nsetup a kerberos kdc and apache web endpoint that can be used for the tests.\notherwise you can also run the following to run a self contained docker\ncontainer\n\n```\ndocker run \\\n-v $(pwd):/app \\\n-w /app \\\n-e pyenv=2.7.13 \\\n-e kerberos_username=administrator \\\n-e kerberos_password=password01 \\\n-e kerberos_realm=example.com \\\n-e kerberos_port=80 \\\nubuntu:16.04 \\\n/bin/bash .travis.sh\n```\n\nthe docker command needs to be run in the same directory as this library and\nyou can test it with different python versions by changing the value of the\npyenv environment value set in the command.\n\nplease have a look at testing_notes.md for more information.\n\n\n## important\n\nthe checkpassword method provided by this library is meant only for testing purposes as it does\nnot offer any protection against possible kdc spoofing. that method should not be used in any\nproduction code.\n\n\n## channel bindings\n\nyou can use this library to authenticate with channel binding support. channel\nbindings are tags that identify the particular data channel being used with the\nauthentication. you can use channel bindings to offer more proof of a valid\nidentity. some services like microsoft's extended protection can enforce\nchannel binding support on authorisation and you can use this library to meet\nthose requirements.\n\nmore details on channel bindings as set through the gssapi can be found here\n<https://docs.oracle.com/cd/e19455-01/806-3814/overview-52/index.html>. using\ntls as a example this is how you would add channel binding support to your\nauthentication mechanism. the following code snippet is based on rfc5929\n<https://tools.ietf.org/html/rfc5929> using the 'tls-server-endpoint-point'\ntype.\n\n```\nimport hashlib\n\ndef get_channel_bindings_application_data(socket):\n    # this is a highly simplified example, there are other use cases\n    # where you might need to use different hash types or get a socket\n    # object somehow.\n    server_certificate = socket.getpeercert(true)\n    certificate_hash = hashlib.sha256(server_certificate).hexdigest().upper()\n    certificate_digest = base64.b16decode(certificate_hash)\n    application_data = b'tls-server-end-point:%s' % certificate_digest\n\n    return application_data\n\ndef main():\n    # code to setup a socket with the server\n    # a lot of code to setup the handshake and start the auth process\n    socket = getsocketsomehow()\n\n    # connect to the host and start the auth process\n\n    # build the channel bindings object\n    application_data = get_channel_bindings_application_data(socket)\n    channel_bindings = kerberos.channelbindings(application_data=application_data)\n\n    # more work to get responses from the server\n\n    result, context = kerberos.authgssclientinit(kerb_spn, gssflags=gssflags, principal=principal)\n\n    # pass through the channel_bindings object as created in the kerberos.channelbindings method\n    result = kerberos.authgssclientstep(context, neg_resp_value, channel_bindings=channel_bindings)\n\n    # repeat as necessary\n```\n\n## python apis\n\nsee kerberos.py.\n\n\n## copyright and license\n\ncopyright (c) 2006-2021 apple inc.  all rights reserved.\n\nthis software is licensed under the apache license, version 2.0.  the\napache license is a well-established open source license, enabling\ncollaborative open source software development.\n\nsee the \"license\" file for the full text of the license terms.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license, version 2.0",
  "name": "kerberos",
  "package_url": "https://pypi.org/project/kerberos/",
  "project_url": "https://pypi.org/project/kerberos/",
  "project_urls": {
    "Homepage": "https://github.com/apple/ccs-pykerberos"
  },
  "release_url": "https://pypi.org/project/kerberos/1.3.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "kerberos high-level interface",
  "version": "1.3.1",
  "releases": [],
  "developers": [
    "apple_inc",
    "calendarserver-dev@lists.macosforge.org"
  ],
  "kwds": "kerberos_port kerberos_password kerberos_realm kerberos_username mod_auth_kerb",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_kerberos",
  "homepage": "https://github.com/apple/ccs-pykerberos",
  "release_count": 9,
  "dependency_ids": []
}