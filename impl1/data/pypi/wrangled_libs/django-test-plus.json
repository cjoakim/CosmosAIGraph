{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 2.2",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "framework :: django :: 4.1",
    "framework :: django :: 4.2",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# django-test-plus\n\nuseful additions to django's default testcase from [revsys](https://www.revsys.com/)\n\n[![pypi](https://img.shields.io/pypi/v/django-test-plus.svg)](https://pypi.org/project/django-test-plus/)\n[![build matrix demo](https://github.com/revsys/django-test-plus/actions/workflows/actions.yml/badge.svg)](https://github.com/revsys/django-test-plus/actions/workflows/actions.yml)\n\n## rationale\n\nlet's face it, writing tests isn't always fun. part of the reason for\nthat is all of the boilerplate you end up writing. django-test-plus is\nan attempt to cut down on some of that when writing django tests. we\nguarantee it will increase the time before you get carpal tunnel by at\nleast 3 weeks!\n\nif you would like to get started testing your django apps or improve how your\nteam is testing we offer [teststart](https://www.revsys.com/teststart/)\nto help your team dramatically improve your productivity.\n\n## support\n\nsupports: python 3.6, 3.7, 3.8, 3.9, 3.10, and 3.11.\n\nsupports django versions: 2.0, 2.1, 2.2, 3.0, 3.1, 3.2, 4.0, 4.1, and 4.2.\n\n## documentation\n\nfull documentation is available at http://django-test-plus.readthedocs.org\n\n## installation\n\n```shell\n$ pip install django-test-plus\n```\n\n## usage\n\nto use django-test-plus, have your tests inherit from test_plus.test.testcase rather than the normal django.test.testcase::\n\n```python\nfrom test_plus.test import testcase\n\nclass myviewtests(testcase):\n    ...\n```\n\nthis is sufficient to get things rolling, but you are encouraged to\ncreate *your own* sub-classes for your projects. this will allow you\nto add your own project-specific helper methods.\n\nfor example, if you have a django project named 'myproject', you might\ncreate the following in `myproject/test.py`:\n\n```python\nfrom test_plus.test import testcase as plustestcase\n\nclass testcase(plustestcase):\n    pass\n```\n\nand then in your tests use:\n\n```python\nfrom myproject.test import testcase\n\nclass myviewtests(testcase):\n    ...\n```\n\nthis import, which is similar to the way you would import django's testcase,\nis also valid:\n\n```python\nfrom test_plus import testcase\n```\n\n## pytest usage\n\nyou can get a testcase like object as a pytest fixture now by asking for `tp`. all of the methods below would then work in pytest functions. for\nexample:\n\n```python\ndef test_url_reverse(tp):\n    expected_url = '/api/'\n    reversed_url = tp.reverse('api')\n    assert expected_url == reversed_url\n```\n\nthe `tp_api` fixture will provide a `testcase` that uses django-rest-framework's `apiclient()`:\n\n```python\ndef test_url_reverse(tp_api):\n    response = tp_api.client.post(\"myapi\", format=\"json\")\n    assert response.status_code == 200\n```\n\n## methods\n\n### `reverse(url_name, *args, **kwargs)`\n\nwhen testing views you often find yourself needing to reverse the url's name. with django-test-plus there is no need for the `from django.core.urlresolvers import reverse` boilerplate. instead, use:\n\n```python\ndef test_something(self):\n    url = self.reverse('my-url-name')\n    slug_url = self.reverse('name-takes-a-slug', slug='my-slug')\n    pk_url = self.reverse('name-takes-a-pk', pk=12)\n```\n\nas you can see our reverse also passes along any args or kwargs you need\nto pass in.\n\n## `get(url_name, follow=true, *args, **kwargs)`\n\nanother thing you do often is http get urls. our `get()` method\nassumes you are passing in a named url with any args or kwargs necessary\nto reverse the url_name.\nif needed, place kwargs for `testclient.get()` in an 'extra' dictionary.:\n\n```python\ndef test_get_named_url(self):\n    response = self.get('my-url-name')\n    # get xml data via ajax request\n    xml_response = self.get(\n        'my-url-name',\n        extra={'http_x_requested_with': 'xmlhttprequest'})\n```\n\nwhen using this get method two other things happen for you: we store the\nlast response in `self.last_response` and the response's context in `self.context`.\n\nso instead of:\n\n```python\ndef test_default_django(self):\n    response = self.client.get(reverse('my-url-name'))\n    self.asserttrue('foo' in response.context)\n    self.assertequal(response.context['foo'], 12)\n```\n\nyou can write:\n\n```python\ndef test_testplus_get(self):\n    self.get('my-url-name')\n    self.assertincontext('foo')\n    self.assertequal(self.context['foo'], 12)\n```\n\nit's also smart about already reversed urls, so you can be lazy and do:\n\n```python\ndef test_testplus_get(self):\n    url = self.reverse('my-url-name')\n    self.get(url)\n    self.response_200()\n```\n\nif you need to pass query string parameters to your url name, you can do so like this. assuming the name 'search' maps to '/search/' then:\n\n```python\ndef test_testplus_get_query(self):\n    self.get('search', data={'query': 'testing'})\n```\n\nwould get `/search/?query=testing`.\n\n## `post(url_name, data, follow=true, *args, **kwargs)`\n\nour `post()` method takes a named url, an optional dictionary of data you wish\nto post and any args or kwargs necessary to reverse the url_name.\nif needed, place kwargs for `testclient.post()` in an 'extra' dictionary.:\n\n```python\ndef test_post_named_url(self):\n    response = self.post('my-url-name', data={'coolness-factor': 11.0},\n                         extra={'http_x_requested_with': 'xmlhttprequest'})\n```\n\n*note* along with the frequently used get and post, we support all of the http verbs such as put, patch, head, trace, options, and delete in the same fashion.\n\n## `get_context(key)`\n\noften you need to get things out of the template context:\n\n```python\ndef test_context_data(self):\n    self.get('my-view-with-some-context')\n    slug = self.get_context('slug')\n```\n\n## `assertincontext(key)`\n\nyou can ensure a specific key exists in the last response's context by\nusing:\n\n```python\ndef test_in_context(self):\n    self.get('my-view-with-some-context')\n    self.assertincontext('some-key')\n```\n\n## `assertcontext(key, value)`\n\nwe can get context values and ensure they exist, but we can also test\nequality while we're at it. this asserts that key == value:\n\n```python\ndef test_in_context(self):\n    self.get('my-view-with-some-context')\n    self.assertcontext('some-key', 'expected value')\n```\n\n## `assert_http_###_<status_name>(response, msg=none)` - status code checking\n\nanother test you often need to do is check that a response has a certain\nhttp status code. with django's default testcase you would write:\n\n```python\nfrom django.core.urlresolvers import reverse\n\ndef test_status(self):\n    response = self.client.get(reverse('my-url-name'))\n    self.assertequal(response.status_code, 200)\n```\n\nwith django-test-plus you can shorten that to be:\n\n```python\ndef test_better_status(self):\n    response = self.get('my-url-name')\n    self.assert_http_200_ok(response)\n```\n\ndjango-test-plus provides a majority of the status codes assertions for you. the status assertions\ncan be found in their own [mixin](https://github.com/revsys/django-test-plus/blob/main/test_plus/status_codes.py)\nand should be searchable if you're using an ide like pycharm. it should be noted that in previous\nversions, django-test-plus had assertion methods in the pattern of `response_###()`, which are still\navailable but have since been deprecated. see below for a list of those methods.\n\neach of the assertion methods takes an optional django test client `response` and a string `msg` argument\nthat, if specified, is used as the error message when a failure occurs. the methods,\n`assert_http_301_moved_permanently` and `assert_http_302_found` also take an optional `url` argument that\nif passed, will check to make sure the `response.url` matches.\n\nif it's available, the `assert_http_###_<status_name>` methods will use the last response. so you\ncan do:\n\n```python\ndef test_status(self):\n    self.get('my-url-name')\n    self.assert_http_200_ok()\n```\n\nwhich is a bit shorter.\n\nthe `response_###()` methods that are deprecated, but still available for use, include:\n\n- `response_200()`\n- `response_201()`\n- `response_204()`\n- `response_301()`\n- `response_302()`\n- `response_400()`\n- `response_401()`\n- `response_403()`\n- `response_404()`\n- `response_405()`\n- `response_409()`\n- `response_410()`\n\nall of which take an optional django test client response and a str msg argument that, if specified, is used as the error message when a failure occurs. just like the `assert_http_###_<status_name>()` methods, these methods will use the last response if it's available.\n\n## `get_check_200(url_name, *args, **kwargs)`\n\ngeting and checking views return status 200 is a common test. this method makes it more convenient::\n\n```python\ndef test_even_better_status(self):\n    response = self.get_check_200('my-url-name')\n```\n\n## make_user(username='testuser', password='password', perms=none)\n\nwhen testing out views you often need to create various users to ensure\nall of your logic is safe and sound. to make this process easier, this\nmethod will create a user for you:\n\n```python\ndef test_user_stuff(self)\n    user1 = self.make_user('u1')\n    user2 = self.make_user('u2')\n```\n\nif creating a user in your project is more complicated, say for example\nyou removed the `username` field from the default django auth model,\nyou can provide a [factory\nboy](https://factoryboy.readthedocs.org/en/latest/) factory to create\nit or override this method on your own sub-class.\n\nto use a factory boy factory, create your class like this::\n\n```python\nfrom test_plus.test import testcase\nfrom .factories import userfactory\n\n\nclass myspecialtest(testcase):\n    user_factory = userfactory\n\n    def test_special_creation(self):\n        user1 = self.make_user('u1')\n```\n\n**note:** users created by this method will have their password\nset to the string 'password' by default, in order to ease testing.\nif you need a specific password, override the `password` parameter.\n\nyou can also pass in user permissions by passing in a string of\n'`<app_name>.<perm name>`' or '`<app_name>.*`'.  for example:\n\n```python\nuser2 = self.make_user(perms=['myapp.create_widget', 'otherapp.*'])\n```\n\n## `print_form_errors(response_or_form=none)`\n\nwhen debugging a failing test for a view with a form, this method helps you\nquickly look at any form errors.\n\nexample usage:\n\n```python\nclass myformtest(testcase):\n\n    self.post('my-url-name', data={})\n    self.print_form_errors()\n\n    # or\n\n    resp = self.post('my-url-name', data={})\n    self.print_form_errors(resp)\n\n    # or\n\n    form = myform(data={})\n    self.print_form_errors(form)\n```\n\n## authentication helpers\n\n### `assertloginrequired(url_name, *args, **kwargs)`\n\nthis method helps you test that a given named url requires authorization:\n\n```python\ndef test_auth(self):\n    self.assertloginrequired('my-restricted-url')\n    self.assertloginrequired('my-restricted-object', pk=12)\n    self.assertloginrequired('my-restricted-object', slug='something')\n```\n\n### `login()` context\n\nalong with ensuring a view requires login and creating users, the next\nthing you end up doing is logging in as various users to test your\nrestriction logic:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n    user2 = self.make_user('u2')\n\n    self.assertloginrequired('my-protected-view')\n\n    with self.login(username=user1.username, password='password'):\n        response = self.get('my-protected-view')\n        # test user1 sees what they should be seeing\n\n    with self.login(username=user2.username, password='password'):\n        response = self.get('my-protected-view')\n        # test user2 see what they should be seeing\n```\n\nsince we're likely creating our users using `make_user()` from above,\nthe login context assumes the password is 'password' unless specified\notherwise. therefore you you can do:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n\n    with self.login(username=user1.username):\n        response = self.get('my-protected-view')\n```\n\nwe can also derive the username if we're using `make_user()` so we can\nshorten that up even further like this:\n\n```python\ndef test_restrictions(self):\n    user1 = self.make_user('u1')\n\n    with self.login(user1):\n        response = self.get('my-protected-view')\n```\n\n## ensuring low query counts\n\n### `assertnumquerieslessthan(number)` - context\n\ndjango provides\n[`assertnumqueries`](https://docs.djangoproject.com/en/1.8/topics/testing/tools/#django.test.transactiontestcase.assertnumqueries)\nwhich is great when your code generates a specific number of\nqueries. however, if this number varies due to the nature of your data, with\nthis method you can still test to ensure the code doesn't start producing a ton\nmore queries than you expect:\n\n```python\ndef test_something_out(self):\n\n    with self.assertnumquerieslessthan(7):\n        self.get('some-view-with-6-queries')\n```\n\n### `assertgoodview(url_name, *args, **kwargs)`\n\nthis method does a few things for you. it:\n\n- retrieves the name url\n- ensures the view does not generate more than 50 queries\n- ensures the response has status code 200\n- returns the response\n\noften a wide, sweeping test like this is better than no test at all. you\ncan use it like this:\n\n```python\ndef test_better_than_nothing(self):\n    response = self.assertgoodview('my-url-name')\n```\n\n## testing drf views\n\nto take advantage of the convenience of drf's test client, you can create a subclass of `testcase` and set the `client_class` property:\n\n```python\nfrom test_plus import testcase\nfrom rest_framework.test import apiclient\n\n\nclass apitestcase(testcase):\n    client_class = apiclient\n```\n\nfor convenience, `test_plus` ships with `apitestcase`, which does just that:\n\n```python\nfrom test_plus import apitestcase\n\n\nclass myapitestcase(apitestcase):\n\n    def test_post(self):\n        data = {'testing': {'prop': 'value'}}\n        self.post('view-json', data=data, extra={'format': 'json'})\n        self.assert_http_200_ok()\n```\n\nnote that using `apitestcase` requires django >= 1.8 and having installed `django-rest-framework`.\n\n## testing class-based \"generic\" views\n\nthe testcase methods `get()` and `post()` work for both function-based\nand class-based views. however, in doing so they invoke django's\nurl resolution, middleware, template processing, and decorator systems.\nfor integration testing this is desirable, as you want to ensure your\nurls resolve properly, view permissions are enforced, etc.\nfor unit testing this is costly because all these django request/response\nsystems are invoked in addition to your method, and they typically do not\naffect the end result.\n\nclass-based views (derived from django's `generic.models.view` class)\ncontain methods and mixins which makes granular unit testing (more) feasible.\nquite often your usage of a generic view class comprises an override\nof an existing method. invoking the entire view and the django request/response\nstack is a waste of time when you really want to call the overridden\nmethod directly and test the result.\n\ncbvtestcase to the rescue!\n\nas with testcase above, have your tests inherit\nfrom test_plus.test.cbvtestcase rather than testcase like so:\n\n```python\nfrom test_plus.test import cbvtestcase\n\nclass myviewtests(cbvtestcase):\n```\n\n## methods\n\n### `get_instance(cls, initkwargs=none, request=none, *args, **kwargs)`\n\nthis core method simplifies the instantiation of your class, giving you\na way to invoke class methods directly.\n\nreturns an instance of `cls`, initialized with `initkwargs`.\nsets `request`, `args`, and `kwargs` attributes on the class instance.\n`args` and `kwargs` are the same values you would pass to `reverse()`.\n\nsample usage:\n\n```python\nfrom django.views import generic\nfrom test_plus.test import cbvtestcase\n\nclass myclass(generic.detailview)\n\n    def get_context_data(self, **kwargs):\n        kwargs['answer'] = 42\n        return kwargs\n\nclass mytests(cbvtestcase):\n\n    def test_context_data(self):\n        my_view = self.get_instance(myclass, {'object': some_object})\n        context = my_view.get_context_data()\n        self.assertequal(context['answer'], 42)\n```\n\n### `get(cls, initkwargs=none, *args, **kwargs)`\n\ninvokes `cls.get()` and returns the response, rendering template if possible.\nbuilds on the `cbvtestcase.get_instance()` foundation.\n\nall test_plus.test.testcase methods are valid, so the following works:\n\n```python\nresponse = self.get(myclass)\nself.assertcontext('my_key', expected_value)\n```\n\nall test_plus testcase side-effects are honored and all test_plus\ntestcase assertion methods work with `cbvtestcase.get()`.\n\n**note:** this method bypasses django's middleware, and therefore context\nvariables created by middleware are not available. if this affects your\ntemplate/context testing, you should use testcase instead of cbvtestcase.\n\n### `post(cls, data=none, initkwargs=none, *args, **kwargs)`\n\ninvokes `cls.post()` and returns the response, rendering template if possible.\nbuilds on the `cbvtestcase.get_instance()` foundation.\n\nexample:\n\n```python\nresponse = self.post(myclass, data={'search_term': 'revsys'})\nself.response_200(response)\nself.assertcontext('company_name', 'revsys')\n```\n\nall test_plus testcase side-effects are honored and all test_plus\ntestcase assertion methods work with `cbvtestcase.post()`.\n\n**note:** this method bypasses django's middleware, and therefore context\nvariables created by middleware are not available. if this affects your\ntemplate/context testing you should use testcase instead of cbvtestcase.\n\n### `get_check_200(cls, initkwargs=none, *args, **kwargs)`\n\nworks just like `testcase.get_check_200()`.\ncaller must provide a view class instead of a url name or path parameter.\n\nall test_plus testcase side-effects are honored and all test_plus\ntestcase assertion methods work with `cbvtestcase.post()`.\n\n### `assertgoodview(cls, initkwargs=none, *args, **kwargs)`\n\nworks just like `testcase.assertgoodview()`.\ncaller must provide a view class instead of a url name or path parameter.\n\nall test_plus testcase side-effects are honored and all test_plus\ntestcase assertion methods work with `cbvtestcase.post()`.\n\n## development\n\nto work on django-test-plus itself, clone this repository and run the following command:\n\n```shell\n$ pip install -e .\n$ pip install -e .[test]\n```\n\n## to run all tests:\n\n```shell\n$ nox\n```\n\n**note**: you will also need to ensure that the `test_project` directory, located\nat the root of this repo, is in your virtualenv's path.\n\n## keep in touch!\n\nif you have a question about this project, please open a github issue. if you love us and want to keep track of our goings-on, here's where you can find us online:\n\n<a href=\"https://revsys.com?utm_medium=github&utm_source=django-test-plus\"><img src=\"https://pbs.twimg.com/profile_images/915928618840285185/sudrgin1_400x400.jpg\" height=\"50\" /></a>\n<a href=\"https://twitter.com/revsys\"><img src=\"https://cdn1.iconfinder.com/data/icons/new_twitter_icon/256/bird_twitter_new_simple.png\" height=\"43\" /></a>\n<a href=\"https://www.facebook.com/revsysllc/\"><img src=\"https://cdn3.iconfinder.com/data/icons/picons-social/57/06-facebook-512.png\" height=\"50\" /></a>\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "django-test-plus",
  "package_url": "https://pypi.org/project/django-test-plus/",
  "project_url": "https://pypi.org/project/django-test-plus/",
  "project_urls": {
    "Homepage": "https://github.com/revsys/django-test-plus/"
  },
  "release_url": "https://pypi.org/project/django-test-plus/2.2.3/",
  "requires_dist": [
    "factory-boy ; extra == 'test'",
    "flake8 ; extra == 'test'",
    "pyflakes ; extra == 'test'",
    "pytest ; extra == 'test'",
    "pytest-cov ; extra == 'test'",
    "pytest-django ; extra == 'test'",
    "pytest-pythonpath ; extra == 'test'"
  ],
  "requires_python": ">=3.6",
  "summary": "\"django-test-plus provides useful additions to django's default testcase\"",
  "version": "2.2.3",
  "releases": [],
  "developers": [
    "frank@revsys.com",
    "frank_wiles"
  ],
  "kwds": "test_default_django django test_plus djangoproject plustestcase",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_django_test_plus",
  "homepage": "https://github.com/revsys/django-test-plus/",
  "release_count": 37,
  "dependency_ids": [
    "pypi_factory_boy",
    "pypi_flake8",
    "pypi_pyflakes",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_django",
    "pypi_pytest_pythonpath"
  ]
}