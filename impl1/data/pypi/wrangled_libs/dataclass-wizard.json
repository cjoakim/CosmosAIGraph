{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "================\ndataclass wizard\n================\n\nfull documentation is available at `read the docs`_. (`installation`_)\n\n.. image:: https://img.shields.io/pypi/v/dataclass-wizard.svg\n        :target: https://pypi.org/project/dataclass-wizard\n\n.. image:: https://img.shields.io/conda/vn/conda-forge/dataclass-wizard.svg\n        :target: https://anaconda.org/conda-forge/dataclass-wizard\n\n.. image:: https://img.shields.io/pypi/pyversions/dataclass-wizard.svg\n        :target: https://pypi.org/project/dataclass-wizard\n\n.. image:: https://github.com/rnag/dataclass-wizard/actions/workflows/dev.yml/badge.svg\n        :target: https://github.com/rnag/dataclass-wizard/actions/workflows/dev.yml\n\n.. image:: https://readthedocs.org/projects/dataclass-wizard/badge/?version=latest\n        :target: https://dataclass-wizard.readthedocs.io/en/latest/?version=latest\n        :alt: documentation status\n\n\n.. image:: https://pyup.io/repos/github/rnag/dataclass-wizard/shield.svg\n     :target: https://pyup.io/repos/github/rnag/dataclass-wizard/\n     :alt: updates\n\n\n\nthis library provides a set of simple, yet elegant *wizarding* tools for\ninteracting with the python ``dataclasses`` module.\n\n    the primary use is as a fast serialization framework that enables dataclass instances to\n    be converted to/from json; this works well in particular with a *nested dataclass* model.\n\n-------------------\n\n**behold, the power of the dataclass wizard**::\n\n    >>> from __future__ import annotations\n    >>> from dataclasses import dataclass, field\n    >>> from dataclass_wizard import jsonwizard\n    ...\n    >>> @dataclass\n    ... class myclass(jsonwizard):\n    ...     my_str: str | none\n    ...     is_active_tuple: tuple[bool, ...]\n    ...     list_of_int: list[int] = field(default_factory=list)\n    ...\n    >>> string = \"\"\"\n    ... {\n    ...   \"my_str\": 20,\n    ...   \"listofint\": [\"1\", \"2\", 3],\n    ...   \"isactivetuple\": [\"true\", false, 1]\n    ... }\n    ... \"\"\"\n    ...\n    >>> instance = myclass.from_json(string)\n    >>> instance\n    myclass(my_str='20', is_active_tuple=(true, false, true), list_of_int=[1, 2, 3])\n    >>> instance.to_json()\n    '{\"mystr\": \"20\", \"isactivetuple\": [true, false, true], \"listofint\": [1, 2, 3]}'\n    >>> instance == myclass.from_dict(instance.to_dict())\n    true\n\n---\n\n.. contents:: contents\n   :depth: 1\n   :local:\n   :backlinks: none\n\n\ninstallation\n------------\n\nthe dataclass wizard library is available `on pypi`_, and can be installed with ``pip``:\n\n.. code-block:: shell\n\n    $ pip install dataclass-wizard\n\nalternatively, this library is available `on conda`_ under the `conda-forge`_ channel:\n\n.. code-block:: shell\n\n    $ conda install dataclass-wizard -c conda-forge\n\nthe ``dataclass-wizard`` library officially supports **python 3.6** or higher.\n\n.. _on conda: https://anaconda.org/conda-forge/dataclass-wizard\n.. _conda-forge: https://conda-forge.org/\n\nfeatures\n--------\n\nhere are the supported features that ``dataclass-wizard`` currently provides:\n\n-  *json/yaml (de)serialization*: marshal dataclasses to/from json, yaml, and python\n   ``dict`` objects.\n-  *field properties*: support for using properties with default\n   values in dataclass instances.\n-  *json to dataclass generation*: construct a dataclass schema with a json file\n   or string input.\n\n\nwizard mixins\n-------------\n\nin addition to the ``jsonwizard``, here are a few extra mixin_ classes that might prove quite convenient to use.\n\n* `jsonlistwizard`_ -- extends ``jsonwizard`` to return `container`_ -- instead of *list* -- objects where possible.\n* `jsonfilewizard`_ -- makes it easier to convert dataclass instances from/to json files on a local drive.\n* `yamlwizard`_ -- provides support to convert dataclass instances to/from yaml, using the default ``pyyaml`` parser.\n\n\nsupported types\n---------------\n\nthe dataclass wizard library provides inherent support for standard python collections\nsuch as ``list``, ``dict`` and ``set``, as well as most generics from the typing\nmodule, such as ``union`` and ``any``. other commonly used types such as ``enum``,\n``defaultdict``, and date and time objects such as ``datetime`` are also natively\nsupported.\n\nfor a complete list of the supported python types, including info on the\nload/dump process for special types, check out the `supported types`_ section\nin the docs.\n\n\nusage and examples\n------------------\n\nusing the built-in json marshalling support for dataclasses:\n\n    note: the following example should work in **python 3.7+** with the included ``__future__``\n    import.\n\n.. code:: python3\n\n    from __future__ import annotations  # this can be removed in python 3.10+\n\n    from dataclasses import dataclass, field\n    from datetime import date\n    from enum import enum\n\n    from dataclass_wizard import jsonwizard\n\n\n    @dataclass\n    class data(jsonwizard):\n\n        class _(jsonwizard.meta):\n            # sets the target key transform to use for serialization;\n            # defaults to `camelcase` if not specified.\n            key_transform_with_dump = 'lisp'\n\n        a_sample_bool: bool\n        values: list[inner] = field(default_factory=list)\n\n\n    @dataclass\n    class inner:\n        vehicle: car | none\n        my_dates: dict[int, date]\n\n\n    class car(enum):\n        sedan = 'bmw coupe'\n        suv = 'toyota 4runner'\n        jeep = 'jeep cherokee'\n\n\n    def main():\n\n        my_dict = {\n            'values': [\n                {\n                    'vehicle': 'toyota 4runner',\n                    'my-dates': {'123': '2023-01-31'}\n                },\n                {\n                    'vehicle': none,\n                    'my_dates': {}\n                }\n            ],\n            'asamplebool': 'true'\n        }\n\n        # de-serialize (a json string or dictionary data) into a `data` instance.\n        data = data.from_dict(my_dict)\n\n        print(repr(data))\n        # > data(a_sample_bool=true, values=[inner(vehicle=<car.suv: 'toyota 4runner'>, ...)])\n\n        # assert enums values are as expected\n        assert data.values[0].vehicle is car.suv\n\n        print(data.to_json(indent=2))\n        # {\n        #   \"a-sample-bool\": true,\n        #   \"values\": [\n        #     {\n        #       \"vehicle\": \"toyota 4runner\",\n        #       \"my-dates\": {\n        #         \"123\": \"2023-01-31\"\n        #       },\n        #   ...\n\n        # true\n        assert data == data.from_json(data.to_json())\n\n    if __name__ == '__main__':\n        main()\n\n... and with the ``property_wizard``, which provides support for\n`field properties`_ with default values in dataclasses:\n\n.. code:: python3\n\n    from __future__ import annotations  # this can be removed in python 3.10+\n\n    from dataclasses import dataclass, field\n    from typing_extensions import annotated\n\n    from dataclass_wizard import property_wizard\n\n\n    @dataclass\n    class vehicle(metaclass=property_wizard):\n        # note: the example below uses the default value from the `field` extra in\n        # the `annotated` definition; if `wheels` were annotated as `int | str`,\n        # it would default to 0, because `int` appears as the first type argument.\n        #\n        # any right-hand value assigned to `wheels` is ignored as it is simply\n        # re-declared by the property; here it is simply omitted for brevity.\n        wheels: annotated[int | str, field(default=4)]\n\n        # this is a shorthand version of the above; here an ide suggests\n        # `_wheels` as a keyword argument to the constructor method, though\n        # it will actually be named as `wheels`.\n        # _wheels: int | str = 4\n\n        @property\n        def wheels(self) -> int:\n            return self._wheels\n\n        @wheels.setter\n        def wheels(self, wheels: int | str):\n            self._wheels = int(wheels)\n\n\n    if __name__ == '__main__':\n        v = vehicle()\n        print(v)\n        # prints:\n        #   vehicle(wheels=4)\n\n        v = vehicle(wheels=3)\n        print(v)\n\n        v = vehicle('6')\n        print(v)\n\n        assert v.wheels == 6, 'the constructor should use our setter method'\n\n        # confirm that we go through our setter method\n        v.wheels = '123'\n        assert v.wheels == 123\n\n... or generate a dataclass schema for json input, via the `wiz-cli`_ tool:\n\n.. code:: shell\n\n    $ echo '{\"myfloat\": \"1.23\", \"products\": [{\"created_at\": \"2021-11-17\"}]}' | wiz gs - my_file\n\n    # contents of my_file.py\n    from dataclasses import dataclass\n    from datetime import date\n    from typing import list, union\n\n    from dataclass_wizard import jsonwizard\n\n\n    @dataclass\n    class data(jsonwizard):\n        \"\"\"\n        data dataclass\n\n        \"\"\"\n        my_float: union[float, str]\n        products: list['product']\n\n\n    @dataclass\n    class product:\n        \"\"\"\n        product dataclass\n\n        \"\"\"\n        created_at: date\n\n\njson marshalling\n----------------\n\n``jsonserializable`` (aliased to ``jsonwizard``) is a mixin_ class which\nprovides the following helper methods that are useful for serializing (and loading)\na dataclass instance to/from json, as defined by the ``abstractjsonwizard``\ninterface.\n\n.. list-table::\n   :widths: 10 40 35\n   :header-rows: 1\n\n   * - method\n     - example\n     - description\n   * - ``from_json``\n     - `item = product.from_json(string)`\n     - converts a json string to an instance of the\n       dataclass, or a list of the dataclass instances.\n   * - ``from_list``\n     - `list_of_item = product.from_list(l)`\n     - converts a python ``list`` object to a list of the\n       dataclass instances.\n   * - ``from_dict``\n     - `item = product.from_dict(d)`\n     - converts a python ``dict`` object to an instance\n       of the dataclass.\n   * - ``to_dict``\n     - `d = item.to_dict()`\n     - converts the dataclass instance to a python ``dict``\n       object that is json serializable.\n   * - ``to_json``\n     - `string = item.to_json()`\n     - converts the dataclass instance to a json string\n       representation.\n   * - ``list_to_json``\n     - `string = product.list_to_json(list_of_item)`\n     - converts a list of dataclass instances to a json string\n       representation.\n\nadditionally, it adds a default ``__str__`` method to subclasses, which will\npretty print the json representation of an object; this is quite useful for\ndebugging purposes. whenever you invoke ``print(obj)`` or ``str(obj)``, for\nexample, it'll call this method which will format the dataclass object as\na prettified json string. if you prefer a ``__str__`` method to not be\nadded, you can pass in ``str=false`` when extending from the mixin class\nas mentioned `here <https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/skip_the_str.html>`_.\n\nnote that the ``__repr__`` method, which is implemented by the\n``dataclass`` decorator, is also available. to invoke the python object\nrepresentation of the dataclass instance, you can instead use\n``repr(obj)`` or ``f'{obj!r}'``.\n\nto mark a dataclass as being json serializable (and\nde-serializable), simply sub-class from ``jsonserializable`` as shown\nbelow. you can also extend from the aliased name ``jsonwizard``, if you\nprefer to use that instead.\n\ncheck out a `more complete example`_ of using the ``jsonserializable``\nmixin class.\n\nno inheritance needed\n---------------------\n\nit is important to note that the main purpose of sub-classing from\n``jsonwizard`` mixin class is to provide helper methods like ``from_dict``\nand ``to_dict``, which makes it much more convenient and easier to load or\ndump your data class from and to json.\n\nthat is, it's meant to *complement* the usage of the ``dataclass`` decorator,\nrather than to serve as a drop-in replacement for data classes, or to provide type\nvalidation for example; there are already excellent libraries like `pydantic`_ that\nprovide these features if so desired.\n\nhowever, there may be use cases where we prefer to do away with the class\ninheritance model introduced by the mixin class. in the interests of convenience\nand also so that data classes can be used *as is*, the dataclass\nwizard library provides the helper functions ``fromlist`` and ``fromdict``\nfor de-serialization, and ``asdict`` for serialization. these functions also\nwork recursively, so there is full support for nested dataclasses -- just as with\nthe class inheritance approach.\n\nhere is an example to demonstrate the usage of these helper functions:\n\n.. note::\n  as of *v0.18.0*, the meta config for the main dataclass will cascade down\n  and be merged with the meta config (if specified) of each nested dataclass. to\n  disable this behavior, you can pass in ``recursive=false`` to the meta config.\n\n.. code:: python3\n\n    from __future__ import annotations\n\n    from dataclasses import dataclass, field\n    from datetime import datetime, date\n\n    from dataclass_wizard import fromdict, asdict, dumpmeta\n\n\n    @dataclass\n    class a:\n        created_at: datetime\n        list_of_b: list[b] = field(default_factory=list)\n\n\n    @dataclass\n    class b:\n        my_status: int | str\n        my_date: date | none = none\n\n\n    source_dict = {'createdat': '2010-06-10 15:50:00z',\n                   'list-of-b': [\n                       {'mystatus': '200', 'my_date': '2021-12-31'}\n                   ]}\n\n    # de-serialize the json dictionary object into an `a` instance.\n    a = fromdict(a, source_dict)\n\n    print(repr(a))\n    # a(created_at=datetime.datetime(2010, 6, 10, 15, 50, tzinfo=datetime.timezone.utc),\n    #   list_of_b=[b(my_status='200', my_date=datetime.date(2021, 12, 31))])\n\n    # set an optional dump config for the main dataclass, for example one which\n    # converts converts date and datetime objects to a unix timestamp (as an int)\n    #\n    # note that `recursive=true` is the default, so this meta config will be\n    # merged with the meta config (if specified) of each nested dataclass.\n    dumpmeta(marshal_date_time_as='timestamp',\n             key_transform='snake',\n             # finally, apply the meta config to the main dataclass.\n             ).bind_to(a)\n\n    # serialize the `a` instance to a python dict object.\n    json_dict = asdict(a)\n\n    expected_dict = {'created_at': 1276185000, 'list_of_b': [{'my_status': '200', 'my_date': 1640926800}]}\n\n    print(json_dict)\n    # assert that we get the expected dictionary object.\n    assert json_dict == expected_dict\n\ncustom key mappings\n-------------------\n\nif you ever find the need to add a `custom mapping`_ of a json key to a dataclass\nfield (or vice versa), the helper function ``json_field`` -- which can be\nconsidered an alias to ``dataclasses.field()`` -- is one approach that can\nresolve this.\n\nexample below:\n\n.. code:: python3\n\n    from dataclasses import dataclass\n\n    from dataclass_wizard import jsonserializable, json_field\n\n\n    @dataclass\n    class myclass(jsonserializable):\n\n        my_str: str = json_field('mystring1', all=true)\n\n\n    # de-serialize a dictionary object with the newly mapped json key.\n    d = {'mystring1': 'testing'}\n    c = myclass.from_dict(d)\n\n    print(repr(c))\n    # prints:\n    #   myclass(my_str='testing')\n\n    # assert we get the same dictionary object when serializing the instance.\n    assert c.to_dict() == d\n\nextending from ``meta``\n-----------------------\n\nlooking to change how ``date`` and ``datetime`` objects are serialized to json? or\nprefer that field names appear in *snake case* when a dataclass instance is serialized?\n\nthe inner ``meta`` class allows easy configuration of such settings, as\nshown below; and as a nice bonus, ides should be able to assist with code completion\nalong the way.\n\n.. note::\n  as of *v0.18.0*, the meta config for the main dataclass will cascade down\n  and be merged with the meta config (if specified) of each nested dataclass. to\n  disable this behavior, you can pass in ``recursive=false`` to the meta config.\n\n.. code:: python3\n\n    from dataclasses import dataclass\n    from datetime import date\n\n    from dataclass_wizard import jsonwizard\n    from dataclass_wizard.enums import datetimeto\n\n\n    @dataclass\n    class myclass(jsonwizard):\n\n        class _(jsonwizard.meta):\n            marshal_date_time_as = datetimeto.timestamp\n            key_transform_with_dump = 'snake'\n\n        my_str: str\n        my_date: date\n\n\n    data = {'my_str': 'test', 'mydate': '2010-12-30'}\n\n    c = myclass.from_dict(data)\n\n    print(repr(c))\n    # prints:\n    #   myclass(my_str='test', my_date=datetime.date(2010, 12, 30))\n\n    string = c.to_json()\n    print(string)\n    # prints:\n    #   {\"my_str\": \"test\", \"my_date\": 1293685200}\n\nother uses for ``meta``\n~~~~~~~~~~~~~~~~~~~~~~~\n\nhere are a few additional use cases for the inner ``meta`` class. note that\na full list of available settings can be found in the `meta`_ section in the docs.\n\ndebug mode\n##########\n\nenables additional (more verbose) log output. for example, a message can be\nlogged whenever an unknown json key is encountered when\n``from_dict`` or ``from_json`` is called.\n\nthis also results in more helpful error messages during the json load\n(de-serialization) process, such as when values are an invalid type --\ni.e. they don't match the annotation for the field. this can be particularly\nuseful for debugging purposes.\n\n.. note::\n  there is a minor performance impact when debug mode is enabled;\n  for that reason, i would personally advise against enabling\n  this in a *production* environment.\n\nhandle unknown json keys\n########################\n\nthe default behavior is to ignore any unknown or extraneous json keys that are\nencountered when ``from_dict`` or ``from_json`` is called, and emit a \"warning\"\nwhich is visible when *debug* mode is enabled (and logging is properly configured).\nan unknown key is one that does not have a known mapping to a dataclass field.\n\nhowever, we can also raise an error in such cases if desired. the below\nexample demonstrates a use case where we want to raise an error when\nan unknown json key is encountered in the  *load* (de-serialization) process.\n\n.. code:: python3\n\n    import logging\n    from dataclasses import dataclass\n\n    from dataclass_wizard import jsonwizard\n    from dataclass_wizard.errors import unknownjsonkey\n\n\n    # sets up application logging if we haven't already done so\n    logging.basicconfig(level='info')\n\n\n    @dataclass\n    class container(jsonwizard):\n\n        class _(jsonwizard.meta):\n            # true to enable debug mode for additional (more verbose) log output.\n            debug_enabled = true\n            # true to raise an class:`unknownjsonkey` when an unmapped json key is\n            # encountered when `from_dict` or `from_json` is called. note that by\n            # default, this is also recursively applied to any nested dataclasses.\n            raise_on_unknown_json_key = true\n\n        element: 'myelement'\n\n\n    @dataclass\n    class myelement:\n        my_str: str\n        my_float: float\n\n\n    d = {\n        'element': {\n            'mystr': 'string',\n            'my_float': '1.23',\n            # notice how this key is not mapped to a known dataclass field!\n            'my_bool': 'testing'\n        }\n    }\n\n    # try to de-serialize the dictionary object into a `myclass` object.\n    try:\n        c = container.from_dict(d)\n    except unknownjsonkey as e:\n        print('received error:', type(e).__name__)\n        print('class:', e.class_name)\n        print('unknown json key:', e.json_key)\n        print('json object:', e.obj)\n        print('known fields:', e.fields)\n    else:\n        print('successfully de-serialized the json object.')\n        print(repr(c))\n\ndate and time with custom patterns\n----------------------------------\n\nas of *v0.20.0*, date and time strings in a `custom format`_ can be de-serialized\nusing the ``datepattern``, ``timepattern``, and ``datetimepattern`` type annotations,\nrepresenting patterned `date`, `time`, and `datetime` objects respectively.\n\nthis will internally call ``datetime.strptime`` with the format specified in the annotation,\nand also use the ``fromisoformat()`` method in case the date string is in iso-8601 format.\nall dates and times will continue to be serialized as iso format strings by default. for more\ninfo, check out the `patterned date and time`_ section in the docs.\n\na brief example of the intended usage is shown below:\n\n.. code:: python3\n\n    from dataclasses import dataclass\n    from datetime import time, datetime\n    from typing import list\n    # note: in python 3.9+, you can import this from `typing` instead\n    from typing_extensions import annotated\n\n    from dataclass_wizard import fromdict, asdict, datepattern, timepattern, pattern\n\n\n    @dataclass\n    class myclass:\n        date_field: datepattern['%m-%y']\n        dt_field: annotated[datetime, pattern('%m/%d/%y %h.%m.%s')]\n        time_field1: timepattern['%h:%m']\n        time_field2: annotated[list[time], pattern('%i:%m %p')]\n\n\n    data = {'date_field': '12-2022',\n            'time_field1': '15:20',\n            'dt_field': '1/02/23 02.03.52',\n            'time_field2': ['1:20 pm', '12:30 am']}\n\n    class_obj = fromdict(myclass, data)\n\n    # all annotated fields de-serialize as just date, time, or datetime, as shown.\n    print(class_obj)\n    # myclass(date_field=datetime.date(2022, 12, 1), dt_field=datetime.datetime(2023, 1, 2, 2, 3, 52),\n    #         time_field1=datetime.time(15, 20), time_field2=[datetime.time(13, 20), datetime.time(0, 30)])\n\n    # all date/time fields are serialized as iso-8601 format strings by default.\n    print(asdict(class_obj))\n    # {'datefield': '2022-12-01', 'dtfield': '2023-01-02t02:03:52',\n    #  'timefield1': '15:20:00', 'timefield2': ['13:20:00', '00:30:00']}\n\n    # but, the patterned date/times can still be de-serialized back after\n    # serialization. in fact, it'll be faster than parsing the custom patterns!\n    assert class_obj == fromdict(myclass, asdict(class_obj))\n\ndataclasses in ``union`` types\n------------------------------\n\nthe ``dataclass-wizard`` library fully supports declaring dataclass models in\n`union`_ types as field annotations, such as ``list[wizard | archer | barbarian]``.\n\nas of *v0.19.0*, there is added support to  *auto-generate* tags for a dataclass model\n-- based on the class name -- as well as to specify a custom *tag key* that will be\npresent in the json object, which defaults to a special ``__tag__`` key otherwise.\nthese two options are controlled by the ``auto_assign_tags`` and ``tag_key``\nattributes (respectively) in the ``meta`` config.\n\nto illustrate a specific example, a json object such as\n``{\"oneof\": {\"type\": \"a\", ...}, ...}`` will now automatically map to a dataclass\ninstance ``a``, provided that the ``tag_key`` is correctly set to \"type\", and\nthe field ``one_of`` is annotated as a union type in the ``a | b`` syntax.\n\nlet's start out with an example, which aims to demonstrate the simplest usage of\ndataclasses in ``union`` types. for more info, check out the\n`dataclasses in union types`_ section in the docs.\n\n.. code:: python3\n\n    from __future__ import annotations\n\n    from dataclasses import dataclass\n\n    from dataclass_wizard import jsonwizard\n\n\n    @dataclass\n    class container(jsonwizard):\n\n        class meta(jsonwizard.meta):\n            tag_key = 'type'\n            auto_assign_tags = true\n\n        objects: list[a | b | c]\n\n\n    @dataclass\n    class a:\n        my_int: int\n        my_bool: bool = false\n\n\n    @dataclass\n    class b:\n        my_int: int\n        my_bool: bool = true\n\n\n    @dataclass\n    class c:\n        my_str: str\n\n\n    data = {\n        'objects': [\n            {'type': 'a', 'my_int': 42},\n            {'type': 'c', 'my_str': 'hello world'},\n            {'type': 'b', 'my_int': 123},\n            {'type': 'a', 'my_int': 321, 'mybool': true}\n        ]\n    }\n\n\n    c = container.from_dict(data)\n    print(f'{c!r}')\n\n    # true\n    assert c == container(objects=[a(my_int=42, my_bool=false),\n                                   c(my_str='hello world'),\n                                   b(my_int=123, my_bool=true),\n                                   a(my_int=321, my_bool=true)])\n\n\n    print(c.to_dict())\n    # prints the following on a single line:\n    # {'objects': [{'myint': 42, 'mybool': false, 'type': 'a'},\n    #              {'mystr': 'hello world', 'type': 'c'},\n    #              {'myint': 123, 'mybool': true, 'type': 'b'},\n    #              {'myint': 321, 'mybool': true, 'type': 'a'}]}\n\n    # true\n    assert c == c.from_json(c.to_json())\n\nserialization options\n---------------------\n\nthe following parameters can be used to fine-tune and control how the serialization of a\ndataclass instance to a python ``dict`` object or json string is handled.\n\nskip defaults\n~~~~~~~~~~~~~\n\na common use case is skipping fields with default values - based on the ``default``\nor ``default_factory`` argument to ``dataclasses.field`` - in the serialization\nprocess.\n\nthe attribute ``skip_defaults`` in the inner ``meta`` class can be enabled, to exclude\nsuch field values from serialization.the ``to_dict`` method (or the ``asdict`` helper\nfunction) can also be passed an ``skip_defaults`` argument, which should have the same\nresult. an example of both these approaches is shown below.\n\n.. code:: python3\n\n    from collections import defaultdict\n    from dataclasses import field, dataclass\n    from typing import defaultdict, list\n\n    from dataclass_wizard import jsonwizard\n\n\n    @dataclass\n    class myclass(jsonwizard):\n\n        class _(jsonwizard.meta):\n            skip_defaults = true\n\n        my_str: str\n        other_str: str = 'any value'\n        optional_str: str = none\n        my_list: list[str] = field(default_factory=list)\n        my_dict: defaultdict[str, list[float]] = field(\n            default_factory=lambda: defaultdict(list))\n\n\n    print('-- load (deserialize)')\n    c = myclass('abc')\n    print(f'instance: {c!r}')\n\n    print('-- dump (serialize)')\n    string = c.to_json()\n    print(string)\n\n    assert string == '{\"mystr\": \"abc\"}'\n\n    print('-- dump (with `skip_defaults=false`)')\n    print(c.to_dict(skip_defaults=false))\n\nexclude fields\n~~~~~~~~~~~~~~\n\nyou can also exclude specific dataclass fields (and their values) from the serialization\nprocess. there are two approaches that can be used for this purpose:\n\n* the argument ``dump=false`` can be passed in to the ``json_key`` and ``json_field``\n  helper functions. note that this is a more permanent option, as opposed to the one\n  below.\n\n* the ``to_dict`` method (or the ``asdict`` helper function ) can be passed\n  an ``exclude`` argument, containing a list of one or more dataclass field names\n  to exclude from the serialization process.\n\nadditionally, here is an example to demonstrate usage of both these approaches:\n\n.. code:: python3\n\n    from dataclasses import dataclass\n    from typing import annotated\n\n    from dataclass_wizard import jsonwizard, json_key, json_field\n\n\n    @dataclass\n    class myclass(jsonwizard):\n\n        my_str: str\n        my_int: int\n        other_str: annotated[str, json_key('anotherstr', dump=false)]\n        my_bool: bool = json_field('testbool', dump=false)\n\n\n    data = {'mystr': 'my string',\n            'myint': 1,\n            'anotherstr': 'testing 123',\n            'testbool': true}\n\n    print('-- from dict')\n    c = myclass.from_dict(data)\n    print(f'instance: {c!r}')\n\n    # dynamically exclude the `my_int` field from serialization\n    additional_exclude = ('my_int',)\n\n    print('-- to dict')\n    out_dict = c.to_dict(exclude=additional_exclude)\n    print(out_dict)\n\n    assert out_dict == {'mystr': 'my string'}\n\nfield properties\n----------------\n\nthe python ``dataclasses`` library has some `key limitations`_\nwith how it currently handles properties and default values.\n\nthe ``dataclass-wizard`` package natively provides support for using\nfield properties with default values in dataclasses. the main use case\nhere is to assign an initial value to the field property, if one is not\nexplicitly passed in via the constructor method.\n\nto use it, simply import\nthe ``property_wizard`` helper function, and add it as a metaclass on\nany dataclass where you would benefit from using field properties with\ndefault values. the metaclass also pairs well with the ``jsonserializable``\nmixin class.\n\nfor more examples and important how-to's on properties with default values,\nrefer to the `using field properties`_ section in the documentation.\n\ncontributing\n------------\n\ncontributions are welcome! open a pull request to fix a bug, or `open an issue`_\nto discuss a new feature or change.\n\ncheck out the `contributing`_ section in the docs for more info.\n\ntodos\n-----\n\nall feature ideas or suggestions for future consideration, have been currently added\n`as milestones`_ in the project's github repo.\n\ncredits\n-------\n\nthis package was created with cookiecutter_ and the `rnag/cookiecutter-pypackage`_ project template.\n\n.. _read the docs: https://dataclass-wizard.readthedocs.io\n.. _installation: https://dataclass-wizard.readthedocs.io/en/latest/installation.html\n.. _on pypi: https://pypi.org/project/dataclass-wizard/\n.. _cookiecutter: https://github.com/cookiecutter/cookiecutter\n.. _`rnag/cookiecutter-pypackage`: https://github.com/rnag/cookiecutter-pypackage\n.. _`contributing`: https://dataclass-wizard.readthedocs.io/en/latest/contributing.html\n.. _`open an issue`: https://github.com/rnag/dataclass-wizard/issues\n.. _`jsonlistwizard`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/wizard_mixins.html#jsonlistwizard\n.. _`jsonfilewizard`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/wizard_mixins.html#jsonfilewizard\n.. _`yamlwizard`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/wizard_mixins.html#yamlwizard\n.. _`container`: https://dataclass-wizard.readthedocs.io/en/latest/dataclass_wizard.html#dataclass_wizard.container\n.. _`supported types`: https://dataclass-wizard.readthedocs.io/en/latest/overview.html#supported-types\n.. _`mixin`: https://stackoverflow.com/a/547714/10237506\n.. _`meta`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/meta.html\n.. _`pydantic`: https://pydantic-docs.helpmanual.io/\n.. _`using field properties`: https://dataclass-wizard.readthedocs.io/en/latest/using_field_properties.html\n.. _`field properties`: https://dataclass-wizard.readthedocs.io/en/latest/using_field_properties.html\n.. _`custom mapping`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/custom_key_mappings.html\n.. _`wiz-cli`: https://dataclass-wizard.readthedocs.io/en/latest/wiz_cli.html\n.. _`key limitations`: https://florimond.dev/en/posts/2018/10/reconciling-dataclasses-and-properties-in-python/\n.. _`more complete example`: https://dataclass-wizard.readthedocs.io/en/latest/examples.html#a-more-complete-example\n.. _custom format: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\n.. _`patterned date and time`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/patterned_date_time.html\n.. _union: https://docs.python.org/3/library/typing.html#typing.union\n.. _`dataclasses in union types`: https://dataclass-wizard.readthedocs.io/en/latest/common_use_cases/dataclasses_in_union_types.html\n.. _as milestones: https://github.com/rnag/dataclass-wizard/milestones\n\n\n",
  "docs_url": null,
  "keywords": "dataclasses,dataclass,wizard,json,marshal,json to dataclass,json2dataclass,dict to dataclass,property,field-property,serialization,deserialization",
  "license": "apache 2.0",
  "name": "dataclass-wizard",
  "package_url": "https://pypi.org/project/dataclass-wizard/",
  "project_url": "https://pypi.org/project/dataclass-wizard/",
  "project_urls": {
    "Documentation": "https://dataclass-wizard.readthedocs.io",
    "Homepage": "https://github.com/rnag/dataclass-wizard",
    "Source": "https://github.com/rnag/dataclass-wizard"
  },
  "release_url": "https://pypi.org/project/dataclass-wizard/0.22.2/",
  "requires_dist": [
    "typing-extensions (>=3.7.4.2) ; python_version <= \"3.9\"",
    "dataclasses ; python_version == \"3.6\"",
    "backports-datetime-fromisoformat (==1.0.0) ; python_version == \"3.6\"",
    "pytimeparse (>=1.1.7) ; extra == 'timedelta'",
    "PyYAML (>=5.3) ; extra == 'yaml'"
  ],
  "requires_python": "",
  "summary": "marshal dataclasses to/from json. use field properties with initial values. construct a dataclass schema with json input.",
  "version": "0.22.2",
  "releases": [],
  "developers": [
    "ritvik_nag",
    "rv.kvetch@gmail.com"
  ],
  "kwds": "dataclass_wizard json2dataclass json_dict jsonfilewizard jsonwizard",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_dataclass_wizard",
  "homepage": "https://github.com/rnag/dataclass-wizard",
  "release_count": 46,
  "dependency_ids": [
    "pypi_backports_datetime_fromisoformat",
    "pypi_dataclasses",
    "pypi_pytimeparse",
    "pypi_pyyaml",
    "pypi_typing_extensions"
  ]
}