{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: system :: monitoring"
  ],
  "description": "# prometheus flask exporter\n\n[![pypi](https://img.shields.io/pypi/v/prometheus-flask-exporter.svg)](https://pypi.python.org/pypi/prometheus-flask-exporter)\n[![pypi](https://img.shields.io/pypi/pyversions/prometheus-flask-exporter.svg)](https://pypi.python.org/pypi/prometheus-flask-exporter)\n[![pypi - downloads](https://img.shields.io/pypi/dm/prometheus-flask-exporter.svg)](https://pypi.python.org/pypi/prometheus-flask-exporter)\n[![coverage status](https://coveralls.io/repos/github/rycus86/prometheus_flask_exporter/badge.svg?branch=master)](https://coveralls.io/github/rycus86/prometheus_flask_exporter?branch=master)\n[![code climate](https://codeclimate.com/github/rycus86/prometheus_flask_exporter/badges/gpa.svg)](https://codeclimate.com/github/rycus86/prometheus_flask_exporter)\n[![test & publish package](https://github.com/rycus86/prometheus_flask_exporter/actions/workflows/test-and-publish.yml/badge.svg)](https://github.com/rycus86/prometheus_flask_exporter/actions/workflows/test-and-publish.yml)\n\nthis library provides http request metrics to export into\n[prometheus](https://prometheus.io/).\nit can also track method invocations using convenient functions.\n\n## installing\n\ninstall using [pip](https://pip.pypa.io/en/stable/quickstart/):\n\n```bash\npip install prometheus-flask-exporter\n```\nor paste it into requirements.txt:\n```\n# newest version\nprometheus-flask-exporter\n\n# or with specific version number\nprometheus-flask-exporter==0.23.0\n```\nand then install dependencies from requirements.txt file as usual:\n```\npip install -r requirements.txt\n```\n\n\n## usage\n\n```python\nfrom flask import flask, request\nfrom prometheus_flask_exporter import prometheusmetrics\n\napp = flask(__name__)\nmetrics = prometheusmetrics(app)\n\n# static information as metric\nmetrics.info('app_info', 'application info', version='1.0.3')\n\n@app.route('/')\ndef main():\n    pass  # requests tracked by default\n\n@app.route('/skip')\n@metrics.do_not_track()\ndef skip():\n    pass  # default metrics are not collected\n\n@app.route('/<item_type>')\n@metrics.do_not_track()\n@metrics.counter('invocation_by_type', 'number of invocations by type',\n         labels={'item_type': lambda: request.view_args['type']})\ndef by_type(item_type):\n    pass  # only the counter is collected, not the default metrics\n\n@app.route('/long-running')\n@metrics.gauge('in_progress', 'long running requests in progress')\ndef long_running():\n    pass\n\n@app.route('/status/<int:status>')\n@metrics.do_not_track()\n@metrics.summary('requests_by_status', 'request latencies by status',\n                 labels={'status': lambda r: r.status_code})\n@metrics.histogram('requests_by_status_and_path', 'request latencies by status and path',\n                   labels={'status': lambda r: r.status_code, 'path': lambda: request.path})\ndef echo_status(status):\n    return 'status: %s' % status, status\n```\n\n## default metrics\n\nthe following metrics are exported by default\n(unless the `export_defaults` is set to `false`).\n\n- `flask_http_request_duration_seconds` (histogram)\n  labels: `method`, `path` and `status`.\n  flask http request duration in seconds for all flask requests.\n- `flask_http_request_total` (counter)\n  labels: `method` and `status`.\n  total number of http requests for all flask requests.\n- `flask_http_request_exceptions_total` (counter)\n  labels: `method` and `status`.\n  total number of uncaught exceptions when serving flask requests.\n- `flask_exporter_info` (gauge)\n  information about the prometheus flask exporter itself (e.g. `version`).\n\nthe prefix for the default metrics can be controlled by the `defaults_prefix` parameter.\nif you don't want to use any prefix, pass the `prometheus_flask_exporter.no_prefix` value in.\nthe buckets on the default request latency histogram can be changed by the `buckets` parameter, and if using a summary for them is more appropriate for your use case, then use the `default_latency_as_histogram=false` parameter.\n\nto register your own *default* metrics that will track all registered\nflask view functions, use the `register_default` function.\n\n```python\napp = flask(__name__)\nmetrics = prometheusmetrics(app)\n\n@app.route('/simple')\ndef simple_get():\n    pass\n    \nmetrics.register_default(\n    metrics.counter(\n        'by_path_counter', 'request count by request paths',\n        labels={'path': lambda: request.path}\n    )\n)\n```\n\n*note:* register your default metrics after all routes have been set up.\nalso note, that gauge metrics registered as default will track the\n`/metrics` endpoint, and this can't be disabled at the moment.\n\nif you want to apply the same metric to multiple (but not all) endpoints,\ncreate its wrapper first, then add to each function.\n\n```python\napp = flask(__name__)\nmetrics = prometheusmetrics(app)\n\nby_path_counter = metrics.counter(\n    'by_path_counter', 'request count by request paths',\n    labels={'path': lambda: request.path}\n)\n\n@app.route('/simple')\n@by_path_counter\ndef simple_get():\n    pass\n    \n@app.route('/plain')\n@by_path_counter\ndef plain():\n    pass\n    \n@app.route('/not/tracked/by/path')\ndef not_tracked_by_path():\n    pass\n```\n\nyou can avoid recording metrics on individual endpoints\nby decorating them with `@metrics.do_not_track()`, or use the \n`excluded_paths` argument when creating the `prometheusmetrics` instance\nthat takes a regular expression (either a single string, or a list) and\nmatching paths will be excluded. these apply to both built-in and user-defined\ndefault metrics, unless you disable it by setting the `exclude_user_defaults`\nargument to `false`. if you have functions that are inherited or otherwise get\nmetrics collected that you don't want, you can use `@metrics.exclude_all_metrics()`\nto exclude both default and non-default metrics being collected from it.\n\n## configuration\n\nby default, the metrics are exposed on the same flask application on the\n`/metrics` endpoint and using the core prometheus registry.\nif this doesn't suit your needs, set the `path` argument to `none` and/or\nthe `export_defaults` argument to `false` plus change the `registry`\nargument if needed.\n\nthe `group_by` constructor argument controls what\nthe default request duration metric is tracked by: endpoint (function)\ninstead of uri path (the default). this parameter also accepts a function\nto extract the value from the request, or a name of a property of the request object.\nexamples:\n\n```python\nprometheusmetrics(app, group_by='path')         # the default\nprometheusmetrics(app, group_by='endpoint')     # by endpoint\nprometheusmetrics(app, group_by='url_rule')     # by url rule\n\ndef custom_rule(req):  # the flask request object\n    \"\"\" the name of the function becomes the label name. \"\"\"\n    return '%s::%s' % (req.method, req.path)\n\nprometheusmetrics(app, group_by=custom_rule)    # by a function\n\n# error: this is not supported:\nprometheusmetrics(app, group_by=lambda r: r.path)\n```\n\n> the `group_by_endpoint` argument is deprecated since 0.4.0,\n> please use the new `group_by` argument.\n\nthe `register_endpoint` allows exposing the metrics endpoint on a specific path.\nit also allows passing in a flask application to register it on but defaults\nto the main one if not defined.\n\nsimilarly, the `start_http_server` allows exposing the endpoint on an\nindependent flask application on a selected http port.\nit also supports overriding the endpoint's path and the http listen address.\n\nyou can also set default labels to add to every request managed by\na `prometheusmetrics` instance, using the `default_labels` argument.\nthis needs to be a dictionary, where each key will become a metric\nlabel name, and the values the label values.\nthese can be constant values, or dynamic functions, see below in the\n[labels](#labels) section.\n\n> the `static_labels` argument is deprecated since 0.15.0,\n> please use the new `default_labels` argument.\n\nif you use another framework over flask (perhaps\n[connexion](https://connexion.readthedocs.io/)) then you might return\nresponses from your endpoints that flask can't deal with by default.\nif that is the case, you might need to pass in a `response_converter`\nthat takes the returned object and should convert that to a flask\nfriendly response.\nsee `connexionprometheusmetrics` for an example.\n\n## labels\n\nwhen defining labels for metrics on functions,\nthe following values are supported in the dictionary:\n\n- a simple static value\n- a no-argument callable\n- a single argument callable that will receive the flask response\n  as the argument\n\nlabel values are evaluated within the request context.\n\n## initial metric values\n_for more info see: https://github.com/prometheus/client_python#labels_\n\nmetrics without any labels will get an initial value.\nmetrics that only have static-value labels will also have an initial value. (except when they are created with the option `initial_value_when_only_static_labels=false`)\nmetrics that have one or more callable-value labels will not have an initial value.\n\n## application information\n\nthe `prometheusmetrics.info(..)` method provides a way to expose\ninformation as a `gauge` metric, the application version for example.\n\nthe metric is returned from the method to allow changing its value\nfrom the default `1`:\n\n```python\nmetrics = prometheusmetrics(app)\ninfo = metrics.info('dynamic_info', 'something dynamic')\n...\ninfo.set(42.1)\n```\n\n## examples\n\nsee some simple examples visualized on a grafana dashboard by running\nthe demo in the [examples/sample-signals](https://github.com/rycus86/prometheus_flask_exporter/tree/master/examples/sample-signals) folder.\n\n![example dashboard](https://github.com/rycus86/prometheus_flask_exporter/raw/master/examples/sample-signals/dashboard.png)\n\n## app factory pattern\n\nthis library also supports the flask [app factory pattern](http://flask.pocoo.org/docs/1.0/patterns/appfactories/). use the `init_app` method to attach the library to one or more application objects. note, that to use this mode, you'll need to use the `for_app_factory()` class method to create the `metrics` instance, or pass in `none` for the `app` in the constructor.\n\n```python\nmetrics = prometheusmetrics.for_app_factory()\n# then later:\nmetrics.init_app(app)\n```\n\n## securing the metrics endpoint\n\nif you wish to have authentication (or any other special handling) on the metrics endpoint,\nyou can use the `metrics_decorator` argument when creating the `prometheusmetrics` instance.\nfor example to integrate with [flask-httpauth](https://github.com/miguelgrinberg/flask-httpauth)\nuse it like it's shown in the example below.\n\n```python\napp = flask(__name__)\nauth = httpbasicauth()\nmetrics = prometheusmetrics(app, metrics_decorator=auth.login_required)\n\n# ... other authentication setup like @auth.verify_password below\n```\n\nsee a full example in the [examples/flask-httpauth](https://github.com/rycus86/prometheus_flask_exporter/tree/master/examples/flask-httpauth) folder.\n\n## custom metrics endpoint\n\nyou can also take full control of the metrics endpoint by generating its contents,\nand managing how it is exposed by yourself.\n\n```python\napp = flask(__name__)\n# path=none to avoid registering a /metrics endpoint on the same flask app\nmetrics = prometheusmetrics(app, path=none)\n\n# later ... generate the response (and its content type) to expose to prometheus\nresponse_data, content_type = metrics.generate_metrics()\n```\n\nsee the related conversation in [issue #135](https://github.com/rycus86/prometheus_flask_exporter/issues/135).\n\n## debug mode\n\nplease note, that changes being live-reloaded, when running the flask\napp with `debug=true`, are not going to be reflected in the metrics.\nsee [https://github.com/rycus86/prometheus_flask_exporter/issues/4](https://github.com/rycus86/prometheus_flask_exporter/issues/4)\nfor more details.\n\nalternatively - since version `0.5.1` - if you set the `debug_metrics`\nenvironment variable, you will get metrics for the latest reloaded code.\nthese will be exported on the main flask app.\nserving the metrics on a different port is not going to work\nmost probably - e.g. `prometheusmetrics.start_http_server(..)` is not\nexpected to work.\n\n## wsgi\n\ngetting accurate metrics for wsgi apps might require a bit more setup.\nsee a working sample app in the `examples` folder, and also the\n[prometheus_flask_exporter#5](https://github.com/rycus86/prometheus_flask_exporter/issues/5) issue.\n\n### multiprocess applications\n\nfor multiprocess applications (wsgi or otherwise), you can find some\nhelper classes in the `prometheus_flask_exporter.multiprocess` module.\nthese provide convenience wrappers for exposing metrics in an\nenvironment where multiple copies of the application will run on a single host.\n\n```python\n# an extension targeted at gunicorn deployments\nfrom prometheus_flask_exporter.multiprocess import gunicornprometheusmetrics\n\napp = flask(__name__)\nmetrics = gunicornprometheusmetrics(app)\n\n# then in the gunicorn config file:\nfrom prometheus_flask_exporter.multiprocess import gunicornprometheusmetrics\n\ndef when_ready(server):\n    gunicornprometheusmetrics.start_http_server_when_ready(8080)\n\ndef child_exit(server, worker):\n    gunicornprometheusmetrics.mark_process_dead_on_child_exit(worker.pid)\n```\n\nalso see the `gunicorninternalprometheusmetrics` class if you want to have\nthe metrics http endpoint exposed internally, on the same flask application.\n\n```python\n# an extension targeted at gunicorn deployments with an internal metrics endpoint\nfrom prometheus_flask_exporter.multiprocess import gunicorninternalprometheusmetrics\n\napp = flask(__name__)\nmetrics = gunicorninternalprometheusmetrics(app)\n\n# then in the gunicorn config file:\nfrom prometheus_flask_exporter.multiprocess import gunicorninternalprometheusmetrics\n\ndef child_exit(server, worker):\n    gunicorninternalprometheusmetrics.mark_process_dead_on_child_exit(worker.pid)\n```\n\nthere's a small wrapper available for [gunicorn](https://gunicorn.org/) and\n[uwsgi](https://uwsgi-docs.readthedocs.io/en/latest/index.html), for everything\nelse you can extend the `prometheus_flask_exporter.multiprocess.multiprocessprometheusmetrics` class\nand implement the `should_start_http_server` method at least.\n\n```python\nfrom prometheus_flask_exporter.multiprocess import multiprocessprometheusmetrics\n\nclass mymultiprocessmetrics(multiprocessprometheusmetrics):\n    def should_start_http_server(self):\n        return this_worker() == primary_worker()\n```\n\nthis should return `true` on one process only, and the underlying\n[prometheus client library](https://github.com/prometheus/client_python)\nwill collect the metrics for all the forked children or siblings.\n\nan additional flask extension for apps with `processes=n` and `threaded=false` exists\nwith the `multiprocessinternalprometheusmetrics` class.\n\n```python\nfrom flask import flask\nfrom prometheus_flask_exporter.multiprocess import multiprocessinternalprometheusmetrics\n\napp = flask(__name__)\nmetrics = multiprocessinternalprometheusmetrics(app)\n\n...\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', 4000, processes=5, threaded=false)\n```\n\n__note:__ this needs the `prometheus_multiproc_dir` environment variable\nto point to a valid, writable directory.\n\nyou'll also have to call the `metrics.start_http_server()` function\nexplicitly somewhere, and the `should_start_http_server` takes care of\nonly starting it once.\nthe [examples](https://github.com/rycus86/prometheus_flask_exporter/tree/master/examples) folder\nhas some working examples on this.\n\nplease also note, that the prometheus client library does not collect process level\nmetrics, like memory, cpu and python gc stats when multiprocessing is enabled.\nsee the [prometheus_flask_exporter#18](https://github.com/rycus86/prometheus_flask_exporter/issues/18)\nissue for some more context and details.\n\na final caveat is that the metrics http server will listen on __any__ paths\non the given http port, not only on `/metrics`, and it is not implemented\nat the moment to be able to change this.\n\n### uwsgi lazy-apps\n\nwhen [uwsgi](https://uwsgi-docs.readthedocs.io/en/latest/) is configured \nto run with [lazy-apps]([lazy-apps](https://uwsgi-docs.readthedocs.io/en/latest/articles/theartofgracefulreloading.html#preforking-vs-lazy-apps-vs-lazy)),\nexposing the metrics endpoint on a separate http server (and port) is not functioning yet.\na workaround is to register the endpoint on the main flask application.\n\n```python\napp = flask(__name__)\nmetrics = uwsgiprometheusmetrics(app)\nmetrics.register_endpoint('/metrics')\n# instead of metrics.start_http_server(port)\n```\n\nsee [#31](https://github.com/rycus86/prometheus_flask_exporter/issues/31)\nfor context, and please let me know if you know a better way!\n\n## connexion integration\n\nthe [connexion](https://connexion.readthedocs.io/) library has some\nsupport to automatically deal with certain response types, for example\ndataclasses, which a plain flask application would not accept.\nto ease the integration, you can use `connexionprometheusmetrics` in\nplace of `prometheusmetrics` that has the `response_converter` set\nappropriately to be able to deal with whatever connexion supports for\nflask integrations.\n\n```python\nimport connexion\nfrom prometheus_flask_exporter import connexionprometheusmetrics\n\napp = connexion.app(__name__)\nmetrics = connexionprometheusmetrics(app)\n```\n\nsee a working sample app in the `examples` folder, and also the\n[prometheus_flask_exporter#61](https://github.com/rycus86/prometheus_flask_exporter/issues/61) issue. \n\nthere's a caveat about this integration, where any endpoints that\ndo not return json responses need to be decorated with\n`@metrics.content_type('...')` as this integration would force them\nto be `application/json` otherwise.\n\n```python\nmetrics = connexionprometheusmetrics(app)\n\n@metrics.content_type('text/plain')\ndef plain_response():\n    return 'plain text'\n```\n\nsee the [prometheus_flask_exporter#64](https://github.com/rycus86/prometheus_flask_exporter/issues/64) issue for more details.\n\n## flask-restful integration\n\nthe [flask-restful library](https://flask-restful.readthedocs.io/) has\nsome custom response handling logic, which can be helpful in some cases.\nfor example, returning `none` would fail on plain flask, but it\nworks on flask-restful.\nto ease the integration, you can use `restfulprometheusmetrics` in\nplace of `prometheusmetrics` that sets the `response_converter` to use\nthe flask-restful `api` response utilities.\n\n```python\nfrom flask import flask\nfrom flask_restful import api\nfrom prometheus_flask_exporter import restfulprometheusmetrics\n\napp = flask(__name__)\nrestful_api = api(app)\nmetrics = restfulprometheusmetrics(app, restful_api)\n```\n\nsee a working sample app in the `examples` folder, and also the\n[prometheus_flask_exporter#62](https://github.com/rycus86/prometheus_flask_exporter/issues/62) issue.\n\n## license\n\nmit\n",
  "docs_url": null,
  "keywords": "prometheus,flask,monitoring,exporter",
  "license": "mit",
  "name": "prometheus-flask-exporter",
  "package_url": "https://pypi.org/project/prometheus-flask-exporter/",
  "project_url": "https://pypi.org/project/prometheus-flask-exporter/",
  "project_urls": {
    "Download": "https://github.com/rycus86/prometheus_flask_exporter/archive/0.23.0.tar.gz",
    "Homepage": "https://github.com/rycus86/prometheus_flask_exporter"
  },
  "release_url": "https://pypi.org/project/prometheus-flask-exporter/0.23.0/",
  "requires_dist": [
    "prometheus-client",
    "flask"
  ],
  "requires_python": "",
  "summary": "prometheus metrics exporter for flask",
  "version": "0.23.0",
  "releases": [],
  "developers": [
    "rycus86@gmail.com",
    "viktor_adam"
  ],
  "kwds": "prometheus_flask_exporter prometheus_multiproc_dir flask_exporter_info prometheus prometheusmetrics",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_prometheus_flask_exporter",
  "homepage": "https://github.com/rycus86/prometheus_flask_exporter",
  "release_count": 70,
  "dependency_ids": [
    "pypi_flask",
    "pypi_prometheus_client"
  ]
}