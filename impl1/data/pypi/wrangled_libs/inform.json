{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: posix :: linux",
    "programming language :: python :: 3",
    "topic :: utilities"
  ],
  "description": "inform \u2014 print & logging utilities\n==================================\n\n..  image:: https://github.com/kenkundert/inform/actions/workflows/build.yaml/badge.svg\n    :target: https://github.com/kenkundert/inform/actions/workflows/build.yaml\n\n.. image:: https://pepy.tech/badge/inform/month\n    :target: https://pepy.tech/project/inform\n\n.. image:: https://img.shields.io/readthedocs/inform.svg\n   :target: https://inform.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://img.shields.io/coveralls/kenkundert/inform.svg\n    :target: https://coveralls.io/r/kenkundert/inform\n\n.. image:: https://img.shields.io/pypi/v/inform.svg\n    :target: https://pypi.python.org/pypi/inform\n\n.. image:: https://img.shields.io/pypi/pyversions/inform.svg\n    :target: https://pypi.python.org/pypi/inform/\n\n\n:author: ken kundert\n:version: 1.28\n:released: 2023-03-20\n\na package that provides specialized print functions that are used when \ncommunicating with the user. it allows you to easily print attractive, \ninformative, and consistent error messages.  for example:\n\n.. code-block:: python\n\n    >> from inform import display, warn, error\n    >> display(\n    ..     'display is like print'\n    ..     'except that it supports logging and can be disabled.'\n    ..     sep=', ')\n    display is like print, except that it supports logging and can be disabled.\n\n    >> warn('warnings get a header that is printed in yellow.')\n    warning: warnings get a header that is printed in yellow.\n\n    >> error('errors get a header that is printed in red.')\n    error: errors get a header that is printed in red.\n\ninform also provides logging and output control.\n\nin addition, inform provides a powerful generic exception that can be used \ndirectly as a general purpose exception, or can be subclassed to produce \npowerful specialized exceptions.  inform exceptions are unique in that they keep \nall of the named and unnamed arguments so they can be used when reporting \nerrors.\n\nyou can find the documentation on `readthedocs\n<https://inform.readthedocs.io>`_. you can download and install the latest\nstable version of the code from `pypi <https://pypi.python.org>`_ using::\n\n    pip3 install --user --upgrade inform\n\nyou can find the latest development version of the source code on\n`github <https://github.com/kenkundert/inform>`_.\n\nsupported in python2.7, python3.5, python3.6, python3.7 and python3.8.\n\n\nintroduction\n------------\n\nthis package defines a collection of *print* functions that have different \nroles.  these functions are referred to as *informants* and are described below \nin the informants section. they include include *log*, *comment*, *codicil*, \n*narrate*, *display*, *output*, *notify*, *debug*, *warn*, *error*, *fatal* and \n*panic*.\n\nwith the simplest use of the program, you simply import the informants you need \nand call them (they take the same arguments as python's built-in *print* \nfunction):\n\n.. code-block:: python\n\n    >>> from inform import display\n    >>> display('ice', 9)\n    ice 9\n\nfor more control of the informants, you can import and instantiate the inform \nclass yourself along with the desired informants.  this gives you the ability to \nspecify options:\n\n.. code-block:: python\n\n    >>> from inform import inform, display, error\n    >>> inform(logfile=false, prog_name=false)\n    <...>\n    >>> display('hello')\n    hello\n    >>> error('file not found.', culprit='data.in')\n    error: data.in: file not found.\n\nan object of the inform class is referred to as an informer (not to be confused \nwith the print functions, which are  referred to as informants). once \ninstantiated, you can use the informer to change various settings, terminate the \nprogram, or return a count of the number of errors that have occurred.\n\n.. code-block:: python\n\n    >>> from inform import inform, error\n    >>> informer = inform(prog_name=\"prog\")\n    >>> error('file not found.', culprit='data.in')\n    prog error: data.in: file not found.\n    >>> informer.errors_accrued()\n    1\n\nyou can create your own informants:\n\n.. code-block:: python\n\n    >>> from inform import inform, informantfactory\n\n    >>> verbose1 = informantfactory(output=lambda m: m.verbosity >= 1)\n    >>> verbose2 = informantfactory(output=lambda m: m.verbosity >= 2)\n    >>> with inform(verbosity=0):\n    ...     verbose1('first level of verbosity.')\n    ...     verbose2('second level of verbosity.')\n\n    >>> with inform(verbosity=1):\n    ...     verbose1('first level of verbosity.')\n    ...     verbose2('second level of verbosity.')\n    first level of verbosity.\n\n    >>> with inform(verbosity=2):\n    ...     verbose1('first level of verbosity.')\n    ...     verbose2('second level of verbosity.')\n    first level of verbosity.\n    second level of verbosity.\n\nthe argument *verbosity* is not an explicitly supported argument to inform.  in \nthis case inform simply saves the value and makes it available as an attribute, \nand it is this attribute that is queried by the lambda function passed to the \ninformantfactory when creating the informants.\n\n\nexception\n---------\nan exception, *error*, is provided that takes the same arguments as an \ninformant.  this allows you to catch the exception and handle it if you like.  \nthe exception provides the *report* and *terminate* methods that processes the \nexception as an error or fatal error if you find that you can do nothing else \nwith the exception:\n\n.. code-block:: python\n\n    >>> from inform import inform, error\n\n    >>> inform(prog_name='myprog')\n    <...>\n    >>> try:\n    ...     raise error('must not be zero.', culprit='naught')\n    ... except error as e:\n    ...     e.report()\n    myprog error: naught: must not be zero.\n\n*error* also provides get_message() and get_culprit() methods, which return the \nmessage and the culprit. you can also cast the exception to a string to get \na string that contains both the message and the culprit formatted so that it can \nbe shown to the user.\n\nany keyword arguments provided will be available in *e.kwargs*, but certain \nkeyword arguments are reserved by inform (see above).\n\none common approach to using *error* is to pass all the arguments that make up \nthe error message as unnamed arguments and then assemble them into the message \nby providing a template.  in that way the arguments are directly available to \nthe handler if needed. for example:\n\n.. code-block:: python\n\n    >>> from difflib import get_close_matches\n    >>> from inform import error, codicil, conjoin, fmt\n\n    >>> known_names = 'alpha beta gamma delta epsilon'.split()\n    >>> name = 'alfa'\n\n    >>> try:\n    ...     if name not in known_names:\n    ...         raise error(name, template=\"name '{}' is not defined.\")\n    ... except error as e:\n    ...     candidates = get_close_matches(e.args[0], known_names, 1, 0.6)\n    ...     candidates = conjoin(candidates, conj=' or ')\n    ...     e.report()\n    ...     codicil(fmt('did you mean {candidates}?'))\n    myprog error: name 'alfa' is not defined.\n        did you mean alpha?\n\n\nutilities\n---------\n\nseveral utility functions are provided for your convenience. they are often \nhelpful when creating messages.\n\nindent:\n    indents the text.\n\nconjoin:\n    like ''.join(), but allows you to specify a conjunction that is placed \n    between the last two elements, ex:\n\n    .. code-block:: python\n\n        >>> from inform import conjoin\n        >>> conjoin(['a', 'b', 'c'])\n        'a, b and c'\n\n        >>> conjoin(['a', 'b', 'c'], conj=' or ')\n        'a, b or c'\n\ncull:\n    strips items from a collection that have a particular value.\n\njoin:\n    combines the arguments in a manner very similar to an informant and returns \n    the result as a string.\n\nfmt:\n    similar to ''.format(), but it can pull arguments from the local scope.\n\nrender:\n    recursively convert an object to a string with reasonable formatting.  has \n    built in support for the base python types (none, bool, int, float, str, \n    set, tuple, list, and dict).  if you confine yourself to these types, the \n    output of render() can be read by the python interpreter. other types are \n    converted to string with repr().\n\nplural:\n    produces either the singular or plural form of a word based on a count.\n\nfull_stop:\n    adds a period to the end of the string if needed (if the last character is \n    not a period, question mark or exclamation mark).\n\ncolumns:\n    distribute array over enough columns to fill the screen.\n\nos_error:\n    generates clean messages for operating system errors.\n\nis_str:\n    returns *true* if its argument is a string-like object.\n\nis_iterable:\n    returns *true* if its argument is iterable.\n\nis_collection:\n    returns *true* if its argument is iterable but is not a string.\n\nis_mapping:\n    returns *true* if its argument is a mapping (are dictionary like).\n\nfor example:\n\n.. code-block:: python\n\n    >>> from inform import inform, display, error, conjoin, cull, fmt, os_error\n\n    >>> inform(prog_name=false)\n    <...>\n    >>> filenames = cull(['a', 'b', none, 'd'])\n    >>> filetype = 'csv'\n    >>> display(\n    ...     fmt(\n    ...         'reading {filetype} files: {names}.',\n    ...         names=conjoin(filenames),\n    ...     )\n    ... )\n    reading csv files: a, b and d.\n\n    >>> contents = {}\n    >>> for name in filenames:\n    ...     try:\n    ...         with open(name) as f:\n    ...             contents[name] = f.read()\n    ...     except ioerror as e:\n    ...         error(os_error(e))\n    error: a: no such file or directory.\n    error: b: no such file or directory.\n    error: d: no such file or directory.\n\nnotice that *filetype* was not explicitly passed into *fmt()* even though it was \nexplicitly called out in the format string.  *filetype* can be left out of the \nargument list because if *fmt* does not find a named argument in its argument \nlist, it will look for a variable of the same name in the local scope.\n\nhere is an example of render():\n\n.. code-block:: python\n\n    >>> from inform import render, display\n    >>> s1='alpha string'\n    >>> s2='beta string'\n    >>> n=42\n    >>> s={s1, s2}\n    >>> l=[s1, n, s]\n    >>> d = {1:s1, 2:s2}\n    >>> d={'s': s1, 'n': n, 's': s, 'l': l, 'd':d}\n    >>> display('d', '=', render(d, true))\n    d = {\n        'l': [\n            'alpha string',\n            42,\n            {'alpha string', 'beta string'},\n        ],\n        's': {'alpha string', 'beta string'},\n        'd': {1: 'alpha string', 2: 'beta string'},\n        'n': 42,\n        's': 'alpha string',\n    }\n\nfinally, here is an example of full_stop and columns. it prints out the phonetic \nalphabet.\n\n.. code-block:: python\n\n    >>> from inform import columns, full_stop\n    >>> title = 'display the nato phonetic alphabet'\n    >>> words = \"\"\"\n    ...     alfa bravo charlie delta echo foxtrot golf hotel india juliett kilo\n    ...     lima mike november oscar papa quebec romeo sierra tango uniform\n    ...     victor whiskey x-ray yankee zulu\n    ... \"\"\".split()\n    >>> display(full_stop(title), columns(words), sep='\\n')\n    display the nato phonetic alphabet.\n        alfa      echo      india     mike      quebec    uniform   yankee\n        bravo     foxtrot   juliett   november  romeo     victor    zulu\n        charlie   golf      kilo      oscar     sierra    whiskey\n        delta     hotel     lima      papa      tango     x-ray\n\ndebugging functions\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nthe debugging functions are intended to be used when you want to print something \nout when debugging your program.  they are colorful to make it easier to find \nthem among the program's normal output, and a header is added that describes \nthe location they were called from. this makes it easier to distinguish several \ndebug message and also makes it easy to find and remove the functions once you \nare done debugging.\n\nppp:\n    this function is very similar to the normal python print function.\n\n    .. code:: python\n\n        >>> from inform import ppp, ddd, sss, vvv\n        >>> a = 1\n        >>> b = 'this is a test'\n        >>> c = (2, 3)\n        >>> d = {'a': a, 'b': b, 'c': c}\n        >>> ppp(a, b, c)\n        debug: <doctest readme.rst[52]>, 1, __main__: 1 this is a test (2, 3)\n\nddd:\n    this function is pretty prints all of both the unnamed and named arguments.\n\n    .. code:: python\n\n        >>> ddd(a, b, c=c, d=d)\n        debug: <doctest readme.rst[53]>, 1, __main__:\n            1\n            'this is a test'\n            c = (2, 3)\n            d = {\n                'a': 1,\n                'b': 'this is a test',\n                'c': (2, 3),\n            }\n\n    if you give named arguments, the name is prepended to its value.\n\n\nvvv:\n    this function prints variables from the calling scope. if no arguments are \n    given, then all the variables are printed. you can optionally give specific \n    variables on the argument list and only those variables are printed.\n\n    .. code:: python\n\n        >>> vvv(b, d)\n        debug: <doctest readme.rst[54]>, 1, __main__:\n            b = 'this is a test'\n            d = {\n                'a': 1,\n                'b': 'this is a test',\n                'c': (2, 3),\n            }\n\n\nsss:\n    this function prints a stack trace, which can answer the *how did i get \n    here?* question better than a simple print function.\n\n    .. code:: python\n\n        >> def foo():\n        ..     sss()\n        ..     print('continuing')\n\n        >> foo()\n        debug: <doctest readme.rst[93]>:2, __main__.foo():\n            traceback (most recent call last):\n                ...\n        continuing\n\n\ncolor class\n\"\"\"\"\"\"\"\"\"\"\"\n\nthe color class creates colorizers, which are used to render text in \na particular color.  they are like the python print function in that they take \nany number of unnamed arguments that are converted to strings and then joined \ninto a single string. the string is then coded for the chosen color and \nreturned. for example:\n\n.. code-block:: python\n\n   >> from inform import color, display\n\n   >> green = color('green')\n   >> red = color('red')\n   >> success = green('pass:')\n   >> failure = red('fail:')\n\n   >> failures = {'outrigger': true, 'signalman': false}\n   >> for name, fails in failures.items():\n   ..     result = failure if fails else success\n   ..     display(result, name)\n   fail: outrigger\n   pass: signalman\n\nwhen the messages print, the 'pass:' will be green and 'fail:' will be red.\n\n",
  "docs_url": null,
  "keywords": "inform,logging,printing",
  "license": "",
  "name": "inform",
  "package_url": "https://pypi.org/project/inform/",
  "project_url": "https://pypi.org/project/inform/",
  "project_urls": {
    "changelog": "https://github.com/KenKundert/inform/blob/master/doc/releases.rst",
    "documentation": "https://inform.readthedocs.io",
    "homepage": "https://inform.readthedocs.io",
    "repository": "https://github.com/kenkundert/inform"
  },
  "release_url": "https://pypi.org/project/inform/1.28/",
  "requires_dist": [
    "arrow",
    "six",
    "pytest ; extra == \"test\"",
    "pytest-cov ; extra == \"test\"",
    "tox ; extra == \"test\"",
    "pylama ; extra == \"test\""
  ],
  "requires_python": ">=3.6",
  "summary": "print & logging utilities for communicating with user",
  "version": "1.28",
  "releases": [],
  "developers": [
    "inform@nurdletech.com",
    "ken_kundert"
  ],
  "kwds": "badge inform yaml svg informer",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_inform",
  "homepage": "",
  "release_count": 43,
  "dependency_ids": [
    "pypi_arrow",
    "pypi_pylama",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_six",
    "pypi_tox"
  ]
}