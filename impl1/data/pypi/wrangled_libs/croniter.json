{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "introduction\n============\n\n.. contents::\n\n\ncroniter provides iteration for the datetime object with a cron like format.\n\n::\n\n                          _ _\n      ___ _ __ ___  _ __ (_) |_ ___ _ __\n     / __| '__/ _ \\| '_ \\| | __/ _ \\ '__|\n    | (__| | | (_) | | | | | ||  __/ |\n     \\___|_|  \\___/|_| |_|_|\\__\\___|_|\n\n\nwebsite: https://github.com/kiorky/croniter\n\nbuild badge\n===========\n.. image:: https://github.com/kiorky/croniter/actions/workflows/cicd.yml/badge.svg\n    :target: https://github.com/kiorky/croniter/actions/workflows/cicd.yml\n\n\nusage\n============\n\na simple example::\n\n    >>> from croniter import croniter\n    >>> from datetime import datetime\n    >>> base = datetime(2010, 1, 25, 4, 46)\n    >>> iter = croniter('*/5 * * * *', base)  # every 5 minutes\n    >>> print(iter.get_next(datetime))   # 2010-01-25 04:50:00\n    >>> print(iter.get_next(datetime))   # 2010-01-25 04:55:00\n    >>> print(iter.get_next(datetime))   # 2010-01-25 05:00:00\n    >>>\n    >>> iter = croniter('2 4 * * mon,fri', base)  # 04:02 on every monday and friday\n    >>> print(iter.get_next(datetime))   # 2010-01-26 04:02:00\n    >>> print(iter.get_next(datetime))   # 2010-01-30 04:02:00\n    >>> print(iter.get_next(datetime))   # 2010-02-02 04:02:00\n    >>>\n    >>> iter = croniter('2 4 1 * wed', base)  # 04:02 on every wednesday or on 1st day of month\n    >>> print(iter.get_next(datetime))   # 2010-01-27 04:02:00\n    >>> print(iter.get_next(datetime))   # 2010-02-01 04:02:00\n    >>> print(iter.get_next(datetime))   # 2010-02-03 04:02:00\n    >>>\n    >>> iter = croniter('2 4 1 * wed', base, day_or=false)  # 04:02 on every 1st day of the month if it is a wednesday\n    >>> print(iter.get_next(datetime))   # 2010-09-01 04:02:00\n    >>> print(iter.get_next(datetime))   # 2010-12-01 04:02:00\n    >>> print(iter.get_next(datetime))   # 2011-06-01 04:02:00\n    >>>\n    >>> iter = croniter('0 0 * * sat#1,sun#2', base)  # 1st saturday, and 2nd sunday of the month\n    >>> print(iter.get_next(datetime))   # 2010-02-06 00:00:00\n    >>>\n    >>> iter = croniter('0 0 * * 5#3,l5', base)  # 3rd and last friday of the month\n    >>> print(iter.get_next(datetime))   # 2010-01-29 00:00:00\n    >>> print(iter.get_next(datetime))   # 2010-02-19 00:00:00\n\n\nall you need to know is how to use the constructor and the ``get_next``\nmethod, the signature of these methods are listed below::\n\n    >>> def __init__(self, cron_format, start_time=time.time(), day_or=true)\n\ncroniter iterates along with ``cron_format`` from ``start_time``.\n``cron_format`` is **min hour day month day_of_week**, you can refer to\nhttp://en.wikipedia.org/wiki/cron for more details. the ``day_or``\nswitch is used to control how croniter handles **day** and **day_of_week**\nentries. default option is the cron behaviour, which connects those\nvalues using **or**. if the switch is set to false, the values are connected\nusing **and**. this behaves like fcron and enables you to e.g. define a job that\nexecutes each 2nd friday of a month by setting the days of month and the\nweekday.\n::\n\n    >>> def get_next(self, ret_type=float)\n\nget_next calculates the next value according to the cron expression and\nreturns an object of type ``ret_type``. ``ret_type`` should be a ``float`` or a\n``datetime`` object.\n\nsupported added for ``get_prev`` method. (>= 0.2.0)::\n\n    >>> base = datetime(2010, 8, 25)\n    >>> itr = croniter('0 0 1 * *', base)\n    >>> print(itr.get_prev(datetime))  # 2010-08-01 00:00:00\n    >>> print(itr.get_prev(datetime))  # 2010-07-01 00:00:00\n    >>> print(itr.get_prev(datetime))  # 2010-06-01 00:00:00\n\nyou can validate your crons using ``is_valid`` class method. (>= 0.3.18)::\n\n    >>> croniter.is_valid('0 0 1 * *')  # true\n    >>> croniter.is_valid('0 wrong_value 1 * *')  # false\n\nabout dst\n=========\nbe sure to init your croniter instance with a tz aware datetime for this to work!\n\nexample using pytz::\n\n    >>> import pytz\n    >>> tz = pytz.timezone(\"europe/paris\")\n    >>> local_date = tz.localize(datetime(2017, 3, 26))\n    >>> val = croniter('0 0 * * *', local_date).get_next(datetime)\n\nexample using python_dateutil::\n\n    >>> import dateutil.tz\n    >>> tz = dateutil.tz.gettz('asia/tokyo')\n    >>> local_date = datetime(2017, 3, 26, tzinfo=tz)\n    >>> val = croniter('0 0 * * *', local_date).get_next(datetime)\n\nexample using python built in module::\n\n    >>> from datetime import datetime, timezone\n    >>> local_date = datetime(2017, 3, 26, tzinfo=timezone.utc)\n    >>> val = croniter('0 0 * * *', local_date).get_next(datetime)\n\nabout second repeats\n=====================\ncroniter is able to do second repetition crontabs form::\n\n    >>> croniter('* * * * * 1', local_date).get_next(datetime)\n    >>> base = datetime(2012, 4, 6, 13, 26, 10)\n    >>> itr = croniter('* * * * * 15,25', base)\n    >>> itr.get_next(datetime) # 4/6 13:26:15\n    >>> itr.get_next(datetime) # 4/6 13:26:25\n    >>> itr.get_next(datetime) # 4/6 13:27:15\n\nyou can also note that this expression will repeat every second from the start datetime.::\n\n    >>> croniter('* * * * * *', local_date).get_next(datetime)\n\ntesting if a date matches a crontab\n===================================\ntest for a match with (>=0.3.32)::\n\n    >>> croniter.match(\"0 0 * * *\", datetime(2019, 1, 14, 0, 0, 0, 0))\n    true\n    >>> croniter.match(\"0 0 * * *\", datetime(2019, 1, 14, 0, 2, 0, 0))\n    false\n    >>>\n    >>> croniter.match(\"2 4 1 * wed\", datetime(2019, 1, 1, 4, 2, 0, 0)) # 04:02 on every wednesday or on 1st day of month\n    true\n    >>> croniter.match(\"2 4 1 * wed\", datetime(2019, 1, 1, 4, 2, 0, 0), day_or=false) # 04:02 on every 1st day of the month if it is a wednesday\n    false\n\ngaps between date matches\n=========================\nfor performance reasons, croniter limits the amount of cpu cycles spent attempting to find the next match.\nstarting in v0.3.35, this behavior is configurable via the ``max_years_between_matches`` parameter, and the default window has been increased from 1 year to 50 years.\n\nthe defaults should be fine for many use cases.\napplications that evaluate multiple cron expressions or handle cron expressions from untrusted sources or end-users should use this parameter.\niterating over sparse cron expressions can result in increased cpu consumption or a raised ``croniterbaddateerror`` exception which indicates that croniter has given up attempting to find the next (or previous) match.\nexplicitly specifying ``max_years_between_matches`` provides a way to limit cpu utilization and simplifies the iterable interface by eliminating the need for ``croniterbaddateerror``.\nthe difference in the iterable interface is based on the reasoning that whenever ``max_years_between_matches`` is explicitly agreed upon, there is no need for croniter to signal that it has given up; simply stopping the iteration is preferable.\n\nthis example matches 4 am friday, january 1st.\nsince january 1st isn't often a friday, there may be a few years between each occurrence.\nsetting the limit to 15 years ensures all matches::\n\n    >>> it = croniter(\"0 4 1 1 fri\", datetime(2000,1,1), day_or=false, max_years_between_matches=15).all_next(datetime)\n    >>> for i in range(5):\n    ...     print(next(it))\n    ...\n    2010-01-01 04:00:00\n    2016-01-01 04:00:00\n    2021-01-01 04:00:00\n    2027-01-01 04:00:00\n    2038-01-01 04:00:00\n\nhowever, when only concerned with dates within the next 5 years, simply set ``max_years_between_matches=5`` in the above example.\nthis will result in no matches found, but no additional cycles will be wasted on unwanted matches far in the future.\n\niterating over a range using cron\n=================================\nfind matches within a range using the ``croniter_range()`` function.  this is much like the builtin ``range(start,stop,step)`` function, but for dates.  the `step` argument is a cron expression.\nadded in (>=0.3.34)\n\nlist the first saturday of every month in 2019::\n\n    >>> from croniter import croniter_range\n    >>> for dt in croniter_range(datetime(2019, 1, 1), datetime(2019, 12, 31), \"0 0 * * sat#1\"):\n    >>>     print(dt)\n\n\nhashed expressions\n==================\n\ncroniter supports jenkins-style hashed expressions, using the \"h\" definition keyword and the required hash_id keyword argument.\nhashed expressions remain consistent, given the same hash_id, but different hash_ids will evaluate completely different to each other.\nthis allows, for example, for an even distribution of differently-named jobs without needing to manually spread them out.\n\n    >>> itr = croniter(\"h h * * *\", hash_id=\"hello\")\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 10, 11, 10)\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 11, 11, 10)\n    >>> itr = croniter(\"h h * * *\", hash_id=\"hello\")\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 10, 11, 10)\n    >>> itr = croniter(\"h h * * *\", hash_id=\"bonjour\")\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 10, 20, 52)\n\n\nrandom expressions\n==================\n\nrandom \"r\" definition keywords are supported, and remain consistent only within their croniter() instance.\n\n    >>> itr = croniter(\"r r * * *\")\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 10, 22, 56)\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 11, 22, 56)\n    >>> itr = croniter(\"r r * * *\")\n    >>> itr.get_next(datetime)\n    datetime.datetime(2021, 4, 11, 4, 19)\n\n\nkeyword expressions\n===================\n\nvixie cron-style \"@\" keyword expressions are supported.\nwhat they evaluate to depends on whether you supply hash_id: no hash_id corresponds to vixie cron definitions (exact times, minute resolution), while with hash_id corresponds to jenkins definitions (hashed within the period, second resolution).\n\n    ============ ============ ================\n    keyword      no hash_id   with hash_id\n    ============ ============ ================\n    @midnight    0 0 * * *    h h(0-2) * * * h\n    @hourly      0 * * * *    h * * * * h\n    @daily       0 0 * * *    h h * * * h\n    @weekly      0 0 * * 0    h h * * h h\n    @monthly     0 0 1 * *    h h h * * h\n    @yearly      0 0 1 1 *    h h h h * h\n    @annually    0 0 1 1 *    h h h h * h\n    ============ ============ ================\n\n\nupgrading\n==========\n\nto 2.0.0\n---------\n\n- install or upgrade pytz by using version specified  requirements/base.txt if you have it installed `<=2021.1`.\n\ndevelop this package\n====================\n\n::\n\n    git clone https://github.com/kiorky/croniter.git\n    cd croniter\n    virtualenv --no-site-packages venv\n    . venv/bin/activate\n    pip install --upgrade -r requirements/test.txt\n    py.test src\n\n\nmake a new release\n====================\nwe use zest.fullreleaser, a great release infrastructure.\n\ndo and follow these instructions\n::\n\n    . venv/bin/activate\n    pip install --upgrade -r requirements/release.txt\n    ./release.sh\n\n\ncontributors\n===============\nthanks to all who have contributed to this project!\nif you have contributed and your name is not listed below please let me know.\n\n    - mrmachine\n    - hinnack\n    - shazow\n    - kiorky\n    - jlsandell\n    - mag009\n    - djmitche\n    - greatcombinator\n    - chris-baynes\n    - ipartola\n    - yuzawa-san\n    - lowell80 (kintyre)\n    - scop\n    - zed2015\n    - ryan finnie (rfinnie)\n\n\n\nchangelog\n==============\n\n2.0.1 (2023-10-11)\n------------------\n\n- fix release issue [kiorky]\n\n\n2.0.0 (2023-10-10)\n------------------\n\n- add python 3.12 support [rafsaf]\n- make major release instructions [kiorky]\n\n\n1.4.1 (2023-06-15)\n------------------\n\n- make a retrocompatible version of 1.4.0 change about supporting vixiecron bug. (fix #47)\n  [kiorky]\n\n\n1.4.0 (2023-06-15)\n------------------\n\n- added \"implement_cron_bug\" flag to make the cron parser compatible with a bug in vixie/isc cron\n  [kiorky, david white <dwhite2@cisco.com>]\n  *warning*: expand method changes return value\n\n\n1.3.15 (2023-05-25)\n-------------------\n\n- fix hashed expressions omitting some entries\n  [@waltervos/walter vos <walter.vos@ns.nl>]\n- enhance .match() precision for 6 position expressions\n  [@szpol/szymon <szymon.polinkiewicz@gmail.com>]\n\n1.3.14 (2023-04-12)\n-------------------\n\n- lint\n\n\n1.3.13 (2023-04-12)\n-------------------\n\n- add check for range begin/end\n\n\n\n1.3.12 (2023-04-12)\n-------------------\n\n- restore py2 compat\n\n\n1.3.11 (2023-04-12)\n-------------------\n\n-  do not expose `i` into global namespace\n\n\n1.3.10 (2023-04-07)\n-------------------\n\n- fix dow hash parsing [kiorky]\n- better error handling on py3 [kiorky]\n\n1.3.8 (2022-11-22)\n------------------\n\n- add python 3.11 support and move docs files to main folder [rafsaf]\n\n\n1.3.7 (2022-09-06)\n------------------\n\n- fix tests\n- fix croniter_range infinite loop  [shachar snapiri <ssnapiri@paloaltonetworks.com>]\n\n\n1.3.5 (2022-05-14)\n------------------\n\n- add python 3.10 support [eelkevdbos]\n\n\n1.3.4 (2022-02-18)\n------------------\n\n- really fix compat for tests under py27\n  [kiorky]\n\n\n1.3.3 (2022-02-18)\n------------------\n\n- fix compat for tests under py27\n  [kiorky]\n\n\n1.3.2 (2022-02-18)\n------------------\n\n- fix #12: regressions with set_current\n  [kiorky, agateblue]\n\n\n1.3.1 (2022-02-15)\n------------------\n\n- restore compat with python2\n  [kiorky]\n\n\n1.3.0 (2022-02-15)\n------------------\n\n- add a way to make next() easier to use. this fixes #11\n  [kiorky]\n\n\n1.2.0 (2022-01-14)\n------------------\n\n- enforce validation for day=1. before this release we used to support day=0 and it was silently glided to day=1 to support having both day in day in 4th field when it came to have 6fields cron forms (second repeat). it will now raises a croniterbaddateerror. see https://github.com/kiorky/croniter/issues/6\n  [kiorky]\n\n1.1.0 (2021-12-03)\n------------------\n\n- enforce validation for month=1. before this release we used to support month=0 and it was silently glided to month=1 to support having both day in month in 4th field when it came to have 6fields cron forms (second repeat). it will now raises a croniterbaddateerror. see https://github.com/kiorky/croniter/issues/6\n  [kiorky]\n\n1.0.15 (2021-06-25)\n-------------------\n\n- restore py2 [kiorky]\n\n\n1.0.14 (2021-06-25)\n-------------------\n\n- better type checks [kiorky]\n\n\n1.0.13 (2021-05-06)\n-------------------\n\n- fix zerodivisionerror with ``* * r/0 * *``\n  [cuu508]\n\n1.0.12 (2021-04-13)\n-------------------\n\n- add support for hashed/random/keyword expressions\n  ryan finnie (rfinnie)\n- review support support for hashed/random/keyword expression and add expanders reactor\n  [ kiorky ]\n\n\n1.0.11 (2021-04-07)\n-------------------\n\n- fix bug: bad case:``0 6 30 3 *``\n  [zed2015(zhangchi)]\n- add support for ``l`` in the day_of_week component.  this enable expressions like ``* * * * l4``, which means last thursday of the month.  this resolves #159.\n  [kintyre]\n- create ``croniterunsupportedsyntaxerror`` exception for situations where cron syntax may be valid but some combinations of features is not supported.\n  currently, this is used when the ``day_of_week`` component has a combination of literal values and nth/last syntax at the same time.\n  for example, ``0 0 * * 1,l6`` or ``0 0 * * 15,sat#1`` will both raise this exception because of mixing literal days of the week with nth-weekday or last-weekday syntax.\n  this *may* impact existing cron expressions in prior releases, because ``0 0 * * 15,sat#1`` was previously allowed but incorrectly handled.\n  [kintyre]\n\n- update ``croniter_range()`` to allow an alternate ``croniter`` class to be used.  helpful when using a custom class derived from croniter.\n  [kintyre]\n\n\n1.0.10 (2021-03-25)\n-------------------\n\n- remove external library ``natsort``.\n  sorting of cron expression components now handled with ``sorted()`` with a custom ``key`` function.\n  [kintyre]\n\n\n\n1.0.9 (2021-03-23)\n------------------\n\n- remove futures dependency\n  [kiorky]\n\n\n1.0.8 (2021-03-06)\n------------------\n\n- update `_expand` to lowercase each component of the expression.\n  this is in relation to #157. with this change, croniter accepts and correctly handles `* * 10-l * *`.\n  [cuu508]\n\n\n1.0.7 (2021-03-02)\n------------------\n\n- fix _expand to reject int literals with underscores\n  [cuu508]\n- remove a debug statement to make flake8 happy\n  [cuu508]\n\n1.0.6 (2021-02-01)\n------------------\n\n- fix combination of star and invalid expression bugs\n  [kiorky]\n\n\n1.0.5 (2021-01-29)\n------------------\n\n- security fix: fix overflow when using cron ranges\n  [kiorky]\n\n1.0.4 (2021-01-29)\n------------------\n\n- spelling fix release\n\n\n1.0.3 (2021-01-29)\n------------------\n\n- fix #155: raise croniterbadcronerror when error syntax\n  [kiorky]\n\n\n1.0.2 (2021-01-19)\n------------------\n\n- fix match when datetime has microseconds\n  [kiorky]\n\n1.0.1 (2021-01-06)\n------------------\n- no changes, just to make sense with new semver2 (making croniter on a stable state)\n  [kiorky]\n\n\n0.3.37 (2020-12-31)\n-------------------\n\n- added python 3.8 and 3.9 support\n  [eumiro]\n\n\n0.3.36 (2020-11-02)\n-------------------\n\n- updated docs section regarding ``max_years_between_matches`` to be more shorter and hopefully more relevant.\n  [kintyre]\n- don't install tests\n  [scop]\n\n\n0.3.35 (2020-10-11)\n-------------------\n\n- handle l in ranges. this fixes #142.\n  [kiorky]\n- add a new initialization parameter ``max_years_between_matches`` to support finding the next/previous date beyond the default 1 year window, if so desired.  updated readme to include additional notes and example of this usage.  fixes #145.\n  [kintyre]\n- the ``croniter_range()`` function was updated to automatically determines the appropriate ``max_years_between_matches`` value, this preventing handling of the ``croniterbaddateerror`` exception.\n  [kintyre]\n- updated exception handling classes:  ``croniterbaddateerror`` now only\n  applies during date finding operations (next/prev), and all parsing errors can now be caught using ``croniterbadcronerror``.  the ``croniternotalphaerror`` exception is now a subclass of ``croniterbadcronerror``.  a brief description of each exception class was added as an inline docstring.\n  [kintyre]\n- updated iterable interfaces to replace the ``croniterbaddateerror`` with ``stopiteration`` if (and only if) the ``max_years_between_matches`` argument is provided.  the rationale here is that if the user has specified the max tolerance between matches, then there's no need to further inform them of no additional matches.  just stop the iteration.  this also keeps backwards compatibility.\n  [kintyre]\n- minor docs update\n  [kintyre]\n\n\n0.3.34 (2020-06-19)\n-------------------\n\n- feat ``croniter_range(start, stop, cron)``\n  [kintyre]\n- optimization for poorly written cron expression\n  [kintyre]\n\n0.3.33 (2020-06-15)\n-------------------\n\n- make dateutil tz support more official\n  [kintyre]\n- feat/support for day or\n  [\u7530\u53e3\u4fe1\u5143]\n\n0.3.32 (2020-05-27)\n-------------------\n\n- document seconds repeats, fixes #122\n  [kiorky]\n- implement match method, fixes #54\n  [kiorky]\n- adding tests for #127 (test more dsts and croniter behavior around)\n  [kiorky]\n- changed lag_hours comparison to absolute to manage dst boundary when getting previous\n  [sokkka]\n\n0.3.31 (2020-01-02)\n-------------------\n\n- fix get_next() when start_time less then 1s before next instant\n  [alexhill]\n\n\n0.3.30 (2019-04-20)\n-------------------\n\n- credits\n\n\n0.3.29 (2019-03-26)\n-------------------\n\n- credits\n- history stripping (security)\n- handle -sun notation, this fixes `#119 <https://github.com/taichino/croniter/issues/119>`_.\n  [kiorky]\n- handle invalid ranges correctly,  this fixes `#114 <https://github.com/taichino/croniter/issues/114>`_.\n  [kiorky]\n\n0.3.25 (2018-08-07)\n-------------------\n- pypi hygiene\n  [hugovk]\n\n\n0.3.24 (2018-06-20)\n-------------------\n- fix `#107 <https://github.com/taichino/croniter/issues/107>`_: microsecond threshold\n  [kiorky]\n\n\n0.3.23 (2018-05-23)\n-------------------\n\n- fix ``get_next`` while preserving the fix of ``get_prev`` in 7661c2aaa\n  [avikam agur <avikam@pagaya-inv.com>]\n\n\n0.3.22 (2018-05-16)\n-------------------\n- don't count previous minute if now is dynamic\n  if the code is triggered from 5-asterisk based cron\n  ``get_prev`` based on ``datetime.now()`` is expected to return\n  current cron iteration and not previous execution.\n  [igor khrol <igor.khrol@toptal.com>]\n\n0.3.20 (2017-11-06)\n-------------------\n\n- more dst fixes\n  [kevin rose <kbrose@github>]\n\n\n0.3.19 (2017-08-31)\n-------------------\n\n- fix #87: backward dst changes\n  [kiorky]\n\n\n0.3.18 (2017-08-31)\n-------------------\n\n- add is valid method, refactor errors\n  [otherpirate, mauro murari <mauro_murari@hotmail.com>]\n\n\n0.3.17 (2017-05-22)\n-------------------\n- dow occurrence sharp style support.\n  [kiorky, kengo seki <sekikn@apache.org>]\n\n\n0.3.16 (2017-03-15)\n-------------------\n\n- better test suite [mrcrilly@github]\n- dst support [kiorky]\n\n0.3.15 (2017-02-16)\n-------------------\n\n- fix bug around multiple conditions and range_val in\n  _get_prev_nearest_diff.\n  [abeja-yuki@github]\n\n0.3.14 (2017-01-25)\n-------------------\n\n- issue #69: added day_or option to change behavior when day-of-month and\n  day-of-week is given\n  [andreas vogl <a.vogl@hackner-security.com>]\n\n\n\n0.3.13 (2016-11-01)\n-------------------\n\n- `real fix for #34 <https://github.com/taichino/croniter/pull/73>`_\n  [kiorky@github]\n- `modernize test infra <https://github.com/taichino/croniter/pull/72>`_\n  [kiorky@github]\n- `release as a universal wheel <https://github.com/kiorky/croniter/pull/16>`_\n  [adamchainz@github]\n- `raise valueerror on negative numbers <https://github.com/taichino/croniter/pull/63>`_\n  [josegonzalez@github]\n- `compare types using \"issubclass\" instead of exact match <https://github.com/taichino/croniter/pull/70>`_\n  [darkk@github]\n- `implement step cron with a variable base <https://github.com/taichino/croniter/pull/60>`_\n  [josegonzalez@github]\n\n0.3.12 (2016-03-10)\n-------------------\n- support setting ret_type in __init__ [brent tubbs <brent.tubbs@gmail.com>]\n\n0.3.11 (2016-01-13)\n-------------------\n\n- bug fix: the get_prev api crashed when last day of month token was used. some\n  essential logic was missing.\n  [iddo aviram <iddo.aviram@similarweb.com>]\n\n\n0.3.10 (2015-11-29)\n-------------------\n\n- the functionality of 'l' as day of month was broken, since the month variable\n  was not properly updated\n  [iddo aviram <iddo.aviram@similarweb.com>]\n\n0.3.9 (2015-11-19)\n------------------\n\n- don't use datetime functions python 2.6 doesn't support\n  [petervtzand]\n\n0.3.8 (2015-06-23)\n------------------\n- truncate microseconds by setting to 0\n  [corey wright]\n\n\n0.3.7 (2015-06-01)\n------------------\n\n- converting sun in range sun-thu transforms to int 0 which is\n  recognized as empty string; the solution was to convert sun to string \"0\"\n\n0.3.6 (2015-05-29)\n------------------\n\n- fix default behavior when no start_time given\n  default value for ``start_time`` parameter is calculated at module init time rather than call time.\n- fix timezone support and stop depending on the system time zone\n\n\n\n0.3.5 (2014-08-01)\n------------------\n\n- support for 'l' (last day of month)\n\n\n0.3.4 (2014-01-30)\n------------------\n\n- python 3 compat\n- qa release\n\n\n0.3.3 (2012-09-29)\n------------------\n- proper packaging\n\n\n\n",
  "docs_url": null,
  "keywords": "datetime,iterator,cron",
  "license": "mit license",
  "name": "croniter",
  "package_url": "https://pypi.org/project/croniter/",
  "project_url": "https://pypi.org/project/croniter/",
  "project_urls": {
    "Homepage": "http://github.com/kiorky/croniter"
  },
  "release_url": "https://pypi.org/project/croniter/2.0.1/",
  "requires_dist": [
    "python-dateutil",
    "pytz (>2021.1)"
  ],
  "requires_python": ">=2.6, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*",
  "summary": "croniter provides iteration for datetime object with cron like format",
  "version": "2.0.1",
  "releases": [],
  "developers": [
    "kiorky@cryptelium.net",
    "matsumoto_taichi",
    "taichino@gmail.com"
  ],
  "kwds": "cron_format cron croniterbaddateerror crontab python_dateutil",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_croniter",
  "homepage": "http://github.com/kiorky/croniter",
  "release_count": 85,
  "dependency_ids": [
    "pypi_python_dateutil",
    "pypi_pytz"
  ]
}