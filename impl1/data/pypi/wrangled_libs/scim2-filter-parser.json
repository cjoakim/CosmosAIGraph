{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "scim 2.0 filter parser\n======================\n\n|github| |codecov| |docs|\n\n.. |codecov| image:: https://codecov.io/gh/15five/scim2-filter-parser/branch/master/graph/badge.svg\n  :target: https://codecov.io/gh/15five/scim2-filter-parser\n\n.. |docs| image:: https://readthedocs.org/projects/scim2-filter-parser/badge/?version=latest\n  :target: https://scim2-filter-parser.readthedocs.io/en/latest/?badge=latest\n  :alt: documentation status\n\n.. |github| image:: https://github.com/15five/scim2-filter-parser/workflows/ci%2fcd/badge.svg\n  :target: https://github.com/15five/scim2-filter-parser/actions?workflow=ci%2fcd\n  :alt: ci/cd status\n\ndescription\n-----------\n\nscim 2.0 defines queries that look like this::\n\n    'emails[type eq \"work\" and value co \"@example.com\"] or ims[type eq \"xmpp\" and value co \"@foo.com\"]'\n\nthese can be hard to work with and covert into sql to run against a database.\n\nthat's where scim 2.0 filter parser (sfp) can help.\n\nsfp is broken up into four modules, each handling a different part of\ntranslating a scim call into a sql query.\n\nthe first step is tokenization or lexical analysis where the filter query\nis broken down into many tokens that make it up.\n\n::\n\n    sfp-lexer 'emails[type eq \"work\" and value co \"@example.com\"] or ims[type eq \"xmpp\" and value co \"@foo.com\"]'\n\n    token(type='attrname', value='emails', lineno=1, index=0)\n    token(type='lbracket', value='[', lineno=1, index=6)\n    token(type='attrname', value='type', lineno=1, index=7)\n    token(type='eq', value='eq', lineno=1, index=12)\n    token(type='comp_value', value='work', lineno=1, index=15)\n    token(type='and', value='and', lineno=1, index=22)\n    token(type='attrname', value='value', lineno=1, index=26)\n    token(type='co', value='co', lineno=1, index=32)\n    token(type='comp_value', value='@example.com', lineno=1, index=35)\n    token(type='rbracket', value=']', lineno=1, index=49)\n    token(type='or', value='or', lineno=1, index=51)\n    token(type='attrname', value='ims', lineno=1, index=54)\n    token(type='lbracket', value='[', lineno=1, index=57)\n    token(type='attrname', value='type', lineno=1, index=58)\n    token(type='eq', value='eq', lineno=1, index=63)\n    token(type='comp_value', value='xmpp', lineno=1, index=66)\n    token(type='and', value='and', lineno=1, index=73)\n    token(type='attrname', value='value', lineno=1, index=77)\n    token(type='co', value='co', lineno=1, index=83)\n    token(type='comp_value', value='@foo.com', lineno=1, index=86)\n    token(type='rbracket', value=']', lineno=1, index=96)\n\n\nthe second step is to convert that series of tokens into a abstract syntax tree.\n\n::\n\n    sfp-parser 'emails[type eq \"work\" and value co \"@example.com\"] or ims[type eq \"xmpp\" and value co \"@foo.com\"]'\n\n    filter(expr=logexpr, negated=false, namespace=none)\n        logexpr(op='or', expr1=filter, expr2=filter)\n            filter(expr=filter, negated=false, namespace=none)\n                filter(expr=filter, negated=false, namespace=attrpath)\n                    filter(expr=logexpr, negated=false, namespace=none)\n                        logexpr(op='and', expr1=filter, expr2=filter)\n                            filter(expr=attrexpr, negated=false, namespace=none)\n                                attrexpr(value='eq', attr_path=attrpath, comp_value=compvalue)\n                                    attrpath(attr_name='type', sub_attr=none, uri=none)\n                                    compvalue(value='work')\n                            filter(expr=attrexpr, negated=false, namespace=none)\n                                attrexpr(value='co', attr_path=attrpath, comp_value=compvalue)\n                                    attrpath(attr_name='value', sub_attr=none, uri=none)\n                                    compvalue(value='@example.com')\n                    attrpath(attr_name='emails', sub_attr=none, uri=none)\n            filter(expr=filter, negated=false, namespace=none)\n                filter(expr=filter, negated=false, namespace=attrpath)\n                    filter(expr=logexpr, negated=false, namespace=none)\n                        logexpr(op='and', expr1=filter, expr2=filter)\n                            filter(expr=attrexpr, negated=false, namespace=none)\n                                attrexpr(value='eq', attr_path=attrpath, comp_value=compvalue)\n                                    attrpath(attr_name='type', sub_attr=none, uri=none)\n                                    compvalue(value='xmpp')\n                            filter(expr=attrexpr, negated=false, namespace=none)\n                                attrexpr(value='co', attr_path=attrpath, comp_value=compvalue)\n                                    attrpath(attr_name='value', sub_attr=none, uri=none)\n                                    compvalue(value='@foo.com')\n                    attrpath(attr_name='ims', sub_attr=none, uri=none)\n\nthe third step is to transpile this ast into a language of our choice.\nthe above query is transpiled to sql below.\n\n::\n\n    sfp-transpiler 'emails[type eq \"work\" and value co \"@example.com\"] or ims[type eq \"xmpp\" and value co \"@foo.com\"]'\n\n    ((emails.type = {0}) and (emails.value like {1})) or ((ims.type = {2}) and (ims.value like {3}))\n    {0: 'work', 1: '%@example.com%', 2: 'xmpp', 3: '%@foo.com%'}\n\nthe fourth step is to take what is a segment of a sql where clause and complete\nthe rest of the sql query.\n\n::\n\n    sfp-query 'emails[type eq \"work\" and value co \"@example.com\"] or ims[type eq \"xmpp\" and value co \"@foo.com\"]'\n\n    >>> do not use this output directly\n    >>> sql injection attack risk\n    >>> sql preview:\n        select distinct users.*\n        from users\n        left join emails on emails.user_id = users.id\n        left join schemas on schemas.user_id = users.id\n        where ((emails.type = work) and (emails.value like %@example.com%)) or ((ims.type = xmpp) and (ims.value like %@foo.com%));\n\nplease note that sfp does not build sql queries with parameters pre-injected.\nthat would create a sql injection attack vulnerability. instead a ``sqlquery``\nobject is created and can be forced to display itself as seen above\nby ``print`` ing the query object.\n\ninstallation\n------------\n::\n\n    pip install scim2-filter-parser\n\n    # or ...\n\n    pip install scim2-filter-parser[django-query]\n\nuse\n---\n\nalthough command line shims are provided, the library is intended to be used\nprogrammatically. users of the library should instantiate the\n``scim2_filter_parser.queries.sqlquery`` class with an attribute map and optionally\nany joins necessary to make all required fields accessible in the query.\n\nfor example, if user information is stored in the ``users`` table and email\ninformation is stored in a different table ``emails``, then the attribute map\nand the joins might be defined as so::\n\n    from scim2_filter_parser.queries import sqlquery\n\n    attr_map = {\n        ('username', none, none): 'users.username',\n        ('name', 'familyname', none): 'users.family_name',\n        ('meta', 'lastmodified', none): 'users.update_ts',\n        ('emails', none, none): 'emails.address',\n        ('emails', 'value', none): 'emails.address',\n    }\n\n    joins = (\n        'left join emails on emails.user_id = users.id',\n    )\n\n    filter_ = 'name.familyname co \"simpson\" or emails.value eq \"lisa@example.com\"'\n\n    q = sqlquery(filter_, 'users', attr_map, joins)\n\n    q.sql # will be...\n\n    select distinct users.*\n    from users\n    left join emails on emails.user_id = users.id\n    where (users.family_name like %s) or (emails.address = %s);\n\n    q.params # will be...\n\n    ['%simpson%', 'lisa@example.com']\n\nthe attribute_map (``attr_map``) is a mapping of scim attribute, subattribute,\nand schema uri to a table field. you will need to customize this to your\nparticular database schema.\n\nthe ``sqlquery.sql`` method returns sql that can be used as the first\nargument in a call to ``cursor.execute()`` with your favorite db engine.\nif you are using a database that requires a replacement character other than '%s',\nthen you can subclass the ``sqlquery`` class and override the ``placeholder`` class\nlevel variable. see the query module and unit tests for an example of this subclassing\nwith sqlite.\n\nthe ``sqlquery.params`` method returns a list of items that can be used as the\nsecond argument in a call to ``cursor.execute()``.\n\ndjango\n------\n\nif you would like to produce a `django q`_ object instead of a raw sql query, you can pass\na scim filter query and attribute map to the ``get_query`` function from the module\n``scim2_filter_parser.transpilers.django_q_object``. for example::\n\n    get_query(scim_query: str, attr_map: mapping)\n\nthis q object can then be passed to a django filter query like so::\n\n    query = get_query(scim_query, attr_map)\n    user.objects.filter(query)\n\nplease note that you will need to install the django query extra like for this feature to be available::\n\n    pip install scim2-filter-parser[django-query]\n\n.. _`django q`: https://docs.djangoproject.com/en/3.1/topics/db/queries/#complex-lookups-with-q-objects\n\nspeed\n-----\n\nsfp is pretty fast. check out the speed_test.py script for details on the long and short\nfilter queries tested. sfp transpiled a short filter query into sql in under 54 microseconds.\nfor a longer query, sfp only took 273 microseconds.\n\n::\n\n    \u279c  scim2-filter-parser git:(master) \u2717 python -m timeit -s \"import speed_test\" \"speed_test.short()\"\n    10000 loops, best of 3: 53.8 usec per loop\n    \u279c  scim2-filter-parser git:(master) \u2717 python -m timeit -s \"import speed_test\" \"speed_test.long()\"\n    1000 loops, best of 3: 273 usec per loop\n\ndevelopment speed\n-----------------\n\nsince this project is relatively stable, time is only dedicated to it on\nfridays. thus if you issue a pr, bug, etc, please note that it may take a week\nbefore we get back to you. thanks you for your patience.\n\ndevelopment\n-----------\n\nthis project uses poetry to manage dependencies, etc. thus to install the\nnecessary tools when developing, run:\n\n::\n\n    poetry install -v --extras \"django-query\"\n\ntests\n-----\n\n.. |tests| image:: https://github.com/15five/scim2-filter-parser/workflows/ci%2fcd/badge.svg\n    :target: https://github.com/15five/scim2-filter-parser/actions\n\nhttps://github.com/15five/scim2-filter-parser/actions\n\ntests are typically run locally with `tox` (https://tox.wiki/). tox will test\nall supported versions of python.\n\n```\ntox\n```\n\nto run the test suite with a single version of python (the version you created\nthe virtualenv with), run:\n\n::\n\n    poetry run pytest tests/\n\ncoverage\n--------\n\n.. |coverage| image:: https://codecov.io/gh/15five/scim2-filter-parser/graph/badge.svg\n    :target: https://codecov.io/gh/15five/scim2-filter-parser\n\nhttps://codecov.io/gh/15five/scim2-filter-parser\n\n::\n\n    tox -e coverage\n\n\ndeployment\n----------\n\nhttps://pypi.org/project/scim2-filter-parser/\n\nto deploy this package to pypi, run:\n\n::\n\n    poetry build\n    poetry publish\n",
  "docs_url": null,
  "keywords": "scim,scim2,2.0,filter",
  "license": "mit",
  "name": "scim2-filter-parser",
  "package_url": "https://pypi.org/project/scim2-filter-parser/",
  "project_url": "https://pypi.org/project/scim2-filter-parser/",
  "project_urls": {
    "Documentation": "https://scim2-filter-parser.readthedocs.io/en/stable/",
    "Homepage": "https://pypi.org/project/scim2-filter-parser/",
    "Repository": "https://github.com/15five/scim2-filter-parser"
  },
  "release_url": "https://pypi.org/project/scim2-filter-parser/0.5.0/",
  "requires_dist": [
    "sly (==0.5)",
    "django (>=3.2) ; extra == \"django-query\""
  ],
  "requires_python": ">=3.8",
  "summary": "a customizable parser/transpiler for scim2.0 filters.",
  "version": "0.5.0",
  "releases": [],
  "developers": [
    "paul.logston@gmail.com",
    "paul@15five.com",
    "paul_logston"
  ],
  "kwds": "scim2_filter_parser scim2 scim_query filter_ scim",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_scim2_filter_parser",
  "homepage": "https://pypi.org/project/scim2-filter-parser/",
  "release_count": 20,
  "dependency_ids": [
    "pypi_django",
    "pypi_sly"
  ]
}