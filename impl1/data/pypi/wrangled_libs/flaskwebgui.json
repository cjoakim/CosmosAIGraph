{
  "classifiers": [],
  "description": "# flaskwebgui\n  \n[![downloads](https://pepy.tech/badge/flaskwebgui)](https://pepy.tech/project/flaskwebgui)\n[![pypi](https://img.shields.io/pypi/v/flaskwebgui?color=blue)](https://pypi.org/project/flaskwebgui/)\n\ncreate desktop applications with flask/fastapi/django!\n\n## install\n\n``` py\npip install flaskwebgui\n```\nif you are using `conda` checkout [this link](https://github.com/conda-forge/flaskwebgui-feedstock).\n\n\n## usage with flask\n\nlet's say we have the following flask application:\n```py\n#main.py\n\nfrom flask import flask  \nfrom flask import render_template\nfrom flaskwebgui import flaskui # import flaskui\n\napp = flask(__name__)\n\n\n@app.route(\"/\")\ndef hello():  \n    return render_template('index.html')\n\n@app.route(\"/home\", methods=['get'])\ndef home(): \n    return render_template('some_page.html')\n\n\nif __name__ == \"__main__\":\n  # if you are debugging you can do that in the browser:\n  # app.run()\n  # if you want to view the flaskwebgui window:\n  flaskui(app=app, server=\"flask\").run()\n   \n```\n\ninstall [`waitress`](https://pypi.org/project/waitress/) for more performance.\n\n\n## usage with flask-socketio\n\nlet's say we have the following socketio application:\n```py\n#main.py\nfrom flask import flask, render_template\nfrom flask_socketio import socketio\nfrom flaskwebgui import flaskui\n\n\napp = flask(__name__)\napp.config['secret_key'] = 'secret!'\nsocketio = socketio(app)\n\n@app.route(\"/\")\ndef hello():  \n    return render_template('index.html')\n\n@app.route(\"/home\", methods=['get'])\ndef home(): \n    return render_template('some_page.html')\n\n\nif __name__ == '__main__':\n    # socketio.run(app) for development\n    flaskui(\n        app=app,\n        socketio=socketio,\n        server=\"flask_socketio\",\n        width=800,\n        height=600,\n    ).run()\n\n```\n\napp will be served by `flask_socketio`.\n\n\n## usage with fastapi\n\npretty much the same, below you have the `main.py` file:\n```py\n#main.py\nfrom fastapi import fastapi, request\nfrom fastapi.responses import htmlresponse\nfrom fastapi.staticfiles import staticfiles\nfrom fastapi.templating import jinja2templates\nfrom fastapi import fastapi\nfrom flaskwebgui import flaskui\n\napp = fastapi()\n\n# mounting default static files\napp.mount(\"/public\", staticfiles(directory=\"dist/\"))\ntemplates = jinja2templates(directory=\"dist\")\n\n\n@app.get(\"/\", response_class=htmlresponse)\nasync def root(request: request):\n    return templates.templateresponse(\"index.html\", {\"request\": request})\n\n\n@app.get(\"/home\", response_class=htmlresponse)\nasync def home(request: request): \n    return templates.templateresponse(\"some_page.html\", {\"request\": request})\n\n\nif __name__ == \"__main__\":\n    \n    flaskui(app=app, server=\"fastapi\").run()\n\n```\n\nfastapi will be served by `uvicorn`.  \n\n\n## usage with django\n\nnext to `manage.py` file create a `gui.py` file where you need to import `application` from project's `wsgi.py` file.\n\n```bash\n\u251c\u2500\u2500 project_name\n\u2502   \u251c\u2500\u2500 asgi.py\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u251c\u2500\u2500 urls.py\n\u2502   \u2514\u2500\u2500 wsgi.py\n\u251c\u2500\u2500 gui.py # this \n\u251c\u2500\u2500 manage.py\n```\n\nin `gui.py` file add below code.\n\n```py\n#gui.py\nfrom flaskwebgui import flaskui\nfrom djangodesktop.wsgi import application as app\n\nif __name__ == \"__main__\":\n    flaskui(app=app, server=\"django\").run()\n\n```\nnext start the application with:\n```py\npython gui.py  \n```\n\ninstall `waitress` for more performance.\n\n\n## close application using a route\n\nyou can close the application using the `close_application` from flaskwebgui. please note that this requires installing `pyautogui` package.\n\n\n```python\n\nfrom flaskwebgui import flaskui, close_application\n\n# any python webframework routing here\n\n@app.route(\"/close\", methods=[\"get\"])\ndef close_window():\n    close_application()\n\n```\n\nand somewhere a link: \n\n```html\n\n<a href=\"/close\" class=\"exit\" role=\"button\">\n    close\n</a>\n\n```\n\nwhen `close_application` is called `ctrl+w` keystrokes are pressed to close the chrome window and the current python process is killed. this hacky implemantation does the job. feel free to open a pr for a cleaner cross platform alternative.\n\n\n## configurations\n\ndefault flaskui class parameters:\n\n- `server: union[str, callable[[any], none]]`: function which receives `server_kwargs` to start server (see examples folder);\n- `server_kwargs: dict = none`: kwargs which will be passed down to `server` function;\n- `app: any = none`: `wsgi` or `asgi` app;\n- `port: int = none`: specify port if not a free port will set;\n- `width: int = none`: width of the window;\n- `height: int = none`: height of the window;\n- `fullscreen: bool = true`: start app in fullscreen (maximized);\n- `on_startup: callable = none`: function to before starting the browser and webserver;\n- `on_shutdown: callable = none`: function to after the browser and webserver shutdown;\n- `browser_path: str = none`: set path to chrome executable or let the defaults do that;\n- `browser_command: list[str] = none`: command line with starts chrome in `app` mode;\n- `socketio: any = none`: socketio instance in case of flask_socketio;\n\ndevelop your app as you would normally do, add flaskwebgui at the end or for tests.\n**flaskwebgui doesn't interfere with your way of doing an application** it just helps converting it into a desktop app more easily with pyinstaller or [pyvan](https://github.com/climentea/pyvan).\n\n\n## advanced usage\n\nyou can plug in any python webframework you want just by providing a function to start the server in `server` flaskui parameter which will be feed `server_kwargs`.\n\nexample:\n\n```python\n\n# until here is the flask example from above\n\ndef start_flask(**server_kwargs):\n\n    app = server_kwargs.pop(\"app\", none)\n    server_kwargs.pop(\"debug\", none)\n\n    try:\n        import waitress\n\n        waitress.serve(app, **server_kwargs)\n    except:\n        app.run(**server_kwargs)\n\n\nif __name__ == \"__main__\":\n\n    # custom start flask\n\n    def saybye():\n        print(\"on_exit bye\")\n\n    flaskui(\n        server=start_flask,\n        server_kwargs={\n            \"app\": app,\n            \"port\": 3000,\n            \"threaded\": true,\n        },\n        width=800,\n        height=600,\n        on_shutdown=saybye,\n    ).run()\n\n```\nin this way any webframework can be plugged in and the webframework can be started in a more customized manner.\n\nhere is another example with the `nicegui` package:\n\n```python\n\nfrom flaskwebgui import flaskui\nfrom nicegui import ui\n\nui.label(\"hello super nicegui!\")\nui.button(\"button\", on_click=lambda: ui.notify(\"button was pressed\"))\n\ndef start_nicegui(**kwargs):\n    ui.run(**kwargs)\n\nif __name__ in {\"__main__\", \"__mp_main__\"}:\n    debug = false\n\n    if debug:\n        ui.run()\n    else:\n        flaskui(\n            server=start_nicegui,\n            server_kwargs={\"dark\": true, \"reload\": false, \"show\": false, \"port\": 3000},\n            width=800,\n            height=600,\n        ).run()\n\n```\n\ncheckout `examples` for more information.\n\n\n## distribution\n\nyou can distribute it as a standalone desktop app with **pyinstaller** or [**pyvan**](https://github.com/climentea/pyvan).\nif pyinstaller failes try pyinstaller version 5.6.2.\n\n\n## observations\n\n- parameters `width`, `height` and maybe `fullscreen` may not work on mac;\n- window control is limited to width, height, fullscreen;\n- remember the gui is still a browser - pressing f5 will refresh the page + other browser specific things (you can hack it with js though);\n- you don't need production level setup with gunicorn etc - you just have one user to serve;\n- if you want to debug/reload features - just run it as you would normally do with `app.run(**etc)`, `uvicorn.run(**etc)`, `python manage.py runserver` etc. flaskwebgui does not provide auto-reload you already have it in the webframework you are using;\n\n\n\n## credits\nit's a combination of https://github.com/widdershin/flask-desktop and https://github.com/chrisknott/eel\n\nit has some advantages over flask-desktop because it doesn't use pyqt5, so you won't have any issues regarding licensing and over eel because you don't need to learn any logic other than flask/django/fastapi/etc.\n\n**submit any questions/issues you have! fell free to fork it and improve it!**\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "flaskwebgui",
  "package_url": "https://pypi.org/project/flaskwebgui/",
  "project_url": "https://pypi.org/project/flaskwebgui/",
  "project_urls": {
    "Homepage": "https://github.com/ClimenteA/flaskwebgui"
  },
  "release_url": "https://pypi.org/project/flaskwebgui/1.0.8/",
  "requires_dist": [
    "psutil ~=5.9"
  ],
  "requires_python": "",
  "summary": "create desktop applications with flask/django/fastapi!",
  "version": "1.0.8",
  "releases": [],
  "developers": [
    "climente.alin@gmail.com",
    "climente_alin"
  ],
  "kwds": "flaskwebgui start_flask flaskui flask flask_socketio",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_flaskwebgui",
  "homepage": "https://github.com/climentea/flaskwebgui",
  "release_count": 30,
  "dependency_ids": [
    "pypi_psutil"
  ]
}