{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# python-inject [![build status](https://travis-ci.org/ivankorobkov/python-inject.svg?branch=master)](https://travis-ci.org/ivankorobkov/python-inject)\ndependency injection the python way, the good way.\n\n## key features\n* fast.\n* thread-safe.\n* simple to use.\n* does not steal class constructors.\n* does not try to manage your application object graph.\n* transparently integrates into tests.\n* autoparams leveraging type annotations.\n* supports type hinting in python 3.5+.\n* supports python 3.9+ (`v5.*`), 3.5-3.8 (`v4.*`) and python 2.7\u20133.5 (`v3.*`).\n* supports context managers.\n\n## python support\n\n| python  | inject version |\n|---------|----------------|\n| 3.9+    | 5.0+           |\n| 3.6-3.8 | 4.1+, < 5.0    |\n| 3.5     | 4.0            |\n| < 3.5   | 3.*            |\n\n\n## installation\nuse pip to install the lastest version:\n\n```bash\npip install inject\n```\n\n## autoparams example\n`@inject.autoparams` returns a decorator which automatically injects arguments into a function \nthat uses type annotations. this is supported only in python >= 3.5.\n\n```python\n@inject.autoparams()\ndef refresh_cache(cache: rediscache, db: dbinterface):\n    pass\n```\n\nthere is an option to specify which arguments we want to inject without attempts of \ninjecting everything:\n\n```python\n@inject.autoparams('cache', 'db')\ndef sign_up(name, email, cache: rediscache, db: dbinterface):\n    pass\n```\n\n## step-by-step example\n```python\n# import the inject module.\nimport inject\n\n\n# `inject.instance` requests dependencies from the injector.\ndef foo(bar):\n    cache = inject.instance(cache)\n    cache.save('bar', bar)\n\n\n# `inject.params` injects dependencies as keyword arguments or positional argument. \n# also you can use @inject.autoparams in python 3.5, see the example above.\n@inject.params(cache=cache, user=currentuser)\ndef baz(foo, cache=none, user=none):\n    cache.save('foo', foo, user)\n\n# this can be called in different ways:\n# with injected arguments\nbaz('foo')\n\n# with positional arguments\nbaz('foo', my_cache)\n\n# with keyword arguments\nbaz('foo', my_cache, user=current_user)\n\n\n# `inject.param` is deprecated, use `inject.params` instead.\n@inject.param('cache', cache)\ndef bar(foo, cache=none):\n    cache.save('foo', foo)\n\n\n# `inject.attr` creates properties (descriptors) which request dependencies on access.\nclass user(object):\n    cache = inject.attr(cache)\n            \n    def __init__(self, id):\n        self.id = id\n\n    def save(self):\n        self.cache.save('users', self)\n    \n    @classmethod\n    def load(cls, id):\n        return cls.cache.load('users', id)\n\n\n# create an optional configuration.\ndef my_config(binder):\n    binder.bind(cache, rediscache('localhost:1234'))\n\n# configure a shared injector.\ninject.configure(my_config)\n\n\n# instantiate user as a normal class. its `cache` dependency is injected when accessed.\nuser = user(10)\nuser.save()\n\n# call the functions, the dependencies are automatically injected.\nfoo('hello')\nbar('world')\n```\n\n\n## context managers\nbinding a class to an instance of a context manager (through `bind` or `bind_to_constructor`) \nor to a function decorated as a context manager leads to the context manager to be used as is, \nnot via with statement.\n\n```python\n@contextlib.contextmanager\ndef get_file_sync():\n    obj = mockfiel()\n    yield obj\n    obj.destroy()\n\n@contextlib.asynccontextmanager\nasync def get_conn_async():\n    obj = mockconnection()\n    yield obj\n    obj.destroy()\n\ndef config(binder):\n    binder.bind_to_provider(mockfile, get_file_sync)\n    binder.bind(int, 100)\n    binder.bind_to_provider(str, lambda: \"hello\")\n    binder.bind_to_provider(mockconnection, get_conn_sync)\n\n    inject.configure(config)\n\n@inject.autoparams()\ndef example(conn: mockconnection, file: mockfile):\n    # connection and file will be automatically destroyed on exit.\n    pass\n```\n\n\n## usage with django\ndjango can load some modules multiple times which can lead to \n`injectorexception: injector is already configured`. you can use `configure(once=true)` which\nis guaranteed to run only once when the injector is absent:\n```python\nimport inject\ninject.configure(my_config, once=true)\n```\n\n## testing\nin tests use `inject.configure(callable, clear=true)` to create a new injector on setup,\nand optionally `inject.clear()` to clean up on tear down:\n```python\nclass mytest(unittest.testcase):\n    def setup(self):\n        inject.configure(lambda binder: binder\n            .bind(cache, mockcache()) \\\n            .bind(validator, testvalidator()),\n            clear=true)\n    \n    def teardown(self):\n        inject.clear()\n```\n\n## composable configurations\nyou can reuse configurations and override already registered dependencies to fit the needs \nin different environments or specific tests.\n```python\n    def base_config(binder):\n        # ... more dependencies registered here\n        binder.bind(validator, realvalidator())\n        binder.bind(cache, rediscache('localhost:1234'))\n\n    def tests_config(binder):\n        # reuse existing configuration\n        binder.install(base_config)\n\n        # override only certain dependencies\n        binder.bind(validator, testvalidator())\n        binder.bind(cache, mockcache())\n    \n    inject.configure(tests_config, allow_override=true, clear=true)\n        \n```\n\n## thread-safety\nafter configuration the injector is thread-safe and can be safely reused by multiple threads.\n\n## binding types\n**instance** bindings always return the same instance:\n\n```python\nredis = rediscache(address='localhost:1234')\ndef config(binder):\n    binder.bind(cache, redis)\n```\n    \n**constructor** bindings create a singleton on injection:\n\n```python\ndef config(binder):\n    # creates a redis cache singleton on first injection.\n    binder.bind_to_constructor(cache, lambda: rediscache(address='localhost:1234'))\n```\n\n**provider** bindings call the provider on injection:\n\n```python\ndef get_my_thread_local_cache():\n    pass\n\ndef config(binder):\n    # executes the provider on each injection.\n    binder.bind_to_provider(cache, get_my_thread_local_cache) \n```\n\n**runtime** bindings automatically create singletons on injection, require no configuration.\nfor example, only the `config` class binding is present, other bindings are runtime:\n\n```python\nclass config(object):\n    pass\n\nclass cache(object):\n    config = inject.attr(config)\n\nclass db(object):\n    config = inject.attr(config)\n\nclass user(object):\n    cache = inject.attr(cache)\n    db = inject.attr(db)\n    \n    @classmethod\n    def load(cls, user_id):\n        return cls.cache.load('users', user_id) or cls.db.load('users', user_id)\n    \ninject.configure(lambda binder: binder.bind(config, load_config_file()))\nuser = user.load(10)\n```\n## disabling runtime binding\nsometimes runtime binding leads to unexpected behaviour.  say if you forget\nto bind an instance to a class, `inject` will try to implicitly instantiate it.\n\nif an instance is unintentionally created with default arguments it may lead to\nhard-to-debug bugs.  to disable runtime binding and make sure that only \nexplicitly bound instances are injected, pass `bind_in_runtime=false` to `inject.configure`.\n\nin this case `inject` immediately raises `injectorexception` when the code\ntries to get an unbound instance.\n\n## keys\nit is possible to use any hashable object as a binding key. for example:\n\n```python\nimport inject\n\ninject.configure(lambda binder: \\\n    binder.bind('host', 'localhost') \\\n    binder.bind('port', 1234))\n```\n\n## why no scopes?\ni've used guice and spring in java for a lot of years, and i don't like their scopes.\n`python-inject` by default creates objects as singletons. it does not need a prototype scope\nas in spring or no_scope as in guice because `python-inject` does not steal your class \nconstructors. create instances the way you like and then inject dependencies into them.\n\nother scopes such as a request scope or a session scope are fragile, introduce high coupling,\nand are difficult to test. in `python-inject` write custom providers which can be thread-local, \nrequest-local, etc.\n\nfor example, a thread-local current user provider:\n\n```python\nimport inject\nimport threading\n\n# given a user class.\nclass user(object):\n    pass\n\n# create a thread-local current user storage.\n_local = threading.local()\n\ndef get_current_user():\n    return getattr(_local, 'user', none)\n\ndef set_current_user(user):\n    _local.user = user\n\n# bind user to a custom provider.\ninject.configure(lambda binder: binder.bind_to_provider(user, get_current_user))\n\n# inject the current user.\n@inject.params(user=user)\ndef foo(user):\n    pass\n```\n\n## links\n* project: https://github.com/ivankorobkov/python-inject\n\n## license\napache license 2.0\n\n## contributors\n* ivan korobkov [@ivankorobkov](https://github.com/ivankorobkov)\n* jaime wyant [@jaimewyant](https://github.com/jaimewyant)\n* sebastian buczy\u0144ski [@enforcer](https://github.com/enforcer)\n* oleksandr fedorov [@fedorof](https://github.com/fedorof)\n* cselvaraj [@cselvaraj](https://github.com/cselvaraj)\n* \u9646\u96e8\u6674 [@sixextreme](https://github.com/sixextreme)\n* andrew william borba [@andrewborba10](https://github.com/andrewborba10)\n* jdmeyer3 [@jdmeyer3](https://github.com/jdmeyer3)\n* alex grover [@ajgrover](https://github.com/ajgrover)\n* harro van der kroft [@wisepotato](https://github.com/wisepotato)\n* samiur rahman [@samiur](https://github.com/samiur)\n* 45deg [@45deg](https://github.com/45deg)\n* alexander nicholas costas [@ancostas](https://github.com/ancostas)\n* dmitry balabka [@dbalabka](https://github.com/dbalabka)\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "inject",
  "package_url": "https://pypi.org/project/inject/",
  "project_url": "https://pypi.org/project/inject/",
  "project_urls": {
    "Homepage": "https://github.com/ivankorobkov/python-inject"
  },
  "release_url": "https://pypi.org/project/inject/5.2.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python dependency injection framework.",
  "version": "5.2.0",
  "releases": [],
  "developers": [
    "ivan.korobkov@gmail.com"
  ],
  "kwds": "contextlib python dependencies injecting dependency",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_inject",
  "homepage": "",
  "release_count": 26,
  "dependency_ids": []
}