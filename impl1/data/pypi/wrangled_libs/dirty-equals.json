{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "environment :: macos x",
    "framework :: pytest",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: information technology",
    "intended audience :: science/research",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "operating system :: posix :: linux",
    "operating system :: unix",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet",
    "topic :: software development :: libraries :: python modules",
    "typing :: typed"
  ],
  "description": "<p align=\"center\">\n  <a href=\"https://dirty-equals.helpmanual.io\">\n    <img src=\"https://dirty-equals.helpmanual.io/latest/img/logo-text.svg\" alt=\"dirty-equals\">\n  </a>\n</p>\n<p align=\"center\">\n  <em>doing dirty (but extremely useful) things with equals.</em>\n</p>\n<p align=\"center\">\n  <a href=\"https://github.com/samuelcolvin/dirty-equals/actions?query=event%3apush+branch%3amain+workflow%3aci\">\n    <img src=\"https://github.com/samuelcolvin/dirty-equals/workflows/ci/badge.svg?event=push\" alt=\"ci\">\n  </a>\n  <a href=\"https://codecov.io/gh/samuelcolvin/dirty-equals\">\n    <img src=\"https://codecov.io/gh/samuelcolvin/dirty-equals/branch/main/graph/badge.svg\" alt=\"coverage\">\n  </a>\n  <a href=\"https://pypi.python.org/pypi/dirty-equals\">\n    <img src=\"https://img.shields.io/pypi/v/dirty-equals.svg\" alt=\"pypi\">\n  </a>\n  <a href=\"https://github.com/samuelcolvin/dirty-equals\">\n    <img src=\"https://img.shields.io/pypi/pyversions/dirty-equals.svg\" alt=\"versions\">\n  </a>\n  <a href=\"https://github.com/samuelcolvin/dirty-equals/blob/main/license\">\n    <img src=\"https://img.shields.io/github/license/samuelcolvin/dirty-equals.svg\" alt=\"license\">\n  </a>\n</p>\n\n---\n\n**documentation**: [dirty-equals.helpmanual.io](https://dirty-equals.helpmanual.io)\n\n**source code**: [github.com/samuelcolvin/dirty-equals](https://github.com/samuelcolvin/dirty-equals)\n\n---\n\n**dirty-equals** is a python library that (mis)uses the `__eq__` method to make python code (generally unit tests)\nmore declarative and therefore easier to read and write.\n\n*dirty-equals* can be used in whatever context you like, but it comes into its own when writing unit tests for\napplications where you're commonly checking the response to api calls and the contents of a database.\n\n## usage\n\nhere's a trivial example of what *dirty-equals* can do:\n\n```py\nfrom dirty_equals import ispositive\n\nassert 1 == ispositive\nassert -2 == ispositive  # this will fail!\n```\n\n**that doesn't look very useful yet!**, but consider the following unit test code using *dirty-equals*:\n\n```py title=\"more powerful usage\"\nfrom dirty_equals import isjson, isnow, ispositiveint, isstr\n\n...\n\n# user_data is a dict returned from a database or api which we want to test\nassert user_data == {\n    # we want to check that id is a positive int\n    'id': ispositiveint,\n    # we know avatar_file should be a string, but we need a regex as we don't know whole value\n    'avatar_file': isstr(regex=r'/[a-z0-9\\-]{10}/example\\.png'),\n    # settings_json is json, but it's more robust to compare the value it encodes, not strings\n    'settings_json': isjson({'theme': 'dark', 'language': 'en'}),\n    # created_ts is datetime, we don't know the exact value, but we know it should be close to now\n    'created_ts': isnow(delta=3),\n}\n```\n\nwithout *dirty-equals*, you'd have to compare individual fields and/or modify some fields before comparison -\nthe test would not be declarative or as clear.\n\n*dirty-equals* can do so much more than that, for example:\n\n* [`ispartialdict`](https://dirty-equals.helpmanual.io/types/dict/#dirty_equals.ispartialdict)\n  lets you compare a subset of a dictionary\n* [`isstrictdict`](https://dirty-equals.helpmanual.io/types/dict/#dirty_equals.isstrictdict)\n  lets you confirm order in a dictionary\n* [`islist`](https://dirty-equals.helpmanual.io/types/sequence/#dirty_equals.islist) and\n  [`istuple`](https://dirty-equals.helpmanual.io/types/sequence/#dirty_equals.istuple)\n  lets you compare partial lists and tuples, with or without order constraints\n* nesting any of these types inside any others\n* [`isinstance`](https://dirty-equals.helpmanual.io/types/other/#dirty_equals.isinstance)\n  lets you simply confirm the type of an object\n* you can even use [boolean operators](https://dirty-equals.helpmanual.io/usage/#boolean-logic)\n  `|` and `&` to combine multiple conditions\n* and much more...\n\n## installation\n\nsimply:\n\n```bash\npip install dirty-equals\n```\n\n**dirty-equals** requires **python 3.7+**.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "dirty-equals",
  "package_url": "https://pypi.org/project/dirty-equals/",
  "project_url": "https://pypi.org/project/dirty-equals/",
  "project_urls": {
    "Changelog": "https://github.com/samuelcolvin/dirty-equals/releases",
    "Documentation": "https://dirty-equals.helpmanual.io",
    "Funding": "https://github.com/sponsors/samuelcolvin",
    "Homepage": "https://github.com/samuelcolvin/dirty-equals",
    "Source": "https://github.com/samuelcolvin/dirty-equals"
  },
  "release_url": "https://pypi.org/project/dirty-equals/0.7.1.post0/",
  "requires_dist": [
    "pytz>=2021.3",
    "pydantic>=2.4.2; extra == 'pydantic'"
  ],
  "requires_python": ">=3.7",
  "summary": "doing dirty (but extremely useful) things with equals.",
  "version": "0.7.1.post0",
  "releases": [],
  "developers": [
    "s@muelcolvin.com"
  ],
  "kwds": "dirty_equals href align logo equals",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_dirty_equals",
  "homepage": "",
  "release_count": 15,
  "dependency_ids": [
    "pypi_pydantic",
    "pypi_pytz"
  ]
}