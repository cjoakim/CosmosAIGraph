{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6"
  ],
  "description": "avro-gen\r\n========\r\n\r\n[![build status](https://travis-ci.org/rbystrit/avro_gen.svg?branch=master)](https://travis-ci.org/rbystrit/avro_gen)\r\n[![codecov](https://codecov.io/gh/rbystrit/avro_gen/branch/master/graph/badge.svg)](https://codecov.io/gh/rbystrit/avro_gen)\r\n##### avro record class and specific record reader generator.\r\n\r\ncurrent avro implementation in python is completely typelss and operates on dicts. \r\nwhile in many cases this is convenient and pythonic, not being able to discover the schema\r\nby looking at the code, not enforcing schema during record constructions, and not having any \r\ncontext help from the ide could hamper developer performance and introduce bugs. \r\n\r\nthis project aims to rectify this situation by providing a generator for constructing concrete\r\nrecord classes and constructing a reader which wraps avro datumreader and returns concrete classes\r\ninstead of dicts. in order not to violate avro internals, this functionality is built strictly\r\non top of the datumreader and all the specific record classes dict wrappers which define accessor\r\nproperties with proper type hints for each field in the schema. for this exact reason the \r\ngenerator does not provide an overloaded dictwriter; each specific record appears just to be a \r\nregular dictionary.\r\n \r\n##### usage:\r\n    schema_json = \".....\"\r\n    output_directory = \".....\"\r\n    from avrogen import write_schema_files\r\n    \r\n    write_schema_files(schema_json, output_directory)\r\n    \r\nthe generator will create output directory if it does not exist and put generated files there. \r\nthe generated files will be:\r\n\r\n>  output_dir\r\n>  + \\_\\_init\\_\\_.py   \r\n>  + schema_classes.py \r\n>  + submodules*\r\n \r\nin order to deal with avro namespaces, since python doesn't support circular imports, the generator\r\n will emit all records into schema_classes.py as nested classes. the top level class there will be\r\n schemaclasses, whose children will be classes representing namespaces. each namespace class will \r\n in turn contain classes for records belonging to that namespace. \r\n \r\n consider following schema:\r\n \r\n     {\"type\": \"record\", \"name\": \"tweet\", \"namespace\": \"com.twitter.avro\", \"fields\": [{\"name\": \"id\", \"type\": \"long\" }\r\n \r\n then schema_classes.py would contain:\r\n \r\n    class schemaclasses(object):\r\n        class com(object):\r\n            class twitter(object):\r\n                class acro(object):\r\n                    class tweetclass(dictwrapper):\r\n                        def __init__(self, inner_dict=none):\r\n                            ....\r\n                        @property\r\n                        def id(self):\r\n                            \"\"\"\r\n                            :rtype: long\r\n                            \"\"\"\r\n                            return self._inner_dict.get('id', none)\r\n                        \r\n                        @id.setter\r\n                        def id(self, value):\r\n                            #\"\"\"\r\n                            #:param long value:\r\n                            #\"\"\"\r\n                            self._inner_dict['id'] = value                        \r\n    \r\n in order to map specific record types and namespaces to modules, so that proper importing can\r\n be supported, there generator will create a sub-module under the output directory for each namespace\r\n which will export names of all types contained in that namespace. types declared with empty \r\n namespace will be exported from the root module. \r\n \r\n so for the example above, output directory will look as follows:\r\n \r\n >  output_dir\r\n >  + \\_\\_init\\_\\_.py\r\n >  + schema_classes.py\r\n >  + com\r\n >   + twitter\r\n >     + avro\r\n >       + \\_\\_init\\_\\_.py  \r\n\r\nthe contents of output_dir/com/twitter/avro/\\_\\_init\\_\\_.py will be:\r\n    \r\n    from ....schema_classes import schemaclasses\r\n    tweet = schemaclasses.com.twitter.avro.tweet\r\n    \r\nso in your code you will be able to say:\r\n    \r\n    from output_dir.com.twitter.avro import tweet\r\n    from output_dir import specificdatumreader as tweetreader, schema as your_schema\r\n    from avro import datafile, io\r\n    my_tweet = tweet()\r\n    \r\n    my_tweet.id = 1\r\n    with open('somefile', 'w+b') as f:\r\n        writer = datafile.datafilewriter(f,io.datumwriter(), your_schema)\r\n        writer.append(my_tweet)\r\n        writer.close()\r\n    \r\n    with open('somefile', 'rb') as f:\r\n        reader = datafile.datafilereader(f,tweetreader(readers_schema=your_schema))\r\n        my_tweet1 = reader.next()\r\n        reader.close()\r\n        \r\n       \r\n### avro protocol support\r\n\r\navro protocol support is implemented the same way as schema support. to generate classes \r\nfor a protocol:\r\n\r\n    protocol_json = \".....\"\r\n    output_directory = \".....\"\r\n    from avrogen import write_protocol_files\r\n    \r\n    write_protocol_files(protocol_json, output_directory)\r\n    \r\nthe structure of the generated code will be exactly same as for schema, but in addition to\r\nregular types, *request types will be generated in the root namespace of the protocol for each \r\neach message defined.\r\n\r\n### logical types support\r\n\r\navrogen implements logical types on top of standard avro package and supports generation of \r\nclasses thus typed. to enable logical types support, pass **use_logical_types=true** to schema \r\nand protocol generators. if custom logical types are implemented and such types map to types \r\nother than simple types or datetime.* or decimal.* then pass **custom_imports** parameter to \r\ngenerator functions so that your types are imported. types implemented out of the box are:\r\n\r\n- decimal (using string representation only)\r\n- date\r\n- time-millis\r\n- time-micros\r\n- timestamp-millis\r\n- timestamp-micros\r\n\r\nto register your custom logical type, inherit from avrogen.logical.logicaltypeprocessor, implement\r\nabstract methods, and add an instance to avrogen.logical.default_logical_types dictionary under the \r\nname of your logical type. a sample implementation looks as follows:\r\n\r\n    class datelogicaltypeprocessor(logicaltypeprocessor):\r\n        _matching_types = {'int', 'long', 'float', 'double'}\r\n    \r\n        def can_convert(self, writers_schema):\r\n            return isinstance(writers_schema, schema.primitiveschema) and writers_schema.type == 'int'\r\n    \r\n        def validate(self, expected_schema, datum):\r\n            return isinstance(datum, datetime.date)\r\n    \r\n        def convert(self, writers_schema, value):\r\n            if not isinstance(value, datetime.date):\r\n                raise exception(\"wrong type for date conversion\")\r\n            return (value - epoch_date).total_seconds() // seconds_in_day\r\n    \r\n        def convert_back(self, writers_schema, readers_schema, value):\r\n            return epoch_date + datetime.timedelta(days=int(value))\r\n    \r\n        def does_match(self, writers_schema, readers_schema):\r\n            if isinstance(writers_schema, schema.primitiveschema):\r\n                if writers_schema.type in datelogicaltypeprocessor._matching_types:\r\n                    return true\r\n            return false\r\n    \r\n        def typename(self):\r\n            return 'datetime.date'\r\n    \r\n        def initializer(self, value=none):\r\n            return ((\r\n                        'logical.datelogicaltypeprocessor().convert_back(none, none, %s)' % value) if value is not none\r\n                    else 'datetime.datetime.today().date()')\r\n\r\n\r\nto read/write data with logical type support, use generated specificdatumreader \r\nand a logicaldatumwriter from avro.logical.\r\n \r\n\r\n\r\n\r\n    ",
  "docs_url": null,
  "keywords": "avro class generator",
  "license": "license :: osi approved :: apache software license",
  "name": "avro-gen",
  "package_url": "https://pypi.org/project/avro-gen/",
  "project_url": "https://pypi.org/project/avro-gen/",
  "project_urls": {
    "Homepage": "https://github.com/rbystrit/avro_gen"
  },
  "release_url": "https://pypi.org/project/avro-gen/0.3.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "avro record class and specific record reader generator",
  "version": "0.3.0",
  "releases": [],
  "developers": [
    "rbystrit@gmail.com",
    "roman_bystritskiy"
  ],
  "kwds": "avro_gen avro generators generator gen",
  "license_kwds": "license :: osi approved :: apache software license",
  "libtype": "pypi",
  "id": "pypi_avro_gen",
  "homepage": "https://github.com/rbystrit/avro_gen",
  "release_count": 11,
  "dependency_ids": []
}