{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu library or lesser general public license (lgpl)",
    "operating system :: os independent",
    "programming language :: python"
  ],
  "description": "..\n    this file is part of lazr.authentication.\n\n    lazr.authentication is free software: you can redistribute it and/or modify it\n    under the terms of the gnu lesser general public license as published by\n    the free software foundation, version 3 of the license.\n\n    lazr.authentication is distributed in the hope that it will be useful, but\n    without any warranty; without even the implied warranty of merchantability\n    or fitness for a particular purpose.  see the gnu lesser general public\n    license for more details.\n\n    you should have received a copy of the gnu lesser general public license\n    along with lazr.authentication.  if not, see <http://www.gnu.org/licenses/>.\n\nwsgi middleware\n===============\n\nlazr.authentication defines some simple wsgi middleware for protecting\nresources with different kinds of http authentication.\n\n    >>> from __future__ import print_function\n    >>> import lazr.authentication\n    >>> print('version: %s' % lazr.authentication.__version__)\n    version: ...\n\n\nbasicauthmiddleware\n-------------------\n\nthe basicauthmiddleware implements http basic auth. its constructor\ntakes a number of arguments, including a callback function that\nperforms the actual authentication. this function returns an object\nidentifying the user who's trying to authenticate. if the\nauthentication credentials are invalid, it's supposed to return none.\n\nfirst, let's create a really simple wsgi application that responds to\nany request with a 200 response code.\n\n    >>> def dummy_application(environ, start_response):\n    ...         start_response('200', [('content-type','text/plain')])\n    ...         return [b'success']\n\nnow let's protect that application. here's an authentication callback\nfunction.\n\n    >>> def authenticate(username, password):\n    ...     \"\"\"accepts \"user/password\", rejects everything else.\n    ...\n    ...     :return: the username, if the credentials are valid.\n    ...              none, otherwise.\n    ...     \"\"\"\n    ...     if username == \"user\" and password == \"password\":\n    ...         return username\n    ...     return none\n\n    >>> print(authenticate(\"user\", \"password\"))\n    user\n\n    >>> print(authenticate(\"notuser\", \"password\"))\n    none\n\nhere's a wsgi application that protects the application using\nbasicauthmiddleware.\n\n    >>> from lazr.authentication.wsgi import basicauthmiddleware\n    >>> def protected_application():\n    ...     return basicauthmiddleware(\n    ...         dummy_application, realm=\"wsgi middleware test\",\n    ...         protect_path_pattern=\".*protected.*\",\n    ...         authenticate_with=authenticate)\n\n    >>> import wsgi_intercept\n    >>> from wsgi_intercept.httplib2_intercept import install\n    >>> install()\n    >>> wsgi_intercept.add_wsgi_intercept(\n    ...     'basictest', 80, protected_application)\n\nmost of the application's urls are not protected by the\nmiddleware. you can access them without providing credentials.\n\n    >>> import httplib2\n    >>> client = httplib2.http()\n    >>> response, body = client.request('http://basictest/')\n    >>> print(response['status'])\n    200\n    >>> print(body.decode())\n    success\n\nany url that includes the string \"protected\" is protected by the\nmiddleware, and cannot be accessed without credentials.\n\n    >>> response, body = client.request('http://basictest/protected/')\n    >>> print(response['status'])\n    401\n    >>> print(response['www-authenticate'])\n    basic realm=\"wsgi middleware test\"\n\n    >>> response, body = client.request(\n    ...     'http://basictest/this-is-protected-as-well/')\n    >>> print(response['status'])\n    401\n\nthe check_credentials() implementation given at the beginning of the\ntest will only accept the user/password combination \"user\"/\"password\".\nprovide a bad username or password and you'll get a 401.\n\n    >>> client.add_credentials(\"baduser\", \"baspassword\")\n    >>> response, body = client.request('http://basictest/protected/')\n    >>> print(response['status'])\n    401\n\nprovide the correct credentials and you'll get a 200, even for the\nprotected uris.\n\n    >>> client.add_credentials(\"user\", \"password\")\n    >>> response, body = client.request('http://basictest/protected/')\n    >>> print(response['status'])\n    200\n\nteardown.\n\n    >>> wsgi_intercept.remove_wsgi_intercept('basictest', 80)\n\nstacking\n********\n\nbasicauthmiddleware instances can be stacked, each instance protecting\na different path pattern. here, we'll use stacking to protect\nthe two regexes \".*protected.*\" and \".*different.*\", without combining\nthem into one complex regex.\n\n    >>> def return_user_application(environ, start_response):\n    ...         start_response('200', [('content-type','text/plain')])\n    ...         return [str(environ['authenticated_user']).encode('utf-8')]\n\n    >>> def protected_application():\n    ...     protected = basicauthmiddleware(\n    ...         return_user_application, realm=\"wsgi middleware test\",\n    ...         protect_path_pattern=\".*protected.*\",\n    ...         authenticate_with=authenticate)\n    ...     return basicauthmiddleware(\n    ...         protected, realm=\"another middleware\",\n    ...         protect_path_pattern=\".*different.*\",\n    ...         authenticate_with=authenticate)\n\nsetup.\n\n    >>> wsgi_intercept.add_wsgi_intercept(\n    ...     'stacked', 80, protected_application)\n    >>> client = httplib2.http()\n\nboth path patterns are protected:\n\n    >>> response, body = client.request('http://stacked/protected')\n    >>> print(response['status'])\n    401\n    >>> response, body = client.request('http://stacked/different')\n    >>> print(response['status'])\n    401\n\nboth path patterns control respond to the same credentials.\n\n    >>> client.add_credentials(\"user\", \"password\")\n\n    >>> response, body = client.request('http://stacked/protected-resource')\n    >>> print(response['status'])\n    200\n    >>> print(body.decode())\n    user\n\n    >>> response, body = client.request('http://stacked/different-resource')\n    >>> print(response['status'])\n    200\n    >>> print(body.decode())\n    user\n\n    >>> wsgi_intercept.remove_wsgi_intercept('stacked', 80)\n\noauthmiddleware\n---------------\n\nthe oauthmiddleware implements section 7 (\"accessing protected\nresources\") of the oauth specification. that is, it makes sure that\nincoming consumer keys and access tokens pass some application-defined\ntest. it does not help you serve request tokens or exchange a request\ntoken for an access token.\n\nwe'll use oauthmiddleware to protect the same simple application we\nprotected earlier with basicauthmiddleware. but since we're using\noauth, we'll be checking a consumer key and access token, instead of a\nusername and password.\n\n    >>> from oauth.oauth import oauthconsumer, oauthtoken\n\n    >>> valid_consumer = oauthconsumer(\"consumer\", '')\n    >>> valid_token = oauthtoken(\"token\", \"secret\")\n\n    >>> def authenticate(consumer, token, parameters):\n    ...     \"\"\"accepts the valid consumer and token, rejects everything else.\n    ...\n    ...     :return: the consumer, if the credentials are valid.\n    ...              none, otherwise.\n    ...     \"\"\"\n    ...     if consumer == valid_consumer and token == valid_token:\n    ...         return consumer\n    ...     return none\n\n    >>> print(authenticate(valid_consumer, valid_token, none).key)\n    consumer\n\n    >>> invalid_consumer = oauthconsumer(\"other consumer\", '')\n    >>> print(authenticate(invalid_consumer, valid_token, none))\n    none\n\nto test the oauthmiddleware's security features, we'll also need to\ncreate a data store. in a real application the data store would\nprobably be a database containing the registered consumer keys and\ntokens. we're using a simple data store designed for testing, and\ntelling it about the one valid consumer and token.\n\n    >>> from lazr.authentication.testing.oauth import simpleoauthdatastore\n    >>> data_store = simpleoauthdatastore(\n    ...     {valid_consumer.key : valid_consumer},\n    ...     {valid_token.key : valid_token})\n\n    >>> print(data_store.lookup_consumer(\"consumer\").key)\n    consumer\n    >>> print(data_store.lookup_consumer(\"badconsumer\"))\n    none\n\nthe data store tracks the use of oauth nonces. if you call the data\nstore's lookup_nonce() twice with the same values, the first call will\nreturn false and the second call will return true.\n\n    >>> print(data_store.lookup_nonce(\"consumer\", \"token\", \"nonce\"))\n    false\n    >>> print(data_store.lookup_nonce(\"consumer\", \"token\", \"nonce\"))\n    true\n\n    >>> print(data_store.lookup_nonce(\"newconsumer\", \"token\", \"nonce\"))\n    false\n\nnow let's protect an application with lazr.authenticate's\noauthmiddleware, using our authentication technique and our simple\ndata store.\n\n    >>> from lazr.authentication.wsgi import oauthmiddleware\n    >>> def protected_application():\n    ...     return oauthmiddleware(\n    ...         dummy_application, realm=\"oauth test\",\n    ...         authenticate_with=authenticate, data_store=data_store)\n\n    >>> wsgi_intercept.add_wsgi_intercept(\n    ...     'oauthtest', 80, protected_application)\n    >>> client = httplib2.http()\n\na properly signed request will go through to the underlying wsgi\napplication.\n\n    >>> from oauth.oauth import (\n    ...     oauthrequest, oauthsignaturemethod_plaintext)\n    >>> def sign_request(url, consumer=valid_consumer, token=valid_token):\n    ...     request = oauthrequest().from_consumer_and_token(\n    ...         consumer, token, http_url=url)\n    ...     request.sign_request(\n    ...         oauthsignaturemethod_plaintext(), consumer, token)\n    ...     headers = request.to_header('oauth test')\n    ...     return headers\n\n    >>> url = 'http://oauthtest/'\n    >>> headers = sign_request(url)\n    >>> response, body = client.request(url, headers=headers)\n    >>> print(response['status'])\n    200\n    >>> print(body.decode())\n    success\n\nif you replay a signed http request that worked the first time, it\nwill fail the second time, because you'll be sending a nonce that was\nalready used.\n\n    >>> response, body = client.request(url, headers=headers)\n    >>> print(response['status'])\n    401\n\nan unsigned request will fail.\n\n    >>> response, body = client.request('http://oauthtest/')\n    >>> print(response['status'])\n    401\n    >>> print(response['www-authenticate'])\n    oauth realm=\"oauth test\"\n\na request signed with invalid credentials will fail.\n\n    >>> bad_token = oauthtoken(\"token\", \"badsecret\")\n    >>> headers = sign_request(url, token=bad_token)\n    >>> response, body = client.request(url, headers=headers)\n    >>> print(response['status'])\n    401\n\nteardown.\n\n    >>> wsgi_intercept.remove_wsgi_intercept('oauthtest', 80)\n\n============================\nnews for lazr.authentication\n============================\n\n0.1.3 (2014-11-08)\n==================\n\n- provide python 3 support.\n- fix wsgi compatibility bug.\n\n0.1.2 (2010-02-09)\n==================\n\n- fixed a bug that prevented middleware instances from stacking.\n\n0.1.1 (2009-10-19)\n==================\n\n- fixed a bug that caused the oauth middleware to specify the\n  authentication realm as basic.\n\n0.1.0 (2009-10-07)\n==================\n\n- initial release",
  "docs_url": null,
  "keywords": "",
  "license": "lgpl v3",
  "name": "lazr.authentication",
  "package_url": "https://pypi.org/project/lazr.authentication/",
  "project_url": "https://pypi.org/project/lazr.authentication/",
  "project_urls": {
    "Download": "https://launchpad.net/lazr.authentication/+download",
    "Homepage": "https://launchpad.net/lazr.authentication"
  },
  "release_url": "https://pypi.org/project/lazr.authentication/0.1.3/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "this is a template for your lazr package.  to start your own lazr package,",
  "version": "0.1.3",
  "releases": [],
  "developers": [
    "lazr-developers@lists.launchpad.net",
    "lazr_developers"
  ],
  "kwds": "authenticate_with wsgi_intercept add_wsgi_intercept check_credentials remove_wsgi_intercept",
  "license_kwds": "lgpl v3",
  "libtype": "pypi",
  "id": "pypi_lazr.authentication",
  "homepage": "https://launchpad.net/lazr.authentication",
  "release_count": 4,
  "dependency_ids": []
}