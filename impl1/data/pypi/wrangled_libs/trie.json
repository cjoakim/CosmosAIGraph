{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# python implementation of the ethereum trie structure\n\n[![join the conversation on discord](https://img.shields.io/discord/809793915578089484?color=blue&label=chat&logo=discord&logocolor=white)](https://discord.gg/ghryrvpb84)\n[![build status](https://circleci.com/gh/ethereum/py-trie.svg?style=shield)](https://circleci.com/gh/ethereum/py-trie)\n[![pypi version](https://badge.fury.io/py/trie.svg)](https://badge.fury.io/py/trie)\n[![python versions](https://img.shields.io/pypi/pyversions/trie.svg)](https://pypi.python.org/pypi/trie)\n\n> this library and repository was previously located at [pipermerriam/py-trie](https://github.com/pipermerriam/py-trie). it was transferred to the ethereum foundation github in\n> november 2017 and renamed to `py-trie`.\n\n## installation\n\n```sh\npython -m pip install trie\n```\n\n## developer setup\n\nif you would like to hack on py-trie, please check out the [snake charmers\ntactical manual](https://github.com/ethereum/snake-charmers-tactical-manual)\nfor information on how we do:\n\n- testing\n- pull requests\n- documentation\n\nwe use [pre-commit](https://pre-commit.com/) to maintain consistent code style. once\ninstalled, it will run automatically with every commit. you can also run it manually\nwith `make lint`. if you need to make a commit that skips the `pre-commit` checks, you\ncan do so with `git commit --no-verify`.\n\n### development environment setup\n\nyou can set up your dev environment with:\n\n```sh\ngit clone git@github.com:ethereum/py-trie.git\ncd py-trie\nvirtualenv -p python3 venv\n. venv/bin/activate\npython -m pip install -e \".[dev]\"\npre-commit install\n```\n\n## running the tests\n\nyou can run the tests with:\n\n```sh\ngit submodule update --init --recursive\npytest tests\n```\n\n### release setup\n\nto release a new version:\n\n```sh\nmake release bump=$$version_part_to_bump$$\n```\n\n#### how to bumpversion\n\nthe version format for this repo is `{major}.{minor}.{patch}` for stable, and\n`{major}.{minor}.{patch}-{stage}.{devnum}` for unstable (`stage` can be alpha or beta).\n\nto issue the next version in line, specify which part to bump,\nlike `make release bump=minor` or `make release bump=devnum`. this is typically done from the\nmain branch, except when releasing a beta (in which case the beta is released from main,\nand the previous stable branch is released from said branch).\n\nif you are in a beta version, `bumpversion stage` will switch to a stable.\n\nto issue an unstable version when the current version is stable, specify the\nnew version explicitly, like `bumpversion --new-version 4.0.0-alpha.1 devnum`\n\n## usage\n\n```python\n>>> from trie import hexarytrie\n>>> t = hexarytrie(db={})\n>>> t.root_hash\nb'v\\xe8\\x1f\\x17\\x1b\\xccu\\xa6\\xff\\x83e\\xe6\\x92\\xc0\\xf8n[h\\xe0\\x1b\\x99l\\xad\\xc0\\x01b/\\xb5\\xe3c\\xb4!'\n>>> t.set(b'my-key', b'some-value')\n>>> t.get(b'my-key')\nb'some-value'\n>>> t.exists(b'another-key')\nfalse\n>>> t.set(b'another-key', b'another-value')\n>>> t.exists(b'another-key')\ntrue\n>>> t.delete(b'another-key')\n>>> t.exists(b'another-key')\nfalse\n```\n\nyou can also use it like a dictionary.\n\n```python\n>>> from trie import hexarytrie\n>>> t = hexarytrie(db={})\n>>> t.root_hash\nb'v\\xe8\\x1f\\x17\\x1b\\xccu\\xa6\\xff\\x83e\\xe6\\x92\\xc0\\xf8n[h\\xe0\\x1b\\x99l\\xad\\xc0\\x01b/\\xb5\\xe3c\\xb4!'\n>>> t[b'my-key'] = b'some-value'\n>>> t[b'my-key']\nb'some-value'\n>>> b'another-key' in t\nfalse\n>>> t[b'another-key']  = b'another-value'\n>>> b'another-key' in t\ntrue\n>>> del t[b'another-key']\n>>> b'another-key' in t\nfalse\n```\n\n### traversing (inspecting trie internals)\n\n```python\n>>> from trie import hexarytrie\n>>> t = hexarytrie(db={})\n>>> t.root_hash\nb'v\\xe8\\x1f\\x17\\x1b\\xccu\\xa6\\xff\\x83e\\xe6\\x92\\xc0\\xf8n[h\\xe0\\x1b\\x99l\\xad\\xc0\\x01b/\\xb5\\xe3c\\xb4!'\n>>> t[b'my-key'] = b'some-value'\n>>> t[b'my-other-key']  = b'another-value'\n\n# look at the root node:\n>>> root_node = t.traverse(())\n>>> root_node\nhexarytrienode(sub_segments=((0x6, 0xd, 0x7, 0x9, 0x2, 0xd, 0x6),), value=b'', suffix=(), raw=[b'\\x16\\xd7\\x92\\xd6', b'\\xb4q\\xb8h\\xec\\x1c\\xe1\\xf4\\\\\\x88\\xda\\xb4\\xc1\\xc2n\\xbaw\\xd0\\x9c\\xf1\\xacv\\xb4dk\\xa7\\xe6\\xd7qf\\xc2\\x82'])\n\n# the root node is an extension down, because the first 7 nibbles are the same between the two keys\n\n# let's walk down to the child of that extension\n>>> prefix6d792d6 = t.traverse(root_node.sub_segments[0])\n>>> prefix6d792d6\nhexarytrienode(sub_segments=((0xb,), (0xf,)), value=b'', suffix=(), raw=[b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', [b' ey', b'some-value'], b'', b'', b'', [b' ther-key', b'another-value'], b''])\n\n# a branch node separates the second nibbles of b'k' and b'o': 0xb and 0xf\n# notice the position of the children in the 11th and 15th index\n\n# another way to get there without loading the root node from the database is using traverse_from:\n>>> assert t.traverse_from(root_node, root_node.sub_segments[0]) == prefix6d792d6\n\n# embedded nodes can be traversed to the same way as nodes stored in the database:\n\n>>> t.traverse(root_node.sub_segments[0] + (0xb,))\nhexarytrienode(sub_segments=(), value=b'some-value', suffix=(0x6, 0x5, 0x7, 0x9), raw=[b' ey', b'some-value'])\n\n# this leaf node includes the suffix (the rest of the key, in nibbles, that haven't been traversed,\n# just b'ey': 0x6579\n\n```\n\n### walking a full trie\n\nto walk through the full trie (for example, to verify that all node bodies are present in the database),\nuse hexarytriefog and the traversal api above.\n\nfor example:\n\n```python\n\n>>> from trie import hexarytrie\n>>> t = hexarytrie(db={})\n>>> t.root_hash\nb'v\\xe8\\x1f\\x17\\x1b\\xccu\\xa6\\xff\\x83e\\xe6\\x92\\xc0\\xf8n[h\\xe0\\x1b\\x99l\\xad\\xc0\\x01b/\\xb5\\xe3c\\xb4!'\n>>> t[b'my-key'] = b'some-value'\n>>> t[b'my-other-key']  = b'another-value'\n>>> t[b'your-key'] = b'your-value'\n>>> t[b'your-other-key'] = b'your-other-value'\n>>> t.root_hash\nb'\\xf8\\xdd\\xe4\\x0f\\xaa\\xf4p7\\xfa$\\xfde>\\xec\\xb4i\\x00n\\xa3)\\xcf\\xef\\x80\\xc4yu\\xe8\\xe7\\xbf\\xa89\\xd5'\n\n# initialize a fog object to track unexplored prefixes in a trie walk\n>>> from trie.fog import hexarytriefog\n>>> empty_fog = hexarytriefog()\n# at the beginning, the unexplored prefix is (), which means that none of the trie has been explored\n>>> prefix = empty_fog.nearest_unknown()\n()\n\n# so we start by exploring the node at prefix () -- which is the root node:\n>>> node = t.traverse(prefix)\nhexarytrienode(sub_segments=((0x6,), (0x7,)), value=b'', suffix=(), raw=[b'', b'', b'', b'', b'', b'', b\"\\x03\\xd2vk\\x85\\xce\\xe1\\xa8\\xdb'f\\x8c\\xe5\\x15\\xc6\\n+m:th\\xa1\\\\\\xb13\\xcc\\xe8\\xd0\\x1d\\xa7\\xa8u\", b\"\\x1b\\x8d'\\xb3\\x99(yx\\xaa\\x96c!\\xba'x \\xbb|\\xa6,\\xb5v!\\xd3\\x1a\\x05\\xe5\\xbf\\x02\\xa3fr\", b'', b'', b'', b'', b'', b'', b'', b'', b''])\n# and mark the root as explored, while defining the unexplored children:\n>>> level1fog = empty_fog.explore(prefix, node.sub_segments)\n# now the unexplored prefixes are the keys starting with the four bits 6 and the four bits 7.\n# all other keys are known to not exist (and so have been explored)\n>>> level1fog\nhexarytriefog<sortedset([(0x6,), (0x7,)])>\n\n# so we continue exploring. the fog helps choose which prefix to explore next:\n>>> level1fog.nearest_unknown()\n(0x6,)\n# we can also look for the nearest unknown key to a particular target\n>>> prefix = level1fog.nearest_unknown((8, 1))\n(0x7,)\n>>> node7 = node.traverse(prefix)\nhexarytrienode(sub_segments=((0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6),), value=b'', suffix=(), raw=[b'\\x00\\x96\\xf7w\"\\xd6', b\"\\xe2\\xe2on\\xe1\\xf8\\xda\\xc1\\x8c\\x03\\x92'\\x93\\x805\\xad-\\xef\\x07_\\x0epv\\x1f\\xb5/lvz\\xc6\\xc1\\xf9\"])\n# we found an extension node, and mark it in the fog\n# for simpliticy, we'll start clobbering the `fog` variable\n>>> fog = level1fog.explore(prefix, node7.sub_segments)\nhexarytriefog<sortedset([(0x6,), (0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6)])>\n\n# let's explore the next branch node and see what's left\n>>> prefix = fog.nearest_unknown((7,))\n(0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6)\n>>> node796f75722d6 = t.traverse(prefix)\nhexarytrienode(sub_segments=((0xb,), (0xf,)), value=b'', suffix=(), raw=[b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', [b' ey', b'your-value'], b'', b'', b'', [b' ther-key', b'your-other-value'], b''])\n# notice that the branch node inlines the values, but the fog and annotated node ignore them for now\n>>> fog = fog.explore(prefix, node796f75722d6.sub_segments)\nhexarytriefog<sortedset([(0x6,), (0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb), (0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xf)])>\n\n# index keys may not matter for some use cases, so we can leave them out\n#   entirely, like nearest_unknown().\n# there's one more feature to consider: we can look directionally to the right\n#   of an index for the nearest prefix.\n>>> prefix = fog.nearest_right((0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xc))\n(0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xf)\n# that same index key would give a closer prefix to the left if direction didn't matter\n#   (see the difference in the very last nibble)\n>>> fog.nearest_unknown((0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xc))\n(0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb)\n# so we traverse to this last embedded leaf node at `prefix`\n>>> a_leaf_node = t.traverse(prefix)\nhexarytrienode(sub_segments=(), value=b'your-other-value', suffix=(0x7, 0x4, 0x6, 0x8, 0x6, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb, 0x6, 0x5, 0x7, 0x9), raw=[b' ther-key', b'your-other-value'])\n# we mark the prefix as fully explored like so:\n>>> fog = fog.explore(prefix, a_leaf_node.sub_segments)\nhexarytriefog<sortedset([(0x6,), (0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb)])>\n# notice that sub_segments was empty, and the prefix has disappeared from our list of unexplored prefixes\n\n# so far we have dealt with an un-changing trie, but what if it is\n#   modified while we are working on it?\n>>> del t[b'your-other-key']\n>>> t[b'your-key-rebranched'] = b'your-value'\n>>> t.root_hash\nb'\"\\xc0\\xcaq\\xa7x\\x08e\\xb5\"a\\xde\\xbfy\\xeb\"xy\\xb1o\\x034=\\x04\\x06\\xa9li\\xd8\\x92\\xadp'\n\n# the unexplored prefixes we have before might not exist anymore. they might:\n#   1. have been deleted entirely, in which case, we will get a blank node, and need no special treatment\n#   2. lead us into the middle of a leaf or extension node, which makes things tricky\n>>> prefix = fog.nearest_unknown((8,))\n(0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb)\n>>> t.traverse(prefix)\ntraversedpartialpath: could not traverse through hexarytrienode(sub_segments=((0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb, 0x6, 0x5, 0x7, 0x9),), value=b'', suffix=(), raw=[b'\\x19our-key', b'f\\xbe\\x88\\x8f#\\xd5\\x15-8\\xc0\\x1f\\xfb\\xf7\\x8b=\\x98\\x86 \\xec\\xdek\\x07\\xc8\\xbf\\xa7\\x93\\xfa\\x9e\\xc1\\x89@\\x00']) at (0x7,), only partially traversed with: (0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb)\n\n# let's drill into what this means:\n#   - we fully traversed to a node at prefix (7,)\n#   - we tried to traverse into the rest of the prefix\n#   - we only got part-way through the extension node: (0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb)\n#   - the extension node full sub-segment is actually: (0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb, 0x6, 0x5, 0x7, 0x9)\n\n# so what do we do about it? catch the exception, and explore with the fog slightly differently\n>>> from trie.exceptions import traversedpartialpath\n>>> last_exception = none\n>>> try:\n      t.traverse(prefix)\n    except traversedpartialpath as exc:\n      last_exception = exc\n\n# we can now continue exploring the children of the extension node, by using an attribute on the exception:\n>>> sub_segments = last_exception.simulated_node.sub_segments\n((0x6, 0x5, 0x7, 0x9),)\n# note that this sub-segment now carries us the rest of the way to the child\n#   of the node that we only partially traversed into.\n# this \"simulated_node\" is created by slicing the extension node in two: the\n#   first extension node having the path that we (partially) traversed, and the second\n#   extension node being the child of that parent, which continues on to point to\n#   the child of the original extension.\n# if the exception is raised on a leaf node, then the leaf node is sliced into\n#   an extension and another shorter leaf node.\n>>> fog = fog.explore(prefix, sub_segments)\nhexarytriefog<sortedset([(0x6,), (0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb, 0x6, 0x5, 0x7, 0x9)])>\n\n# so now we can pick up where we left off, traversing to the child of the extension node, and so on.\n>>> prefix = fog.nearest_unknown((8,))\n(0x7, 0x9, 0x6, 0xf, 0x7, 0x5, 0x7, 0x2, 0x2, 0xd, 0x6, 0xb, 0x6, 0x5, 0x7, 0x9)\n# the following will not raise a traversedpartialpath exception, because we know that\n#   a node was at the path, and the trie hasn't changed:\n>>> t.traverse(prefix)\nhexarytrienode(sub_segments=((0x2,),), value=b'your-value', suffix=(), raw=[b'', b'', [b'=rebranched', b'your-value'], b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'', b'your-value'])\n\n# etc...\n```\n\n**note**: `traverse()` will access the database for every node from the root to the target node. if navigating a large trie, consider using `triefrontiercache` and `hexarytrie.traverse_from()` to minimize database lookups. see the tests in `tests/test_hexary_trie_walk.py` for some examples.\n\n## binarytrie\n\n**note:** one drawback of binary trie is that **one key can not be the prefix of another key**. for example,\nif you already set the value `value1` with key `key1`, you can not set another value with key `key` or `key11`\nand the like.\n\n### binarytrie branch and witness helper functions\n\n```python\n>>> from trie import binarytrie\n>>> from trie.branches import (\n>>>     check_if_branch_exist,\n>>>     get_branch,\n>>>     if_branch_valid,\n>>>     get_witness_for_key_prefix,\n>>> )\n>>> t = binarytrie(db={})\n>>> t.root_hash\nb\"\\xc5\\xd2f\\x01\\x86\\xf7#<\\x92~}\\xb2\\xdc\\xc7\\x03\\xc0\\xe5\\x00\\xb6s\\xca\\x82';{\\xfa\\xd8\\x04]\\x85\\xa4p\"\n>>> t.set(b'key1', b'value1')\n>>> t.set(b'key2', b'value2')\n```\n\nnow trie looks like this:\n\n```\n    root --->  (kvnode, *common key prefix*)\n                         |\n                         |\n                         |\n                    (branchnode)\n                     /         \\\n                    /           \\\n                   /             \\\n(kvnode, *remain kepath*)(kvnode, *remain kepath*)\n            |                           |\n            |                           |\n            |                           |\n  (leafnode, b'value1')       (leafnode, b'value2')\n```\n\n```python\n>>> # check_if_branch_exist function\n>>> check_if_branch_exist(t.db, t.root_hash, b'key')\ntrue\n>>> check_if_branch_exist(t.db, t.root_hash, b'key1')\ntrue\n>>> check_if_branch_exist(t.db, t.root_hash, b'ken')\nfalse\n>>> check_if_branch_exist(t.db, t.root_hash, b'key123')\nfalse\n>>> # get_branch function\n>>> get_branch(t.db, t.root_hash, b'key1')\n(b'\\x00\\x82\\x1a\\xd9^l|38j\\xed\\xf31s\\xb2\\x97a\\x8dy\\x91rj\\x92\\xf5zc\\xb4\\x99t&;!\\x9f\\xa9!\\xa2\\xfe;', b\"\\x01*\\xaccxh\\x89\\x08}\\x93|\\xda\\xb9\\r\\x9b\\x82\\x8b\\xb2y\\xbc\\x10\\xb9\\x88\\xf40\\xef\\xed\\x8b'\\x13\\xbc\\xa5\\xccygb\\xc2\\x8db\\x88lps@)\\x86v\\xd7b\\xf7\\xd3x\\x93\\xc9\\xf0\\xfd\\xae\\xe0`j#\\x0b\\xca;\\xf8\", b'\\x00\\x11\\x8ael3\\x839e\\xbd\\xc4g\\xd1xj\\x0fxwu\\xcb\\xf6\\xf3\\xf2\\x8e7!m\\xca\\x1c/\\xd7\\x7f\\xed\\xc6', b'\\x02value1')\n```\n\nnode started with `b'\\x00'`, `b'\\x01'` and `b'\\x02'` are kvnode, branchnode and leafnode respectively.\n\n```python\n>>> get_branch(t.db, t.root_hash, b'key')\n(b'\\x00\\x82\\x1a\\xd9^l|38j\\xed\\xf31s\\xb2\\x97a\\x8dy\\x91rj\\x92\\xf5zc\\xb4\\x99t&;!\\x9f\\xa9!\\xa2\\xfe;',)\n>>> get_branch(t.db, t.root_hash, b'key123') # invalidkeyerror\n>>> get_branch(t.db, t.root_hash, b'key5') # there is still branch for non-exist key\n(b'\\x00\\x82\\x1a\\xd9^l|38j\\xed\\xf31s\\xb2\\x97a\\x8dy\\x91rj\\x92\\xf5zc\\xb4\\x99t&;!\\x9f\\xa9!\\xa2\\xfe;',)\n>>> # if_branch_valid function\n>>> v = t.get(b'key1')\n>>> b = get_branch(t.db, t.root_hash, b'key1')\n>>> if_branch_valid(b, t.root_hash, b'key1', v)\ntrue\n>>> v = t.get(b'key5') # v should be none\n>>> b = get_branch(t.db, t.root_hash, b'key5')\n>>> if_branch_valid(b, t.root_hash, b'key5', v)\ntrue\n>>> v = t.get(b'key1')\n>>> b = get_branch(t.db, t.root_hash, b'key2')\n>>> if_branch_valid(b, t.root_hash, b'key1', v) # keyerror\n>>> if_branch_valid([], t.root_hash, b'key1', v) # assertionerror\n>>> # get_witness_for_key_prefix function\n>>> get_witness_for_key_prefix(t.db, t.root_hash, b'key1') # equivalent to `get_branch(t.db, t.root_hash, b'key1')`\n(b'\\x00\\x82\\x1a\\xd9^l|38j\\xed\\xf31s\\xb2\\x97a\\x8dy\\x91rj\\x92\\xf5zc\\xb4\\x99t&;!\\x9f\\xa9!\\xa2\\xfe;', b\"\\x01*\\xaccxh\\x89\\x08}\\x93|\\xda\\xb9\\r\\x9b\\x82\\x8b\\xb2y\\xbc\\x10\\xb9\\x88\\xf40\\xef\\xed\\x8b'\\x13\\xbc\\xa5\\xccygb\\xc2\\x8db\\x88lps@)\\x86v\\xd7b\\xf7\\xd3x\\x93\\xc9\\xf0\\xfd\\xae\\xe0`j#\\x0b\\xca;\\xf8\", b'\\x00\\x11\\x8ael3\\x839e\\xbd\\xc4g\\xd1xj\\x0fxwu\\xcb\\xf6\\xf3\\xf2\\x8e7!m\\xca\\x1c/\\xd7\\x7f\\xed\\xc6', b'\\x02value1')\n>>> get_witness_for_key_prefix(t.db, t.root_hash, b'key') # this will include additional nodes of b'key2'\n(b'\\x00\\x82\\x1a\\xd9^l|38j\\xed\\xf31s\\xb2\\x97a\\x8dy\\x91rj\\x92\\xf5zc\\xb4\\x99t&;!\\x9f\\xa9!\\xa2\\xfe;', b\"\\x01*\\xaccxh\\x89\\x08}\\x93|\\xda\\xb9\\r\\x9b\\x82\\x8b\\xb2y\\xbc\\x10\\xb9\\x88\\xf40\\xef\\xed\\x8b'\\x13\\xbc\\xa5\\xccygb\\xc2\\x8db\\x88lps@)\\x86v\\xd7b\\xf7\\xd3x\\x93\\xc9\\xf0\\xfd\\xae\\xe0`j#\\x0b\\xca;\\xf8\", b'\\x00\\x11\\x8ael3\\x839e\\xbd\\xc4g\\xd1xj\\x0fxwu\\xcb\\xf6\\xf3\\xf2\\x8e7!m\\xca\\x1c/\\xd7\\x7f\\xed\\xc6', b'\\x02value1', b'\\x00\\x10o\\xa9\\x0b\\x1c!_`<\\xb5^\\x98d\\x89\\x17\\x148\\xac\\xda&\\xb3p\\xf6\\x06[\\x1b9\\xc09\\xbas\\x85\\xf5', b'\\x02value2')\n>>> get_witness_for_key_prefix(t.db, t.root_hash, b'') # this will return the whole trie\n```\n",
  "docs_url": null,
  "keywords": "ethereum blockchain evm trie merkle",
  "license": "mit",
  "name": "trie",
  "package_url": "https://pypi.org/project/trie/",
  "project_url": "https://pypi.org/project/trie/",
  "project_urls": {
    "Homepage": "https://github.com/ethereum/py-trie"
  },
  "release_url": "https://pypi.org/project/trie/3.0.0/",
  "requires_dist": [
    "eth-hash >=0.1.0",
    "eth-utils >=2.0.0",
    "hexbytes <0.4.0,>=0.2.0",
    "rlp >=3",
    "sortedcontainers >=2.1.0",
    "build >=0.9.0 ; extra == 'dev'",
    "bumpversion >=0.5.3 ; extra == 'dev'",
    "eth-hash <1.0.0,>=0.1.0 ; extra == 'dev'",
    "ipython ; extra == 'dev'",
    "pre-commit >=3.4.0 ; extra == 'dev'",
    "tox >=4.0.0 ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "wheel ; extra == 'dev'",
    "towncrier <22,>=21 ; extra == 'dev'",
    "hypothesis <7,>=6.56.4 ; extra == 'dev'",
    "pycryptodome ; extra == 'dev'",
    "pytest >=7.0.0 ; extra == 'dev'",
    "pytest-xdist >=2.4.0 ; extra == 'dev'",
    "towncrier <22,>=21 ; extra == 'docs'",
    "hypothesis <7,>=6.56.4 ; extra == 'test'",
    "pycryptodome ; extra == 'test'",
    "pytest >=7.0.0 ; extra == 'test'",
    "pytest-xdist >=2.4.0 ; extra == 'test'"
  ],
  "requires_python": ">=3.8, <4",
  "summary": "python implementation of the ethereum trie structure",
  "version": "3.0.0",
  "releases": [],
  "developers": [
    "snakecharmers@ethereum.org",
    "the_ethereum_foundation"
  ],
  "kwds": "trie triefrontiercache test_hexary_trie_walk python3 pytest",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_trie",
  "homepage": "https://github.com/ethereum/py-trie",
  "release_count": 34,
  "dependency_ids": [
    "pypi_build",
    "pypi_bumpversion",
    "pypi_eth_hash",
    "pypi_eth_utils",
    "pypi_hexbytes",
    "pypi_hypothesis",
    "pypi_ipython",
    "pypi_pre_commit",
    "pypi_pycryptodome",
    "pypi_pytest",
    "pypi_pytest_xdist",
    "pypi_rlp",
    "pypi_sortedcontainers",
    "pypi_towncrier",
    "pypi_tox",
    "pypi_twine",
    "pypi_wheel"
  ]
}