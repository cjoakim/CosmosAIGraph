{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "intended audience :: system administrators",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# databricks sdk for python (beta)\n\n[![pypi - downloads](https://img.shields.io/pypi/dw/databricks-sdk)](https://pypistats.org/packages/databricks-sdk)\n[![pypi - license](https://img.shields.io/pypi/l/databricks-sdk)](https://github.com/databricks/databricks-sdk-py/blob/main/license)\n[![databricks-sdk](https://snyk.io/advisor/python/databricks-sdk/badge.svg)](https://snyk.io/advisor/python/databricks-sdk)\n![pypi](https://img.shields.io/pypi/v/databricks-sdk)\n[![codecov](https://codecov.io/gh/databricks/databricks-sdk-py/branch/main/graph/badge.svg?token=gu63k7wdbe)](https://codecov.io/gh/databricks/databricks-sdk-py)\n\n[beta](https://docs.databricks.com/release-notes/release-types.html): this sdk is supported for production use cases, \nbut we do expect future releases to have some interface changes; see [interface stability](#interface-stability). \nwe are keen to hear feedback from you on these sdks. please [file issues](https://github.com/databricks/databricks-sdk-py/issues), and we will address them. \n| see also the [sdk for java](https://github.com/databricks/databricks-sdk-java) \n| see also the [sdk for go](https://github.com/databricks/databricks-sdk-go) \n| see also the [terraform provider](https://github.com/databricks/terraform-provider-databricks)\n| see also cloud-specific docs ([aws](https://docs.databricks.com/dev-tools/sdk-python.html), \n   [azure](https://learn.microsoft.com/en-us/azure/databricks/dev-tools/sdk-python), \n   [gcp](https://docs.gcp.databricks.com/dev-tools/sdk-python.html)) \n| see also the [api reference on readthedocs](https://databricks-sdk-py.readthedocs.io/en/latest/)\n\nthe databricks sdk for python includes functionality to accelerate development with [python](https://www.python.org/) for the databricks lakehouse.\nit covers all public [databricks rest api](https://docs.databricks.com/dev-tools/api/index.html) operations.\nthe sdk's internal http client is robust and handles failures on different levels by performing intelligent retries.\n\n## contents\n\n- [getting started](#getting-started)\n- [code examples](#code-examples)\n- [authentication](#authentication)\n- [long-running operations](#long-running-operations)\n- [paginated responses](#paginated-responses)\n- [single-sign-on with oauth](#single-sign-on-sso-with-oauth)\n- [logging](#logging)\n- [integration with `dbutils`](#interaction-with-dbutils)\n- [interface stability](#interface-stability)\n\n## getting started<a id=\"getting-started\"></a>\n\n1. please install databricks sdk for python via `pip install databricks-sdk` and instantiate `workspaceclient`:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient()\nfor c in w.clusters.list():\n    print(c.cluster_name)\n```\n\ndatabricks sdk for python is compatible with python 3.7 _(until [june 2023](https://devguide.python.org/versions/))_, 3.8, 3.9, 3.10, and 3.11.  \n**note:** databricks runtime starting from version 13.1 includes a bundled version of the python sdk.  \nit is highly recommended to upgrade to the latest version which you can do by running the following in a notebook cell:\n\n```python\n%pip install --upgrade databricks-sdk\n```\nfollowed by\n```python\ndbutils.library.restartpython()\n```\n## code examples<a id=\"code-examples\"></a>\n\nthe databricks sdk for python comes with a number of examples demonstrating how to use the library for various common use-cases, including\n\n* [using the sdk with oauth from a webserver](https://github.com/databricks/databricks-sdk-py/blob/main/examples/flask_app_with_oauth.py)\n* [using long-running operations](https://github.com/databricks/databricks-sdk-py/blob/main/examples/starting_job_and_waiting.py)\n* [authenticating a client app using oauth](https://github.com/databricks/databricks-sdk-py/blob/main/examples/local_browser_oauth.py)\n\nthese examples and more are located in the [`examples/` directory of the github repository](https://github.com/databricks/databricks-sdk-py/tree/main/examples).\n\nsome other examples of using the sdk include:\n* [unity catalog automated migration](https://github.com/databricks/ucx) heavily relies on python sdk for working with databricks apis.\n* [ip-access-list-analyzer](https://github.com/alexott/databricks-playground/tree/main/ip-access-list-analyzer) checks & prunes invalid entries from ip access lists.\n\n## authentication<a id=\"authentication\"></a>\n\nif you use databricks [configuration profiles](https://docs.databricks.com/dev-tools/auth.html#configuration-profiles)\nor databricks-specific [environment variables](https://docs.databricks.com/dev-tools/auth.html#environment-variables)\nfor [databricks authentication](https://docs.databricks.com/dev-tools/auth.html), the only code required to start\nworking with a databricks workspace is the following code snippet, which instructs the databricks sdk for python to use\nits [default authentication flow](#default-authentication-flow):\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient()\nw. # press <tab> for autocompletion\n```\n\nthe conventional name for the variable that holds the workspace-level client of the databricks sdk for python is `w`, which is shorthand for `workspace`.\n\n### in this section\n\n- [default authentication flow](#default-authentication-flow)\n- [databricks native authentication](#databricks-native-authentication)\n- [azure native authentication](#azure-native-authentication)\n- [overriding .databrickscfg](#overriding-databrickscfg)\n- [additional authentication configuration options](#additional-authentication-configuration-options)\n\n### default authentication flow\n\nif you run the [databricks terraform provider](https://registry.terraform.io/providers/databrickslabs/databricks/latest),\nthe [databricks sdk for go](https://github.com/databricks/databricks-sdk-go), the [databricks cli](https://docs.databricks.com/dev-tools/cli/index.html),\nor applications that target the databricks sdks for other languages, most likely they will all interoperate nicely together.\nby default, the databricks sdk for python tries the following [authentication](https://docs.databricks.com/dev-tools/auth.html) methods,\nin the following order, until it succeeds:\n\n1. [databricks native authentication](#databricks-native-authentication)\n2. [azure native authentication](#azure-native-authentication)\n4. if the sdk is unsuccessful at this point, it returns an authentication error and stops running.\n\nyou can instruct the databricks sdk for python to use a specific authentication method by setting the `auth_type` argument\nas described in the following sections.\n\nfor each authentication method, the sdk searches for compatible authentication credentials in the following locations,\nin the following order. once the sdk finds a compatible set of credentials that it can use, it stops searching:\n\n1. credentials that are hard-coded into configuration arguments.\n\n   :warning: **caution**: databricks does not recommend hard-coding credentials into arguments, as they can be exposed in plain text in version control systems. use environment variables or configuration profiles instead.\n\n2. credentials in databricks-specific [environment variables](https://docs.databricks.com/dev-tools/auth.html#environment-variables).\n3. for databricks native authentication, credentials in the `.databrickscfg` file's `default` [configuration profile](https://docs.databricks.com/dev-tools/auth.html#configuration-profiles) from its default file location (`~` for linux or macos, and `%userprofile%` for windows).\n4. for azure native authentication, the sdk searches for credentials through the azure cli as needed.\n\ndepending on the databricks authentication method, the sdk uses the following information. presented are the `workspaceclient` and `accountclient` arguments (which have corresponding `.databrickscfg` file fields), their descriptions, and any corresponding environment variables.\n\n### databricks native authentication\n\nby default, the databricks sdk for python initially tries [databricks token authentication](https://docs.databricks.com/dev-tools/api/latest/authentication.html) (`auth_type='pat'` argument). if the sdk is unsuccessful, it then tries databricks basic (username/password) authentication (`auth_type=\"basic\"` argument).\n\n- for databricks token authentication, you must provide `host` and `token`; or their environment variable or `.databrickscfg` file field equivalents.\n- for databricks basic authentication, you must provide `host`, `username`, and `password` _(for aws workspace-level operations)_; or `host`, `account_id`, `username`, and `password` _(for aws, azure, or gcp account-level operations)_; or their environment variable or `.databrickscfg` file field equivalents.\n\n| argument     | description | environment variable |\n|--------------|-------------|-------------------|\n| `host`       | _(string)_ the databricks host url for either the databricks workspace endpoint or the databricks accounts endpoint. | `databricks_host` |     \n| `account_id` | _(string)_ the databricks account id for the databricks accounts endpoint. only has effect when `host` is either `https://accounts.cloud.databricks.com/` _(aws)_, `https://accounts.azuredatabricks.net/` _(azure)_, or `https://accounts.gcp.databricks.com/` _(gcp)_. | `databricks_account_id` |\n| `token`      | _(string)_ the databricks personal access token (pat) _(aws, azure, and gcp)_ or azure active directory (azure ad) token _(azure)_. | `databricks_token` |\n| `username`   | _(string)_ the databricks username part of basic authentication. only possible when `host` is `*.cloud.databricks.com` _(aws)_. | `databricks_username` |\n| `password`   | _(string)_ the databricks password part of basic authentication. only possible when `host` is `*.cloud.databricks.com` _(aws)_. | `databricks_password` |\n\nfor example, to use databricks token authentication:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(host=input('databricks workspace url: '), token=input('token: '))\n```\n\n### azure native authentication\n\nby default, the databricks sdk for python first tries azure client secret authentication (`auth_type='azure-client-secret'` argument). if the sdk is unsuccessful, it then tries azure cli authentication (`auth_type='azure-cli'` argument). see [manage service principals](https://learn.microsoft.com/azure/databricks/administration-guide/users-groups/service-principals).\n\nthe databricks sdk for python picks up an azure cli token, if you've previously authenticated as an azure user by running `az login` on your machine. see [get azure ad tokens for users by using the azure cli](https://learn.microsoft.com/azure/databricks/dev-tools/api/latest/aad/user-aad-token).\n\nto authenticate as an azure active directory (azure ad) service principal, you must provide one of the following. see also [add a service principal to your azure databricks account](https://learn.microsoft.com/azure/databricks/administration-guide/users-groups/service-principals#add-sp-account):\n\n- `azure_resource_id`, `azure_client_secret`, `azure_client_id`, and `azure_tenant_id`; or their environment variable or `.databrickscfg` file field equivalents.\n- `azure_resource_id` and `azure_use_msi`; or their environment variable or `.databrickscfg` file field equivalents.\n\n| argument              | description | environment variable |\n|-----------------------|-------------|----------------------|\n| `azure_resource_id`   | _(string)_ the azure resource manager id for the azure databricks workspace, which is exchanged for a databricks host url. | `databricks_azure_resource_id` |\n| `azure_use_msi`       | _(boolean)_ `true` to use azure managed service identity passwordless authentication flow for service principals. _this feature is not yet implemented in the databricks sdk for python._ | `arm_use_msi` |\n| `azure_client_secret` | _(string)_ the azure ad service principal's client secret. | `arm_client_secret` |\n| `azure_client_id`     | _(string)_ the azure ad service principal's application id. | `arm_client_id` |\n| `azure_tenant_id`     | _(string)_ the azure ad service principal's tenant id. | `arm_tenant_id` |\n| `azure_environment`   | _(string)_ the azure environment type (such as public, usgov, china, and germany) for a specific set of api endpoints. defaults to `public`. | `arm_environment` |\n\nfor example, to use azure client secret authentication:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(host=input('databricks workspace url: '),\n                    azure_workspace_resource_id=input('azure resource id: '),\n                    azure_tenant_id=input('aad tenant id: '),\n                    azure_client_id=input('aad client id: '),\n                    azure_client_secret=input('aad client secret: '))\n```\n\nplease see more examples in [this document](./docs/azure-ad.md).\n\n### google cloud platform native authentication\n\nby default, the databricks sdk for python first tries gcp credentials authentication (`auth_type='google-credentials'`, argument). if the sdk is unsuccessful, it then tries google cloud platform (gcp) id authentication (`auth_type='google-id'`, argument).\n\nthe databricks sdk for python picks up an oauth token in the scope of the google default application credentials (dac) flow. this means that if you have run `gcloud auth application-default login` on your development machine, or launch the application on the compute, that is allowed to impersonate the google cloud service account specified in `google_service_account`. authentication should then work out of the box. see [creating and managing service accounts](https://cloud.google.com/iam/docs/creating-managing-service-accounts).\n\nto authenticate as a google cloud service account, you must provide one of the following:\n\n- `host` and `google_credentials`; or their environment variable or `.databrickscfg` file field equivalents.\n- `host` and `google_service_account`; or their environment variable or `.databrickscfg` file field equivalents.\n\n| argument                 | description | environment variable |\n|--------------------------|-------------|--------------------------------------------------|\n| `google_credentials`     | _(string)_ gcp service account credentials json or the location of these credentials on the local filesystem. | `google_credentials` |\n| `google_service_account` | _(string)_ the google cloud platform (gcp) service account e-mail used for impersonation in the default application credentials flow that does not require a password. | `databricks_google_service_account` |\n\nfor example, to use google id authentication:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(host=input('databricks workspace url: '),\n                    google_service_account=input('google service account: '))\n\n```\n\n### overriding `.databrickscfg`\n\nfor [databricks native authentication](#databricks-native-authentication), you can override the default behavior for using `.databrickscfg` as follows:\n\n| argument      | description | environment variable |\n|---------------|-------------|----------------------|\n| `profile`     | _(string)_ a connection profile specified within `.databrickscfg` to use instead of `default`. | `databricks_config_profile` |\n| `config_file` | _(string)_ a non-default location of the databricks cli credentials file. | `databricks_config_file` |\n\nfor example, to use a profile named `myprofile` instead of `default`:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(profile='myprofile')\n# now call the databricks workspace apis as desired...\n```\n\n### additional authentication configuration options\n\nfor all authentication methods, you can override the default behavior in client arguments as follows:\n\n| argument                | description | environment variable   |\n|-------------------------|-------------|------------------------|\n| `auth_type`             | _(string)_ when multiple auth attributes are available in the environment, use the auth type specified by this argument. this argument also holds the currently selected auth. | `databricks_auth_type` |\n| `http_timeout_seconds`  | _(integer)_ number of seconds for http timeout. default is _60_. | _(none)_               |\n| `retry_timeout_seconds` | _(integer)_ number of seconds to keep retrying http requests. default is _300 (5 minutes)_. | _(none)_               |\n| `debug_truncate_bytes`  | _(integer)_ truncate json fields in debug logs above this limit. default is 96. | `databricks_debug_truncate_bytes` |\n| `debug_headers`         | _(boolean)_ `true` to debug http headers of requests made by the application. default is `false`, as headers contain sensitive data, such as access tokens. | `databricks_debug_headers` |\n| `rate_limit`            | _(integer)_ maximum number of requests per second made to databricks rest api. | `databricks_rate_limit` |\n\nfor example, to turn on debug http headers:\n\n```python\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(debug_headers=true)\n# now call the databricks workspace apis as desired...\n```\n\n## long-running operations<a id=\"long-running-operations\"></a>\n\nwhen you invoke a long-running operation, the sdk provides a high-level api to _trigger_ these operations and _wait_ for the related entities\nto reach the correct state or return the error message in case of failure. all long-running operations return generic `wait` instance with `result()`\nmethod to get a result of long-running operation, once it's finished. databricks sdk for python picks the most reasonable default timeouts for\nevery method, but sometimes you may find yourself in a situation, where you'd want to provide `datetime.timedelta()` as the value of `timeout`\nargument to `result()` method.\n\nthere are a number of long-running operations in databricks apis such as managing:\n* clusters,\n* command execution\n* jobs\n* libraries\n* delta live tables pipelines\n* databricks sql warehouses.\n\nfor example, in the clusters api, once you create a cluster, you receive a cluster id, and the cluster is in the `pending` state meanwhile\ndatabricks takes care of provisioning virtual machines from the cloud provider in the background. the cluster is\nonly usable in the `running` state and so you have to wait for that state to be reached.\n\nanother example is the api for running a job or repairing the run: right after\nthe run starts, the run is in the `pending` state. the job is only considered to be finished when it is in either\nthe `terminated` or `skipped` state. also you would likely need the error message if the long-running\noperation times out and fails with an error code. other times you may want to configure a custom timeout other than\nthe default of 20 minutes.\n\nin the following example, `w.clusters.create` returns `clusterinfo` only once the cluster is in the `running` state,\notherwise it will timeout in 10 minutes:\n\n```python\nimport datetime\nimport logging\nfrom databricks.sdk import workspaceclient\n\nw = workspaceclient()\ninfo = w.clusters.create_and_wait(cluster_name='created cluster',\n                                  spark_version='12.0.x-scala2.12',\n                                  node_type_id='m5d.large',\n                                  autotermination_minutes=10,\n                                  num_workers=1,\n                                  timeout=datetime.timedelta(minutes=10))\nlogging.info(f'created: {info}')\n```\n\nplease look at the `examples/starting_job_and_waiting.py` for a more advanced usage:\n\n```python\nimport datetime\nimport logging\nimport time\n\nfrom databricks.sdk import workspaceclient\nimport databricks.sdk.service.jobs as j\n\nw = workspaceclient()\n\n# create a dummy file on dbfs that just sleeps for 10 seconds\npy_on_dbfs = f'/home/{w.current_user.me().user_name}/sample.py'\nwith w.dbfs.open(py_on_dbfs, write=true, overwrite=true) as f:\n    f.write(b'import time; time.sleep(10); print(\"hello, world!\")')\n\n# trigger one-time-run job and get waiter object\nwaiter = w.jobs.submit(run_name=f'py-sdk-run-{time.time()}', tasks=[\n    j.runsubmittasksettings(\n        task_key='hello_world',\n        new_cluster=j.baseclusterinfo(\n            spark_version=w.clusters.select_spark_version(long_term_support=true),\n            node_type_id=w.clusters.select_node_type(local_disk=true),\n            num_workers=1\n        ),\n        spark_python_task=j.sparkpythontask(\n            python_file=f'dbfs:{py_on_dbfs}'\n        ),\n    )\n])\n\nlogging.info(f'starting to poll: {waiter.run_id}')\n\n# callback, that receives a polled entity between state updates\ndef print_status(run: j.run):\n    statuses = [f'{t.task_key}: {t.state.life_cycle_state}' for t in run.tasks]\n    logging.info(f'workflow intermediate status: {\", \".join(statuses)}')\n\n# if you want to perform polling in a separate thread, process, or service,\n# you can use w.jobs.wait_get_run_job_terminated_or_skipped(\n#   run_id=waiter.run_id,\n#   timeout=datetime.timedelta(minutes=15),\n#   callback=print_status) to achieve the same results.\n#\n# waiter interface allows for `w.jobs.submit(..).result()` simplicity in\n# the scenarios, where you need to block the calling thread for the job to finish.\nrun = waiter.result(timeout=datetime.timedelta(minutes=15),\n                    callback=print_status)\n\nlogging.info(f'job finished: {run.run_page_url}')\n```\n\n## paginated responses<a id=\"paginated-responses\"></a>\n\non the platform side the databricks apis have different wait to deal with pagination:\n* some apis follow the offset-plus-limit pagination\n* some start their offsets from 0 and some from 1\n* some use the cursor-based iteration\n* others just return all results in a single response\n\nthe databricks sdk for python hides this  complexity\nunder `iterator[t]` abstraction, where multi-page results `yield` items. python typing helps to auto-complete\nthe individual item fields.\n\n```python\nimport logging\nfrom databricks.sdk import workspaceclient\nw = workspaceclient()\nfor repo in w.repos.list():\n    logging.info(f'found repo: {repo.path}')\n```\n\nplease look at the `examples/last_job_runs.py` for a more advanced usage:\n\n```python\nimport logging\nfrom collections import defaultdict\nfrom datetime import datetime, timezone\nfrom databricks.sdk import workspaceclient\n\nlatest_state = {}\nall_jobs = {}\ndurations = defaultdict(list)\n\nw = workspaceclient()\nfor job in w.jobs.list():\n    all_jobs[job.job_id] = job\n    for run in w.jobs.list_runs(job_id=job.job_id, expand_tasks=false):\n        durations[job.job_id].append(run.run_duration)\n        if job.job_id not in latest_state:\n            latest_state[job.job_id] = run\n            continue\n        if run.end_time < latest_state[job.job_id].end_time:\n            continue\n        latest_state[job.job_id] = run\n\nsummary = []\nfor job_id, run in latest_state.items():\n    summary.append({\n        'job_name': all_jobs[job_id].settings.name,\n        'last_status': run.state.result_state,\n        'last_finished': datetime.fromtimestamp(run.end_time/1000, timezone.utc),\n        'average_duration': sum(durations[job_id]) / len(durations[job_id])\n    })\n\nfor line in sorted(summary, key=lambda s: s['last_finished'], reverse=true):\n    logging.info(f'latest: {line}')\n```\n\n## single-sign-on (sso) with oauth<a id=\"single-sign-on-sso-with-oauth\"></a>\n\n### authorization code flow with pkce\n\nfor a regular web app running on a server, it's recommended to use the authorization code flow to obtain an access token\nand a refresh token. this method is considered safe because the access token is transmitted directly to the server\nhosting the app, without passing through the user's web browser and risking exposure.\n\nto enhance the security of the authorization code flow, the pkce (proof key for code exchange) mechanism can be\nemployed. with pkce, the calling application generates a secret called the code verifier, which is verified by\nthe authorization server. the app also creates a transform value of the code verifier, called the code challenge,\nand sends it over https to obtain an authorization code. by intercepting the authorization code, a malicious attacker\ncannot exchange it for a token without possessing the code verifier.\n\nthe [presented sample](https://github.com/databricks/databricks-sdk-py/blob/main/examples/flask_app_with_oauth.py)\nis a python3 script that uses the flask web framework along with databricks sdk for python to demonstrate how to\nimplement the oauth authorization code flow with pkce security. it can be used to build an app where each user uses\ntheir identity to access databricks resources. the script can be executed with or without client and secret credentials\nfor a custom oauth app.\n\ndatabricks sdk for python exposes the `oauth_client.initiate_consent()` helper to acquire user redirect url and initiate\npkce state verification. application developers are expected to persist `refreshablecredentials` in the webapp session\nand restore it via `refreshablecredentials.from_dict(oauth_client, session['creds'])` helpers.\n\nworks for both aws and azure. not supported for gcp at the moment.\n\n```python\nfrom databricks.sdk.oauth import oauthclient\n\noauth_client = oauthclient(host='<workspace-url>',\n                           client_id='<oauth client id>',\n                           redirect_url=f'http://host.domain/callback',\n                           scopes=['clusters'])\n\nimport secrets\nfrom flask import flask, render_template_string, request, redirect, url_for, session\n\napp_name = 'flask-demo'\napp = flask(app_name)\napp.secret_key = secrets.token_urlsafe(32)\n\n\n@app.route('/callback')\ndef callback():\n   from databricks.sdk.oauth import consent\n   consent = consent.from_dict(oauth_client, session['consent'])\n   session['creds'] = consent.exchange_callback_parameters(request.args).as_dict()\n   return redirect(url_for('index'))\n\n\n@app.route('/')\ndef index():\n   if 'creds' not in session:\n      consent = oauth_client.initiate_consent()\n      session['consent'] = consent.as_dict()\n      return redirect(consent.auth_url)\n\n   from databricks.sdk import workspaceclient\n   from databricks.sdk.oauth import sessioncredentials\n\n   credentials_provider = sessioncredentials.from_dict(oauth_client, session['creds'])\n   workspace_client = workspaceclient(host=oauth_client.host,\n                                      product=app_name,\n                                      credentials_provider=credentials_provider)\n\n   return render_template_string('...', w=workspace_client)\n```\n\n### sso for local scripts on development machines\n\nfor applications, that do run on developer workstations, databricks sdk for python provides `auth_type='external-browser'`\nutility, that opens up a browser for a user to go through sso flow. azure support is still in the early experimental\nstage.\n\n```python\nfrom databricks.sdk import workspaceclient\n\nhost = input('enter databricks host: ')\n\nw = workspaceclient(host=host, auth_type='external-browser')\nclusters = w.clusters.list()\n\nfor cl in clusters:\n    print(f' - {cl.cluster_name} is {cl.state}')\n```\n\n### creating custom oauth applications\n\nin order to use oauth with databricks sdk for python, you should use `account_client.custom_app_integration.create` api.\n\n```python\nimport logging, getpass\nfrom databricks.sdk import accountclient\naccount_client = accountclient(host='https://accounts.cloud.databricks.com',\n                               account_id=input('databricks account id: '),\n                               username=input('username: '),\n                               password=getpass.getpass('password: '))\n\nlogging.info('enrolling all published apps...')\naccount_client.o_auth_enrollment.create(enable_all_published_apps=true)\n\nstatus = account_client.o_auth_enrollment.get()\nlogging.info(f'enrolled all published apps: {status}')\n\ncustom_app = account_client.custom_app_integration.create(\n    name='awesome-app',\n    redirect_urls=[f'https://host.domain/path/to/callback'],\n    confidential=true)\nlogging.info(f'created new custom app: '\n             f'--client_id {custom_app.client_id} '\n             f'--client_secret {custom_app.client_secret}')\n```\n\n## logging<a id=\"logging\"></a>\n\nthe databricks sdk for python seamlessly integrates with the standard [logging facility for python](https://docs.python.org/3/library/logging.html).\nthis allows developers to easily enable and customize logging for their databricks python projects.\nto enable debug logging in your databricks python project, you can follow the example below:\n\n```python\nimport logging, sys\nlogging.basicconfig(stream=sys.stderr,\n                    level=logging.info,\n                    format='%(asctime)s [%(name)s][%(levelname)s] %(message)s')\nlogging.getlogger('databricks.sdk').setlevel(logging.debug)\n\nfrom databricks.sdk import workspaceclient\nw = workspaceclient(debug_truncate_bytes=1024, debug_headers=false)\nfor cluster in w.clusters.list():\n    logging.info(f'found cluster: {cluster.cluster_name}')\n```\n\nin the above code snippet, the logging module is imported and the `basicconfig()` method is used to set the logging level to `debug`.\nthis will enable logging at the debug level and above. developers can adjust the logging level as needed to control the verbosity of the logging output.\nthe sdk will log all requests and responses to standard error output, using the format `> ` for requests and `< ` for responses.\nin some cases, requests or responses may be truncated due to size considerations. if this occurs, the log message will include\nthe text `... (xxx additional elements)` to indicate that the request or response has been truncated. to increase the truncation limits,\ndevelopers can set the `debug_truncate_bytes` configuration property or the `databricks_debug_truncate_bytes` environment variable.\nto protect sensitive data, such as authentication tokens, passwords, or any http headers, the sdk will automatically replace these\nvalues with `**redacted**` in the log output. developers can disable this redaction by setting the `debug_headers` configuration property to `true`.\n\n```text\n2023-03-22 21:19:21,702 [databricks.sdk][debug] get /api/2.0/clusters/list\n< 200 ok\n< {\n<   \"clusters\": [\n<     {\n<       \"autotermination_minutes\": 60,\n<       \"cluster_id\": \"1109-115255-s1w13zjj\",\n<       \"cluster_name\": \"default test cluster\",\n<       ... truncated for brevity\n<     },\n<     \"... (47 additional elements)\"\n<   ]\n< }\n```\n\noverall, the logging capabilities provided by the databricks sdk for python can be a powerful tool for monitoring and troubleshooting your\ndatabricks python projects. developers can use the various logging methods and configuration options provided by the sdk to customize\nthe logging output to their specific needs.\n\n## interaction with `dbutils`<a id=\"interaction-with-dbutils\"></a>\n\nyou can use the client-side implementation of [`dbutils`](https://docs.databricks.com/dev-tools/databricks-utils.html) by accessing `dbutils` property on the `workspaceclient`.\nmost of the `dbutils.fs` operations and `dbutils.secrets` are implemented natively in python within databricks sdk. non-sdk implementations still require a databricks cluster,\nthat you have to specify through the `cluster_id` configuration attribute or `databricks_cluster_id` environment variable. don't worry if cluster is not running: internally,\ndatabricks sdk for python calls `w.clusters.ensure_cluster_is_running()`.\n\n```python\nfrom databricks.sdk import workspaceclient\n\nw = workspaceclient()\ndbutils = w.dbutils\n\nfiles_in_root = dbutils.fs.ls('/')\nprint(f'number of files in root: {len(files_in_root)}')\n```\n\nalternatively, you can import `dbutils` from `databricks.sdk.runtime` module, but you have to make sure that all configuration is already [present in the environment variables](#default-authentication-flow):\n\n```python\nfrom databricks.sdk.runtime import dbutils\n\nfor secret_scope in dbutils.secrets.listscopes():\n    for secret_metadata in dbutils.secrets.list(secret_scope.name):\n        print(f'found {secret_metadata.key} secret in {secret_scope.name} scope')\n```\n\n## interface stability<a id=\"interface-stability\"></a>\n\ndatabricks is actively working on stabilizing the databricks sdk for python's interfaces. \napi clients for all services are generated from specification files that are synchronized from the main platform. \nyou are highly encouraged to pin the exact dependency version and read the [changelog](https://github.com/databricks/databricks-sdk-py/blob/main/changelog.md) \nwhere databricks documents the changes. databricks may have minor [documented](https://github.com/databricks/databricks-sdk-py/blob/main/changelog.md) \nbackward-incompatible changes, such as renaming some type names to bring more consistency.\n\n\n",
  "docs_url": null,
  "keywords": "databricks sdk",
  "license": "",
  "name": "databricks-sdk",
  "package_url": "https://pypi.org/project/databricks-sdk/",
  "project_url": "https://pypi.org/project/databricks-sdk/",
  "project_urls": {
    "Homepage": "https://databricks-sdk-py.readthedocs.io"
  },
  "release_url": "https://pypi.org/project/databricks-sdk/0.16.0/",
  "requires_dist": [
    "google-auth (~=2.0)",
    "requests (<3,>=2.28.1)",
    "autoflake ; extra == 'dev'",
    "ipython ; extra == 'dev'",
    "ipywidgets ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "pycodestyle ; extra == 'dev'",
    "pyfakefs ; extra == 'dev'",
    "pytest ; extra == 'dev'",
    "pytest-cov ; extra == 'dev'",
    "pytest-mock ; extra == 'dev'",
    "pytest-xdist ; extra == 'dev'",
    "requests-mock ; extra == 'dev'",
    "wheel ; extra == 'dev'",
    "yapf ; extra == 'dev'",
    "ipython (<9,>=8) ; extra == 'notebook'",
    "ipywidgets (<9,>=8) ; extra == 'notebook'"
  ],
  "requires_python": ">=3.7",
  "summary": "databricks sdk for python (beta)",
  "version": "0.16.0",
  "releases": [],
  "developers": [
    "serge.smertin@databricks.com",
    "serge_smertin"
  ],
  "kwds": "databrickslabs databricks databrickscfg databricks_token databricks_debug_headers",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_databricks_sdk",
  "homepage": "https://databricks-sdk-py.readthedocs.io",
  "release_count": 33,
  "dependency_ids": [
    "pypi_autoflake",
    "pypi_google_auth",
    "pypi_ipython",
    "pypi_ipywidgets",
    "pypi_isort",
    "pypi_pycodestyle",
    "pypi_pyfakefs",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_mock",
    "pypi_pytest_xdist",
    "pypi_requests",
    "pypi_requests_mock",
    "pypi_wheel",
    "pypi_yapf"
  ]
}