{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: software development"
  ],
  "description": "# reretry\n\n![](https://img.shields.io/pypi/dm/reretry.svg)\n![](https://github.com/leshchenko1979/reretry/workflows/build/badge.svg)\n[![codecov](https://codecov.io/gh/leshchenko1979/reretry/branch/master/graph/badge.svg)](https://codecov.io/gh/leshchenko1979/reretry)\n[![codefactor](https://www.codefactor.io/repository/github/leshchenko1979/reretry/badge)](https://www.codefactor.io/repository/github/leshchenko1979/reretry)\n\nan easy to use retry decorator.\n\nthis package is a fork from the [`retry`](https://github.com/invl/retry) package, but with some of added community-sourced features.\n\n\n## features\n\nnew features in `reretry`:\n- log traceback of an error that lead to a failed attempt.\n- call a custom callback after each failed attempt.\n- can be used with async functions.\n\nfrom original `retry`:\n- retry on specific exceptions.\n- set a maximum number of retries.\n- set a delay between retries.\n- set a maximum delay between retries.\n- set backoff and jitter parameters.\n- use a custom logger.\n- no external dependencies (stdlib only).\n- (optionally) preserve function signatures (`pip install decorator`).\n\n\n## installation\n\n```bash\n$ pip install reretry\n```\n\n## api\n### the @retry decorator\n\n#### usage\n`@retry(exceptions=exception, tries=-1, delay=0, max_delay=none, backoff=1, jitter=0, show_traceback=false, logger=logging_logger, fail_callback=none)`\n\n#### arguments\n- `exceptions`: an exception or a tuple of exceptions to catch. default: exception.\n\n- `tries`: the maximum number of attempts. default: -1 (infinite).\n\n- `delay`: initial delay between attempts (in seconds). default: 0.\n\n- `max_delay`: the maximum value of delay (in seconds). default: none (no limit).\n\n- `backoff`: multiplier applied to delay between attempts. default: 1 (no backoff).\n\n- `jitter`: extra seconds added to delay between attempts. default: 0. fixed if a number, random if a range tuple (min, max).\n\n- `show_traceback`: print traceback before retrying (python3 only). default: false.\n\n- `logger`: `logger.warning(fmt, error, delay)` will be called on failed attempts. default: retry.logging_logger. if none, logging is disabled.\n\n- `fail_callback`: `fail_callback(e)` will be called after failed attempts.\n\n\n#### examples\n```python\nfrom reretry import retry\n\n@retry()\ndef make_trouble():\n    '''retry until succeeds'''\n\n@retry()\nasync def async_make_trouble():\n    '''retry an async function until it succeeds'''\n\n@retry(zerodivisionerror, tries=3, delay=2)\ndef make_trouble():\n    '''retry on zerodivisionerror, raise error after 3 attempts,\n    sleep 2 seconds between attempts.'''\n\n@retry((valueerror, typeerror), delay=1, backoff=2)\ndef make_trouble():\n    '''retry on valueerror or typeerror, sleep 1, 2, 4, 8, ... seconds between attempts.'''\n\n@retry((valueerror, typeerror), delay=1, backoff=2, max_delay=4)\ndef make_trouble():\n    '''retry on valueerror or typeerror, sleep 1, 2, 4, 4, ... seconds between attempts.'''\n\n@retry(valueerror, delay=1, jitter=1)\ndef make_trouble():\n    '''retry on valueerror, sleep 1, 2, 3, 4, ... seconds between attempts.'''\n\ndef callback(e: exception):\n    '''print error message'''\n    print(e)\n\n@retry(valueerror, fail_callback=callback):\ndef make_trouble():\n    '''retry on valueerror, between attempts call callback(e)\n    (where e is the exception raised).'''\n\n# if you enable logging, you can get warnings like 'valueerror, retrying in\n# 1 seconds'\nif __name__ == '__main__':\n    import logging\n    logging.basicconfig()\n    make_trouble()\n```\n\n### the `retry_call` function\ncalls a function and re-executes it if it failed.\n\nthis is very similar to the decorator, except that it takes a function and its arguments as parameters. the use case behind it is to be able to dynamically adjust the retry arguments.\n\n#### usage\n`retry_call(f, fargs=none, fkwargs=none, exceptions=exception, tries=-1, delay=0, max_delay=none, backoff=1, jitter=0, show_traceback=false, logger=logging_logger, fail_callback=none)`\n\n#### example\n```python\nimport requests\n\nfrom reretry.api import retry_call\n\n\ndef make_trouble(service, info=none):\n    if not info:\n        info = ''\n    r = requests.get(service + info)\n    return r.text\n\n\ndef what_is_my_ip(approach=none):\n    if approach == \"optimistic\":\n        tries = 1\n    elif approach == \"conservative\":\n        tries = 3\n    else:\n        # skeptical\n        tries = -1\n    result = retry_call(\n        make_trouble,\n        fargs=[\"http://ipinfo.io/\"],\n        fkwargs={\"info\": \"ip\"},\n        tries=tries\n    )\n    print(result)\n\nwhat_is_my_ip(\"conservative\")\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license 2.0",
  "name": "reretry",
  "package_url": "https://pypi.org/project/reretry/",
  "project_url": "https://pypi.org/project/reretry/",
  "project_urls": {
    "Homepage": "https://github.com/leshchenko1979/reretry"
  },
  "release_url": "https://pypi.org/project/reretry/0.11.8/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "an easy to use, but functional decorator for retrying on exceptions.",
  "version": "0.11.8",
  "releases": [],
  "developers": [
    "leshchenko1979",
    "leshchenko1979@gmail.com"
  ],
  "kwds": "retries retrying retry_call retry reretry",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_reretry",
  "homepage": "https://github.com/leshchenko1979/reretry",
  "release_count": 5,
  "dependency_ids": []
}