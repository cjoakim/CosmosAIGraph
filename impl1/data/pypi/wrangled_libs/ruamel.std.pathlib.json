{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python"
  ],
  "description": "\nruamel.std.pathlib\n==================\n\n`package ruamel.std.pathlib <https://bitbucket.org/ruamel/std.pathlib>`_ is a drop-in\nreplacement to extend the python standard `pathlib`` module.\n\nyou can just replace::\n\n  from pathlib import posixpath, path\n\nwith::\n\n  from ruamel.std.pathlib import posixpath, path\n\n.. image:: https://sourceforge.net/p/ruamel-std-pathlib/code/ci/default/tree/_doc/_static/pypi.svg?format=raw\n     :target: https://pypi.org/project/ruamel.std.pathlib\n\n.. image:: https://sourceforge.net/p/ruamel-std-pathlib/code/ci/default/tree/_doc/_static/license.svg?format=raw\n     :target: https://opensource.org/licenses/mit\n\n.. image:: https://sourceforge.net/p/oitnb/code/ci/default/tree/_doc/_static/oitnb.svg?format=raw\n   :target: https://pypi.org/project/oitnb/\n\nstarting with 0.8.0 `ruamel.std.pathlib` no longer supports python 2\n\nextra path functionality\n------------------------\n\n* alias ``remove`` for ``unlink`` on path\n* add ``copy()`` and ``rmtree()`` from shutil to path\n* add ``hash()`` to path return the ``hashlib.new()`` value on the\n  file content (defaults to 'sha224', other algorithms can be given as\n  parameter:  ``print(p.hash('md5').hexdigest())``)\n\nwhen you have `blake3` installed and do `import ruamel.std.pathlib.blake3`, you\ncan also use that method on `path` instances.\n\ntransition helper\n-----------------\n\nif you are starting to use the standard pathlib library, it is cumbersome to\nchange everything at once, and also to change all the arguments to calls to\n``os.path.join``, ``os.rename``, ``os.path.dirname`` to be made encapsulated in ``str()``\n\nby making an instance of ``pathlibconversionhelper`` named ``pl`` you can change\n``os.path.join()`` to ``pl.path.join()``, etc., and then start passing in path\ninstances instead of strings.\n\n``pathlibconversionhelper`` currently supports the following replacements for `os`,\n `os.path`, `shutil` and built-in functions::\n\n  .chdir()             replaces: os.chdir()\n  .copy()              replaces: shutil.copy()\n  .glob()              replaces: glob.glob()\n  .listdir()           replaces: os.listdir()\n  .makedirs()          replaces: os.makedirs()\n  .mkstemp()           replaces: tempfile.mkstemp()\n  .open()              replaces: built-in open()\n  .path.basename()     replaces: os.path.basename()\n  .path.dirname()      replaces: os.path.dirname()\n  .path.exists()       replaces: os.path.exists()\n  .path.expanduser()   replaces: os.path.expanduser()\n  .path.getmtime()     replaces: os.path.getmtime()\n  .path.isdir()        replaces: os.path.isdir()\n  .path.join()         replaces: os.path.join()\n  .path.splitext()     replaces: os.path.splitext()\n  .remove()            replaces: os.remove()\n  .rename()            replaces: os.rename()\n  .rmdir()             replaces: os.rmdir()\n  .rmtree()            replaces: shutil.rmtree()\n  .walk()              replaces: os.walk()\n\n\n.. example output methods.py\n\nyou can provide a check level when you create the\n`pathlibconversionhelper()` instance.\n\n- if check is non-zero, all calls are being logged and the invocations\n  can be dumped e.g. at the end of the program with\n  ``pl.dump(stream, show_all=false)`` this will include\n  the number of invocations not using path (and using path uniquely as well\n  if ``show_all=true``)\n- if check is greater than 1, first usage is dumped immediately.\n\n\nif you start with the following code::\n\n  # coding: utf-8\n  \n  import os\n  import glob\n  import tempfile\n  import shutil\n  import random\n  \n  \n  class tempdir(object):\n      \"\"\"self removing (unless keep=true) temporary directory\"\"\"\n      def __init__(self, keep=false, basedir=none, prefix=none):\n          self._keep = keep\n          # mkdtemp creates with permissions rwx------\n          kw = dict(dir=basedir)\n          if prefix is not none:\n              kw['prefix'] = prefix\n          # mkdtemp doesn't do the right thing if none is passed in\n          # as it has prefix=template in definition\n          self._tmpdir = tempfile.mkdtemp(**kw)\n  \n      def remove(self):\n          shutil.rmtree(self._tmpdir)\n  \n      def chdir(self):\n          os.chdir(self._tmpdir)\n  \n      def tempfilename(self, extension=''):\n          fd, name = tempfile.mkstemp(suffix=extension, dir=self._tmpdir)\n          os.close(fd)\n          return name\n  \n      def tempfilename2(self, extension=''):\n          while true:\n              name = os.path.join(\n                  self._tmpdir,\n                  '%08d' % random.randint(0, 100000) + extension\n              )\n              if not os.path.exists(name):\n                  break\n          return name\n  \n      @property\n      def directory(self):\n          return self._tmpdir\n  \n      def __enter__(self):\n          return self\n  \n      def __exit__(self, exc_type, exc_val, exc_tb):\n          if not self._keep:\n              self.remove()\n  \n  \n  def main():\n      \"\"\"contrived example using tempdir\"\"\"\n      org_dir = os.getcwd()\n      with tempdir() as td:\n          for n in range(3):\n              t1 = td.tempfilename(extension='.sample')\n              with open(t1, 'w') as fp:\n                  fp.write('content\\n')\n          t2 = td.tempfilename2(extension='.sample2')\n          with open(t2, 'w') as fp:\n              fp.write('content\\n')\n          os.chdir(td.directory)\n          count = 0\n          for file_name in glob.glob('*.samp*'):\n              full_name = os.path.join(os.getcwd(), file_name)  # noqa\n              # print(full_name)\n              count += 1\n          os.chdir('/tmp')  # not using path\n          os.chdir(org_dir)\n      print('{} files found in temporary directory'.format(count))\n  \n  main()\n\n.. example code original.py\n\nyou get::\n\n  4 files found in temporary directory\n\n\n.. example output original.py\n\nwhen you start to change ``tempdir()`` to store the\nactual directory as a path, things start to break immediately::\n\n  # coding: utf-8\n  \n  import os\n  import glob\n  import tempfile\n  import shutil\n  import random\n  \n  from ruamel.std.pathlib import path                                   # added\n  \n  \n  class tempdir(object):\n      \"\"\"self removing (unless keep=true) temporary directory\"\"\"\n      def __init__(self, keep=false, basedir=none, prefix=none):\n          self._keep = keep\n          # mkdtemp creates with permissions rwx------\n          kw = dict(dir=basedir)\n          if prefix is not none:\n              kw['prefix'] = prefix\n          # mkdtemp doesn't do the right thing if none is passed in\n          # as it has prefix=template in definition\n          self._tmpdir = path(tempfile.mkdtemp(**kw))                   # changed\n  \n      def remove(self):\n          shutil.rmtree(self._tmpdir)\n  \n      def chdir(self):\n          os.chdir(self._tmpdir)\n  \n      def tempfilename(self, extension=''):\n          fd, name = tempfile.mkstemp(suffix=extension, dir=self._tmpdir)\n          os.close(fd)\n          return name\n  \n      def tempfilename2(self, extension=''):\n          while true:\n              name = os.path.join(\n                  self._tmpdir,\n                  '%08d' % random.randint(0, 100000) + extension\n              )\n              if not os.path.exists(name):\n                  break\n          return name\n  \n      @property\n      def directory(self):\n          return self._tmpdir\n  \n      def __enter__(self):\n          return self\n  \n      def __exit__(self, exc_type, exc_val, exc_tb):\n          if not self._keep:\n              self.remove()\n  \n  \n  def main():\n      \"\"\"contrived example using tempdir\"\"\"\n      org_dir = os.getcwd()\n      with tempdir() as td:\n          for n in range(3):\n              t1 = td.tempfilename(extension='.sample')\n              with open(t1, 'w') as fp:\n                  fp.write('content\\n')\n          t2 = td.tempfilename2(extension='.sample2')\n          with open(t2, 'w') as fp:\n              fp.write('content\\n')\n          os.chdir(td.directory)\n          count = 0\n          for file_name in glob.glob('*.samp*'):\n              full_name = os.path.join(os.getcwd(), file_name)  # noqa\n              # print(full_name)\n              count += 1\n          os.chdir('/tmp')  # not using path\n          os.chdir(org_dir)\n      print('{} files found in temporary directory'.format(count))\n  \n  main()\n\n.. example code stage1.py\n\nwith some errors::\n\n  traceback (most recent call last):\n    file \"_example/stage1.py\", line 80, in <module>\n      main()\n    file \"_example/stage1.py\", line 77, in main\n      os.chdir(org_dir)\n    file \"_example/stage1.py\", line 56, in __exit__\n      self.remove()\n    file \"_example/stage1.py\", line 27, in remove\n      shutil.rmtree(self._tmpdir)\n    file \"/opt/python/2.7.13/lib/python2.7/shutil.py\", line 228, in rmtree\n      if os.path.islink(path):\n    file \"/home/venv/dev/lib/python2.7/posixpath.py\", line 135, in islink\n      st = os.lstat(path)\n  typeerror: coercing to unicode: need string or buffer, posixpath found\n\n\n.. example error_output stage1.py\n\ninstead of changing every usage in your program in one go, and\nhope it will work again, you replace the routines from the standard\nmodule::\n\n  # coding: utf-8\n  \n  import os\n  import glob\n  import tempfile\n  import shutil                       # noqa\n  import random\n  \n  from ruamel.std.pathlib import path, pathlibconversionhelper            # changed\n  pl = pathlibconversionhelper()                                          # added\n  \n  \n  class tempdir(object):\n      \"\"\"self removing (unless keep=true) temporary directory\"\"\"\n      def __init__(self, keep=false, basedir=none, prefix=none):\n          self._keep = keep\n          # mkdtemp creates with permissions rwx------\n          kw = dict(dir=basedir)\n          if prefix is not none:\n              kw['prefix'] = prefix\n          # mkdtemp doesn't do the right thing if none is passed in\n          # as it has prefix=template in definition\n          self._tmpdir = path(tempfile.mkdtemp(**kw))\n  \n      def remove(self):\n          pl.rmtree(self._tmpdir)\n  \n      def chdir(self):\n          os.chdir(self._tmpdir)\n  \n      def tempfilename(self, extension=''):\n          fd, name = pl.mkstemp(suffix=extension, dir=self._tmpdir)     # changed\n          os.close(fd)\n          return name\n  \n      def tempfilename2(self, extension=''):\n          while true:\n              name = pl.path.join(\n                  self._tmpdir,\n                  '%08d' % random.randint(0, 100000) + extension\n              )\n              if not pl.path.exists(name):                              # changed\n                  break\n          return name\n  \n      @property\n      def directory(self):\n          return self._tmpdir\n  \n      def __enter__(self):\n          return self\n  \n      def __exit__(self, exc_type, exc_val, exc_tb):\n          if not self._keep:\n              self.remove()\n  \n  \n  def main():\n      \"\"\"contrived example using tempdir\"\"\"\n      org_dir = os.getcwd()\n      with tempdir() as td:\n          for n in range(3):\n              t1 = td.tempfilename(extension='.sample')\n              with open(t1, 'w') as fp:\n                  fp.write('content\\n')\n          t2 = td.tempfilename2(extension='.sample2')\n          with pl.open(t2, 'w') as fp:\n              c = 'content\\n'                                           # added\n              if not isinstance(fp, file):                              # added\n                  c = unicode(c)                                        # added\n              fp.write(c)                                               # changed\n          pl.chdir(td.directory)\n          count = 0\n          for file_name in glob.glob('*.samp*'):\n              full_name = pl.path.join(os.getcwd(), file_name)  # noqa  # changed\n              # print(full_name)\n              count += 1\n          pl.chdir('/tmp')  # not using path\n          pl.chdir(org_dir)                                             # changed\n      print('{} files found in temporary directory'.format(count))\n  \n  main()\n\n.. example code stage2.py\n\ngiving (again)::\n\n  4 files found in temporary directory\n\n\n.. example output stage2.py\n\nchange back just the creation of ``self._tempdir`` to the original::\n\n  self._tmpdir = tempfile.mkdtemp(**kw)\n\nand the output stays::\n\n  4 files found in temporary directory\n\n\n.. example output stage2org.py\n\n\nif you now change the creation of ``pl`` to::\n\n  pl = pathlibconversionhelper(check=2)\n\nyou get as output::\n\n  update .mkstemp to use path.mkstemp() [_example/stage3.py:34 / path (true,)]\n  update .path.join to use \"/\" [_example/stage3.py:42 / path (true, false)]\n  update .exists to use path.exists() [_example/stage3.py:44 / path (true,)]\n  update .open to use path.open() [_example/stage3.py:69 / path (true,)]\n  update .chdir to use path.chdir() or os.chdir(str(path)) [_example/stage3.py:74 / path (true,)]\n  update .path.join to use \"/\" [_example/stage3.py:77 / path (false, false)]\n  update .chdir to use path.chdir() or os.chdir(str(path)) [_example/stage3.py:80 / path (false,)]\n  update .chdir to use path.chdir() or os.chdir(str(path)) [_example/stage3.py:81 / path (false,)]\n  update .rmtree to use path.rmtree() or shutil.rmtree(str(path)) [_example/stage3.py:28 / path (true,)]\n  4 files found in temporary directory\n\n\n.. example output stage3.py\n\nif you use ``check=1`` and at the end ``pl.dump()``, you get::\n\n  4 files found in temporary directory\n  update .path.join to use \"/\" [_example/stage4.py:42 / 1 / path (true, false)]\n  update .chdir to use path.chdir() or os.chdir(str(path)) [_example/stage4.py:81 / 1 / path (false,)]\n  update .path.join to use \"/\" [_example/stage4.py:77 / 4 / path (false, false)]\n  update .chdir to use path.chdir() or os.chdir(str(path)) [_example/stage4.py:80 / 1 / path (false,)]\n\n\n.. example output stage4.py\n\nshowing where you still use string based paths/filenames.\n\nthe message\npart ``file_name.py: 123 / 2 / path (true, false)`` means that there\nwere two calls on line 123 in ``file_name.py`` and that they were called with\nthe first parameter being a path, the second not being a path (when replacing\n``os.path.join()`` with path's ``\"/\"`` concatenation operator that would\nbe a good starting point, for other situation you might want to convert\nthe second parameter to a path instance as well).\n\nextending ``pathlibconversionhelper``\n-------------------------------------\n\nif ``pathlibconversionhelper`` doesn't contain a particular function (yet)\nyou can easily subclass it and add your own::\n\n  from ruamel.std.pathlib import path, pathlibconversionhelper\n  \n  \n  class myplch(pathlibconversionhelper):\n      # an example, ruamel.std.pathlib already adds mkstemp\n      def mkstemp(self, suffix=\"\", prefix=none, dir=none, text=false):\n          import tempfile\n          # would be much better if prefix defaults to built-in value (int, none, string)\n          if prefix is none:\n              prefix = tempfile.template\n          self.__add_usage(dir, 'update .mkstemp to use path.mkstemp()')\n          if isinstance(dir, path):\n              dir = str(dir)\n          return tempfile.mkstemp(suffix, prefix, dir, text)\n  \n  pl = myplch(check=1)\n\n.. example code extend.py\n\nthe first parameter for ``self.add_usage()`` is used to determine if\na path is used or not. this should be a list of all relevant variables\n(that could be ``path`` instances or not). if the list would only have a\nsingle element it doesn't have to be passed in as a list (as in the\nexample). the second parameter should be a string with some help on further\ngetting rid of the call to ``.mkstemp()``.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "ruamel.std.pathlib",
  "package_url": "https://pypi.org/project/ruamel.std.pathlib/",
  "project_url": "https://pypi.org/project/ruamel.std.pathlib/",
  "project_urls": {
    "Homepage": "https://sourceforge.net/p/ruamel-std-pathlib/code/ci/default/tree"
  },
  "release_url": "https://pypi.org/project/ruamel.std.pathlib/0.12.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "improvements over the standard pathlib module and pathlib2 package",
  "version": "0.12.0",
  "releases": [],
  "developers": [
    "a.van.der.neut@ruamel.eu",
    "anthon_van_der_neut"
  ],
  "kwds": "pathlib2 pathlib ruamel pathlibconversionhelper posixpath",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_ruamel.std.pathlib",
  "homepage": "https://sourceforge.net/p/ruamel-std-pathlib/code/ci/default/tree",
  "release_count": 16,
  "dependency_ids": []
}