{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing"
  ],
  "description": "************************************************************\nfixtures: fixtures with cleanups for testing and convenience\n************************************************************\n\n*fixtures* defines a python contract for reusable state / support logic,\nprimarily for unit testing. helper and adaption logic is included to make it\neasy to write your own fixtures using the fixtures contract. glue code is\nprovided that makes using fixtures that meet the ``fixtures`` contract in\n``unittest`` compatible test cases easy and straight forward.\n\ndependencies\n============\n\n* python 3.7+\n  this is the base language fixtures is written in and for.\n\n* ``pbr``\n  used for version and release management of fixtures.\n\nthe ``fixtures[streams]`` extra adds:\n\n* ``testtools`` <https://launchpad.net/testtools>\n\n  ``testtools`` provides helpful glue functions for the details api used to report\n  information about a fixture (whether its used in a testing or production\n  environment).\n\nfor use in a unit test suite using the included glue, you will need a test\nenvironment that supports ``testcase.addcleanup``. writing your own glue code\nis easy. alternatively, you can simply use fixtures directly without any\nsupport code.\n\nto run the test suite for fixtures, ``testtools`` is needed.\n\nwhy fixtures\n============\n\nstandard python ``unittest`` provides no obvious method for making and reusing\nstate needed in a test case other than by adding a method on the test class.\nthis scales poorly - complex helper functions propagating up a test class\nhierarchy is a regular pattern when this is done. mocking, while a great tool,\ndoesn't itself prevent this (and helpers to mock complex things can accumulate\nin the same way if placed on the test class).\n\nby defining a uniform contract where helpers have no dependency on the test\nclass we permit all the regular code hygiene activities to take place without\nthe distorting influence of being in a class hierarchy that is modelling an\nentirely different thing - which is what helpers on a ``testcase`` suffer from.\n\nabout fixtures\n==============\n\na fixture represents some state. each fixture has attributes on it that are\nspecific to the fixture. for instance, a fixture representing a directory that\ncan be used for temporary files might have a attribute ``path``.\n\nmost fixtures have complete ``pydoc`` documentation, so be sure to check\n``pydoc fixtures`` for usage information.\n\ncreating fixtures\n=================\n\nminimally, subclass ``fixture``, define ``_setup`` to initialize your state,\nschedule a cleanup for when ``cleanup`` is called, and you're done::\n\n  >>> import unittest\n  >>> import fixtures\n  >>> class noddyfixture(fixtures.fixture):\n  ...     def _setup(self):\n  ...         self.frobnozzle = 42\n  ...         self.addcleanup(delattr, self, 'frobnozzle')\n\nthis will initialize ``frobnozzle`` when ``setup`` is called, and when\n``cleanup`` is called get rid of the ``frobnozzle`` attribute. prior to version\n1.3.0 *fixtures* recommended overriding ``setup``. this is still supported, but\nsince it is harder to write leak-free fixtures in this fashion, it is not\nrecommended.\n\nif your fixture has diagnostic data - for instance the log file of an\napplication server, or log messages - it can expose that by creating a content\nobject (``testtools.content.content``) and calling ``adddetail``::\n\n  >>> from testtools.content import text_content\n  >>> class withlog(fixtures.fixture):\n  ...     def _setup(self):\n  ...         self.adddetail('message', text_content('foo bar baz'))\n\nthe method ``usefixture`` will use another fixture, call ``setup`` on it, call\n``self.addcleanup(thefixture.cleanup)``, attach any details from it and return\nthe fixture. this allows simple composition of different fixtures::\n\n  >>> class reusingfixture(fixtures.fixture):\n  ...     def _setup(self):\n  ...         self.noddy = self.usefixture(noddyfixture())\n\nthere is a helper for adapting a function or function pair into fixtures. it\nputs the result of the function in ``fn_result``::\n\n  >>> import os.path\n  >>> import shutil\n  >>> import tempfile\n  >>> def setup_function():\n  ...     return tempfile.mkdtemp()\n  >>> def teardown_function(fixture):\n  ...     shutil.rmtree(fixture)\n  >>> fixture = fixtures.functionfixture(setup_function, teardown_function)\n  >>> fixture.setup()\n  >>> print (os.path.isdir(fixture.fn_result))\n  true\n  >>> fixture.cleanup()\n\nthis can be expressed even more pithily::\n\n  >>> fixture = fixtures.functionfixture(tempfile.mkdtemp, shutil.rmtree)\n  >>> fixture.setup()\n  >>> print (os.path.isdir(fixture.fn_result))\n  true\n  >>> fixture.cleanup()\n\nanother variation is ``methodfixture`` which is useful for adapting alternate\nfixture implementations to fixture::\n\n  >>> class myserver:\n  ...    def start(self):\n  ...        pass\n  ...    def stop(self):\n  ...        pass\n  >>> server = myserver()\n  >>> fixture = fixtures.methodfixture(server, server.start, server.stop)\n\nyou can also combine existing fixtures using ``compoundfixture``::\n\n  >>> noddy_with_log = fixtures.compoundfixture([noddyfixture(),\n  ...                                            withlog()])\n  >>> with noddy_with_log as x:\n  ...     print (x.fixtures[0].frobnozzle)\n  42\n\nthe fixture api\n===============\n\nthe example above introduces some of the ``fixture`` api. in order to be able\nto clean up after a fixture has been used, all fixtures define a ``cleanup``\nmethod which should be called when a fixture is finished with.\n\nbecause it's nice to be able to build a particular set of related fixtures in\nadvance of using them, fixtures also have a ``setup`` method which should be\ncalled before trying to use them.\n\none common desire with fixtures that are expensive to create is to reuse them\nin many test cases; to support this the base ``fixture`` also defines a\n``reset`` which calls ``self.cleanup(); self.setup()``. fixtures that can more\nefficiently make themselves reusable should override this method. this can then\nbe used with multiple test state via things like ``testresources``,\n``setupclass``, or ``setupmodule``.\n\nwhen using a fixture with a test you can manually call the ``setup`` and\n``cleanup`` methods. more convenient though is to use the included glue from\n``fixtures.testwithfixtures`` which provides a mixin defining ``usefixture``\n(camel case because ``unittest`` is camel case throughout) method. it will call\n``setup`` on the fixture, call ``self.addcleanup(fixture)`` to schedule a\ncleanup, and return the fixture. this lets one write::\n\n  >>> import testtools\n  >>> import unittest\n\nnote that we use ``testtools.testcase``. ``testtools`` has it's own\nimplementation of ``usefixture`` so there is no need to use\n``fixtures.testwithfixtures`` with ``testtools.testcase``::\n\n  >>> class noddytest(testtools.testcase, fixtures.testwithfixtures):\n  ...     def test_example(self):\n  ...         fixture = self.usefixture(noddyfixture())\n  ...         self.assertequal(42, fixture.frobnozzle)\n  >>> result = unittest.testresult()\n  >>> _ = noddytest('test_example').run(result)\n  >>> print (result.wassuccessful())\n  true\n\nfixtures implement the context protocol, so you can also use a fixture as a\ncontext manager::\n\n  >>> with fixtures.functionfixture(setup_function, teardown_function) as fixture:\n  ...    print (os.path.isdir(fixture.fn_result))\n  true\n\nwhen multiple cleanups error, ``fixture.cleanup()`` will raise a wrapper\nexception rather than choosing an arbitrary single exception to raise::\n\n  >>> import sys\n  >>> from fixtures.fixture import multipleexceptions\n  >>> class brokenfixture(fixtures.fixture):\n  ...     def _setup(self):\n  ...         self.addcleanup(lambda:1/0)\n  ...         self.addcleanup(lambda:1/0)\n  >>> fixture = brokenfixture()\n  >>> fixture.setup()\n  >>> try:\n  ...    fixture.cleanup()\n  ... except multipleexceptions:\n  ...    exc_info = sys.exc_info()\n  >>> print (exc_info[1].args[0][0].__name__)\n  zerodivisionerror\n\nfixtures often expose diagnostic details that can be useful for tracking down\nissues. the ``getdetails`` method will return a dict of all the attached\ndetails but can only be called before ``cleanup`` is called. each detail\nobject is an instance of ``testtools.content.content``::\n\n  >>> with withlog() as l:\n  ...     print(l.getdetails()['message'].as_text())\n  foo bar baz\n\nerrors in setup\n+++++++++++++++\n\nthe examples above used ``_setup`` rather than ``setup`` because the base\nclass implementation of ``setup`` acts to reduce the chance of leaking\nexternal resources if an error is raised from ``_setup``. specifically,\n``setup`` contains a try/except block which catches all exceptions, captures\nany registered detail objects, and calls ``self.cleanup`` before propagating\nthe error. as long as you take care to register any cleanups before calling\nthe code that may fail, this will cause them to be cleaned up. the captured\ndetail objects are provided to the args of the raised exception.\n\nif the error that occurred was a subclass of ``exception`` then ``setup`` will\nraise ``multipleexceptions`` with the last element being a ``setuperror`` that\ncontains the detail objects. otherwise, to prevent causing normally\nuncatchable errors like ``keyboardinterrupt`` being caught inappropriately in\nthe calling layer, the original exception will be raised as-is and no\ndiagnostic data other than that from the original exception will be available.\n\nshared dependencies\n+++++++++++++++++++\n\na common use case within complex environments is having some fixtures shared by\nother ones.\n\nconsider the case of testing using a ``tempdir`` with two fixtures built on top\nof it; say a small database and a web server. writing either one is nearly\ntrivial. however handling ``reset()`` correctly is hard: both the database and\nweb server would reasonably expect to be able to discard operating system\nresources they may have open within the temporary directory before its removed.\na recursive ``reset()`` implementation would work for one, but not both.\ncalling ``reset()`` on the ``tempdir`` instance between each test is probably\ndesirable but we don't want to have to do a complete ``cleanup`` of the higher\nlayer fixtures (which would make the ``tempdir`` be unused and trivially\nresettable. we have a few options available to us.\n\nimagine that the webserver does not depend on the db fixture in any way - we\njust want the webserver and db fixture to coexist in the same tempdir.\n\na simple option is to just provide an explicit dependency fixture for the\nhigher layer fixtures to use.  this pushes complexity out of the core and onto\nusers of fixtures::\n\n  >>> class withdep(fixtures.fixture):\n  ...     def __init__(self, tempdir, dependency_fixture):\n  ...         super(withdep, self).__init__()\n  ...         self.tempdir = tempdir\n  ...         self.dependency_fixture = dependency_fixture\n  ...     def setup(self):\n  ...         super(withdep, self).setup()\n  ...         self.addcleanup(self.dependency_fixture.cleanup)\n  ...         self.dependency_fixture.setup()\n  ...         # we assume that at this point self.tempdir is usable.\n  >>> db = withdep\n  >>> webserver = withdep\n  >>> tempdir = fixtures.tempdir()\n  >>> db = db(tempdir, tempdir)\n  >>> server = webserver(tempdir, db)\n  >>> server.setup()\n  >>> server.cleanup()\n\nanother option is to write the fixtures to gracefully handle a dependency\nbeing reset underneath them. this is insufficient if the fixtures would\nblock the dependency resetting (for instance by holding file locks open\nin a tempdir - on windows this will prevent the directory being deleted).\n\nanother approach which ``fixtures`` neither helps nor hinders is to raise\na signal of some sort for each user of a fixture before it is reset. in the\nexample here, ``tempdir`` might offer a subscribers attribute that both the\ndb and web server would be registered in. calling ``reset`` or ``cleanup``\non the tempdir would trigger a callback to all the subscribers; the db and\nweb server reset methods would look something like::\n\n  >>> def reset(self):\n  ...     if not self._cleaned:\n  ...         self._clean()\n\n(their action on the callback from the tempdir would be to do whatever work\nwas needed and set ``self._cleaned``.) this approach has the (perhaps)\nsurprising effect that resetting the webserver may reset the db - if the\nwebserver were to be depending on ``tempdir.reset`` as a way to reset the\nwebserver's state.\n\nanother approach which is not currently implemented is to provide an object\ngraph of dependencies and a reset mechanism that can traverse that, along with\na separation between 'reset starting' and 'reset finishing' - the db and\nwebserver would both have their ``reset_starting`` methods called, then the\ntempdir would be reset, and finally the db and webserver would have\n``reset_finishing`` called.\n\nstock fixtures\n==============\n\nin addition to the ``fixture``, ``functionfixture`` and ``methodfixture``\nclasses, fixtures includes a number of pre-canned fixtures. the api docs for\nfixtures will list the complete set of these, should the docs be out of date or\nnot to hand. for the complete feature set of each fixture please see the api\ndocs.\n\n``bytestream``\n++++++++++++++\n\ntrivial adapter to make a ``bytesio`` (though it may in future auto-spill to\ndisk for large content) and expose that as a detail object, for automatic\ninclusion in test failure descriptions. very useful in combination with\n``monkeypatch``::\n\n  >>> fixture = fixtures.stringstream('my-content')\n  >>> fixture.setup()\n  >>> with fixtures.monkeypatch('sys.something', fixture.stream):\n  ...     pass\n  >>> fixture.cleanup()\n\nthis requires the ``fixtures[streams]`` extra.\n\n``environmentvariable``\n+++++++++++++++++++++++\n\nisolate your code from environmental variables, delete them or set them to a\nnew value::\n\n  >>> fixture = fixtures.environmentvariable('home')\n\n``fakelogger``\n++++++++++++++\n\nisolate your code from an external logging configuration - so that your test\ngets the output from logged messages, but they don't go to e.g. the console::\n\n  >>> fixture = fixtures.fakelogger()\n\n``fakepopen``\n+++++++++++++\n\npretend to run an external command rather than needing it to be present to run\ntests::\n\n  >>> from io import bytesio\n  >>> fixture = fixtures.fakepopen(lambda _:{'stdout': bytesio('foobar')})\n\n``loghandler``\n++++++++++++++\n\nreplace or extend a logger's handlers. the behavior of this fixture depends on\nthe value of the ``nuke_handlers`` parameter: if ``true``, the logger's\nexisting handlers are removed and replaced by the provided handler, while if\n``false`` the logger's set of handlers is extended by the provided handler::\n\n  >>> from logging import streamhandler\n  >>> fixture = fixtures.loghandler(streamhandler())\n\n``mockpatchobject``\n+++++++++++++++++++\n\nadapts ``mock.patch.object`` to be used as a fixture::\n\n  >>> class fred:\n  ...     value = 1\n  >>> fixture = fixtures.mockpatchobject(fred, 'value', 2)\n  >>> with fixture:\n  ...     fred().value\n  2\n  >>> fred().value\n  1\n\n``mockpatch``\n+++++++++++++\n\nadapts ``mock.patch`` to be used as a fixture::\n\n  >>> fixture = fixtures.mockpatch('subprocess.popen.returncode', 3)\n\n``mockpatchmultiple``\n+++++++++++++++++++++\n\nadapts ``mock.patch.multiple`` to be used as a ``fixture``::\n\n  >>> fixture = fixtures.mockpatchmultiple('subprocess.popen', returncode=3)\n\n``monkeypatch``\n+++++++++++++++\n\ncontrol the value of a named python attribute::\n\n  >>> def fake_open(path, mode):\n  ...     pass\n  >>> fixture = fixtures.monkeypatch('__builtin__.open', fake_open)\n\nnote that there are some complexities when patching methods - please see the\napi documentation for details.\n\n``nestedtempfile``\n++++++++++++++++++\n\nchange the default directory that the ``tempfile`` module places temporary\nfiles and directories in. this can be useful for containing the noise created\nby code which doesn't clean up its temporary files. this does not affect\ntemporary file creation where an explicit containing directory was provided::\n\n  >>> fixture = fixtures.nestedtempfile()\n\n``packagepathentry``\n++++++++++++++++++++\n\nadds a single directory to the path for an existing python package. this adds\nto the ``package.__path__`` list. if the directory is already in the path,\nnothing happens, if it isn't then it is added on ``setup`` and removed on\n``cleanup``::\n\n  >>> fixture = fixtures.packagepathentry('package/name', '/foo/bar')\n\n``pythonpackage``\n+++++++++++++++++\n\ncreates a python package directory. particularly useful for testing code that\ndynamically loads packages/modules, or for mocking out the command line entry\npoints to python programs::\n\n  >>> fixture = fixtures.pythonpackage('foo.bar', [('quux.py', '')])\n\n``pythonpathentry``\n+++++++++++++++++++\n\nadds a single directory to ``sys.path``. if the directory is already in the\npath, nothing happens, if it isn't then it is added on ``setup`` and removed on\n``cleanup``::\n\n  >>> fixture = fixtures.pythonpathentry('/foo/bar')\n\n``stream``\n++++++++++\n\ntrivial adapter to expose a file-like object as a detail object, for automatic\ninclusion in test failure descriptions. ``stringstream`` and ``bytesstream``\nprovided concrete users of this fixture.\n\nthis requires the ``fixtures[streams]`` extra.\n\n``stringstream``\n++++++++++++++++\n\ntrivial adapter to make a ``stringio`` (though it may in future auto-spill to\ndisk for large content) and expose that as a detail object, for automatic\ninclusion in test failure descriptions. very useful in combination with\n``monkeypatch``::\n\n  >>> fixture = fixtures.stringstream('stdout')\n  >>> fixture.setup()\n  >>> with fixtures.monkeypatch('sys.stdout', fixture.stream):\n  ...     pass\n  >>> fixture.cleanup()\n\nthis requires the ``fixtures[streams]`` extra.\n\n``tempdir``\n+++++++++++\n\ncreate a temporary directory and clean it up later::\n\n  >>> fixture = fixtures.tempdir()\n\nthe created directory is stored in the ``path`` attribute of the fixture after\n``setup``.\n\n``temphomedir``\n+++++++++++++++\n\ncreate a temporary directory and set it as ``$home`` in the environment::\n\n  >>> fixture = fixtures.temphomedir()\n\nthe created directory is stored in the ``path`` attribute of the fixture after\n``setup``.\n\nthe environment will now have ``$home`` set to the same path, and the value\nwill be returned to its previous value after ``teardown``.\n\n``timeout``\n+++++++++++\n\naborts if the covered code takes more than a specified number of whole wall-clock\nseconds.\n\nthere are two possibilities, controlled by the ``gentle`` argument: when gentle,\nan exception will be raised and the test (or other covered code) will fail.\nwhen not gentle, the entire process will be terminated, which is less clean,\nbut more likely to break hangs where no python code is running.\n\n.. caution::\n\n   only one timeout can be active at any time across all threads in a single\n   process.  using more than one has undefined results.  (this could be improved\n   by chaining alarms.)\n\n.. note::\n\n   currently supported only on unix because it relies on the ``alarm`` system\n   call.\n\n``warningscapture``\n+++++++++++++++++++\n\ncapture warnings for later analysis::\n\n  >>> fixture = fixtures.warningscapture()\n\nthe captured warnings are stored in the ``captures`` attribute of the fixture\nafter ``setup``.\n\n``warningsfilter``\n++++++++++++++++++\n\nconfigure warnings filters during test runs::\n\n  >>> fixture = fixtures.warningsfilter(\n  ...     [\n  ...         {\n  ...             'action': 'ignore',\n  ...             'message': 'foo',\n  ...             'category': deprecationwarning,\n  ...         },\n  ...     ]\n  ... )\n\norder is important: entries closer to the front of the list override entries\nlater in the list, if both match a particular warning.\n\ncontributing\n============\n\nfixtures has its project homepage on github\n<https://github.com/testing-cabal/fixtures>.\n\nlicense\n=======\n\n  copyright (c) 2010, robert collins <robertc@robertcollins.net>\n\n  licensed under either the apache license, version 2.0 or the bsd 3-clause\n  license at the users choice. a copy of both licenses are available in the\n  project source as apache-2.0 and bsd. you may not use this file except in\n  compliance with one of these two licences.\n\n  unless required by applicable law or agreed to in writing, software\n  distributed under these licenses is distributed on an \"as is\" basis, without\n  warranties or conditions of any kind, either express or implied.  see the\n  license you chose for the specific language governing permissions and\n  limitations under that license.\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "fixtures",
  "package_url": "https://pypi.org/project/fixtures/",
  "project_url": "https://pypi.org/project/fixtures/",
  "project_urls": {
    "Homepage": "https://github.com/testing-cabal/fixtures"
  },
  "release_url": "https://pypi.org/project/fixtures/4.1.0/",
  "requires_dist": [
    "pbr (>=5.7.0)",
    "docutils ; extra == 'docs'",
    "testtools ; extra == 'streams'",
    "mock ; extra == 'test'",
    "testtools ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "fixtures, reusable state for writing clean tests and more.",
  "version": "4.1.0",
  "releases": [],
  "developers": [
    "robert_collins",
    "robertc@robertcollins.net"
  ],
  "kwds": "dependency_fixture fixtures fixture python testresources",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_fixtures",
  "homepage": "https://github.com/testing-cabal/fixtures",
  "release_count": 33,
  "dependency_ids": [
    "pypi_docutils",
    "pypi_mock",
    "pypi_pbr",
    "pypi_testtools"
  ]
}