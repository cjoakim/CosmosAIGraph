{
  "classifiers": [],
  "description": "# sqlite-fts4\n\n[![pypi](https://img.shields.io/pypi/v/sqlite-fts4.svg)](https://pypi.org/project/sqlite-fts4/)\n[![changelog](https://img.shields.io/github/v/release/simonw/sqlite-fts4?include_prereleases&label=changelog)](https://github.com/simonw/sqlite-fts4/releases)\n[![tests](https://github.com/simonw/sqlite-fts4/workflows/test/badge.svg)](https://github.com/simonw/sqlite-fts4/actions?query=workflow%3atest)\n[![license](https://img.shields.io/badge/license-apache%202.0-blue.svg)](https://github.com/simonw/sqlite-fts4/blob/main/license)\n\ncustom sqlite functions written in python for ranking documents indexed using the fts4 extension.\n\nread [exploring search relevance algorithms with sqlite](https://simonwillison.net/2019/jan/7/exploring-search-relevance-algorithms-sqlite/) for further details on this project.\n\n## demo\n\nyou can try out these sql functions [using this interactive demo](https://datasette-sqlite-fts4.datasette.io/24ways-fts4?sql=select%0d%0a++++json_object%28%0d%0a++++++++\"label\"%2c+articles.title%2c+\"href\"%2c+articles.url%0d%0a++++%29+as+article%2c%0d%0a++++articles.author%2c%0d%0a++++rank_score%28matchinfo%28articles_fts%2c+\"pcx\"%29%29+as+score%2c%0d%0a++++rank_bm25%28matchinfo%28articles_fts%2c+\"pcnalx\"%29%29+as+bm25%2c%0d%0a++++json_object%28%0d%0a++++++++\"pre\"%2c+annotate_matchinfo%28matchinfo%28articles_fts%2c+\"pcxnalyb\"%29%2c+\"pcxnalyb\"%29%0d%0a++++%29+as+annotated_matchinfo%2c%0d%0a++++matchinfo%28articles_fts%2c+\"pcxnalyb\"%29+as+matchinfo%2c%0d%0a++++decode_matchinfo%28matchinfo%28articles_fts%2c+\"pcxnalyb\"%29%29+as+decoded_matchinfo%0d%0afrom%0d%0a++++articles_fts+join+articles+on+articles.rowid+%3d+articles_fts.rowid%0d%0awhere%0d%0a++++articles_fts+match+%3asearch%0d%0aorder+by+bm25&search=jquery+maps).\n\n## installation\n\n    pip install sqlite-fts4\n\n## usage\n\nthis module implements several custom sqlite3 functions. you can register them against an existing sqlite connection like so:\n\n```python\nimport sqlite3\nfrom sqlite_fts4 import register_functions\n\nconn = sqlite3.connect(\":memory:\")\nregister_functions(conn)\n```\n\nif you only want a subset of the functions registered you can do so like this:\n\n```python\nfrom sqlite_fts4 import rank_score\n\nconn = sqlite3.connect(\":memory:\")\nconn.create_function(\"rank_score\", 1, rank_score)\n```\n\nif you want to use these functions with [datasette](https://github.com/simonw/datasette) you can enable them by installing the [datasette-sqlite-fts4](https://github.com/simonw/datasette-sqlite-fts4) plugin:\n\n    pip install datasette-sqlite-fts4\n\n## rank_score()\n\nthis is an extremely simple ranking function, based on [an example](https://www.sqlite.org/fts3.html#appendix_a) in the sqlite documentation. it generates a score for each document using the sum of the score for each column. the score for each column is calculated as the number of search matches in that column divided by the number of search matches for every column in the index - a classic [tf-idf](https://en.wikipedia.org/wiki/tf%e2%80%93idf) calculation.\n\nyou can use it in a query like this:\n\n```sql\nselect *, rank_score(matchinfo(docs, \"pcx\")) as score\nfrom docs where docs match \"dog\"\norder by score desc\n```\n\nyou *must* use the `\"pcx\"` matchinfo format string here, or you will get incorrect results.\n\n## rank_bm25()\n\nan implementation of the [okapi bm25](https://en.wikipedia.org/wiki/okapi_bm25) scoring algorithm. use it in a query like this:\n\n```sql\nselect *, rank_bm25(matchinfo(docs, \"pcnalx\")) as score\nfrom docs where docs match \"dog\"\norder by score desc\n```\n\nyou *must* use the `\"pcnalx\"` matchinfo format string here, or you will get incorrect results. if you see any `math domain` errors in your logs it may be because you did not use exactly the right format string here.\n\n## decode_matchinfo()\n\nsqlite's [built-in matchinfo() function](https://www.sqlite.org/fts3.html#matchinfo) returns results as a binary string. this binary represents a list of 32 bit unsigned integers, but reading the binary results is not particularly human-friendly.\n\nthe `decode_matchinfo()` function decodes the binary string and converts it into a json list of integers.\n\nusage:\n\n```sql\nselect *, decode_matchinfo(matchinfo(docs, \"pcx\"))\nfrom docs where docs match \"dog\"\n```\n\nexample output:\n\n    hello dog, [1, 1, 1, 1, 1]\n\n## annotate_matchinfo()\n\nthis function decodes the matchinfo document into a verbose json structure that describes exactly what each of the returned integers actually means.\n\nfull documentation for the different format string options can be found here: https://www.sqlite.org/fts3.html#matchinfo\n\nyou need to call this function with the same format string as was passed to `matchinfo()` - for example:\n\n```sql\nselect annotate_matchinfo(matchinfo(docs, \"pcxnal\"), \"pcxnal\")\nfrom docs where docs match \"dog\"\n```\n\nthe returned json will include a key for each letter in the format string. for example:\n\n```json\n{\n    \"p\": {\n        \"value\": 1,\n        \"title\": \"number of matchable phrases in the query\"\n    },\n    \"c\": {\n        \"value\": 1,\n        \"title\": \"number of user defined columns in the fts table\"\n    },\n    \"x\": {\n        \"value\": [\n            {\n                \"column_index\": 0,\n                \"phrase_index\": 0,\n                \"hits_this_column_this_row\": 1,\n                \"hits_this_column_all_rows\": 2,\n                \"docs_with_hits\": 2\n            }\n        ],\n        \"title\": \"details for each phrase/column combination\"\n    },\n    \"n\": {\n        \"value\": 3,\n        \"title\": \"number of rows in the fts4 table\"\n    },\n    \"a\": {\n        \"title\":\"average number of tokens in the text values stored in each column\",\n        \"value\": [\n            {\n                \"column_index\": 0,\n                \"average_num_tokens\": 2\n            }\n        ]\n    },\n    \"l\": {\n        \"title\": \"length of value stored in current row of the fts4 table in tokens for each column\",\n        \"value\": [\n            {\n                \"column_index\": 0,\n                \"length_of_value\": 2\n            }\n        ]\n    }\n}\n```\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license, version 2.0",
  "name": "sqlite-fts4",
  "package_url": "https://pypi.org/project/sqlite-fts4/",
  "project_url": "https://pypi.org/project/sqlite-fts4/",
  "project_urls": {
    "CI": "https://github.com/simonw/sqlite-fts4/actions",
    "Changelog": "https://github.com/simonw/sqlite-fts4/releases",
    "Homepage": "https://github.com/simonw/sqlite-fts4",
    "Issues": "https://github.com/simonw/sqlite-fts4/issues"
  },
  "release_url": "https://pypi.org/project/sqlite-fts4/1.0.3/",
  "requires_dist": [
    "pytest ; extra == 'test'"
  ],
  "requires_python": "",
  "summary": "python functions for working with sqlite fts4 search",
  "version": "1.0.3",
  "releases": [],
  "developers": [
    "simon_willison"
  ],
  "kwds": "sqlite_fts4 sqlite sqlite3 changelog workflows",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_sqlite_fts4",
  "homepage": "https://github.com/simonw/sqlite-fts4",
  "release_count": 9,
  "dependency_ids": [
    "pypi_pytest"
  ]
}