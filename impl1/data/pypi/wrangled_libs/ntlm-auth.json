{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7"
  ],
  "description": "ntlm-auth\n=========\n\n|build status|\\ |build status|\\ |coverage status|\n\nabout this library\n------------------\n\nthis library handles the low-level details of ntlm authentication for\nuse in authenticating with a service that uses ntlm. it will create and\nparse the 3 different message types in the order required and produce a\nbase64 encoded value that can be attached to the http header.\n\nthe goal of this library is to offer full ntlm support including signing\nand sealing of messages as well as supporting mic for message integrity\nand the ability to customise and set limits on the messages sent. please\nsee features and backlog for a list of what is and is not currently\nsupported.\n\nfeatures\n--------\n\n-  lm, ntlm and ntlmv2 authentication\n-  ntlm1 and ntlm2 extended session security\n-  set the the ntlm compatibility level when sending messages\n-  channel binding tokens support, need to pass in the sha256 hash of\n   the certificate for it to work\n-  support for mic to enhance the integrity of the messages\n-  support for session security with signing and sealing messages after\n   authentication happens\n\ninstallation\n------------\n\nntlm-auth supports python 2.6, 2.7 and 3.3+\n\nto install, use pip:\n\n::\n\n   pip install ntlm-auth\n\nto install from source, download the source code, then run:\n\n::\n\n   python setup.py install\n\nusage\n-----\n\nalmost all users should use\n`requests-ntlm <https://github.com/requests/requests-ntlm>`__ instead of\nthis library. the library requests-ntlm is a plugin that uses this\nlibrary under the hood and provides an easier function to use and\nunderstand.\n\nif you are set on using ntlm-auth directly to compute the message\nstructures this is a very basic outline of how it can be done. the code\nexamples are psuedocode and should be adapted for your purpose.\n\nwhen initliasing the ntlm context you will have to supply the ntlm\ncompatibility level. the key difference between the different auth\nlevels are the ntlm_compatibility variable supplied when initialising\nntlm. an overview of what each sets is below; \\* ``0`` - lm auth and\nntlmv1 auth \\* ``1`` - lm auth and ntlmv1 auth with extended session\nsecurity (ntlm2) \\* ``2`` - ntlmv1 auth with extended session security\n(ntlm2) \\* ``3`` - ntlmv2 auth (default choice) \\* ``4`` - ntlmv2 auth\n\\* ``5`` - ntlmv2 auth\n\nlevel 3 to 5 are the same from a client perspective but differ with how\nthe server handles the auth which is outside this project\u2019s scope. this\nsetting is set independently on that server so choosing 3, 4 or 5 when\ncalling ntlm will make no difference at all. see\n`lmcompatibilitylevel <https://technet.microsoft.com/en-us/library/cc960646.aspx>`__\nfor more details.\n\nextended session security is a security feature designed to increase the\nsecurity of lm and ntlmv1 auth. it is no substitution for ntlmv2 but is\nbetter than nothing and should be used if possible when you need ntlmv1\ncompatibility.\n\nthe variables required are outlined below; \\* ``username`` - the\nusername to authenticate with, should not have the domain prefix,\ni.e.\u00a0user not domain\\user \\* ``password`` - the password of the user to\nauthenticate with \\* ``domain`` - the domain of the user, i.e.\u00a0domain.\ncan be blank if not in a domain environment \\* ``workstation`` - the\nworkstation you are running on. can be blank if you do not wish to send\nthis \\* ``cbt_data`` - (ntlmv2 only) the\n``gss_channel_bindings.gsschannelbindingsstruct`` used to bind with the\nauth response. can be none if no binding needs to occur\n\nlm auth/ntlmv1 auth\n^^^^^^^^^^^^^^^^^^^\n\nlm and ntlmv1 auth are older authentication methods that should be\navoided where possible. choosing between these authentication methods\nare almost identical expect where you specify the ntlm_compatiblity\nlevel.\n\n.. code:: python\n\n   import socket\n\n   from ntlm_auth.ntlm import ntlmcontext\n\n   username = 'user'\n   password = 'password'\n   domain = 'domain' # can be blank if you are not in a domain\n   workstation = socket.gethostname().upper() # can be blank if you wish to not send this info\n\n   ntlm_context = ntlmcontext(username, password, domain, workstation, ntlm_compatibility=0) # put the ntlm_compatibility level here, 0-2 for lm auth/ntlmv1 auth\n   negotiate_message = ntlm_context.step()\n\n   # attach the negotiate_message to your ntlm/negotiate http header and send to the server. get the challenge response back from the server\n   challenge_message = http.response.headers['headerfield']\n\n   authenticate_message = ntlm_context.step(challenge_message)\n\n   # attach the authenticate_message ot your ntlm_negotiate http header and send to the server. you are now authenticated with ntlmv1\n\nntlmv2\n^^^^^^\n\nntlmv2 auth is the newest ntlm auth method from microsoft and should be\nthe option chosen by default unless you require an older auth method.\nthe implementation is the same as ntlmv1 but with the addition of the\noptional ``server_certificate_hash`` variable and the\n``ntlm_compatibility`` is not specified.\n\n.. code:: python\n\n   import base64\n   import socket\n\n   from ntlm_auth.gss_channel_bindings import gsschannelbindingsstruct\n   from ntlm_auth.ntlm import ntlmcontext\n\n   username = 'user'\n   password = 'password'\n   domain = 'domain' # can be blank if you are not in a domain\n   workstation = socket.gethostname().upper() # can be blank if you wish to not send this info\n\n   # create the cbt struct if you wish to bind it with the auth response\n   server_certificate_hash = '96b2fc1ec30792619286a0c7fd62863e81a6564e72829cbc0a46f7b1d5d92a18'\n   certificate_digest = base64.b16decode(server_certificate_hash)\n   cbt_data = gsschannelbindingsstruct()\n   cbt_data[cbt_data.application_data] = b'tls-server-end-point:' + certificate_digest\n\n   ntlm_context = ntlmcontext(username, password, domain, workstation, cbt_data, ntlm_compatibility=3)\n   negotiate_message = ntlm_context.step()\n\n   # attach the negotiate_message to your ntlm/negotiate http header and send to the server. get the challenge response back from the server\n   challenge_message = http.response.headers['headerfield']\n\n   authenticate_message = ntlm_context.step(challenge_message)\n\n   # attach the authenticate_message ot your ntlm_negotiate http header and send to the server. you are now authenticated with ntlmv1\n\nsigning/sealing\n^^^^^^^^^^^^^^^\n\nall version of ntlm supports signing (integrity) and sealing\n(confidentiality) of message content. this function can add these\nimprovements to a message that is sent and received from the server.\nwhile it does encrypt the data if supported by the server it is only\ndone with rc4 with a 128-bit key which is not very secure and on older\nsystems this key length could be 56 or 40 bit. this functionality while\ntested and conforms with the microsoft documentation has yet to be fully\ntested in an integrated environment. once again this has not been\nthoroughly tested and has only passed unit tests and their expections.\n\n.. code:: python\n\n   import base64\n   import socket\n\n   from ntlm_auth.ntlm import ntlmcontext\n\n   username = 'user'\n   password = 'password'\n   domain = 'domain' # can be blank if you are not in a domain\n   workstation = socket.gethostname().upper() # can be blank if you wish to not send this info\n\n   # create the cbt struct if you wish to bind it with the auth response\n   server_certificate_hash = '96b2fc1ec30792619286a0c7fd62863e81a6564e72829cbc0a46f7b1d5d92a18'\n   certificate_digest = base64.b16decode(server_certificate_hash)\n   cbt_data = gsschannelbindingsstruct()\n   cbt_data[cbt_data.application_data] = b'tls-server-end-point:' + certificate_digest\n\n   ntlm_context = ntlmcontext(username, password, domain, workstation, cbt_data, ntlm_compatibility=3)\n   negotiate_message = ntlm_context.step()\n\n   # attach the negotiate_message to your ntlm/negotiate http header and send to the server. get the challenge response back from the server\n   challenge_message = http.response.headers['headerfield']\n\n   authenticate_message = ntlm_context.step(challenge_message)\n\n   # attach the authenticate_message ot your ntlm_negotiate http header and send to the server. you are now authenticated with ntlmv1\n\n   # encrypt the message with the wrapping function and send the message\n   enc_message = ntlm_context.wrap(\"message to send\", encrypt=true)\n   request.body = msg_data\n   request.send\n\n   # receive the response from the server and decrypt\n   response_msg = response.content\n   response = ntlm_context.unwrap(response_msg)\n\nbacklog\n-------\n\n-  automatically get windows version if running on windows, use default\n   if not that case\n-  add param when initialising the ntlm context to throw an exception\n   and cancel auth if the server doesn\u2019t support 128-bit keys for\n   sealing\n-  add param when initialising the ntlm context to not send the mic\n   structure for older servers\n-  add param to independently verify the target name returned from the\n   server and the value passed in\n\n.. |build status| image:: https://travis-ci.org/jborean93/ntlm-auth.svg?branch=master\n   :target: https://travis-ci.org/jborean93/ntlm-auth\n.. |build status| image:: https://ci.appveyor.com/api/projects/status/osvvfgmhfk4anvu0/branch/master?svg=true\n   :target: https://ci.appveyor.com/project/jborean93/ntlm-auth/branch/master\n.. |coverage status| image:: https://coveralls.io/repos/github/jborean93/ntlm-auth/badge.svg?branch=master\n   :target: https://coveralls.io/github/jborean93/ntlm-auth?branch=master\n\n\n",
  "docs_url": null,
  "keywords": "authentication auth microsoft ntlm lm",
  "license": "mit",
  "name": "ntlm-auth",
  "package_url": "https://pypi.org/project/ntlm-auth/",
  "project_url": "https://pypi.org/project/ntlm-auth/",
  "project_urls": {
    "Homepage": "https://github.com/jborean93/ntlm-auth"
  },
  "release_url": "https://pypi.org/project/ntlm-auth/1.5.0/",
  "requires_dist": [
    "ordereddict ; python_version<\"2.7\"",
    "cryptography (<2.2) ; (python_version<\"2.7\") and extra == 'cryptography'",
    "cryptography ; (python_version>=\"2.7\") and extra == 'cryptography'"
  ],
  "requires_python": ">=2.6,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*",
  "summary": "creates ntlm authentication structures",
  "version": "1.5.0",
  "releases": [],
  "developers": [
    "jborean93@gmail.com",
    "jordan_borean"
  ],
  "kwds": "ntlm_auth ntlm_compatibility ntlm_compatiblity ntlm_negotiate ntlm",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_ntlm_auth",
  "homepage": "https://github.com/jborean93/ntlm-auth",
  "release_count": 12,
  "dependency_ids": [
    "pypi_cryptography",
    "pypi_ordereddict"
  ]
}