{
  "classifiers": [
    "license :: osi approved :: mit license",
    "topic :: software development :: compilers",
    "topic :: text processing :: linguistic"
  ],
  "description": "# py-tree-sitter\n\n[![build status](https://github.com/tree-sitter/py-tree-sitter/actions/workflows/ci.yml/badge.svg)](https://github.com/tree-sitter/py-tree-sitter/actions/workflows/ci.yml)\n[![build status](https://ci.appveyor.com/api/projects/status/mde790v0v9gux85w/branch/master?svg=true)](https://ci.appveyor.com/project/maxbrunsfeld/py-tree-sitter/branch/master)\n\nthis module provides python bindings to the [tree-sitter](https://github.com/tree-sitter/tree-sitter)\nparsing library.\n\n## installation\n\nthis package currently only works with python 3. there are no library dependencies,\nbut you do need to have a c compiler installed.\n\n```sh\npip3 install tree_sitter\n```\n\n## usage\n\n### setup\n\nfirst you'll need a tree-sitter language implementation for each language that you\nwant to parse. you can clone some of the [existing language repos](https://github.com/tree-sitter)\nor [create your own](http://tree-sitter.github.io/tree-sitter/creating-parsers):\n\n```sh\ngit clone https://github.com/tree-sitter/tree-sitter-go\ngit clone https://github.com/tree-sitter/tree-sitter-javascript\ngit clone https://github.com/tree-sitter/tree-sitter-python\n```\n\nuse the `language.build_library` method to compile these into a library that's\nusable from python. this function will return immediately if the library has\nalready been compiled since the last time its source code was modified:\n\n```python\nfrom tree_sitter import language\n\nlanguage.build_library(\n    # store the library in the `build` directory\n    \"build/my-languages.so\",\n    # include one or more languages\n    [\"vendor/tree-sitter-go\", \"vendor/tree-sitter-javascript\", \"vendor/tree-sitter-python\"],\n)\n```\n\nload the languages into your app as `language` objects:\n\n```python\ngo_language = language(\"build/my-languages.so\", \"go\")\njs_language = language(\"build/my-languages.so\", \"javascript\")\npy_language = language(\"build/my-languages.so\", \"python\")\n```\n\n#### basic parsing\n\ncreate a `parser` and configure it to use one of the languages:\n\n```python\nparser = parser()\nparser.set_language(py_language)\n```\n\nparse some source code:\n\n```python\ntree = parser.parse(\n    bytes(\n        \"\"\"\ndef foo():\n    if bar:\n        baz()\n\"\"\",\n        \"utf8\",\n    )\n)\n```\n\nif you have your source code in some data structure other than a bytes object,\nyou can pass a \"read\" callable to the parse function.\n\nthe read callable can use either the byte offset or point tuple to read from\nbuffer and return source code as bytes object. an empty bytes object or none\nterminates parsing for that line. the bytes must encode the source as utf-8.\n\nfor example, to use the byte offset:\n\n```python\nsrc = bytes(\n    \"\"\"\ndef foo():\n    if bar:\n        baz()\n\"\"\",\n    \"utf8\",\n)\n\n\ndef read_callable(byte_offset, point):\n    return src[byte_offset : byte_offset + 1]\n\n\ntree = parser.parse(read_callable)\n```\n\nand to use the point:\n\n```python\nsrc_lines = [\"def foo():\\n\", \"    if bar:\\n\", \"        baz()\"]\n\n\ndef read_callable(byte_offset, point):\n    row, column = point\n    if row >= len(src_lines) or column >= len(src_lines[row]):\n        return none\n    return src_lines[row][column:].encode(\"utf8\")\n\n\ntree = parser.parse(read_callable)\n```\n\ninspect the resulting `tree`:\n\n```python\nroot_node = tree.root_node\nassert root_node.type == 'module'\nassert root_node.start_point == (1, 0)\nassert root_node.end_point == (3, 13)\n\nfunction_node = root_node.children[0]\nassert function_node.type == 'function_definition'\nassert function_node.child_by_field_name('name').type == 'identifier'\n\nfunction_name_node = function_node.children[1]\nassert function_name_node.type == 'identifier'\nassert function_name_node.start_point == (1, 4)\nassert function_name_node.end_point == (1, 7)\n\nassert root_node.sexp() == \"(module \"\n    \"(function_definition \"\n        \"name: (identifier) \"\n        \"parameters: (parameters) \"\n        \"body: (block \"\n            \"(if_statement \"\n                \"condition: (identifier) \"\n                \"consequence: (block \"\n                    \"(expression_statement (call \"\n                        \"function: (identifier) \"\n                        \"arguments: (argument_list))))))))\"\n```\n\n#### walking syntax trees\n\nif you need to traverse a large number of nodes efficiently, you can use\na `treecursor`:\n\n```python\ncursor = tree.walk()\n\nassert cursor.node.type == \"module\"\n\nassert cursor.goto_first_child()\nassert cursor.node.type == \"function_definition\"\n\nassert cursor.goto_first_child()\nassert cursor.node.type == \"def\"\n\n# returns `false` because the `def` node has no children\nassert not cursor.goto_first_child()\n\nassert cursor.goto_next_sibling()\nassert cursor.node.type == \"identifier\"\n\nassert cursor.goto_next_sibling()\nassert cursor.node.type == \"parameters\"\n\nassert cursor.goto_parent()\nassert cursor.node.type == \"function_definition\"\n```\n\n#### editing\n\nwhen a source file is edited, you can edit the syntax tree to keep it in sync with\nthe source:\n\n```python\ntree.edit(\n    start_byte=5,\n    old_end_byte=5,\n    new_end_byte=5 + 2,\n    start_point=(0, 5),\n    old_end_point=(0, 5),\n    new_end_point=(0, 5 + 2),\n)\n```\n\nthen, when you're ready to incorporate the changes into a new syntax tree,\nyou can call `parser.parse` again, but pass in the old tree:\n\n```python\nnew_tree = parser.parse(new_source, tree)\n```\n\nthis will run much faster than if you were parsing from scratch.\n\nthe `tree.get_changed_ranges` method can be called on the _old_ tree to return\nthe list of ranges whose syntactic structure has been changed:\n\n```python\nfor changed_range in tree.get_changed_ranges(new_tree):\n    print(\"changed range:\")\n    print(f\"  start point {changed_range.start_point}\")\n    print(f\"  start byte {changed_range.start_byte}\")\n    print(f\"  end point {changed_range.end_point}\")\n    print(f\"  end byte {changed_range.end_byte}\")\n```\n\n#### pattern-matching\n\nyou can search for patterns in a syntax tree using a _tree query_:\n\n```python\nquery = py_language.query(\n    \"\"\"\n(function_definition\n  name: (identifier) @function.def)\n\n(call\n  function: (identifier) @function.call)\n\"\"\"\n)\n\ncaptures = query.captures(tree.root_node)\nassert len(captures) == 2\nassert captures[0][0] == function_name_node\nassert captures[0][1] == \"function.def\"\n```\n\nthe `query.captures()` method takes optional `start_point`, `end_point`,\n`start_byte` and `end_byte` keyword arguments which can be used to restrict the\nquery's range. only one of the `..._byte` or `..._point` pairs need to be given\nto restrict the range. if all are omitted, the entire range of the passed node\nis used.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "tree-sitter",
  "package_url": "https://pypi.org/project/tree-sitter/",
  "project_url": "https://pypi.org/project/tree-sitter/",
  "project_urls": {
    "Homepage": "https://github.com/tree-sitter/py-tree-sitter",
    "Source": "https://github.com/tree-sitter/py-tree-sitter"
  },
  "release_url": "https://pypi.org/project/tree-sitter/0.20.4/",
  "requires_dist": [
    "setuptools >=60.0.0 ; python_version >= \"3.12\""
  ],
  "requires_python": ">=3.3",
  "summary": "python bindings for the tree-sitter parsing library",
  "version": "0.20.4",
  "releases": [],
  "developers": [
    "max_brunsfeld",
    "maxbrunsfeld@gmail.com"
  ],
  "kwds": "tree_sitter treecursor tree new_tree _tree",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_tree_sitter",
  "homepage": "https://github.com/tree-sitter/py-tree-sitter",
  "release_count": 21,
  "dependency_ids": [
    "pypi_setuptools"
  ]
}