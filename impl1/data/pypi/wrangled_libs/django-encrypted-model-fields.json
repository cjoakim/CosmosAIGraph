{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 2.2",
    "framework :: django :: 3.0",
    "framework :: django :: 3.1",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http",
    "topic :: security",
    "topic :: system :: systems administration :: authentication/directory"
  ],
  "description": "# django encrypted model fields\n\n[![image](https://travis-ci.org/lanshark/django-encrypted-model-fields.png)](https://travis-ci.org/lanshark/django-encrypted-model-fields)\n\n## about\n\nthis is a fork of\n<https://github.com/foundertherapy/django-cryptographic-fields>. it has\nbeen renamed, and updated to properly support python3 and latest\nversions of django.\n\n`django-encrypted-model-fields` is set of fields that wrap standard\ndjango fields with encryption provided by the python cryptography\nlibrary. these fields are much more compatible with a 12-factor design\nsince they take their encryption key from the settings file instead of a\nfile on disk used by `keyczar`.\n\nwhile keyczar is an excellent tool to use for encryption, it's not\ncompatible with python 3, and it requires, for hosts like heroku, that\nyou either check your key file into your git repository for deployment,\nor implement manual post-deployment processing to write the key stored\nin an environment variable into a file that keyczar can read.\n\n## generating an encryption key\n\nthere is a django management command `generate_encryption_key` provided\nwith the `encrypted_model_fields` library. use this command to generate\na new encryption key to set as `settings.field_encryption_key`:\n\n    ./manage.py generate_encryption_key\n\nrunning this command will print an encryption key to the terminal, which\ncan be configured in your environment or settings file.\n\n*note: this command will only work in a clean, new django project that\ndoes not import encrypted_model_fields in any of it's apps.* if you are\nalready importing encrypted_model_fields, try running this in a python\nshell instead:\n\n    import os\n    import base64\n\n    new_key = base64.urlsafe_b64encode(os.urandom(32))\n    print(new_key)\n\n## getting started\n\n> $ pip install django-encrypted-model-fields\n\nadd \"encrypted_model_fields\" to your installed_apps setting like this:\n\n    installed_apps = (\n        ...\n        'encrypted_model_fields',\n    )\n\n`django-encrypted-model-fields` expects the encryption key to be\nspecified using `field_encryption_key` in your project's `settings.py`\nfile. for example, to load it from the local environment:\n\n    import os\n\n    field_encryption_key = os.environ.get('field_encryption_key', '')\n\nto use an encrypted field in a django model, use one of the fields from\nthe `encrypted_model_fields` module:\n\n    from encrypted_model_fields.fields import encryptedcharfield\n\n    class encryptedfieldmodel(models.model):\n        encrypted_char_field = encryptedcharfield(max_length=100)\n\nfor fields that require `max_length` to be specified, the `encrypted`\nvariants of those fields will automatically increase the size of the\ndatabase field to hold the encrypted form of the content. for example, a\n3 character charfield will automatically specify a database field size\nof 100 characters when `encryptedcharfield(max_length=3)` is specified.\n\ndue to the nature of the encrypted data, filtering by values contained\nin encrypted fields won't work properly. sorting is also not supported.\n\n## development environment\n\nadded tox for testing with different versions of django and python. to get started:\npip install -r requirements/dev.txt\n\nusing `pyenv` add the requisite python interpreters::\npyenv install 3.6.15\n\npyenv install 3.7.12\n\npyenv install 3.8.12\n\npyenv install 3.9.10\n\npyenv install 3.10.2\n\nadd the requisite versions to the local version::\npyenv local 3.6.15 3.7.12 3.8.12 3.9.10 3.10.2\n\nrun `tox`::\ntox\n",
  "docs_url": null,
  "keywords": "encryption,django,fields",
  "license": "mit",
  "name": "django-encrypted-model-fields",
  "package_url": "https://pypi.org/project/django-encrypted-model-fields/",
  "project_url": "https://pypi.org/project/django-encrypted-model-fields/",
  "project_urls": {
    "Homepage": "https://gitlab.com/lansharkconsulting/django/django-encrypted-model-fields",
    "Repository": "https://gitlab.com/lansharkconsulting/django/django-encrypted-model-fields"
  },
  "release_url": "https://pypi.org/project/django-encrypted-model-fields/0.6.5/",
  "requires_dist": [
    "cryptography (>=3.4)",
    "Django (>=2.2)"
  ],
  "requires_python": ">=3.6,<4.0",
  "summary": "a set of fields that wrap standard django fields with encryption provided by the python cryptography library.",
  "version": "0.6.5",
  "releases": [],
  "developers": [
    "scott_sharkey",
    "ssharkey@lanshark.com"
  ],
  "kwds": "encrypted_model_fields field_encryption_key encryptedfieldmodel encrypted_char_field encryptedcharfield",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_django_encrypted_model_fields",
  "homepage": "https://gitlab.com/lansharkconsulting/django/django-encrypted-model-fields",
  "release_count": 9,
  "dependency_ids": [
    "pypi_cryptography",
    "pypi_django"
  ]
}