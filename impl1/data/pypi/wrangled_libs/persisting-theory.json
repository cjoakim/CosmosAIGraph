{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "introduction\n============\n\npersisting-theory is a small python utility designed to automate data discovering and access inside a list of packages. use case: you are building an application that will have pluggable components. you want to allow these components to register data so it can be accessed by any other component of your app.\nif you ever used django framework, you may remember this:\n\n.. code-block:: python\n\n    from django.contrib import admin\n    admin.autodiscover()\n\nbasically, persisting-theory will do the same, except that it let you declare what you want to autodiscover.\n\nokay, i'm bad at explaining things, and english is not my mother tongue. let's build a simple example.\n\nquickstart\n==========\n\ninstall\n*******\n\ninstall the package from `pypi <https://pypi.python.org/pypi/persisting-theory/>`_. via pip (or any other tool)::\n\n    pip install persisting-theory\n\npersisting-theory does not require any dependency but a python installation (it has been tested on python 2.7 and python 3.4).\n\nsetup\n*****\n\na basic setup:\n\n.. code-block:: python\n\n    # registries.py\n\n    from persiting_theory import registry\n\n    class callbacksregistry(registry):\n        \"\"\"\n            allow your apps to register callbacks\n        \"\"\"\n        # the package where the registry will try to find callbacks in each app\n        look_into = \"callbacks_registry\"\n\n    callbacks_registry = callbacksregistry()\n\n\n    # app1/callbacks_registry.py\n\n    from registries import callbacks_registry\n\n    @callbacks_registry.register\n    def dog():\n        print(\"wouf\")\n\n\n    # app2/callbacks_registry.py\n\n    from registries import callbacks_registry\n\n    @callbacks_registry.register\n    def cat():\n        print(\"meow\")\n\n\n    # dosomething.py\n\n    from registries import callbacks_registry\n\n    apps = (\n        'app1',\n        'app2',\n    )\n\n    # trigger autodiscovering process\n    callbacks_registry.autodiscover(apps)\n\n    for callback in callbacks_registry.values():\n        callback()\n\n        # wouf\n        # meow\n\napi\n===\n\n``registry`` inherits from python built-in `collections.ordereddict`, which means you can use regular dict methods to access registered data:\n\n.. code-block:: python\n\n    callbacks_registry.get(\"dog\")()  #  will print wouf\n    assert callbacks_registry.get(\"chicken\", none) is none\n\nregistry.register()\n*******************\n\nyou can use this function as a decorator for registering functions and classes:\n\n.. code-block:: python\n\n    from persisting_theory import registry\n\n    class awesomeregistry(registry):\n        pass\n\n    r = awesomeregistry()\n\n    # register a class\n    @r.register\n    class awesomeclass:\n        pass\n\n    # register a function\n    @r.register\n    def awesome_function():\n        pass\n\n    # by default, the key in the registry for a given value is obtained from the function or class name, if possible\n\n    assert r.get(\"awesomeclass\") == awesomeclass\n    assert r.get(\"awesome_function\") == awesome_function\n\n    # you can override this behaviour:\n\n    @r.register(name=\"chuck\")\n    class awesomeclass:\n        pass\n\n    @r.register(name=\"norris\")\n    def awesome_function():\n        pass\n\n    assert r.get(\"chuck\") == awesomeclass\n    assert r.get(\"norris\") == awesome_function\n\n\n    # you can also use the register method as is\n\n    awesome_var = \"chuck norris\"\n    r.register(awesome_var, name=\"who am i ?\")\n\n    assert r.get(\"who am i ?\") == awesome_var\n\n    # i f you are not registering a function or a class, you must provide a name argument\n\nregistry.validate()\n*******************\n\nby default, a registry will accept any registered value. sometimes, it's not what you want, so you can restrict what kind of data your registry accepts:\n\n.. code-block:: python\n\n    from persisting_theory import registry\n\n    class startswithawesomeregistry(registry):\n\n        def validate(self, data):\n            if isinstance(data, str):\n                return data.startswith(\"awesome\")\n            return false\n\n    r = startswithawesomeregistry()\n\n    # will pass registration\n    r.register(\"awesome day\", name=\"awesome_day\")\n\n    # will fail and raise valueerror\n    r.register(\"not so awesome day\", name=\"not_so_awesome_day\")\n\nregistry.prepare_data()\n***********************\n\nif you want to manipulate your data before registering it, override this method. in this example, we prefix every registered string with 'hello':\n\n.. code-block:: python\n\n    from persisting_theory import registry\n\n    class helloregistry(registry):\n\n        def prepare_data(self, data):\n            return 'hello ' + data\n\n    r = helloregistry()\n\n    class greeting:\n        def __init__(self, first_name):\n            self.first_name = first_name\n\n\n    r.register(greeting('world'), name=\"world\")\n    r.register(greeting('agate'), name=\"agate\")\n\n    assert r.register.get('world') == \"hello world\"\n    assert r.register.get('agate') == \"hello agate\"\n\n\nregistry.prepare_name()\n***********************\n\nin a similar way, you can manipulate the name of registered data. this can help if you want to avoid repetitions. let's improve our previous example:\n\n.. code-block:: python\n\n    from persisting_theory import registry\n\n    class helloregistry(registry):\n\n        def prepare_data(self, data):\n            return 'hello ' + data\n\n        def prepare_name(self, data, name=none):\n            return self.data.first_name.lower()\n\n    r = helloregistry()\n\n    class greeting:\n        def __init__(self, first_name):\n            self.first_name = first_name\n\n\n    r.register(greeting('world'))\n    r.register(greeting('agate'))\n\n    assert r.register.get('world') == \"hello world\"\n    assert r.register.get('agate') == \"hello agate\"\n\ngoing meta\n**********\n\nif you have multiple registries, or want to allow your apps to declare their own registries, this is for you:\n\n.. code-block:: python\n\n    # registries.py\n\n    from persisting_theory import meta_registry, registry\n\n    class registrya(registry):\n        look_into = \"a\"\n\n    class registryb(registry):\n        look_into = \"b\"\n\n    registry_a = registrya()\n    meta_registry.register(registry_a, name=\"registry_a\")\n\n    registry_b = registryb()\n    meta_registry.register(registry_b, name=\"registry_b\")\n\n\n    # dosomethingelse.py\n\n    from persisting_theory import meta_registry\n\n    # will import registries declared in `registries` packages, and trigger autodiscover() on each of them\n    meta_registry.autodiscover(apps=(\"app1\", \"app2\"))\n\n\nwhat the hell is that name ?\n============================\n\nit's an anagram for \"python registries\".\n\ncontribute\n==========\n\ncontributions, bug reports, and \"thank you\" are welcomed.\n\nlicense\n=======\n\nthe project is licensed under bsd licence.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "persisting-theory",
  "package_url": "https://pypi.org/project/persisting-theory/",
  "project_url": "https://pypi.org/project/persisting-theory/",
  "project_urls": {
    "Homepage": "https://code.agate.blue/agate/persisting-theory"
  },
  "release_url": "https://pypi.org/project/persisting-theory/1.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "registries that can autodiscover values accross your project apps",
  "version": "1.0",
  "releases": [],
  "developers": [
    "agate_blue"
  ],
  "kwds": "persisting_theory autodiscovering autodiscover persisting django",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_persisting_theory",
  "homepage": "https://code.agate.blue/agate/persisting-theory",
  "release_count": 6,
  "dependency_ids": []
}