{
  "classifiers": [
    "development status :: 3 - alpha",
    "license :: osi approved :: bsd license",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "# python-fcl\n### python interface for the flexible collision library\n\npython-fcl is an (unofficial) python interface for the [flexible collision library (fcl)](https://github.com/flexible-collision-library/fcl),\nan excellent c++ library for performing proximity and collision queries on pairs of geometric models.\ncurrently, this package is targeted for fcl 0.7.0.\n\nthis package supports three types of proximity queries for pairs of geometric models:\n* __collision detection__: detecting whether two models overlap (and optionally where).\n* __distance computation__: computing the minimum distance between a pair of models.\n* __continuous collision detection__: detecting whether two models overlap during motion (and optionally the time of contact).\n\nthis package also supports most of fcl's object shapes, including:\n* trianglep\n* box\n* sphere\n* ellipsoid\n* capsule\n* cone\n* convex\n* cylinder\n* half-space\n* plane\n* mesh\n* octree\n\n## installation\n\nfirst, install [octomap](https://github.com/octomap/octomap), which is necessary to use octree. for ubuntu, use `sudo apt-get install liboctomap-dev`.\nsecond, install fcl using the instructions provided [here](https://github.com/flexible-collision-library/fcl).\nif you're on ubuntu 17.04 or newer, you can install fcl using `sudo apt-get install libfcl-dev`.\notherwise, just compile fcl from source -- it's quick and easy, and its dependencies are all easily installed via `apt` or `brew`.\nnote: the provided install scripts (under `build_dependencies`) can automate this process as well.\n\nin order to install the python wrappers for fcl, simply run\n```shell\npip install python-fcl\n```\n\n## objects\n\n### collision objects\nthe primary construct in fcl is the `collisionobject`, which forms the backbone of all collision and distance computations.\na `collisionobject` consists of two components -- its geometry, defined by a `collisiongeometry` object, and its pose, defined by a `transform` object.\n\n#### collision geometries\nthere are two main types of `collisiongeometry` objects -- geometric primitives, such as boxes and spheres,\nand arbitrary triangular meshes.\nhere's some examples of how to instantiate geometric primitives.\nnote that the box, sphere, ellipsoid, capsule, cone, and cylinder are all centered at the origin.\n\n```python\nimport numpy as np\nimport fcl\n\nv1 = np.array([1.0, 2.0, 3.0])\nv2 = np.array([2.0, 1.0, 3.0])\nv3 = np.array([3.0, 2.0, 1.0])\nx, y, z = 1, 2, 3\nrad, lz = 1.0, 3.0\nn = np.array([1.0, 0.0, 0.0])\nd = 5.0\n\nt = fcl.trianglep(v1, v2, v3) # triangle defined by three points\nb = fcl.box(x, y, z)          # axis-aligned box with given side lengths\ns = fcl.sphere(rad)           # sphere with given radius\ne = fcl.ellipsoid(x, y, z)    # axis-aligned ellipsoid with given radii\nc = fcl.capsule(rad, lz)      # capsule with given radius and height along z-axis\nc = fcl.cone(rad, lz)         # cone with given radius and cylinder height along z-axis\nc = fcl.cylinder(rad, lz)     # cylinder with given radius and height along z-axis\nh = fcl.halfspace(n, d)       # half-space defined by {x : <n, x> < d}\np = fcl.plane(n, d)           # plane defined by {x : <n, x> = d}\n```\n\ntriangular meshes are wrapped by the `bvhmodel` class, and they are instantiated a bit differently.\n```python\nverts = np.array([[1.0, 1.0, 1.0],\n                  [2.0, 1.0, 1.0],\n                  [1.0, 2.0, 1.0],\n                  [1.0, 1.0, 2.0]])\ntris  = np.array([[0,2,1],\n                  [0,3,2],\n                  [0,1,3],\n                  [1,2,3]])\n\nm = fcl.bvhmodel()\nm.beginmodel(len(verts), len(tris))\nm.addsubmodel(verts, tris)\nm.endmodel()\n```\n\nif the mesh is convex, such as the example above, you can also wrap it in the `convex` class. note that the instantiation is a bit different because the `convex` class supports arbitrary polygons for each face of the convex object.\n```python\nverts = np.array([[1.0, 1.0, 1.0],\n                  [2.0, 1.0, 1.0],\n                  [1.0, 2.0, 1.0],\n                  [1.0, 1.0, 2.0]])\ntris  = np.array([[0,2,1],\n                  [0,3,2],\n                  [0,1,3],\n                  [1,2,3]])\nfaces = np.concatenate((3 * np.ones((len(tris), 1), dtype=np.int64), tris), axis=1).flatten()\nc = fcl.convex(verts, len(tris), faces)\n```\n\n#### transforms\nin addition to a `collisiongeometry`, a `collisionobject` requires a `transform`, which tells fcl where the `collisiongeometry` is actually located in the world.\nall `transform` objects specify a rigid transformation (i.e. a rotation and a translation).\nthe translation is always a 3-entry vector, while the rotation can be specified by a 3x3 rotation matrix or a 4-entry quaternion.\n\nhere are some examples of possible ways to instantiate and manipulate a `transform`.\n\n```python\nr = np.array([[0.0, -1.0, 0.0],\n              [1.0,  0.0, 0.0],\n              [0.0,  0.0, 1.0]])\nt = np.array([1.0, 2.0, 3.0])\nq = np.array([0.707, 0.0, 0.0, 0.707])\n\ntf = fcl.transform()     # default gives identity transform\ntf = fcl.transform(q)    # quaternion rotation, zero translation\ntf = fcl.transform(r)    # matrix rotation, zero translation\ntf = fcl.transform(t)    # translation, identity rotation\ntf = fcl.transform(q, t) # quaternion rotation and translation\ntf = fcl.transform(r, t) # matrix rotation and translation\ntf1 = fcl.transform(tf)  # can also initialize with another transform\n```\n\nnow, given a `collisiongeometry` and a `transform`, we can create a `collisionobject`:\n\n```python\nt = fcl.transform(r, t)\nb = fcl.box(x, y, z)\nobj = fcl.collisionobject(b, t)\n```\n\nthe transform of a collision object can be modified in-place:\n```python\nt1 = fcl.transform(r1, t1)\nobj.settransform(t1)   # using a transform\nobj.setrotation(r2)    # specifying components individually\nobj.settranslation(t2)\nobj.setquatrotation(q2)\n```\n## commands\n\n### pairwise operations\n\ngiven a pair of collision objects, this library supports three types of queries:\n* __collision detection__\n* __distance computation__\n* __continuous collision detection__\n\nthe interfaces for each of these operations follow a common pipeline.\nfirst, a query request data structure is initialized and populated with parameters.\nthen, an empty query response structure is initialized.\nfinally, the query function is called with the two `collisionobject` items, the request structure, and the response structure as arguments.\nthe query function returns a scalar result, and any additional information is stored in the query result data structure.\nexamples of all three operations are shown below.\n\n#### collision checking\n\n```python\ng1 = fcl.box(1,2,3)\nt1 = fcl.transform()\no1 = fcl.collisionobject(g1, t1)\n\ng2 = fcl.cone(1,3)\nt2 = fcl.transform()\no2 = fcl.collisionobject(g2, t2)\n\nrequest = fcl.collisionrequest()\nresult = fcl.collisionresult()\n\nret = fcl.collide(o1, o2, request, result)\n```\n\nafter calling `fcl.collide()`, `ret` contains the number of contacts generated between the two objects,\nand `result` contains information about the collision and contacts.\nfor more information about available parameters for collision requests and results,\nsee `fcl/collision_data.py`.\n\n#### distance checking\n\n```python\ng1 = fcl.box(1,2,3)\nt1 = fcl.transform()\no1 = fcl.collisionobject(g1, t1)\n\ng2 = fcl.cone(1,3)\nt2 = fcl.transform()\no2 = fcl.collisionobject(g2, t2)\n\nrequest = fcl.distancerequest()\nresult = fcl.distanceresult()\n\nret = fcl.distance(o1, o2, request, result)\n```\n\nafter calling `fcl.distance()`, `ret` contains the minimum distance between the two objects\nand `result` contains information about the closest points on the objects.\nif `ret` is negative, the objects are in collision.\nfor more information about available parameters for distance requests and results,\nsee `fcl/collision_data.py`.\n\n#### continuous collision checking\n\n```python\ng1 = fcl.box(1,2,3)\nt1 = fcl.transform()\no1 = fcl.collisionobject(g1, t1)\nt1_final = fcl.transform(np.array([1.0, 0.0, 0.0]))\n\ng2 = fcl.cone(1,3)\nt2 = fcl.transform()\no2 = fcl.collisionobject(g2, t2)\nt2_final = fcl.transform(np.array([-1.0, 0.0, 0.0]))\n\nrequest = fcl.continuouscollisionrequest()\nresult = fcl.continuouscollisionresult()\n\nret = fcl.continuouscollide(o1, t1_final, o2, t2_final, request, result)\n```\n\nafter calling `fcl.continuouscollide()`, `ret` contains the time of contact in (0,1), or 1.0 if the objects did not collide during movement from their initial poses to their final poses.\nadditionally, `result` contains information about the collision time and status.\nfor more information about available parameters for continuous collision requests and results,\nsee `fcl/collision_data.py`.\n\n### broadphase checking\nin addition to pairwise checks, fcl supports broadphase collision/distance queries between groups of objects and can avoid n-squared complexity.\nspecifically, `collisionobject` items are registered with a `dynamicaabbtreecollisionmanager` before collision or distance checking is performed.\n\nthree types of checks are possible:\n* one-to-many: collision/distance checking between a stand-alone `collisionobject` and all objects managed by a manager.\n* internal many-to-many: pairwise collision/distance checking between all pairs of objects managed by a manager.\n* group many-to-many: pairwise collision/distance checking between items from two managers.\n\nin general, the collision methods can return all contact pairs, while the distance methods will just return the single closest distance between any pair of objects.\nhere are some examples of managed collision checking.\nthe methods take a callback function -- use the defaults from `python-fcl` unless you have a special use case -- and a wrapper object, either `collisiondata` or `distancedata`, that wraps a request-response pair. this object also has a field, `done`, that tells the recursive collision checker when to quit.\nbe sure to use a new `data` object for each request or set the `done` attribute to `false` before reusing one.\n\n```python\nobjs1 = [fcl.collisionobject(box), fcl.collisionobject(sphere)]\nobjs2 = [fcl.collisionobject(cone), fcl.collisionobject(mesh)]\n\nmanager1 = fcl.dynamicaabbtreecollisionmanager()\nmanager2 = fcl.dynamicaabbtreecollisionmanager()\n\nmanager1.registerobjects(objs1)\nmanager2.registerobjects(objs2)\n\nmanager1.setup()\nmanager2.setup()\n\n#=====================================================================\n# managed internal (sub-n^2) collision checking\n#=====================================================================\ncdata = fcl.collisiondata()\nmanager1.collide(cdata, fcl.defaultcollisioncallback)\nprint 'collision within manager 1?: {}'.format(cdata.result.is_collision)\n\n##=====================================================================\n## managed internal (sub-n^2) distance checking\n##=====================================================================\nddata = fcl.distancedata()\nmanager1.distance(ddata, fcl.defaultdistancecallback)\nprint 'closest distance within manager 1?: {}'.format(ddata.result.min_distance)\n\n#=====================================================================\n# managed one to many collision checking\n#=====================================================================\nreq = fcl.collisionrequest(num_max_contacts=100, enable_contact=true)\nrdata = fcl.collisiondata(request = req)\n\nmanager1.collide(fcl.collisionobject(mesh), rdata, fcl.defaultcollisioncallback)\nprint 'collision between manager 1 and mesh?: {}'.format(rdata.result.is_collision)\nprint 'contacts:'\nfor c in rdata.result.contacts:\n    print '\\to1: {}, o2: {}'.format(c.o1, c.o2)\n\n#=====================================================================\n# managed many to many collision checking\n#=====================================================================\nrdata = fcl.collisiondata(request = req)\nmanager1.collide(manager2, rdata, fcl.defaultcollisioncallback)\nprint 'collision between manager 1 and manager 2?: {}'.format(rdata.result.is_collision)\nprint 'contacts:'\nfor c in rdata.result.contacts:\n    print '\\to1: {}, o2: {}'.format(c.o1, c.o2)\n```\n\n### extracting which objects are in collision\n\nto determine which objects are actually in collision, you'll need parse the collision data's contacts and use an additional external data structure.\n\nspecifically, the `fcl.collisiondata` object that is passed into any `collide()` call has an internal set of contacts, stored in `cdata.result.contacts`.\nthis object is a simple list of `contact` objects, each of which represents a contact point between two objects.\neach contact object has two attributes, `o1` and `o2`, that store references to the original `fcl.collisiongeometry` objects were created for the two `fcl.collisionobject` objects that are in collision.\nthis is a bit wonky, but it's part of the fcl api.\n\ntherefore, all you have to do is make a map from the `id` of each `fcl.collisiongeometry` object to either the actual `fcl.collisionobject` it corresponds to or to some string identifier for each object.\nthen, you can iterate over `cdata.result.contacts`, extract `o1` and `o2`, apply the built-in `id()` function to each, and find the corresponding data you want in your map.\n\nhere's an example.\n\n```python\nimport fcl\nimport numpy as np\n\n# create collision geometry and objects\ngeom1 = fcl.cylinder(1.0, 1.0)\nobj1 = fcl.collisionobject(geom1)\n\ngeom2 = fcl.cylinder(1.0, 1.0)\nobj2 = fcl.collisionobject(geom2, fcl.transform(np.array([0.0, 0.0, 0.3])))\n\ngeom3 = fcl.cylinder(1.0, 1.0)\nobj3 = fcl.collisionobject(geom3, fcl.transform(np.array([0.0, 0.0, 3.0])))\n\ngeoms = [geom1, geom2, geom3]\nobjs = [obj1, obj2, obj3]\nnames = ['obj1', 'obj2', 'obj3']\n\n# create map from geometry ids to objects\ngeom_id_to_obj = { id(geom) : obj for geom, obj in zip(geoms, objs) }\n\n# create map from geometry ids to string names\ngeom_id_to_name = { id(geom) : name for geom, name in zip(geoms, names) }\n\n# create manager\nmanager = fcl.dynamicaabbtreecollisionmanager()\nmanager.registerobjects(objs)\nmanager.setup()\n\n# create collision request structure\ncrequest = fcl.collisionrequest(num_max_contacts=100, enable_contact=true)\ncdata = fcl.collisiondata(crequest, fcl.collisionresult())\n\n# run collision request\nmanager.collide(cdata, fcl.defaultcollisioncallback)\n\n# extract collision data from contacts and use that to infer set of\n# objects that are in collision\nobjs_in_collision = set()\n\nfor contact in cdata.result.contacts:\n    # extract collision geometries that are in contact\n    coll_geom_0 = contact.o1\n    coll_geom_1 = contact.o2\n\n    # get their names\n    coll_names = [geom_id_to_name[id(coll_geom_0)], geom_id_to_name[id(coll_geom_1)]]\n    coll_names = tuple(sorted(coll_names))\n    objs_in_collision.add(coll_names)\n\nfor coll_pair in objs_in_collision:\n    print('object {} in collision with object {}!'.format(coll_pair[0], coll_pair[1]))\n```\n\n```\n>>> object obj1 in collision with object obj2!\n```\nfor more examples, see `examples/example.py`.\n",
  "docs_url": null,
  "keywords": "fcl collision distance",
  "license": "bsd",
  "name": "python-fcl",
  "package_url": "https://pypi.org/project/python-fcl/",
  "project_url": "https://pypi.org/project/python-fcl/",
  "project_urls": {
    "Homepage": "https://github.com/CyrilWaechter/python-fcl"
  },
  "release_url": "https://pypi.org/project/python-fcl/0.7.0.5/",
  "requires_dist": [
    "numpy >=1.26.0b1 ; python_version >= \"3.12\"",
    "Cython",
    "numpy ; python_version < \"3.12\""
  ],
  "requires_python": "",
  "summary": "python bindings for the flexible collision library",
  "version": "0.7.0.5",
  "releases": [],
  "developers": [
    "jelle_feringa",
    "jelleferinga@gmail.com",
    "matthew_matl",
    "mmatl@eecs.berkeley.edu",
    "rootstock_acg@yahoo.co.jp"
  ],
  "kwds": "collisiongeometry is_collision collision_data collisionrequest collision",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_python_fcl",
  "homepage": "https://github.com/cyrilwaechter/python-fcl",
  "release_count": 16,
  "dependency_ids": [
    "pypi_cython",
    "pypi_numpy"
  ]
}