{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "mpire (multiprocessing is really easy)\n======================================\n\n|build status| |docs status| |pypi status| |python versions|\n\n.. |build status| image:: https://github.com/sybrenjansen/mpire/workflows/build/badge.svg?branch=master\n    :target: https://github.com/sybrenjansen/mpire/actions/workflows/python-package.yml\n    :alt: build status\n.. |docs status| image:: https://github.com/sybrenjansen/mpire/workflows/docs/badge.svg?branch=master\n    :target: https://sybrenjansen.github.io/mpire/\n    :alt: documentation\n.. |pypi status| image:: https://img.shields.io/pypi/v/mpire\n    :target: https://pypi.org/project/mpire/\n    :alt: pypi project page\n.. |python versions| image:: https://img.shields.io/pypi/pyversions/mpire\n    :target: https://pypi.org/project/mpire/\n    :alt: pypi project page\n\n``mpire``, short for multiprocessing is really easy, is a python package for multiprocessing. ``mpire`` is faster in\nmost scenarios, packs more features, and is generally more user-friendly than the default multiprocessing package. it\ncombines the convenient map like functions of ``multiprocessing.pool`` with the benefits of using copy-on-write shared\nobjects of ``multiprocessing.process``, together with easy-to-use worker state, worker insights, worker init and exit\nfunctions, timeouts, and progress bar functionality.\n\nfull documentation is available at https://sybrenjansen.github.io/mpire/.\n\nfeatures\n--------\n\n- faster execution than other multiprocessing libraries. see benchmarks_.\n- intuitive, pythonic syntax\n- multiprocessing with ``map``/``map_unordered``/``imap``/``imap_unordered``/``apply``/``apply_async`` functions\n- easy use of copy-on-write shared objects with a pool of workers (copy-on-write is only available for start method\n  ``fork``)\n- each worker can have its own state and with convenient worker init and exit functionality this state can be easily\n  manipulated (e.g., to load a memory-intensive model only once for each worker without the need of sending it through a\n  queue)\n- progress bar support using tqdm_\n- progress dashboard support\n- worker insights to provide insight into your multiprocessing efficiency\n- graceful and user-friendly exception handling\n- timeouts, including for worker init and exit functions\n- automatic task chunking for all available map functions to speed up processing of small task queues (including numpy\n  arrays)\n- adjustable maximum number of active tasks to avoid memory problems\n- automatic restarting of workers after a specified number of tasks to reduce memory footprint\n- nested pool of workers are allowed when setting the ``daemon`` option\n- child processes can be pinned to specific or a range of cpus\n- optionally utilizes dill_ as serialization backend through multiprocess_, enabling parallelizing more exotic objects,\n  lambdas, and functions in ipython and jupyter notebooks.\n\nmpire is tested on linux and windows. for windows and macos users, there are a few minor known caveats, which are documented in the troubleshooting_ chapter.\n\n.. _benchmarks: https://towardsdatascience.com/mpire-for-python-multiprocessing-is-really-easy-d2ae7999a3e9\n.. _multiprocess: https://github.com/uqfoundation/multiprocess\n.. _dill: https://pypi.org/project/dill/\n.. _tqdm: https://tqdm.github.io/\n.. _troubleshooting: https://sybrenjansen.github.io/mpire/troubleshooting.html\n\n\ninstallation\n------------\n\nthrough pip (pypi):\n\n.. code-block:: bash\n\n    pip install mpire\n\nmpire is also available through conda-forge:\n\n.. code-block:: bash\n\n    conda install -c conda-forge mpire\n\n\ngetting started\n---------------\n\nsuppose you have a time consuming function that receives some input and returns its results. simple functions like these\nare known as `embarrassingly parallel`_ problems, functions that require little to no effort to turn into a parallel\ntask. parallelizing a simple function as this can be as easy as importing ``multiprocessing`` and using the\n``multiprocessing.pool`` class:\n\n.. _embarrassingly parallel: https://en.wikipedia.org/wiki/embarrassingly_parallel\n\n.. code-block:: python\n\n    import time\n    from multiprocessing import pool\n\n    def time_consuming_function(x):\n        time.sleep(1)  # simulate that this function takes long to complete\n        return ...\n\n    with pool(processes=5) as pool:\n        results = pool.map(time_consuming_function, range(10))\n\nmpire can be used almost as a drop-in replacement to ``multiprocessing``. we use the ``mpire.workerpool`` class and\ncall one of the available ``map`` functions:\n\n.. code-block:: python\n\n    from mpire import workerpool\n\n    with workerpool(n_jobs=5) as pool:\n        results = pool.map(time_consuming_function, range(10))\n\nthe differences in code are small: there's no need to learn a completely new multiprocessing syntax, if you're used to\nvanilla ``multiprocessing``. the additional available functionality, though, is what sets mpire apart.\n\nprogress bar\n~~~~~~~~~~~~\n\nsuppose we want to know the status of the current task: how many tasks are completed, how long before the work is ready?\nit's as simple as setting the ``progress_bar`` parameter to ``true``:\n\n.. code-block:: python\n\n    with workerpool(n_jobs=5) as pool:\n        results = pool.map(time_consuming_function, range(10), progress_bar=true)\n\nand it will output a nicely formatted tqdm_ progress bar.\n\nmpire also offers a dashboard, for which you need to install additional dependencies_. see dashboard_ for more\ninformation.\n\n.. _dependencies: https://sybrenjansen.github.io/mpire/install.html#dashboard\n.. _dashboard: https://sybrenjansen.github.io/mpire/usage/dashboard.html\n\n\nshared objects\n~~~~~~~~~~~~~~\n\nnote: copy-on-write shared objects is only available for start method ``fork``. for ``threading`` the objects are shared\nas-is. for other start methods the shared objects are copied once for each worker, which can still be better than once\nper task.\n\nif you have one or more objects that you want to share between all workers you can make use of the copy-on-write\n``shared_objects`` option of mpire.  mpire will pass on these objects only once for each worker without\ncopying/serialization. only when you alter the object in the worker function it will start copying it for that worker.\n\n.. code-block:: python\n\n    def time_consuming_function(some_object, x):\n        time.sleep(1)  # simulate that this function takes long to complete\n        return ...\n\n    def main():\n        some_object = ...\n        with workerpool(n_jobs=5, shared_objects=some_object) as pool:\n            results = pool.map(time_consuming_function, range(10), progress_bar=true)\n\nsee shared_objects_ for more details.\n\n.. _shared_objects: https://sybrenjansen.github.io/mpire/usage/workerpool/shared_objects.html\n\nworker initialization\n~~~~~~~~~~~~~~~~~~~~~\n\nworkers can be initialized using the ``worker_init`` feature. together with ``worker_state`` you can load a model, or\nset up a database connection, etc.:\n\n.. code-block:: python\n\n    def init(worker_state):\n        # load a big dataset or model and store it in a worker specific worker_state\n        worker_state['dataset'] = ...\n        worker_state['model'] = ...\n\n    def task(worker_state, idx):\n        # let the model predict a specific instance of the dataset\n        return worker_state['model'].predict(worker_state['dataset'][idx])\n\n    with workerpool(n_jobs=5, use_worker_state=true) as pool:\n        results = pool.map(task, range(10), worker_init=init)\n\nsimilarly, you can use the ``worker_exit`` feature to let mpire call a function whenever a worker terminates. you can\neven let this exit function return results, which can be obtained later on. see the `worker_init and worker_exit`_\nsection for more information.\n\n.. _worker_init and worker_exit: https://sybrenjansen.github.io/mpire/usage/map/worker_init_exit.html\n\n\nworker insights\n~~~~~~~~~~~~~~~\n\nwhen your multiprocessing setup isn't performing as you want it to and you have no clue what's causing it, there's the\nworker insights functionality. this will give you insight in your setup, but it will not profile the function you're\nrunning (there are other libraries for that). instead, it profiles the worker start up time, waiting time and\nworking time. when worker init and exit functions are provided it will time those as well.\n\nperhaps you're sending a lot of data over the task queue, which makes the waiting time go up. whatever the case, you\ncan enable and grab the insights using the ``enable_insights`` flag and ``mpire.workerpool.get_insights`` function,\nrespectively:\n\n.. code-block:: python\n\n    with workerpool(n_jobs=5, enable_insights=true) as pool:\n        results = pool.map(time_consuming_function, range(10))\n        insights = pool.get_insights()\n\nsee `worker insights`_ for a more detailed example and expected output.\n\n.. _worker insights: https://sybrenjansen.github.io/mpire/usage/workerpool/worker_insights.html\n\n\ntimeouts\n~~~~~~~~\n\ntimeouts can be set separately for the target, ``worker_init`` and ``worker_exit`` functions. when a timeout has been\nset and reached, it will throw a ``timeouterror``:\n\n.. code-block:: python\n\n    def init():\n        ...\n\n    def exit_():\n        ...\n\n    # will raise timeouterror, provided that the target function takes longer\n    # than half a second to complete\n    with workerpool(n_jobs=5) as pool:\n        pool.map(time_consuming_function, range(10), task_timeout=0.5)\n\n    # will raise timeouterror, provided that the worker_init function takes longer\n    # than 3 seconds to complete or the worker_exit function takes longer than\n    # 150.5 seconds to complete\n    with workerpool(n_jobs=5) as pool:\n        pool.map(time_consuming_function, range(10), worker_init=init, worker_exit=exit_,\n                 worker_init_timeout=3.0, worker_exit_timeout=150.5)\n\nwhen using ``threading`` as start method mpire won't be able to interrupt certain functions, like ``time.sleep``.\n\nsee timeouts_ for more details.\n\n.. _timeouts: https://sybrenjansen.github.io/mpire/usage/map/timeouts.html\n\nbenchmarks\n----------\n\nmpire has been benchmarked on three different benchmarks: numerical computation, stateful computation, and expensive\ninitialization. more details on these benchmarks can be found in this `blog post`_. all code for these benchmarks can\nbe found in this project_.\n\nin short, the main reasons why mpire is faster are:\n\n- when ``fork`` is available we can make use of copy-on-write shared objects, which reduces the need to copy objects\n  that need to be shared over child processes\n- workers can hold state over multiple tasks. therefore you can choose to load a big file or send resources over only\n  once per worker\n- automatic task chunking\n\nthe following graph shows the average normalized results of all three benchmarks. results for individual benchmarks\ncan be found in the `blog post`_. the benchmarks were run on a linux machine with 20 cores, with disabled hyperthreading\nand 200gb of ram. for each task, experiments were run with different numbers of processes/workers and results were\naveraged over 5 runs.\n\n.. image:: images/benchmarks_averaged.png\n    :width: 600px\n    :alt: average normalized bechmark results\n\n.. _blog post: https://towardsdatascience.com/mpire-for-python-multiprocessing-is-really-easy-d2ae7999a3e9\n.. _project: https://github.com/sybrenjansen/multiprocessing_benchmarks\n\n\n\ndocumentation\n-------------\n\nsee the full documentation at https://sybrenjansen.github.io/mpire/ for information on all the other features of mpire.\n\nif you want to build the documentation yourself, please install the documentation dependencies by executing:\n\n.. code-block:: bash\n\n    pip install mpire[docs]\n\nor \n\n.. code-block:: bash\n\n    pip install .[docs]\n\n\ndocumentation can then be build by using python <= 3.9 and executing:\n\n.. code-block:: bash\n\n    python setup.py build_docs\n\ndocumentation can also be build from the ``docs`` folder directly. in that case ``mpire`` should be installed and\navailable in your current working environment. then execute:\n\n.. code-block:: bash\n\n    make html\n\nin the ``docs`` folder.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "mpire",
  "package_url": "https://pypi.org/project/mpire/",
  "project_url": "https://pypi.org/project/mpire/",
  "project_urls": {
    "Homepage": "https://github.com/sybrenjansen/mpire"
  },
  "release_url": "https://pypi.org/project/mpire/2.8.1/",
  "requires_dist": [
    "pygments (>=2.0)",
    "tqdm (>=4.27)",
    "pywin32 (==225) ; platform_system == \"Windows\" and python_version == \"3.6\"",
    "pywin32 (>=301) ; platform_system == \"Windows\" and python_version > \"3.6\"",
    "dataclasses ; python_version < \"3.7\"",
    "flask ; extra == 'dashboard'",
    "multiprocess ; (python_version < \"3.11\") and extra == 'dill'",
    "multiprocess (>=0.70.15) ; (python_version >= \"3.11\") and extra == 'dill'",
    "docutils (==0.17.1) ; extra == 'docs'",
    "sphinx (==3.2.1) ; extra == 'docs'",
    "sphinx-rtd-theme (==0.5.0) ; extra == 'docs'",
    "sphinx-autodoc-typehints (==1.11.0) ; extra == 'docs'",
    "sphinxcontrib-images (==0.9.2) ; extra == 'docs'",
    "sphinx-versions (==1.0.1) ; extra == 'docs'",
    "numpy ; extra == 'testing'",
    "pywin32 (==225) ; (platform_system == \"Windows\" and python_version == \"3.6\") and extra == 'testing'",
    "pywin32 (>=301) ; (platform_system == \"Windows\" and python_version > \"3.6\") and extra == 'testing'",
    "multiprocess ; (python_version < \"3.11\") and extra == 'testing'",
    "dataclasses ; (python_version < \"3.7\") and extra == 'testing'",
    "multiprocess (>=0.70.15) ; (python_version >= \"3.11\") and extra == 'testing'"
  ],
  "requires_python": "",
  "summary": "a python package for easy multiprocessing, but faster than multiprocessing",
  "version": "2.8.1",
  "releases": [],
  "developers": [
    "sybren_jansen"
  ],
  "kwds": "_multiprocess multiprocess_ multiprocess multiprocessing pyversions",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_mpire",
  "homepage": "https://github.com/sybrenjansen/mpire",
  "release_count": 22,
  "dependency_ids": [
    "pypi_dataclasses",
    "pypi_docutils",
    "pypi_flask",
    "pypi_multiprocess",
    "pypi_numpy",
    "pypi_pygments",
    "pypi_pywin32",
    "pypi_sphinx",
    "pypi_sphinx_autodoc_typehints",
    "pypi_sphinx_rtd_theme",
    "pypi_sphinx_versions",
    "pypi_sphinxcontrib_images",
    "pypi_tqdm"
  ]
}