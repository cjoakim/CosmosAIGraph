{
  "classifiers": [],
  "description": ".. image:: https://github.com/globocom/m3u8/actions/workflows/main.yml/badge.svg\n\n.. image:: https://badge.fury.io/py/m3u8.svg\n    :target: https://badge.fury.io/py/m3u8\n\nm3u8\n====\n\npython `m3u8`_ parser.\n\ndocumentation\n=============\n\nloading a playlist\n------------------\n\nto load a playlist into an object from uri, file path or directly from string, use the `load/loads` functions:\n\n.. code-block:: python\n\n    import m3u8\n\n    playlist = m3u8.load('http://videoserver.com/playlist.m3u8')  # this could also be an absolute filename\n    print(playlist.segments)\n    print(playlist.target_duration)\n\n    # if you already have the content as string, use\n    \n    playlist = m3u8.loads('#extm3u8 ... etc ... ')\n\ndumping a playlist\n------------------\n\nto dump a playlist from an object to the console or a file, use the `dump/dumps` functions:\n\n.. code-block:: python\n\n    import m3u8\n\n    playlist = m3u8.load('http://videoserver.com/playlist.m3u8')\n    print(playlist.dumps())\n\n    # if you want to write a file from its content\n    \n    playlist.dump('playlist.m3u8')\n\n\nsupported tags\n==============\n\n* `#ext-x-targetduration`_\n* `#ext-x-media-sequence`_\n* `#ext-x-discontinuity-sequence`_\n* `#ext-x-program-date-time`_\n* `#ext-x-media`_\n* `#ext-x-playlist-type`_\n* `#ext-x-key`_\n* `#ext-x-stream-inf`_\n* `#ext-x-version`_\n* `#ext-x-allow-cache`_\n* `#ext-x-endlist`_\n* `#extinf`_\n* `#ext-x-i-frames-only`_\n* `#ext-x-bitrate`_\n* `#ext-x-byterange`_\n* `#ext-x-i-frame-stream-inf`_\n* `#ext-x-images-only`_\n* `#ext-x-image-stream-inf`_\n* `#ext-x-tiles`_\n* `#ext-x-discontinuity`_\n* #ext-x-cue-out\n* #ext-x-cue-out-cont\n* #ext-x-cue-in\n* #ext-x-cue-span\n* #ext-oatcls-scte35\n* `#ext-x-independent-segments`_\n* `#ext-x-map`_\n* `#ext-x-start`_\n* `#ext-x-server-control`_\n* `#ext-x-part-inf`_\n* `#ext-x-part`_\n* `#ext-x-rendition-report`_\n* `#ext-x-skip`_\n* `#ext-x-session-data`_\n* `#ext-x-preload-hint`_\n* `#ext-x-session-key`_\n* `#ext-x-daterange`_\n* `#ext-x-gap`_\n* `#ext-x-content-steering`_\n\nencryption keys\n---------------\n\nthe segments may or may not be encrypted. the ``keys`` attribute list will\nbe a list  with all the different keys as described with `#ext-x-key`_:\n\neach key has the next properties:\n\n-  ``method``: ex.: \"aes-128\"\n-  ``uri``: the key uri, ex.: \"http://videoserver.com/key.bin\"\n-  ``iv``: the initialization vector, if available. otherwise ``none``.\n\nif no ``#ext-x-key`` is found, the ``keys`` list will have a unique element ``none``. multiple keys are supported.\n\nif unencrypted and encrypted segments are mixed in the m3u8 file, then the list will contain a ``none`` element, with one\nor more keys afterwards.\n\nto traverse the list of keys available:\n\n.. code-block:: python\n\n    import m3u8\n\n    m3u8_obj = m3u8.loads('#extm3u8 ... etc ...')\n    len(m3u8_obj.keys)  # => returns the number of keys available in the list (normally 1)\n    for key in m3u8_obj.keys:\n       if key:  # first one could be none\n          key.uri\n          key.method\n          key.iv\n\n\ngetting segments encrypted with one key\n---------------------------------------\n\nthere are cases where listing segments for a given key is important. it's possible to\nretrieve the list of segments encrypted with one key via ``by_key`` method in the\n``segments`` list.\n\nexample of getting the segments with no encryption:\n\n.. code-block:: python\n\n    import m3u8\n\n    m3u8_obj = m3u8.loads('#extm3u8 ... etc ...')\n    segmk1 = m3u8_obj.segments.by_key(none)\n\n    # get the list of segments encrypted using last key\n    segm = m3u8_obj.segments.by_key( m3u8_obj.keys[-1] )\n\n\nwith this method, is now possible also to change the key from some of the segments programmatically:\n\n\n.. code-block:: python\n\n    import m3u8\n\n    m3u8_obj = m3u8.loads('#extm3u8 ... etc ...')\n\n    # create a new key and replace it\n    new_key = m3u8.key(\"aes-128\", \"/encrypted/newkey.bin\", none, iv=\"0xf123ad23f22e441098aa87ee\")\n    for segment in m3u8_obj.segments.by_key( m3u8_obj.keys[-1] ):\n        segment.key = new_key\n    # remember to sync the key from the list as well\n    m3u8_obj.keys[-1] = new_key\n\n\n\nvariant playlists (variable bitrates)\n-------------------------------------\n\na playlist can have a list to other playlist files, this is used to\nrepresent multiple bitrates videos, and it's called `variant streams`_.\nsee an `example here`_.\n\n.. code-block:: python\n\n    variant_m3u8 = m3u8.loads('#extm3u8 ... contains a variant stream ...')\n    variant_m3u8.is_variant    # in this case will be true\n\n    for playlist in variant_m3u8.playlists:\n        playlist.uri\n        playlist.stream_info.bandwidth\n\nthe playlist object used in the for loop above has a few attributes:\n\n-  ``uri``: the url to the stream\n-  ``stream_info``: a ``streaminfo`` object (actually a namedtuple) with\n   all the attributes available to `#ext-x-stream-inf`_\n-  ``media``: a list of related ``media`` objects with all the attributes\n   available to `#ext-x-media`_\n-  ``playlist_type``: the type of the playlist, which can be one of `vod`_\n   (video on demand) or `event`_\n\n**note: the following attributes are not implemented yet**, follow\n`issue 4`_ for updates\n\n-  ``alternative_audios``: its an empty list, unless it's a playlist\n   with `alternative audio`_, in this case it's a list with ``media``\n   objects with all the attributes available to `#ext-x-media`_\n-  ``alternative_videos``: same as ``alternative_audios``\n\na variant playlist can also have links to `i-frame playlists`_, which are used\nto specify where the i-frames are in a video. see `apple's documentation`_ on\nthis for more information. these i-frame playlists can be accessed in a similar\nway to regular playlists.\n\n.. code-block:: python\n\n    variant_m3u8 = m3u8.loads('#extm3u ... contains a variant stream ...')\n\n    for iframe_playlist in variant_m3u8.iframe_playlists:\n        iframe_playlist.uri\n        iframe_playlist.iframe_stream_info.bandwidth\n\nthe iframe_playlist object used in the for loop above has a few attributes:\n\n-  ``uri``: the url to the i-frame playlist\n-  ``base_uri``: the base uri of the variant playlist (if given)\n-  ``iframe_stream_info``: a ``streaminfo`` object (same as a regular playlist)\n\ncustom tags\n-----------\n\nquoting the documentation::\n\n    lines that start with the character '#' are either comments or tags.\n    tags begin with #ext.  they are case-sensitive.  all other lines that\n    begin with '#' are comments and should be ignored.\n\nthis library ignores all the non-standard tags by default. if you want them to be collected while loading the file content,\nyou need to pass a function to the `load/loads` functions, following the example below:\n\n.. code-block:: python\n\n    import m3u8\n\n    def get_movie(line, lineno, data, state):\n        if line.startswith('#movie-name:'):\n            custom_tag = line.split(':')\n            data['movie'] = custom_tag[1].strip()\n\n    m3u8_obj = m3u8.load('http://videoserver.com/playlist.m3u8', custom_tags_parser=get_movie)\n    print(m3u8_obj.data['movie'])  #  million dollar baby\n\n\nalso you are able to override parsing of existing standard tags.\nto achieve this your custom_tags_parser function have to return boolean true - it will mean that you fully implement parsing of current line therefore 'main parser' can go to next line.\n\n.. code-block:: python\n\n    import re\n    import m3u8\n    from m3u8 import protocol\n    from m3u8.parser import save_segment_custom_value\n\n\n    def parse_iptv_attributes(line, lineno, data, state):\n        # customize parsing #extinf\n        if line.startswith(protocol.extinf):\n            title = ''\n            chunks = line.replace(protocol.extinf + ':', '').split(',', 1)\n            if len(chunks) == 2:\n                duration_and_props, title = chunks\n            elif len(chunks) == 1:\n                duration_and_props = chunks[0]\n\n            additional_props = {}\n            chunks = duration_and_props.strip().split(' ', 1)\n            if len(chunks) == 2:\n                duration, raw_props = chunks\n                matched_props = re.finditer(r'([\\w\\-]+)=\"([^\"]*)\"', raw_props)\n                for match in matched_props:\n                    additional_props[match.group(1)] = match.group(2)\n            else:\n                duration = duration_and_props\n\n            if 'segment' not in state:\n                state['segment'] = {}\n            state['segment']['duration'] = float(duration)\n            state['segment']['title'] = title\n\n            # helper function for saving custom values\n            save_segment_custom_value(state, 'extinf_props', additional_props)\n\n            # tell 'main parser' that we expect an url on next lines\n            state['expect_segment'] = true\n\n            # tell 'main parser' that it can go to next line, we've parsed current fully.\n            return true\n\n\n    if __name__ == '__main__':\n        playlist = \"\"\"#extm3u\n        #extinf:-1 timeshift=\"0\" catchup-days=\"7\" catchup-type=\"flussonic\" tvg-id=\"channel1\" group-title=\"group1\",channel1\n        http://str00.iptv.domain/7331/mpegts?token=longtokenhere\n        \"\"\"\n\n        parsed = m3u8.loads(playlist, custom_tags_parser=parse_iptv_attributes)\n\n        first_segment_props = parsed.segments[0].custom_parser_values['extinf_props']\n        print(first_segment_props['tvg-id'])  # 'channel1'\n        print(first_segment_props['group-title'])  # 'group1'\n        print(first_segment_props['catchup-type'])  # 'flussonic'\n\nhelper functions get_segment_custom_value() and save_segment_custom_value() are intended for getting/storing your parsed values per segment into segment class.\nafter that all custom values will be accessible via property custom_parser_values of segment instance.\n\nusing different http clients\n----------------------------\n\nif you don't want to use urllib to download playlists, having more control on how objects are fetched over the internet,\nyou can use your own client. `requests` is a well known python http library and it can be used with `m3u8`:\n\n.. code-block:: python\n\n    import m3u8\n    import requests\n\n    class requestsclient():\n        def download(self, uri, timeout=none, headers={}, verify_ssl=true):\n            o = requests.get(uri, timeout=timeout, headers=headers)\n            return o.text, o.url\n\n    playlist = m3u8.load('http://videoserver.com/playlist.m3u8', http_client=requestsclient())\n    print(playlist.dumps())\n\nthe advantage of using a custom http client is to refine ssl verification, proxies, performance, flexibility, etc.\n\nplaylists behind proxies\n------------------------\n\nin case you need to use a proxy but can't use a system wide proxy (http/https proxy environment variables), you can pass your\nhttp/https proxies as a dict to the load function.\n\n.. code-block:: python\n\n    import m3u8\n\n    proxies = {\n        'http': 'http://10.10.1.10:3128',\n        'https': 'http://10.10.1.10:1080',\n    }\n\n    http_client = m3u8.httpclient.defaulthttpclient(proxies)\n    playlist = m3u8.load('http://videoserver.com/playlist.m3u8', http_client=http_client)  # this could also be an absolute filename\n    print(playlist.dumps())\n\nit works with the default client only. custom http clients must implement this feature.\n\nrunning tests\n=============\n\n.. code-block:: bash\n\n    $ ./runtests\n\ncontributing\n============\n\nall contributions are welcome, but we will merge a pull request if, and only if, it\n\n-  has tests\n-  follows the code conventions\n\nif you plan to implement a new feature or something that will take more\nthan a few minutes, please open an issue to make sure we don't work on\nthe same thing.\n\n.. _m3u8: https://tools.ietf.org/html/rfc8216\n.. _#ext-x-version: https://tools.ietf.org/html/rfc8216#section-4.3.1.2\n.. _#extinf: https://tools.ietf.org/html/rfc8216#section-4.3.2.1\n.. _#ext-x-allow-cache: https://datatracker.ietf.org/doc/html/draft-pantos-http-live-streaming-07#section-3.3.6\n.. _#ext-x-bitrate: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.4.8\n.. _#ext-x-byterange: https://tools.ietf.org/html/rfc8216#section-4.3.2.2\n.. _#ext-x-discontinuity: https://tools.ietf.org/html/rfc8216#section-4.3.2.3\n.. _#ext-x-key: https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n.. _#ext-x-map: https://tools.ietf.org/html/rfc8216#section-4.3.2.5\n.. _#ext-x-program-date-time: https://tools.ietf.org/html/rfc8216#section-4.3.2.6\n.. _#ext-x-daterange: https://tools.ietf.org/html/rfc8216#section-4.3.2.7\n.. _#ext-x-targetduration: https://tools.ietf.org/html/rfc8216#section-4.3.3.1\n.. _#ext-x-media-sequence: https://tools.ietf.org/html/rfc8216#section-4.3.3.2\n.. _#ext-x-discontinuity-sequence: https://tools.ietf.org/html/rfc8216#section-4.3.3.3\n.. _#ext-x-endlist: https://tools.ietf.org/html/rfc8216#section-4.3.3.4\n.. _#ext-x-playlist-type: https://tools.ietf.org/html/rfc8216#section-4.3.3.5\n.. _#ext-x-i-frames-only: https://tools.ietf.org/html/rfc8216#section-4.3.3.6\n.. _#ext-x-media: https://tools.ietf.org/html/rfc8216#section-4.3.4.1\n.. _#ext-x-stream-inf: https://tools.ietf.org/html/rfc8216#section-4.3.4.2\n.. _#ext-x-i-frame-stream-inf: https://tools.ietf.org/html/rfc8216#section-4.3.4.3\n.. _#ext-x-images-only: https://github.com/image-media-playlist/spec/blob/master/image_media_playlist_v0_4.pdf\n.. _#ext-x-image-stream-inf: https://github.com/image-media-playlist/spec/blob/master/image_media_playlist_v0_4.pdf\n.. _#ext-x-tiles: https://github.com/image-media-playlist/spec/blob/master/image_media_playlist_v0_4.pdf\n.. _#ext-x-session-data: https://tools.ietf.org/html/rfc8216#section-4.3.4.4\n.. _#ext-x-session-key: https://tools.ietf.org/html/rfc8216#section-4.3.4.5\n.. _#ext-x-independent-segments: https://tools.ietf.org/html/rfc8216#section-4.3.5.1\n.. _#ext-x-start: https://tools.ietf.org/html/rfc8216#section-4.3.5.2\n.. _#ext-x-preload-hint: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.5.3\n.. _#ext-x-daterange: https://tools.ietf.org/html/rfc8216#section-4.3.2.7\n.. _#ext-x-gap: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-05#section-4.4.2.7\n.. _#ext-x-content-steering: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-10#section-4.4.6.64\n.. _#ext-x-skip: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.5.2\n.. _#ext-x-rendition-report: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.5.4\n.. _#ext-x-part: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.4.9\n.. _#ext-x-part-inf: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.3.7\n.. _#ext-x-server-control: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-4.4.3.8\n.. _issue 1: https://github.com/globocom/m3u8/issues/1\n.. _variant streams: https://tools.ietf.org/html/rfc8216#section-6.2.4\n.. _example here: http://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-8.5\n.. _issue 4: https://github.com/globocom/m3u8/issues/4\n.. _i-frame playlists: https://tools.ietf.org/html/rfc8216#section-4.3.4.3\n.. _apple's documentation: https://developer.apple.com/library/ios/technotes/tn2288/_index.html#//apple_ref/doc/uid/dts40012238-ch1-i_frame_playlist\n.. _alternative audio: http://tools.ietf.org/html/draft-pantos-http-live-streaming-08#section-8.7\n.. _vod: https://developer.apple.com/library/mac/technotes/tn2288/_index.html#//apple_ref/doc/uid/dts40012238-ch1-tntag2\n.. _event: https://developer.apple.com/library/mac/technotes/tn2288/_index.html#//apple_ref/doc/uid/dts40012238-ch1-event_playlist\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "m3u8",
  "package_url": "https://pypi.org/project/m3u8/",
  "project_url": "https://pypi.org/project/m3u8/",
  "project_urls": {
    "Homepage": "https://github.com/globocom/m3u8"
  },
  "release_url": "https://pypi.org/project/m3u8/4.0.0/",
  "requires_dist": [
    "backports-datetime-fromisoformat ; python_version < \"3.11\""
  ],
  "requires_python": ">=3.7",
  "summary": "python m3u8 parser",
  "version": "4.0.0",
  "releases": [],
  "developers": [
    "globo"
  ],
  "kwds": "variant_m3u8 m3u8_obj m3u8 image_media_playlist_v0_4 _m3u8",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_m3u8",
  "homepage": "https://github.com/globocom/m3u8",
  "release_count": 55,
  "dependency_ids": [
    "pypi_backports_datetime_fromisoformat"
  ]
}