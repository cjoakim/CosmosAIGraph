{
  "classifiers": [
    "license :: osi approved",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# prometheus fastapi instrumentator <!-- omit in toc -->\n\n[![pypi-version](https://badge.fury.io/py/prometheus-fastapi-instrumentator.svg)](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator)\n[![python-versions](https://img.shields.io/pypi/pyversions/prometheus-fastapi-instrumentator.svg)](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator)\n[![downloads](https://pepy.tech/badge/prometheus-fastapi-instrumentator/month)](https://pepy.tech/project/prometheus-fastapi-instrumentator/month)\n[![build](https://img.shields.io/github/actions/workflow/status/trallnag/kubestatus2cloudwatch/ci.yaml?branch=master)](https://github.com/trallnag/kubestatus2cloudwatch/actions)\n[![codecov](https://codecov.io/gh/trallnag/prometheus-fastapi-instrumentator/branch/master/graph/badge.svg)](https://codecov.io/gh/trallnag/prometheus-fastapi-instrumentator)\n\na configurable and modular prometheus instrumentator for your fastapi. install\n`prometheus-fastapi-instrumentator` from\n[pypi](https://pypi.python.org/pypi/prometheus-fastapi-instrumentator/). here is\nthe fast track to get started with a pre-configured instrumentator. import the\ninstrumentator class:\n\n```python\nfrom prometheus_fastapi_instrumentator import instrumentator\n```\n\ninstrument your app with default metrics and expose the metrics:\n\n```python\ninstrumentator().instrument(app).expose(app)\n```\n\ndepending on your code you might have to use the following instead:\n\n```python\ninstrumentator = instrumentator().instrument(app)\n\n@app.on_event(\"startup\")\nasync def _startup():\n    instrumentator.expose(app)\n```\n\nwith this, your fastapi is instrumented and metrics are ready to be scraped. the\ndefaults give you:\n\n- counter `http_requests_total` with `handler`, `status` and `method`. total\n  number of requests.\n- summary `http_request_size_bytes` with `handler`. added up total of the\n  content lengths of all incoming requests.\n- summary `http_response_size_bytes` with `handler`. added up total of the\n  content lengths of all outgoing responses.\n- histogram `http_request_duration_seconds` with `handler` and `method`. only a\n  few buckets to keep cardinality low.\n- histogram `http_request_duration_highr_seconds` without any labels. large\n  number of buckets (>20).\n\nin addition, following behavior is active:\n\n- status codes are grouped into `2xx`, `3xx` and so on.\n- requests without a matching template are grouped into the handler `none`.\n\nif one of these presets does not suit your needs you can do one of multiple\nthings:\n\n- pick one of the already existing closures from\n  [`metrics`](./src/prometheus_fastapi_instrumentator/metrics.py) and pass it to\n  the instrumentator instance. see [here](#adding-metrics) how to do that.\n- create your own instrumentation function that you can pass to an\n  instrumentator instance. see [here](#creating-new-metrics) to learn how more.\n- don't use this package at all and just use the source code as inspiration on\n  how to instrument your fastapi.\n\n## table of contents <!-- omit in toc -->\n\n<!--toc-->\n\n- [disclaimer](#disclaimer)\n- [features](#features)\n- [advanced usage](#advanced-usage)\n  - [creating the instrumentator](#creating-the-instrumentator)\n  - [adding metrics](#adding-metrics)\n  - [creating new metrics](#creating-new-metrics)\n  - [perform instrumentation](#perform-instrumentation)\n  - [specify namespace and subsystem](#specify-namespace-and-subsystem)\n  - [exposing endpoint](#exposing-endpoint)\n- [contributing](#contributing)\n- [licensing](#licensing)\n\n<!--toc-->\n\n## disclaimer\n\nnot made for generic prometheus instrumentation in python. use the prometheus\nclient library for that. this packages uses it as well.\n\nall the generic middleware and instrumentation code comes with a cost in\nperformance that can become noticeable.\n\n## features\n\nbeyond the fast track, this instrumentator is **highly configurable** and it is\nvery easy to customize and adapt to your specific use case. here is a list of\nsome of these options you may opt-in to:\n\n- regex patterns to ignore certain routes.\n- completely ignore untemplated routes.\n- control instrumentation and exposition with an env var.\n- rounding of latencies to a certain decimal number.\n- renaming of labels and the metric.\n- metrics endpoint can compress data with gzip.\n- opt-in metric to monitor the number of requests in progress.\n\nit also features a **modular approach to metrics** that should instrument all\nfastapi endpoints. you can either choose from a set of already existing metrics\nor create your own. and every metric function by itself can be configured as\nwell. you can see ready to use metrics\n[here](https://trallnag.github.io/prometheus-fastapi-instrumentator/metrics.html).\n\n## advanced usage\n\nthis chapter contains an example on the advanced usage of the prometheus fastapi\ninstrumentator to showcase most of it's features. fore more concrete info check\nout the\n[automatically generated documentation](https://trallnag.github.io/prometheus-fastapi-instrumentator/).\n\n### creating the instrumentator\n\nwe start by creating an instance of the instrumentator. notice the additional\n`metrics` import. this will come in handy later.\n\n```python\nfrom prometheus_fastapi_instrumentator import instrumentator, metrics\n\ninstrumentator = instrumentator(\n    should_group_status_codes=false,\n    should_ignore_untemplated=true,\n    should_respect_env_var=true,\n    should_instrument_requests_inprogress=true,\n    excluded_handlers=[\".*admin.*\", \"/metrics\"],\n    env_var_name=\"enable_metrics\",\n    inprogress_name=\"inprogress\",\n    inprogress_labels=true,\n)\n```\n\nunlike in the fast track example, now the instrumentation and exposition will\nonly take place if the environment variable `enable_metrics` is `true` at\nrun-time. this can be helpful in larger deployments with multiple services\ndepending on the same base fastapi.\n\n### adding metrics\n\nlet's say we also want to instrument the size of requests and responses. for\nthis we use the `add()` method. this method does nothing more than taking a\nfunction and adding it to a list. then during run-time every time fastapi\nhandles a request all functions in this list will be called while giving them a\nsingle argument that stores useful information like the request and response\nobjects. if no `add()` at all is used, the default metric gets added in the\nbackground. this is what happens in the fast track example.\n\nall instrumentation functions are stored as closures in the `metrics` module.\nfore more concrete info check out the\n[automatically generated documentation](https://trallnag.github.io/prometheus-fastapi-instrumentator/).\n\nclosures come in handy here because it allows us to configure the functions\nwithin.\n\n```python\ninstrumentator.add(metrics.latency(buckets=(1, 2, 3,)))\n```\n\nthis simply adds the metric you also get in the fast track example with a\nmodified buckets argument. but we would also like to record the size of all\nrequests and responses.\n\n```python\ninstrumentator.add(\n    metrics.request_size(\n        should_include_handler=true,\n        should_include_method=false,\n        should_include_status=true,\n        metric_namespace=\"a\",\n        metric_subsystem=\"b\",\n    )\n).add(\n    metrics.response_size(\n        should_include_handler=true,\n        should_include_method=false,\n        should_include_status=true,\n        metric_namespace=\"namespace\",\n        metric_subsystem=\"subsystem\",\n    )\n)\n```\n\nyou can add as many metrics you like to the instrumentator.\n\n### creating new metrics\n\nas already mentioned, it is possible to create custom functions to pass on to\n`add()`. this is also how the default metrics are implemented. the documentation\nand code\n[here](https://trallnag.github.io/prometheus-fastapi-instrumentator/metrics.html)\nis helpful to get an overview.\n\nthe basic idea is that the instrumentator creates an `info` object that contains\neverything necessary for instrumentation based on the configuration of the\ninstrumentator. this includes the raw request and response objects but also the\nmodified handler, grouped status code and duration. next, all registered\ninstrumentation functions are called. they get `info` as their single argument.\n\nlet's say we want to count the number of times a certain language has been\nrequested.\n\n```python\nfrom typing import callable\nfrom prometheus_fastapi_instrumentator.metrics import info\nfrom prometheus_client import counter\n\ndef http_requested_languages_total() -> callable[[info], none]:\n    metric = counter(\n        \"http_requested_languages_total\",\n        \"number of times a certain language has been requested.\",\n        labelnames=(\"langs\",)\n    )\n\n    def instrumentation(info: info) -> none:\n        langs = set()\n        lang_str = info.request.headers[\"accept-language\"]\n        for element in lang_str.split(\",\"):\n            element = element.split(\";\")[0].strip().lower()\n            langs.add(element)\n        for language in langs:\n            metric.labels(language).inc()\n\n    return instrumentation\n```\n\nthe function `http_requested_languages_total` is used for persistent elements\nthat are stored between all instrumentation executions (for example the metric\ninstance itself). next comes the closure. this function must adhere to the shown\ninterface. it will always get an `info` object that contains the request,\nresponse and a few other modified informations. for example the (grouped) status\ncode or the handler. finally, the closure is returned.\n\n**important:** the response object inside `info` can either be the response\nobject or `none`. in addition, errors thrown in the handler are not caught by\nthe instrumentator. i recommend to check the documentation and/or the source\ncode before creating your own metrics.\n\nto use it, we hand over the closure to the instrumentator object.\n\n```python\ninstrumentator.add(http_requested_languages_total())\n```\n\n### perform instrumentation\n\nup to this point, the fastapi has not been touched at all. everything has been\nstored in the `instrumentator` only. to actually register the instrumentation\nwith fastapi, the `instrument()` method has to be called.\n\n```python\ninstrumentator.instrument(app)\n```\n\nnotice that this will do nothing if `should_respect_env_var` has been set during\nconstruction of the instrumentator object and the respective env var is not\nfound.\n\n### specify namespace and subsystem\n\nyou can specify the namespace and subsystem of the metrics by passing them in\nthe instrument method.\n\n```python\nfrom prometheus_fastapi_instrumentator import instrumentator\n\n@app.on_event(\"startup\")\nasync def startup():\n    instrumentator().instrument(app, metric_namespace='myproject', metric_subsystem='myservice').expose(app)\n```\n\nthen your metrics will contain the namespace and subsystem in the metric name.\n\n```sh\n# type myproject_myservice_http_request_duration_highr_seconds histogram\nmyproject_myservice_http_request_duration_highr_seconds_bucket{le=\"0.01\"} 0.0\n```\n\n### exposing endpoint\n\nto expose an endpoint for the metrics either follow\n[prometheus python client](https://github.com/prometheus/client_python) and add\nthe endpoint manually to the fastapi or serve it on a separate server. you can\nalso use the included `expose` method. it will add an endpoint to the given\nfastapi. with `should_gzip` you can instruct the endpoint to compress the data\nas long as the client accepts gzip encoding. prometheus for example does by\ndefault. beware that network bandwith is often cheaper than cpu cycles.\n\n```python\ninstrumentator.expose(app, include_in_schema=false, should_gzip=true)\n```\n\nnotice that this will to nothing if `should_respect_env_var` has been set during\nconstruction of the instrumentator object and the respective env var is not\nfound.\n\n## contributing\n\nplease refer to [`contributing.md`](contributing).\n\nconsult [`development.md`](development.md) for guidance regarding development.\n\nread [`release.md`](release.md) for details about the release process.\n\n## licensing\n\nthe default license for this project is the\n[isc license](https://choosealicense.com/licenses/isc). a permissive license\nfunctionally equivalent to the bsd 2-clause and mit licenses, removing some\nlanguage that is no longer necessary. see [`license`](license) for the license\ntext.\n\nthe [bsd 3-clause license](https://choosealicense.com/licenses/bsd-3-clause) is\nused as the license for the\n[`routing`](src/prometheus_fastapi_instrumentator/routing.py) module. this is\ndue to it containing code from\n[elastic/apm-agent-python](https://github.com/elastic/apm-agent-python). bsd\n3-clause is a permissive license similar to the bsd 2-clause license, but with a\n3rd clause that prohibits others from using the name of the copyright holder or\nits contributors to promote derived products without written consent. the\nlicense text is included in the module itself.\n",
  "docs_url": null,
  "keywords": "prometheus,instrumentation,fastapi,exporter,metrics",
  "license": "isc",
  "name": "prometheus-fastapi-instrumentator",
  "package_url": "https://pypi.org/project/prometheus-fastapi-instrumentator/",
  "project_url": "https://pypi.org/project/prometheus-fastapi-instrumentator/",
  "project_urls": {
    "Homepage": "https://github.com/trallnag/prometheus-fastapi-instrumentator",
    "Repository": "https://github.com/trallnag/prometheus-fastapi-instrumentator"
  },
  "release_url": "https://pypi.org/project/prometheus-fastapi-instrumentator/6.1.0/",
  "requires_dist": [
    "fastapi (>=0.38.1,<1.0.0)",
    "prometheus-client (>=0.8.0,<1.0.0)"
  ],
  "requires_python": ">=3.7.0,<4.0.0",
  "summary": "instrument your fastapi with prometheus metrics.",
  "version": "6.1.0",
  "releases": [],
  "developers": [
    "tim@trallnag.com",
    "tim_schwenke"
  ],
  "kwds": "prometheus_fastapi_instrumentator prometheus_client prometheus instrumentation enable_metrics",
  "license_kwds": "isc",
  "libtype": "pypi",
  "id": "pypi_prometheus_fastapi_instrumentator",
  "homepage": "https://github.com/trallnag/prometheus-fastapi-instrumentator",
  "release_count": 34,
  "dependency_ids": [
    "pypi_fastapi",
    "pypi_prometheus_client"
  ]
}