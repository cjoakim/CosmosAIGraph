{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing"
  ],
  "description": "testresources: extensions to python unittest to allow declarative use\nof resources by test cases.\n\ncopyright (c) 2005-2013  robert collins <robertc@robertcollins.net>\n\n  licensed under either the apache license, version 2.0 or the bsd 3-clause\n  license at the users choice. a copy of both licenses are available in the\n  project source as apache-2.0 and bsd. you may not use this file except in\n  compliance with one of these two licences.\n\n  unless required by applicable law or agreed to in writing, software\n  distributed under these licenses is distributed on an \"as is\" basis, without\n  warranties or conditions of any kind, either express or implied.  see the\n  license you chose for the specific language governing permissions and\n  limitations under that license.\n\n  see the copying file for full details on the licensing of testresources.\n\n\ntestresources\n+++++++++++++\n\ntestresources extends unittest with a clean and simple api to provide test\noptimisation where expensive common resources are needed for test cases - for\nexample sample working trees for vcs systems, reference databases for\nenterprise applications, or web servers ... let imagination run wild.\n\ndependencies to build/selftest\n==============================\n\n* python 2.6+ (or 3.3+)\n* docutils\n* testtools (http://pypi.python.org/pypi/testtools/)\n* fixtures (http://pypi.python.org/pypi/fixtures)\n\ndependencies to use testresources\n=================================\n\n* python 2.6+ (or 3.3+)\n\nfor older versions of python, testresources <= 1.0.0 supported 2.4, 2.5 and\n3.2.\n\nhow testresources works\n=======================\n\nthe basic idea of testresources is:\n\n* tests declare the resources they need in a ``resources`` attribute.\n* when the test is run, the required resource objects are allocated (either\n  newly constructed, or reused), and assigned to attributes of the testcase.\n\ntestresources distinguishes a 'resource manager' (a subclass of\n``testresourcemanager``) which acts as a kind of factory, and a 'resource'\nwhich can be any kind of object returned from the manager class's\n``getresource`` method.\n\nresources are either clean or dirty.  being clean means they have same state in\nall important ways as a newly constructed instance and they can therefore be\nsafely reused.\n\nat this time, testresources is incompatible with setupclass and setupmodule -\nwhen an optimisingtestsuite is wrapped around a test suite using those\nfeatures, the result will be flattened for optimisation and those setup's will\nnot run at all.\n\nmain classes\n============\n\ntestresources.resourcedtestcase\n-------------------------------\n\nby extending or mixing-in this class, tests can have necessary resources\nautomatically allocated and disposed or recycled.\n\nresourcetestcase can be used as a base class for tests, and when that is done\ntests will have their ``resources`` attribute automatically checked for\nresources by both optimisingtestsuite and their own setup() and teardown()\nmethods. (this allows tests to remain functional without needing this specific\ntestsuite as a container). alternatively, you can call setupresources(self,\nresources, test_result) and teardownresources(self, resources, test_result)\nfrom your own classes setup and teardown and the same behaviour will be\nactivated.\n\nto declare the use of a resource, set the ``resources`` attribute to a list of\ntuples of ``(attribute_name, resource_manager)``.\n\nduring setup, for each declared requirement, the test gains an attribute\npointing to an allocated resource, which is the result of calling\n``resource_manager.getresource()``.  ``finishedwith`` will be called on each\nresource during teardown().\n\nfor example::\n\n    class testlog(testresources.resourcedtestcase):\n\n        resources = [('branch', bzrpopulatedbranch())]\n\n        def test_log(self):\n            show_log(self.branch, ...)\n\ntestresources.testresourcemanager\n---------------------------------\n\na testresourcemanager is an object that tests can use to create resources.  it\ncan be overridden to manage different types of resources.  normally test code\ndoesn't need to call any methods on it, as this will be arranged by the\ntestresources machinery.\n\nwhen implementing a new ``testresourcemanager`` subclass you should consider\noverriding these methods:\n\n``make``\n    must be overridden in every concrete subclass.\n\n    returns a new instance of the resource object\n    (the actual resource, not the testresourcemanager).  doesn't need to worry about\n    reuse, which is taken care of separately.  this method is only called when a\n    new resource is definitely needed.\n\n    ``make`` is called by ``getresource``; you should not normally need to override\n    the latter.\n\n``clean``\n    cleans up an existing resource instance, eg by deleting a directory or\n    closing a network connection.  by default this does nothing, which may be\n    appropriate for resources that are automatically garbage collected.\n\n``_reset``\n    reset a no-longer-used dirty resource to a clean state.  by default this\n    just discards it and creates a new one, but for some resources there may be a\n    faster way to reset them.\n\n``isdirty``\n    check whether an existing resource is dirty.  by default this just reports\n    whether ``testresourcemanager.dirtied`` has been called or any of the\n    dependency resources are dirty.\n\nfor instance::\n\n    class temporarydirectoryresource(testresourcemanager):\n\n        def clean(self, resource):\n            shutil.rmtree(resource)\n\n        def make(self):\n            return tempfile.mkdtemp()\n\n        def isdirty(self, resource):\n            # can't detect when the directory is written to, so assume it\n            # can never be reused.  we could list the directory, but that might\n            # not catch it being open as a cwd etc.\n            return true\n\nthe ``resources`` list on the testresourcemanager object is used to declare\ndependencies. for instance, a databaseresource that needs a temporarydirectory\nmight be declared with a resources list::\n\n    class databaseresource(testresourcemanager):\n\n        resources = [(\"scratchdir\", temporarydirectoryresource())]\n\nmost importantly, two getresources to the same testresourcemanager with no\nfinishedwith call in the middle, will return the same object as long as it is\nnot dirty.\n\nwhen a test has a dependency and that dependency successfully completes but\nreturns none, the framework does *not* consider this an error: be sure to always\nreturn a valid resource, or raise an error. error handling hasn't been heavily\nexercised, but any bugs in this area will be promptly dealt with.\n\na sample testresourcemanager can be found in the doc/ folder.\n\nsee pydoc testresources.testresourcemanager for details.\n\ntestresources.genericresource\n-----------------------------\n\nglue to adapt testresources to an existing resource-like class.\n\ntestresources.fixtureresource\n-----------------------------\n\nglue to adapt testresources to the simpler fixtures.fixture api. long\nterm testresources is likely to consolidate on that simpler api as the\nrecommended method of writing resources.\n\ntestresources.optimisingtestsuite\n---------------------------------\n\nthis testsuite will introspect all the test cases it holds directly and if\nthey declare needed resources, will run the tests in an order that attempts to\nminimise the number of setup and tear downs required. it attempts to achieve\nthis by callling getresource() and finishedwith() around the sequence of tests\nthat use a specific resource.\n\ntests are added to an optimisingtestsuite as normal. any standard library\ntestsuite objects will be flattened, while any custom testsuite subclasses\nwill be distributed across their member tests. this means that any custom\nlogic in test suites should be preserved, at the price of some level of\noptimisation.\n\nbecause the test suite does the optimisation, you can control the amount of\noptimising that takes place by adding more or fewer tests to a single\noptimisingtestsuite. you could add everything to a single optimisingtestsuite,\ngetting global optimisation or you could use several smaller\noptimisingtestsuites.\n\n\ntestresources.testloader\n------------------------\n\nthis is a trivial testloader that creates optimisingtestsuites by default.\n\nunittest.testresult\n-------------------\n\ntestresources will log activity about resource creation and destruction to the\nresult object tests are run with. 6 extension methods are looked for:\n``startcleanresource``, ``stopcleanresource``, ``startmakeresource``,\n``stopmakeresource``, ``startresetresource`` and finally ``stopresetresource``.\n``testresources.tests.resultwithresourceextensions`` is\nan example of a ``testresult`` with these methods present.\n\ncontrolling resource reuse\n==========================\n\nwhen or how do i mark the resource dirtied?\n\nthe simplest approach is to have ``testresourcemanager.make`` call ``self.dirtied``:\nthe resource is always immediately dirty and will never be reused without first\nbeing reset.  this is appropriate when the underlying resource is cheap to\nreset or recreate, or when it's hard to detect whether it's been dirtied or to\ntrap operations that change it.\n\nalternatively, override ``testresourcemanager.isdirty`` and inspect the resource to\nsee if it is safe to reuse.\n\nfinally, you can arrange for the returned resource to always call back to\n``testresourcemanager.dirtied`` on the first operation that mutates it.\n\nfaq\n===\n\n* can i dynamically request resources inside a test method?\n\n  generally, no, you shouldn't do this.  the idea is that the resources are\n  declared statically, so that testresources can \"smooth\" resource usage across\n  several tests.\n\n  but, you may be able to find some object that is statically declared and reusable\n  to act as the resource, which can then provide methods to generate sub-elements\n  of itself during a test.\n\n* if the resource is held inside the testresourcemanager object, and the\n  testresourcemanager is typically constructed inline in the test case\n  ``resources`` attribute, how can they be shared across different test\n  classes?\n\n  good question.\n\n  i guess you should arrange for a single instance to be held in an appropriate\n  module scope, then referenced by the test classes that want to share it.\n\nreleasing\n=========\n\n1. add a section to news (after in development).\n2. git tag -s\n3. python setup.py sdist bdist_wheel upload -s",
  "docs_url": null,
  "keywords": "",
  "license": "unknown",
  "name": "testresources",
  "package_url": "https://pypi.org/project/testresources/",
  "project_url": "https://pypi.org/project/testresources/",
  "project_urls": {
    "Download": "UNKNOWN",
    "Homepage": "https://launchpad.net/testresources"
  },
  "release_url": "https://pypi.org/project/testresources/2.0.1/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "testresources, a pyunit extension for managing expensive test resources",
  "version": "2.0.1",
  "releases": [],
  "developers": [
    "https",
    "testresources_developers"
  ],
  "kwds": "testresources testresourcemanager resourcetestcase setupresources getresources",
  "license_kwds": "unknown",
  "libtype": "pypi",
  "id": "pypi_testresources",
  "homepage": "https://launchpad.net/testresources",
  "release_count": 11,
  "dependency_ids": []
}