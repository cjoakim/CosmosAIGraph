{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "aniso8601\n=========\n\nanother iso 8601 parser for python\n----------------------------------\n\nfeatures\n========\n* pure python implementation\n* logical behavior\n\n  - parse a time, get a `datetime.time <http://docs.python.org/3/library/datetime.html#datetime.time>`_\n  - parse a date, get a `datetime.date <http://docs.python.org/3/library/datetime.html#datetime.date>`_\n  - parse a datetime, get a `datetime.datetime <http://docs.python.org/3/library/datetime.html#datetime.datetime>`_\n  - parse a duration, get a `datetime.timedelta <http://docs.python.org/3/library/datetime.html#datetime.timedelta>`_\n  - parse an interval, get a tuple of dates or datetimes\n  - parse a repeating interval, get a date or datetime `generator <https://wiki.python.org/moin/generators>`_\n\n* utc offset represented as fixed-offset tzinfo\n* parser separate from representation, allowing parsing to different datetime representations (see `builders`_)\n* no regular expressions\n\ninstallation\n============\n\nthe recommended installation method is to use pip::\n\n  $ pip install aniso8601\n\nalternatively, you can download the source (git repository hosted at `bitbucket <https://bitbucket.org/nielsenb/aniso8601>`_) and install directly::\n\n  $ python setup.py install\n\nuse\n===\n\nparsing datetimes\n-----------------\n\n*consider* `datetime.datetime.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.datetime.fromisoformat>`_ *for basic iso 8601 datetime parsing*\n\nto parse a typical iso 8601 datetime string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_datetime('1977-06-10t12:00:00z')\n  datetime.datetime(1977, 6, 10, 12, 0, tzinfo=+0:00:00 utc)\n\nalternative delimiters can be specified, for example, a space::\n\n  >>> aniso8601.parse_datetime('1977-06-10 12:00:00z', delimiter=' ')\n  datetime.datetime(1977, 6, 10, 12, 0, tzinfo=+0:00:00 utc)\n\nutc offsets are supported::\n\n  >>> aniso8601.parse_datetime('1979-06-05t08:00:00-08:00')\n  datetime.datetime(1979, 6, 5, 8, 0, tzinfo=-8:00:00 utc)\n\nif a utc offset is not specified, the returned datetime will be naive::\n\n  >>> aniso8601.parse_datetime('1983-01-22t08:00:00')\n  datetime.datetime(1983, 1, 22, 8, 0)\n\nleap seconds are currently not supported and attempting to parse one raises a :code:`leapseconderror`::\n\n  >>> aniso8601.parse_datetime('2018-03-06t23:59:60')\n  traceback (most recent call last):\n    file \"<stdin>\", line 1, in <module>\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/time.py\", line 196, in parse_datetime\n      return builder.build_datetime(datepart, timepart)\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 237, in build_datetime\n      cls._build_object(time))\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 336, in _build_object\n      return cls.build_time(hh=parsetuple.hh, mm=parsetuple.mm,\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 191, in build_time\n      hh, mm, ss, tz = cls.range_check_time(hh, mm, ss, tz)\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 266, in range_check_time\n      raise leapseconderror('leap seconds are not supported.')\n  aniso8601.exceptions.leapseconderror: leap seconds are not supported.\n\nto get the resolution of an iso 8601 datetime string::\n\n  >>> aniso8601.get_datetime_resolution('1977-06-10t12:00:00z') == aniso8601.resolution.timeresolution.seconds\n  true\n  >>> aniso8601.get_datetime_resolution('1977-06-10t12:00') == aniso8601.resolution.timeresolution.minutes\n  true\n  >>> aniso8601.get_datetime_resolution('1977-06-10t12') == aniso8601.resolution.timeresolution.hours\n  true\n\nnote that datetime resolutions map to :code:`timeresolution` as a valid datetime must have at least one time member so the resolution mapping is equivalent.\n\nparsing dates\n-------------\n\n*consider* `datetime.date.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.date.fromisoformat>`_ *for basic iso 8601 date parsing*\n\nto parse a date represented in an iso 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_date('1984-04-23')\n  datetime.date(1984, 4, 23)\n\nbasic format is supported as well::\n\n  >>> aniso8601.parse_date('19840423')\n  datetime.date(1984, 4, 23)\n\nto parse a date using the iso 8601 week date format::\n\n  >>> aniso8601.parse_date('1986-w38-1')\n  datetime.date(1986, 9, 15)\n\nto parse an iso 8601 ordinal date::\n\n  >>> aniso8601.parse_date('1988-132')\n  datetime.date(1988, 5, 11)\n\nto get the resolution of an iso 8601 date string::\n\n  >>> aniso8601.get_date_resolution('1981-04-05') == aniso8601.resolution.dateresolution.day\n  true\n  >>> aniso8601.get_date_resolution('1981-04') == aniso8601.resolution.dateresolution.month\n  true\n  >>> aniso8601.get_date_resolution('1981') == aniso8601.resolution.dateresolution.year\n  true\n\nparsing times\n-------------\n\n*consider* `datetime.time.fromisoformat <https://docs.python.org/3/library/datetime.html#datetime.time.fromisoformat>`_ *for basic iso 8601 time parsing*\n\nto parse a time formatted as an iso 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_time('11:31:14')\n  datetime.time(11, 31, 14)\n\nas with all of the above, basic format is supported::\n\n  >>> aniso8601.parse_time('113114')\n  datetime.time(11, 31, 14)\n\na utc offset can be specified for times::\n\n  >>> aniso8601.parse_time('17:18:19-02:30')\n  datetime.time(17, 18, 19, tzinfo=-2:30:00 utc)\n  >>> aniso8601.parse_time('171819z')\n  datetime.time(17, 18, 19, tzinfo=+0:00:00 utc)\n\nreduced accuracy is supported::\n\n  >>> aniso8601.parse_time('21:42')\n  datetime.time(21, 42)\n  >>> aniso8601.parse_time('22')\n  datetime.time(22, 0)\n\na decimal fraction is always allowed on the lowest order element of an iso 8601 formatted time::\n\n  >>> aniso8601.parse_time('22:33.5')\n  datetime.time(22, 33, 30)\n  >>> aniso8601.parse_time('23.75')\n  datetime.time(23, 45)\n\nthe decimal fraction can be specified with a comma instead of a full-stop::\n\n  >>> aniso8601.parse_time('22:33,5')\n  datetime.time(22, 33, 30)\n  >>> aniso8601.parse_time('23,75')\n  datetime.time(23, 45)\n\nleap seconds are currently not supported and attempting to parse one raises a :code:`leapseconderror`::\n\n  >>> aniso8601.parse_time('23:59:60')\n  traceback (most recent call last):\n    file \"<stdin>\", line 1, in <module>\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/time.py\", line 174, in parse_time\n      return builder.build_time(hh=hourstr, mm=minutestr, ss=secondstr, tz=tz)\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 191, in build_time\n      hh, mm, ss, tz = cls.range_check_time(hh, mm, ss, tz)\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/__init__.py\", line 266, in range_check_time\n      raise leapseconderror('leap seconds are not supported.')\n  aniso8601.exceptions.leapseconderror: leap seconds are not supported.\n\nto get the resolution of an iso 8601 time string::\n\n  >>> aniso8601.get_time_resolution('11:31:14') == aniso8601.resolution.timeresolution.seconds\n  true\n  >>> aniso8601.get_time_resolution('11:31') == aniso8601.resolution.timeresolution.minutes\n  true\n  >>> aniso8601.get_time_resolution('11') == aniso8601.resolution.timeresolution.hours\n  true\n\nparsing durations\n-----------------\n\nto parse a duration formatted as an iso 8601 string::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_duration('p1y2m3dt4h54m6s')\n  datetime.timedelta(428, 17646)\n\nreduced accuracy is supported::\n\n  >>> aniso8601.parse_duration('p1y')\n  datetime.timedelta(365)\n\na decimal fraction is allowed on the lowest order element::\n\n  >>> aniso8601.parse_duration('p1yt3.5m')\n  datetime.timedelta(365, 210)\n\nthe decimal fraction can be specified with a comma instead of a full-stop::\n\n  >>> aniso8601.parse_duration('p1yt3,5m')\n  datetime.timedelta(365, 210)\n\nparsing a duration from a combined date and time is supported as well::\n\n  >>> aniso8601.parse_duration('p0001-01-02t01:30:05')\n  datetime.timedelta(397, 5405)\n\nto get the resolution of an iso 8601 duration string::\n\n  >>> aniso8601.get_duration_resolution('p1y2m3dt4h54m6s') == aniso8601.resolution.durationresolution.seconds\n  true\n  >>> aniso8601.get_duration_resolution('p1y2m3dt4h54m') == aniso8601.resolution.durationresolution.minutes\n  true\n  >>> aniso8601.get_duration_resolution('p1y2m3dt4h') == aniso8601.resolution.durationresolution.hours\n  true\n  >>> aniso8601.get_duration_resolution('p1y2m3d') == aniso8601.resolution.durationresolution.days\n  true\n  >>> aniso8601.get_duration_resolution('p1y2m') == aniso8601.resolution.durationresolution.months\n  true\n  >>> aniso8601.get_duration_resolution('p1y') == aniso8601.resolution.durationresolution.years\n  true\n\nthe default :code:`pythontimebuilder` assumes years are 365 days, and months are 30 days. where calendar level accuracy is required, a `relativetimebuilder <https://bitbucket.org/nielsenb/relativetimebuilder>`_ can be used, see also `builders`_.\n\nparsing intervals\n-----------------\n\nto parse an interval specified by a start and end::\n\n  >>> import aniso8601\n  >>> aniso8601.parse_interval('2007-03-01t13:00:00/2008-05-11t15:30:00')\n  (datetime.datetime(2007, 3, 1, 13, 0), datetime.datetime(2008, 5, 11, 15, 30))\n\nintervals specified by a start time and a duration are supported::\n\n  >>> aniso8601.parse_interval('2007-03-01t13:00:00z/p1y2m10dt2h30m')\n  (datetime.datetime(2007, 3, 1, 13, 0, tzinfo=+0:00:00 utc), datetime.datetime(2008, 5, 9, 15, 30, tzinfo=+0:00:00 utc))\n\na duration can also be specified by a duration and end time::\n\n  >>> aniso8601.parse_interval('p1m/1981-04-05')\n  (datetime.date(1981, 4, 5), datetime.date(1981, 3, 6))\n\nnotice that the result of the above parse is not in order from earliest to latest. if sorted intervals are required, simply use the :code:`sorted` keyword as shown below::\n\n  >>> sorted(aniso8601.parse_interval('p1m/1981-04-05'))\n  [datetime.date(1981, 3, 6), datetime.date(1981, 4, 5)]\n\nthe end of an interval is returned as a datetime when required to maintain the resolution specified by a duration, even if the duration start is given as a date::\n\n  >>> aniso8601.parse_interval('2014-11-12/pt4h54m6.5s')\n  (datetime.date(2014, 11, 12), datetime.datetime(2014, 11, 12, 4, 54, 6, 500000))\n  >>> aniso8601.parse_interval('2007-03-01/p1.5d')\n  (datetime.date(2007, 3, 1), datetime.datetime(2007, 3, 2, 12, 0))\n\nconcise representations are supported::\n\n  >>> aniso8601.parse_interval('2020-01-01/02')\n  (datetime.date(2020, 1, 1), datetime.date(2020, 1, 2))\n  >>> aniso8601.parse_interval('2007-12-14t13:30/15:30')\n  (datetime.datetime(2007, 12, 14, 13, 30), datetime.datetime(2007, 12, 14, 15, 30))\n  >>> aniso8601.parse_interval('2008-02-15/03-14')\n  (datetime.date(2008, 2, 15), datetime.date(2008, 3, 14))\n  >>> aniso8601.parse_interval('2007-11-13t09:00/15t17:00')\n  (datetime.datetime(2007, 11, 13, 9, 0), datetime.datetime(2007, 11, 15, 17, 0))\n\nrepeating intervals are supported as well, and return a `generator <https://wiki.python.org/moin/generators>`_::\n\n  >>> aniso8601.parse_repeating_interval('r3/1981-04-05/p1d')\n  <generator object _date_generator at 0x7fd800d3b320>\n  >>> list(aniso8601.parse_repeating_interval('r3/1981-04-05/p1d'))\n  [datetime.date(1981, 4, 5), datetime.date(1981, 4, 6), datetime.date(1981, 4, 7)]\n\nrepeating intervals are allowed to go in the reverse direction::\n\n  >>> list(aniso8601.parse_repeating_interval('r2/pt1h2m/1980-03-05t01:01:00'))\n  [datetime.datetime(1980, 3, 5, 1, 1), datetime.datetime(1980, 3, 4, 23, 59)]\n\nunbounded intervals are also allowed (python 2)::\n\n  >>> result = aniso8601.parse_repeating_interval('r/pt1h2m/1980-03-05t01:01:00')\n  >>> result.next()\n  datetime.datetime(1980, 3, 5, 1, 1)\n  >>> result.next()\n  datetime.datetime(1980, 3, 4, 23, 59)\n\nor for python 3::\n\n  >>> result = aniso8601.parse_repeating_interval('r/pt1h2m/1980-03-05t01:01:00')\n  >>> next(result)\n  datetime.datetime(1980, 3, 5, 1, 1)\n  >>> next(result)\n  datetime.datetime(1980, 3, 4, 23, 59)\n\nnote that you should never try to convert a generator produced by an unbounded interval to a list::\n\n  >>> list(aniso8601.parse_repeating_interval('r/pt1h2m/1980-03-05t01:01:00'))\n  traceback (most recent call last):\n    file \"<stdin>\", line 1, in <module>\n    file \"/home/nielsenb/jetfuse/aniso8601/aniso8601/aniso8601/builders/python.py\", line 560, in _date_generator_unbounded\n      currentdate += timedelta\n  overflowerror: date value out of range\n\nto get the resolution of an iso 8601 interval string::\n\n  >>> aniso8601.get_interval_resolution('2007-03-01t13:00:00/2008-05-11t15:30:00') == aniso8601.resolution.intervalresolution.seconds\n  true\n  >>> aniso8601.get_interval_resolution('2007-03-01t13:00/2008-05-11t15:30') == aniso8601.resolution.intervalresolution.minutes\n  true\n  >>> aniso8601.get_interval_resolution('2007-03-01t13/2008-05-11t15') == aniso8601.resolution.intervalresolution.hours\n  true\n  >>> aniso8601.get_interval_resolution('2007-03-01/2008-05-11') == aniso8601.resolution.intervalresolution.day\n  true\n  >>> aniso8601.get_interval_resolution('2007-03/p1y') == aniso8601.resolution.intervalresolution.month\n  true\n  >>> aniso8601.get_interval_resolution('2007/p1y') == aniso8601.resolution.intervalresolution.year\n  true\n\nand for repeating iso 8601 interval strings::\n\n  >>> aniso8601.get_repeating_interval_resolution('r3/1981-04-05/p1d') == aniso8601.resolution.intervalresolution.day\n  true\n  >>> aniso8601.get_repeating_interval_resolution('r/pt1h2m/1980-03-05t01:01:00') == aniso8601.resolution.intervalresolution.seconds\n  true\n\nbuilders\n========\n\nbuilders can be used to change the output format of a parse operation. all parse functions have a :code:`builder` keyword argument which accepts a builder class.\n\ntwo builders are included. the :code:`pythontimebuilder` (the default) in the :code:`aniso8601.builders.python` module, and the :code:`tuplebuilder` which returns the parse result as a corresponding named tuple and is located in the :code:`aniso8601.builders` module.\n\ninformation on writing a builder can be found in `builders </builders.rst>`_.\n\nthe following builders are available as separate projects:\n\n* `relativetimebuilder <https://bitbucket.org/nielsenb/relativetimebuilder>`_ supports parsing to `datetutil relativedelta types <https://dateutil.readthedocs.io/en/stable/relativedelta.html>`_ for calendar level accuracy\n* `attotimebuilder <https://bitbucket.org/nielsenb/attotimebuilder>`_ supports parsing directly to `attotime attodatetime and attotimedelta types <https://bitbucket.org/nielsenb/attotime>`_ which support sub-nanosecond precision\n* `numpytimebuilder <https://bitbucket.org/nielsenb/numpytimebuilder>`_ supports parsing directly to `numpy datetime64 and timedelta64 types <https://docs.scipy.org/doc/numpy/reference/arrays.datetime.html>`_\n\ntuplebuilder\n------------\n\nthe :code:`tuplebuilder` returns parse results as `named tuples <https://docs.python.org/3/library/collections.html#collections.namedtuple>`_. it is located in the :code:`aniso8601.builders` module.\n\ndatetimes\n^^^^^^^^^\n\nparsing a datetime returns a :code:`datetimetuple` containing :code:`date` and :code:`time` tuples . the date tuple contains the following parse components: :code:`yyyy`, :code:`mm`, :code:`dd`, :code:`www`, :code:`d`, :code:`ddd`. the time tuple contains the following parse components :code:`hh`, :code:`mm`, :code:`ss`, :code:`tz`, where :code:`tz` itself is a tuple with the following components :code:`negative`, :code:`z`, :code:`hh`, :code:`mm`, :code:`name` with :code:`negative` and :code:`z` being booleans::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import tuplebuilder\n  >>> aniso8601.parse_datetime('1977-06-10t12:00:00', builder=tuplebuilder)\n  datetime(date=date(yyyy='1977', mm='06', dd='10', www=none, d=none, ddd=none), time=time(hh='12', mm='00', ss='00', tz=none))\n  >>> aniso8601.parse_datetime('1979-06-05t08:00:00-08:00', builder=tuplebuilder)\n  datetime(date=date(yyyy='1979', mm='06', dd='05', www=none, d=none, ddd=none), time=time(hh='08', mm='00', ss='00', tz=timezone(negative=true, z=none, hh='08', mm='00', name='-08:00')))\n\ndates\n^^^^^\n\nparsing a date returns a :code:`datetuple` containing the following parse components: :code:`yyyy`, :code:`mm`, :code:`dd`, :code:`www`, :code:`d`, :code:`ddd`::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import tuplebuilder\n  >>> aniso8601.parse_date('1984-04-23', builder=tuplebuilder)\n  date(yyyy='1984', mm='04', dd='23', www=none, d=none, ddd=none)\n  >>> aniso8601.parse_date('1986-w38-1', builder=tuplebuilder)\n  date(yyyy='1986', mm=none, dd=none, www='38', d='1', ddd=none)\n  >>> aniso8601.parse_date('1988-132', builder=tuplebuilder)\n  date(yyyy='1988', mm=none, dd=none, www=none, d=none, ddd='132')\n\ntimes\n^^^^^\n\nparsing a time returns a :code:`timetuple` containing following parse components: :code:`hh`, :code:`mm`, :code:`ss`, :code:`tz`, where :code:`tz` is a :code:`timezonetuple` with the following components :code:`negative`, :code:`z`, :code:`hh`, :code:`mm`, :code:`name`, with :code:`negative` and :code:`z` being booleans::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import tuplebuilder\n  >>> aniso8601.parse_time('11:31:14', builder=tuplebuilder)\n  time(hh='11', mm='31', ss='14', tz=none)\n  >>> aniso8601.parse_time('171819z', builder=tuplebuilder)\n  time(hh='17', mm='18', ss='19', tz=timezone(negative=false, z=true, hh=none, mm=none, name='z'))\n  >>> aniso8601.parse_time('17:18:19-02:30', builder=tuplebuilder)\n  time(hh='17', mm='18', ss='19', tz=timezone(negative=true, z=none, hh='02', mm='30', name='-02:30'))\n\ndurations\n^^^^^^^^^\n\nparsing a duration returns a :code:`durationtuple` containing the following parse components: :code:`pny`, :code:`pnm`, :code:`pnw`, :code:`pnd`, :code:`tnh`, :code:`tnm`, :code:`tns`::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import tuplebuilder\n  >>> aniso8601.parse_duration('p1y2m3dt4h54m6s', builder=tuplebuilder)\n  duration(pny='1', pnm='2', pnw=none, pnd='3', tnh='4', tnm='54', tns='6')\n  >>> aniso8601.parse_duration('p7w', builder=tuplebuilder)\n  duration(pny=none, pnm=none, pnw='7', pnd=none, tnh=none, tnm=none, tns=none)\n\nintervals\n^^^^^^^^^\n\nparsing an interval returns an :code:`intervaltuple` containing the following parse components: :code:`start`, :code:`end`, :code:`duration`, :code:`start` and :code:`end` may both be datetime or date tuples, :code:`duration` is a duration tuple::\n\n  >>> import aniso8601\n  >>> from aniso8601.builders import tuplebuilder\n  >>> aniso8601.parse_interval('2007-03-01t13:00:00/2008-05-11t15:30:00', builder=tuplebuilder)\n  interval(start=datetime(date=date(yyyy='2007', mm='03', dd='01', www=none, d=none, ddd=none), time=time(hh='13', mm='00', ss='00', tz=none)), end=datetime(date=date(yyyy='2008', mm='05', dd='11', www=none, d=none, ddd=none), time=time(hh='15', mm='30', ss='00', tz=none)), duration=none)\n  >>> aniso8601.parse_interval('2007-03-01t13:00:00z/p1y2m10dt2h30m', builder=tuplebuilder)\n  interval(start=datetime(date=date(yyyy='2007', mm='03', dd='01', www=none, d=none, ddd=none), time=time(hh='13', mm='00', ss='00', tz=timezone(negative=false, z=true, hh=none, mm=none, name='z'))), end=none, duration=duration(pny='1', pnm='2', pnw=none, pnd='10', tnh='2', tnm='30', tns=none))\n  >>> aniso8601.parse_interval('p1m/1981-04-05', builder=tuplebuilder)\n  interval(start=none, end=date(yyyy='1981', mm='04', dd='05', www=none, d=none, ddd=none), duration=duration(pny=none, pnm='1', pnw=none, pnd=none, tnh=none, tnm=none, tns=none))\n\na repeating interval returns a :code:`repeatingintervaltuple` containing the following parse components: :code:`r`, :code:`rnn`, :code:`interval`, where :code:`r` is a boolean, :code:`true` for an unbounded interval, :code:`false` otherwise.::\n\n  >>> aniso8601.parse_repeating_interval('r3/1981-04-05/p1d', builder=tuplebuilder)\n  repeatinginterval(r=false, rnn='3', interval=interval(start=date(yyyy='1981', mm='04', dd='05', www=none, d=none, ddd=none), end=none, duration=duration(pny=none, pnm=none, pnw=none, pnd='1', tnh=none, tnm=none, tns=none)))\n  >>> aniso8601.parse_repeating_interval('r/pt1h2m/1980-03-05t01:01:00', builder=tuplebuilder)\n  repeatinginterval(r=true, rnn=none, interval=interval(start=none, end=datetime(date=date(yyyy='1980', mm='03', dd='05', www=none, d=none, ddd=none), time=time(hh='01', mm='01', ss='00', tz=none)), duration=duration(pny=none, pnm=none, pnw=none, pnd=none, tnh='1', tnm='2', tns=none)))\n\ndevelopment\n===========\n\nsetup\n-----\n\nit is recommended to develop using a `virtualenv <https://virtualenv.pypa.io/en/stable/>`_.\n\ninside a virtualenv, development dependencies can be installed automatically::\n\n  $ pip install -e .[dev]\n\n`pre-commit <https://pre-commit.com/>`_ is used for managing pre-commit hooks::\n\n  $ pre-commit install\n\nto run the pre-commit hooks manually::\n\n  $ pre-commit run --all-files\n\ntests\n-----\n\ntests can be run using the `unittest testing framework <https://docs.python.org/3/library/unittest.html>`_::\n\n  $ python -m unittest discover aniso8601\n\ncontributing\n============\n\naniso8601 is an open source project hosted on `bitbucket <https://bitbucket.org/nielsenb/aniso8601>`_.\n\nany and all bugs are welcome on our `issue tracker <https://bitbucket.org/nielsenb/aniso8601/issues>`_.\nof particular interest are valid iso 8601 strings that don't parse, or invalid ones that do. at a minimum,\nbug reports should include an example of the misbehaving string, as well as the expected result. of course\npatches containing unit tests (or fixed bugs) are welcome!\n\nreferences\n==========\n\n* `iso 8601:2004(e) <http://dotat.at/tmp/iso_8601-2004_e.pdf>`_ (caution, pdf link)\n* `wikipedia article on iso 8601 <http://en.wikipedia.org/wiki/iso8601>`_\n* `discussion on alternative iso 8601 parsers for python <https://groups.google.com/forum/#!topic/comp.lang.python/q2w4r89nq1w>`_\n\n\n",
  "docs_url": null,
  "keywords": "iso8601 parser",
  "license": "",
  "name": "aniso8601",
  "package_url": "https://pypi.org/project/aniso8601/",
  "project_url": "https://pypi.org/project/aniso8601/",
  "project_urls": {
    "Documentation": "https://aniso8601.readthedocs.io/",
    "Homepage": "https://bitbucket.org/nielsenb/aniso8601",
    "Source": "https://bitbucket.org/nielsenb/aniso8601",
    "Tracker": "https://bitbucket.org/nielsenb/aniso8601/issues"
  },
  "release_url": "https://pypi.org/project/aniso8601/9.0.1/",
  "requires_dist": [
    "black ; extra == 'dev'",
    "coverage ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "pre-commit ; extra == 'dev'",
    "pyenchant ; extra == 'dev'",
    "pylint ; extra == 'dev'"
  ],
  "requires_python": "",
  "summary": "a library for parsing iso 8601 strings.",
  "version": "9.0.1",
  "releases": [],
  "developers": [
    "brandon_nielsen",
    "nielsenb@jetfuse.net"
  ],
  "kwds": "parse_time parse_datetime parse_duration pythontimebuilder datetimes",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_aniso8601",
  "homepage": "https://bitbucket.org/nielsenb/aniso8601",
  "release_count": 36,
  "dependency_ids": [
    "pypi_black",
    "pypi_coverage",
    "pypi_isort",
    "pypi_pre_commit",
    "pypi_pyenchant",
    "pypi_pylint"
  ]
}