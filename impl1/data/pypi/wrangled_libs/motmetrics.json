{
  "classifiers": [],
  "description": "[![pypi version](https://badge.fury.io/py/motmetrics.svg)](https://badge.fury.io/py/motmetrics) [![build status](https://github.com/cheind/py-motmetrics/actions/workflows/python-package.yml/badge.svg)](https://github.com/cheind/py-motmetrics/actions/workflows/python-package.yml)\r\n\r\n# py-motmetrics\r\n\r\nthe **py-motmetrics** library provides a python implementation of metrics for benchmarking multiple object trackers (mot).\r\n\r\nwhile benchmarking single object trackers is rather straightforward, measuring the performance of multiple object trackers needs careful design as multiple correspondence constellations can arise (see image below). a variety of methods have been proposed in the past and while there is no general agreement on a single method, the methods of [[1,2,3,4]](#references) have received considerable attention in recent years. **py-motmetrics** implements these [metrics](#metrics).\r\n\r\n<div style=\"text-align:center;\">\r\n\r\n![](./motmetrics/etc/mot.png)<br/>\r\n\r\n_pictures courtesy of bernardin, keni, and rainer stiefelhagen [[1]](#references)_\r\n\r\n</div>\r\n\r\nin particular **py-motmetrics** supports `clear-mot`[[1,2]](#references) metrics and `id`[[4]](#references) metrics. both metrics attempt to find a minimum cost assignment between ground truth objects and predictions. however, while clear-mot solves the assignment problem on a local per-frame basis, `id-measure` solves the bipartite graph matching by finding the minimum cost of objects and predictions over all frames. this [blog-post](https://web.archive.org/web/20190413133409/http://vision.cs.duke.edu:80/dukemtmc/idmeasures.html) by ergys illustrates the differences in more detail.\r\n\r\n## features at a glance\r\n\r\n-   _variety of metrics_ <br/>\r\n    provides mota, motp, track quality measures, global id measures and more. the results are [comparable](#motchallengecompatibility) with the popular [motchallenge][motchallenge] benchmarks [(\\*1)](#asterixcompare).\r\n-   _distance agnostic_ <br/>\r\n    supports euclidean, intersection over union and other distances measures.\r\n-   _complete event history_ <br/>\r\n    tracks all relevant per-frame events suchs as correspondences, misses, false alarms and switches.\r\n-   _flexible solver backend_ <br/>\r\n    support for switching minimum assignment cost solvers. supports `scipy`, `ortools`, `munkres` out of the box. auto-tunes solver selection based on [availability and problem size](#solverbackends).\r\n-   _easy to extend_ <br/>\r\n    events and summaries are utilizing [pandas][pandas] for data structures and analysis. new metrics can reuse already computed values from depending metrics.\r\n\r\n<a name=\"metrics\"></a>\r\n\r\n## metrics\r\n\r\n**py-motmetrics** implements the following metrics. the metrics have been aligned with what is reported by [motchallenge][motchallenge] benchmarks.\r\n\r\n```python\r\nimport motmetrics as mm\r\n# list all default metrics\r\nmh = mm.metrics.create()\r\nprint(mh.list_metrics_markdown())\r\n```\r\n\r\n| name                 | description                                                                        |\r\n| :------------------- | :--------------------------------------------------------------------------------- |\r\n| num_frames           | total number of frames.                                                            |\r\n| num_matches          | total number matches.                                                              |\r\n| num_switches         | total number of track switches.                                                    |\r\n| num_false_positives  | total number of false positives (false-alarms).                                    |\r\n| num_misses           | total number of misses.                                                            |\r\n| num_detections       | total number of detected objects including matches and switches.                   |\r\n| num_objects          | total number of unique object appearances over all frames.                         |\r\n| num_predictions      | total number of unique prediction appearances over all frames.                     |\r\n| num_unique_objects   | total number of unique object ids encountered.                                     |\r\n| mostly_tracked       | number of objects tracked for at least 80 percent of lifespan.                     |\r\n| partially_tracked    | number of objects tracked between 20 and 80 percent of lifespan.                   |\r\n| mostly_lost          | number of objects tracked less than 20 percent of lifespan.                        |\r\n| num_fragmentations   | total number of switches from tracked to not tracked.                              |\r\n| motp                 | multiple object tracker precision.                                                 |\r\n| mota                 | multiple object tracker accuracy.                                                  |\r\n| precision            | number of detected objects over sum of detected and false positives.               |\r\n| recall               | number of detections over number of objects.                                       |\r\n| idfp                 | id measures: number of false positive matches after global min-cost matching.      |\r\n| idfn                 | id measures: number of false negatives matches after global min-cost matching.     |\r\n| idtp                 | id measures: number of true positives matches after global min-cost matching.      |\r\n| idp                  | id measures: global min-cost precision.                                            |\r\n| idr                  | id measures: global min-cost recall.                                               |\r\n| idf1                 | id measures: global min-cost f1 score.                                             |\r\n| obj_frequencies      | `pd.series` total number of occurrences of individual objects over all frames.     |\r\n| pred_frequencies     | `pd.series` total number of occurrences of individual predictions over all frames. |\r\n| track_ratios         | `pd.series` ratio of assigned to total appearance count per unique object id.      |\r\n| id_global_assignment | `dict` id measures: global min-cost assignment for id measures.                    |\r\n\r\n<a name=\"motchallengecompatibility\"></a>\r\n\r\n## motchallenge compatibility\r\n\r\n**py-motmetrics** produces results compatible with popular [motchallenge][motchallenge] benchmarks [(\\*1)](#asterixcompare). below are two results taken from motchallenge [matlab devkit][devkit] corresponding to the results of the cem tracker on the training set of the 2015 mot 2dmark.\r\n\r\n```\r\n\r\ntud-campus\r\n idf1  idp  idr| rcll  prcn   far| gt  mt  pt  ml|   fp    fn  ids   fm| mota  motp motal\r\n 55.8 73.0 45.1| 58.2  94.1  0.18|  8   1   6   1|   13   150    7    7| 52.6  72.3  54.3\r\n\r\ntud-stadtmitte\r\n idf1  idp  idr| rcll  prcn   far| gt  mt  pt  ml|   fp    fn  ids   fm| mota  motp motal\r\n 64.5 82.0 53.1| 60.9  94.0  0.25| 10   5   4   1|   45   452    7    6| 56.4  65.4  56.9\r\n\r\n```\r\n\r\nin comparison to **py-motmetrics**\r\n\r\n```\r\n                idf1   idp   idr  rcll  prcn gt mt pt ml fp  fn ids  fm  mota  motp\r\ntud-campus     55.8% 73.0% 45.1% 58.2% 94.1%  8  1  6  1 13 150   7   7 52.6% 0.277\r\ntud-stadtmitte 64.5% 82.0% 53.1% 60.9% 94.0% 10  5  4  1 45 452   7   6 56.4% 0.346\r\n```\r\n\r\n<a name=\"asterixcompare\"></a>(\\*1) besides naming conventions, the only obvious differences are\r\n\r\n-   metric `far` is missing. this metric is given implicitly and can be recovered by `falsepos / frames * 100`.\r\n-   metric `motp` seems to be off. to convert compute `(1 - motp) * 100`. [motchallenge][motchallenge] benchmarks compute `motp` as percentage, while **py-motmetrics** sticks to the original definition of average distance over number of assigned objects [[1]](#references).\r\n\r\nyou can compare tracker results to ground truth in motchallenge format by\r\n\r\n```\r\npython -m motmetrics.apps.eval_motchallenge --help\r\n```\r\n\r\nfor mot16/17, you can run\r\n\r\n```\r\npython -m motmetrics.apps.evaluatetracking --help\r\n```\r\n\r\n## installation\r\n\r\nto install latest development version of **py-motmetrics** (usually a bit more recent than pypi below)\r\n\r\n```\r\npip install git+https://github.com/cheind/py-motmetrics.git\r\n```\r\n\r\n### install via pypi\r\n\r\nto install **py-motmetrics** use `pip`\r\n\r\n```\r\npip install motmetrics\r\n```\r\n\r\npython 3.5/3.6/3.9 and numpy, pandas and scipy is required. if no binary packages are available for your platform and building source packages fails, you might want to try a distribution like conda (see below) to install dependencies.\r\n\r\nalternatively for developing, clone or fork this repository and install in editing mode.\r\n\r\n```\r\npip install -e <path/to/setup.py>\r\n```\r\n\r\n### install via conda\r\n\r\nin case you are using conda, a simple way to run **py-motmetrics** is to create a virtual environment with all the necessary dependencies\r\n\r\n```\r\nconda env create -f environment.yml\r\n> activate motmetrics-env\r\n```\r\n\r\nthen activate / source the `motmetrics-env` and install **py-motmetrics** and run the tests.\r\n\r\n```\r\nactivate motmetrics-env\r\npip install .\r\npytest\r\n```\r\n\r\nin case you already have an environment you install the dependencies from within your environment by\r\n\r\n```\r\nconda install --file requirements.txt\r\npip install .\r\npytest\r\n```\r\n\r\n## usage\r\n\r\n### populating the accumulator\r\n\r\n```python\r\nimport motmetrics as mm\r\nimport numpy as np\r\n\r\n# create an accumulator that will be updated during each frame\r\nacc = mm.motaccumulator(auto_id=true)\r\n\r\n# call update once for per frame. for now, assume distances between\r\n# frame objects / hypotheses are given.\r\nacc.update(\r\n    [1, 2],                     # ground truth objects in this frame\r\n    [1, 2, 3],                  # detector hypotheses in this frame\r\n    [\r\n        [0.1, np.nan, 0.3],     # distances from object 1 to hypotheses 1, 2, 3\r\n        [0.5,  0.2,   0.3]      # distances from object 2 to hypotheses 1, 2, 3\r\n    ]\r\n)\r\n```\r\n\r\nthe code above updates an event accumulator with data from a single frame. here we assume that pairwise object / hypothesis distances have already been computed. note `np.nan` inside the distance matrix. it signals that object `1` cannot be paired with hypothesis `2`. to inspect the current event history simple print the events associated with the accumulator.\r\n\r\n```python\r\nprint(acc.events) # a pandas dataframe containing all events\r\n\r\n\"\"\"\r\n                type  oid hid    d\r\nframeid event\r\n0       0        raw    1   1  0.1\r\n        1        raw    1   2  nan\r\n        2        raw    1   3  0.3\r\n        3        raw    2   1  0.5\r\n        4        raw    2   2  0.2\r\n        5        raw    2   3  0.3\r\n        6      match    1   1  0.1\r\n        7      match    2   2  0.2\r\n        8         fp  nan   3  nan\r\n\"\"\"\r\n```\r\n\r\nthe above data frame contains `raw` and mot events. to obtain just mot events type\r\n\r\n```python\r\nprint(acc.mot_events) # a pandas dataframe containing mot only events\r\n\r\n\"\"\"\r\n                type  oid hid    d\r\nframeid event\r\n0       6      match    1   1  0.1\r\n        7      match    2   2  0.2\r\n        8         fp  nan   3  nan\r\n\"\"\"\r\n```\r\n\r\nmeaning object `1` was matched to hypothesis `1` with distance 0.1. similarily, object `2` was matched to hypothesis `2` with distance 0.2. hypothesis `3` could not be matched to any remaining object and generated a false positive (fp). possible assignments are computed by minimizing the total assignment distance (kuhn-munkres algorithm).\r\n\r\ncontinuing from above\r\n\r\n```python\r\nframeid = acc.update(\r\n    [1, 2],\r\n    [1],\r\n    [\r\n        [0.2],\r\n        [0.4]\r\n    ]\r\n)\r\nprint(acc.mot_events.loc[frameid])\r\n\r\n\"\"\"\r\n        type oid  hid    d\r\nevent\r\n2      match   1    1  0.2\r\n3       miss   2  nan  nan\r\n\"\"\"\r\n```\r\n\r\nwhile object `1` was matched, object `2` couldn't be matched because no hypotheses are left to pair with.\r\n\r\n```python\r\nframeid = acc.update(\r\n    [1, 2],\r\n    [1, 3],\r\n    [\r\n        [0.6, 0.2],\r\n        [0.1, 0.6]\r\n    ]\r\n)\r\nprint(acc.mot_events.loc[frameid])\r\n\r\n\"\"\"\r\n         type oid hid    d\r\nevent\r\n4       match   1   1  0.6\r\n5      switch   2   3  0.6\r\n\"\"\"\r\n```\r\n\r\nobject `2` is now tracked by hypothesis `3` leading to a track switch. note, although a pairing `(1, 3)` with cost less than 0.6 is possible, the algorithm prefers prefers to continue track assignments from past frames which is a property of mot metrics.\r\n\r\n### computing metrics\r\n\r\nonce the accumulator has been populated you can compute and display metrics. continuing the example from above\r\n\r\n```python\r\nmh = mm.metrics.create()\r\nsummary = mh.compute(acc, metrics=['num_frames', 'mota', 'motp'], name='acc')\r\nprint(summary)\r\n\r\n\"\"\"\r\n     num_frames  mota  motp\r\nacc           3   0.5  0.34\r\n\"\"\"\r\n```\r\n\r\ncomputing metrics for multiple accumulators or accumulator views is also possible\r\n\r\n```python\r\nsummary = mh.compute_many(\r\n    [acc, acc.events.loc[0:1]],\r\n    metrics=['num_frames', 'mota', 'motp'],\r\n    names=['full', 'part'])\r\nprint(summary)\r\n\r\n\"\"\"\r\n      num_frames  mota      motp\r\nfull           3   0.5  0.340000\r\npart           2   0.5  0.166667\r\n\"\"\"\r\n```\r\n\r\nfinally, you may want to reformat column names and how column values are displayed.\r\n\r\n```python\r\nstrsummary = mm.io.render_summary(\r\n    summary,\r\n    formatters={'mota' : '{:.2%}'.format},\r\n    namemap={'mota': 'mota', 'motp' : 'motp'}\r\n)\r\nprint(strsummary)\r\n\r\n\"\"\"\r\n      num_frames   mota      motp\r\nfull           3 50.00%  0.340000\r\npart           2 50.00%  0.166667\r\n\"\"\"\r\n```\r\n\r\nfor motchallenge **py-motmetrics** provides predefined metric selectors, formatters and metric names, so that the result looks alike what is provided via their matlab `devkit`.\r\n\r\n```python\r\nsummary = mh.compute_many(\r\n    [acc, acc.events.loc[0:1]],\r\n    metrics=mm.metrics.motchallenge_metrics,\r\n    names=['full', 'part'])\r\n\r\nstrsummary = mm.io.render_summary(\r\n    summary,\r\n    formatters=mh.formatters,\r\n    namemap=mm.io.motchallenge_metric_names\r\n)\r\nprint(strsummary)\r\n\r\n\"\"\"\r\n      idf1   idp   idr  rcll  prcn gt mt pt ml fp fn ids  fm  mota  motp\r\nfull 83.3% 83.3% 83.3% 83.3% 83.3%  2  1  1  0  1  1   1   1 50.0% 0.340\r\npart 75.0% 75.0% 75.0% 75.0% 75.0%  2  1  1  0  1  1   0   0 50.0% 0.167\r\n\"\"\"\r\n```\r\n\r\nin order to generate an overall summary that computes the metrics jointly over all accumulators add `generate_overall=true` as follows\r\n\r\n```python\r\nsummary = mh.compute_many(\r\n    [acc, acc.events.loc[0:1]],\r\n    metrics=mm.metrics.motchallenge_metrics,\r\n    names=['full', 'part'],\r\n    generate_overall=true\r\n    )\r\n\r\nstrsummary = mm.io.render_summary(\r\n    summary,\r\n    formatters=mh.formatters,\r\n    namemap=mm.io.motchallenge_metric_names\r\n)\r\nprint(strsummary)\r\n\r\n\"\"\"\r\n         idf1   idp   idr  rcll  prcn gt mt pt ml fp fn ids  fm  mota  motp\r\nfull    83.3% 83.3% 83.3% 83.3% 83.3%  2  1  1  0  1  1   1   1 50.0% 0.340\r\npart    75.0% 75.0% 75.0% 75.0% 75.0%  2  1  1  0  1  1   0   0 50.0% 0.167\r\noverall 80.0% 80.0% 80.0% 80.0% 80.0%  4  2  2  0  2  2   1   1 50.0% 0.275\r\n\"\"\"\r\n```\r\n\r\n### computing distances\r\n\r\nup until this point we assumed the pairwise object/hypothesis distances to be known. usually this is not the case. you are mostly given either rectangles or points (centroids) of related objects. to compute a distance matrix from them you can use `motmetrics.distance` module as shown below.\r\n\r\n#### euclidean norm squared on points\r\n\r\n```python\r\n# object related points\r\no = np.array([\r\n    [1., 2],\r\n    [2., 2],\r\n    [3., 2],\r\n])\r\n\r\n# hypothesis related points\r\nh = np.array([\r\n    [0., 0],\r\n    [1., 1],\r\n])\r\n\r\nc = mm.distances.norm2squared_matrix(o, h, max_d2=5.)\r\n\r\n\"\"\"\r\n[[  5.   1.]\r\n [ nan   2.]\r\n [ nan   5.]]\r\n\"\"\"\r\n```\r\n\r\n#### intersection over union norm for 2d rectangles\r\n\r\n```python\r\na = np.array([\r\n    [0, 0, 1, 2],    # format x, y, width, height\r\n    [0, 0, 0.8, 1.5],\r\n])\r\n\r\nb = np.array([\r\n    [0, 0, 1, 2],\r\n    [0, 0, 1, 1],\r\n    [0.1, 0.2, 2, 2],\r\n])\r\nmm.distances.iou_matrix(a, b, max_iou=0.5)\r\n\r\n\"\"\"\r\n[[ 0.          0.5                nan]\r\n [ 0.4         0.42857143         nan]]\r\n\"\"\"\r\n```\r\n\r\n<a name=\"solverbackends\"></a>\r\n\r\n### solver backends\r\n\r\nfor large datasets solving the minimum cost assignment becomes the dominant runtime part. **py-motmetrics** therefore supports these solvers out of the box\r\n\r\n-   `lapsolver` - https://github.com/cheind/py-lapsolver\r\n-   `lapjv` - https://github.com/gatagat/lap\r\n-   `scipy` - https://github.com/scipy/scipy/tree/master/scipy\r\n-   `ortools<9.4` - https://github.com/google/or-tools\r\n-   `munkres` - http://software.clapper.org/munkres/\r\n\r\na comparison for different sized matrices is shown below (taken from [here](https://github.com/cheind/py-lapsolver#benchmarks))\r\n\r\nplease note that the x-axis is scaled logarithmically. missing bars indicate excessive runtime or errors in returned result.\r\n![](https://github.com/cheind/py-lapsolver/raw/master/lapsolver/etc/benchmark-dtype-numpy.float32.png)\r\n\r\nby default **py-motmetrics** will try to find a lap solver in the order of the list above. in order to temporarly replace the default solver use\r\n\r\n```python\r\ncosts = ...\r\nmysolver = lambda x: ... # solver code that returns pairings\r\n\r\nwith lap.set_default_solver(mysolver):\r\n    ...\r\n```\r\n\r\n## running tests\r\n\r\n**py-motmetrics** uses the pytest framework. to run the tests, simply `cd` into the source directly and run `pytest`.\r\n\r\n<a name=\"references\"></a>\r\n\r\n### references\r\n\r\n1. bernardin, keni, and rainer stiefelhagen. \"evaluating multiple object tracking performance: the clear mot metrics.\"\r\n   eurasip journal on image and video processing 2008.1 (2008): 1-10.\r\n2. milan, anton, et al. \"mot16: a benchmark for multi-object tracking.\" arxiv preprint arxiv:1603.00831 (2016).\r\n3. li, yuan, chang huang, and ram nevatia. \"learning to associate: hybridboosted multi-target tracker for crowded scene.\"\r\n   computer vision and pattern recognition, 2009. cvpr 2009. ieee conference on. ieee, 2009.\r\n4. performance measures and a data set for multi-target, multi-camera tracking. e. ristani, f. solera, r. s. zou, r. cucchiara and c. tomasi. eccv 2016 workshop on benchmarking multi-target tracking.\r\n\r\n## docker\r\n\r\n### update ground truth and test data:\r\n\r\n/data/train directory should contain mot 2d 2015 ground truth files.\r\n/data/test directory should contain your results.\r\n\r\nyou can check usage and directory listing at\r\nhttps://github.com/cheind/py-motmetrics/blob/master/motmetrics/apps/eval_motchallenge.py\r\n\r\n### build image\r\n\r\ndocker build -t desired-image-name -f dockerfile .\r\n\r\n### run image\r\n\r\ndocker run desired-image-name\r\n\r\n(credits to [christosavg](https://github.com/christosavg))\r\n\r\n## license\r\n\r\n```\r\nmit license\r\n\r\ncopyright (c) 2017-2022 christoph heindl\r\ncopyright (c) 2018 toka\r\ncopyright (c) 2019-2022 jack valmadre\r\n\r\npermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"software\"), to deal\r\nin the software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the software, and to permit persons to whom the software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nthe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the software.\r\n\r\nthe software is provided \"as is\", without warranty of any kind, express or\r\nimplied, including but not limited to the warranties of merchantability,\r\nfitness for a particular purpose and noninfringement. in no event shall the\r\nauthors or copyright holders be liable for any claim, damages or other\r\nliability, whether in an action of contract, tort or otherwise, arising from,\r\nout of or in connection with the software or the use or other dealings in the\r\nsoftware.\r\n```\r\n\r\n[pandas]: http://pandas.pydata.org/\r\n[motchallenge]: https://motchallenge.net/\r\n[devkit]: https://motchallenge.net/devkit/\r\n\r\n\r\n",
  "docs_url": null,
  "keywords": "tracker mot evaluation metrics compare",
  "license": "mit",
  "name": "motmetrics",
  "package_url": "https://pypi.org/project/motmetrics/",
  "project_url": "https://pypi.org/project/motmetrics/",
  "project_urls": {
    "Homepage": "https://github.com/cheind/py-motmetrics"
  },
  "release_url": "https://pypi.org/project/motmetrics/1.4.0/",
  "requires_dist": [
    "numpy (>=1.12.1)",
    "pandas (>=0.23.1)",
    "scipy (>=0.19.0)",
    "xmltodict (>=0.12.0)",
    "enum34 ; python_version < \"3\""
  ],
  "requires_python": "",
  "summary": "metrics for multiple object tracker benchmarking.",
  "version": "1.4.0",
  "releases": [],
  "developers": [
    "christoph_heindl"
  ],
  "kwds": "benchmarking trackers tracker benchmark benchmarks",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_motmetrics",
  "homepage": "https://github.com/cheind/py-motmetrics",
  "release_count": 9,
  "dependency_ids": [
    "pypi_enum34",
    "pypi_numpy",
    "pypi_pandas",
    "pypi_scipy",
    "pypi_xmltodict"
  ]
}