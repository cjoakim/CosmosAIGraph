{
  "classifiers": [
    "framework :: jupyter",
    "license :: osi approved :: bsd license",
    "programming language :: python :: 3",
    "topic :: system :: shells"
  ],
  "description": ".. image:: https://mybinder.org/badge_logo.svg\n :target: https://mybinder.org/v2/gh/takluyver/bash_kernel/master\n\n=========================\na jupyter kernel for bash\n=========================\n\ninstallation\n------------\nthis requires ipython 3.\n\n.. code:: shell\n\n    pip install bash_kernel\n    python -m bash_kernel.install\n\nto use it, run one of:\n\n.. code:: shell\n\n    jupyter notebook\n    # in the notebook interface, select bash from the 'new' menu\n    jupyter qtconsole --kernel bash\n    jupyter console --kernel bash\n\ndisplaying rich content\n-----------------------\n\nto use specialized content (images, html, etc) this file defines (in `build_cmds()`) bash functions\nthat take the contents as standard input. currently, `display` (images), `displayhtml` (html)\nand `displayjs` (javascript) are supported.\n\nexample:\n\n.. code:: shell\n\n    cat dog.png | display\n    echo \"<b>dog</b>, not a cat.\" | displayhtml\n    echo \"alert('it is known khaleesi\\!');\" | displayjs\n\nupdating rich content cells\n---------------------------\n\nif one is doing something that requires dynamic updates, one can specify a unique display_id,\nshould be a string name (downstream documentation is not clear on this), and the contents\nwill be replaced by the new value. example:\n\n.. code:: shell\n\n    display_id=\"id_${random}\"\n    ((ii=0))\n    while ((ii < 10)) ; do\n        echo \"<div>${ii}</div>\" | displayhtml $display_id\n        ((ii = ii+1))\n        sleep 1\n    done\n\nthe same works for images or even javascript content.\n\n**remember to create always a new id** (random ids works perfect) each time the cell is executed, otherwise\nit will try to display on an html element that no longer exists (they are erased each time a cell is re-run).\n\nprogrammatically generating rich content\n----------------------------------------\n\nalternatively one can simply generate the rich content to a file in /tmp (or $tmpdir)\nand then output the corresponding (to the mimetype) context prefix \"_text_saved_*\"\nconstant. so one can write programs (c++, go, rust, etc.) that generates rich content\nappropriately, when within a notebook.\n\nthe environment variable \"notebook_bash_kernel_capabilities\" will be set with a comma\nseparated list of the supported types (currently \"image,html,javascript\") that a program\ncan check for.\n\nto output to a particular \"display_id\", to allow update of content (e.g: dynamically\nupdating/generating a plot from a command line program), prefix the filename\nwith \"(<display_id>)\". e.g: a line to display the contents of /tmp/myhtml.html to\na display id \"id_12345\" would look like:\n\n    bash_kernel: saved html data to: (id_12345) /tmp/myhtml.html\n\nmore information\n----------------\n\nfor details of how this works, see the jupyter docs on `wrapper kernels\n<http://jupyter-client.readthedocs.org/en/latest/wrapperkernels.html>`_, and\npexpect's docs on the `replwrap module\n<http://pexpect.readthedocs.org/en/latest/api/replwrap.html>`_.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "bash_kernel",
  "package_url": "https://pypi.org/project/bash_kernel/",
  "project_url": "https://pypi.org/project/bash_kernel/",
  "project_urls": {
    "Source": "https://github.com/takluyver/bash_kernel"
  },
  "release_url": "https://pypi.org/project/bash_kernel/0.9.3/",
  "requires_dist": [
    "pexpect (>=4.0)",
    "ipykernel"
  ],
  "requires_python": null,
  "summary": "a bash kernel for jupyter",
  "version": "0.9.3",
  "releases": [],
  "developers": [
    "thomas@kluyver.me.uk"
  ],
  "kwds": "jupyter ipython notebook_bash_kernel_capabilities bash_kernel pip",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_bash_kernel",
  "homepage": "",
  "release_count": 15,
  "dependency_ids": [
    "pypi_ipykernel",
    "pypi_pexpect"
  ]
}