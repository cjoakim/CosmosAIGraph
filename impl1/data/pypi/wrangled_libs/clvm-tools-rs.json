{
  "classifiers": [],
  "description": "clvm_tools_rs\n=\n\ntheory of operation of the modern compiler: ./how_chialisp_is_compiled.md\n-\nthis repo can be installed via cargo\n\n    cargo install clvm_tools_rs\n\nor via pip\n\n    pip install clvm_tools_rs@git+https://github.com/chia-network/clvm_tools_rs.git@e17412032aa7d3b8b1d1f931893fb5802eee626a\n\nnote: `pip` installs a subset of the tools installed by `cargo`, including `brun`, `run`, `opc` and `opd`.\n\n\nthe most current version of the language is in the nightly branch:\n\n    [nightly](https://github.com/chia-network/clvm_tools_rs/tree/nightly)\n\nto install from a specific branch:\n\n    cargo install --no-default-features --git 'https://github.com/chia-network/clvm_tools_rs' --branch nightly\n    \nto install a git checkout into your current python environment (must be in some kind of venv or conda environment):\n\n    git clone https://github.com/chia-network/clvm_tools_rs\n    cd clvm_tools_rs\n    maturin develop\n\ninstall from pypi:\n\n    pip install -i https://pypi.chia.net/nightlies/ clvm_tools_rs\n    \nmost people still compile chialisp via python.  one way to set up compilation\nin that way is like this:\n\n    import json\n    from clvm_tools_rs import compile_clvm\n\n    def compile_module_with_symbols(include_paths,source):\n        path_obj = path(source)\n        file_path = path_obj.parent\n        file_stem = path_obj.stem\n        target_file = file_path / (file_stem + \".clvm.hex\")\n        sym_file = file_path / (file_stem + \".sym\")\n        compile_result = compile_clvm(source, str(target_file.absolute()), include_paths, true)\n        symbols = compile_result['symbols']\n        if len(symbols) != 0:\n            with open(str(sym_file.absolute()),'w') as symfile:\n                symfile.write(json.dumps(symbols))\n\nthe command line tools provided:\n\n    - run -- compiles clvm code from chialisp\n\n    most commonly, you'll compile chialisp like this:\n\n      ./target/debug/run -o -i include_dir chialisp.clsp\n    \n    'run' outputs the code resulting from compiling the program, or an error.\n    \n    - repl -- accepts chialisp forms and expressions and produces results\n              interactively.\n              \n    run like:\n    \n      ./target/debug/repl\n      \n    example session:\n    \n    >>> (defmacro assert items\n       (if (r items)\n           (list if (f items) (c assert (r items)) (q . (x)))\n         (f items)\n         )\n       )\n    (q)\n    >>> (assert 1 1 \"hello\")\n    (q . hello)\n    >>> (assert 1 0 \"bye\")\n    failed: compileerr(srcloc { file: \"*macros*\", line: 2, col: 26, until: some(until { line: 2, col: 82 }) }, \"clvm raise in (8) (())\")\n    >>> \n\n    - cldb -- stepwise run chialisp programs with program readable yaml output.\n    \n      ./target/debug/cldb '(mod (x) (x x))' '(4)'\n      ---\n      - arguments: (() (4))\n        operator: \"4\"\n        operator-location: \"*command*(1):11\"\n        result-location: \"*command*(1):11\"\n        row: \"0\"\n        value: (() 4)\n      - env: \"4\"\n        env-args: ()\n        operator: \"2\"\n        operator-location: \"*command*(1):11\"\n        result-location: \"*command*(1):13\"\n        row: \"1\"\n        value: \"4\"\n      - arguments: (4)\n        failure: clvm raise in (8 5) (() 4)\n        failure-location: \"*command*(1):11\"\n        operator: \"8\"\n        operator-location: \"*command*(1):13\"\n\n    - brun -- runs a \"binary\" program.  instead of serving as a chialisp\n      compiler, instead runs clvm programs.\n    \n    as 'brun' from the python code:\n    \n    $ ./target/debug/run '(mod (x) (defun fact (n x) (if (> 2 x) n (fact (* x n) (- x 1)))) (fact 1 x))'\n    (a (q 2 2 (c 2 (c (q . 1) (c 5 ())))) (c (q 2 (i (> (q . 2) 11) (q . 5) (q 2 2 (c 2 (c (* 11 5) (c (- 11 (q . 1)) ()))))) 1) 1))\n    $ ./target/debug/brun '(a (q 2 2 (c 2 (c (q . 1) (c 5 ())))) (c (q 2 (i (> (q . 2) 11) (q . 5) (q 2 2 (c 2 (c (* 11 5) (c (- 11 (q . 1)) ()))))) 1) 1))' '(5)'\n    120\n    \n    - opc -- crush clvm s-expression form to hex.\n    \n    as 'opc' from the python code.\n    \n    opc '(a (q 2 2 (c 2 (c (q . 1) (c 5 ())))) (c (q 2 (i (> (q . 2) 11) (q . 5) (q 2 2 (c 2 (c (* 11 5) (c (- 11 (q . 1)) ()))))) 1) 1))'\n    ff02ffff01ff02ff02ffff04ff02ffff04ffff0101ffff04ff05ff8080808080ffff04ffff01ff02ffff03ffff15ffff0102ff0b80ffff0105ffff01ff02ff02ffff04ff02ffff04ffff12ff0bff0580ffff04ffff11ff0bffff010180ff808080808080ff0180ff018080\n    \n    - opd -- disassemble hex to s-expression form.\n    \n    as 'opd' from the python code.\n    \n    opd 'ff02ffff01ff02ff02ffff04ff02ffff04ffff0101ffff04ff05ff8080808080ffff04ffff01ff02ffff03ffff15ffff0102ff0b80ffff0105ffff01ff02ff02ffff04ff02ffff04ffff12ff0bff0580ffff04ffff11ff0bffff010180ff808080808080ff0180ff018080'\n    (a (q 2 2 (c 2 (c (q . 1) (c 5 ())))) (c (q 2 (i (> (q . 2) 11) (q . 5) (q 2 2 (c 2 (c (* 11 5) (c (- 11 (q . 1)) ()))))) 1) 1))\n\nhistory\n=\n\nthis is a second-hand port of chia's [clvm tools](https://github.com/chia-network/clvm_tools/) to rust via the work of\nchiaminejp porting to typescript.  this would have been a lot harder to\nget to where it is without prior work mapping out the types of various\nsemi-dynamic things (thanks, chiaminejp).\n\nsome reasons for doing this are:\n\n - chia switched the clvm implementation to rust: [clvm_rs](https://github.com/chia-network/clvm_rs), and this code may both pick up speed and track clvm better being in the same language.\n \n - i wrote a new compiler with a simpler, less intricate structure that should be easier to improve and verify in the future in ocaml: [ochialisp](https://github.com/prozacchiwawa/ochialisp).\n\n - also it's faster even in this unoptimized form.\n\nall acceptance tests i've brought over so far work, and more are being added.\nas of now, i'm not aware of anything that shouldn't be authentic when running\nthese command line tools from clvm_tools in their equivalents in this repository\n\n - opc\n \n - opd\n \n - run\n \n - brun\n\n - repl\n \nargparse was ported to javascript and i believe i have faithfully reproduced it\nas it is used in cmds, so command line parsing should work similarly in all three\nversions.\n\nthe directory structure is expected to be:\n\n    src/classic  <-- any ported code with heritage pointing back to\n                     the original chia repo.\n                    \n    src/compiler <-- a newer compiler (ochialisp) with a simpler\n                     structure.  select new style compilation by\n                     including a `(include *standard-cl-21*)`\n                     form in your toplevel `mod` form.\n\nmac m1\n===\n\nuse ```cargo build --no-default-features``` due to differences in how mac m1 and\nother platforms handle python extensions.\n\nuse with chia-blockchain\n===\n\n    # activate your venv, then\n    $ maturin develop --release\n\n\n",
  "docs_url": null,
  "keywords": "chia,chialisp,clvm",
  "license": "apache-2.0",
  "name": "clvm-tools-rs",
  "package_url": "https://pypi.org/project/clvm-tools-rs/",
  "project_url": "https://pypi.org/project/clvm-tools-rs/",
  "project_urls": {
    "Homepage": "https://prozacchiwawa.github.io/clvm_tools_rs/",
    "Source Code": "https://github.com/Chia-Network/clvm_tools_rs"
  },
  "release_url": "https://pypi.org/project/clvm-tools-rs/0.1.40/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "tools for working with chialisp language; compiler, repl, python and wasm bindings",
  "version": "0.1.40",
  "releases": [],
  "developers": [
    "art.yerkes@gmail.com"
  ],
  "kwds": "how_chialisp_is_compiled clvm_tools clvm_tools_rs compile_clvm clvm_rs",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_clvm_tools_rs",
  "homepage": "https://prozacchiwawa.github.io/clvm_tools_rs/",
  "release_count": 37,
  "dependency_ids": []
}