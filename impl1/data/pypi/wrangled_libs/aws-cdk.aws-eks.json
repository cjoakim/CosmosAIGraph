{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon eks construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthis construct library allows you to define [amazon elastic container service for kubernetes (eks)](https://aws.amazon.com/eks/) clusters.\nin addition, the library also supports defining kubernetes resource manifests within eks clusters.\n\n## table of contents\n\n* [quick start](#quick-start)\n* [api reference](https://docs.aws.amazon.com/cdk/api/latest/docs/aws-eks-readme.html)\n* [architectural overview](#architectural-overview)\n* [provisioning clusters](#provisioning-clusters)\n\n  * [managed node groups](#managed-node-groups)\n  * [fargate profiles](#fargate-profiles)\n  * [self-managed nodes](#self-managed-nodes)\n  * [endpoint access](#endpoint-access)\n  * [alb controller](#alb-controller)\n  * [vpc support](#vpc-support)\n  * [kubectl support](#kubectl-support)\n  * [arm64 support](#arm64-support)\n  * [masters role](#masters-role)\n  * [encryption](#encryption)\n* [permissions and security](#permissions-and-security)\n* [applying kubernetes resources](#applying-kubernetes-resources)\n\n  * [kubernetes manifests](#kubernetes-manifests)\n  * [helm charts](#helm-charts)\n  * [cdk8s charts](#cdk8s-charts)\n* [patching kubernetes resources](#patching-kubernetes-resources)\n* [querying kubernetes resources](#querying-kubernetes-resources)\n* [using existing clusters](#using-existing-clusters)\n* [known issues and limitations](#known-issues-and-limitations)\n\n## quick start\n\nthis example defines an amazon eks cluster with the following configuration:\n\n* dedicated vpc with default configuration (implicitly created using [ec2.vpc](https://docs.aws.amazon.com/cdk/api/latest/docs/aws-ec2-readme.html#vpc))\n* a kubernetes pod with a container based on the [paulbouwer/hello-kubernetes](https://github.com/paulbouwer/hello-kubernetes) image.\n\n```python\n# provisiong a cluster\ncluster = eks.cluster(self, \"hello-eks\",\n    version=eks.kubernetesversion.v1_21\n)\n\n# apply a kubernetes manifest to the cluster\ncluster.add_manifest(\"mypod\", {\n    \"api_version\": \"v1\",\n    \"kind\": \"pod\",\n    \"metadata\": {\"name\": \"mypod\"},\n    \"spec\": {\n        \"containers\": [{\n            \"name\": \"hello\",\n            \"image\": \"paulbouwer/hello-kubernetes:1.5\",\n            \"ports\": [{\"container_port\": 8080}]\n        }\n        ]\n    }\n})\n```\n\nin order to interact with your cluster through `kubectl`, you can use the `aws eks update-kubeconfig` [aws cli command](https://docs.aws.amazon.com/cli/latest/reference/eks/update-kubeconfig.html)\nto configure your local kubeconfig. the eks module will define a cloudformation output in your stack which contains the command to run. for example:\n\n```plaintext\noutputs:\nclusterconfigcommand43aae40f = aws eks update-kubeconfig --name cluster-xxxxx --role-arn arn:aws:iam::112233445566:role/yyyyy\n```\n\nexecute the `aws eks update-kubeconfig ...` command in your terminal to create or update a local kubeconfig context:\n\n```console\n$ aws eks update-kubeconfig --name cluster-xxxxx --role-arn arn:aws:iam::112233445566:role/yyyyy\nadded new context arn:aws:eks:rrrrr:112233445566:cluster/cluster-xxxxx to /home/boom/.kube/config\n```\n\nand now you can simply use `kubectl`:\n\n```console\n$ kubectl get all -n kube-system\nname                           ready   status    restarts   age\npod/aws-node-fpmwv             1/1     running   0          21m\npod/aws-node-m9htf             1/1     running   0          21m\npod/coredns-5cb4fb54c7-q222j   1/1     running   0          23m\npod/coredns-5cb4fb54c7-v9nxx   1/1     running   0          23m\n...\n```\n\n## architectural overview\n\nthe following is a qualitative diagram of the various possible components involved in the cluster deployment.\n\n```text\n +-----------------------------------------------+               +-----------------+\n |                 eks cluster                   |    kubectl    |                 |\n |-----------------------------------------------|<-------------+| kubectl handler |\n |                                               |               |                 |\n |                                               |               +-----------------+\n | +--------------------+    +-----------------+ |\n | |                    |    |                 | |\n | | managed node group |    | fargate profile | |               +-----------------+\n | |                    |    |                 | |               |                 |\n | +--------------------+    +-----------------+ |               | cluster handler |\n |                                               |               |                 |\n +-----------------------------------------------+               +-----------------+\n    ^                                   ^                          +\n    |                                   |                          |\n    | connect self managed capacity     |                          | aws-sdk\n    |                                   | create/update/delete     |\n    +                                   |                          v\n +--------------------+                 +              +-------------------+\n |                    |                 --------------+| eks.amazonaws.com |\n | auto scaling group |                                +-------------------+\n |                    |\n +--------------------+\n```\n\nin a nutshell:\n\n* `eks cluster` - the cluster endpoint created by eks.\n* `managed node group` - ec2 worker nodes managed by eks.\n* `fargate profile` - fargate worker nodes managed by eks.\n* `auto scaling group` - ec2 worker nodes managed by the user.\n* `kubectlhandler` - lambda function for invoking `kubectl` commands on the cluster - created by cdk.\n* `clusterhandler` - lambda function for interacting with eks api to manage the cluster lifecycle - created by cdk.\n\na more detailed breakdown of each is provided further down this readme.\n\n## provisioning clusters\n\ncreating a new cluster is done using the `cluster` or `fargatecluster` constructs. the only required property is the kubernetes `version`.\n\n```python\neks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21\n)\n```\n\nyou can also use `fargatecluster` to provision a cluster that uses only fargate workers.\n\n```python\neks.fargatecluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21\n)\n```\n\n> **note: only 1 cluster per stack is supported.** if you have a use-case for multiple clusters per stack, or would like to understand more about this limitation, see [https://github.com/aws/aws-cdk/issues/10073](https://github.com/aws/aws-cdk/issues/10073).\n\nbelow you'll find a few important cluster configuration options. first of which is capacity.\ncapacity is the amount and the type of worker nodes that are available to the cluster for deploying resources. amazon eks offers 3 ways of configuring capacity, which you can combine as you like:\n\n### managed node groups\n\namazon eks managed node groups automate the provisioning and lifecycle management of nodes (amazon ec2 instances) for amazon eks kubernetes clusters.\nwith amazon eks managed node groups, you don\u2019t need to separately provision or register the amazon ec2 instances that provide compute capacity to run your kubernetes applications. you can create, update, or terminate nodes for your cluster with a single operation. nodes run using the latest amazon eks optimized amis in your aws account while node updates and terminations gracefully drain nodes to ensure that your applications stay available.\n\n> for more details visit [amazon eks managed node groups](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html).\n\n**managed node groups are the recommended way to allocate cluster capacity.**\n\nby default, this library will allocate a managed node group with 2 *m5.large* instances (this instance type suits most common use-cases, and is good value for money).\n\nat cluster instantiation time, you can customize the number of instances and their type:\n\n```python\neks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    default_capacity=5,\n    default_capacity_instance=ec2.instancetype.of(ec2.instanceclass.m5, ec2.instancesize.small)\n)\n```\n\nto access the node group that was created on your behalf, you can use `cluster.defaultnodegroup`.\n\nadditional customizations are available post instantiation. to apply them, set the default capacity to 0, and use the `cluster.addnodegroupcapacity` method:\n\n```python\ncluster = eks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    default_capacity=0\n)\n\ncluster.add_nodegroup_capacity(\"custom-node-group\",\n    instance_types=[ec2.instancetype(\"m5.large\")],\n    min_size=4,\n    disk_size=100,\n    ami_type=eks.nodegroupamitype.al2_x86_64_gpu\n)\n```\n\nto set node taints, you can set `taints` option.\n\n```python\n# cluster: eks.cluster\n\ncluster.add_nodegroup_capacity(\"custom-node-group\",\n    instance_types=[ec2.instancetype(\"m5.large\")],\n    taints=[eks.taintspec(\n        effect=eks.tainteffect.no_schedule,\n        key=\"foo\",\n        value=\"bar\"\n    )\n    ]\n)\n```\n\n#### spot instances support\n\nuse `capacitytype` to create managed node groups comprised of spot instances. to maximize the availability of your applications while using\nspot instances, we recommend that you configure a spot managed node group to use multiple instance types with the `instancetypes` property.\n\n> for more details visit [managed node group capacity types](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types).\n\n```python\n# cluster: eks.cluster\n\ncluster.add_nodegroup_capacity(\"extra-ng-spot\",\n    instance_types=[\n        ec2.instancetype(\"c5.large\"),\n        ec2.instancetype(\"c5a.large\"),\n        ec2.instancetype(\"c5d.large\")\n    ],\n    min_size=3,\n    capacity_type=eks.capacitytype.spot\n)\n```\n\n#### launch template support\n\nyou can specify a launch template that the node group will use. for example, this can be useful if you want to use\na custom ami or add custom user data.\n\nwhen supplying a custom user data script, it must be encoded in the mime multi-part archive format, since amazon eks merges with its own user data. visit the [launch template docs](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html#launch-template-user-data)\nfor mode details.\n\n```python\n# cluster: eks.cluster\n\n\nuser_data = \"\"\"mime-version: 1.0\ncontent-type: multipart/mixed; boundary=\"==myboundary==\"\n\n--==myboundary==\ncontent-type: text/x-shellscript; charset=\"us-ascii\"\n\n#!/bin/bash\necho \"running custom user data script\"\n\n--==myboundary==--\\\\\n\"\"\"\nlt = ec2.cfnlaunchtemplate(self, \"launchtemplate\",\n    launch_template_data=ec2.cfnlaunchtemplate.launchtemplatedataproperty(\n        instance_type=\"t3.small\",\n        user_data=fn.base64(user_data)\n    )\n)\n\ncluster.add_nodegroup_capacity(\"extra-ng\",\n    launch_template_spec=eks.launchtemplatespec(\n        id=lt.ref,\n        version=lt.attr_latest_version_number\n    )\n)\n```\n\nnote that when using a custom ami, amazon eks doesn't merge any user data. which means you do not need the multi-part encoding. and are responsible for supplying the required bootstrap commands for nodes to join the cluster.\nin the following example, `/ect/eks/bootstrap.sh` from the ami will be used to bootstrap the node.\n\n```python\n# cluster: eks.cluster\n\nuser_data = ec2.userdata.for_linux()\nuser_data.add_commands(\"set -o xtrace\", f\"/etc/eks/bootstrap.sh {cluster.clustername}\")\nlt = ec2.cfnlaunchtemplate(self, \"launchtemplate\",\n    launch_template_data=ec2.cfnlaunchtemplate.launchtemplatedataproperty(\n        image_id=\"some-ami-id\",  # custom ami\n        instance_type=\"t3.small\",\n        user_data=fn.base64(user_data.render())\n    )\n)\ncluster.add_nodegroup_capacity(\"extra-ng\",\n    launch_template_spec=eks.launchtemplatespec(\n        id=lt.ref,\n        version=lt.attr_latest_version_number\n    )\n)\n```\n\nyou may specify one `instancetype` in the launch template or multiple `instancetypes` in the node group, **but not both**.\n\n> for more details visit [launch template support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html).\n\ngraviton 2 instance types are supported including `c6g`, `m6g`, `r6g` and `t4g`.\n\n### fargate profiles\n\naws fargate is a technology that provides on-demand, right-sized compute\ncapacity for containers. with aws fargate, you no longer have to provision,\nconfigure, or scale groups of virtual machines to run containers. this removes\nthe need to choose server types, decide when to scale your node groups, or\noptimize cluster packing.\n\nyou can control which pods start on fargate and how they run with fargate\nprofiles, which are defined as part of your amazon eks cluster.\n\nsee [fargate considerations](https://docs.aws.amazon.com/eks/latest/userguide/fargate.html#fargate-considerations) in the aws eks user guide.\n\nyou can add fargate profiles to any eks cluster defined in your cdk app\nthrough the `addfargateprofile()` method. the following example adds a profile\nthat will match all pods from the \"default\" namespace:\n\n```python\n# cluster: eks.cluster\n\ncluster.add_fargate_profile(\"myprofile\",\n    selectors=[eks.selector(namespace=\"default\")]\n)\n```\n\nyou can also directly use the `fargateprofile` construct to create profiles under different scopes:\n\n```python\n# cluster: eks.cluster\n\neks.fargateprofile(self, \"myprofile\",\n    cluster=cluster,\n    selectors=[eks.selector(namespace=\"default\")]\n)\n```\n\nto create an eks cluster that **only** uses fargate capacity, you can use `fargatecluster`.\nthe following code defines an amazon eks cluster with a default fargate profile that matches all pods from the \"kube-system\" and \"default\" namespaces. it is also configured to [run coredns on fargate](https://docs.aws.amazon.com/eks/latest/userguide/fargate-getting-started.html#fargate-gs-coredns).\n\n```python\ncluster = eks.fargatecluster(self, \"mycluster\",\n    version=eks.kubernetesversion.v1_21\n)\n```\n\n`fargatecluster` will create a default `fargateprofile` which can be accessed via the cluster's `defaultprofile` property. the created profile can also be customized by passing options as with `addfargateprofile`.\n\n**note**: classic load balancers and network load balancers are not supported on\npods running on fargate. for ingress, we recommend that you use the [alb ingress\ncontroller](https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html)\non amazon eks (minimum version v1.1.4).\n\n### self-managed nodes\n\nanother way of allocating capacity to an eks cluster is by using self-managed nodes.\nec2 instances that are part of the auto-scaling group will serve as worker nodes for the cluster.\nthis type of capacity is also commonly referred to as *ec2 capacity** or *ec2 nodes*.\n\nfor a detailed overview please visit [self managed nodes](https://docs.aws.amazon.com/eks/latest/userguide/worker.html).\n\ncreating an auto-scaling group and connecting it to the cluster is done using the `cluster.addautoscalinggroupcapacity` method:\n\n```python\n# cluster: eks.cluster\n\ncluster.add_auto_scaling_group_capacity(\"frontend-nodes\",\n    instance_type=ec2.instancetype(\"t2.medium\"),\n    min_capacity=3,\n    vpc_subnets=ec2.subnetselection(subnet_type=ec2.subnettype.public)\n)\n```\n\nto connect an already initialized auto-scaling group, use the `cluster.connectautoscalinggroupcapacity()` method:\n\n```python\n# cluster: eks.cluster\n# asg: autoscaling.autoscalinggroup\n\ncluster.connect_auto_scaling_group_capacity(asg)\n```\n\nto connect a self-managed node group to an imported cluster, use the `cluster.connectautoscalinggroupcapacity()` method:\n\n```python\n# cluster: eks.cluster\n# asg: autoscaling.autoscalinggroup\n\nimported_cluster = eks.cluster.from_cluster_attributes(self, \"importedcluster\",\n    cluster_name=cluster.cluster_name,\n    cluster_security_group_id=cluster.cluster_security_group_id\n)\n\nimported_cluster.connect_auto_scaling_group_capacity(asg)\n```\n\nin both cases, the [cluster security group](https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html#cluster-sg) will be automatically attached to\nthe auto-scaling group, allowing for traffic to flow freely between managed and self-managed nodes.\n\n> **note:** the default `updatetype` for auto-scaling groups does not replace existing nodes. since security groups are determined at launch time, self-managed nodes that were provisioned with version `1.78.0` or lower, will not be updated.\n> to apply the new configuration on all your self-managed nodes, you'll need to replace the nodes using the `updatetype.replacing_update` policy for the [`updatetype`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-autoscaling.autoscalinggroup.html#updatetypespan-classapi-icon-api-icon-deprecated-titlethis-api-element-is-deprecated-its-use-is-not-recommended%ef%b8%8fspan) property.\n\nyou can customize the [/etc/eks/boostrap.sh](https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh) script, which is responsible\nfor bootstrapping the node to the eks cluster. for example, you can use `kubeletextraargs` to add custom node labels or taints.\n\n```python\n# cluster: eks.cluster\n\ncluster.add_auto_scaling_group_capacity(\"spot\",\n    instance_type=ec2.instancetype(\"t3.large\"),\n    min_capacity=2,\n    bootstrap_options=eks.bootstrapoptions(\n        kubelet_extra_args=\"--node-labels foo=bar,goo=far\",\n        aws_api_retry_attempts=5\n    )\n)\n```\n\nto disable bootstrapping altogether (i.e. to fully customize user-data), set `bootstrapenabled` to `false`.\nyou can also configure the cluster to use an auto-scaling group as the default capacity:\n\n```python\ncluster = eks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    default_capacity_type=eks.defaultcapacitytype.ec2\n)\n```\n\nthis will allocate an auto-scaling group with 2 *m5.large* instances (this instance type suits most common use-cases, and is good value for money).\nto access the `autoscalinggroup` that was created on your behalf, you can use `cluster.defaultcapacity`.\nyou can also independently create an `autoscalinggroup` and connect it to the cluster using the `cluster.connectautoscalinggroupcapacity` method:\n\n```python\n# cluster: eks.cluster\n# asg: autoscaling.autoscalinggroup\n\ncluster.connect_auto_scaling_group_capacity(asg)\n```\n\nthis will add the necessary user-data to access the apiserver and configure all connections, roles, and tags needed for the instances in the auto-scaling group to properly join the cluster.\n\n#### spot instances\n\nwhen using self-managed nodes, you can configure the capacity to use spot instances, greatly reducing capacity cost.\nto enable spot capacity, use the `spotprice` property:\n\n```python\n# cluster: eks.cluster\n\ncluster.add_auto_scaling_group_capacity(\"spot\",\n    spot_price=\"0.1094\",\n    instance_type=ec2.instancetype(\"t3.large\"),\n    max_capacity=10\n)\n```\n\n> spot instance nodes will be labeled with `lifecycle=ec2spot` and tainted with `prefernoschedule`.\n\nthe [aws node termination handler](https://github.com/aws/aws-node-termination-handler) `daemonset` will be\ninstalled from [amazon eks helm chart repository](https://github.com/aws/eks-charts/tree/master/stable/aws-node-termination-handler) on these nodes.\nthe termination handler ensures that the kubernetes control plane responds appropriately to events that\ncan cause your ec2 instance to become unavailable, such as [ec2 maintenance events](https://docs.aws.amazon.com/awsec2/latest/userguide/monitoring-instances-status-check_sched.html)\nand [ec2 spot interruptions](https://docs.aws.amazon.com/awsec2/latest/userguide/spot-interruptions.html) and helps gracefully stop all pods running on spot nodes that are about to be\nterminated.\n\n> handler version: [1.7.0](https://github.com/aws/aws-node-termination-handler/releases/tag/v1.7.0)\n>\n> chart version: [0.9.5](https://github.com/aws/eks-charts/blob/v0.0.28/stable/aws-node-termination-handler/chart.yaml)\n\nto disable the installation of the termination handler, set the `spotinterrupthandler` property to `false`. this applies both to `addautoscalinggroupcapacity` and `connectautoscalinggroupcapacity`.\n\n#### bottlerocket\n\n[bottlerocket](https://aws.amazon.com/bottlerocket/) is a linux-based open-source operating system that is purpose-built by amazon web services for running containers on virtual machines or bare metal hosts.\n\n`bottlerocket` is supported when using managed nodegroups or self-managed auto-scaling groups.\n\nto create a bottlerocket managed nodegroup:\n\n```python\n# cluster: eks.cluster\n\ncluster.add_nodegroup_capacity(\"bottlerocketng\",\n    ami_type=eks.nodegroupamitype.bottlerocket_x86_64\n)\n```\n\nthe following example will create an auto-scaling group of 2 `t3.small` linux instances running with the `bottlerocket` ami.\n\n```python\n# cluster: eks.cluster\n\ncluster.add_auto_scaling_group_capacity(\"bottlerocketnodes\",\n    instance_type=ec2.instancetype(\"t3.small\"),\n    min_capacity=2,\n    machine_image_type=eks.machineimagetype.bottlerocket\n)\n```\n\nthe specific bottlerocket ami variant will be auto selected according to the k8s version for the `x86_64` architecture.\nfor example, if the amazon eks cluster version is `1.17`, the bottlerocket ami variant will be auto selected as\n`aws-k8s-1.17` behind the scene.\n\n> see [variants](https://github.com/bottlerocket-os/bottlerocket/blob/develop/readme.md#variants) for more details.\n\nplease note bottlerocket does not allow to customize bootstrap options and `bootstrapoptions` properties is not supported when you create the `bottlerocket` capacity.\n\nfor more details about bottlerocket, see [bottlerocket faqs](https://aws.amazon.com/bottlerocket/faqs/) and [bottlerocket open source blog](https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/).\n\n### endpoint access\n\nwhen you create a new cluster, amazon eks creates an endpoint for the managed kubernetes api server that you use to communicate with your cluster (using kubernetes management tools such as `kubectl`)\n\nby default, this api server endpoint is public to the internet, and access to the api server is secured using a combination of\naws identity and access management (iam) and native kubernetes [role based access control](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) (rbac).\n\nyou can configure the [cluster endpoint access](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html) by using the `endpointaccess` property:\n\n```python\ncluster = eks.cluster(self, \"hello-eks\",\n    version=eks.kubernetesversion.v1_21,\n    endpoint_access=eks.endpointaccess.private\n)\n```\n\nthe default value is `eks.endpointaccess.public_and_private`. which means the cluster endpoint is accessible from outside of your vpc, but worker node traffic and `kubectl` commands issued by this library stay within your vpc.\n\n### alb controller\n\nsome kubernetes resources are commonly implemented on aws with the help of the [alb controller](https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.3/).\n\nfrom the docs:\n\n> aws load balancer controller is a controller to help manage elastic load balancers for a kubernetes cluster.\n>\n> * it satisfies kubernetes ingress resources by provisioning application load balancers.\n> * it satisfies kubernetes service resources by provisioning network load balancers.\n\nto deploy the controller on your eks cluster, configure the `albcontroller` property:\n\n```python\neks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    alb_controller=eks.albcontrolleroptions(\n        version=eks.albcontrollerversion.v2_4_1\n    )\n)\n```\n\nquerying the controller pods should look something like this:\n\n```console\n\u276f kubectl get pods -n kube-system\nname                                            ready   status    restarts   age\naws-load-balancer-controller-76bd6c7586-d929p   1/1     running   0          109m\naws-load-balancer-controller-76bd6c7586-fqxph   1/1     running   0          109m\n...\n...\n```\n\nevery kubernetes manifest that utilizes the alb controller is effectively dependant on the controller.\nif the controller is deleted before the manifest, it might result in dangling elb/alb resources.\ncurrently, the eks construct library does not detect such dependencies, and they should be done explicitly.\n\nfor example:\n\n```python\n# cluster: eks.cluster\n\nmanifest = cluster.add_manifest(\"manifest\", {})\nif cluster.alb_controller:\n    manifest.node.add_dependency(cluster.alb_controller)\n```\n\n### vpc support\n\nyou can specify the vpc of the cluster using the `vpc` and `vpcsubnets` properties:\n\n```python\n# vpc: ec2.vpc\n\n\neks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    vpc=vpc,\n    vpc_subnets=[ec2.subnetselection(subnet_type=ec2.subnettype.private_with_nat)]\n)\n```\n\n> note: isolated vpcs (i.e with no internet access) are not currently supported. see https://github.com/aws/aws-cdk/issues/12171\n\nif you do not specify a vpc, one will be created on your behalf, which you can then access via `cluster.vpc`. the cluster vpc will be associated to any eks managed capacity (i.e managed node groups and fargate profiles).\n\nplease note that the `vpcsubnets` property defines the subnets where eks will place the *control plane* enis. to choose\nthe subnets where eks will place the worker nodes, please refer to the **provisioning clusters** section above.\n\nif you allocate self managed capacity, you can specify which subnets should the auto-scaling group use:\n\n```python\n# vpc: ec2.vpc\n# cluster: eks.cluster\n\ncluster.add_auto_scaling_group_capacity(\"nodes\",\n    vpc_subnets=ec2.subnetselection(subnets=vpc.private_subnets),\n    instance_type=ec2.instancetype(\"t2.medium\")\n)\n```\n\nthere are two additional components you might want to provision within the vpc.\n\n#### kubectl handler\n\nthe `kubectlhandler` is a lambda function responsible to issuing `kubectl` and `helm` commands against the cluster when you add resource manifests to the cluster.\n\nthe handler association to the vpc is derived from the `endpointaccess` configuration. the rule of thumb is: *if the cluster vpc can be associated, it will be*.\n\nbreaking this down, it means that if the endpoint exposes private access (via `endpointaccess.private` or `endpointaccess.public_and_private`), and the vpc contains **private** subnets, the lambda function will be provisioned inside the vpc and use the private subnets to interact with the cluster. this is the common use-case.\n\nif the endpoint does not expose private access (via `endpointaccess.public`) **or** the vpc does not contain private subnets, the function will not be provisioned within the vpc.\n\nif your use-case requires control over the iam role that the kubectl handler assumes, a custom role can be passed through the clusterprops (as `kubectllambdarole`) of the eks cluster construct.\n\n#### cluster handler\n\nthe `clusterhandler` is a set of lambda functions (`oneventhandler`, `iscompletehandler`) responsible for interacting with the eks api in order to control the cluster lifecycle. to provision these functions inside the vpc, set the `placeclusterhandlerinvpc` property to `true`. this will place the functions inside the private subnets of the vpc based on the selection strategy specified in the [`vpcsubnets`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-eks.cluster.html#vpcsubnetsspan-classapi-icon-api-icon-experimental-titlethis-api-element-is-experimental-it-may-change-without-noticespan) property.\n\nyou can configure the environment of the cluster handler functions by specifying it at cluster instantiation. for example, this can be useful in order to configure an http proxy:\n\n```python\n# proxy_instance_security_group: ec2.securitygroup\n\ncluster = eks.cluster(self, \"hello-eks\",\n    version=eks.kubernetesversion.v1_21,\n    cluster_handler_environment={\n        \"https_proxy\": \"http://proxy.myproxy.com\"\n    },\n    #\n    # if the proxy is not open publicly, you can pass a security group to the\n    # cluster handler lambdas so that it can reach the proxy.\n    #\n    cluster_handler_security_group=proxy_instance_security_group\n)\n```\n\n### kubectl support\n\nthe resources are created in the cluster by running `kubectl apply` from a python lambda function.\n\nby default, cdk will create a new python lambda function to apply your k8s manifests. if you want to use an existing kubectl provider function, for example with tight trusted entities on your iam roles - you can import the existing provider and then use the imported provider when importing the cluster:\n\n```python\nhandler_role = iam.role.from_role_arn(self, \"handlerrole\", \"arn:aws:iam::123456789012:role/lambda-role\")\nkubectl_provider = eks.kubectlprovider.from_kubectl_provider_attributes(self, \"kubectlprovider\",\n    function_arn=\"arn:aws:lambda:us-east-2:123456789012:function:my-function:1\",\n    kubectl_role_arn=\"arn:aws:iam::123456789012:role/kubectl-role\",\n    handler_role=handler_role\n)\n\ncluster = eks.cluster.from_cluster_attributes(self, \"cluster\",\n    cluster_name=\"cluster\",\n    kubectl_provider=kubectl_provider\n)\n```\n\n#### environment\n\nyou can configure the environment of this function by specifying it at cluster instantiation. for example, this can be useful in order to configure an http proxy:\n\n```python\ncluster = eks.cluster(self, \"hello-eks\",\n    version=eks.kubernetesversion.v1_21,\n    kubectl_environment={\n        \"http_proxy\": \"http://proxy.myproxy.com\"\n    }\n)\n```\n\n#### runtime\n\nthe kubectl handler uses `kubectl`, `helm` and the `aws` cli in order to\ninteract with the cluster. these are bundled into aws lambda layers included in\nthe `@aws-cdk/lambda-layer-awscli` and `@aws-cdk/lambda-layer-kubectl` modules.\n\nyou can specify a custom `lambda.layerversion` if you wish to use a different\nversion of these tools. the handler expects the layer to include the following\nthree executables:\n\n```text\nhelm/helm\nkubectl/kubectl\nawscli/aws\n```\n\nsee more information in the\n[dockerfile](https://github.com/aws/aws-cdk/tree/master/packages/%40aws-cdk/lambda-layer-awscli/layer) for @aws-cdk/lambda-layer-awscli\nand the\n[dockerfile](https://github.com/aws/aws-cdk/tree/master/packages/%40aws-cdk/lambda-layer-kubectl/layer) for @aws-cdk/lambda-layer-kubectl.\n\n```python\nlayer = lambda_.layerversion(self, \"kubectllayer\",\n    code=lambda_.code.from_asset(\"layer.zip\")\n)\n```\n\nnow specify when the cluster is defined:\n\n```python\n# layer: lambda.layerversion\n# vpc: ec2.vpc\n\n\ncluster1 = eks.cluster(self, \"mycluster\",\n    kubectl_layer=layer,\n    vpc=vpc,\n    cluster_name=\"cluster-name\",\n    version=eks.kubernetesversion.v1_21\n)\n\n# or\ncluster2 = eks.cluster.from_cluster_attributes(self, \"mycluster\",\n    kubectl_layer=layer,\n    vpc=vpc,\n    cluster_name=\"cluster-name\"\n)\n```\n\n#### memory\n\nby default, the kubectl provider is configured with 1024mib of memory. you can use the `kubectlmemory` option to specify the memory size for the aws lambda function:\n\n```python\n# or\n# vpc: ec2.vpc\neks.cluster(self, \"mycluster\",\n    kubectl_memory=size.gibibytes(4),\n    version=eks.kubernetesversion.v1_21\n)\neks.cluster.from_cluster_attributes(self, \"mycluster\",\n    kubectl_memory=size.gibibytes(4),\n    vpc=vpc,\n    cluster_name=\"cluster-name\"\n)\n```\n\n### arm64 support\n\ninstance types with `arm64` architecture are supported in both managed nodegroup and self-managed capacity. simply specify an arm64 `instancetype` (such as `m6g.medium`), and the latest\namazon linux 2 ami for arm64 will be automatically selected.\n\n```python\n# cluster: eks.cluster\n\n# add a managed arm64 nodegroup\ncluster.add_nodegroup_capacity(\"extra-ng-arm\",\n    instance_types=[ec2.instancetype(\"m6g.medium\")],\n    min_size=2\n)\n\n# add a self-managed arm64 nodegroup\ncluster.add_auto_scaling_group_capacity(\"self-ng-arm\",\n    instance_type=ec2.instancetype(\"m6g.medium\"),\n    min_capacity=2\n)\n```\n\n### masters role\n\nwhen you create a cluster, you can specify a `mastersrole`. the `cluster` construct will associate this role with the `system:masters` [rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac/) group, giving it super-user access to the cluster.\n\n```python\n# role: iam.role\n\neks.cluster(self, \"helloeks\",\n    version=eks.kubernetesversion.v1_21,\n    masters_role=role\n)\n```\n\nif you do not specify it, a default role will be created on your behalf, that can be assumed by anyone in the account with `sts:assumerole` permissions for this role.\n\nthis is the role you see as part of the stack outputs mentioned in the [quick start](#quick-start).\n\n```console\n$ aws eks update-kubeconfig --name cluster-xxxxx --role-arn arn:aws:iam::112233445566:role/yyyyy\nadded new context arn:aws:eks:rrrrr:112233445566:cluster/cluster-xxxxx to /home/boom/.kube/config\n```\n\n### encryption\n\nwhen you create an amazon eks cluster, envelope encryption of kubernetes secrets using the aws key management service (aws kms) can be enabled.\nthe documentation on [creating a cluster](https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html)\ncan provide more details about the customer master key (cmk) that can be used for the encryption.\n\nyou can use the `secretsencryptionkey` to configure which key the cluster will use to encrypt kubernetes secrets. by default, an aws managed key will be used.\n\n> this setting can only be specified when the cluster is created and cannot be updated.\n\n```python\nsecrets_key = kms.key(self, \"secretskey\")\ncluster = eks.cluster(self, \"mycluster\",\n    secrets_encryption_key=secrets_key,\n    version=eks.kubernetesversion.v1_21\n)\n```\n\nyou can also use a similar configuration for running a cluster built using the fargatecluster construct.\n\n```python\nsecrets_key = kms.key(self, \"secretskey\")\ncluster = eks.fargatecluster(self, \"myfargatecluster\",\n    secrets_encryption_key=secrets_key,\n    version=eks.kubernetesversion.v1_21\n)\n```\n\nthe amazon resource name (arn) for that cmk can be retrieved.\n\n```python\n# cluster: eks.cluster\n\ncluster_encryption_config_key_arn = cluster.cluster_encryption_config_key_arn\n```\n\n## permissions and security\n\namazon eks provides several mechanism of securing the cluster and granting permissions to specific iam users and roles.\n\n### aws iam mapping\n\nas described in the [amazon eks user guide](https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html), you can map aws iam users and roles to [kubernetes role-based access control (rbac)](https://kubernetes.io/docs/reference/access-authn-authz/rbac).\n\nthe amazon eks construct manages the *aws-auth* `configmap` kubernetes resource on your behalf and exposes an api through the `cluster.awsauth` for mapping\nusers, roles and accounts.\n\nfurthermore, when auto-scaling group capacity is added to the cluster, the iam instance role of the auto-scaling group will be automatically mapped to rbac so nodes can connect to the cluster. no manual mapping is required.\n\nfor example, let's say you want to grant an iam user administrative privileges on your cluster:\n\n```python\n# cluster: eks.cluster\n\nadmin_user = iam.user(self, \"admin\")\ncluster.aws_auth.add_user_mapping(admin_user, groups=[\"system:masters\"])\n```\n\na convenience method for mapping a role to the `system:masters` group is also available:\n\n```python\n# cluster: eks.cluster\n# role: iam.role\n\ncluster.aws_auth.add_masters_role(role)\n```\n\n### cluster security group\n\nwhen you create an amazon eks cluster, a [cluster security group](https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html)\nis automatically created as well. this security group is designed to allow all traffic from the control plane and managed node groups to flow freely\nbetween each other.\n\nthe id for that security group can be retrieved after creating the cluster.\n\n```python\n# cluster: eks.cluster\n\ncluster_security_group_id = cluster.cluster_security_group_id\n```\n\n### node ssh access\n\nif you want to be able to ssh into your worker nodes, you must already have an ssh key in the region you're connecting to and pass it when\nyou add capacity to the cluster. you must also be able to connect to the hosts (meaning they must have a public ip and you\nshould be allowed to connect to them on port 22):\n\nsee [ssh into nodes](test/example.ssh-into-nodes.lit.ts) for a code example.\n\nif you want to ssh into nodes in a private subnet, you should set up a bastion host in a public subnet. that setup is recommended, but is\nunfortunately beyond the scope of this documentation.\n\n### service accounts\n\nwith services account you can provide kubernetes pods access to aws resources.\n\n```python\n# cluster: eks.cluster\n\n# add service account\nservice_account = cluster.add_service_account(\"myserviceaccount\")\n\nbucket = s3.bucket(self, \"bucket\")\nbucket.grant_read_write(service_account)\n\nmypod = cluster.add_manifest(\"mypod\", {\n    \"api_version\": \"v1\",\n    \"kind\": \"pod\",\n    \"metadata\": {\"name\": \"mypod\"},\n    \"spec\": {\n        \"service_account_name\": service_account.service_account_name,\n        \"containers\": [{\n            \"name\": \"hello\",\n            \"image\": \"paulbouwer/hello-kubernetes:1.5\",\n            \"ports\": [{\"container_port\": 8080}]\n        }\n        ]\n    }\n})\n\n# create the resource after the service account.\nmypod.node.add_dependency(service_account)\n\n# print the iam role arn for this service account\ncfnoutput(self, \"serviceaccountiamrole\", value=service_account.role.role_arn)\n```\n\nnote that using `serviceaccount.serviceaccountname` above **does not** translate into a resource dependency.\nthis is why an explicit dependency is needed. see [https://github.com/aws/aws-cdk/issues/9910](https://github.com/aws/aws-cdk/issues/9910) for more details.\n\nit is possible to pass annotations and labels to the service account.\n\n```python\n# cluster: eks.cluster\n\n# add service account with annotations and labels\nservice_account = cluster.add_service_account(\"myserviceaccount\",\n    annotations={\n        \"eks.amazonaws.com/sts-regional-endpoints\": \"false\"\n    },\n    labels={\n        \"some-label\": \"with-some-value\"\n    }\n)\n```\n\nyou can also add service accounts to existing clusters.\nto do so, pass the `openidconnectprovider` property when you import the cluster into the application.\n\n```python\n# or create a new one using an existing issuer url\n# issuer_url: str\n# you can import an existing provider\nprovider = eks.openidconnectprovider.from_open_id_connect_provider_arn(self, \"provider\", \"arn:aws:iam::123456:oidc-provider/oidc.eks.eu-west-1.amazonaws.com/id/ab123456abc\")\nprovider2 = eks.openidconnectprovider(self, \"provider\",\n    url=issuer_url\n)\n\ncluster = eks.cluster.from_cluster_attributes(self, \"mycluster\",\n    cluster_name=\"cluster\",\n    open_id_connect_provider=provider,\n    kubectl_role_arn=\"arn:aws:iam::123456:role/service-role/k8sservicerole\"\n)\n\nservice_account = cluster.add_service_account(\"myserviceaccount\")\n\nbucket = s3.bucket(self, \"bucket\")\nbucket.grant_read_write(service_account)\n```\n\nnote that adding service accounts requires running `kubectl` commands against the cluster.\nthis means you must also pass the `kubectlrolearn` when importing the cluster.\nsee [using existing clusters](https://github.com/aws/aws-cdk/tree/master/packages/@aws-cdk/aws-eks#using-existing-clusters).\n\n## applying kubernetes resources\n\nthe library supports several popular resource deployment mechanisms, among which are:\n\n### kubernetes manifests\n\nthe `kubernetesmanifest` construct or `cluster.addmanifest` method can be used\nto apply kubernetes resource manifests to this cluster.\n\n> when using `cluster.addmanifest`, the manifest construct is defined within the cluster's stack scope. if the manifest contains\n> attributes from a different stack which depend on the cluster stack, a circular dependency will be created and you will get a synth time error.\n> to avoid this, directly use `new kubernetesmanifest` to create the manifest in the scope of the other stack.\n\nthe following examples will deploy the [paulbouwer/hello-kubernetes](https://github.com/paulbouwer/hello-kubernetes)\nservice on the cluster:\n\n```python\n# cluster: eks.cluster\n\napp_label = {\"app\": \"hello-kubernetes\"}\n\ndeployment = {\n    \"api_version\": \"apps/v1\",\n    \"kind\": \"deployment\",\n    \"metadata\": {\"name\": \"hello-kubernetes\"},\n    \"spec\": {\n        \"replicas\": 3,\n        \"selector\": {\"match_labels\": app_label},\n        \"template\": {\n            \"metadata\": {\"labels\": app_label},\n            \"spec\": {\n                \"containers\": [{\n                    \"name\": \"hello-kubernetes\",\n                    \"image\": \"paulbouwer/hello-kubernetes:1.5\",\n                    \"ports\": [{\"container_port\": 8080}]\n                }\n                ]\n            }\n        }\n    }\n}\n\nservice = {\n    \"api_version\": \"v1\",\n    \"kind\": \"service\",\n    \"metadata\": {\"name\": \"hello-kubernetes\"},\n    \"spec\": {\n        \"type\": \"loadbalancer\",\n        \"ports\": [{\"port\": 80, \"target_port\": 8080}],\n        \"selector\": app_label\n    }\n}\n\n# option 1: use a construct\neks.kubernetesmanifest(self, \"hello-kub\",\n    cluster=cluster,\n    manifest=[deployment, service]\n)\n\n# or, option2: use `addmanifest`\ncluster.add_manifest(\"hello-kub\", service, deployment)\n```\n\n#### alb controller integration\n\nthe `kubernetesmanifest` construct can detect ingress resources inside your manifest and automatically add the necessary annotations\nso they are picked up by the alb controller.\n\n> see [alb controller](#alb-controller)\n\nto that end, it offers the following properties:\n\n* `ingressalb` - signal that the ingress detection should be done.\n* `ingressalbscheme` - which alb scheme should be applied. defaults to `internal`.\n\n#### adding resources from a url\n\nthe following example will deploy the resource manifest hosting on remote server:\n\n```text\n// this example is only available in typescript\n\nimport * as yaml from 'js-yaml';\nimport * as request from 'sync-request';\n\ndeclare const cluster: eks.cluster;\nconst manifesturl = 'https://url/of/manifest.yaml';\nconst manifest = yaml.safeloadall(request('get', manifesturl).getbody());\ncluster.addmanifest('my-resource', manifest);\n```\n\n#### dependencies\n\nthere are cases where kubernetes resources must be deployed in a specific order.\nfor example, you cannot define a resource in a kubernetes namespace before the\nnamespace was created.\n\nyou can represent dependencies between `kubernetesmanifest`s using\n`resource.node.adddependency()`:\n\n```python\n# cluster: eks.cluster\n\nnamespace = cluster.add_manifest(\"my-namespace\", {\n    \"api_version\": \"v1\",\n    \"kind\": \"namespace\",\n    \"metadata\": {\"name\": \"my-app\"}\n})\n\nservice = cluster.add_manifest(\"my-service\", {\n    \"metadata\": {\n        \"name\": \"myservice\",\n        \"namespace\": \"my-app\"\n    },\n    \"spec\": {}\n})\n\nservice.node.add_dependency(namespace)\n```\n\n**note:** when a `kubernetesmanifest` includes multiple resources (either directly\nor through `cluster.addmanifest()`) (e.g. `cluster.addmanifest('foo', r1, r2, r3,...)`), these resources will be applied as a single manifest via `kubectl`\nand will be applied sequentially (the standard behavior in `kubectl`).\n\n---\n\n\nsince kubernetes manifests are implemented as cloudformation resources in the\ncdk. this means that if the manifest is deleted from your code (or the stack is\ndeleted), the next `cdk deploy` will issue a `kubectl delete` command and the\nkubernetes resources in that manifest will be deleted.\n\n#### resource pruning\n\nwhen a resource is deleted from a kubernetes manifest, the eks module will\nautomatically delete these resources by injecting a *prune label* to all\nmanifest resources. this label is then passed to [`kubectl apply --prune`](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/#alternative-kubectl-apply-f-directory-prune-l-your-label).\n\npruning is enabled by default but can be disabled through the `prune` option\nwhen a cluster is defined:\n\n```python\neks.cluster(self, \"mycluster\",\n    version=eks.kubernetesversion.v1_21,\n    prune=false\n)\n```\n\n#### manifests validation\n\nthe `kubectl` cli supports applying a manifest by skipping the validation.\nthis can be accomplished by setting the `skipvalidation` flag to `true` in the `kubernetesmanifest` props.\n\n```python\n# cluster: eks.cluster\n\neks.kubernetesmanifest(self, \"helloappwithoutvalidation\",\n    cluster=cluster,\n    manifest=[{\"foo\": \"bar\"}],\n    skip_validation=true\n)\n```\n\n### helm charts\n\nthe `helmchart` construct or `cluster.addhelmchart` method can be used\nto add kubernetes resources to this cluster using helm.\n\n> when using `cluster.addhelmchart`, the manifest construct is defined within the cluster's stack scope. if the manifest contains\n> attributes from a different stack which depend on the cluster stack, a circular dependency will be created and you will get a synth time error.\n> to avoid this, directly use `new helmchart` to create the chart in the scope of the other stack.\n\nthe following example will install the [nginx ingress controller](https://kubernetes.github.io/ingress-nginx/) to your cluster using helm.\n\n```python\n# cluster: eks.cluster\n\n# option 1: use a construct\neks.helmchart(self, \"nginxingress\",\n    cluster=cluster,\n    chart=\"nginx-ingress\",\n    repository=\"https://helm.nginx.com/stable\",\n    namespace=\"kube-system\"\n)\n\n# or, option2: use `addhelmchart`\ncluster.add_helm_chart(\"nginxingress\",\n    chart=\"nginx-ingress\",\n    repository=\"https://helm.nginx.com/stable\",\n    namespace=\"kube-system\"\n)\n```\n\nhelm charts will be installed and updated using `helm upgrade --install`, where a few parameters\nare being passed down (such as `repo`, `values`, `version`, `namespace`, `wait`, `timeout`, etc).\nthis means that if the chart is added to cdk with the same release name, it will try to update\nthe chart in the cluster.\n\nadditionally, the `chartasset` property can be an `aws-s3-assets.asset`. this allows the use of local, private helm charts.\n\n```python\nimport aws_cdk.aws_s3_assets as s3_assets\n\n# cluster: eks.cluster\n\nchart_asset = s3_assets.asset(self, \"chartasset\",\n    path=\"/path/to/asset\"\n)\n\ncluster.add_helm_chart(\"test-chart\",\n    chart_asset=chart_asset\n)\n```\n\n### oci charts\n\noci charts are also supported.\nalso replace the `${vars}` with appropriate values.\n\n```python\n# cluster: eks.cluster\n\n# option 1: use a construct\neks.helmchart(self, \"myocichart\",\n    cluster=cluster,\n    chart=\"some-chart\",\n    repository=\"oci://${account_id}.dkr.ecr.${account_region}.amazonaws.com/${repo_name}\",\n    namespace=\"oci\",\n    version=\"0.0.1\"\n)\n```\n\nhelm charts are implemented as cloudformation resources in cdk.\nthis means that if the chart is deleted from your code (or the stack is\ndeleted), the next `cdk deploy` will issue a `helm uninstall` command and the\nhelm chart will be deleted.\n\nwhen there is no `release` defined, a unique id will be allocated for the release based\non the construct path.\n\nby default, all helm charts will be installed concurrently. in some cases, this\ncould cause race conditions where two helm charts attempt to deploy the same\nresource or if helm charts depend on each other. you can use\n`chart.node.adddependency()` in order to declare a dependency order between\ncharts:\n\n```python\n# cluster: eks.cluster\n\nchart1 = cluster.add_helm_chart(\"mychart\",\n    chart=\"foo\"\n)\nchart2 = cluster.add_helm_chart(\"mychart\",\n    chart=\"bar\"\n)\n\nchart2.node.add_dependency(chart1)\n```\n\n#### cdk8s charts\n\n[cdk8s](https://cdk8s.io/) is an open-source library that enables kubernetes manifest authoring using familiar programming languages. it is founded on the same technologies as the aws cdk, such as [`constructs`](https://github.com/aws/constructs) and [`jsii`](https://github.com/aws/jsii).\n\n> to learn more about cdk8s, visit the [getting started](https://cdk8s.io/docs/latest/getting-started/) tutorials.\n\nthe eks module natively integrates with cdk8s and allows you to apply cdk8s charts on aws eks clusters via the `cluster.addcdk8schart` method.\n\nin addition to `cdk8s`, you can also use [`cdk8s+`](https://cdk8s.io/docs/latest/plus/), which provides higher level abstraction for the core kubernetes api objects.\nyou can think of it like the `l2` constructs for kubernetes. any other `cdk8s` based libraries are also supported, for example [`cdk8s-debore`](https://github.com/toricls/cdk8s-debore).\n\nto get started, add the following dependencies to your `package.json` file:\n\n```json\n\"dependencies\": {\n  \"cdk8s\": \"^1.0.0\",\n  \"cdk8s-plus-21\": \"^1.0.0-beta.38\",\n  \"constructs\": \"^3.3.69\"\n}\n```\n\nnote that here we are using `cdk8s-plus-21` as we are targeting kubernetes version 1.21.0. if you operate a different kubernetes version, you should\nuse the corresponding `cdk8s-plus-xx` library.\nsee [select the appropriate cdk8s+ library](https://cdk8s.io/docs/latest/plus/#i-operate-kubernetes-version-1xx-which-cdk8s-library-should-i-be-using)\nfor more details.\n\nsimilarly to how you would create a stack by extending `@aws-cdk/core.stack`, we recommend you create a chart of your own that extends `cdk8s.chart`,\nand add your kubernetes resources to it. you can use `aws-cdk` construct attributes and properties inside your `cdk8s` construct freely.\n\nin this example we create a chart that accepts an `s3.bucket` and passes its name to a kubernetes pod as an environment variable.\n\nnotice that the chart must accept a `constructs.construct` type as its scope, not an `@aws-cdk/core.construct` as you would normally use.\nfor this reason, to avoid possible confusion, we will create the chart in a separate file:\n\n`+ my-chart.ts`\n\n```python\nimport aws_cdk.aws_s3 as s3\nimport constructs as constructs\nimport cdk8s as cdk8s\nimport cdk8s_plus_21 as kplus\n\nclass mychart(cdk8s.chart):\n    def __init__(self, scope, id, *, bucket):\n        super().__init__(scope, id)\n\n        kplus.pod(self, \"pod\",\n            containers=[\n                kplus.container(\n                    image=\"my-image\",\n                    env_variables={\n                        \"bucket_name\": kplus.envvalue.from_value(bucket.bucket_name)\n                    }\n                )\n            ]\n        )\n```\n\nthen, in your aws cdk app:\n\n```python\n# cluster: eks.cluster\n\n\n# some bucket..\nbucket = s3.bucket(self, \"bucket\")\n\n# create a cdk8s chart and use `cdk8s.app` as the scope.\nmy_chart = mychart(cdk8s.app(), \"mychart\", bucket=bucket)\n\n# add the cdk8s chart to the cluster\ncluster.add_cdk8s_chart(\"my-chart\", my_chart)\n```\n\n##### custom cdk8s constructs\n\nyou can also compose a few stock `cdk8s+` constructs into your own custom construct. however, since mixing scopes between `aws-cdk` and `cdk8s` is currently not supported, the `construct` class\nyou'll need to use is the one from the [`constructs`](https://github.com/aws/constructs) module, and not from `@aws-cdk/core` like you normally would.\nthis is why we used `new cdk8s.app()` as the scope of the chart above.\n\n```python\nimport constructs as constructs\nimport cdk8s as cdk8s\nimport cdk8s_plus_21 as kplus\n\napp = cdk8s.app()\nchart = cdk8s.chart(app, \"my-chart\")\n\nclass loadbalancedwebservice(constructs.construct):\n    def __init__(self, scope, id, props):\n        super().__init__(scope, id)\n\n        deployment = kplus.deployment(chart, \"deployment\",\n            replicas=props.replicas,\n            containers=[kplus.container(image=props.image)]\n        )\n\n        deployment.expose_via_service(\n            port=props.port,\n            service_type=kplus.servicetype.load_balancer\n        )\n```\n\n##### manually importing k8s specs and crd's\n\nif you find yourself unable to use `cdk8s+`, or just like to directly use the `k8s` native objects or crd's, you can do so by manually importing them using the `cdk8s-cli`.\n\nsee [importing kubernetes objects](https://cdk8s.io/docs/latest/cli/import/) for detailed instructions.\n\n## patching kubernetes resources\n\nthe `kubernetespatch` construct can be used to update existing kubernetes\nresources. the following example can be used to patch the `hello-kubernetes`\ndeployment from the example above with 5 replicas.\n\n```python\n# cluster: eks.cluster\n\neks.kubernetespatch(self, \"hello-kub-deployment-label\",\n    cluster=cluster,\n    resource_name=\"deployment/hello-kubernetes\",\n    apply_patch={\"spec\": {\"replicas\": 5}},\n    restore_patch={\"spec\": {\"replicas\": 3}}\n)\n```\n\n## querying kubernetes resources\n\nthe `kubernetesobjectvalue` construct can be used to query for information about kubernetes objects,\nand use that as part of your cdk application.\n\nfor example, you can fetch the address of a [`loadbalancer`](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer) type service:\n\n```python\n# cluster: eks.cluster\n\n# query the load balancer address\nmy_service_address = eks.kubernetesobjectvalue(self, \"loadbalancerattribute\",\n    cluster=cluster,\n    object_type=\"service\",\n    object_name=\"my-service\",\n    json_path=\".status.loadbalancer.ingress[0].hostname\"\n)\n\n# pass the address to a lambda function\nproxy_function = lambda_.function(self, \"proxyfunction\",\n    handler=\"index.handler\",\n    code=lambda_.code.from_inline(\"my-code\"),\n    runtime=lambda_.runtime.nodejs_14_x,\n    environment={\n        \"my_service_address\": my_service_address.value\n    }\n)\n```\n\nspecifically, since the above use-case is quite common, there is an easier way to access that information:\n\n```python\n# cluster: eks.cluster\n\nload_balancer_address = cluster.get_service_load_balancer_address(\"my-service\")\n```\n\n## using existing clusters\n\nthe amazon eks library allows defining kubernetes resources such as [kubernetes\nmanifests](#kubernetes-resources) and [helm charts](#helm-charts) on clusters\nthat are not defined as part of your cdk app.\n\nfirst, you'll need to \"import\" a cluster to your cdk app. to do that, use the\n`eks.cluster.fromclusterattributes()` static method:\n\n```python\ncluster = eks.cluster.from_cluster_attributes(self, \"mycluster\",\n    cluster_name=\"my-cluster-name\",\n    kubectl_role_arn=\"arn:aws:iam::1111111:role/iam-role-that-has-masters-access\"\n)\n```\n\nthen, you can use `addmanifest` or `addhelmchart` to define resources inside\nyour kubernetes cluster. for example:\n\n```python\n# cluster: eks.cluster\n\ncluster.add_manifest(\"test\", {\n    \"api_version\": \"v1\",\n    \"kind\": \"configmap\",\n    \"metadata\": {\n        \"name\": \"myconfigmap\"\n    },\n    \"data\": {\n        \"key\": \"value\",\n        \"another\": \"123454\"\n    }\n})\n```\n\nat the minimum, when importing clusters for `kubectl` management, you will need\nto specify:\n\n* `clustername` - the name of the cluster.\n* `kubectlrolearn` - the arn of an iam role mapped to the `system:masters` rbac\n  role. if the cluster you are importing was created using the aws cdk, the\n  cloudformation stack has an output that includes an iam role that can be used.\n  otherwise, you can create an iam role and map it to `system:masters` manually.\n  the trust policy of this role should include the the\n  `arn:aws::iam::${accountid}:root` principal in order to allow the execution\n  role of the kubectl resource to assume it.\n\nif the cluster is configured with private-only or private and restricted public\nkubernetes [endpoint access](#endpoint-access), you must also specify:\n\n* `kubectlsecuritygroupid` - the id of an ec2 security group that is allowed\n  connections to the cluster's control security group. for example, the eks managed [cluster security group](#cluster-security-group).\n* `kubectlprivatesubnetids` - a list of private vpc subnets ids that will be used\n  to access the kubernetes endpoint.\n\n## logging\n\neks supports cluster logging for 5 different types of events:\n\n* api requests to the cluster.\n* cluster access via the kubernetes api.\n* authentication requests into the cluster.\n* state of cluster controllers.\n* scheduling decisions.\n\nyou can enable logging for each one separately using the `clusterlogging`\nproperty. for example:\n\n```python\ncluster = eks.cluster(self, \"cluster\",\n    # ...\n    version=eks.kubernetesversion.v1_21,\n    cluster_logging=[eks.clusterloggingtypes.api, eks.clusterloggingtypes.authenticator, eks.clusterloggingtypes.scheduler\n    ]\n)\n```\n\n## known issues and limitations\n\n* [one cluster per stack](https://github.com/aws/aws-cdk/issues/10073)\n* [service account dependencies](https://github.com/aws/aws-cdk/issues/9910)\n* [support isolated vpcs](https://github.com/aws/aws-cdk/issues/12171)\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-eks",
  "package_url": "https://pypi.org/project/aws-cdk.aws-eks/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-eks/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-eks/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-autoscaling (==1.204.0)",
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-kms (==1.204.0)",
    "aws-cdk.aws-lambda (==1.204.0)",
    "aws-cdk.aws-s3-assets (==1.204.0)",
    "aws-cdk.aws-ssm (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.custom-resources (==1.204.0)",
    "aws-cdk.lambda-layer-awscli (==1.204.0)",
    "aws-cdk.lambda-layer-kubectl (==1.204.0)",
    "aws-cdk.lambda-layer-node-proxy-agent (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::eks",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "kubernetesversion kubernetes aws_cdk kubernetesmanifest kubernetespatch",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_eks",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_autoscaling",
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_kms",
    "pypi_aws_cdk.aws_lambda",
    "pypi_aws_cdk.aws_s3_assets",
    "pypi_aws_cdk.aws_ssm",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.custom_resources",
    "pypi_aws_cdk.lambda_layer_awscli",
    "pypi_aws_cdk.lambda_layer_kubectl",
    "pypi_aws_cdk.lambda_layer_node_proxy_agent",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}