{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "operating system :: android",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: bsd :: freebsd",
    "operating system :: posix :: bsd :: netbsd",
    "operating system :: posix :: bsd :: openbsd",
    "operating system :: posix :: linux",
    "programming language :: c",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: software development :: build tools",
    "topic :: software development :: compilers",
    "topic :: software development :: quality assurance",
    "topic :: system :: software distribution"
  ],
  "description": "####################\n nuitka user manual\n####################\n\n**********\n overview\n**********\n\nthis document is the recommended first read if you are interested in\nusing nuitka, understand its use cases, check what you can expect,\nlicense, requirements, credits, etc.\n\nnuitka is **the** python compiler. it is written in python. it is a\nseamless replacement or extension to the python interpreter and compiles\n**every** construct that cpython 2.6, 2.7, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9,\n3.10, 3.11 have, when itself run with that python version.\n\nit then executes uncompiled code and compiled code together in an\nextremely compatible manner.\n\nyou can use all python library modules and all extension modules freely.\n\nnuitka translates the python modules into a c level program that then\nuses ``libpython`` and static c files of its own to execute in the same\nway as cpython does.\n\nall optimization is aimed at avoiding overhead, where it's unnecessary.\nnone is aimed at removing compatibility, although slight improvements\nwill occasionally be done, where not every bug of standard python is\nemulated, e.g. more complete error messages are given, but there is a\nfull compatibility mode to disable even that.\n\n**************\n requirements\n**************\n\nc compiler\n==========\n\nyou need a c compiler with support for c11 or alternatively a c++\ncompiler for c++03 [#]_.\n\ncurrently this means, you need to use one of these compilers:\n\n-  the mingw64 c11 compiler on windows, must be based on gcc 11.2 or\n   higher. it will be *automatically* downloaded if no usable c compiler\n   is found, which is the recommended way of installing it, as nuitka\n   will also upgrade it for you.\n\n-  visual studio 2022 or higher on windows [#]_, older versions will\n   work but only supported for commercial users. configure to use the\n   english language pack for best results (nuitka filters away garbage\n   outputs, but only for english language). it will be used by default\n   if installed.\n\n-  on all other platforms, the ``gcc`` compiler of at least version 5.1,\n   and below that the ``g++`` compiler of at least version 4.4 as an\n   alternative.\n\n-  the ``clang`` compiler on macos x and most freebsd architectures.\n\n-  on windows the ``clang-cl`` compiler on windows can be used if\n   provided by the visual studio installer.\n\n.. [#]\n\n   support for this c11 is given with gcc 5.x or higher or any clang\n   version.\n\n   the msvc compiler doesn't do it yet. but as a workaround, as the c++03\n   language standard is very overlapping with c11, it is then used instead\n   where the c compiler is too old. nuitka used to require a c++ compiler\n   in the past, but it changed.\n\n.. [#]\n\n   download for free from\n   https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx\n   (the community editions work just fine).\n\n   the latest version is recommended but not required. on the other hand,\n   there is no need to except to support pre-windows 10 versions, and they\n   might work for you, but support of these configurations is only\n   available to commercial users.\n\npython\n======\n\npython version 2.6, 2.7 or 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11 are\nsupported. if at any moment, there is a stable python release that is\nnot in this list, rest assured it is being worked on and will be added.\n\n.. important::\n\n   for python 3.4 and *only* that version, we need other python version\n   as a *compile time* dependency.\n\n   nuitka itself is fully compatible with all listed versions, but scons\n   as an internally used tool is not.\n\n   for these versions, you *need* a python2 or python 3.5 or higher\n   installed as well, but only during the compile time only. that is for\n   use with scons (which orchestrates the c compilation), which does not\n   support the same python versions as nuitka.\n\n   in addition, on windows, python2 cannot be used because ``clcache``\n   does not work with it, there a python 3.5 or higher needs to be\n   installed.\n\n   nuitka finds these needed python versions (e.g. on windows via\n   registry) and you shouldn't notice it as long as they are installed.\n\n   increasingly, other functionality is available when another python\n   has a certain package installed. for example, onefile compression\n   will work for a python 2.x when another python is found that has the\n   ``zstandard`` package installed.\n\n.. admonition:: moving binaries to other machines\n\n   the created binaries can be made executable independent of the python\n   installation, with ``--standalone`` and ``--onefile`` options.\n\n.. admonition:: binary filename suffix\n\n   the created binaries have an ``.exe`` suffix on windows. on other\n   platforms they have no suffix for standalone mode, or ``.bin``\n   suffix, that you are free to remove or change, or specify with the\n   ``-o`` option.\n\n   the suffix for acceleration mode is added just to be sure that the\n   original script name and the binary name do not ever collide, so we\n   can safely do an overwrite without destroying the original source\n   file.\n\n.. admonition:: it **has to** be cpython, anaconda python, or homebrew\n\n   you need the standard python implementation, called \"cpython\", to\n   execute nuitka, because it is closely tied to implementation details\n   of it.\n\n.. admonition:: it **cannot be** from windows app store\n\n   it is known that windows app store python definitely does not work,\n   it's checked against.\n\n.. admonition:: it **cannot be** pyenv on macos\n\n   it is known that macos \"pyenv\" does **not** work. use homebrew\n   instead for self compiled python installations. but note that\n   standalone mode will be worse on these platforms and not be as\n   backward compatible with older macos versions.\n\noperating system\n================\n\nsupported operating systems: linux, freebsd, netbsd, macos x, and\nwindows (32bits/64 bits/arm).\n\nothers will work as well. the portability is expected to be generally\ngood, but the e.g. nuitka's internal scons usage may have to be adapted\nor need flags passed. make sure to match python and c compiler\narchitecture, or else you will get cryptic error messages.\n\narchitecture\n============\n\nsupported architectures are x86, x86_64 (amd64), and arm, likely many,\nmany more.\n\nother architectures are expected to also work, out of the box, as nuitka\nis generally not using any hardware specifics. these are just the ones\ntested and known to be good. feedback is welcome. generally, the\narchitectures that debian supports can be considered good and tested\ntoo.\n\n*******\n usage\n*******\n\ncommand line\n============\n\nthe recommended way of executing nuitka is ``<the_right_python> -m\nnuitka`` to be absolutely certain which python interpreter you are\nusing, so it is easier to match with what nuitka has.\n\nthe next best way of executing nuitka bare that is from a source\ncheckout or archive, with no environment variable changes, most\nnoteworthy, you do not have to mess with ``pythonpath`` at all for\nnuitka. you just execute the ``nuitka`` and ``nuitka-run`` scripts\ndirectly without any changes to the environment. you may want to add the\n``bin`` directory to your ``path`` for your convenience, but that step\nis optional.\n\nmoreover, if you want to execute with the right interpreter, in that\ncase, be sure to execute ``<the_right_python> bin/nuitka`` and be good.\n\n.. admonition:: pick the right interpreter\n\n   if you encounter a ``syntaxerror`` you absolutely most certainly have\n   picked the wrong interpreter for the program you are compiling.\n\nnuitka has a ``--help`` option to output what it can do:\n\n.. code:: bash\n\n   nuitka --help\n\nthe ``nuitka-run`` command is the same as ``nuitka``, but with a\ndifferent default. it tries to compile *and* directly execute a python\nscript:\n\n.. code:: bash\n\n   nuitka-run --help\n\nthis option that is different is ``--run``, and passing on arguments\nafter the first non-option to the created binary, so it is somewhat more\nsimilar to what plain ``python`` will do.\n\ninstallation\n============\n\nfor most systems, there will be packages on the `download page\n<https://nuitka.net/doc/download.html>`__ of nuitka. but you can also\ninstall it from source code as described above, but also like any other\npython program it can be installed via the normal ``python setup.py\ninstall`` routine.\n\nlicense\n=======\n\nnuitka is licensed under the apache license, version 2.0; you may not\nuse it except in compliance with the license.\n\nyou may obtain a copy of the license at\nhttp://www.apache.org/licenses/license-2.0\n\nunless required by applicable law or agreed to in writing, software\ndistributed under the license is distributed on an \"as is\" basis,\nwithout warranties or conditions of any kind, either express or implied.\nsee the license for the specific language governing permissions and\nlimitations under the license.\n\n*************************************\n tutorial setup and build on windows\n*************************************\n\nthis is basic steps if you have nothing installed, of course if you have\nany of the parts, just skip it.\n\nsetup\n=====\n\ninstall python\n--------------\n\n-  download and install python from\n   https://www.python.org/downloads/windows\n\n-  select one of ``windows x86-64 web-based installer`` (64 bits python,\n   recommended) or ``x86 executable`` (32 bits python) installer.\n\n-  verify it's working using command ``python --version``.\n\ninstall nuitka\n--------------\n\n-  ``python -m pip install nuitka``\n\n-  verify using command ``python -m nuitka --version``\n\nwrite some code and test\n========================\n\ncreate a folder for the python code\n-----------------------------------\n\n-  ``mkdir`` helloworld\n\n-  make a python file named **hello.py**\n\n.. code:: python\n\n   def talk(message):\n       return \"talk \" + message\n\n\n   def main():\n       print(talk(\"hello world\"))\n\n\n   if __name__ == \"__main__\":\n       main()\n\ntest your program\n-----------------\n\ndo as you normally would. running nuitka on code that works incorrectly\nis not easier to debug.\n\n.. code:: bash\n\n   python hello.py\n\n----\n\nbuild it using\n--------------\n\n.. code:: bash\n\n   python -m nuitka hello.py\n\n.. note::\n\n   this will prompt you to download a c caching tool (to speed up\n   repeated compilation of generated c code) and a mingw64 based c\n   compiler unless you have a suitable msvc installed. say ``yes`` to\n   both those questions.\n\nrun it\n------\n\nexecute the ``hello.exe`` created near ``hello.py``.\n\ndistribute\n----------\n\nto distribute, build with ``--standalone`` option, which will not output\na single executable, but a whole folder. copy the resulting\n``hello.dist`` folder to the other machine and run it.\n\nyou may also try ``--onefile`` which does create a single file, but make\nsure that the mere standalone is working, before turning to it, as it\nwill make the debugging only harder, e.g. in case of missing data files.\n\n***********\n use cases\n***********\n\nuse case 1 - program compilation with all modules embedded\n==========================================================\n\nif you want to compile a whole program recursively, and not only the\nsingle file that is the main program, do it like this:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports program.py\n\n.. note::\n\n   there are more fine grained controls than ``--follow-imports``\n   available. consider the output of ``nuitka --help``. including less\n   modules into the compilation, but instead using normal python for it\n   will make it faster to compile.\n\nin case you have a source directory with dynamically loaded files, i.e.\none which cannot be found by recursing after normal import statements\nvia the ``pythonpath`` (which would be the recommended way), you can\nalways require that a given directory shall also be included in the\nexecutable:\n\n.. code:: bash\n\n   python -m nuitka --follow-imports --include-plugin-directory=plugin_dir program.py\n\n.. note::\n\n   if you don't do any dynamic imports, simply setting your\n   ``pythonpath`` at compilation time is what you should do.\n\n   use ``--include-plugin-directory`` only if you make ``__import__()``\n   calls that nuitka cannot predict, and that come from a directory, for\n   everything from your python installation, use ``--include-module`` or\n   ``--include-package``.\n\n.. note::\n\n   the resulting filename will be ``program.exe`` on windows,\n   ``program.bin`` on other platforms, but ``--output-filename`` allows\n   changing that.\n\n.. note::\n\n   the resulting binary still depends on cpython and used c extension\n   modules being installed.\n\n   if you want to be able to copy it to another machine, use\n   ``--standalone`` and copy the created ``program.dist`` directory and\n   execute the ``program.exe`` (windows) or ``program`` (other\n   platforms) put inside.\n\nuse case 2 - extension module compilation\n=========================================\n\nif you want to compile a single extension module, all you have to do is\nthis:\n\n.. code:: bash\n\n   python -m nuitka --module some_module.py\n\nthe resulting file ``some_module.so`` can then be used instead of\n``some_module.py``.\n\n.. important::\n\n   the filename of the produced extension module must not be changed as\n   python insists on a module name derived function as an entry point,\n   in this case ``pyinit_some_module`` and renaming the file will not\n   change that. match the filename of the source code to what the binary\n   name should be.\n\n.. note::\n\n   if both the extension module and the source code of it are in the\n   same directory, the extension module is loaded. changes to the source\n   code only have effect once you recompile.\n\n.. note::\n\n   the option ``--follow-import-to`` and work as well, but the included\n   modules will only become importable *after* you imported the\n   ``some_module`` name. if these kinds of imports are invisible to\n   nuitka, e.g. dynamically created, you can use ``--include-module`` or\n   ``--include-package`` in that case, but for static imports it should\n   not be needed.\n\n.. note::\n\n   an extension module can never include other extension modules. you\n   will have to create a wheel for this to be doable.\n\n.. note::\n\n   the resulting extension module can only be loaded into a cpython of\n   the same version and doesn't include other extension modules.\n\nuse case 3 - package compilation\n================================\n\nif you need to compile a whole package and embed all modules, that is\nalso feasible, use nuitka like this:\n\n.. code:: bash\n\n   python -m nuitka --module some_package --include-package=some_package\n\n.. note::\n\n   the inclusion of the package contents needs to be provided manually,\n   otherwise, the package is mostly empty. you can be more specific if\n   you want, and only include part of it, or exclude part of it, e.g.\n   with ``--nofollow-import-to='*.tests'`` you would not include the\n   unused test part of your code.\n\n.. note::\n\n   data files located inside the package will not be embedded by this\n   process, you need to copy them yourself with this approach.\n   alternatively you can use the `file embedding of nuitka commercial\n   <https://nuitka.net/doc/commercial/protect-data-files.html>`__.\n\nuse case 4 - program distribution\n=================================\n\nfor distribution to other systems, there is the standalone mode which\nproduces a folder for which you can specify ``--standalone``.\n\n.. code:: bash\n\n   python -m nuitka --standalone program.py\n\nfollowing all imports is default in this mode. you can selectively\nexclude modules by specifically saying ``--nofollow-import-to``, but\nthen an ``importerror`` will be raised when import of it is attempted at\nprogram run time. this may cause different behavior, but it may also\nimprove your compile time if done wisely.\n\nfor data files to be included, use the option\n``--include-data-files=<source>=<target>`` where the source is a file\nsystem path, but target has to be specified relative. for standalone you\ncan also copy them manually, but this can do extra checks, and for\nonefile mode, there is no manual copying possible.\n\nto copy some or all file in a directory, use the option\n``--include-data-files=/etc/*.txt=etc/`` where you get to specify shell\npatterns for the files, and a subdirectory where to put them, indicated\nby the trailing slash.\n\nto copy a whole folder with all files, you can use\n``--include-data-dir=/path/to/images=images`` which will copy all files\nincluding a potential subdirectory structure. you cannot filter here,\ni.e. if you want only a partial copy, remove the files beforehand.\n\nfor package data, there is a better way, using\n``--include-package-data`` which detects data files of packages\nautomatically and copies them over. it even accepts patterns in shell\nstyle. it spares you the need to find the package directory yourself and\nshould be preferred whenever available.\n\nwith data files, you are largely on your own. nuitka keeps track of ones\nthat are needed by popular packages, but it might be incomplete. raise\nissues if you encounter something in these.\n\nwhen that is working, you can use the onefile mode if you so desire.\n\n.. code:: bash\n\n   python -m nuitka --onefile program.py\n\nthis will create a single binary, that extracts itself on the target,\nbefore running the program. but notice, that accessing files relative to\nyour program is impacted, make sure to read the section `onefile:\nfinding files`_ as well.\n\n.. code:: bash\n\n   # create a binary that unpacks into a temporary folder\n   python -m nuitka --onefile program.py\n\n.. note::\n\n   there are more platform specific options, e.g. related to icons,\n   splash screen, and version information, consider the ``--help``\n   output for the details of these and check the section `tweaks_`.\n\nfor the unpacking, by default a unique user temporary path one is used,\nand then deleted, however this default\n``--onefile-tempdir-spec=\"%temp%/onefile_%pid%_%time%\"`` can be\noverridden with a path specification that is using then using a cached\npath, avoiding repeated unpacking, e.g. with\n``--onefile-tempdir-spec=\"%cache_dir%/%company%/%product%/%version%\"``\nwhich uses version information, and user specific cache directory.\n\n.. note::\n\n   using cached paths will e.g. be relevant too, when windows firewall\n   comes into play, because otherwise, the binary will be a different\n   one to it each time it is run.\n\ncurrently these expanded tokens are available:\n\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| token          | what this expands to                                      | example                               |\n+================+===========================================================+=======================================+\n| %temp%         | user temporary file directory                             | c:\\\\users\\\\...\\\\appdata\\\\locals\\\\temp |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %pid%          | process id                                                | 2772                                  |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %time%         | time in seconds since the epoch.                          | 1299852985                            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %program%      | full program run-time filename of executable.             | c:\\\\somewhere\\\\youronefile.exe        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %program_base% | no-suffix of run-time filename of executable.             | c:\\\\somewhere\\\\youronefile            |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %cache_dir%    | cache directory for the user.                             | c:\\\\users\\\\somebody\\\\appdata\\\\local   |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %company%      | value given as ``--company-name``                         | yourcompanyname                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %product%      | value given as ``--product-name``                         | yourproductname                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %version%      | combination of ``--file-version`` & ``--product-version`` | 3.0.0.0-1.0.0.0                       |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %home%         | home directory for the user.                              | /home/somebody                        |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %none%         | when provided for file outputs, ``none`` is used          | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n| %null%         | when provided for file outputs, ``os.devnull`` is used    | see notice below                      |\n+----------------+-----------------------------------------------------------+---------------------------------------+\n\n.. important::\n\n   it is your responsibility to make the path provided unique, on\n   windows a running program will be locked, and while using a fixed\n   folder name is possible, it can cause locking issues in that case,\n   where the program gets restarted.\n\n   usually you need to use ``%time%`` or at least ``%pid%`` to make a\n   path unique, and this is mainly intended for use cases, where e.g.\n   you want things to reside in a place you choose or abide your naming\n   conventions.\n\n.. important::\n\n   for disabling output and stderr with ``--force-stdout-spec`` and\n   ``--force-stderr-spec`` the values ``%none%`` and ``%null%`` achieve\n   it, but with different effect. with ``%none%``the corresponding\n   handle becomes ``none``. as a result e.g. ``sys.stdout`` will be\n   ``none`` which is different from ``%null%`` where it will be backed\n   by a file pointing to ``os.devnull``, i.e. you can write to it.\n\n   with ``%none%`` you may get ``runtimeerror: lost sys.stdout`` in case\n   it does get used, with ``%null%`` that never happens. however, some\n   libraries handle this as input for their logging mechanism, and on\n   windows this is how you are compatible with ``pythonw.exe`` which is\n   behaving like ``%none%``.\n\nuse case 5 - setuptools wheels\n==============================\n\nif you have a ``setup.py``, ``setup.cfg`` or ``pyproject.toml`` driven\ncreation of wheels for your software in place, putting nuitka to use is\nextremely easy.\n\nlets start with the most common ``setuptools`` approach, you can -\nhaving nuitka installed of course, simply execute the target\n``bdist_nuitka`` rather than the ``bdist_wheel``. it takes all the\noptions and allows you to specify some more, that are specific to\nnuitka.\n\n.. code:: python\n\n   # for setup.py if not you't use other build systems:\n   setup(\n      # data files are to be handled by setuptools and not nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # this is to pass nuitka options.\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for c compilation commands\n            '--show-scons': true,\n            # options without value, e.g. enforce using clang\n            '--clang': none,\n            # options with single values, e.g. enable a plugin of nuitka\n            '--enable-plugin': \"pyside2\",\n            # options with several values, e.g. avoiding including modules\n            '--nofollow-import-to' : [\"*.tests\", \"*.distutils\"],\n         },\n      },\n   )\n\n   # for setup.py with other build systems:\n   # the tuple nature of the arguments is required by the dark nature of\n   # \"setuptools\" and plugins to it, that insist on full compatibility,\n   # e.g. \"setuptools_rust\"\n\n   setup(\n      # data files are to be handled by setuptools and not nuitka\n      package_data={\"some_package\": [\"some_file.txt\"]},\n      ...,\n      # this is to pass nuitka options.\n      ...,\n      command_options={\n         'nuitka': {\n            # boolean option, e.g. if you cared for c compilation commands\n            '--show-scons': (\"setup.py\", true),\n            # options without value, e.g. enforce using clang\n            '--clang': (\"setup.py\", none),\n            # options with single values, e.g. enable a plugin of nuitka\n            '--enable-plugin': (\"setup.py\", \"pyside2\"),\n            # options with several values, e.g. avoiding including modules\n            '--nofollow-import-to' : (\"setup.py\", [\"*.tests\", \"*.distutils\"]),\n         }\n      },\n   )\n\nif for some reason, you cannot or do not want to change the target, you\ncan add this to your ``setup.py``.\n\n.. code:: python\n\n   # for setup.py\n   setup(\n      ...,\n      build_with_nuitka=true\n   )\n\n.. note::\n\n   to temporarily disable the compilation, you could remove above line,\n   or edit the value to ``false`` by or take its value from an\n   environment variable if you so choose, e.g.\n   ``bool(os.environ.get(\"use_nuitka\", \"true\"))``. this is up to you.\n\nor you could put it in your ``setup.cfg``\n\n.. code:: toml\n\n   [metadata]\n   build_with_nuitka = true\n\nand last, but not least, nuitka also supports the new ``build`` meta, so\nwhen you have a ``pyproject.toml`` already, simple replace or add this\nvalue:\n\n.. code:: toml\n\n   [build-system]\n   requires = [\"setuptools>=42\", \"wheel\", \"nuitka\", \"toml\"]\n   build-backend = \"nuitka.distutils.build\"\n\n   # data files are to be handled by setuptools and not nuitka\n   [tool.setuptools.package-data]\n   some_package = ['data_file.txt']\n\n   [tool.nuitka]\n   # these are not recommended, but they make it obvious to have effect.\n\n   # boolean option, e.g. if you cared for c compilation commands, leading\n   # dashes are omitted\n   show-scons = true\n\n   # options with single values, e.g. enable a plugin of nuitka\n   enable-plugin = pyside2\n\n   # options with several values, e.g. avoiding including modules, accepts\n   # list argument.\n   nofollow-import-to = [\"*.tests\", \"*.distutils\"]\n\n.. note::\n\n   for the ``nuitka`` requirement above absolute paths like\n   ``c:\\users\\...\\nuitka`` will also work on linux, use an absolute path\n   with *two* leading slashes, e.g. ``//home/.../nuitka``.\n\n.. note::\n\n   whatever approach you take, data files in these wheels are not\n   handled by nuitka at all, but by setuptools. you can however use the\n   data file embedding of nuitka commercial. in that case you actually\n   would embed the files inside the extension module itself, and not as\n   a file in the wheel.\n\nuse case 6 - multidist\n======================\n\nif you have multiple programs, that each should be executable, in the\npast you had to compile multiple times, and deploy all of these. with\nstandalone mode, this of course meant that you were fairly wasteful, as\nsharing the folders could be done, but wasn't really supported by\nnuitka.\n\nenter ``multidist``. there is an option ``--main`` that replaces or adds\nto the positional argument given. and it can be given multiple times.\nwhen given multiple times, nuitka will create a binary that contains the\ncode of all the programs given, but sharing modules used in them. they\ntherefore do not have to be distributed multiple times.\n\nlets call the basename of the main path, and entry point. the names of\nthese must of course be different. then the created binary can execute\neither entry point, and will react to what ``sys.argv[0]`` appears to\nit. so if executed in the right way (with something like ``subprocess``\nor os api you can control this name), or by renaming or copying the\nbinary, or symlinking to it, you can then achieve the miracle.\n\nthis allows to combine very different programs into one.\n\n.. note::\n\n   this feature is still experimental. use with care and report your\n   findings should you encounter anything that is undesirable behavior\n\nthis mode works with standalone, onefile, and mere acceleration. it does\nnot work with module mode.\n\n********\n tweaks\n********\n\nicons\n=====\n\nfor good looks, you may specify icons. on windows, you can provide an\nicon file, a template executable, or a png file. all of these will work\nand may even be combined:\n\n.. code:: bash\n\n   # these create binaries with icons on windows\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.png program.py\n   python -m nuitka --onefile --windows-icon-from-ico=your-icon.ico program.py\n   python -m nuitka --onefile --windows-icon-template-exe=your-icon.ico program.py\n\n   # these create application bundles with icons on macos\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.png program.py\n   python -m nuitka --macos-create-app-bundle --macos-app-icon=your-icon.icns program.py\n\n.. note::\n\n   with nuitka, you do not have to create platform specific icons, but\n   instead it will convert e.g. png, but also other format on the fly\n   during the build.\n\nmacos entitlements\n==================\n\nentitlements for an macos application bundle can be added with the\noption, ``--macos-app-protected-resource``, all values are listed on\n`this page from apple\n<https://developer.apple.com/documentation/bundleresources/information_property_list/protected_resources>`__\n\nan example value would be\n``--macos-app-protected-resource=nsmicrophoneusagedescription:microphone\naccess`` for requesting access to a microphone. after the colon, the\ndescriptive text is to be given.\n\n.. note::\n\n   beware that in the likely case of using spaces in the description\n   part, you need to quote it for your shell to get through to nuitka\n   and not be interpreted as nuitka arguments.\n\nconsole window\n==============\n\non windows, the console is opened by programs unless you say so. nuitka\ndefaults to this, effectively being only good for terminal programs, or\nprograms where the output is requested to be seen. there is a difference\nin ``pythonw.exe`` and ``python.exe`` along those lines. this is\nreplicated in nuitka with the option ``--disable-console``. nuitka\nrecommends you to consider this in case you are using ``pyside6`` e.g.\nand other gui packages, e.g. ``wx``, but it leaves the decision up to\nyou. in case, you know your program is console application, just using\n``--enable-console`` which will get rid of these kinds of outputs from\nnuitka.\n\n.. note::\n\n   the ``pythonw.exe`` is never good to be used with nuitka, as you\n   cannot see its output.\n\nsplash screen\n=============\n\nsplash screens are useful when program startup is slow. onefile startup\nitself is not slow, but your program may be, and you cannot really know\nhow fast the computer used will be, so it might be a good idea to have\nthem. luckily with nuitka, they are easy to add for windows.\n\nfor splash screen, you need to specify it as a png file, and then make\nsure to disable the splash screen when your program is ready, e.g. has\ncomplete the imports, prepared the window, connected to the database,\nand wants the splash screen to go away. here we are using the project\nsyntax to combine the code with the creation, compile this:\n\n.. code:: python\n\n   # nuitka-project: --onefile\n   # nuitka-project: --onefile-windows-splash-screen-image={main_directory}/splash-screen.png\n\n   # whatever this is obviously\n   print(\"delaying startup by 10s...\")\n   import time, tempfile, os\n   time.sleep(10)\n\n   # use this code to signal the splash screen removal.\n   if \"nuitka_onefile_parent\" in os.environ:\n      splash_filename = os.path.join(\n         tempfile.gettempdir(),\n         \"onefile_%d_splash_feedback.tmp\" % int(os.environ[\"nuitka_onefile_parent\"]),\n      )\n\n      if os.path.exists(splash_filename):\n         os.unlink(splash_filename)\n\n   print(\"done... splash should be gone.\")\n   ...\n\n   # rest of your program goes here.\n\nreports\n=======\n\nfor analysis of your program and nuitka packaging, there is the\n`compilation report`_ available. you can also make custom reports\nproviding your own template, with a few of them built-in to nuitka.\nthese reports carry all the detail information, e.g. when a module was\nattempted to be imported, but not found, you can see where that happens.\nfor bug reporting, it is very much recommended to provide the report.\n\nversion information\n===================\n\nyou can attach copyright and trademark information, company name,\nproduct name, and so on to your compilation. this is then used in\nversion information for the created binary on windows, or application\nbundle on macos. if you find something that is lacking, let us know.\n\n******************\n typical problems\n******************\n\ndeployment mode\n===============\n\nby default, nuitka compiles without ``--deployment`` which leaves a set\nof safe guards and helpers on, that are aimed at debugging wrong uses of\nnuitka.\n\nthis is a new feature, and implements a bunch of protections and\nhelpers, that are documented here.\n\nfork bombs (self-execution)\n---------------------------\n\nso after compilation, ``sys.executable`` is the compiled binary. in case\nof packages like ``multiprocessing``, ``joblib``, or ``loky`` what these\ntypically do is to expect to run from a full ``python`` with\n``sys.executable`` and then to be able to use its options like ``-c\ncommand`` or ``-m module_name`` and then be able to launch other code\ntemporarily or permanently as a service daemon.\n\nwith nuitka however, this executes your program again, and puts these\narguments, in ``sys.argv`` where you maybe ignore them, and then you\nfork yourself again to launch the helper daemons. sometimes this ends up\nspawning cpu count processes that spawn cpu count processes that... this\nis called a fork bomb, and with almost all systems, that freezes them\neasily to death.\n\nthat is why e.g. this happens with default nuitka:\n\n.. code::\n\n   ./hello.dist/hello.bin -l fool -m foom -n foon -o fooo -p\n   error, the program tried to call itself with '-m' argument. disable with '--no-deployment-flag=self-execution'.\n\nyour program may well have its own command line parsing, and not use an\nunsupported package that does attempt to re-execute. in this case, you\nneed at *compile time* to use ``--no-deployment-flag=self-execution``\nwhich disables this specific guard.\n\nmisleading messages\n-------------------\n\nsome packages output what they think is helpful information about what\nthe reason of a failed import might me. with compiled programs there are\nvery often just plain wrong. we try and repair those in non-deployment\nmode. here is an example, where we change a message that asks to pip\ninstall (which is not the issue) to point the user to the include\ncommand that makes an ``imageio`` plugin work.\n\n.. code:: yaml\n\n   - module-name: 'imageio.core.imopen'\n     anti-bloat:\n       - replacements_plain:\n           '`pip install imageio[{config.install_name}]` to install it': '`--include-module={config.module_name}` with nuitka to include it'\n           'err_type = importerror': 'err_type = runtimeerror'\n         when: 'not deployment'\n\nand much more\n-------------\n\nthe deployment mode is relatively new and has constantly more features\nadded, e.g. something for ``filenotfounderror`` should be coming soon.\n\ndisabling all\n-------------\n\nall these helpers can of course be disabled at once with\n``--deployment`` but keep in mind that for debugging, you may want to\nre-enable it. you might want to use nuitka project options and an\nenvironment variable to make this conditional.\n\nshould you disable them all?\n\nwe believe, disabling should only happen selectively, but with pypi\nupgrades, your code changes, all of these issues can sneak back in. the\nspace saving of deployment mode is currently negligible, so attempt to\nnot do it, but review what exists, and if you know that it cannot affect\nyou, or if it does, you will not need it. some of the future ones, will\nclearly be geared at beginner level usage.\n\nwindows virus scanners\n======================\n\nbinaries compiled on windows with default settings of nuitka and no\nfurther actions taken might be recognized by some av vendors as malware.\nthis is avoidable, but only in nuitka commercial there is actual support\nand instructions for how to do it, seeing this as a typical commercial\nonly need. https://nuitka.net/doc/commercial.html\n\nlinux standalone\n================\n\nfor linux standalone it is pretty difficult to build a binary that works\non other linux versions. this is mainly because on linux, much software\nis built specifically targeted to concrete dlls. things like glibc used,\nare then encoded into the binary built, and it will not run with an\nolder glibc, just to give one critical example.\n\nthe solution is to build on the oldest os that you want to see\nsupported. picking that and setting it up can be tedious, so can be\nlogin, and keeping it secure, as it's something you put your source code\non.\n\nto aid that, nuitka commercial has container based builds, that you can\nuse. this uses dedicated optimized python builds, targets centos 7 and\nsupports even newest pythons and very old oses that way using recent c\ncompiler chains all turn key solution. the effort needs to be\ncompensated to support nuitka development for linux, there you need to\npurchase it https://nuitka.net/doc/commercial.html but even a sponsor\nlicense will be cheaper than doing it yourself.\n\nmemory issues and compiler bugs\n===============================\n\nsometimes the c compilers will crash saying they cannot allocate memory\nor that some input was truncated, or similar error messages, clearly\nfrom it. there are several options you can explore here:\n\nask nuitka to use less memory\n-----------------------------\n\nthere is a dedicated option ``--low-memory`` which influences decisions\nof nuitka, such that it avoids high usage of memory during compilation\nat the cost of increased compile time.\n\navoid 32 bit c compiler/assembler memory limits\n-----------------------------------------------\n\ndo not use a 32 bits compiler, but a 64 bit one. if you are using python\nwith 32 bits on windows, you most definitely ought to use msvc as the c\ncompiler, and not mingw64. the msvc is a cross compiler, and can use\nmore memory than gcc on that platform. if you are not on windows, that\nis not an option of course. also using the 64 bits python will work.\n\nuse a minimal virtualenv\n------------------------\n\nwhen you compile from a living installation, that may well have many\noptional dependencies of your software installed. some software, will\nthen have imports on these, and nuitka will compile them as well. not\nonly may these be just the trouble makers, they also require more\nmemory, so get rid of that. of course you do have to check that your\nprogram has all needed dependencies before you attempt to compile, or\nelse the compiled program will equally not run.\n\nuse lto compilation or not\n--------------------------\n\nwith ``--lto=yes`` or ``--lto=no`` you can switch the c compilation to\nonly produce bytecode, and not assembler code and machine code directly,\nbut make a whole program optimization at the end. this will change the\nmemory usage pretty dramatically, and if your error is coming from the\nassembler, using lto will most definitely avoid that.\n\nswitch the c compiler to clang\n------------------------------\n\npeople have reported that programs that fail to compile with gcc due to\nits bugs or memory usage work fine with clang on linux. on windows, this\ncould still be an option, but it needs to be implemented first for the\nautomatic downloaded gcc, that would contain it. since msvc is known to\nbe more memory effective anyway, you should go there, and if you want to\nuse clang, there is support for the one contained in msvc.\n\nadd a larger swap file to your embedded linux\n---------------------------------------------\n\non systems with not enough ram, you need to use swap space. running out\nof it is possibly a cause, and adding more swap space, or one at all,\nmight solve the issue, but beware that it will make things extremely\nslow when the compilers swap back and forth, so consider the next tip\nfirst or on top of it.\n\nlimit the amount of compilation jobs\n------------------------------------\n\nwith the ``--jobs`` option of nuitka, it will not start many c compiler\ninstances at once, each competing for the scarce resource of ram. by\npicking a value of one, only one c compiler instance will be running,\nand on a 8 core system, that reduces the amount of memory by factor 8,\nso that's a natural choice right there.\n\ndynamic ``sys.path``\n====================\n\nif your script modifies ``sys.path`` to e.g. insert directories with\nsource code relative to it, nuitka will not be able to see those.\nhowever, if you set the ``pythonpath`` to the resulting value, it will\nbe able to compile it and find the used modules from these paths as\nwell.\n\nmanual python file loading\n==========================\n\na very frequent pattern with private code is that it scans plugin\ndirectories of some kind, and e.g. uses ``os.listdir``, then considers\npython filenames, and then opens a file and does ``exec`` on them. this\napproach is working for python code, but for compiled code, you should\nuse this much cleaner approach, that works for pure python code and is a\nlot less vulnerable.\n\n.. code:: python\n\n   # using a package name, to locate the plugins. this is also a sane\n   # way to organize them into a directory.\n   scan_path = scan_package.__path__\n\n   for item in pkgutil.iter_modules(scan_path):\n      importlib.import_module(scan_package.__name__ + \".\" + item.name)\n\n      # you may want to do it recursively, but we don't do this here in\n      # this example. if you want to, handle that in this kind of branch.\n      if item.ispkg:\n         ...\n\nmissing data files in standalone\n================================\n\nif your program fails to file data, it can cause all kinds of different\nbehaviors, e.g. a package might complain it is not the right version,\nbecause a ``version`` file check defaulted to unknown. the absence of\nicon files or help texts, may raise strange errors.\n\noften the error paths for files not being present are even buggy and\nwill reveal programming errors like unbound local variables. please look\ncarefully at these exceptions keeping in mind that this can be the\ncause. if your program works without standalone, chances are data files\nmight be cause.\n\nthe most common error indicating file absence is of course an uncaught\n``filenotfounderror`` with a filename. you should figure out what\npackage is missing files and then use ``--include-package-data``\n(preferably), or ``--include-data-dir``/``--include-data-files`` to\ninclude them.\n\nmissing dlls/exes in standalone\n===============================\n\nnuitka has plugins that deal with copying dlls. for numpy, scipy,\ntkinter, etc.\n\nthese need special treatment to be able to run on other systems.\nmanually copying them is not enough and will given strange errors.\nsometimes newer version of packages, esp. numpy can be unsupported. in\nthis case you will have to raise an issue, and use the older one.\n\nif you want to manually add a dll or an exe, because it is your project\nonly, you will have to use user yaml files describing where they can be\nfound. this is described in detail with examples in the `nuitka package\nconfiguration <https://nuitka.net/doc/nuitka-package-config.html>`__\npage.\n\ndependency creep in standalone\n==============================\n\nsome packages are a single import, but to nuitka mean that more than a\nthousand packages (literally) are to be included. the prime example of\npandas, which does want to plug and use just about everything you can\nimagine. multiple frameworks for syntax highlighting everything\nimaginable take time.\n\nnuitka will have to learn effective caching to deal with this in the\nfuture. right now, you will have to deal with huge compilation times for\nthese.\n\na major weapon in fighting dependency creep should be applied, namely\nthe ``anti-bloat`` plugin, which offers interesting abilities, that can\nbe put to use and block unneeded imports, giving an error for where they\noccur. use it e.g. like this ``--noinclude-pytest-mode=nofollow\n--noinclude-setuptools-mode=nofollow`` and e.g. also\n``--noinclude-custom-mode=setuptools:error`` to get the compiler to\nerror out for a specific package. make sure to check its help output. it\ncan take for each module of your choice, e.g. forcing also that e.g.\n``pyqt5`` is considered uninstalled for standalone mode.\n\nit's also driven by a configuration file, ``anti-bloat.yml`` that you\ncan contribute to, removing typical bloat from packages. feel free to\nenhance it and make prs towards nuitka with it.\n\nstandalone: finding files\n=========================\n\nthe standard code that normally works, also works, you should refer to\n``os.path.dirname(__file__)`` or use all the packages like ``pkgutil``,\n``pkg_resources``, ``importlib.resources`` to locate data files near the\nstandalone binary.\n\n.. important::\n\n   what you should **not** do, is use the current directory\n   ``os.getcwd``, or assume that this is the script directory, e.g. with\n   paths like ``data/``.\n\n   if you did that, it was never good code. links, to a program,\n   launching from another directory, etc. will all fail in bad ways. do\n   not make assumptions about the directory your program is started\n   from.\n\nonefile: finding files\n======================\n\nthere is a difference between ``sys.argv[0]`` and ``__file__`` of the\nmain module for onefile mode, that is caused by using a bootstrap to a\ntemporary location. the first one will be the original executable path,\nwhereas the second one will be the temporary or permanent path the\nbootstrap executable unpacks to. data files will be in the later\nlocation, your original environment files will be in the former\nlocation.\n\ngiven 2 files, one which you expect to be near your executable, and one\nwhich you expect to be inside the onefile binary, access them like this.\n\n.. code:: python\n\n   # this will find a file *near* your onefile.exe\n   open(os.path.join(os.path.dirname(sys.argv[0]), \"user-provided-file.txt\"))\n   # this will find a file *inside* your onefile.exe\n   open(os.path.join(os.path.dirname(__file__), \"user-provided-file.txt\"))\n\nwindows programs without console give no errors\n===============================================\n\nfor debugging purposes, remove ``--disable-console`` or use the options\n``--force-stdout-spec`` and ``--force-stderr-spec`` with paths as\ndocumented for ``--onefile-tempdir-spec`` above. these can be relative\nto the program or absolute, so you can see the outputs given.\n\ndeep copying uncompiled functions\n=================================\n\nsometimes people use this kind of code, which for packages on pypi, we\ndeal with by doing source code patches on the fly. if this is in your\nown code, here is what you can do:\n\n.. code:: python\n\n   def binder(func, name):\n      result = types.functiontype(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n      result = functools.update_wrapper(result, func)\n      result.__kwdefaults__ = func.__kwdefaults__\n      result.__name__ = name\n      return result\n\ncompiled functions cannot be used to create uncompiled ones from, so the\nabove code will not work. however, there is a dedicated ``clone``\nmethod, that is specific to them, so use this instead.\n\n.. code:: python\n\n   def binder(func, name):\n      try:\n         result = func.clone()\n      except attributeerror:\n         result = types.functiontype(func.__code__, func.__globals__, name=func.__name__, argdefs=func.__defaults__, closure=func.__closure__)\n         result = functools.update_wrapper(result, func)\n         result.__kwdefaults__ = func.__kwdefaults__\n\n      result.__name__ = name\n      return result\n\nmodules: extension modules are not executable directly\n======================================================\n\na package can be compiled with nuitka, no problem, but when it comes to\nexecuting it, ``python -m compiled_module`` is not going to work and\ngive the error ``no code object available for assertstest`` because the\ncompiled module is not source code, and python will not just load it.\nthe closest would be ``python -c \"import compile_module\"`` and you might\nhave to call the main function yourself.\n\nto support this, the cpython ``runpy`` and/or ``extensionfileloader``\nwould need improving such that nuitka could supply its compiled module\nobject for python to use.\n\n******\n tips\n******\n\nnuitka options in the code\n==========================\n\nthere is support for conditional options, and options using pre-defined\nvariables, this is an example:\n\n.. code:: python\n\n   # compilation mode, support os specific options\n   # nuitka-project-if: {os} in (\"windows\", \"linux\", \"darwin\", \"freebsd\"):\n   #    nuitka-project: --onefile\n   # nuitka-project-else:\n   #    nuitka-project: --standalone\n\n   # the pyside2 plugin covers qt-plugins\n   # nuitka-project: --enable-plugin=pyside2\n   # nuitka-project: --include-qt-plugins=sensible,qml\n\n   # debugging toggle\n   # nuitka-project-if: os.environ.get(\"debug_compilation\", \"no\") == \"yes\"\n   #    nuitka-project: --debug\n   # nuitka-project-else:\n   #    nuitka-project: --deployment\n\nthe comments must be a start of line, and indentation is to be used, to\nend a conditional block, much like in python. there are currently no\nother keywords than the used ones demonstrated above.\n\nyou can put arbitrary python expressions there, and if you wanted to\ne.g. access a version information of a package, you could simply use\n``__import__(\"module_name\").__version__`` if that would be required to\ne.g. enable or disable certain nuitka settings. the only thing nuitka\ndoes that makes this not python expressions, is expanding ``{variable}``\nfor a pre-defined set of variables:\n\ntable with supported variables:\n\n+------------------+--------------------------------+------------------------------------------+\n| variable         | what this expands to           | example                                  |\n+==================+================================+==========================================+\n| {os}             | name of the os used            | linux, windows, darwin, freebsd, openbsd |\n+------------------+--------------------------------+------------------------------------------+\n| {version}        | version of nuitka              | e.g. (1, 6, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {commercial}     | version of nuitka commercial   | e.g. (2, 1, 0)                           |\n+------------------+--------------------------------+------------------------------------------+\n| {arch}           | architecture used              | x86_64, arm64, etc.                      |\n+------------------+--------------------------------+------------------------------------------+\n| {main_directory} | directory of the compiled file | some_dir/maybe_relative                  |\n+------------------+--------------------------------+------------------------------------------+\n| {flavor}         | variant of python              | e.g. debian python, anaconda python      |\n+------------------+--------------------------------+------------------------------------------+\n\nthe use of ``{main_directory}`` is recommended when you want to specify\na filename relative to the main script, e.g. for use in data file\noptions or user package configuration yaml files,\n\n.. code:: python\n\n   # nuitka-project: --include-data-files={main_directory}/my_icon.png=my_icon.png\n   # nuitka-project: --user-package-configuration-file={main_directory}/user.nuitka-package.config.yml\n\npython command line flags\n=========================\n\nfor passing things like ``-o`` or ``-s`` to python, to your compiled\nprogram, there is a command line option name ``--python-flag=`` which\nmakes nuitka emulate these options.\n\nthe most important ones are supported, more can certainly be added.\n\ncaching compilation results\n===========================\n\nthe c compiler, when invoked with the same input files, will take a long\ntime and much cpu to compile over and over. make sure you are having\n``ccache`` installed and configured when using gcc (even on windows). it\nwill make repeated compilations much faster, even if things are not yet\nnot perfect, i.e. changes to the program can cause many c files to\nchange, requiring a new compilation instead of using the cached result.\n\non windows, with gcc nuitka supports using ``ccache.exe`` which it will\noffer to download from an official source and it automatically. this is\nthe recommended way of using it on windows, as other versions can e.g.\nhang.\n\nnuitka will pick up ``ccache`` if it's in found in system ``path``, and\nit will also be possible to provide if by setting\n``nuitka_ccache_binary`` to the full path of the binary, this is for use\nin ci systems where things might be non-standard.\n\nfor the msvc compilers and clangcl setups, using the ``clcache`` is\nautomatic and included in nuitka.\n\non macos and intel, there is an automatic download of a ``ccache``\nbinary from our site, for arm64 arches, it's recommended to use this\nsetup, which installs homebrew and ccache in there. nuitka picks that\none up automatically if it on that kind of machine. you need and should\nnot use homebrew with nuitka otherwise, it's not the best for standalone\ndeployments, but we can take ``ccache`` from there.\n\n.. code:: bash\n\n   export homebrew_install_from_api=1\n   /bin/bash -c \"$(curl -fssl https://raw.githubusercontent.com/homebrew/install/master/install.sh)\"\n   eval $(/opt/homebrew/bin/brew shellenv)\n   brew install ccache\n\ncontrol where caches live\n=========================\n\nthe storage for cache results of all kinds, downloads, cached\ncompilation results from c and nuitka, is done in a platform dependent\ndirectory as determined by the ``appdirs`` package. however, you can\noverride it with setting the environment variable ``nuitka_cache_dir``\nto a base directory. this is for use in environments where the home\ndirectory is not persisted, but other paths are.\n\nrunners\n=======\n\navoid running the ``nuitka`` binary, doing ``python -m nuitka`` will\nmake a 100% sure you are using what you think you are. using the wrong\npython will make it give you ``syntaxerror`` for good code or\n``importerror`` for installed modules. that is happening, when you run\nnuitka with python2 on python3 code and vice versa. by explicitly\ncalling the same python interpreter binary, you avoid that issue\nentirely.\n\nfastest c compilers\n===================\n\nthe fastest binaries of ``pystone.exe`` on windows with 64 bits python\nproved to be significantly faster with mingw64, roughly 20% better\nscore. so it is recommended for use over msvc. using ``clang-cl.exe`` of\nclang7 was faster than msvc, but still significantly slower than\nmingw64, and it will be harder to use, so it is not recommended.\n\non linux for ``pystone.bin`` the binary produced by ``clang6`` was\nfaster than ``gcc-6.3``, but not by a significant margin. since gcc is\nmore often already installed, that is recommended to use for now.\n\ndifferences in c compilation times have not yet been examined.\n\nunexpected slowdowns\n====================\n\nusing the python dll, like standard cpython does can lead to unexpected\nslowdowns, e.g. in uncompiled code that works with unicode strings. this\nis because calling to the dll rather than residing in the dll causes\noverhead, and this even happens to the dll with itself, being slower,\nthan a python all contained in one binary.\n\nso if feasible, aim at static linking, which is currently only possible\nwith anaconda python on non-windows, debian python2, self compiled\npythons (do not activate ``--enable-shared``, not needed), and installs\ncreated with ``pyenv``.\n\n.. note::\n\n   on anaconda, you may need to execute ``conda install\n   libpython-static``\n\nstandalone executables and dependencies\n=======================================\n\nthe process of making standalone executables for windows traditionally\ninvolves using an external dependency walker in order to copy necessary\nlibraries along with the compiled executables to the distribution\nfolder.\n\nthere is plenty of ways to find that something is missing. do not\nmanually copy things into the folder, esp. not dlls, as that's not going\nto work. instead make bug reports to get these handled by nuitka\nproperly.\n\nwindows errors with resources\n=============================\n\non windows, the windows defender tool and the windows indexing service\nboth scan the freshly created binaries, while nuitka wants to work with\nit, e.g. adding more resources, and then preventing operations randomly\ndue to holding locks. make sure to exclude your compilation stage from\nthese services.\n\nwindows standalone program redistribution\n=========================================\n\nwhether compiling with mingw or msvc, the standalone programs have\nexternal dependencies to visual c runtime libraries. nuitka tries to\nship those dependent dlls by copying them from your system.\n\nbeginning with microsoft windows 10, microsoft ships ``ucrt.dll``\n(universal c runtime libraries) which handles calls to\n``api-ms-crt-*.dll``.\n\nwith earlier windows platforms (and wine/reactos), you should consider\ninstalling visual c runtime libraries before executing a nuitka\nstandalone compiled program.\n\ndepending on the used c compiler, you'll need the following redist\nversions on the target machines. however notice that compilation using\nthe 14.3 based version is recommended.\n\n+------------------+-------------+-------------------------------+\n| visual c version | redist year | cpython                       |\n+==================+=============+===============================+\n| 14.3             | 2022        | 3.11                          |\n+------------------+-------------+-------------------------------+\n| 14.2             | 2019        | 3.5, 3.6, 3.7, 3.8, 3.9, 3.10 |\n+------------------+-------------+-------------------------------+\n| 14.1             | 2017        | 3.5, 3.6, 3.7, 3.8            |\n+------------------+-------------+-------------------------------+\n| 14.0             | 2015        | 3.5, 3.6, 3.7, 3.8            |\n+------------------+-------------+-------------------------------+\n| 10.0             | 2010        | 3.4                           |\n+------------------+-------------+-------------------------------+\n| 9.0              | 2008        | 2.6, 2.7                      |\n+------------------+-------------+-------------------------------+\n\nwhen using minggw64, you'll need the following redist versions:\n\n+------------------+-------------+-------------------------------------+\n| minggw64 version | redist year | cpython                             |\n+==================+=============+=====================================+\n| 8.1.0            | 2015        | 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11 |\n+------------------+-------------+-------------------------------------+\n\nonce the corresponding runtime libraries are installed on the target\nsystem, you may remove all ``api-ms-crt-*.dll`` files from your nuitka\ncompiled dist folder.\n\ndetecting nuitka at run time\n============================\n\nnuitka does *not* ``sys.frozen`` unlike other tools, because it usually\ntriggers inferior code for no reason. for nuitka, we have the module\nattribute ``__compiled__`` to test if a specific module was compiled,\nand the function attribute ``__compiled__`` to test if a specific\nfunction was compiled.\n\nproviding extra options to nuitka c compilation\n===============================================\n\nnuitka will apply values from the environment variables ``ccflags``,\n``ldflags`` during the compilation on top of what it determines to be\nnecessary. beware of course, that is this is only useful if you know\nwhat you are doing, so should this pose an issues, raise them only with\nperfect information.\n\nproducing a 32 bit binary on a 64 bit windows system\n====================================================\n\nnuitka will automatically target the architecture of the python you are\nusing. if this is 64 bits, it will create a 64 bits binary, if it is 32\nbits, it will create a 32 bits binary. you have the option to select the\nbits when you download the python. in the output of ``python -m nuitka\n--version`` there is a line for the architecture. it ``arch: x86_64``\nfor 64 bits, and just ``arch: x86`` for 32 bits.\n\nthe c compiler will be picked to match that more or less automatically.\nif you specify it explicitly and it mismatches, you will get a warning\nabout the mismatch and informed that your compiler choice was rejected.\n\n********************\n compilation report\n********************\n\nwhen you use ``--report=compilation-report.xml`` nuitka will create an\nxml file with detailed information about the compilation and packaging\nprocess. this is growing in completeness with every release and exposes\nmodule usage attempts, timings of the compilation, plugin influences,\ndata file paths, dlls, and reasons why things are included or not.\n\nat this time, the report contains absolute paths in some places, with\nyour private information. the goal is to make this blended out by\ndefault, because we also want to become able to compare compilation\nreports from different setups, e.g. with updated packages, and see the\nchanges to nuitka. the report is however recommended for your bug\nreporting.\n\nalso, another form is available, where the report is free form and\naccording to a jinja2 template of yours, and one that is included in\nnuitka. the same information as used to produce the xml file is\naccessible. however, right now this is not yet documented, but we plan\nto add a table with the data. for reader of the source code that is\nfamiliar with jinja2, however, it will be easy to do it now already.\n\nif you have a template, you can use it like this\n``--report-template=your_template.rst.j2:your_report.rst`` and of\ncourse, the usage of restructured text, is only an example. you can use\nmarkdown, your own xml, or whatever you see fit. nuitka will just expand\nthe template with the compilation report data.\n\ncurrently the follow reports are included in nuitka. you just use the\nname as a filename, and nuitka will pick that one instead.\n\n+---------------+--------------+--------------------------------------------------------+\n| report name   | status       | purpose                                                |\n+===============+==============+========================================================+\n| licensereport | experimental | distributions used in a compilation with license texts |\n+---------------+--------------+--------------------------------------------------------+\n\n.. note::\n\n   the community can and should contribute more report types and help\n   enhancing the existing ones for good looks.\n\n*************\n performance\n*************\n\nthis chapter gives an overview, of what to currently expect in terms of\nperformance from nuitka. it's a work in progress and is updated as we\ngo. the current focus for performance measurements is python 2.7, but\n3.x is going to follow later.\n\npystone results\n===============\n\nthe results are the top value from this kind of output, running pystone\n1000 times and taking the minimal value. the idea is that the fastest\nrun is most meaningful, and eliminates usage spikes.\n\n.. code:: bash\n\n   echo \"uncompiled python2\"\n   for i in {1..100}; do bench=1 python2 tests/benchmarks/pystone.py ; done | sort -rn | head -n 1\n   python2 -m nuitka --lto=yes --pgo tests/benchmarks/pystone.py\n   echo \"compiled python2\"\n   for i in {1..100}; do bench=1 ./pystone.bin ; done | sort -n | head -rn 1\n\n   echo \"uncompiled python3\"\n   for i in {1..100}; do bench=1 python3 tests/benchmarks/pystone3.py ; done | sort -rn | head -n 1\n   python3 -m nuitka --lto=yes --pgo tests/benchmarks/pystone3.py\n   echo \"compiled python3\"\n   for i in {1..100}; do bench=1 ./pystone3.bin ; done | sort -rn | head -n 1\n\n+-------------------+-------------------+----------------------+---------------------+\n| python            | uncompiled        | compiled lto         | compiled pgo        |\n+===================+===================+======================+=====================+\n| debian python 2.7 | 137497.87 (1.000) | 460995.20 (3.353)    | 503681.91 (3.663)   |\n+-------------------+-------------------+----------------------+---------------------+\n| nuitka python 2.7 | 144074.78 (1.048) | 479271.51 (3.486)    | 511247.44 (3.718)   |\n+-------------------+-------------------+----------------------+---------------------+\n\n******************\n where to go next\n******************\n\nremember, this project needs constant work. although the python\ncompatibility is insanely high, and test suite works near perfectly,\nthere is still more work needed, esp. to make it do more optimization.\ntry it out, and when popular packages do not work, please make reports\non github.\n\nfollow me on mastodon and twitter\n=================================\n\nnuitka announcements and interesting stuff is pointed to on both the\nmastodon and twitter accounts, but obviously with not too many details,\nusually pointing to the website, but sometimes i also ask questions\nthere.\n\n`@kayhayen on mastodon <https://fosstodon.org/@kayhayen>`_. `@kayhayen\non twitter <https://twitter.com/kayhayen>`_.\n\nreport issues or bugs\n=====================\n\nshould you encounter any issues, bugs, or ideas, please visit the\n`nuitka bug tracker <https://github.com/nuitka/nuitka/issues>`__ and\nreport them.\n\nbest practices for reporting bugs:\n\n-  please always include the following information in your report, for\n   the underlying python version. you can easily copy&paste this into\n   your report. it does contain more information that you think. do not\n   write something manually. you may always add of course.\n\n   .. code:: bash\n\n      python -m nuitka --version\n\n-  try to make your example minimal. that is, try to remove code that\n   does not contribute to the issue as much as possible. ideally come up\n   with a small reproducing program that illustrates the issue, using\n   ``print`` with different results when that programs runs compiled or\n   native.\n\n-  if the problem occurs spuriously (i.e. not each time), try to set the\n   environment variable ``pythonhashseed`` to ``0``, disabling hash\n   randomization. if that makes the problem go away, try increasing in\n   steps of 1 to a hash seed value that makes it happen every time,\n   include it in your report.\n\n-  do not include the created code in your report. given proper input,\n   it's redundant, and it's not likely that i will look at it without\n   the ability to change the python or nuitka source and re-run it.\n\n-  do not send screenshots of text, that is bad and lazy. instead,\n   capture text outputs from the console.\n\nword of warning\n===============\n\nconsider using this software with caution. even though many tests are\napplied before releases, things are potentially breaking. your feedback\nand patches to nuitka are very welcome.\n\n*************\n join nuitka\n*************\n\nyou are more than welcome to join nuitka development and help to\ncomplete the project in all minor and major ways.\n\nthe development of nuitka occurs in git. we currently have these 3\nbranches:\n\n-  ``main``\n\n   this branch contains the stable release to which only hotfixes for\n   bugs will be done. it is supposed to work at all times and is\n   supported.\n\n-  ``develop``\n\n   this branch contains the ongoing development. it may at times contain\n   little regressions, but also new features. on this branch, the\n   integration work is done, whereas new features might be developed on\n   feature branches.\n\n-  ``factory``\n\n   this branch contains unfinished and incomplete work. it is very\n   frequently subject to ``git rebase`` and the public staging ground,\n   where my work for develop branch lives first. it is intended for\n   testing only and recommended to base any of your own development on.\n   when updating it, you very often will get merge conflicts. simply\n   resolve those by doing ``git fetch && git reset --hard\n   origin/factory`` and switch to the latest version.\n\n.. note::\n\n   the `developer manual\n   <https://nuitka.net/doc/developer-manual.html>`__ explains the coding\n   rules, branching model used, with feature branches and hotfix\n   releases, the nuitka design and much more. consider reading it to\n   become a contributor. this document is intended for nuitka users.\n\n***********\n donations\n***********\n\nshould you feel that you cannot help nuitka directly, but still want to\nsupport, please consider `making a donation\n<https://nuitka.net/pages/donations.html>`__ and help this way.\n\n***************************\n unsupported functionality\n***************************\n\nthe ``co_code`` attribute of code objects\n=========================================\n\nthe code objects are empty for native compiled functions. there is no\nbytecode with nuitka's compiled function objects, so there is no way to\nprovide it.\n\npdb\n===\n\nthere is no tracing of compiled functions to attach a debugger to.\n\n**************\n optimization\n**************\n\nconstant folding\n================\n\nthe most important form of optimization is the constant folding. this is\nwhen an operation can be fully predicted at compile time. currently,\nnuitka does these for some built-ins (but not all yet, somebody to look\nat this more closely will be very welcome!), and it does it e.g. for\nbinary/unary operations and comparisons.\n\nconstants currently recognized:\n\n.. code:: python\n\n   5 + 6  # binary operations\n   not 7  # unary operations\n   5 < 6  # comparisons\n   range(3)  # built-ins\n\nliterals are the one obvious source of constants, but also most likely\nother optimization steps like constant propagation or function inlining\nwill be. so this one should not be underestimated and a very important\nstep of successful optimizations. every option to produce a constant may\nimpact the generated code quality a lot.\n\n.. admonition:: status\n\n   the folding of constants is considered implemented, but it might be\n   incomplete in that not all possible cases are caught. please report\n   it as a bug when you find an operation in nuitka that has only\n   constants as input and is not folded.\n\nconstant propagation\n====================\n\nat the core of optimizations, there is an attempt to determine the\nvalues of variables at run time and predictions of assignments. it\ndetermines if their inputs are constants or of similar values. an\nexpression, e.g. a module variable access, an expensive operation, may\nbe constant across the module of the function scope and then there needs\nto be none or no repeated module variable look-up.\n\nconsider e.g. the module attribute ``__name__`` which likely is only\never read, so its value could be predicted to a constant string known at\ncompile time. this can then be used as input to the constant folding.\n\n.. code:: python\n\n   if __name__ == \"__main__\":\n       # your test code might be here\n       use_something_not_use_by_program()\n\n.. admonition:: status\n\n   from modules attributes, only ``__name__`` is currently actually\n   optimized. also possible would be at least ``__doc__``. in the\n   future, this may improve as ssa is expanded to module variables.\n\nbuilt-in name lookups\n=====================\n\nalso, built-in exception name references are optimized if they are used\nas a module level read-only variables:\n\n.. code:: python\n\n   try:\n       something()\n   except valueerror:  # the valueerror is a slow global name lookup normally.\n       pass\n\n.. admonition:: status\n\n   this works for all built-in names. when an assignment is done to such\n   a name, or it's even local, then, of course, it is not done.\n\nbuilt-in call prediction\n========================\n\nfor built-in calls like ``type``, ``len``, or ``range`` it is often\npossible to predict the result at compile time, esp. for constant inputs\nthe resulting value often can be precomputed by nuitka. it can simply\ndetermine the result or the raised exception and replace the built-in\ncall with that value, allowing for more constant folding or code path\nreduction.\n\n.. code:: python\n\n   type(\"string\")  # predictable result, builtin type str.\n   len([1, 2])  # predictable result\n   range(3, 9, 2)  # predictable result\n   range(3, 9, 0)  # predictable exception, range raises due to 0.\n\n.. admonition:: status\n\n   the built-in call prediction is considered implemented. we can simply\n   during compile time emulate the call and use its result or raised\n   exception. but we may not cover all the built-ins there are yet.\n\nsometimes the result of a built-in should not be predicted when the\nresult is big. a ``range()`` call e.g. may give too big values to\ninclude the result in the binary. then it is not done.\n\n.. code:: python\n\n   range(100000)  # we do not want this one to be expanded\n\n.. admonition:: status\n\n   this is considered mostly implemented. please file bugs for built-ins\n   that are pre-computed, but should not be computed by nuitka at\n   compile time with specific values.\n\nconditional statement prediction\n================================\n\nfor conditional statements, some branches may not ever be taken, because\nof the condition truth value being possible to predict. in these cases,\nthe branch not taken and the condition check is removed.\n\nthis can typically predict code like this:\n\n.. code:: python\n\n   if __name__ == \"__main__\":\n       # your test code might be here\n       use_something_not_use_by_program()\n\nor\n\n.. code:: python\n\n   if false:\n       # your deactivated code might be here\n       use_something_not_use_by_program()\n\nit will also benefit from constant propagations, or enable them because\nonce some branches have been removed, other things may become more\npredictable, so this can trigger other optimization to become possible.\n\nevery branch removed makes optimization more likely. with some code\nbranches removed, access patterns may be more friendly. imagine e.g.\nthat a function is only called in a removed branch. it may be possible\nto remove it entirely, and that may have other consequences too.\n\n.. admonition:: status\n\n   this is considered implemented, but for the maximum benefit, more\n   constants need to be determined at compile time.\n\nexception propagation\n=====================\n\nfor exceptions that are determined at compile time, there is an\nexpression that will simply do raise the exception. these can be\npropagated upwards, collecting potentially \"side effects\", i.e. parts of\nexpressions that were executed before it occurred, and still have to be\nexecuted.\n\nconsider the following code:\n\n.. code:: python\n\n   print(side_effect_having() + (1 / 0))\n   print(something_else())\n\nthe ``(1 / 0)`` can be predicted to raise a ``zerodivisionerror``\nexception, which will be propagated through the ``+`` operation. that\npart is just constant propagation as normal.\n\nthe call ``side_effect_having()`` will have to be retained though, but\nthe ``print`` does not and can be turned into an explicit raise. the\nstatement sequence can then be aborted and as such the\n``something_else`` call needs no code generation or consideration\nanymore.\n\nto that end, nuitka works with a special node that raises an exception\nand is wrapped with a so-called \"side_effects\" expression, but yet can\nbe used in the code as an expression having a value.\n\n.. admonition:: status\n\n   the propagation of exceptions is mostly implemented but needs\n   handling in every kind of operations, and not all of them might do it\n   already. as work progresses or examples arise, the coverage will be\n   extended. feel free to generate bug reports with non-working\n   examples.\n\nexception scope reduction\n=========================\n\nconsider the following code:\n\n.. code:: python\n\n   try:\n       b = 8\n       print(range(3, b, 0))\n       print(\"will not be executed\")\n   except valueerror as e:\n       print(e)\n\nthe ``try`` block is bigger than it needs to be. the statement ``b = 8``\ncannot cause a ``valueerror`` to be raised. as such it can be moved to\noutside the try without any risk.\n\n.. code:: python\n\n   b = 8\n   try:\n       print(range(3, b, 0))\n       print(\"will not be executed\")\n   except valueerror as e:\n       print(e)\n\n.. admonition:: status\n\n   this is considered done. for every kind of operation, we trace if it\n   may raise an exception. we do however *not* track properly yet, what\n   can do a ``valueerror`` and what cannot.\n\nexception block inlining\n========================\n\nwith the exception propagation, it then becomes possible to transform\nthis code:\n\n.. code:: python\n\n   try:\n       b = 8\n       print(range(3, b, 0))\n       print(\"will not be executed!\")\n   except valueerror as e:\n       print(e)\n\n.. code:: python\n\n   try:\n       raise valueerror(\"range() step argument must not be zero\")\n   except valueerror as e:\n       print(e)\n\nwhich then can be lowered in complexity by avoiding the raise and catch\nof the exception, making it:\n\n.. code:: python\n\n   e = valueerror(\"range() step argument must not be zero\")\n   print(e)\n\n.. admonition:: status\n\n   this is not implemented yet.\n\nempty branch removal\n====================\n\nfor loops and conditional statements that contain only code without\neffect, it should be possible to remove the whole construct:\n\n.. code:: python\n\n   for i in range(1000):\n       pass\n\nthe loop could be removed, at maximum, it should be considered an\nassignment of variable ``i`` to ``999`` and no more.\n\n.. admonition:: status\n\n   this is not implemented yet, as it requires us to track iterators,\n   and their side effects, as well as loop values, and exit conditions.\n   too much yet, but we will get there.\n\nanother example:\n\n.. code:: python\n\n   if side_effect_free:\n       pass\n\nthe condition check should be removed in this case, as its evaluation is\nnot needed. it may be difficult to predict that ``side_effect_free`` has\nno side effects, but many times this might be possible.\n\n.. admonition:: status\n\n   this is considered implemented. the conditional statement nature is\n   removed if both branches are empty, only the condition is evaluated\n   and checked for truth (in cases that could raise an exception).\n\nunpacking prediction\n====================\n\nwhen the length of the right-hand side of an assignment to a sequence\ncan be predicted, the unpacking can be replaced with multiple\nassignments.\n\n.. code:: python\n\n   a, b, c = 1, side_effect_free(), 3\n\n.. code:: python\n\n   a = 1\n   b = side_effect_free()\n   c = 3\n\nthis is of course only really safe if the left-hand side cannot raise an\nexception while building the assignment targets.\n\nwe do this now, but only for constants, because we currently have no\nability to predict if an expression can raise an exception or not.\n\n.. admonition:: status\n\n   this is partially implemented. we are working on unpacking\n   enhancements, that will recognize where index access is available.\n   this faster access will then avoid tuples and iteration, then this\n   will be perfect.\n\nbuilt-in type inference\n=======================\n\nwhen a construct like ``in xrange()`` or ``in range()`` is used, it is\npossible to know what the iteration does and represent that so that\niterator users can use that instead.\n\ni consider that:\n\n.. code:: python\n\n   for i in xrange(1000):\n       something(i)\n\ncould translate ``xrange(1000)`` into an object of a special class that\ndoes the integer looping more efficiently. in case ``i`` is only\nassigned from there, this could be a nice case for a dedicated class.\n\n.. admonition:: status\n\n   future work, not even started.\n\nquicker function calls\n======================\n\nfunctions are structured so that their parameter parsing and ``tp_call``\ninterface is separate from the actual function code. this way the call\ncan be optimized away. one problem is that the evaluation order can\ndiffer.\n\n.. code:: python\n\n   def f(a, b, c):\n       return a, b, c\n\n\n   f(c=get1(), b=get2(), a=get3())\n\nthis will have to evaluate first ``get1()``, then ``get2()`` and only\nthen ``get3()`` and then make the function call with these values.\n\ntherefore it will be necessary to have a staging of the parameters\nbefore making the actual call, to avoid a re-ordering of the calls to\n``get1()``, ``get2()``, and ``get3()``.\n\n.. admonition:: status\n\n   not even started. a re-formulation that avoids the dictionary to call\n   the function, and instead uses temporary variables appears to be\n   relatively straightforward once we do that kind of parameter\n   analysis.\n\nlowering of iterated container types\n====================================\n\nin some cases, accesses to ``list`` constants can become ``tuple``\nconstants instead.\n\nconsider that:\n\n.. code:: python\n\n   for x in [a, b, c]:\n       something(x)\n\ncan be optimized into this:\n\n.. code:: python\n\n   for x in (a, b, c):\n       something(x)\n\nthis allows for simpler, faster code to be generated, and fewer checks\nneeded, because e.g. the ``tuple`` is clearly immutable, whereas the\n``list`` needs a check to assert that. this is also possible for sets.\n\n.. admonition:: status\n\n   implemented, even works for non-constants. needs other optimization\n   to become generally useful, and will itself help other optimization\n   to become possible. this allows us to e.g. only treat iteration over\n   tuples, and not care about sets.\n\nin theory, something similar is also possible for ``dict``. for the\nlater, it will be non-trivial though to maintain the order of execution\nwithout temporary values introduced. the same thing is done for pure\nconstants of these types, they change to ``tuple`` values when iterated.\n\nmetadata calls at compile time\n==============================\n\nnuitka does not include metadata in the distribution. it's rather large,\nand the goal is to use it at compile time. therefore information about\nentry points, version checks, etc. are all done at compile time rather\nthan at run time. not only is that faster, it also recognized problems\nsooner.\n\n.. code:: python\n\n   pkg_resources.require(\"lxml\")\n   importlib.metadata.version(\"lxml\")\n   ...\n\n.. admonition:: status\n\n   this is considered complete. the coverage of the apis is very good,\n   but naturally this will always have to be code that uses compile time\n   values, but that is nearly never an issue, and where it happens, we\n   use \"anti-bloat\" patches to deal with these in 3rd party packages.\n\n*************************\n updates for this manual\n*************************\n\nthis document is written in rest. that is an ascii format which is\nreadable to human, but easily used to generate pdf or html documents.\n\nyou will find the current version at:\nhttps://nuitka.net/doc/user-manual.html\n",
  "docs_url": null,
  "keywords": "compiler,python,nuitka",
  "license": "apache license, version 2.0",
  "name": "nuitka",
  "package_url": "https://pypi.org/project/Nuitka/",
  "project_url": "https://pypi.org/project/Nuitka/",
  "project_urls": {
    "Commercial": "https://nuitka.net/doc/commercial.html",
    "Documentation": "https://nuitka.net/doc/user-manual.html",
    "Donations": "https://nuitka.net/pages/donations.html",
    "Homepage": "https://nuitka.net",
    "Mastodon": "https://fosstodon.org/@kayhayen",
    "Source": "https://github.com/Nuitka/Nuitka",
    "Support": "https://nuitka.net/pages/support.html",
    "Twitter": "https://twitter.com/KayHayen"
  },
  "release_url": "https://pypi.org/project/Nuitka/1.9.5/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python compiler with full language support and cpython compatibility",
  "version": "1.9.5",
  "releases": [],
  "developers": [
    "kay.hayen@gmail.com",
    "kay_hayen"
  ],
  "kwds": "use_nuitka build_with_nuitka nuitka nuitka_cache_dir nuitka_onefile_parent",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_nuitka",
  "homepage": "https://nuitka.net",
  "release_count": 282,
  "dependency_ids": []
}