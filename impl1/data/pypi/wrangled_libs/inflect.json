{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: linguistic"
  ],
  "description": ".. image:: https://img.shields.io/pypi/v/inflect.svg\n   :target: https://pypi.org/project/inflect\n\n.. image:: https://img.shields.io/pypi/pyversions/inflect.svg\n\n.. image:: https://github.com/jaraco/inflect/workflows/tests/badge.svg\n   :target: https://github.com/jaraco/inflect/actions?query=workflow%3a%22tests%22\n   :alt: tests\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/charliermarsh/ruff/main/assets/badge/v2.json\n    :target: https://github.com/astral-sh/ruff\n    :alt: ruff\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/psf/black\n   :alt: code style: black\n\n.. image:: https://readthedocs.org/projects/inflect/badge/?version=latest\n   :target: https://inflect.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://img.shields.io/badge/skeleton-2023-informational\n   :target: https://blog.jaraco.com/skeleton\n\n.. image:: https://tidelift.com/badges/package/pypi/inflect\n   :target: https://tidelift.com/subscription/pkg/pypi-inflect?utm_source=pypi-inflect&utm_medium=readme\n\nname\n====\n\ninflect.py - correctly generate plurals, singular nouns, ordinals, indefinite articles; convert numbers to words.\n\nsynopsis\n========\n\n.. code-block:: python\n\n    import inflect\n\n    p = inflect.engine()\n\n    # methods:\n\n    # plural plural_noun plural_verb plural_adj singular_noun no num\n    # compare compare_nouns compare_nouns compare_adjs\n    # a an\n    # present_participle\n    # ordinal number_to_words\n    # join\n    # inflect classical gender\n    # defnoun defverb defadj defa defan\n\n\n    # unconditionally form the plural\n\n    print(\"the plural of \", word, \" is \", p.plural(word))\n\n\n    # conditionally form the plural\n\n    print(\"i saw\", cat_count, p.plural(\"cat\", cat_count))\n\n\n    # form plurals for specific parts of speech\n\n    print(\n        p.plural_noun(\"i\", n1),\n        p.plural_verb(\"saw\", n1),\n        p.plural_adj(\"my\", n2),\n        p.plural_noun(\"saw\", n2),\n    )\n\n\n    # form the singular of plural nouns\n\n    print(\"the singular of \", word, \" is \", p.singular_noun(word))\n\n    # select the gender of singular pronouns\n\n    print(p.singular_noun(\"they\"))  # 'it'\n    p.gender(\"feminine\")\n    print(p.singular_noun(\"they\"))  # 'she'\n\n\n    # deal with \"0/1/n\" -> \"no/1/n\" translation:\n\n    print(\"there \", p.plural_verb(\"was\", errors), p.no(\" error\", errors))\n\n\n    # use default counts:\n\n    print(\n        p.num(n1, \"\"),\n        p.plural(\"i\"),\n        p.plural_verb(\" saw\"),\n        p.num(n2),\n        p.plural_noun(\" saw\"),\n    )\n    print(\"there \", p.num(errors, \"\"), p.plural_verb(\"was\"), p.no(\" error\"))\n\n\n    # compare two words \"number-insensitively\":\n\n    if p.compare(word1, word2):\n        print(\"same\")\n    if p.compare_nouns(word1, word2):\n        print(\"same noun\")\n    if p.compare_verbs(word1, word2):\n        print(\"same verb\")\n    if p.compare_adjs(word1, word2):\n        print(\"same adj.\")\n\n\n    # add correct \"a\" or \"an\" for a given word:\n\n    print(\"did you want \", p.a(thing), \" or \", p.an(idea))\n\n\n    # convert numerals into ordinals (i.e. 1->1st, 2->2nd, 3->3rd, etc.)\n\n    print(\"it was\", p.ordinal(position), \" from the left\\n\")\n\n    # convert numerals to words (i.e. 1->\"one\", 101->\"one hundred and one\", etc.)\n    # returns a single string...\n\n    words = p.number_to_words(1234)\n    # \"one thousand, two hundred and thirty-four\"\n    words = p.number_to_words(p.ordinal(1234))\n    # \"one thousand, two hundred and thirty-fourth\"\n\n\n    # get back a list of strings, one for each \"chunk\"...\n\n    words = p.number_to_words(1234, wantlist=true)\n    # (\"one thousand\",\"two hundred and thirty-four\")\n\n\n    # optional parameters change translation:\n\n    words = p.number_to_words(12345, group=1)\n    # \"one, two, three, four, five\"\n\n    words = p.number_to_words(12345, group=2)\n    # \"twelve, thirty-four, five\"\n\n    words = p.number_to_words(12345, group=3)\n    # \"one twenty-three, forty-five\"\n\n    words = p.number_to_words(1234, andword=\"\")\n    # \"one thousand, two hundred thirty-four\"\n\n    words = p.number_to_words(1234, andword=\", plus\")\n    # \"one thousand, two hundred, plus thirty-four\"\n    # todo: i get no comma before plus: check perl\n\n    words = p.number_to_words(555_1202, group=1, zero=\"oh\")\n    # \"five, five, five, one, two, oh, two\"\n\n    words = p.number_to_words(555_1202, group=1, one=\"unity\")\n    # \"five, five, five, unity, two, oh, two\"\n\n    words = p.number_to_words(123.456, group=1, decimal=\"mark\")\n    # \"one two three mark four five six\"\n    # todo: docbug: perl gives commas here as do i\n\n    # literal style only names numbers less than a certain threshold...\n\n    words = p.number_to_words(9, threshold=10)  # \"nine\"\n    words = p.number_to_words(10, threshold=10)  # \"ten\"\n    words = p.number_to_words(11, threshold=10)  # \"11\"\n    words = p.number_to_words(1000, threshold=10)  # \"1,000\"\n\n    # join words into a list:\n\n    mylist = p.join((\"apple\", \"banana\", \"carrot\"))\n    # \"apple, banana, and carrot\"\n\n    mylist = p.join((\"apple\", \"banana\"))\n    # \"apple and banana\"\n\n    mylist = p.join((\"apple\", \"banana\", \"carrot\"), final_sep=\"\")\n    # \"apple, banana and carrot\"\n\n\n    # require \"classical\" plurals (eg: \"focus\"->\"foci\", \"cherub\"->\"cherubim\")\n\n    p.classical()  # use all classical plurals\n\n    p.classical(all=true)  # use all classical plurals\n    p.classical(all=false)  # switch off classical mode\n\n    p.classical(zero=true)  #  \"no error\" instead of \"no errors\"\n    p.classical(zero=false)  #  \"no errors\" instead of \"no error\"\n\n    p.classical(herd=true)  #  \"2 buffalo\" instead of \"2 buffalos\"\n    p.classical(herd=false)  #  \"2 buffalos\" instead of \"2 buffalo\"\n\n    p.classical(persons=true)  # \"2 chairpersons\" instead of \"2 chairpeople\"\n    p.classical(persons=false)  # \"2 chairpeople\" instead of \"2 chairpersons\"\n\n    p.classical(ancient=true)  # \"2 formulae\" instead of \"2 formulas\"\n    p.classical(ancient=false)  # \"2 formulas\" instead of \"2 formulae\"\n\n\n    # interpolate \"plural()\", \"plural_noun()\", \"plural_verb()\", \"plural_adj()\", \"singular_noun()\",\n    # a()\", \"an()\", \"num()\" and \"ordinal()\" within strings:\n\n    print(p.inflect(\"the plural of {0} is plural('{0}')\".format(word)))\n    print(p.inflect(\"the singular of {0} is singular_noun('{0}')\".format(word)))\n    print(p.inflect(\"i saw {0} plural('cat',{0})\".format(cat_count)))\n    print(\n        p.inflect(\n            \"plural('i',{0}) \"\n            \"plural_verb('saw',{0}) \"\n            \"plural('a',{1}) \"\n            \"plural_noun('saw',{1})\".format(n1, n2)\n        )\n    )\n    print(\n        p.inflect(\n            \"num({0}, false)plural('i') \"\n            \"plural_verb('saw') \"\n            \"num({1}, false)plural('a') \"\n            \"plural_noun('saw')\".format(n1, n2)\n        )\n    )\n    print(p.inflect(\"i saw num({0}) plural('cat')\\nnum()\".format(cat_count)))\n    print(p.inflect(\"there plural_verb('was',{0}) no('error',{0})\".format(errors)))\n    print(p.inflect(\"there num({0}, false)plural_verb('was') no('error')\".format(errors)))\n    print(p.inflect(\"did you want a('{0}') or an('{1}')\".format(thing, idea)))\n    print(p.inflect(\"it was ordinal('{0}') from the left\".format(position)))\n\n\n    # add user-defined inflections (overriding inbuilt rules):\n\n    p.defnoun(\"vax\", \"vaxen\")  # singular => plural\n\n    p.defverb(\n        \"will\",  # 1st person singular\n        \"shall\",  # 1st person plural\n        \"will\",  # 2nd person singular\n        \"will\",  # 2nd person plural\n        \"will\",  # 3rd person singular\n        \"will\",  # 3rd person plural\n    )\n\n    p.defadj(\"hir\", \"their\")  # singular => plural\n\n    p.defa(\"h\")  # \"ay halways sez 'haitch'!\"\n\n    p.defan(\"horrendous.*\")  # \"an horrendous affectation\"\n\n\ndescription\n===========\n\nthe methods of the class ``engine`` in module ``inflect.py`` provide plural\ninflections, singular noun inflections, \"a\"/\"an\" selection for english words,\nand manipulation of numbers as words.\n\nplural forms of all nouns, most verbs, and some adjectives are\nprovided. where appropriate, \"classical\" variants (for example: \"brother\" ->\n\"brethren\", \"dogma\" -> \"dogmata\", etc.) are also provided.\n\nsingle forms of nouns are also provided. the gender of singular pronouns\ncan be chosen (for example \"they\" -> \"it\" or \"she\" or \"he\" or \"they\").\n\npronunciation-based \"a\"/\"an\" selection is provided for all english\nwords, and most initialisms.\n\nit is also possible to inflect numerals (1,2,3) to ordinals (1st, 2nd, 3rd)\nand to english words (\"one\", \"two\", \"three\").\n\nin generating these inflections, ``inflect.py`` follows the oxford\nenglish dictionary and the guidelines in fowler's modern english\nusage, preferring the former where the two disagree.\n\nthe module is built around standard british spelling, but is designed\nto cope with common american variants as well. slang, jargon, and\nother english dialects are *not* explicitly catered for.\n\nwhere two or more inflected forms exist for a single word (typically a\n\"classical\" form and a \"modern\" form), ``inflect.py`` prefers the\nmore common form (typically the \"modern\" one), unless \"classical\"\nprocessing has been specified\n(see `modern vs classical inflections`).\n\nforming plurals and singulars\n=============================\n\ninflecting plurals and singulars\n--------------------------------\n\nall of the ``plural...`` plural inflection methods take the word to be\ninflected as their first argument and return the corresponding inflection.\nnote that all such methods expect the *singular* form of the word. the\nresults of passing a plural form are undefined (and unlikely to be correct).\nsimilarly, the ``si...`` singular inflection method expects the *plural*\nform of the word.\n\nthe ``plural...`` methods also take an optional second argument,\nwhich indicates the grammatical \"number\" of the word (or of another word\nwith which the word being inflected must agree). if the \"number\" argument is\nsupplied and is not ``1`` (or ``\"one\"`` or ``\"a\"``, or some other adjective that\nimplies the singular), the plural form of the word is returned. if the\n\"number\" argument *does* indicate singularity, the (uninflected) word\nitself is returned. if the number argument is omitted, the plural form\nis returned unconditionally.\n\nthe ``si...`` method takes a second argument in a similar fashion. if it is\nsome form of the number ``1``, or is omitted, the singular form is returned.\notherwise the plural is returned unaltered.\n\n\nthe various methods of ``inflect.engine`` are:\n\n\n\n``plural_noun(word, count=none)``\n\n the method ``plural_noun()`` takes a *singular* english noun or\n pronoun and returns its plural. pronouns in the nominative (\"i\" ->\n \"we\") and accusative (\"me\" -> \"us\") cases are handled, as are\n possessive pronouns (\"mine\" -> \"ours\").\n\n\n``plural_verb(word, count=none)``\n\n the method ``plural_verb()`` takes the *singular* form of a\n conjugated verb (that is, one which is already in the correct \"person\"\n and \"mood\") and returns the corresponding plural conjugation.\n\n\n``plural_adj(word, count=none)``\n\n the method ``plural_adj()`` takes the *singular* form of\n certain types of adjectives and returns the corresponding plural form.\n adjectives that are correctly handled include: \"numerical\" adjectives\n (\"a\" -> \"some\"), demonstrative adjectives (\"this\" -> \"these\", \"that\" ->\n \"those\"), and possessives (\"my\" -> \"our\", \"cat's\" -> \"cats'\", \"child's\"\n -> \"childrens'\", etc.)\n\n\n``plural(word, count=none)``\n\n the method ``plural()`` takes a *singular* english noun,\n pronoun, verb, or adjective and returns its plural form. where a word\n has more than one inflection depending on its part of speech (for\n example, the noun \"thought\" inflects to \"thoughts\", the verb \"thought\"\n to \"thought\"), the (singular) noun sense is preferred to the (singular)\n verb sense.\n\n hence ``plural(\"knife\")`` will return \"knives\" (\"knife\" having been treated\n as a singular noun), whereas ``plural(\"knifes\")`` will return \"knife\"\n (\"knifes\" having been treated as a 3rd person singular verb).\n\n the inherent ambiguity of such cases suggests that,\n where the part of speech is known, ``plural_noun``, ``plural_verb``, and\n ``plural_adj`` should be used in preference to ``plural``.\n\n\n``singular_noun(word, count=none)``\n\n the method ``singular_noun()`` takes a *plural* english noun or\n pronoun and returns its singular. pronouns in the nominative (\"we\" ->\n \"i\") and accusative (\"us\" -> \"me\") cases are handled, as are\n possessive pronouns (\"ours\" -> \"mine\"). when third person\n singular pronouns are returned they take the neuter gender by default\n (\"they\" -> \"it\"), not (\"they\"-> \"she\") nor (\"they\" -> \"he\"). this can be\n changed with ``gender()``.\n\nnote that all these methods ignore any whitespace surrounding the\nword being inflected, but preserve that whitespace when the result is\nreturned. for example, ``plural(\" cat  \")`` returns \" cats  \".\n\n\n``gender(genderletter)``\n\n the third person plural pronoun takes the same form for the female, male and\n neuter (e.g. \"they\"). the singular however, depends upon gender (e.g. \"she\",\n \"he\", \"it\" and \"they\" -- \"they\" being the gender neutral form.) by default\n ``singular_noun`` returns the neuter form, however, the gender can be selected with\n the ``gender`` method. pass the first letter of the gender to\n ``gender`` to return the f(eminine), m(asculine), n(euter) or t(hey)\n form of the singular. e.g.\n gender('f') followed by singular_noun('themselves') returns 'herself'.\n\nnumbered plurals\n----------------\n\nthe ``plural...`` methods return only the inflected word, not the count that\nwas used to inflect it. thus, in order to produce \"i saw 3 ducks\", it\nis necessary to use:\n\n.. code-block:: python\n\n    print(\"i saw\", n, p.plural_noun(animal, n))\n\nsince the usual purpose of producing a plural is to make it agree with\na preceding count, inflect.py provides a method\n(``no(word, count)``) which, given a word and a(n optional) count, returns the\ncount followed by the correctly inflected word. hence the previous\nexample can be rewritten:\n\n.. code-block:: python\n\n    print(\"i saw \", p.no(animal, n))\n\nin addition, if the count is zero (or some other term which implies\nzero, such as ``\"zero\"``, ``\"nil\"``, etc.) the count is replaced by the\nword \"no\". hence, if ``n`` had the value zero, the previous example\nwould print (the somewhat more elegant)::\n\n    i saw no animals\n\nrather than::\n\n    i saw 0 animals\n\nnote that the name of the method is a pun: the method\nreturns either a number (a *no.*) or a ``\"no\"``, in front of the\ninflected word.\n\n\nreducing the number of counts required\n--------------------------------------\n\nin some contexts, the need to supply an explicit count to the various\n``plural...`` methods makes for tiresome repetition. for example:\n\n.. code-block:: python\n\n    print(\n        plural_adj(\"this\", errors),\n        plural_noun(\" error\", errors),\n        plural_verb(\" was\", errors),\n        \" fatal.\",\n    )\n\ninflect.py therefore provides a method\n(``num(count=none, show=none)``) which may be used to set a persistent \"default number\"\nvalue. if such a value is set, it is subsequently used whenever an\noptional second \"number\" argument is omitted. the default value thus set\ncan subsequently be removed by calling ``num()`` with no arguments.\nhence we could rewrite the previous example:\n\n.. code-block:: python\n\n    p.num(errors)\n    print(p.plural_adj(\"this\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\")\n    p.num()\n\nnormally, ``num()`` returns its first argument, so that it may also\nbe \"inlined\" in contexts like:\n\n.. code-block:: python\n\n    print(p.num(errors), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \" detected.\")\n    if severity > 1:\n        print(\n            p.plural_adj(\"this\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\"\n        )\n\nhowever, in certain contexts (see `interpolating inflections in strings`)\nit is preferable that ``num()`` return an empty string. hence ``num()``\nprovides an optional second argument. if that argument is supplied (that is, if\nit is defined) and evaluates to false, ``num`` returns an empty string\ninstead of its first argument. for example:\n\n.. code-block:: python\n\n    print(p.num(errors, 0), p.no(\"error\"), p.plural_verb(\" was\"), \" detected.\")\n    if severity > 1:\n        print(\n            p.plural_adj(\"this\"), p.plural_noun(\" error\"), p.plural_verb(\" was\"), \"fatal.\"\n        )\n\n\n\nnumber-insensitive equality\n---------------------------\n\ninflect.py also provides a solution to the problem\nof comparing words of differing plurality through the methods\n``compare(word1, word2)``, ``compare_nouns(word1, word2)``,\n``compare_verbs(word1, word2)``, and ``compare_adjs(word1, word2)``.\neach  of these methods takes two strings, and  compares them\nusing the corresponding plural-inflection method (``plural()``, ``plural_noun()``,\n``plural_verb()``, and ``plural_adj()`` respectively).\n\nthe comparison returns true if:\n\n- the strings are equal, or\n- one string is equal to a plural form of the other, or\n- the strings are two different plural forms of the one word.\n\n\nhence all of the following return true:\n\n.. code-block:: python\n\n    p.compare(\"index\", \"index\")  # returns \"eq\"\n    p.compare(\"index\", \"indexes\")  # returns \"s:p\"\n    p.compare(\"index\", \"indices\")  # returns \"s:p\"\n    p.compare(\"indexes\", \"index\")  # returns \"p:s\"\n    p.compare(\"indices\", \"index\")  # returns \"p:s\"\n    p.compare(\"indices\", \"indexes\")  # returns \"p:p\"\n    p.compare(\"indexes\", \"indices\")  # returns \"p:p\"\n    p.compare(\"indices\", \"indices\")  # returns \"eq\"\n\nas indicated by the comments in the previous example, the actual value\nreturned by the various ``compare`` methods encodes which of the\nthree equality rules succeeded: \"eq\" is returned if the strings were\nidentical, \"s:p\" if the strings were singular and plural respectively,\n\"p:s\" for plural and singular, and \"p:p\" for two distinct plurals.\ninequality is indicated by returning an empty string.\n\nit should be noted that two distinct singular words which happen to take\nthe same plural form are *not* considered equal, nor are cases where\none (singular) word's plural is the other (plural) word's singular.\nhence all of the following return false:\n\n.. code-block:: python\n\n    p.compare(\"base\", \"basis\")  # although both -> \"bases\"\n    p.compare(\"syrinx\", \"syringe\")  # although both -> \"syringes\"\n    p.compare(\"she\", \"he\")  # although both -> \"they\"\n\n    p.compare(\"opus\", \"operas\")  # although \"opus\" -> \"opera\" -> \"operas\"\n    p.compare(\"taxi\", \"taxes\")  # although \"taxi\" -> \"taxis\" -> \"taxes\"\n\nnote too that, although the comparison is \"number-insensitive\" it is *not*\ncase-insensitive (that is, ``plural(\"time\",\"times\")`` returns false. to obtain\nboth number and case insensitivity, use the ``lower()`` method on both strings\n(that is, ``plural(\"time\".lower(), \"times\".lower())`` returns true).\n\nrelated functionality\n=====================\n\nshout out to these libraries that provide related functionality:\n\n* `wordset <https://jaracotext.readthedocs.io/en/latest/#jaraco.text.wordset>`_\n  parses identifiers like variable names into sets of words suitable for re-assembling\n  in another form.\n\n* `word2number <https://pypi.org/project/word2number/>`_ converts words to\n  a number.\n\n\nfor enterprise\n==============\n\navailable as part of the tidelift subscription.\n\nthis project and the maintainers of thousands of other packages are working with tidelift to deliver one enterprise subscription that covers all of the open source you use.\n\n`learn more <https://tidelift.com/subscription/pkg/pypi-project?utm_source=pypi-project&utm_medium=referral&utm_campaign=github>`_.\n\nsecurity contact\n================\n\nto report a security vulnerability, please use the\n`tidelift security contact <https://tidelift.com/security>`_.\ntidelift will coordinate the fix and disclosure.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "inflect",
  "package_url": "https://pypi.org/project/inflect/",
  "project_url": "https://pypi.org/project/inflect/",
  "project_urls": {
    "Homepage": "https://github.com/jaraco/inflect"
  },
  "release_url": "https://pypi.org/project/inflect/7.0.0/",
  "requires_dist": [
    "pydantic (>=1.9.1)",
    "typing-extensions",
    "sphinx (>=3.5) ; extra == 'docs'",
    "jaraco.packaging (>=9) ; extra == 'docs'",
    "rst.linker (>=1.9) ; extra == 'docs'",
    "furo ; extra == 'docs'",
    "sphinx-lint ; extra == 'docs'",
    "jaraco.tidelift (>=1.4) ; extra == 'docs'",
    "pytest (>=6) ; extra == 'testing'",
    "pytest-checkdocs (>=2.4) ; extra == 'testing'",
    "pytest-cov ; extra == 'testing'",
    "pytest-enabler (>=2.2) ; extra == 'testing'",
    "pytest-ruff ; extra == 'testing'",
    "pygments ; extra == 'testing'",
    "pytest-black (>=0.3.7) ; (platform_python_implementation != \"PyPy\") and extra == 'testing'",
    "pytest-mypy (>=0.9.1) ; (platform_python_implementation != \"PyPy\") and extra == 'testing'"
  ],
  "requires_python": ">=3.8",
  "summary": "correctly generate plurals, singular nouns, ordinals, indefinite articles; convert numbers to words",
  "version": "7.0.0",
  "releases": [],
  "developers": [
    "jaraco@jaraco.com",
    "jason_r",
    "paul_dyson",
    "pwdyson@yahoo.com"
  ],
  "kwds": "badge badges ruff shields image",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_inflect",
  "homepage": "https://github.com/jaraco/inflect",
  "release_count": 49,
  "dependency_ids": [
    "pypi_furo",
    "pypi_jaraco.packaging",
    "pypi_jaraco.tidelift",
    "pypi_pydantic",
    "pypi_pygments",
    "pypi_pytest",
    "pypi_pytest_black",
    "pypi_pytest_checkdocs",
    "pypi_pytest_cov",
    "pypi_pytest_enabler",
    "pypi_pytest_mypy",
    "pypi_pytest_ruff",
    "pypi_rst.linker",
    "pypi_sphinx",
    "pypi_sphinx_lint",
    "pypi_typing_extensions"
  ]
}