{
  "classifiers": [],
  "description": "# bigquery schema generator\n\n[![bigquery schema generator ci](https://github.com/bxparks/bigquery-schema-generator/actions/workflows/pythonpackage.yml/badge.svg)](https://github.com/bxparks/bigquery-schema-generator/actions/workflows/pythonpackage.yml)\n\nthis script generates the bigquery schema from the newline-delimited data\nrecords on the stdin. the records can be in json format or csv format. the\nbigquery data importer (`bq load`) uses only the\n[first 500 records](https://cloud.google.com/bigquery/docs/schema-detect)\nwhen the schema auto-detection feature is enabled. in contrast, this script uses\nall data records to generate the schema.\n\nusage:\n```\n$ generate-schema < file.data.json > file.schema.json\n$ generate-schema --input_format csv < file.data.csv > file.schema.json\n```\n\n**version**: 1.5.1 (2022-12-04)\n\n**changelog**: [changelog.md](changelog.md)\n\n## table of contents\n\n* [background](#background)\n* [installation](#installation)\n    * [ubuntu linux](#ubuntulinux)\n    * [macos](#macos)\n        * [macos 11 (big sur)](#macos11)\n        * [macos 10.14 (mojave)](#macos1014)\n* [usage](#usage)\n    * [command line](#commandline)\n    * [schema output](#schemaoutput)\n    * [command line flag options](#flagoptions)\n        * [help (`--help`)](#help)\n        * [input format (`--input_format`)](#inputformat)\n        * [keep nulls (`--keep_nulls`)](#keepnulls)\n        * [quoted values are strings(`--quoted_values_are_strings`)](#quotedvaluesarestrings)\n        * [infer mode (`--infer_mode`)](#infermode)\n        * [debugging interval (`--debugging_interval`)](#debugginginterval)\n        * [debugging map (`--debugging_map`)](#debuggingmap)\n        * [sanitize names (`--sanitize_names`)](#sanitizednames)\n        * [ignore invalid lines (`--ignore_invalid_lines`)](#ignoreinvalidlines)\n        * [existing schema path (`--existing_schema_path`)](#existingschemapath)\n        * [preserve input sort order\n          (`--preserve_input_sort_order`)](#preserveinputsortorder)\n    * [using as a library](#usingaslibrary)\n        * [`schemagenerator.run()`](#schemageneratorrun)\n        * [`schemagenerator.deduce_schema()` with file](#schemageneratordeduceschemafromfile)\n        * [`schemagenerator.deduce_schema()` with dict](#schemageneratordeduceschemafromdict)\n* [schema types](#schematypes)\n    * [supported types](#supportedtypes)\n    * [type inference](#typeinference)\n* [examples](#examples)\n* [benchmarks](#benchmarks)\n* [system requirements](#systemrequirements)\n* [license](#license)\n* [feedback and support](#feedback)\n* [authors](#authors)\n\n<a name=\"background\"></a>\n## background\n\ndata can be imported into [bigquery](https://cloud.google.com/bigquery/) using\nthe [bq](https://cloud.google.com/bigquery/bq-command-line-tool) command line\ntool. it accepts a number of data formats including csv or newline-delimited\njson. the data can be loaded into an existing table or a new table can be\ncreated during the loading process. the structure of the table is defined by\nits [schema](https://cloud.google.com/bigquery/docs/schemas). the table's\nschema can be defined manually or the schema can be\n[auto-detected](https://cloud.google.com/bigquery/docs/schema-detect#auto-detect).\n\nwhen the auto-detect feature is used, the bigquery data importer examines only\nthe [first 500 records](https://cloud.google.com/bigquery/docs/schema-detect)\nof the input data. in many cases, this is sufficient\nbecause the data records were dumped from another database and the exact schema\nof the source table was known. however, for data extracted from a service\n(e.g. using a rest api) the record fields could have been organically added\nat later dates. in this case, the first 100 records do not contain fields which\nare present in later records. the **bq load** auto-detection fails and the data\nfails to load.\n\nthe **bq load** tool does not support the ability to process the entire dataset\nto determine a more accurate schema. this script fills in that gap. it\nprocesses the entire dataset given in the stdin and outputs the bigquery schema\nin json format on the stdout. this schema file can be fed back into the **bq\nload** tool to create a table that is more compatible with the data fields in\nthe input dataset.\n\n<a name=\"installation\"></a>\n## installation\n\n**prerequisite**: you need have python 3.6 or higher.\n\ninstall from [pypi](https://pypi.python.org/pypi) repository using `pip3`. there\nare too many ways to install packages in python. the following are in order\nhighest to lowest recommendation:\n\n1) if you are using a virtual environment (such as\n[venv](https://docs.python.org/3/library/venv.html)), then use:\n```\n$ pip3 install bigquery_schema_generator\n```\n\n2) if you aren't using a virtual environment you can install into\nyour local python directory:\n\n```\n$ pip3 install --user bigquery_schema_generator\n```\n\n3) if you want to install the package for your entire system globally, use\n```\n$ sudo -h pip3 install bigquery_schema_generator\n```\nbut realize that you will be running code from pypi as `root` so this has\nsecurity implications.\n\nsometimes, your python environment gets into a complete mess and the `pip3`\ncommand won't work. try typing `python3 -m pip` instead.\n\na successful install should print out something like the following (the version\nnumber may be different):\n```\ncollecting bigquery-schema-generator\ninstalling collected packages: bigquery-schema-generator\nsuccessfully installed bigquery-schema-generator-1.1\n```\n\nthe shell script `generate-schema` will be installed somewhere in your system,\ndepending on how your python environment is configured. see below for\nsome notes for ubuntu linux and macos.\n\n<a name=\"ubuntulinux\"></a>\n### ubuntu linux (18.04, 20.04, 22.04)\n\nafter running `pip3 install bigquery_schema_generator`, the `generate-schema`\nscript may be installed in one the following locations:\n\n* `/usr/bin/generate-schema`\n* `/usr/local/bin/generate-schema`\n* `$home/.local/bin/generate-schema`\n* `$home/.virtualenvs/{your_virtual_env}/bin/generate-schema`\n\n<a name=\"macos\"></a>\n### macos\n\ni don't have any macs which are able to run the latest macos, and i don't use\nthem much for software development these days, but here are some notes if they\nhelp.\n\n<a name=\"macos11\"></a>\n#### macos 11 (big sur)\n\ni believe big sur comes preinstalled with python 3.8. if you install\n`bigquery_schema_generator` using:\n\n```\n$ pip3 install --user bigquery_schema_generator\n```\n\nthen the `generate-schema` wrapper script will be installed at:\n\n```\n/user/{your-login}/library/python/3.8/bin/generate-schema\n```\n\n<a name=\"macos1014\"></a>\n#### macos 10.14 (mojave)\n\nthis macos version comes with python 2.7 only. to install python 3, you can\ninstall using:\n\n1)) downloading the [macos installer directly from\n   python.org](https://www.python.org/downloads/macos/).\n\nthe python3 binary will be located at `/usr/local/bin/python3`, and the\n`/usr/local/bin/pip3` is a symlink to\n`/library/frameworks/python.framework/versions/3.6/bin/pip3`.\n\nso running\n\n```\n$ pip3 install --user bigquery_schema_generator\n```\n\nwill install `generate-schema` at\n`/library/frameworks/python.framework/versions/3.6/bin/generate-schema`.\n\nthe python installer updates `$home/.bash_profile` to add\n`/library/frameworks/python.framework/versions/3.6/bin` to the `$path`\nenvironment variable. so you should be able to run the `generate-schema`\ncommand without typing in the full path.\n\n2)) using [homebrew](https://docs.brew.sh/homebrew-and-python).\n\nin this environment, the `generate-schema` script will probably be installed in\n`/usr/local/bin` but i'm not completely certain.\n\n<a name=\"usage\"></a>\n## usage\n\n<a name=\"commandline\"></a>\n### command line\n\nthe `generate_schema.py` script accepts a newline-delimited json or\ncsv data file on the stdin. json input format has been tested extensively.\ncsv input format was added more recently (in v0.4) using the `--input_format\ncsv` flag. the support is not as robust as json file. for example, csv format\nsupports only the comma-separator, and does not support the pipe (`|`) or tab\n(`\\t`) character.\n\nunlike `bq load`, the `generate_schema.py` script reads every record in the\ninput data file to deduce the table's schema. it prints the json formatted\nschema file on the stdout.\n\nthere are at least 3 ways to run this script:\n\n**1) shell script**\n\nif you installed using `pip3`, then it should have installed a small helper\nscript named `generate-schema` in your local `./bin` directory of your current\nenvironment (depending on whether you are using a virtual environment).\n\n```\n$ generate-schema < file.data.json > file.schema.json\n```\n\n**2) python module**\n\nyou can invoke the module directly using:\n```\n$ python3 -m bigquery_schema_generator.generate_schema < file.data.json > file.schema.json\n```\nthis is essentially what the `generate-schema` command does.\n\n**3) python script**\n\nif you retrieved this code from its\n[github repository](https://github.com/bxparks/bigquery-schema-generator),\nthen you can invoke the python script directly:\n```\n$ ./generate_schema.py < file.data.json > file.schema.json\n```\n\n<a name=\"schemaoutput\"></a>\n### using the schema output\n\nthe resulting schema file can be given to the **bq load** command using the\n`--schema` flag:\n```\n\n$ bq load --source_format newline_delimited_json \\\n    --ignore_unknown_values \\\n    --schema file.schema.json \\\n    mydataset.mytable \\\n    file.data.json\n```\nwhere `mydataset.mytable` is the target table in bigquery.\n\nfor debugging purposes, here is the equivalent `bq load` command using schema\nautodetection:\n\n```\n$ bq load --source_format newline_delimited_json \\\n    --autodetect \\\n    mydataset.mytable \\\n    file.data.json\n```\n\nif the input file is in csv format, the first line will be the header line which\nenumerates the names of the columns. but this header line must be skipped when\nimporting the file into the bigquery table. we accomplish this using\n`--skip_leading_rows` flag:\n```\n$ bq load --source_format csv \\\n    --schema file.schema.json \\\n    --skip_leading_rows 1 \\\n    mydataset.mytable \\\n    file.data.csv\n```\n\nhere is the equivalent `bq load` command for csv files using autodetection:\n```\n$ bq load --source_format csv \\\n    --autodetect \\\n    mydataset.mytable \\\n    file.data.csv\n```\n\na useful flag for `bq load`, particularly for json files,  is\n`--ignore_unknown_values`, which causes `bq load` to ignore fields in the input\ndata which are not defined in the schema. when `generate_schema.py` detects an\ninconsistency in the definition of a particular field in the input data, it\nremoves the field from the schema definition. without the\n`--ignore_unknown_values`, the `bq load` fails when the inconsistent data record\nis read.\n\nanother useful flag during development and debugging is `--replace` which\nreplaces any existing bigquery table.\n\nafter the bigquery table is loaded, the schema can be retrieved using:\n\n```\n$ bq show --schema mydataset.mytable | python3 -m json.tool\n```\n\n(the `python -m json.tool` command will pretty-print the json formatted schema\nfile. an alternative is the [jq command](https://stedolan.github.io/jq/).)\nthe resulting schema file should be identical to `file.schema.json`.\n\n<a name=\"flagoptions\"></a>\n### command line flag options\n\nthe `generate_schema.py` script supports a handful of command line flags\nas shown by the `--help` flag below.\n\n<a name=\"help\"></a>\n#### help (`--help`)\n\nprint the built-in help strings:\n\n```bash\n$ generate-schema --help\nusage: generate-schema [-h] [--input_format input_format] [--keep_nulls]\n                       [--quoted_values_are_strings] [--infer_mode]\n                       [--debugging_interval debugging_interval]\n                       [--debugging_map] [--sanitize_names]\n                       [--ignore_invalid_lines]\n                       [--existing_schema_path existing_schema_path]\n                       [--preserve_input_sort_order]\n\ngenerate bigquery schema from json or csv file.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --input_format input_format\n                        specify an alternative input format ('csv', 'json',\n                        'dict')\n  --keep_nulls          print the schema for null values, empty arrays or\n                        empty records\n  --quoted_values_are_strings\n                        quoted values should be interpreted as strings\n  --infer_mode          determine if mode can be 'nullable' or 'required'\n  --debugging_interval debugging_interval\n                        number of lines between heartbeat debugging messages\n  --debugging_map       print the metadata schema_map instead of the schema\n  --sanitize_names      forces schema name to comply with bigquery naming\n                        standard\n  --ignore_invalid_lines\n                        ignore lines that cannot be parsed instead of stopping\n  --existing_schema_path existing_schema_path\n                        file that contains the existing bigquery schema for a\n                        table. this can be fetched with: `bq show --schema\n                        <project_id>:<dataset>:<table_name>\n  --preserve_input_sort_order\n                        preserve the original ordering of columns from input\n                        instead of sorting alphabetically. this only impacts\n                        `input_format` of json or dict\n\n```\n\n<a name=\"inputformat\"></a>\n#### input format (`--input_format`)\n\nspecifies the format of the input file as a string. it must be one of `json`\n(default), `csv`, or `dict`:\n\n* `json`\n    * a \"file-like\" object containing newline-delimited json\n* `csv`\n    * a \"file-like\" object containing newline-delimited csv\n* `dict`\n    * a `list` of python `dict` objects corresponding to list of\n      newline-delimited json, in other words `list[dict[str, any]]`\n    * applies only if `schemagenerator` is used as a library through the\n      `run()` or `deduce_schema()` method\n    * useful if the input data (usually json) has already been read into memory\n      and parsed from newline-delimited json into native python dict objects.\n\nif `csv` file is specified, the `--keep_nulls` flag is automatically activated.\nthis is required because csv columns are defined positionally, so the schema\nfile must contain all the columns specified by the csv file, in the same\norder, even if the column contains an empty value for every record.\n\nsee [issue #26](https://github.com/bxparks/bigquery-schema-generator/issues/26)\nfor implementation details.\n\n<a name=\"keepnulls\"></a>\n#### keep nulls (`--keep_nulls`)\n\nnormally when the input data file contains a field which has a null, empty\narray or empty record as its value, the field is suppressed in the schema file.\nthis flag enables this field to be included in the schema file.\n\nin other words, using a data file containing just nulls and empty values:\n```bash\n$ generate_schema\n{ \"s\": null, \"a\": [], \"m\": {} }\n^d\ninfo:root:processed 1 lines\n[]\n```\n\nwith the `keep_nulls` flag, we get:\n```bash\n$ generate-schema --keep_nulls\n{ \"s\": null, \"a\": [], \"m\": {} }\n^d\ninfo:root:processed 1 lines\n[\n  {\n    \"mode\": \"repeated\",\n    \"type\": \"string\",\n    \"name\": \"a\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"fields\": [\n      {\n        \"mode\": \"nullable\",\n        \"type\": \"string\",\n        \"name\": \"__unknown__\"\n      }\n    ],\n    \"type\": \"record\",\n    \"name\": \"d\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"type\": \"string\",\n    \"name\": \"s\"\n  }\n]\n```\n\n<a name=\"quotedvaluesarestrings\"></a>\n#### quoted values are strings (`--quoted_values_are_strings`)\n\nby default, quoted values are inspected to determine if they can be interpreted\nas `date`, `time`, `timestamp`, `boolean`, `integer` or `float`. this is\nconsistent with the algorithm used by `bq load`. however, for the `boolean`,\n`integer`, or `float` types, it is sometimes more useful to interpret those as\nnormal strings instead. this flag disables type inference for `boolean`,\n`integer` and `float` types inside quoted strings.\n\n```bash\n$ generate-schema\n{ \"name\": \"1\" }\n^d\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"name\",\n    \"type\": \"integer\"\n  }\n]\n\n$ generate-schema --quoted_values_are_strings\n{ \"name\": \"1\" }\n^d\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"name\",\n    \"type\": \"string\"\n  }\n]\n```\n\n<a name=\"infermode\"></a>\n#### infer mode (`--infer_mode`)\n\nset the schema `mode` of a field to `required` instead of the default\n`nullable` if the field contains a non-null or non-empty value for every data\nrecord in the input file. this option is available only for csv\n(`--input_format csv`) files. it is theoretically possible to implement this\nfeature for json files, but too difficult to implement in practice because\nfields are often completely missing from a given json record (instead of\nexplicitly being defined to be `null`).\n\nin addition to the above, this option, when used in conjunction with\n`--existing_schema_map`, will allow fields to be relaxed from required to\nnullable if they were required in the existing schema and null rows are found in\nthe new data we are inferring a schema from. in this case it can be used with\neither input_format, csv or json.\n\nsee [issue #28](https://github.com/bxparks/bigquery-schema-generator/issues/28)\nfor implementation details.\n\n<a name=\"debugginginterval\"></a>\n#### debugging interval (`--debugging_interval`)\n\nby default, the `generate_schema.py` script prints a short progress message\nevery 1000 lines of input data. this interval can be changed using the\n`--debugging_interval` flag.\n\n```bash\n$ generate-schema --debugging_interval 50 < file.data.json > file.schema.json\n```\n\n<a name=\"debuggingmap\"></a>\n#### debugging map (`--debugging_map`)\n\ninstead of printing out the bigquery schema, the `--debugging_map` prints out\nthe bookkeeping metadata map which is used internally to keep track of the\nvarious fields and their types that were inferred using the data file. this\nflag is intended to be used for debugging.\n\n```bash\n$ generate-schema --debugging_map < file.data.json > file.schema.json\n```\n\n<a name=\"sanitizednames\"></a>\n#### sanitize names (`--sanitize_names`)\n\nbigquery column names are [restricted to certain characters and\nlength](https://cloud.google.com/bigquery/docs/schemas#column_names):\n* it must contain only letters (a-z, a-z), numbers (0-9), or underscores\n* it must start with a letter or underscore\n* the maximum length is 128 characters\n* column names are case-insensitive\n\nfor csv files, the `bq load` command seems to automatically convert invalid\ncolumn names into valid column names. this flag attempts to perform some of the\nsame transformations, to avoid having to scan through the input data twice to\ngenerate the schema file. the transformations are:\n\n* any character outside of ascii letters, numbers and underscore\n  (`[a-za-z0-9_]`) are converted to an underscore. for example `go&2#there!` is\n  converted to `go_2_there_`;\n* names longer than 128 characters are truncated to 128.\n\nmy recollection is that the `bq load` command does *not* normalize the json key\nnames. instead it prints an error message. so the `--sanitize_names` flag is\nuseful mostly for csv files. for json files, you'll have to do a second pass\nthrough the data files to cleanup the column names anyway. see\n[issue #14](https://github.com/bxparks/bigquery-schema-generator/issues/14) and\n[issue #33](https://github.com/bxparks/bigquery-schema-generator/issues/33).\n\n<a name=\"ignoreinvalidlines\"></a>\n#### ignore invalid lines (`--ignore_invalid_lines`)\n\nby default, if an error is encountered on a particular line, processing stops\nimmediately with an exception. this flag causes invalid lines to be ignored and\nprocessing continues. a list of all errors and their line numbers will be\nprinted on the stderr after processing the entire file.\n\nthis flag is currently most useful for json files, to ignore lines which do not\nparse correctly as a json object.\n\nthis flag is probably not useful for csv files. csv files are processed by the\n`dictreader` class which performs its own line processing internally, including\nextracting the column names from the first line of the file. if the `dictreader`\ndoes throw an exception on a given line, we would not be able to catch it and\ncontinue processing. fortunately, csv files are fairly robust, and the schema\ndeduction logic will handle any missing or extra columns gracefully.\n\nfixes\n[issue #49](https://github.com/bxparks/bigquery-schema-generator/issues/49).\n\n<a name=\"existingschemapath\"></a>\n#### existing schema path (`--existing_schema_path`)\n\nthere are cases where we would like to start from an existing bigquery table\nschema rather than starting from scratch with a new batch of data we would like\nto load. in this case we can specify the path to a local file on disk that is\nour existing bigquery table schema. this can be generated via the following `bq\nshow --schema` command:\n```bash\nbq show --schema <project_id>:<dataset_name>.<table_name> > existing_table_schema.json\n```\n\nwe can then run generate-schema with the additional option\n```bash\n--existing_schema_path existing_table_schema.json\n```\n\nthere is some subtle interaction between the `--existing_schema_path` and fields\nwhich are marked with a `mode` of `required` in the existing schema. if the new\ndata contains a `null` value (either in a csv or json data file), it is not\nclear if the schema should be changed to `mode=nullable` or whether the new data\nshould be ignored and the schema should remain `mode=required`. the choice is\ndetermined by overloading the `--infer_mode` flag:\n\n* if `--infer_mode` is given, the new schema will be allowed to revert back to\n  `nullable`.\n* if `--infer_mode` is not given, the offending new record will be ignored\n  and the new schema will remain `required`.\n\nsee discussion in\n[pr #57](https://github.com/bxparks/bigquery-schema-generator/pull/57) for\nmore details.\n\n<a name=\"preserveinputsortorder\"></a>\n#### preserve input sort order (`--preserve_input_sort_order`)\n\nby default, the order of columns in the bq schema file is sorted\nlexicographically, which matched the original behavior of `bq load\n--autodetect`. if the `--preserve_input_sort_order` flag is given, the columns\nin the resulting schema file is not sorted, but preserves the order of\nappearance in the input json data. for example, the following json data with\nthe `--preserve_input_sort_order` flag will produce:\n\n```bash\n$ generate-schema --preserve_input_sort_order\n{ \"s\": \"string\", \"i\": 3, \"x\": 3.2, \"b\": true }\n^d\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"s\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"i\",\n    \"type\": \"integer\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"x\",\n    \"type\": \"float\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"b\",\n    \"type\": \"boolean\"\n  }\n]\n```\n\nit is possible that each json record line contains only a partial subset of the\ntotal possible columns in the data set. the order of the columns in the bq\nschema will then be the order that each column was first *seen* by the\nscript:\n\n```bash\n$ generate-schema --preserve_input_sort_order\n{ \"s\": \"string\", \"i\": 3 }\n{ \"x\": 3.2, \"s\": \"string\", \"i\": 3 }\n{ \"b\": true, \"x\": 3.2, \"s\": \"string\", \"i\": 3 }\n^d\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"s\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"i\",\n    \"type\": \"integer\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"x\",\n    \"type\": \"float\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"b\",\n    \"type\": \"boolean\"\n  }\n]\n```\n\n**note**: in python 3.6 (the earliest version of python supported by this\nproject), the order of keys in a `dict` was the insertion-order, but this\nordering was an implementation detail, and not guaranteed. in python 3.7, that\nordering was made permanent. so the `--preserve_input_sort_order` flag\n**should** work in python 3.6 but is not guaranteed.\n\nsee discussion in\n[pr #75](https://github.com/bxparks/bigquery-schema-generator/pull/75) for\nmore details.\n\n<a name=\"usingaslibrary\"></a>\n### using as a library\n\nthe `schemagenerator` class can be used programmatically as a library from a\nlarger python application.\n\n<a name=\"schemageneratorrun\"></a>\n#### `schemagenerator.run()`\n\nthe `bigquery_schema_generator` module can be used as a library by an external\npython client code by creating an instance of `schemagenerator` and calling the\n`run(input, output)` method:\n\n```python\nfrom bigquery_schema_generator.generate_schema import schemagenerator\n\ngenerator = schemagenerator(\n    input_format=input_format,\n    infer_mode=infer_mode,\n    keep_nulls=keep_nulls,\n    quoted_values_are_strings=quoted_values_are_strings,\n    debugging_interval=debugging_interval,\n    debugging_map=debugging_map,\n    sanitize_names=sanitize_names,\n    ignore_invalid_lines=ignore_invalid_lines,\n    preserve_input_sort_order=preserve_input_sort_order,\n)\n\nfilename = \"...\"\n\nwith open(filename) as input_file:\n    generator.run(input_file=input_file, output_file=output_file)\n```\n\nthe `input_format` is one of `json`, `csv`, and `dict` as described in the\n[input format](#inputformat) section above. the `input_file` must match the\nformat given by this parameter.\n\nsee [generatorrun.py](examples/generatorrun.py) for an example.\n\n<a name=\"schemageneratordeduceschemafromfile\"></a>\n#### `schemagenerator.deduce_schema()` from file\n\nif you need to process the generated schema programmatically, use the\n`deduce_schema()` method and process the resulting `schema_map` and `error_log`\ndata structures like this:\n\n```python\nimport json\nimport logging\nimport sys\nfrom bigquery_schema_generator.generate_schema import schemagenerator\n\nfilename = \"jsonfile.json\"\n\ngenerator = schemagenerator(\n    input_format='json',\n    quoted_values_are_strings=true,\n)\n\nwith open(filename) as file:\n    schema_map, errors = generator.deduce_schema(file)\n\nschema_map, error_logs = generator.deduce_schema(input_data=input_data)\n\nfor error in error_logs:\n    logging.info(\"problem on line %s: %s\", error['line_number'], error['msg'])\n\nschema = generator.flatten_schema(schema_map)\njson.dump(schema, sys.stdout, indent=2)\nprint()\n```\n\nsee [csvreader.py](examples/csvreader.py) and\n[jsoneader.py](examples/jsoneader.py) for 2 examples.\n\nthe `deduce_schema()` also supports starting from an existing `schema_map`\ninstead of starting from scratch. this is the internal version of the\n`--existing_schema_path` functionality.\n\n```python\nschema_map1, error_logs = generator.deduce_schema(input_data=data1)\nschema_map2, error_logs = generator.deduce_schema(\n    input_data=data1, schema_map=schema_map1\n)\n```\n\nthe `input_data` must match the `input_format` given in the constructor. the\nformat is described in the [input format](#inputformat) section above.\n\n<a name=\"schemageneratordeduceschemafromdict\"></a>\n#### `schemagenerator.deduce_schema()` from dict\n\nif the json data set has already been read into memory into a python `dict`\nobject, the `schemagenerator` can process that too like this:\n\n```python\nimport json\nimport logging\nimport sys\nfrom bigquery_schema_generator.generate_schema import schemagenerator\n\ngenerator = schemagenerator(input_format='dict')\ninput_data = [\n    {\n        's': 'string',\n        'b': true,\n    },\n    {\n        'd': '2021-08-18',\n        'x': 3.1\n    },\n]\nschema_map, error_logs = generator.deduce_schema(input_data)\nschema = generator.flatten_schema(schema_map)\njson.dump(schema, sys.stdout, indent=2)\nprint()\n```\n\nsee [dictreader.py](examples/dictreader.py) for an example.\n\n<a name=\"schematypes\"></a>\n## schema types\n\n<a name=\"supportedtypes\"></a>\n### supported types\n\nthe `bq show --schema` command produces a json schema file that uses the\nolder [legacy sql date types](https://cloud.google.com/bigquery/data-types).\nfor compatibility, **generate-schema** script will also generate a schema file\nusing the legacy data types.\n\nthe supported types are:\n\n* `boolean`\n* `integer`\n* `float`\n* `string`\n* `timestamp`\n* `date`\n* `time`\n* `record`\n\nthe `generate-schema` script supports both `nullable` and `repeated` modes of\nall of the above types.\n\nthe supported format of `timestamp` is as close as practical to the\n[bq load format](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#timestamp-type):\n```\nyyyy-[m]m-[d]d[( |t)[h]h:[m]m:[s]s[.dddddd]][time zone]\n```\nwhich appears to be an extension of the\n[iso 8601 format](https://en.wikipedia.org/wiki/iso_8601).\nthe difference from `bq load` is that the `[time zone]` component can be only\n* `z`\n* `utc` (same as `z`)\n* `(+|-)h[h][:m[m]]`\n\nnote that bigquery supports up to 6 decimal places after the integer 'second'\ncomponent. `generate-schema` follows the same restriction for compatibility. if\nyour input file contains more than 6 decimal places, you need to write a data\ncleansing filter to fix this.\n\nthe suffix `utc` is not standard iso 8601 nor\n[documented by google](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#time-zones)\nbut the `utc` suffix is used by `bq extract` and the web interface. (see\n[issue 19](https://github.com/bxparks/bigquery-schema-generator/issues/19).)\n\ntimezone names from the [tz database](http://www.iana.org/time-zones) (e.g.\n\"america/los_angeles\") are _not_ supported by `generate-schema`.\n\nthe following types are _not_ supported at all:\n\n* `bytes`\n* `datetime` (unable to distinguish from `timestamp`)\n\n<a name=\"typeinference\"></a>\n### type inference rules\n\nthe `generate-schema` script attempts to emulate the various type conversion and\ncompatibility rules implemented by **bq load**:\n\n* `integer` can upgrade to `float`\n    * if a field in an early record is an `integer`, but a subsequent record\n      shows this field to have a `float` value, the type of the field will be\n      upgraded to a `float`\n    * the reverse does not happen, once a field is a `float`, it will remain a\n      `float`\n* conflicting `time`, `date`, `timestamp` types upgrades to `string`\n    * if a field is determined to have one type of \"time\" in one record, then\n      subsequently a different \"time\" type, then the field will be assigned a\n      `string` type\n* `nullable record` can upgrade to a `repeated record`\n    * a field may be defined as `record` (aka \"struct\") type with `{ ... }`\n    * if the field is subsequently read as an array with a `[{ ... }]`, the\n      field is upgraded to a `repeated record`\n* a primitive type (`float`, `integer`, `string`) cannot upgrade to a `repeated`\n  primitive type\n    * there's no technical reason why this cannot be allowed, but **bq load**\n      does not support it, so we follow its behavior\n* a `datetime` field is always inferred to be a `timestamp`\n    * the format of these two fields is identical (in the absence of timezone)\n    * we follow the same logic as **bq load** and always infer these as\n      `timestamp`\n* `boolean`, `integer`, and `float` can appear inside quoted strings\n    * in other words, `\"true\"` (or `\"true\"` or `\"false\"`, etc) is considered a\n      boolean type, `\"1\"` is considered an integer type, and `\"2.1\"` is\n      considered a float type. luigi mori (jtschichold@) added additional logic\n      to replicate the type conversion logic used by `bq load` for these\n      strings.\n    * this type inference inside quoted strings can be disabled using the\n      `--quoted_values_are_strings` flag\n    * (see [issue #22](https://github.com/bxparks/bigquery-schema-generator/issues/22) for more details.)\n* `integer` values overflowing a 64-bit signed integer upgrade to `float`\n    * integers greater than `2^63-1` (9223372036854775807)\n    * integers less than `-2^63` (-9223372036854775808)\n    * (see [issue #18](https://github.com/bxparks/bigquery-schema-generator/issues/18) for more details)\n\n<a name=\"examples\"></a>\n## examples\n\nhere is an example of a single json data record on the stdin (the `^d` below\nmeans typing control-d, which indicates \"end of file\" under linux and macos):\n\n```bash\n$ generate-schema\n{ \"s\": \"string\", \"b\": true, \"i\": 1, \"x\": 3.1, \"t\": \"2017-05-22t17:10:00-07:00\" }\n^d\ninfo:root:processed 1 lines\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"b\",\n    \"type\": \"boolean\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"i\",\n    \"type\": \"integer\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"s\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"t\",\n    \"type\": \"timestamp\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"x\",\n    \"type\": \"float\"\n  }\n]\n```\n\nin most cases, the data file will be stored in a file:\n```bash\n$ cat > file.data.json\n{ \"a\": [1, 2] }\n{ \"i\": 3 }\n^d\n\n$ generate-schema < file.data.json > file.schema.json\ninfo:root:processed 2 lines\n\n$ cat file.schema.json\n[\n  {\n    \"mode\": \"repeated\",\n    \"name\": \"a\",\n    \"type\": \"integer\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"i\",\n    \"type\": \"integer\"\n  }\n]\n```\n\nhere is the schema generated from a csv input file. the first line is the header\ncontaining the names of the columns, and the schema lists the columns in the\nsame order as the header:\n```bash\n$ generate-schema --input_format csv\ne,b,c,d,a\n1,x,true,,2.0\n2,x,,,4\n3,,,,\n^d\ninfo:root:processed 3 lines\n[\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"e\",\n    \"type\": \"integer\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"b\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"c\",\n    \"type\": \"boolean\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"d\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"a\",\n    \"type\": \"float\"\n  }\n]\n```\n\nhere is an example of the schema generated with the `--infer_mode` flag:\n```bash\n$ generate-schema --input_format csv --infer_mode\nname,surname,age\njohn\nmichael,,\nmaria,smith,30\njoanna,anders,21\n^d\ninfo:root:processed 4 lines\n[\n  {\n    \"mode\": \"required\",\n    \"name\": \"name\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"surname\",\n    \"type\": \"string\"\n  },\n  {\n    \"mode\": \"nullable\",\n    \"name\": \"age\",\n    \"type\": \"integer\"\n  }\n]\n```\n\n<a name=\"benchmarks\"></a>\n## benchmarks\n\ni wrote the `bigquery_schema_generator/anonymize.py` script to create an\nanonymized data file `tests/testdata/anon1.data.json.gz`:\n```bash\n$ ./bigquery_schema_generator/anonymize.py < original.data.json \\\n    > anon1.data.json\n$ gzip anon1.data.json\n```\nthis data file is 290mb (5.6mb compressed) with 103080 data records.\n\ngenerating the schema using\n```bash\n$ bigquery_schema_generator/generate_schema.py < anon1.data.json \\\n    > anon1.schema.json\n```\ntook 67s on a dell precision m4700 laptop with an intel core i7-3840qm cpu @\n2.80ghz, 32gb of ram, ubuntu linux 18.04, python 3.6.7.\n\n<a name=\"systemrequirements\"></a>\n## system requirements\n\nthis project was initially developed on ubuntu 17.04 using python 3.5.3, but it\nnow requires python 3.6 or higher, i think mostly due to the use of f-strings.\n\ni have tested it on:\n\n* ubuntu 22.04, python 3.10.6\n* ubuntu 20.04, python 3.8.5\n* ubuntu 18.04, python 3.7.7\n* ubuntu 18.04, python 3.6.7\n* ubuntu 17.10, python 3.6.3\n* macos 11.7.1 (big sur), python 3.8.9\n* macos 10.14.2 (mojave), python 3.6.4\n* macos 10.13.2 (high sierra), python 3.6.4\n\nthe github actions continuous integration pipeline validates on python 3.6, 3.7\nand 3.8.\n\nthe unit tests are invoked with `$ make tests` target, and depends only on the\nbuilt-in python `unittest` package.\n\nthe coding style check is invoked using `$ make flake8` and depends on the\n`flake8` package. it can be installed using `$ pip3 install --user flake8`.\n\n<a name=\"license\"></a>\n## license\n\napache license 2.0\n\n<a name=\"feedback\"></a>\n## feedback and support\n\nif you have any questions, comments, or feature requests for this library,\nplease use the [github\ndiscussions](https://github.com/bxparks/bigquery-schema-generator/discussions)\nfor this project. if you have bug reports, please file a ticket in [github\nissues](https://github.com/bxparks/bigquery-schema-generator/issues). feature\nrequests should go into discussions first because they often have alternative\nsolutions which are useful to remain visible, instead of disappearing from the\ndefault view of the issue tracker after the ticket is closed.\n\nplease refrain from emailing me directly unless the content is sensitive. the\nproblem with email is that i cannot reference the email conversation when other\npeople ask similar questions later.\n\n<a name=\"authors\"></a>\n## authors\n\n* created by brian t. park (brian@xparks.net).\n* type inference inside quoted strings by luigi mori (jtschichold@).\n* flag to disable type inference inside quoted strings by daniel ecer\n  (de-code@).\n* support for csv files and detection of `required` fields by sandor korotkevics\n  (korotkevics@).\n* better support for using `bigquery_schema_generator` as a library from an\n  external python code by stefanog_ita (stefanogita@).\n* sanitizing of column names to valid bigquery characters and length by jon\n  warghed (jonwarghed@).\n* bug fix in `--sanitize_names` by riccardo m. cefala (riccardomc@).\n* print full path of nested json elements in error messages, by austin brogle\n  (abroglesc@).\n* allow an existing schema file to be specified using `--existing_schema_path`,\n  by austin brogle (abroglesc@) and bozo dragojevic (bozzzzo@).\n* allow `schemagenerator.deduce_schema()` to accept a list of native python\n  `dict` objects, by zigfrid zvezdin (ziggerzz@).\n* make the column order in the bq schema file match the order of appearance in\n  the json data file using the `--preserve_input_sort_order` flag. by kevin\n  deggelman (kdeggelman@).\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "bigquery-schema-generator",
  "package_url": "https://pypi.org/project/bigquery-schema-generator/",
  "project_url": "https://pypi.org/project/bigquery-schema-generator/",
  "project_urls": {
    "Homepage": "https://github.com/bxparks/bigquery-schema-generator"
  },
  "release_url": "https://pypi.org/project/bigquery-schema-generator/1.5.1/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "bigquery schema generator from json or csv data",
  "version": "1.5.1",
  "releases": [],
  "developers": [
    "brian@xparks.net",
    "brian_t"
  ],
  "kwds": "bigquery_schema_generator bigquery schemaoutput generate_schema schemageneratorrun",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_bigquery_schema_generator",
  "homepage": "https://github.com/bxparks/bigquery-schema-generator",
  "release_count": 23,
  "dependency_ids": []
}