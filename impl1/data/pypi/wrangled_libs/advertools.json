{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: end users/desktop",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": ".. image:: https://img.shields.io/pypi/v/advertools.svg\n        :target: https://pypi.python.org/pypi/advertools\n\n.. image:: https://readthedocs.org/projects/advertools/badge/?version=latest\n        :target: https://advertools.readthedocs.io/en/latest/?badge=latest\n        :alt: documentation status\n\n.. image:: http://pepy.tech/badge/advertools\n        :target: http://pepy.tech/project/advertools \n\n**announcing** `data science with python for seo course <https://bit.ly/dsseo-course>`_: cohort based course, interactive, live-coding.\n\n\n``advertools``: productivity & analysis tools to scale your online marketing\n============================================================================\n\n| a digital marketer is a data scientist.\n| your job is to manage, manipulate, visualize, communicate, understand,\n  and make decisions based on data.\n\nyou might be doing basic stuff, like copying and pasting text on spread\nsheets, you might be running large scale automated platforms with\nsophisticated algorithms, or somewhere in between. in any case your job\nis all about working with data.\n\nas a data scientist you don't spend most of your time producing cool\nvisualizations or finding great insights. the majority of your time is spent\nwrangling with urls, figuring out how to stitch together two tables, hoping\nthat the dates, won't break, without you knowing, or trying to generate the\nnext 124,538 keywords for an upcoming campaign, by the end of the week!\n\n``advertools`` is a python package that can hopefully make that part of your job a little easier.\n\ninstallation\n------------\n\n.. code:: bash\n\n   python3 -m pip install advertools\n\n\nsem campaigns\n-------------\nthe most important thing to achieve in sem is a proper mapping between the\nthree main elements of a search campaign\n\n**keywords** (the intention) -> **ads** (your promise) -> **landing pages** (your delivery of the promise)\nonce you have this done, you can focus on management and analysis. more importantly,\nonce you know that you can set this up in an easy way, you know you can focus\non more strategic issues. in practical terms you need two main tables to get started:\n\n* keywords: you can `generate keywords <https://advertools.readthedocs.io/en/master/advertools.kw_generate.html>`_ (note i didn't say research)  with the\n  `kw_generate` function.\n\n* ads: there are two approaches that you can use:\n\n  * bottom-up: you can create text ads for a large number of products by simple\n    replacement of product names, and providing a placeholder in case your text\n    is too long. check out the `ad_create <https://advertools.readthedocs.io/en/master/advertools.ad_create.html>`_ function for more details.\n  * top-down: sometimes you have a long description text that you want to split\n    into headlines, descriptions and whatever slots you want to split them into.\n    `ad_from_string <https://advertools.readthedocs.io/en/master/advertools.ad_from_string.html>`_\n    helps you accomplish that.\n\n* tutorials and additional resources\n\n  * get started with `data science for digital marketing and seo/sem <https://www.oncrawl.com/technical-seo/data-science-seo-digital-marketing-guide-beginners/>`_\n  * `setting a full sem campaign <https://www.datacamp.com/community/tutorials/sem-data-science>`_ for datacamp's website tutorial\n  * project to practice `generating sem keywords with python <https://www.datacamp.com/projects/400>`_ on datacamp\n  * `setting up sem campaigns on a large scale <https://www.semrush.com/blog/setting-up-search-engine-marketing-campaigns-on-large-scale/>`_ tutorial on semrush\n  * visual `tool to generate keywords <https://www.dashboardom.com/advertools>`_ online based on the `kw_generate` function\n\n\nseo\n---\nprobably the most comprehensive online marketing area that is both technical\n(crawling, indexing, rendering, redirects, etc.) and non-technical (content\ncreation, link building, outreach, etc.). here are some tools that can help\nwith your seo\n\n* `seo crawler: <https://advertools.readthedocs.io/en/master/advertools.spider.html>`_\n  a generic seo crawler that can be customized, built with scrapy, & with several\n  features:\n\n  * standard seo elements extracted by default (title, header tags, body text,\n    status code, reponse and request headers, etc.)\n  * css and xpath selectors: you probably have more specific needs in mind, so\n    you can easily pass any selectors to be extracted in addition to the\n    standard elements being extracted\n  * custom settings: full access to scrapy's settings, allowing you to better\n    control the crawling behavior (set custom headers, user agent, stop spider\n    after x pages, seconds, megabytes, save crawl logs, run jobs at intervals\n    where you can stop and resume your crawls, which is ideal for large crawls\n    or for continuous monitoring, and many more options)\n  * following links: option to only crawl a set of specified pages or to follow\n    and discover all pages through links\n\n* `robots.txt downloader <https://advertools.readthedocs.io/en/master/advertools.sitemaps.html#advertools.sitemaps.robotstxt_to_df>`_\n  a simple downloader of robots.txt files in a dataframe format, so you can\n  keep track of changes across crawls if any, and check the rules, sitemaps,\n  etc.\n* `xml sitemaps downloader / parser <https://advertools.readthedocs.io/en/master/advertools.sitemaps.html>`_\n  an essential part of any seo analysis is to check xml sitemaps. this is a\n  simple function with which you can download one or more sitemaps (by\n  providing the url for a robots.txt file, a sitemap file, or a sitemap index\n* `serp importer and parser for google & youtube <https://advertools.readthedocs.io/en/master/advertools.serp.html>`_\n  connect to google's api and get the search data you want. multiple search\n  parameters supported, all in one function call, and all results returned in a\n  dataframe\n\n* tutorials and additional resources\n\n  * a visual tool built with the ``serp_goog`` function to get `serp rankings on google <https://www.dashboardom.com/google-serp>`_\n  * a tutorial on `analyzing serps on a large scale with python <https://www.semrush.com/blog/analyzing-search-engine-results-pages/>`_ on semrush\n  * `serp datasets on kaggle <https://www.kaggle.com/eliasdabbas/datasets?search=engine>`_ for practicing on different industries and use cases\n  * `serp notebooks on kaggle <https://www.kaggle.com/eliasdabbas/notebooks?sortby=votecount&group=everyone&pagesize=20&userid=484496&tagids=1220>`_\n    some examples on how you might tackle such data\n  * `content analysis with xml sitemaps and python <https://www.semrush.com/blog/content-analysis-xml-sitemaps-python/>`_\n  * xml dataset examples: `news sites <https://www.kaggle.com/eliasdabbas/news-sitemaps>`_, `turkish news sites <https://www.kaggle.com/eliasdabbas/turk-haber-sitelerinin-site-haritalari>`_,\n    `bloomberg news <https://www.kaggle.com/eliasdabbas/bloomberg-business-articles-urls>`_\n\n\ntext & content analysis (for seo & social media)\n------------------------------------------------\n\nurls, page titles, tweets, video descriptions, comments, hashtags are some\nexmaples of the types of text we deal with. ``advertools`` provides a few\noptions for text analysis\n\n\n* `word frequency <https://advertools.readthedocs.io/en/master/advertools.word_frequency.html>`_\n  counting words in a text list is one of the most basic and important tasks in\n  text mining. what is also important is counting those words by taking in\n  consideration their relative weights in the dataset. ``word_frequency`` does\n  just that.\n* `url analysis <https://advertools.readthedocs.io/en/master/advertools.urlytics.html>`_\n  we all have to handle many thousands of urls in reports, crawls, social media\n  extracts, xml sitemaps and so on. ``url_to_df`` converts your urls into\n  easily readable dataframes.\n\n* `emoji <https://advertools.readthedocs.io/en/master/advertools.emoji.html>`_\n  produced with one click, extremely expressive, highly diverse (3k+ emoji),\n  and very popular, it's important to capture what people are trying to communicate\n  with emoji. extracting emoji, get their names, groups, and sub-groups is\n  possible. the full emoji database is also available for convenience, as well\n  as an ``emoji_search`` function in case you want some ideas for your next\n  social media or any kind of communication\n* `extract_ functions <https://advertools.readthedocs.io/en/master/advertools.extract.html>`_\n  the text that we deal with contains many elements and entities that have\n  their own special meaning and usage. there is a group of convenience\n  functions to help in extracting and getting basic statistics about structured\n  entities in text; emoji, hashtags, mentions, currency, numbers, urls, questions\n  and more. you can also provide a special regex for your own needs.\n* `stopwords <https://advertools.readthedocs.io/en/master/advertools.stopwords.html>`_\n  a list of stopwords in forty different languages to help in text analysis.\n* tutorial on datacamp for creating the ``word_frequency`` function and\n  explaining the importance of the difference between `absolute and weighted word frequency <https://www.datacamp.com/community/tutorials/absolute-weighted-word-frequency>`_\n* `text analysis for online marketers <https://www.semrush.com/blog/text-analysis-for-online-marketers/>`_\n  an introductory article on semrush\n\nsocial media\n------------\n\nin addition to the text analysis techniques provided, you can also connect to\nthe twitter and youtube data apis. the main benefits of using ``advertools``\nfor this:\n\n* handles pagination and request limits: typically every api has a limited\n  number of results that it returns. you have to handle pagination when you\n  need more than the limit per request, which you typically do. this is handled\n  by default\n* dataframe results: apis send you back data in a formats that need to be\n  parsed and cleaned so you can more easily start your analysis. this is also\n  handled automatically\n* multiple requests: in youtube's case you might want to request data for the\n  same query across several countries, languages, channels, etc. you can\n  specify them all in one request and get the product of all the requests in\n  one response\n\n* tutorials and additional resources\n\n* a visual tool to `check what is trending on twitter <https://www.dashboardom.com/trending-twitter>`_ for all available locations\n* a `twitter data analysis dashboard <https://www.dashboardom.com/twitterdash>`_ with many options\n* how to use the `twitter data api with python <https://www.kaggle.com/eliasdabbas/twitter-in-a-dataframe>`_\n* `extracting entities from social media posts <https://www.kaggle.com/eliasdabbas/extract-entities-from-social-media-posts>`_ tutorial on kaggle\n* `analyzing 131k tweets <https://www.kaggle.com/eliasdabbas/extract-entities-from-social-media-posts>`_ by european football clubs tutorial on kaggle\n* an overview of the `youtube data api with python <https://www.kaggle.com/eliasdabbas/youtube-data-api>`_\n\n\nconventions\n-----------\n\nfunction names mostly start with the object you are working on, so you can use\nautocomplete to discover other options:\n\n| ``kw_``: for keywords-related functions\n| ``ad_``: for ad-related functions\n| ``url_``: url tracking and generation\n| ``extract_``: for extracting entities from social media posts (mentions, hashtags, emoji, etc.)\n| ``emoji_``: emoji related functions and objects\n| ``twitter``: a module for querying the twitter api and getting results in a dataframe\n| ``youtube``: a module for querying the youtube data api and getting results in a dataframe\n| ``serp_``: get search engine results pages in a dataframe, currently available: google and youtube\n| ``crawl``: a function you will probably use a lot if you do seo\n| ``*_to_df``: a set of convenience functions for converting to dataframes\n  (log files, xml sitemaps, robots.txt files, and lists of urls)\n\n\n=======================\nchange log - advertools\n=======================\n\n\n0.13.5 (2023-08-22)\n-------------------\n\n* added\n    - initial experimental functionality for ``crawl_images``.\n\n* changed\n    - enable autothrottling by default for ``crawl_headers``.\n\n0.13.4 (2023-07-26)\n-------------------\n\n* fixed\n  -  make img attributes consistent in length, and support all attributes.\n\n0.13.3 (2023-06-27)\n-------------------\n\n* changed\n    - allow optional trailing space in log files (contributed by @andypayne)\n\n* fixed\n    - replace newlines with spaces while parsing json-ld which was causing \n      errors in some cases.\n\n\n0.13.2 (2022-09-30)\n-------------------\n\n* added\n    - crawling recipe for how to use the ``default_request_headers`` to change\n      the default headers.\n\n* changed\n    - split long lists of url while crawling regardless of the ``follow_links``\n      parameter\n\n* fixed\n    - clarify that while authenticating for twitter only ``app_key`` and \n      ``app_secret`` are required, with the option to provide ``oauth_token``\n      and ``oauth_token_secret`` if/when needed.\n\n\n0.13.1 (2022-05-11)\n-------------------\n\n* added\n    - command line interface with most functions\n    - make documentation interactive for most pages using ``thebe-sphinx``\n\n* changed\n    - use `np.nan` wherever there are missing values in ``url_to_df``\n\n* fixed\n    - don't remove double quotes from etags when downloading xml sitemaps\n    - replace instances of ``pd.dataframe.append`` with ``pd.concat``, which is\n      depracated.\n    - replace empty values with np.nan for the size column in ``logs_to_df``\n\n\n0.13.0 (2022-02-10)\n-------------------\n\n* added\n    - new function ``crawl_headers``: a crawler that only makes `head` requests\n      to a known list of urls.\n    - new function ``reverse_dns_lookup``: a way to get host information for a\n      large list of ip addresses concurrently.\n    - new options for crawling: `exclude_url_params`, `include_url_params`,\n      `exclude_url_regex`, and `include_url_regex` for controlling which links to\n      follow while crawling.\n\n* fixed\n    - any ``custom_settings`` options given to the ``crawl`` function that were\n      defined using a dictionary can now be set without issues. there was an\n      issue if those options were not strings.\n\n* changed\n    - the `skip_url_params` option was removed and replaced with the more\n      versatile ``exclude_url_params``, which accepts either ``true`` or a list\n      of url parameters to exclude while following links.\n\n0.12.3 (2021-11-27)\n-------------------\n\n* fixed\n    - crawler stops when provided with bad urls in list mode.\n\n0.12.0,1,2 (2021-11-27)\n-----------------------\n\n* added\n    - new function ``logs_to_df``: convert a log file of any non-json format\n      into a pandas dataframe and save it to a `parquet` file. this also\n      compresses the file to a much smaller size.\n    - crawler extracts all available ``img`` attributes: 'alt', 'crossorigin',\n      'height', 'ismap', 'loading', 'longdesc', 'referrerpolicy', 'sizes',\n      'src', 'srcset', 'usemap',  and 'width' (excluding global html attributes\n      like ``style`` and ``draggable``).\n    - new parameter for the ``crawl`` function ``skip_url_params``: defaults to\n      false, consistent with previous behavior, with the ability to not\n      follow/crawl links containing any url parameters.\n    - new column for ``url_to_df`` \"last_dir\": extract the value in the last\n      directory for each of the urls.\n\n* changed\n    - query parameter columns in ``url_to_df`` dataframe are now sorted by how\n      full the columns are (the percentage of values that are not `na`)\n\n0.11.1 (2021-04-09)\n-------------------\n\n* added\n    - the `nofollow` attribute for nav, header, and footer links.\n\n* fixed\n    - timeout error while downloading robots.txt files.\n    - make extracting nav, header, and footer links consistent with all links.\n\n0.11.0 (2021-03-31)\n-------------------\n\n* added\n    - new parameter `recursive` for ``sitemap_to_df`` to control whether or not\n      to get all sub sitemaps (default), or to only get the current\n      (sitemapindex) one.\n    - new columns for ``sitemap_to_df``: ``sitemap_size_mb``\n      (1 mb = 1,024x1,024 bytes), and ``sitemap_last_modified`` and ``etag``\n      (if available).\n    - option to request multiple robots.txt files with ``robotstxt_to_df``.\n    - option to save downloaded robots dataframe(s) to a file with\n      ``robotstxt_to_df`` using the new parameter ``output_file``.\n    - two new columns for ``robotstxt_to_df``: ``robotstxt_last_modified`` and\n      ``etag`` (if available).\n    - raise `valueerror` in ``crawl`` if ``css_selectors`` or\n      ``xpath_selectors`` contain any of the default crawl column headers\n    - new xpath code recipes for custom extraction.\n    - new function ``crawllogs_to_df`` which converts crawl logs to a dataframe\n      provided they were saved while using the ``crawl`` function.\n    - new columns in ``crawl``: `viewport`, `charset`, all `h` headings\n      (whichever is available), nav, header and footer links and text, if\n      available.\n    - crawl errors don't stop crawling anymore, and the error message is\n      included in the output file under a new `errors` and/or `jsonld_errors`\n      column(s).\n    - in case of having json-ld errors, errors are reported in their respective\n      column, and the remainder of the page is scraped.\n\n* changed\n    - removed column prefix `resp_meta_` from columns containing it\n    - redirect urls and reasons are separated by '@@' for consistency with\n      other multiple-value columns\n    - links extracted while crawling are not unique any more (all links are\n      extracted).\n    - emoji data updated with v13.1.\n    - heading tags are scraped even if they are empty, e.g. <h2></h2>.\n    - default user agent for crawling is now advertools/version.\n\n* fixed\n    - handle sitemap index files that contain links to themselves, with an\n      error message included in the final dataframe\n    - error in robots.txt files caused by comments preceded by whitespace\n    - zipped robots.txt files causing a parsing issue\n    - crawl issues on some linux systems when providing a long list of urls\n\n* removed\n    - columns from the ``crawl`` output: `url_redirected_to`, `links_fragment`\n\n\n0.10.7 (2020-09-18)\n-------------------\n\n* added\n    - new function ``knowledge_graph`` for querying google's api\n    - faster ``sitemap_to_df`` with threads\n    - new parameter `max_workers` for ``sitemap_to_df`` to determine how fast\n      it could go\n    - new parameter `capitalize_adgroups` for ``kw_generate`` to determine\n      whether or not to keep ad groups as is, or set them to title case (the\n      default)\n\n* fixed\n    - remove restrictions on the number of urls provided to ``crawl``,\n      assuming `follow_links` is set to `false` (list mode)\n    - json-ld issue breaking crawls when it's invalid (now skipped)\n\n* removed\n    - deprecate the ``youtube.guide_categories_list`` (no longer supported by\n      the api)\n\n0.10.6 (2020-06-30)\n-------------------\n\n* added\n    - json-ld support in crawling. if available on a page, json-ld items will\n      have special columns, and multiple json-ld snippets will be numbered for\n      easy filtering\n* changed\n    - stricter parsing for rel attributes, making sure they are in link\n      elements as well\n    - date column names for ``robotstxt_to_df`` and ``sitemap_to_df`` unified\n      as \"download_date\"\n    - numbering og, twitter, and json-ld where multiple elements are present in\n      the same page, follows a unified approach: no numbering for the first\n      element, and numbers start with \"1\" from the second element on. \"element\",\n      \"element_1\", \"element_2\" etc.\n\n0.10.5 (2020-06-14)\n-------------------\n\n* added\n    - new features for the ``crawl`` function:\n        * extract canonical tags if available\n        * extract alternate `href` and `hreflang` tags if available\n        * open graph data \"og:title\", \"og:type\", \"og:image\", etc.\n        * twitter cards data \"twitter:site\", \"twitter:title\", etc.\n\n* fixed\n    - minor fixes to ``robotstxt_to_df``:\n        * allow whitespace in fields\n        * allow case-insensitive fields\n\n* changed\n    - ``crawl`` now only supports `output_file` with the extension \".jl\"\n    - ``word_frequency`` drops `wtd_freq` and `rel_value` columns if `num_list`\n      is not provided\n\n0.10.4 (2020-06-07)\n-------------------\n\n* added\n    - new function ``url_to_df``, splitting urls into their components and to a\n      dataframe\n    - slight speed up for ``robotstxt_test``\n\n0.10.3 (2020-06-03)\n-------------------\n\n* added\n    - new function ``robotstxt_test``, testing urls and whether they can be\n      fetched by certain user-agents\n\n* changed\n    - documentation main page relayout, grouping of topics, & sidebar captions\n    - various documentation clarifications and new tests\n\n0.10.2 (2020-05-25)\n-------------------\n\n* added\n    - user-agent info to requests getting sitemaps and robotstxt files\n    - css/xpath selectors support for the crawl function\n    - support for custom spider settings with a new parameter ``custom_settings``\n\n* fixed\n    - update changed supported search operators and values for cse\n\n0.10.1 (2020-05-23)\n-------------------\n\n* changed\n    - links are better handled, and new output columns are available:\n      ``links_url``, ``links_text``, ``links_fragment``, ``links_nofollow``\n    - ``body_text`` extraction is improved by containing <p>, <li>, and <span>\n      elements\n\n0.10.0 (2020-05-21)\n-------------------\n\n* added\n    - new function ``crawl`` for crawling and parsing websites\n    - new function ``robotstxt_to_df`` downloading robots.txt files into\n      dataframes\n\n0.9.1 (2020-05-19)\n------------------\n\n* added\n    - ability to specify robots.txt file for ``sitemap_to_df``\n    - ability to retreive any kind of sitemap (news, video, or images)\n    - errors column to the returnd dataframe if any errors occur\n    - a new ``sitemap_downloaded`` column showing datetime of getting the\n      sitemap\n\n* fixed\n    - logging issue causing ``sitemap_to_df`` to log the same action twice\n    - issue preventing urls not ending with xml or gz from being retreived\n    - correct sitemap url showing in the ``sitemap`` column\n\n0.9.0 (2020-04-03)\n------------------\n\n* added\n    - new function ``sitemap_to_df`` imports an xml sitemap into a\n      ``dataframe``\n\n0.8.1 (2020-02-08)\n------------------\n\n* changed\n    - column `query_time` is now named `querytime` in the `youtube` functions\n    - handle json_normalize import from pandas based on pandas version\n\n0.8.0 (2020-02-02)\n------------------\n\n* added\n    - new module `youtube` connecting to all get requests in api\n    - `extract_numbers` new function\n    - `emoji_search` new function\n    - `emoji_df` new variable containing all emoji as a dataframe\n\n* changed\n    - emoji database updated to v13.0\n    - `serp_goog` with expanded `pagemap` and metadata\n\n* fixed\n    - `serp_goog` errors, some parameters not appearing in result\n      df\n    - `extract_numbers` issue when providing dash as a separator\n      in the middle\n\n0.7.3 (2019-04-17)\n------------------\n\n* added\n    - new function `extract_exclamations` very similar to\n      `extract_questions`\n    - new function `extract_urls`, also counts top domains and\n      top tlds\n    - new keys to `extract_emoji`; `top_emoji_categories`\n      & `top_emoji_sub_categories`\n    - groups and sub-groups to `emoji db`\n\n0.7.2 (2019-03-29)\n------------------\n\n* changed\n    - emoji regex updated\n    - simpler extraction of spanish `questions`\n\n0.7.1 (2019-03-26)\n------------------\n\n* fixed\n    - missing __init__ imports.\n\n\n0.7.0 (2019-03-26)\n------------------\n\n* added\n    - new `extract_` functions:\n\n      * generic `extract` used by all others, and takes\n        arbitrary regex to extract text.\n      * `extract_questions` to get question mark statistics, as\n        well as the text of questions asked.\n      * `extract_currency` shows text that has currency symbols in it, as\n        well as surrounding text.\n      * `extract_intense_words` gets statistics about, and extract words with\n        any character repeated three or more times, indicating an intense\n        feeling (+ve or -ve).\n\n    - new function `word_tokenize`:\n\n      * used by `word_frequency` to get tokens of\n        1,2,3-word phrases (or more).\n      * split a list of text into tokens of a specified number of words each.\n\n    - new stop-words from the ``spacy`` package:\n\n      **current:** arabic, azerbaijani, danish, dutch, english, finnish,\n      french, german, greek, hungarian, italian, kazakh, nepali, norwegian,\n      portuguese, romanian, russian, spanish, swedish, turkish.\n\n      **new:** bengali, catalan, chinese, croatian, hebrew, hindi, indonesian,\n      irish, japanese, persian, polish, sinhala, tagalog, tamil, tatar, telugu,\n      thai, ukrainian, urdu, vietnamese\n\n* changed\n    - `word_frequency` takes new parameters:\n        * `regex` defaults to words, but can be changed to anything '\\s+'\n          to split words and keep punctuation for example.\n\n        * `sep` not longer used as an option, the above `regex` can\n          be used instead\n\n        * `num_list` now optional, and defaults to counts of 1 each if not\n          provided. useful for counting `abs_freq` only if data not\n          available.\n\n        * `phrase_len` the number of words in each split token. defaults\n          to 1 and can be set to 2 or higher. this helps in analyzing phrases\n          as opposed to words.\n\n    - parameters supplied to `serp_goog` appear at the beginning\n      of the result df\n    - `serp_youtube` now contains `nextpagetoken` to make\n      paginating requests easier\n\n0.6.0 (2019-02-11)\n------------------\n\n* new function\n    - `extract_words` to extract an arbitrary set of words\n* minor updates\n    - `ad_from_string` slots argument reflects new text\n      ad lenghts\n    - `hashtag` regex improved\n\n0.5.3 (2019-01-31)\n------------------\n\n* fix minor bugs\n    - handle twitter search queries with 0 results in final request\n\n0.5.2 (2018-12-01)\n------------------\n\n* fix minor bugs\n    - properly handle requests for >50 items (`serp_youtube`)\n    - rewrite test for _dict_product\n    - fix issue with string printing error msg\n\n0.5.1 (2018-11-06)\n------------------\n\n* fix minor bugs\n    - _dict_product implemented with lists\n    - missing keys in some youtube responses\n\n0.5.0 (2018-11-04)\n------------------\n\n* new function `serp_youtube`\n    - query youtube api for videos, channels, or playlists\n    - multiple queries (product of parameters) in one function call\n    - reponse looping and merging handled, one dataframe \n* `serp_goog` return google's original error messages\n* twitter responses with entities, get the entities extracted, each in a\n  separate column\n\n\n0.4.1 (2018-10-13)\n------------------\n\n* new function `serp_goog` (based on google cse)\n    - query google search and get the result in a dataframe\n    - make multiple queries / requests in one function call\n    - all responses merged in one dataframe\n* twitter.get_place_trends results are ranked by town and country\n\n0.4.0 (2018-10-08)\n------------------\n\n* new twitter module based on twython\n    - wraps 20+ functions for getting twitter api data\n    - gets data in a pands dataframe\n    - handles looping over requests higher than the defaults\n* tested on python 3.7\n\n0.3.0 (2018-08-14)\n------------------\n\n* search engine marketing cheat sheet.\n* new set of extract\\_ functions with summary stats for each:\n    * extract_hashtags\n    * extract_mentions\n    * extract_emoji\n* tests and bug fixes\n\n0.2.0 (2018-07-06)\n------------------\n\n* new set of kw_<match-type> functions.\n* full testing and coverage. \n\n0.1.0 (2018-07-02)\n------------------\n\n* first release on pypi.\n* functions available:\n    - ad_create: create a text ad place words in placeholders\n    - ad_from_string: split a long string to shorter string that fit into\n        given slots\n    - kw_generate: generate keywords from lists of products and words\n    - url_utm_ga: generate a utm-tagged url for google analytics tracking\n    - word_frequency: measure the absolute and weighted frequency of words in\n        collection of documents\n\n\n",
  "docs_url": null,
  "keywords": "advertising marketing search-engine-optimization adwords seo sem bingads keyword-research",
  "license": "mit license",
  "name": "advertools",
  "package_url": "https://pypi.org/project/advertools/",
  "project_url": "https://pypi.org/project/advertools/",
  "project_urls": {
    "Homepage": "https://github.com/eliasdabbas/advertools"
  },
  "release_url": "https://pypi.org/project/advertools/0.13.5/",
  "requires_dist": [
    "pandas (>=1.1.0)",
    "pyasn1 (>=0.4)",
    "scrapy (>=2.5.0)",
    "twython (>=3.8.0)",
    "pyarrow (>=5.0.0)"
  ],
  "requires_python": "",
  "summary": "productivity and analysis tools for online marketing",
  "version": "0.13.5",
  "releases": [],
  "developers": [
    "elias_dabbas",
    "eliasdabbas@gmail.com"
  ],
  "kwds": "adwords advertools advertising seo ads",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_advertools",
  "homepage": "https://github.com/eliasdabbas/advertools",
  "release_count": 54,
  "dependency_ids": [
    "pypi_pandas",
    "pypi_pyarrow",
    "pypi_pyasn1",
    "pypi_scrapy",
    "pypi_twython"
  ]
}