{
  "classifiers": [
    "intended audience :: developers",
    "intended audience :: information technology",
    "intended audience :: system administrators",
    "license :: osi approved :: gnu general public license v2 (gplv2)",
    "operating system :: os independent",
    "programming language :: python",
    "topic :: internet",
    "topic :: security",
    "topic :: software development :: libraries"
  ],
  "description": "iocextract\n==========\n\n![developed by inquest](https://inquest.net/images/inquest-badge.svg)\n![build status](https://github.com/inquest/iocextract/workflows/iocextract-build/badge.svg)\n[![documentation status](https://readthedocs.org/projects/iocextract/badge/?version=latest)](https://inquest.readthedocs.io/projects/iocextract/en/latest/?badge=latest)\n![pypi version](https://img.shields.io/pypi/v/iocextract.svg)\n\n[**indicator of compromise**](https://en.wikipedia.org/wiki/indicator_of_compromise) (ioc) extractor for some of the most commonly ingested artifacts.\n\ntable of contents\n=================\n\n* [overview](#overview)\n    * [the problem](#the-problem)\n    * [our solution](#our-solution)\n    * [example use case](#example-use-case)\n* [installation](#installation)\n* [usage](#usage)\n    * [library](#library)\n    * [command line interface](#command-line-interface)\n* [helpful information](#helpful-information)\n    * [faq](#faq)\n    * [more details](#more-details)\n    * [custom regex](#custom-regex)\n    * [related projects](#related-projects)\n    * [contributing](#contributing)\n\noverview\n========\n\nthe `iocextract` package is a library and command line interface (cli) for extracting urls, ip addresses, md5/sha hashes, email addresses, and yara rules from text corpora. it allows for you to extract encoded and \"defanged\" iocs and optionally decode or refang them.\n\nthe problem\n-----------\n\nit is common practice for malware analysts or endpoint software to \"defang\" iocs such as urls and ip addresses, in order to prevent accidental exposure to live malicious content. being able to extract and aggregate these iocs is often valuable for analysts. unfortunately, existing \"ioc extraction\" tools often pass right by them, as they are not caught by standard regex.\n\nfor example, the simple defanging technique of surrounding periods with brackets:\n```\n127[.]0[.]0[.]1\n```\n\nexisting tools that use a simple ip address regex will ignore this ioc entirely.\n\nour solution\n------------\n\nby combining specially crafted regex with some custom post-processing, we are able to both detect and deobfuscate \"defanged\" iocs. this saves time and effort for the analyst, who might otherwise have to manually find and convert iocs into machine-readable format.\n\nexample use case\n-----------------\n\nmany twitter users post c2s or other valuable ioc information with defanged urls.\nfor example, [this tweet from @inquest](https://twitter.com/inquest/status/969469856931287041):\n\n```\nrecommended reading and great work from @unit42_intel:\nhttps://researchcenter.paloaltonetworks.com/2018/02/unit42-sofacy-attacks-multiple-government-entities/ ...\ninquest customers have had detection for threats delivered from hotfixmsupload[.]com\nsince 6/3/2017 and cdnverify[.]net since 2/1/18.\n```\n\nif we run this through the extractor, we can easily pull out the urls:\n\n```\nhttps://researchcenter.paloaltonetworks.com/2018/02/unit42-sofacy-attacks-multiple-government-entities/\nhotfixmsupload[.]com\ncdnverify[.]net\n```\n\npassing in `refang=true` at extraction time would remove the obfuscation, but since these are real iocs, let's leave them defanged in our documentation.\n\ninstallation\n============\n\nyou may need to install the python development headers in order to install the `regex` dependency. on ubuntu/debian-based systems, try:\n\n```bash\nsudo apt-get install python-dev\n```\n\nthen install `iocextract` from pip:\n\n```bash\npip install iocextract\n```\n\nif you have problems installing on windows, try installing `regex` directly by downloading the [appropriate wheel from pypi](https://pypi.org/project/regex/#files) and installing via `pip`:\n\n```bash\npip install regex-2018.06.21-cp27-none-win_amd64.whl\n```\n\nusage\n=====\n\nlibrary\n-------\n\ntry extracting some defanged urls:\n\n```python\nimport iocextract\n\ncontent = \\\n\"\"\"\ni really love example[.]com!\nall the bots are on hxxp://example.com/bad/url these days.\nc2: tcp://example[.]com:8989/bad\n\"\"\"\n\nfor url in iocextract.extract_urls(content):\n    print(url)\n\n    # output\n\n    # hxxp://example.com/bad/url\n    # tcp://example[.]com:8989/bad\n    # example[.]com\n    # tcp://example[.]com:8989/bad\n```\n\nnote: some urls may show up twice if they are caught by multiple regexes.\n\nif you want, you can also \"refang\", or remove common obfuscation methods from iocs:\n\n```python\nimport iocextract\n\nfor url in iocextract.extract_urls(content, refang=true):\n    print(url)\n\n    # output\n\n    # http://example.com/bad/url\n    # http://example.com:8989/bad\n    # http://example.com\n    # http://example.com:8989/bad\n```\n\nif you don't want to defang the extracted iocs at all during extraction, you can disable this as well:\n\n```python\nimport iocextract\n\ncontent = \\\n\"\"\"\nhttp://example.com/bad/url\nhttp://example.com:8989/bad\nhttp://example.com\nhttp://example.com:8989/bad\n\"\"\"\n\nfor url in iocextract.extract_urls(content, defang=false):\n    print(url)\n\n    # output\n\n    # http://example.com/bad/url\n    # http://example.com:8989/bad\n    # http://example.com\n    # http://example.com:8989/bad\n```\n\nall `extract_*` functions in this library return iterators, not lists. the benefit of this behavior is that `iocextract` can process extremely large inputs, with a very low overhead. however, if for some reason you need to iterate over the iocs more than once, you will have to save the results as a list:\n\n```python\nimport iocextract\n\ncontent = \\\n\"\"\"\ni really love example[.]com!\nall the bots are on hxxp://example.com/bad/url these days.\nc2: tcp://example[.]com:8989/bad\n\"\"\"\n\nprint(list(iocextract.extract_urls(content)))\n# ['hxxp://example.com/bad/url', 'tcp://example[.]com:8989/bad', 'example[.]com', 'tcp://example[.]com:8989/bad']\n```\n\ncommand line interface\n----------------------\n\na command-line tool is also included:\n\n```bash\n$ iocextract -h\n    usage: iocextract [-h] [--input input] [--output output] [--extract-emails]\n                  [--extract-ips] [--extract-ipv4s] [--extract-ipv6s]\n                  [--extract-urls] [--extract-yara-rules] [--extract-hashes]\n                  [--custom-regex regex_file] [--refang] [--strip-urls]\n                  [--wide]\n\n    advanced indicator of compromise (ioc) extractor. if no arguments are\n    specified, the default behavior is to extract all iocs.\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      --input input         default: stdin\n      --output output       default: stdout\n      --extract-emails\n      --extract-ips\n      --extract-ipv4s\n      --extract-ipv6s\n      --extract-urls\n      --extract-yara-rules\n      --extract-hashes\n      --custom-regex regex_file file with custom regex strings, one per line, with one capture group each\n      --refang              default: no\n      --strip-urls          remove possible garbage from the end of urls. default: no\n      --wide                preprocess input to allow wide-encoded character matches. default: no\n```\n\nnote: only urls, emails, and ipv4 addresses can be \"refanged\".\n\nhelpful information\n===================\n\nfaq\n---\n\nare you...\n\n> q. extracting possibly-defanged iocs from plain text, like the contents of tweets or blog posts?\n>> a. yes! this is exactly what iocextract was designed for, and where it performs best. want to go a step farther and automate extraction and storage? check out [threatingestor](https://github.com/inquest/threatingestor).\n\n> q. extracting urls that have been hex or base64 encoded?\n>> a. yes, but the cli might not give you the best results. try writing a python script and calling `iocextract.extract_encoded_urls` directly.\n\nnote: you will most likely end up with extra garbage at the end of urls.\n\n> q. extracting iocs that have not been defanged, from html/xml/rtf?\n>> a. maybe, but you should consider using the `--strip-urls` cli flag (or the `strip=true` parameter in the library), and you may still get some extra garbage in your output. if you're extracting from html, consider using something like [beautiful soup](https://www.crummy.com/software/beautifulsoup/) to first isolate the text content, and then pass that to iocextract, [like this](https://gist.github.com/rshipp/d399491305c5d293357a800d5a51b0aa).\n\n> q. extracting iocs that have not been defanged, from binary data like executables, or very large inputs?\n>> a. there is a very simplistic version of this available when running as a library, but it requires the `defang=false` parameter and could potentially miss some of the iocs. the regex in iocextract is designed to be flexible to catch defanged iocs. if you're unable to collect the information you need, consider using something like [cacador](https://github.com/sroberts/cacador) instead.\n\nmore details\n------------\n\nthis library currently supports the following iocs:\n\n* ip addresses\n    * ipv4 fully supported\n    * ipv6 partially supported\n* urls\n    * with protocol specifier: http, https, tcp, udp, ftp, sftp, ftps\n    * with `[.]` anchor, even with no protocol specifier\n    * ipv4 and ipv6 (rfc2732) urls are supported\n    * hex-encoded urls with protocol specifier: http, https, ftp\n    * url-encoded urls with protocol specifier: http, https, ftp, ftps, sftp\n    * base64-encoded urls with protocol specifier: http, https, ftp\n* emails\n    * partially supported, anchoring on `@` or `at`\n* yara rules\n    * with imports, includes, and comments\n* hashes\n    * md5\n    * sha1\n    * sha256\n    * sha512\n* telephone numbers\n* custom regex\n    * with exactly one capture group\n\nfor ipv4 addresses, the following defang techniques are supported:\n\n| technique       | defanged      | refanged  |\n|-----------------|---------------|-----------|\n| `.` -> `[.]`    | 1[.]1[.]1[.]1 | 1.1.1.1   |\n| `.` -> `(.)`    | 1(.)1(.)1(.)1 | 1.1.1.1   |\n| `.` -> `\\.`     | 1\\\\.1\\\\.1\\\\.1  | 1.1.1.1  |\n| partial         | 1[.1[.1.]1    | 1.1.1.1   |\n| any combination | 1\\.)1[.1.)1   | 1.1.1.1   |\n\nfor email addresses, the following defang techniques are supported:\n\n| technique       | defanged           | refanged       |\n|-----------------|--------------------|----------------|\n| `.` -> `[.]`    | me@example[.]com   | me@example.com |\n| `.` -> `(.)`    | me@example(.)com   | me@example.com |\n| `.` -> `{.}`    | me@example{.}com   | me@example.com |\n| `.` -> `_dot_`  | me@example dot com | me@example.com |\n| `@` -> `[@]`    | me[@]example.com   | me@example.com |\n| `@` -> `(@)`    | me(@)example.com   | me@example.com |\n| `@` -> `{@}`    | me{@}example.com   | me@example.com |\n| `@` -> `_at_`   | me at example.com  | me@example.com |\n| partial         | me@} example[.com  | me@example.com |\n| added spaces    | me@example [.] com | me@example.com |\n| any combination | me @example [.)com | me@example.com |\n\nfor urls, the following defang techniques are supported:\n\n| technique       | defanged                                           | refanged                  |\n|-----------------|----------------------------------------------------|---------------------------|\n| `.` -> `[.]`    | `example[.]com/path`                               | `http://example.com/path` |\n| `.` -> `(.)`    | `example(.)com/path`                               | `http://example.com/path` |\n| `.` -> `\\.`     | `example\\.com/path`                                | `http://example.com/path` |\n| partial         | `http://example[.com/path`                         | `http://example.com/path` |\n| `/` -> `[/]`    | `http://example.com[/]path`                        | `http://example.com/path` |\n| [cisco esa](https://www.cisco.com/c/en/us/support/docs/security/email-security-appliance/118775-technote-esa-00.html)   | `http:// example .com /path`                       | `http://example.com/path` |\n| `://` -> `__`   | `http__example.com/path`                           | `http://example.com/path` |\n| `://` -> `:\\\\`  | `http:\\\\example.com/path`                          | `http://example.com/path` |\n| `:` -> `[:]`    | `http[:]//example.com/path`                        | `http://example.com/path` |\n| `hxxp`          | `hxxp://example.com/path`                          | `http://example.com/path` |\n| any combination | `hxxp__ example( .com[/]path`                      | `http://example.com/path` |\n| hex encoded     | `687474703a2f2f6578616d706c652e636f6d2f70617468`   | `http://example.com/path` |\n| url encoded     | `http%3a%2f%2fexample%2ecom%2fpath`                | `http://example.com/path` |\n| base64 encoded  | `ahr0cdovl2v4yw1wbguuy29tl3bhdggk`                 | `http://example.com/path` |\n\nnote: the tables above are not exhaustive, and other url/defang patterns may also be extracted correctly. if you notice something missing or not working correctly, feel free to let us know via the [github issues](https://github.com/inquest/iocextract/issues).\n\nthe base64 regex was generated with [@deadpixi](https://github.com/deadpixi)'s [base64 regex tool](https://www.erlang-factory.com/upload/presentations/225/erlangfactorysfbay2010-robking.pdf).\n\ncustom regex\n------------\n\nif you'd like to use the cli to extract iocs using your own custom regex, create a plain text file with one regex string per line, and pass it in with the `--custom-regex` flag. be sure each regex string includes exactly one [capture group](https://www.regular-expressions.info/brackets.html).\n\nfor example:\n\n```\nhttp://(example\\.com)/\n(?:https|ftp)://(example\\.com)/\n```\n\nthis custom regex file will extrac the domain `example.com` from matching urls. the `(?: )` noncapture group won't be included in matches.\n\nif you would like to extract the entire match, just put parentheses around your entire regex string, like this:\n\n```\n(https?://.*?.com)\n```\n\nif your regex is invalid, you'll see an error message like this:\n\n```\nerror in custom regex: missing ) at position 5\n```\n\nif your regex does not include a capture group, you'll see an error message like this:\n\n```\nerror in custom regex: no such group\n```\n\nalways use a single capture group when working with custom regex. here's a quick example:\n\n```python\n[\n    r'(my regex)',  # this yields 'my regex' if the pattern matches\n    r'my (re)gex',  # this yields 're' if the pattern matches\n]\n```\n\nusing more than a single capture group can cause unexpected results. check out this example:\n\n```python\n[\n    r'my regex',  # this doesn't yield anything\n    r'(my) (re)gex',  # this yields 'my' if the pattern matches\n]\n```\n\nwhy? because the result will always yield only the first *group* match from each regex.\n\nfor more complicated regex queries, you can combine capture and non-capture groups like so:\n\n```python\n[\n    r'(?:my|your) (re)gex',  # this yields 're' if the pattern matches\n]\n```\n\nyou can now compare the `(?: )` syntax for noncapture groups vs the `( )` syntax for the capture group.\n\n\nrelated projects\n----------------\n\nif iocextract doesn't fit your use case, several similar projects exist. check out the [defang](https://github.com/topics/defang)  and [indicators-of-compromise](https://github.com/topics/indicators-of-compromise) tags on github, as well as:\n\n* [cacador](https://github.com/sroberts/cacador) in go\n* [ioc-extractor](https://github.com/ninoseki/ioc-extractor) in javascript\n* [cyobstract](https://github.com/cmu-sei/cyobstract) in python\n\nif you'd like to automate ioc extraction, enrichment, export, and more, check out [threatingestor](https://github.com/inquest/threatingestor).\n\nif you're working with yara rules, you may be interested in [plyara](https://github.com/plyara/plyara).\n\ncontributing\n------------\n\nif you have a defang technique that doesn't make it through the extractor, or if you find any bugs, pull requests and issues are always welcome. the library is released under a gpl-2.0 [license](https://github.com/inquest/iocextract/blob/master/license).\n\nwho's using iocextract?\n-----------------------\n\n- [inquest](https://inquest.net)\n- [packettotal](https://www.packettotal.com)\n\nare you using it? want to see your site listed here? let us know!\n",
  "docs_url": null,
  "keywords": "",
  "license": "gpl",
  "name": "iocextract",
  "package_url": "https://pypi.org/project/iocextract/",
  "project_url": "https://pypi.org/project/iocextract/",
  "project_urls": {
    "Homepage": "https://github.com/InQuest/iocextract"
  },
  "release_url": "https://pypi.org/project/iocextract/1.16.1/",
  "requires_dist": [
    "regex",
    "ipaddress ; python_version <= \"2.7\""
  ],
  "requires_python": "",
  "summary": "advanced indicator of compromise (ioc) extractor.",
  "version": "1.16.1",
  "releases": [],
  "developers": [
    "inquest_labs",
    "labs@inquest.net"
  ],
  "kwds": "iocextract iocs ioc badge extracted",
  "license_kwds": "gpl",
  "libtype": "pypi",
  "id": "pypi_iocextract",
  "homepage": "https://github.com/inquest/iocextract",
  "release_count": 30,
  "dependency_ids": [
    "pypi_ipaddress",
    "pypi_regex"
  ]
}