{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: jython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing"
  ],
  "description": "pyhamcrest\n==========\n\n| |docs| |status| |version| |downloads|\n\n.. |docs| image:: https://readthedocs.org/projects/pyhamcrest/badge/?version=latest\n    :target: https://pyhamcrest.readthedocs.io/en/latest/?badge=latest\n    :alt: documentation status\n\n.. |status| image:: https://github.com/hamcrest/pyhamcrest/workflows/ci/badge.svg\n    :alt: ci build status\n    :target: https://github.com/hamcrest/pyhamcrest/actions?query=workflow%3aci\n\n.. |version| image:: http://img.shields.io/pypi/v/pyhamcrest.svg?style=flat\n    :alt: pypi package latest release\n    :target: https://pypi.python.org/pypi/pyhamcrest\n\n.. |downloads| image:: http://img.shields.io/pypi/dm/pyhamcrest.svg?style=flat\n    :alt: pypi package monthly downloads\n    :target: https://pypi.python.org/pypi/pyhamcrest\n\n\nintroduction\n============\n\npyhamcrest is a framework for writing matcher objects, allowing you to\ndeclaratively define \"match\" rules. there are a number of situations where\nmatchers are invaluable, such as ui validation, or data filtering, but it is in\nthe area of writing flexible tests that matchers are most commonly used. this\ntutorial shows you how to use pyhamcrest for unit testing.\n\nwhen writing tests it is sometimes difficult to get the balance right between\noverspecifying the test (and making it brittle to changes), and not specifying\nenough (making the test less valuable since it continues to pass even when the\nthing being tested is broken). having a tool that allows you to pick out\nprecisely the aspect under test and describe the values it should have, to a\ncontrolled level of precision, helps greatly in writing tests that are \"just\nright.\" such tests fail when the behavior of the aspect under test deviates\nfrom the expected behavior, yet continue to pass when minor, unrelated changes\nto the behaviour are made.\n\ninstallation\n============\n\nhamcrest can be installed using the usual python packaging tools. it depends on\ndistribute, but as long as you have a network connection when you install, the\ninstallation process will take care of that for you.\n\nfor example:\n\n.. code::\n\n pip install pyhamcrest\n\nmy first pyhamcrest test\n========================\n\nwe'll start by writing a very simple pyunit test, but instead of using pyunit's\n``assertequal`` method, we'll use pyhamcrest's ``assert_that`` construct and\nthe standard set of matchers:\n\n.. code:: python\n\n from hamcrest import assert_that, equal_to\n import unittest\n\n\n class biscuittest(unittest.testcase):\n     def testequals(self):\n         thebiscuit = biscuit(\"ginger\")\n         mybiscuit = biscuit(\"ginger\")\n         assert_that(thebiscuit, equal_to(mybiscuit))\n\n\n if __name__ == \"__main__\":\n     unittest.main()\n\nthe ``assert_that`` function is a stylized sentence for making a test\nassertion. in this example, the subject of the assertion is the object\n``thebiscuit``, which is the first method parameter. the second method\nparameter is a matcher for ``biscuit`` objects, here a matcher that checks one\nobject is equal to another using the python ``==`` operator. the test passes\nsince the ``biscuit`` class defines an ``__eq__`` method.\n\nif you have more than one assertion in your test you can include an identifier\nfor the tested value in the assertion:\n\n.. code:: python\n\n assert_that(thebiscuit.getchocolatechipcount(), equal_to(10), \"chocolate chips\")\n assert_that(thebiscuit.gethazelnutcount(), equal_to(3), \"hazelnuts\")\n\nas a convenience, assert_that can also be used to verify a boolean condition:\n\n.. code:: python\n\n assert_that(thebiscuit.iscooked(), \"cooked\")\n\nthis is equivalent to the ``assert_`` method of unittest.testcase, but because\nit's a standalone function, it offers greater flexibility in test writing.\n\n\npredefined matchers\n===================\n\npyhamcrest comes with a library of useful matchers:\n\n* object\n\n  * ``equal_to`` - match equal object\n  * ``has_length`` - match ``len()``\n  * ``has_property`` - match value of property with given name\n  * ``has_properties`` - match an object that has all of the given properties.\n  * ``has_string`` - match ``str()``\n  * ``instance_of`` - match object type\n  * ``none``, ``not_none`` - match ``none``, or not ``none``\n  * ``same_instance`` - match same object\n  * ``calling, raises`` - wrap a method call and assert that it raises an exception\n\n* number\n\n  * ``close_to`` - match number close to a given value\n  * ``greater_than``, ``greater_than_or_equal_to``, ``less_than``,\n    ``less_than_or_equal_to`` - match numeric ordering\n\n* text\n\n  * ``contains_string`` - match part of a string\n  * ``ends_with`` - match the end of a string\n  * ``equal_to_ignoring_case`` - match the complete string but ignore case\n  * ``equal_to_ignoring_whitespace`` - match the complete string but ignore extra whitespace\n  * ``matches_regexp`` - match a regular expression in a string\n  * ``starts_with`` - match the beginning of a string\n  * ``string_contains_in_order`` - match parts of a string, in relative order\n\n* logical\n\n  * ``all_of`` - ``and`` together all matchers\n  * ``any_of`` - ``or`` together all matchers\n  * ``anything`` - match anything, useful in composite matchers when you don't care about a particular value\n  * ``is_not``, ``not_`` - negate the matcher\n\n* sequence\n\n  * ``contains`` - exactly match the entire sequence\n  * ``contains_inanyorder`` - match the entire sequence, but in any order\n  * ``has_item`` - match if given item appears in the sequence\n  * ``has_items`` - match if all given items appear in the sequence, in any order\n  * ``is_in`` - match if item appears in the given sequence\n  * ``only_contains`` - match if sequence's items appear in given list\n  * ``empty`` - match if the sequence is empty\n\n* dictionary\n\n  * ``has_entries`` - match dictionary with list of key-value pairs\n  * ``has_entry`` - match dictionary containing a key-value pair\n  * ``has_key`` - match dictionary with a key\n  * ``has_value`` - match dictionary with a value\n\n* decorator\n\n  * ``calling`` - wrap a callable in a deferred object, for subsequent matching on calling behaviour\n  * ``raises`` - ensure that a deferred callable raises as expected\n  * ``described_as`` - give the matcher a custom failure description\n  * ``is_`` - decorator to improve readability - see `syntactic sugar` below\n\nthe arguments for many of these matchers accept not just a matching value, but\nanother matcher, so matchers can be composed for greater flexibility. for\nexample, ``only_contains(less_than(5))`` will match any sequence where every\nitem is less than 5.\n\n\nsyntactic sugar\n===============\n\npyhamcrest strives to make your tests as readable as possible. for example, the\n``is_`` matcher is a wrapper that doesn't add any extra behavior to the\nunderlying matcher. the following assertions are all equivalent:\n\n.. code:: python\n\n assert_that(thebiscuit, equal_to(mybiscuit))\n assert_that(thebiscuit, is_(equal_to(mybiscuit)))\n assert_that(thebiscuit, is_(mybiscuit))\n\nthe last form is allowed since ``is_(value)`` wraps most non-matcher arguments\nwith ``equal_to``. but if the argument is a type, it is wrapped with\n``instance_of``, so the following are also equivalent:\n\n.. code:: python\n\n assert_that(thebiscuit, instance_of(biscuit))\n assert_that(thebiscuit, is_(instance_of(biscuit)))\n assert_that(thebiscuit, is_(biscuit))\n\n*note that pyhamcrest's ``is_`` matcher is unrelated to python's ``is``\noperator. the matcher for object identity is ``same_instance``.*\n\n\nwriting custom matchers\n=======================\n\npyhamcrest comes bundled with lots of useful matchers, but you'll probably find\nthat you need to create your own from time to time to fit your testing needs.\nthis commonly occurs when you find a fragment of code that tests the same set\nof properties over and over again (and in different tests), and you want to\nbundle the fragment into a single assertion. by writing your own matcher you'll\neliminate code duplication and make your tests more readable!\n\nlet's write our own matcher for testing if a calendar date falls on a saturday.\nthis is the test we want to write:\n\n.. code:: python\n\n def testdateisonasaturday(self):\n     d = datetime.date(2008, 4, 26)\n     assert_that(d, is_(on_a_saturday()))\n\nand here's the implementation:\n\n.. code:: python\n\n from hamcrest.core.base_matcher import basematcher\n from hamcrest.core.helpers.hasmethod import hasmethod\n\n\n class isgivendayofweek(basematcher):\n     def __init__(self, day):\n         self.day = day  # monday is 0, sunday is 6\n\n     def _matches(self, item):\n         if not hasmethod(item, \"weekday\"):\n             return false\n         return item.weekday() == self.day\n\n     def describe_to(self, description):\n         day_as_string = [\n             \"monday\",\n             \"tuesday\",\n             \"wednesday\",\n             \"thursday\",\n             \"friday\",\n             \"saturday\",\n             \"sunday\",\n         ]\n         description.append_text(\"calendar date falling on \").append_text(\n             day_as_string[self.day]\n         )\n\n\n def on_a_saturday():\n     return isgivendayofweek(5)\n\nfor our matcher implementation we implement the ``_matches`` method - which\ncalls the ``weekday`` method after confirming that the argument (which may not\nbe a date) has such a method - and the ``describe_to`` method - which is used\nto produce a failure message when a test fails. here's an example of how the\nfailure message looks:\n\n.. code:: python\n\n assert_that(datetime.date(2008, 4, 6), is_(on_a_saturday()))\n\nfails with the message::\n\n    assertionerror:\n    expected: is calendar date falling on saturday\n         got: <2008-04-06>\n\nlet's say this matcher is saved in a module named ``isgivendayofweek``. we\ncould use it in our test by importing the factory function ``on_a_saturday``:\n\n.. code:: python\n\n from hamcrest import assert_that, is_\n import unittest\n from isgivendayofweek import on_a_saturday\n\n\n class datetest(unittest.testcase):\n     def testdateisonasaturday(self):\n         d = datetime.date(2008, 4, 26)\n         assert_that(d, is_(on_a_saturday()))\n\n\n if __name__ == \"__main__\":\n     unittest.main()\n\neven though the ``on_a_saturday`` function creates a new matcher each time it\nis called, you should not assume this is the only usage pattern for your\nmatcher. therefore you should make sure your matcher is stateless, so a single\ninstance can be reused between matches.\n\n\nmore resources\n==============\n\n* documentation_\n* package_\n* sources_\n* hamcrest_\n\n.. _documentation: https://pyhamcrest.readthedocs.io/\n.. _package: http://pypi.python.org/pypi/pyhamcrest\n.. _sources: https://github.com/hamcrest/pyhamcrest\n.. _hamcrest: http://hamcrest.org\n",
  "docs_url": "https://pythonhosted.org/PyHamcrest/",
  "keywords": "hamcrest,matchers,pyunit,test,testing,unit,unittest,unittesting",
  "license": "bsd license  copyright 2020 hamcrest.org all rights reserved.  redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  neither the name of hamcrest nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.  this software is provided by the copyright holders and contributors \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. in no event shall the copyright owner or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.",
  "name": "pyhamcrest",
  "package_url": "https://pypi.org/project/PyHamcrest/",
  "project_url": "https://pypi.org/project/PyHamcrest/",
  "project_urls": {
    "History": "https://github.com/hamcrest/PyHamcrest/blob/main/CHANGELOG.rst",
    "Issues": "https://github.com/hamcrest/PyHamcrest/issues",
    "Source": "https://github.com/hamcrest/PyHamcrest/"
  },
  "release_url": "https://pypi.org/project/PyHamcrest/2.1.0/",
  "requires_dist": [
    "black; extra == 'dev'",
    "doc2dash; extra == 'dev'",
    "flake8; extra == 'dev'",
    "pyhamcrest[docs,tests]; extra == 'dev'",
    "pytest-mypy; extra == 'dev'",
    "towncrier; extra == 'dev'",
    "tox; extra == 'dev'",
    "tox-asdf; extra == 'dev'",
    "twine; extra == 'dev'",
    "alabaster~=0.7; extra == 'docs'",
    "sphinx~=4.0; extra == 'docs'",
    "coverage[toml]; extra == 'tests'",
    "dataclasses; python_version < '3.7' and extra == 'tests'",
    "mypy!=0.940; platform_python_implementation != 'PyPy' and extra == 'tests'",
    "pytest-mypy-plugins; platform_python_implementation != 'PyPy' and extra == 'tests'",
    "pytest-sugar; extra == 'tests'",
    "pytest-xdist; extra == 'tests'",
    "pytest>=5.0; extra == 'tests'",
    "pyyaml; extra == 'tests'",
    "types-dataclasses; python_version < '3.7' and extra == 'tests'",
    "types-mock; extra == 'tests'",
    "numpy; extra == 'tests-numpy'",
    "pyhamcrest[tests]; extra == 'tests-numpy'"
  ],
  "requires_python": ">=3.6",
  "summary": "hamcrest framework for matcher objects",
  "version": "2.1.0",
  "releases": [],
  "developers": [
    "offline@offby1.net",
    "simon_brunning"
  ],
  "kwds": "pyhamcrest badge hamcrest_ hamcrest pyunit",
  "license_kwds": "liability liable copyright negligence damages",
  "libtype": "pypi",
  "id": "pypi_pyhamcrest",
  "homepage": "",
  "release_count": 24,
  "dependency_ids": [
    "pypi_alabaster",
    "pypi_black",
    "pypi_coverage",
    "pypi_dataclasses",
    "pypi_doc2dash",
    "pypi_flake8",
    "pypi_mypy!",
    "pypi_numpy",
    "pypi_pyhamcrest",
    "pypi_pytest",
    "pypi_pytest_mypy",
    "pypi_pytest_mypy_plugins",
    "pypi_pytest_sugar",
    "pypi_pytest_xdist",
    "pypi_pyyaml",
    "pypi_sphinx",
    "pypi_towncrier",
    "pypi_tox",
    "pypi_tox_asdf",
    "pypi_twine",
    "pypi_types_dataclasses",
    "pypi_types_mock"
  ]
}