{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# dataclasses json\n\n![](https://github.com/lidatong/dataclasses-json/workflows/dataclasses-json/badge.svg)\n\nthis library provides a simple api for encoding and decoding [dataclasses](https://docs.python.org/3/library/dataclasses.html) to and from json.\n\nit's very easy to get started.\n\n[readme / documentation website](https://lidatong.github.io/dataclasses-json). features a navigation bar and search functionality, and should mirror this readme exactly -- take a look!\n\n## quickstart\n\n`pip install dataclasses-json`\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\n\n@dataclass_json\n@dataclass\nclass person:\n    name: str\n\n\nperson = person(name='lidatong')\nperson.to_json()  # '{\"name\": \"lidatong\"}' <- this is a string\nperson.to_dict()  # {'name': 'lidatong'} <- this is a dict\nperson.from_json('{\"name\": \"lidatong\"}')  # person(1)\nperson.from_dict({'name': 'lidatong'})  # person(1)\n\n# you can also apply _schema validation_ using an alternative api\n# this can be useful for \"typed\" python code\n\nperson.from_json('{\"name\": 42}')  # this is ok. 42 is not a `str`, but\n                                  # dataclass creation does not validate types\nperson.schema().loads('{\"name\": 42}')  # error! raises `validationerror`\n```\n\n**what if you want to work with camelcase json?**\n\n```python\n# same imports as above, with the additional `lettercase` import\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json, lettercase\n\n@dataclass_json(letter_case=lettercase.camel)  # now all fields are encoded/decoded from camelcase\n@dataclass\nclass configuredsimpleexample:\n    int_field: int\n\nconfiguredsimpleexample(1).to_json()  # {\"intfield\": 1}\nconfiguredsimpleexample.from_json('{\"intfield\": 1}')  # configuredsimpleexample(1)\n```\n\n## supported types\n\nit's recursive (see caveats below), so you can easily work with nested dataclasses.\nin addition to the supported types in the \n[py to json table](https://docs.python.org/3/library/json.html#py-to-json-table), this library supports the following:\n\n- any arbitrary [collection](https://docs.python.org/3/library/collections.abc.html#collections.abc.collection) type is supported.\n[mapping](https://docs.python.org/3/library/collections.abc.html#collections.abc.mapping) types are encoded as json objects and `str` types as json strings. \nany other collection types are encoded into json arrays, but decoded into the original collection types.\n\n- [datetime](https://docs.python.org/3/library/datetime.html#available-types) \nobjects. `datetime` objects are encoded to `float` (json number) using \n[timestamp](https://docs.python.org/3/library/datetime.html#datetime.datetime.timestamp).\nas specified in the `datetime` docs, if your `datetime` object is naive, it will \nassume your system local timezone when calling `.timestamp()`. json numbers \ncorresponding to a `datetime` field in your dataclass are decoded \ninto a datetime-aware object, with `tzinfo` set to your system local timezone.\nthus, if you encode a datetime-naive object, you will decode into a \ndatetime-aware object. this is important, because encoding and decoding won't \nstrictly be inverses. see [this section](#overriding) if you want to override this default\nbehavior (for example, if you want to use iso).\n\n- [uuid](https://docs.python.org/3/library/uuid.html#uuid.uuid) objects. they \nare encoded as `str` (json string).\n\n- [decimal](https://docs.python.org/3/library/decimal.html) objects. they are\nalso encoded as `str`.\n\n**the [latest release](https://github.com/lidatong/dataclasses-json/releases/latest) is compatible with both python 3.7 and python 3.6 (with the dataclasses backport).**\n\n## usage\n\n#### approach 1: class decorator\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\n@dataclass_json\n@dataclass\nclass person:\n    name: str\n\nlidatong = person('lidatong')\n\n# encoding to json\nlidatong.to_json()  # '{\"name\": \"lidatong\"}'\n\n# decoding from json\nperson.from_json('{\"name\": \"lidatong\"}')  # person(name='lidatong')\n```\n\nnote that the `@dataclass_json` decorator must be stacked above the `@dataclass`\ndecorator (order matters!)\n\n#### approach 2: inherit from a mixin\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclassjsonmixin\n\n@dataclass\nclass person(dataclassjsonmixin):\n    name: str\n\nlidatong = person('lidatong')\n\n# a different example from approach 1 above, but usage is the exact same\nassert person.from_json(lidatong.to_json()) == lidatong\n```\n\npick whichever approach suits your taste. note that there is better support for\n the mixin approach when using _static analysis_ tools (e.g. linting, typing),\n but the differences in implementation will be invisible in _runtime_ usage.\n\n## how do i...\n\n\n\n### use my dataclass with json arrays or objects?\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\n@dataclass_json\n@dataclass\nclass person:\n    name: str\n```\n\n**encode into a json array containing instances of my data class**\n\n```python\npeople_json = [person('lidatong')]\nperson.schema().dumps(people_json, many=true)  # '[{\"name\": \"lidatong\"}]'\n```\n\n**decode a json array containing instances of my data class**\n\n```python\npeople_json = '[{\"name\": \"lidatong\"}]'\nperson.schema().loads(people_json, many=true)  # [person(name='lidatong')]\n```\n\n**encode as part of a larger json object containing my data class (e.g. an http \nrequest/response)**\n\n```python\nimport json\n\nresponse_dict = {\n    'response': {\n        'person': person('lidatong').to_dict()\n    }\n}\n\nresponse_json = json.dumps(response_dict)\n```\n\nin this case, we do two steps. first, we encode the dataclass into a \n**python dictionary** rather than a json string, using `.to_dict`. \n\nsecond, we leverage the built-in `json.dumps` to serialize our `dataclass` into \na json string.\n\n**decode as part of a larger json object containing my data class (e.g. an http \nresponse)**\n\n```python\nimport json\n\nresponse_dict = json.loads('{\"response\": {\"person\": {\"name\": \"lidatong\"}}}')\n\nperson_dict = response_dict['response']\n\nperson = person.from_dict(person_dict)\n```\n\nin a similar vein to encoding above, we leverage the built-in `json` module.\n\nfirst, call `json.loads` to read the entire json object into a \ndictionary. we then access the key of the value containing the encoded dict of \nour `person` that we want to decode (`response_dict['response']`).\n\nsecond, we load in the dictionary using `person.from_dict`.\n\n\n### encode or decode into python lists/dictionaries rather than json?\n\nthis can be by calling `.schema()` and then using the corresponding \nencoder/decoder methods, ie. `.load(...)`/`.dump(...)`.\n\n**encode into a single python dictionary**\n\n```python\nperson = person('lidatong')\nperson.to_dict()  # {'name': 'lidatong'}\n```\n\n**encode into a list of python dictionaries**\n\n```python\npeople = [person('lidatong')]\nperson.schema().dump(people, many=true)  # [{'name': 'lidatong'}]\n```\n\n**decode a dictionary into a single dataclass instance**\n\n```python\nperson_dict = {'name': 'lidatong'}\nperson.from_dict(person_dict)  # person(name='lidatong')\n```\n\n**decode a list of dictionaries into a list of dataclass instances**\n\n```python\npeople_dicts = [{\"name\": \"lidatong\"}]\nperson.schema().load(people_dicts, many=true)  # [person(name='lidatong')]\n```\n\n### encode or decode from camelcase (or kebab-case)?\n\njson letter case by convention is camelcase, in python members are by convention snake_case.\n\nyou can configure it to encode/decode from other casing schemes at both the class level and the field level.\n\n```python\nfrom dataclasses import dataclass, field\n\nfrom dataclasses_json import lettercase, config, dataclass_json\n\n\n# changing casing at the class level\n@dataclass_json(letter_case=lettercase.camel)\n@dataclass\nclass person:\n    given_name: str\n    family_name: str\n    \nperson('alice', 'liddell').to_json()  # '{\"givenname\": \"alice\"}'\nperson.from_json('{\"givenname\": \"alice\", \"familyname\": \"liddell\"}')  # person('alice', 'liddell')\n\n# at the field level\n@dataclass_json\n@dataclass\nclass person:\n    given_name: str = field(metadata=config(letter_case=lettercase.camel))\n    family_name: str\n    \nperson('alice', 'liddell').to_json()  # '{\"givenname\": \"alice\"}'\n# notice how the `family_name` field is still snake_case, because it wasn't configured above\nperson.from_json('{\"givenname\": \"alice\", \"family_name\": \"liddell\"}')  # person('alice', 'liddell')\n```\n\n**this library assumes your field follows the python convention of snake_case naming.**\nif your field is not `snake_case` to begin with and you attempt to parameterize `lettercase`, \nthe behavior of encoding/decoding is undefined (most likely it will result in subtle bugs).\n\n### encode or decode using a different name\n\n```python\nfrom dataclasses import dataclass, field\n\nfrom dataclasses_json import config, dataclass_json\n\n@dataclass_json\n@dataclass\nclass person:\n    given_name: str = field(metadata=config(field_name=\"overriddengivenname\"))\n\nperson(given_name=\"alice\")  # person('alice')\nperson.from_json('{\"overriddengivenname\": \"alice\"}')  # person('alice')\nperson('alice').to_json()  # {\"overriddengivenname\": \"alice\"}\n```\n\n### handle missing or optional field values when decoding?\n\nby default, any fields in your dataclass that use `default` or \n`default_factory` will have the values filled with the provided default, if the\ncorresponding field is missing from the json you're decoding.\n\n**decode json with missing field**\n\n```python\n@dataclass_json\n@dataclass\nclass student:\n    id: int\n    name: str = 'student'\n\nstudent.from_json('{\"id\": 1}')  # student(id=1, name='student')\n```\n\nnotice `from_json` filled the field `name` with the specified default 'student'\nwhen it was missing from the json.\n\nsometimes you have fields that are typed as `optional`, but you don't \nnecessarily want to assign a default. in that case, you can use the \n`infer_missing` kwarg to make `from_json` infer the missing field value as `none`.\n\n**decode optional field without default**\n\n```python\n@dataclass_json\n@dataclass\nclass tutor:\n    id: int\n    student: optional[student] = none\n\ntutor.from_json('{\"id\": 1}')  # tutor(id=1, student=none)\n```\n\npersonally i recommend you leverage dataclass defaults rather than using \n`infer_missing`, but if for some reason you need to decouple the behavior of \njson decoding from the field's default value, this will allow you to do so.\n\n\n### handle unknown / extraneous fields in json?\n\nby default, it is up to the implementation what happens when a `json_dataclass` receives input parameters that are not defined.\n(the `from_dict` method ignores them, when loading using `schema()` a validationerror is raised.)\nthere are three ways to customize this behavior.\n\nassume you want to instantiate a dataclass with the following dictionary:\n```python\ndump_dict = {\"endpoint\": \"some_api_endpoint\", \"data\": {\"foo\": 1, \"bar\": \"2\"}, \"undefined_field_name\": [1, 2, 3]}\n```\n\n1. you can enforce to always raise an error by setting the `undefined` keyword to `undefined.raise`\n (`'raise'` as a case-insensitive string works as well). of course it works normally if you don't pass any undefined parameters.\n    \n```python\nfrom dataclasses_json import undefined\n\n@dataclass_json(undefined=undefined.raise)\n@dataclass()\nclass exactapidump:\n    endpoint: str\n    data: dict[str, any]\n\ndump = exactapidump.from_dict(dump_dict)  # raises undefinedparametererror\n```\n\n2. you can simply ignore any undefined parameters by setting the `undefined` keyword to `undefined.exclude`\n (`'exclude'` as a case-insensitive string works as well). note that you will not be able to retrieve them using `to_dict`:\n    \n```python\nfrom dataclasses_json import undefined\n\n@dataclass_json(undefined=undefined.exclude)\n@dataclass()\nclass dontcareapidump:\n    endpoint: str\n    data: dict[str, any]\n\ndump = dontcareapidump.from_dict(dump_dict)  # dontcareapidump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'})\ndump.to_dict()  # {\"endpoint\": \"some_api_endpoint\", \"data\": {\"foo\": 1, \"bar\": \"2\"}}\n```\n\n3. you can save them in a catch-all field and do whatever needs to be done later. simply set the `undefined`\nkeyword to `undefined.include` (`'include'` as a case-insensitive string works as well) and define a field\nof type `catchall` where all unknown values will end up.\n this simply represents a dictionary that can hold anything. \n if there are no undefined parameters, this will be an empty dictionary.\n    \n```python\nfrom dataclasses_json import undefined, catchall\n\n@dataclass_json(undefined=undefined.include)\n@dataclass()\nclass unknownapidump:\n    endpoint: str\n    data: dict[str, any]\n    unknown_things: catchall\n\ndump = unknownapidump.from_dict(dump_dict)  # unknownapidump(endpoint='some_api_endpoint', data={'foo': 1, 'bar': '2'}, unknown_things={'undefined_field_name': [1, 2, 3]})\ndump.to_dict()  # {'endpoint': 'some_api_endpoint', 'data': {'foo': 1, 'bar': '2'}, 'undefined_field_name': [1, 2, 3]}\n```\n\nnotes:\n- when using `undefined.include`, an `undefinedparametererror` will be raised if you don't specify\nexactly one field of type `catchall`.\n- note that `lettercase` does not affect values written into the `catchall` field, they will be as they are given.\n- when specifying a default (or a default factory) for the the `catchall`-field, e.g. `unknown_things: catchall = none`, the default value will be used instead of an empty dict if there are no undefined parameters.\n- calling __init__ with non-keyword arguments resolves the arguments to the defined fields and writes everything else into the catch-all field.\n\n4. all 3 options work as well using `schema().loads` and `schema().dumps`, as long as you don't overwrite it by specifying `schema(unknown=<a marshmallow value>)`.\nmarshmallow uses the same 3 keywords ['include', 'exclude', 'raise'](https://marshmallow.readthedocs.io/en/stable/quickstart.html#handling-unknown-fields).\n\n5. all 3 operations work as well using `__init__`, e.g. `unknownapidump(**dump_dict)` will **not** raise a `typeerror`, but write all unknown values to the field tagged as `catchall`.\n   classes tagged with `exclude` will also simply ignore unknown parameters. note that classes tagged as `raise` still raise a `typeerror`, and **not** a `undefinedparametererror` if supplied with unknown keywords.\n\n\n### override the default encode / decode / marshmallow field of a specific field?\n\nsee [overriding](#overriding)\n\n### handle recursive dataclasses?\nobject hierarchies where fields are of the type that they are declared within require a small\ntype hinting trick to declare the forward reference.\n```python\nfrom typing import optional\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\n@dataclass_json\n@dataclass\nclass tree():\n    value: str\n    left: optional['tree']\n    right: optional['tree']\n```\n\navoid using\n```python\nfrom __future__ import annotations\n```\nas it will cause problems with the way dataclasses_json accesses the type annotations.\n\n### use numpy or pandas types?\ndata types specific to libraries commonly used in data analysis and machine learning like [numpy](https://github.com/numpy/numpy) and [pandas](https://github.com/pandas-dev/pandas) are not supported by default, but you can easily enable them by using custom decoders and encoders. below are two examples for `numpy` and `pandas` types.\n\n```python\nfrom dataclasses import field, dataclass\nfrom dataclasses_json import config, dataclass_json\nimport numpy as np\nimport pandas as pd\n\n@dataclass_json\n@dataclass\nclass datawithnumpy:\n    my_int: np.int64 = field(metadata=config(decoder=np.int64))\n    my_float: np.float64 = field(metadata=config(decoder=np.float64))\n    my_array: np.ndarray = field(metadata=config(decoder=np.asarray))\ndatawithnumpy.from_json(\"{\\\"my_int\\\": 42, \\\"my_float\\\": 13.37, \\\"my_array\\\": [1,2,3]}\")\n\n@dataclass_json\n@dataclass\nclass datawithpandas:\n    my_df: pd.dataframe = field(metadata=config(decoder=pd.dataframe.from_records, encoder=lambda x: x.to_dict(orient=\"records\")))\ndata = datawithpandas.from_dict({\"my_df\": [{\"col1\": 1, \"col2\": 2}, {\"col1\": 3, \"col2\": 4}]})\n# my_df results in:\n# col1  col2\n# 1    2    \n# 3    4\ndata.to_dict()\n# {\"my_df\": [{\"col1\": 1, \"col2\": 2}, {\"col1\": 3, \"col2\": 4}]}\n```\n\n## marshmallow interop\n\nusing the `dataclass_json` decorator or mixing in `dataclassjsonmixin` will\nprovide you with an additional method `.schema()`.\n\n`.schema()` generates a schema exactly equivalent to manually creating a\nmarshmallow schema for your dataclass. you can reference the [marshmallow api docs](https://marshmallow.readthedocs.io/en/3.0/api_reference.html#schema)\nto learn other ways you can use the schema returned by `.schema()`.\n\nyou can pass in the exact same arguments to `.schema()` that you would when\nconstructing a `personschema` instance, e.g. `.schema(many=true)`, and they will\nget passed through to the marshmallow schema.\n\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\n@dataclass_json\n@dataclass\nclass person:\n    name: str\n\n# you don't need to do this - it's generated for you by `.schema()`!\nfrom marshmallow import schema, fields\n\nclass personschema(schema):\n    name = fields.str()\n```\n\nbriefly, on what's going on under the hood in the above examples: calling \n`.schema()` will have this library generate a\n[marshmallow schema]('https://marshmallow.readthedocs.io/en/3.0/api_reference.html#schema)\nfor you. it also fills in the corresponding object hook, so that marshmallow\nwill create an instance of your data class on `load` (e.g.\n`person.schema().load` returns a `person`) rather than a `dict`, which it does\nby default in marshmallow.\n\n**performance note**\n\n`.schema()` is not cached (it generates the schema on every call), so if you\nhave a nested data class you may want to save the result to a variable to \navoid re-generation of the schema on every usage.\n\n```python\nperson_schema = person.schema()\nperson_schema.dump(people, many=true)\n\n# later in the code...\n\nperson_schema.dump(person)\n```\n\n## overriding / extending\n\n#### overriding\n\nfor example, you might want to encode/decode `datetime` objects using iso format\nrather than the default `timestamp`.\n\n```python\nfrom dataclasses import dataclass, field\nfrom dataclasses_json import dataclass_json, config\nfrom datetime import datetime\nfrom marshmallow import fields\n\n@dataclass_json\n@dataclass\nclass dataclasswithisodatetime:\n    created_at: datetime = field(\n        metadata=config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,\n            mm_field=fields.datetime(format='iso')\n        )\n    )\n```\n\n#### extending\n\nsimilarly, you might want to extend `dataclasses_json` to encode `date` objects.\n\n```python\nfrom dataclasses import dataclass, field\nfrom dataclasses_json import dataclass_json, config\nfrom datetime import date\nfrom marshmallow import fields\n\ndataclasses_json.cfg.global_config.encoders[date] = date.isoformat\ndataclasses_json.cfg.global_config.decoders[date] = date.fromisoformat\n\n@dataclass_json\n@dataclass\nclass dataclasswithisodatetime:\n    created_at: date\n    modified_at: date\n    accessed_at: date\n```\n\nas you can see, you can **override** or **extend** the default codecs by providing a \"hook\" via a \ncallable:\n- `encoder`: a callable, which will be invoked to convert the field value when encoding to json\n- `decoder`: a callable, which will be invoked to convert the json value when decoding from json\n- `mm_field`: a marshmallow field, which will affect the behavior of any operations involving `.schema()`\n\nnote that these hooks will be invoked regardless if you're using \n`.to_json`/`dump`/`dumps`\nand `.from_json`/`load`/`loads`. so apply overrides / extensions judiciously, making sure to \ncarefully consider whether the interaction of the encode/decode/mm_field is consistent with what you expect!\n\n\n#### what if i have other dataclass field extensions that rely on `metadata`\n\nall the `dataclasses_json.config` does is return a mapping, namespaced under the key `'dataclasses_json'`.\n\nsay there's another module, `other_dataclass_package` that uses metadata. here's how you solve your problem:\n\n```python\nmetadata = {'other_dataclass_package': 'some metadata...'}  # pre-existing metadata for another dataclass package\ndataclass_json_config = config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,\n            mm_field=fields.datetime(format='iso')\n        )\nmetadata.update(dataclass_json_config)\n\n@dataclass_json\n@dataclass\nclass dataclasswithisodatetime:\n    created_at: datetime = field(metadata=metadata)\n```\n\nyou can also manually specify the dataclass_json configuration mapping.\n\n```python\n@dataclass_json\n@dataclass\nclass dataclasswithisodatetime:\n    created_at: date = field(\n        metadata={'dataclasses_json': {\n            'encoder': date.isoformat,\n            'decoder': date.fromisoformat,\n            'mm_field': fields.datetime(format='iso')\n        }}\n    )\n```\n\n## a larger example\n\n```python\nfrom dataclasses import dataclass\nfrom dataclasses_json import dataclass_json\n\nfrom typing import list\n\n@dataclass_json\n@dataclass(frozen=true)\nclass minion:\n    name: str\n\n\n@dataclass_json\n@dataclass(frozen=true)\nclass boss:\n    minions: list[minion]\n\nboss = boss([minion('evil minion'), minion('very evil minion')])\nboss_json = \"\"\"\n{\n    \"minions\": [\n        {\n            \"name\": \"evil minion\"\n        },\n        {\n            \"name\": \"very evil minion\"\n        }\n    ]\n}\n\"\"\".strip()\n\nassert boss.to_json(indent=4) == boss_json\nassert boss.from_json(boss_json) == boss\n```\n\n## performance\n\ntake a look at [this issue](https://github.com/lidatong/dataclasses-json/issues/228)\n\n## versioning\n\nnote this library is still pre-1.0.0 (semver).\n\nthe current convention is:\n- **patch** version upgrades for bug fixes and minor feature additions.\n- **minor** version upgrades for big api features and breaking changes.\n\nonce this library is 1.0.0, it will follow standard semver conventions.\n\n### python compatibility \n\nany version that is not listed in the table below we do not test against, though you might still be able to install the library. for future python versions, please open an issue and/or a pull request, adding them to the ci suite.\n\n\n| python version range | compatible dataclasses-json version |\n|----------------------|:-----------------------------------:|\n| 3.7.x - 3.12.x       |            0.5.x - 0.6.x            |\n| >= 3.13.x            |         no official support (yet)   |\n\n\n## roadmap\n\ncurrently the focus is on investigating and fixing bugs in this library, working\non performance, and finishing [this issue](https://github.com/lidatong/dataclasses-json/issues/31).\n\nthat said, if you think there's a feature missing / something new needed in the\nlibrary, please see the contributing section below.\n\n\n## contributing\n\nfirst of all, thank you for being interested in contributing to this library.\ni really appreciate you taking the time to work on this project.\n\n- if you're just interested in getting into the code, a good place to start are \nissues tagged as bugs.\n- if introducing a new feature, especially one that modifies the public api, \nconsider submitting an issue for discussion before a pr. please also take a look \nat existing issues / prs to see what you're proposing has  already been covered \nbefore / exists.\n- i like to follow the commit conventions documented [here](https://www.conventionalcommits.org/en/v1.0.0/#summary)\n\n### setting up your environment\n\nthis project uses [poetry](https://python-poetry.org/) for dependency and venv management. it is quite simple to get ready for your first commit:\n- [install](https://python-poetry.org/docs/#installation) latest stable poetry\n- navigate to where you cloned `dataclasses-json`\n- run `poetry install`\n- create a branch and start writing code!\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "dataclasses-json",
  "package_url": "https://pypi.org/project/dataclasses-json/",
  "project_url": "https://pypi.org/project/dataclasses-json/",
  "project_urls": {
    "Homepage": "https://github.com/lidatong/dataclasses-json",
    "Repository": "https://github.com/lidatong/dataclasses-json",
    "changelog": "https://github.com/lidatong/dataclasses-json/releases",
    "documentation": "https://lidatong.github.io/dataclasses-json/",
    "issues": "https://github.com/lidatong/dataclasses-json/issues"
  },
  "release_url": "https://pypi.org/project/dataclasses-json/0.6.3/",
  "requires_dist": [
    "marshmallow (>=3.18.0,<4.0.0)",
    "typing-inspect (>=0.4.0,<1)"
  ],
  "requires_python": ">=3.7,<4.0",
  "summary": "easily serialize dataclasses to and from json.",
  "version": "0.6.3",
  "releases": [],
  "developers": [
    "charles.dt.li@gmail.com",
    "charles_li"
  ],
  "kwds": "dataclasses_json dataclass_json json_dataclass dataclassjsonmixin json",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_dataclasses_json",
  "homepage": "https://github.com/lidatong/dataclasses-json",
  "release_count": 73,
  "dependency_ids": [
    "pypi_marshmallow",
    "pypi_typing_inspect"
  ]
}