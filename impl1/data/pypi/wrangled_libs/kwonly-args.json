{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "===========\nkwonly-args\n===========\n\n\n.. image:: https://img.shields.io/travis/pasztorpisti/kwonly-args.svg?style=flat\n    :target: https://travis-ci.org/pasztorpisti/kwonly-args\n    :alt: build\n\n.. image:: https://img.shields.io/codacy/1a359512094746ae9d39e281cdbc581a/master.svg?style=flat\n    :target: https://www.codacy.com/app/pasztorpisti/kwonly-args\n    :alt: code quality\n\n.. image:: https://landscape.io/github/pasztorpisti/kwonly-args/master/landscape.svg?style=flat\n    :target: https://landscape.io/github/pasztorpisti/kwonly-args/master\n    :alt: code health\n\n.. image:: https://img.shields.io/coveralls/pasztorpisti/kwonly-args/master.svg?style=flat\n    :target: https://coveralls.io/r/pasztorpisti/kwonly-args?branch=master\n    :alt: coverage\n\n.. image:: https://img.shields.io/pypi/v/kwonly-args.svg?style=flat\n    :target: https://pypi.python.org/pypi/kwonly-args\n    :alt: pypi\n\n.. image:: https://img.shields.io/github/tag/pasztorpisti/kwonly-args.svg?style=flat\n    :target: https://github.com/pasztorpisti/kwonly-args\n    :alt: github\n\n.. image:: https://img.shields.io/github/license/pasztorpisti/kwonly-args.svg?style=flat\n    :target: https://github.com/pasztorpisti/kwonly-args/blob/master/license.txt\n    :alt: license: mit\n\n\nproviding keyword-only argument emulation for python2. the resulting code is python3 compatible.\n\nyou have to read only the short usage_ section of the document to get started, the rest is optional for curious people and\nbored time billionaires.\n\n\n.. contents::\n\n\n-----\nusage\n-----\n\n\ninstallation\n------------\n\n.. code-block:: sh\n\n    pip install kwonly-args\n\nalternatively you can download the zipped library from https://pypi.python.org/pypi/kwonly-args\n\n\nbrief how-to with code examples\n-------------------------------\n\nwith this library you can turn some or all of the default arguments of your function into keyword-only arguments.\n\n- decorate your function with ``kwonly_args.first_kwonly_arg`` and select one of the default arguments of your function\n  with the ``name`` parameter of the decorator. the selected argument along with all default arguments on its right\n  side will be treated as keyword-only arguments.\n- all keyword-only arguments have a default value and they aren't required args by default. you can make a\n  keyword-only argument required by using ``kwonly_args.kwonly_required`` as its default value.\n\nyour new-born keyword-only args are no longer treated as positional arguments and varargs still work if your function\nhas ``*args`` or something like that.\n\n.. code-block:: python\n\n    from kwonly_args import first_kwonly_arg, kwonly_required\n\n\n    # this turns default1 and default2 into keyword-only arguments.\n    # they are no longer handled as positional arguments.\n    @first_kwonly_arg('default1')\n    def func(arg0, arg1, default0='d0', default1='d1', default2='d2', *args):\n        print('arg0=%s arg1=%s default0=%s default1=%s default2=%s args=%s' % (\n              arg0, arg1, default0, default1, default2, args))\n\n\n    func(0, 1, 2, 3, 4)\n    # output:\n    # arg0=0 arg1=1 default0=2 default1=d1 default=d2 args=(3, 4)\n\n    # the default1 and default2 args can be passed only as keyword arguments:\n    func(0, 1, 2, 3, 4, default1='kwonly_param')\n    # output:\n    # arg0=0 arg1=1 default0=2 default1=kwonly_param default=d2 args=(3, 4)\n\n\n    # in this example all three args are keyword-only args and default1 is required.\n    @first_kwonly_arg('default0')\n    def func2(default0='d0', default1=kwonly_required, default2='d2'):\n        ...\n\n\nyou can also decorate class methods (including both old and new style classes):\n\n.. code-block:: python\n\n    from kwonly_args import first_kwonly_arg\n\n\n    class myclass:\n        # turning d1 and d2 into keyword-only arguments\n        @first_kwonly_arg('d1')\n        def my_instance_method(self, a0, a1, d0='d0', d1='d1', d2='d2', *args):\n            ...\n\n        # you have to apply @first_kwonly_arg before @classmethod!\n        @classmethod\n        @first_kwonly_arg('d1')\n        def my_class_method(cls, a0, a1, d0='d0', d1='d1', d2='d2', *args):\n            ...\n\n        # you have to apply @first_kwonly_arg before @staticmethod!\n        @staticmethod\n        @first_kwonly_arg('d1')\n        def my_static_method(a0, a1, d0='d0', d1='d1', d2='d2', *args):\n            ...\n\n\nif you want to turn all default arguments into keyword-only arguments then the following convenience api may be useful:\n\n.. code-block:: python\n\n    from kwonly_args import first_kwonly_arg, first_default_arg, kwonly_defaults\n\n\n    # the first_default_arg constant automatically selects the first default\n    # argument (default0) so it turns all default arguments into keyword-only.\n    @first_kwonly_arg(first_default_arg)\n    def func(arg0, arg1, default0='d0', default1='d1', *args):\n        ...\n\n\n    # as an equivalent shortcut you can use @kwonly_defaults.\n    @kwonly_defaults\n    def func(arg0, arg1, default0='d0', default1='d1', *args):\n        ...\n\n\n--------------------------------------------------\ncode style/design: why use keyword-only arguments?\n--------------------------------------------------\n\nyou may have an understanding of this topic. if not then read along.\nusing keyword-only arguments provides the following benefits:\n\n\ncode readability\n----------------\n\nit can make code that calls your function more readable. this is especially true if you have several functions with\nlong argument lists like some of the python standard library apis. for example ``subprocess.popen()`` has more than\n10 arguments. ``subprocess.popen()`` is a legacy function from python2 (so it couldn't make use of keyword-only\narguments despite being a very good candidate for that) but some newer python3 apis make use of keyword-only\narguments with a good reason. for example the python3 ``subprocess.run()`` has about 10 arguments but only\nthe first ``argv`` argument can be passed as positional, the rest are keyword-only.\n\n.. code-block:: python\n\n    def draw_circle(x, y, radius, filled=false):\n        ...\n\n    def draw_ellipse(x, y, radius_x, radius_y, filled=false):\n        ...\n\n    # 1. calling without using keyword arguments:\n    draw_circle(100, 200, 50, true)\n    draw_ellipse(200, 100, 100, 50)\n\n    # 2. calling using keyword arguments:\n    draw_circle(x=100, y=200, radius=50, filled=true)\n    draw_ellipse(x=200, y=100, radius_x=100, radius_y=50)\n\nwithout keyword-only arguments users of your function will be able to use both of the above conventions. if you\nemploy keyword-only arguments then they can use only #2. in case of a simple function like my ``draw_circle()`` it\nmay not seem reasonable enough to force keyword-only arguments. but imagine what happens if you start having many\nsimilar functions like ``draw_ellpise()``, ``draw_rectangle()``, etc.. and you have to read code that calls these\nwithout keyword arguments with a bunch of listed numbers and bools mixed together as their input... the above\nexample in section #1 is relatively lightweight compared to what it can look in real life.\n\nwhen a function has more than 3-4 arguments (like ``subprocess.popen()``) i think it is a very good practice to\nallow at most the first few (or none of the) arguments to be passed as positional ones and make the rest kw-only\n(like the standard python3 ``subprocess.run()``).\nit isn't a problem if a function has a lot of parameters (especially default ones) as long as the code that calls\nthe function remains readable by using keyword argument passing and you can enforce/guarantee that by making the\nmost of the arguments keyword-only:\n\n.. code-block:: python\n\n    import subprocess\n\n    argv = ['ls', '-l']\n\n    # bad! i think i don't really have to explain why...\n    p = subprocess.popen(argv, -1, none, subprocess.pipe, subprocess.pipe,\n                         subprocess.stdout, none, true, true)\n\n    # good! and this has the same behavior as the previous call.\n    # i think it is well worth enforcing this form with keyword-only args.\n    p = subprocess.popen(argv, stdin=subprocess.pipe, stdout=subprocess.pipe,\n                         stderr=subprocess.stdout, shell=true)\n\n    # if the number of passed arguments exceeds my threshold\n    # i switch to the following format for readability:\n    p = subprocess.popen(\n        argv,\n        stdin=subprocess.pipe,\n        stdout=subprocess.pipe,\n        stderr=subprocess.stdout,\n        shell=true,\n    )\n\n\neasier maintenance and refactorization\n--------------------------------------\n\nkeyword-only args have an extremely useful property: you can declare them in any order in your function signature and\nthe code that calls your function can also pass them in any order.\nlater you can change the order of declaration of your keyword-only arguments for cosmetic and readability reasons\nwithout affecting behavior and without having to refactor code that calls this function. this comes in handy not only\nin case of code cosmetics but also makes it easier to add new keyword-only args and to remove old ones if necessary.\nlet's review these scenarios with code examples.\n\nimagine a scenario where you have a ``draw_circle(x, y, radius, outline_color=black, filled=false, fill_color=none)``\nfunction. it already looks bad enough without keyword-only args. let's imagine that someone asks you to add an\n`outline_width` argument. since all parameters can be passed as positional arguments you have to keep backward\ncompatibility and you have to append this argument to the end of the current arg list with a default value. this\nintroduces another ugly thing: the arguments that belong to the outline aren't adjacent. there will be two unrelated\nargs between ``outline_color`` and the newly added ``outline_width``. if these args were keyword-only arguments then\nthe arbitrary argument order would allow you to insert the new ``outline_width`` arg right after ``outline_color``.\n\nanother typical and similar scenario is having a function that makes use of 2 or more other functions. for this reason\nit receives input args and passes them through to the two other functions. let's say you start out with something like\nthis at the beginning of your project:\n\n.. code-block:: python\n\n    # lower level workhorse functions used by the higher level ``my_func()``\n    def workhorse1(wh1_1, wh1_2):\n        ...\n\n    def workhorse2(wh2_1, wh2_2):\n        ...\n\n    # and your function looks like this\n    def my_func(wh1_1, wh2_1, wh2_2):\n        # todo: perhaps manipulate the input args...\n        workhorse1(wh1_1, 8)\n        workhorse2(wh2_1, wh2_2)\n\n\nthen for some reason someone introduces a new ``wh1_3`` parameter for ``workhorse1()`` and you have to pass it through\nyour higher level ``my_func()``. it will look like this:\n\n.. code-block:: python\n\n    # one arg for wh1, then two args for wh2 and then another arg for wh1... nice.\n    def my_func(wh1_1, wh2_1, wh2_2, wh1_3):\n        # todo: perhaps manipulate the input args...\n        workhorse1(wh1_1, 8)\n        workhorse2(wh2_1, wh2_2)\n\n\nin python you can avoid such scenarios by passing such arguments in ``**kwargs`` or in separate dictionaries but it\noften makes the code less explicit and readable:\n\n.. code-block:: python\n\n    # it is more difficult to find out what's going on with ``*args``\n    # and ``**kwargs`` then with explicitly named arguments.\n    def my_func(**kwargs):\n        # let the workhorses to cherry pick the parameters they\n        # need and ignore the rest that they don't need.\n        workhorse1(**kwargs)\n        workhorse2(**kwargs)\n\n\nyou can also use two separate dictionaries or data objects to pass the arguments to the workhorses. this technique\nis better than keyword only argument passing when the workhorses have a lot of parameters and/or you have to pass\nthe arguments deeply through several calls but this solution is an an overkill in many simpler situations where the\nnumber of parameters isn't too high and there is no deep arg passing:\n\n.. code-block:: python\n\n    def my_func(wh1_args, wh2_args):\n        # todo: perhaps manipulate the input args...\n        workhorse1(wh1_args)\n        workhorse2(wh2_args)\n\n\nwith keyword-only arguments the above problems don't exist. the new `wh1_3` argument can be placed anywhere in the\nkeyword-only argument part of the argument list (e.g.: after ``wh1_1``) without affecting the rest of the code that\nalready calls this functions with other keyword-only args (given that they don't want to use the newly added arg).\n\n\n----------------------\nimplementation details\n----------------------\n\n\npython 2 function signature anatomy\n-----------------------------------\n\na python2 function signature consists of the following optional parts. any optional parts that are present in\na function signature appear in the listed order:\n\n1.  positional arguments\n\n    1.  required arguments (positional arguments without default value)\n    2.  default arguments (positional arguments with default value)\n    3.  **keyword-only arguments (non-standard, emulated/provided by this library)**\n\n2.  varargs (``*args``)\n3.  varkwargs (``**kwargs``)\n\n\nas you see in standard python2 your positional argument list consists of zero or more required arguments followed by\nzero or more default arguments. this library can turn the last n default arguments (all/some of them) into keyword-only\narguments. with the help of this library you can now split the positional argument list of your python2 function\nsignatures into 3 parts instead of the standard 2.\n\nin python3 the keyword-only arguments reside between varargs and varkwargs but in python2 you can't put anything\nbetween those (it would be a syntax error) so your best bet to emulate keyword-only arguments is turning some of your\npositional arguments into keyword-only args.\n\n\nemulated keyword-only args vs static analyzers\n..............................................\n\nas discussed previously unfortunately we can declare our emulated python2 keyword-only arguments only before the\nvarargs (``*args``) of the function. this means that our signature can have positional arguments not only before our\nkeyword-only args, but also after them (because varargs are positional). this may lead to false-positive\nwarnings/errors with static analyzers in the following case:\n\nif you have a function with both keyword-only arguments and varargs then static analyzers may treat some\nof the calls to this function suspicious (resulting in a false positive warning/error).\n\n.. code-block:: python\n\n    @first_kwonly_arg('ko0')\n    def func(a0, d0=-1, ko0=-1, ko1=-1, *args):\n        ...\n\n\n    # no problem: a0=0\n    func(0)\n\n    # no problem: a0=0, d0=1\n    func(0, 1)\n\n    # no problem: a0=0 d0=1 args=(2,)\n    func(0, 1, 2)\n\n    # the static analyzer will probably treat this as an error. it thinks that\n    # you pass both the positional argument 2 and ko0=3 to the ko0 arg of the\n    # function because it can't track down the magic done by the @first_kwonly_arg\n    # decorator and binds the passed parameters to the function args using standard\n    # python2 rules. if func() didn't have our @first_kwonly_arg decorator then\n    # this function call would probably cause an error like:\n    # typeerror: func() got multiple values for argument 'ko0'\n    #\n    # however what actually happens as a result of the magic done by the\n    # decorator is: a0=0 d0=1 ko0=3 ko1=-1 args=(2,)\n    # the decorator ensures that positional parameters passed by function calls\n    # are bound only to positional non-keyword-only arguments and the varargs\n    # of the function.\n    func(0, 1, 2, ko0=3)\n\n    # no problem despite the fact that the static analyzer probably assumes\n    # something different than what actually happens. according to standard\n    # python2 arg binding rules the static analyzer probably thinks that:\n    # a0=0 d0=1 ko0=2 ko1=3 args=()\n    #\n    # however the actual outcome caused by our decorator is:\n    # a0=0 d0=1 ko0=-1 ko1=3 args=(2,)\n    func(0, 1, 2, ko1=3)\n\n\ndespite the above issue a decorator like this can still be very useful. the reason for this is that for me it happens\nquite rarely that in a function i need both keyword-only arguments and varargs. i need varargs quite rarely in general\nwhile keyword-only arguments come in handy quite often. if this is the same for you then go on using this decorator in\nyour python2 projects and in the rare cases where you need both keyword-only arguments and varargs use one of the\nfollowing workarounds to aid this issue:\n\n- static analyzers are stupid! don't use them! (well, this was only a joke. :-d)\n- in your static analyzer tool or service ignore the individual instances of these false positive warnings.\n- use `poor man's python2 keyword-only arguments`_ with these problematic cases instead of decorating them and use the\n  decorator only with the rest (probably the majority) of the functions that don't have varargs.\n\n\npoor man's python2 keyword-only arguments\n-----------------------------------------\n\ni really like the benefits brought by keyword-only arguments. long ago before extensively working with python i've\nalready forged some coding-convention rules that have similar advantages (unordered arguments, specifying arg names\nwhile calling the function for readability) in other languages (e.g.: c/c++). before thinking about using a python2\nsolution like the one provided by this library i've used a \"manually implemented poor man's python2 keyword-only args\"\nsolution like this:\n\n.. code-block:: python\n\n    def func(arg0, arg1, default0='d0', default1='d1', **kwargs):\n        # keyword-only arg with a default value:\n        optional_kwonly0 = kwargs.pop('kwonly0', 'ko0')\n        # required keyword-only arg:\n        required_kwonly1 = kwargs.pop('kwonly1')\n\n        # checking whether the caller has passed an unexpected keyword argument.\n        # sometimes passing an unexpected keyword argument is simply the result\n        # of a typo in the name of an expected arg. e.g.: kwnly0 instead of kwonly0\n        check_no_kwargs_left(func, kwargs)\n\n        # ... the rest of the function body\n\n\n    # utility function far away somewhere in a central place...\n    def check_no_kwargs_left(func_or_func_name, kwargs):\n        if not kwargs:\n            return\n        func_name = func_or_func_name.__name__ if callable(func_or_func_name) else func_or_func_name\n        arg_names = ', '.join(repr(k) for k in sorted(kwargs.keys()))\n        raise typeerror('%s() got unexpected keyword argument(s): %s' % (func_name, arg_names))\n\n\nwhile i think the above solution if fairly good it still requires checking the function body too in order to see the\nfull signature and sometimes people may forget to check for leftover kwargs after popping the kwonly args.\n\n\n------------------------------\nwhy does this \"library\" exist?\n------------------------------\n\ni've checked out some other python2 keyword-only argument emulator code snippets and decided to roll my own just for\nfun and also for the following reasons:\n\n- some of those implementations provide you with a decorator with which you have to specify your keyword-only arguments\n  with their (usually zero based) index in the arg list of the function. this is error prone, i never liked the\n  idea of identifying arguments with indexes. the only minor disadvantage of using arg names instead of arg indexes\n  is that using arg names requires direct access to the signature of the *original* wrapped function.\n  if there are other decorators between our decorator and the original function then under python2 using names isn't\n  really possible (because ``functools.update_wrapper()`` and decorators in general don't have/support the\n  ``__wrapped__`` attribute to maintain a chain back to the originally wrapped function).\n- some implementations allow you to pick an arbitrary set of positional arguments by specifying their indexes or names.\n  i don't like the idea of promoting arbitrary positional arguments into keyword-only arguments by scattering\n  keyword-only args through the remaining positional args. it degrades code readability a lot. this is why i decided\n  to keep positional arguments of the same type (required/default/kwonly) together in a well defined slice of the\n  positional argument list.\n- `the implementation of this solution`__ is brief (~40 lines of logic), simple, and well tested.\n\n.. _decorator_source: https://github.com/pasztorpisti/kwonly-args/blob/7603c3a0f0c2d37d02c7220492de248f65ff0451/src/kwonly_args/__init__.py#l76-l118\n\n__ decorator_source_",
  "docs_url": null,
  "keywords": "kwonly keyword only arguments args decorator",
  "license": "mit",
  "name": "kwonly-args",
  "package_url": "https://pypi.org/project/kwonly-args/",
  "project_url": "https://pypi.org/project/kwonly-args/",
  "project_urls": {
    "Homepage": "https://github.com/pasztorpisti/kwonly-args"
  },
  "release_url": "https://pypi.org/project/kwonly-args/1.0.10/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python2 keyword-only argument emulation as a decorator. python 3 compatible.",
  "version": "1.0.10",
  "releases": [],
  "developers": [
    "pasztorpisti@gmail.com"
  ],
  "kwds": "kwonly_args kwonly_param kwonly_defaults first_kwonly_arg kwonly0",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_kwonly_args",
  "homepage": "https://github.com/pasztorpisti/kwonly-args",
  "release_count": 11,
  "dependency_ids": []
}