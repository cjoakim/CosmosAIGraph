{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: python software foundation license",
    "operating system :: os independent",
    "programming language :: c",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: utilities"
  ],
  "description": "bitarray: efficient arrays of booleans\n======================================\n\nthis library provides an object type which efficiently represents an array\nof booleans.  bitarrays are sequence types and behave very much like usual\nlists.  eight bits are represented by one byte in a contiguous block of\nmemory.  the user can select between two representations: little-endian\nand big-endian.  all functionality is implemented in c.\nmethods for accessing the machine representation are provided, including the\nability to import and export buffers.  this allows creating bitarrays that\nare mapped to other objects, including memory-mapped files.\n\n\nroadmap\n-------\n\nin 2024 (probably around july), we are planning the release of bitarray 3.0.\nthe 3.0 release will:\n\n* remove python 2.7 support.\n* rename ``.itersearch()`` to ``.search()`` and ``.iterdecode()``\n  to ``.decode()`` (and remove their non-iterator counterpart).\n* remove ``util.rindex()``, use ``.index(..., right=1)`` instead\n* remove ``util.make_endian()``, use ``bitarray(..., endian=...)`` instead\n* remove hackish support for ``bitarray()`` handling unpickling,\n  see detailed explaination in `#207 <https://github.com/ilanschnell/bitarray/pull/207>`__.  this will close `#206 <https://github.com/ilanschnell/bitarray/issues/206>`__.\n\n\nkey features\n------------\n\n* the bit-endianness can be specified for each bitarray object, see below.\n* sequence methods: slicing (including slice assignment and deletion),\n  operations ``+``, ``*``, ``+=``, ``*=``, the ``in`` operator, ``len()``\n* bitwise operations: ``~``, ``&``, ``|``, ``^``, ``<<``, ``>>`` (as well as\n  their in-place versions ``&=``, ``|=``, ``^=``, ``<<=``, ``>>=``).\n* fast methods for encoding and decoding variable bit length prefix codes.\n* bitarray objects support the buffer protocol (both importing and\n  exporting buffers).\n* packing and unpacking to other binary data formats, e.g. ``numpy.ndarray``.\n* pickling and unpickling of bitarray objects.\n* immutable ``frozenbitarray`` objects which are hashable\n* sequential search\n* type hinting\n* extensive test suite with about 500 unittests.\n* utility module ``bitarray.util``:\n\n  * conversion to and from hexadecimal strings\n  * (de-) serialization\n  * pretty printing\n  * conversion to and from integers\n  * creating huffman codes\n  * compression of sparse bitarrays\n  * various count functions\n  * other helpful functions\n\n\ninstallation\n------------\n\npython wheels are are available on pypi for all mayor platforms and python\nversions.  which means you can simply:\n\n.. code-block:: shell-session\n\n    $ pip install bitarray\n\nin addition, conda packages are available (both the default anaconda\nrepository as well as conda-forge support bitarray):\n\n.. code-block:: shell-session\n\n    $ conda install bitarray\n\nonce you have installed the package, you may want to test it:\n\n.. code-block:: shell-session\n\n    $ python -c 'import bitarray; bitarray.test()'\n    bitarray is installed in: /users/ilan/bitarray/bitarray\n    bitarray version: 2.9.1\n    sys.version: 3.11.0 (main, oct 25 2022) [clang 14.0.4]\n    sys.prefix: /users/ilan/mini3/envs/py311\n    pointer size: 64 bit\n    sizeof(size_t): 8\n    sizeof(bitarrayobject): 80\n    have_builtin_bswap64: 1\n    default bit-endianness: big\n    machine byte-order: little\n    debug: 0\n    .........................................................................\n    .........................................................................\n    ................................................................\n    ----------------------------------------------------------------------\n    ran 502 tests in 0.416s\n\n    ok\n\nthe ``test()`` function is part of the api.  it will return\na ``unittest.runner.texttestresult`` object, such that one can verify that\nall tests ran successfully by:\n\n.. code-block:: python\n\n    import bitarray\n    assert bitarray.test().wassuccessful()\n\n\nusage\n-----\n\nas mentioned above, bitarray objects behave very much like lists, so\nthere is not too much to learn.  the biggest difference from list\nobjects (except that bitarray are obviously homogeneous) is the ability\nto access the machine representation of the object.\nwhen doing so, the bit-endianness is of importance; this issue is\nexplained in detail in the section below.  here, we demonstrate the\nbasic usage of bitarray objects:\n\n.. code-block:: python\n\n    >>> from bitarray import bitarray\n    >>> a = bitarray()         # create empty bitarray\n    >>> a.append(1)\n    >>> a.extend([1, 0])\n    >>> a\n    bitarray('110')\n    >>> x = bitarray(2 ** 20)  # bitarray of length 1048576 (initialized to 0)\n    >>> len(x)\n    1048576\n    >>> bitarray('1001 011')   # initialize from string (whitespace is ignored)\n    bitarray('1001011')\n    >>> lst = [1, 0, false, true, true]\n    >>> a = bitarray(lst)      # initialize from iterable\n    >>> a\n    bitarray('10011')\n    >>> a[2]    # indexing a single item will always return an integer\n    0\n    >>> a[2:4]  # whereas indexing a slice will always return a bitarray\n    bitarray('01')\n    >>> a[2:3]  # even when the slice length is just one\n    bitarray('0')\n    >>> a.count(1)\n    3\n    >>> a.remove(0)            # removes first occurrence of 0\n    >>> a\n    bitarray('1011')\n\nlike lists, bitarray objects support slice assignment and deletion:\n\n.. code-block:: python\n\n    >>> a = bitarray(50)\n    >>> a.setall(0)            # set all elements in a to 0\n    >>> a[11:37:3] = 9 * bitarray('1')\n    >>> a\n    bitarray('00000000000100100100100100100100100100000000000000')\n    >>> del a[12::3]\n    >>> a\n    bitarray('0000000000010101010101010101000000000')\n    >>> a[-6:] = bitarray('10011')\n    >>> a\n    bitarray('000000000001010101010101010100010011')\n    >>> a += bitarray('000111')\n    >>> a[9:]\n    bitarray('001010101010101010100010011000111')\n\nin addition, slices can be assigned to booleans, which is easier (and\nfaster) than assigning to a bitarray in which all values are the same:\n\n.. code-block:: python\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = true\n    >>> a\n    bitarray('01001001001001000000')\n\nthis is easier and faster than:\n\n.. code-block:: python\n\n    >>> a = 20 * bitarray('0')\n    >>> a[1:15:3] = 5 * bitarray('1')\n    >>> a\n    bitarray('01001001001001000000')\n\nnote that in the latter we have to create a temporary bitarray whose length\nmust be known or calculated.  another example of assigning slices to booleans,\nis setting ranges:\n\n.. code-block:: python\n\n    >>> a = bitarray(30)\n    >>> a[:] = 0         # set all elements to 0 - equivalent to a.setall(0)\n    >>> a[10:25] = 1     # set elements in range(10, 25) to 1\n    >>> a\n    bitarray('000000000011111111111111100000')\n\nas of bitarray version 2.8, indices may also be lists of arbitrary\nindices (like in numpy), or bitarrays that are treated as masks,\nsee `bitarray indexing <https://github.com/ilanschnell/bitarray/blob/master/doc/indexing.rst>`__.\n\n\nbitwise operators\n-----------------\n\nbitarray objects support the bitwise operators ``~``, ``&``, ``|``, ``^``,\n``<<``, ``>>`` (as well as their in-place versions ``&=``, ``|=``, ``^=``,\n``<<=``, ``>>=``).  the behavior is very much what one would expect:\n\n.. code-block:: python\n\n    >>> a = bitarray('101110001')\n    >>> ~a  # invert\n    bitarray('010001110')\n    >>> b = bitarray('111001011')\n    >>> a ^ b\n    bitarray('010111010')\n    >>> a &= b\n    >>> a\n    bitarray('101000001')\n    >>> a <<= 2   # in-place left shift by 2\n    >>> a\n    bitarray('100000100')\n    >>> b >> 1\n    bitarray('011100101')\n\nthe c language does not specify the behavior of negative shifts and\nof left shifts larger or equal than the width of the promoted left operand.\nthe exact behavior is compiler/machine specific.\nthis python bitarray library specifies the behavior as follows:\n\n* the length of the bitarray is never changed by any shift operation\n* blanks are filled by 0\n* negative shifts raise ``valueerror``\n* shifts larger or equal to the length of the bitarray result in\n  bitarrays with all values 0\n\nit is worth noting that (regardless of bit-endianness) the bitarray left\nshift (``<<``) always shifts towards lower indices, and the right\nshift (``>>``) always shifts towards higher indices.\n\n\nbit-endianness\n--------------\n\nunless explicitly converting to machine representation, using\nthe ``.tobytes()``, ``.frombytes()``, ``.tofile()`` and ``.fromfile()``\nmethods, as well as using ``memoryview``, the bit-endianness will have no\neffect on any computation, and one can skip this section.\n\nsince bitarrays allows addressing individual bits, where the machine\nrepresents 8 bits in one byte, there are two obvious choices for this\nmapping: little-endian and big-endian.\n\nwhen dealing with the machine representation of bitarray objects, it is\nrecommended to always explicitly specify the endianness.\n\nby default, bitarrays use big-endian representation:\n\n.. code-block:: python\n\n    >>> a = bitarray()\n    >>> a.endian()\n    'big'\n    >>> a.frombytes(b'a')\n    >>> a\n    bitarray('01000001')\n    >>> a[6] = 1\n    >>> a.tobytes()\n    b'c'\n\nbig-endian means that the most-significant bit comes first.\nhere, ``a[0]`` is the lowest address (index) and most significant bit,\nand ``a[7]`` is the highest address and least significant bit.\n\nwhen creating a new bitarray object, the endianness can always be\nspecified explicitly:\n\n.. code-block:: python\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'a')\n    >>> a\n    bitarray('10000010')\n    >>> a.endian()\n    'little'\n\nhere, the low-bit comes first because little-endian means that increasing\nnumeric significance corresponds to an increasing address.\nso ``a[0]`` is the lowest address and least significant bit,\nand ``a[7]`` is the highest address and most significant bit.\n\nthe bit-endianness is a property of the bitarray object.\nthe endianness cannot be changed once a bitarray object is created.\nwhen comparing bitarray objects, the endianness (and hence the machine\nrepresentation) is irrelevant; what matters is the mapping from indices\nto bits:\n\n.. code-block:: python\n\n    >>> bitarray('11001', endian='big') == bitarray('11001', endian='little')\n    true\n\nbitwise operations (``|``, ``^``, ``&=``, ``|=``, ``^=``, ``~``) are\nimplemented efficiently using the corresponding byte operations in c, i.e. the\noperators act on the machine representation of the bitarray objects.\ntherefore, it is not possible to perform bitwise operators on bitarrays\nwith different endianness.\n\nwhen converting to and from machine representation, using\nthe ``.tobytes()``, ``.frombytes()``, ``.tofile()`` and ``.fromfile()``\nmethods, the endianness matters:\n\n.. code-block:: python\n\n    >>> a = bitarray(endian='little')\n    >>> a.frombytes(b'\\x01')\n    >>> a\n    bitarray('10000000')\n    >>> b = bitarray(endian='big')\n    >>> b.frombytes(b'\\x80')\n    >>> b\n    bitarray('10000000')\n    >>> a == b\n    true\n    >>> a.tobytes() == b.tobytes()\n    false\n\nas mentioned above, the endianness can not be changed once an object is\ncreated.  however, you can create a new bitarray with different endianness:\n\n.. code-block:: python\n\n    >>> a = bitarray('111000', endian='little')\n    >>> b = bitarray(a, endian='big')\n    >>> b\n    bitarray('111000')\n    >>> a == b\n    true\n\n\nbuffer protocol\n---------------\n\nbitarray objects support the buffer protocol.  they can both export their\nown buffer, as well as import another object's buffer.  to learn more about\nthis topic, please read `buffer protocol <https://github.com/ilanschnell/bitarray/blob/master/doc/buffer.rst>`__.  there is also an example that shows how\nto memory-map a file to a bitarray: `mmapped-file.py <https://github.com/ilanschnell/bitarray/blob/master/examples/mmapped-file.py>`__\n\n\nvariable bit length prefix codes\n--------------------------------\n\nthe ``.encode()`` method takes a dictionary mapping symbols to bitarrays\nand an iterable, and extends the bitarray object with the encoded symbols\nfound while iterating.  for example:\n\n.. code-block:: python\n\n    >>> d = {'h':bitarray('111'), 'e':bitarray('0'),\n    ...      'l':bitarray('110'), 'o':bitarray('10')}\n    ...\n    >>> a = bitarray()\n    >>> a.encode(d, 'hello')\n    >>> a\n    bitarray('111011011010')\n\nnote that the string ``'hello'`` is an iterable, but the symbols are not\nlimited to characters, in fact any immutable python object can be a symbol.\ntaking the same dictionary, we can apply the ``.decode()`` method which will\nreturn a list of the symbols:\n\n.. code-block:: python\n\n    >>> a.decode(d)\n    ['h', 'e', 'l', 'l', 'o']\n    >>> ''.join(a.decode(d))\n    'hello'\n\nsince symbols are not limited to being characters, it is necessary to return\nthem as elements of a list, rather than simply returning the joined string.\nthe above dictionary ``d`` can be efficiently constructed using the function\n``bitarray.util.huffman_code()``.  i also wrote `huffman coding in python\nusing bitarray <http://ilan.schnell-web.net/prog/huffman/>`__ for more\nbackground information.\n\nwhen the codes are large, and you have many decode calls, most time will\nbe spent creating the (same) internal decode tree objects.  in this case,\nit will be much faster to create a ``decodetree`` object, which can be\npassed to bitarray's ``.decode()`` and ``.iterdecode()`` methods, instead\nof passing the prefix code dictionary to those methods itself:\n\n.. code-block:: python\n\n    >>> from bitarray import bitarray, decodetree\n    >>> t = decodetree({'a': bitarray('0'), 'b': bitarray('1')})\n    >>> a = bitarray('0110')\n    >>> a.decode(t)\n    ['a', 'b', 'b', 'a']\n    >>> ''.join(a.iterdecode(t))\n    'abba'\n\nthe sole purpose of the immutable ``decodetree`` object is to be passed\nto bitarray's ``.decode()`` and ``.iterdecode()`` methods.\n\n\nfrozenbitarrays\n---------------\n\na ``frozenbitarray`` object is very similar to the bitarray object.\nthe difference is that this a ``frozenbitarray`` is immutable, and hashable,\nand can therefore be used as a dictionary key:\n\n.. code-block:: python\n\n    >>> from bitarray import frozenbitarray\n    >>> key = frozenbitarray('1100011')\n    >>> {key: 'some value'}\n    {frozenbitarray('1100011'): 'some value'}\n    >>> key[3] = 1\n    traceback (most recent call last):\n        ...\n    typeerror: frozenbitarray is immutable\n\n\nreference\n=========\n\nbitarray version: 2.9.1 -- `change log <https://github.com/ilanschnell/bitarray/blob/master/doc/changelog.rst>`__\n\nin the following, ``item`` and ``value`` are usually a single bit -\nan integer 0 or 1.\n\nalso, ``sub_bitarray`` refers to either a bitarray, or an ``item``.\n\n\nthe bitarray object:\n--------------------\n\n``bitarray(initializer=0, /, endian='big', buffer=none)`` -> bitarray\n   return a new bitarray object whose items are bits initialized from\n   the optional initial object, and endianness.\n   the initializer may be of the following types:\n\n   ``int``: create a bitarray of given integer length.  the initial values are\n   all ``0``.\n\n   ``str``: create bitarray from a string of ``0`` and ``1``.\n\n   ``iterable``: create bitarray from iterable or sequence of integers 0 or 1.\n\n   optional keyword arguments:\n\n   ``endian``: specifies the bit-endianness of the created bitarray object.\n   allowed values are ``big`` and ``little`` (the default is ``big``).\n   the bit-endianness effects the buffer representation of the bitarray.\n\n   ``buffer``: any object which exposes a buffer.  when provided, ``initializer``\n   cannot be present (or has to be ``none``).  the imported buffer may be\n   read-only or writable, depending on the object type.\n\n   new in version 2.3: optional ``buffer`` argument.\n\n\nbitarray methods:\n-----------------\n\n``all()`` -> bool\n   return true when all bits in bitarray are true.\n   note that ``a.all()`` is faster than ``all(a)``.\n\n\n``any()`` -> bool\n   return true when any bit in bitarray is true.\n   note that ``a.any()`` is faster than ``any(a)``.\n\n\n``append(item, /)``\n   append ``item`` to the end of the bitarray.\n\n\n``buffer_info()`` -> tuple\n   return a tuple containing:\n\n   0. memory address of buffer\n   1. buffer size (in bytes)\n   2. bit-endianness as a string\n   3. number of pad bits\n   4. allocated memory for the buffer (in bytes)\n   5. memory is read-only\n   6. buffer is imported\n   7. number of buffer exports\n\n\n``bytereverse(start=0, stop=<end of buffer>, /)``\n   for each byte in byte-range(start, stop) reverse bits in-place.\n   the start and stop indices are given in terms of bytes (not bits).\n   also note that this method only changes the buffer; it does not change the\n   endianness of the bitarray object.  padbits are left unchanged such that\n   two consecutive calls will always leave the bitarray unchanged.\n\n   new in version 2.2.5: optional start and stop arguments.\n\n\n``clear()``\n   remove all items from the bitarray.\n\n   new in version 1.4.\n\n\n``copy()`` -> bitarray\n   return a copy of the bitarray.\n\n\n``count(value=1, start=0, stop=<end>, step=1, /)`` -> int\n   number of occurrences of ``value`` bitarray within ``[start:stop:step]``.\n   optional arguments ``start``, ``stop`` and ``step`` are interpreted in\n   slice notation, meaning ``a.count(value, start, stop, step)`` equals\n   ``a[start:stop:step].count(value)``.\n   the ``value`` may also be a sub-bitarray.  in this case non-overlapping\n   occurrences are counted within ``[start:stop]`` (``step`` must be 1).\n\n   new in version 1.1.0: optional start and stop arguments.\n\n   new in version 2.3.7: optional step argument.\n\n   new in version 2.9: add non-overlapping sub-bitarray count.\n\n\n``decode(code, /)`` -> list\n   given a prefix code (a dict mapping symbols to bitarrays, or ``decodetree``\n   object), decode content of bitarray and return it as a list of symbols.\n\n\n``encode(code, iterable, /)``\n   given a prefix code (a dict mapping symbols to bitarrays),\n   iterate over the iterable object with symbols, and extend bitarray\n   with corresponding bitarray for each symbol.\n\n\n``endian()`` -> str\n   return the bit-endianness of the bitarray as a string (``little`` or ``big``).\n\n\n``extend(iterable, /)``\n   append all items from ``iterable`` to the end of the bitarray.\n   if the iterable is a string, each ``0`` and ``1`` are appended as\n   bits (ignoring whitespace and underscore).\n\n\n``fill()`` -> int\n   add zeros to the end of the bitarray, such that the length will be\n   a multiple of 8, and return the number of bits added [0..7].\n\n\n``find(sub_bitarray, start=0, stop=<end>, /, right=false)`` -> int\n   return lowest (or rightmost when ``right=true``) index where sub_bitarray\n   is found, such that sub_bitarray is contained within ``[start:stop]``.\n   return -1 when sub_bitarray is not found.\n\n   new in version 2.1.\n\n   new in version 2.9: add optional keyword argument ``right``.\n\n\n``frombytes(bytes, /)``\n   extend bitarray with raw bytes from a bytes-like object.\n   each added byte will add eight bits to the bitarray.\n\n   new in version 2.5.0: allow bytes-like argument.\n\n\n``fromfile(f, n=-1, /)``\n   extend bitarray with up to ``n`` bytes read from file object ``f`` (or any\n   other binary stream what supports a ``.read()`` method, e.g. ``io.bytesio``).\n   each read byte will add eight bits to the bitarray.  when ``n`` is omitted or\n   negative, all bytes until eof are read.  when ``n`` is non-negative but\n   exceeds the data available, ``eoferror`` is raised (but the available data\n   is still read and appended).\n\n\n``index(sub_bitarray, start=0, stop=<end>, /, right=false)`` -> int\n   return lowest (or rightmost when ``right=true``) index where sub_bitarray\n   is found, such that sub_bitarray is contained within ``[start:stop]``.\n   raises ``valueerror`` when the sub_bitarray is not present.\n\n   new in version 2.9: add optional keyword argument ``right``.\n\n\n``insert(index, value, /)``\n   insert ``value`` into bitarray before ``index``.\n\n\n``invert(index=<all bits>, /)``\n   invert all bits in bitarray (in-place).\n   when the optional ``index`` is given, only invert the single bit at index.\n\n   new in version 1.5.3: optional index argument.\n\n\n``iterdecode(code, /)`` -> iterator\n   given a prefix code (a dict mapping symbols to bitarrays, or ``decodetree``\n   object), decode content of bitarray and return an iterator over\n   the symbols.\n\n\n``itersearch(sub_bitarray, start=0, stop=<end>, /, right=false)`` -> iterator\n   return iterator over indices where sub_bitarray is found, such that\n   sub_bitarray is contained within ``[start:stop]``.\n   the indices are iterated in ascending order (from lowest to highest),\n   unless ``right=true``, which will iterate in descending oder (starting with\n   rightmost match).\n\n   new in version 2.9: optional start and stop arguments - add optional keyword argument ``right``.\n\n\n``pack(bytes, /)``\n   extend bitarray from a bytes-like object, where each byte corresponds\n   to a single bit.  the byte ``b'\\x00'`` maps to bit 0 and all other bytes\n   map to bit 1.\n\n   this method, as well as the ``.unpack()`` method, are meant for efficient\n   transfer of data between bitarray objects to other python objects (for\n   example numpy's ndarray object) which have a different memory view.\n\n   new in version 2.5.0: allow bytes-like argument.\n\n\n``pop(index=-1, /)`` -> item\n   remove and return item at ``index`` (default last).\n   raises ``indexerror`` if index is out of range.\n\n\n``remove(value, /)``\n   remove the first occurrence of ``value``.\n   raises ``valueerror`` if value is not present.\n\n\n``reverse()``\n   reverse all bits in bitarray (in-place).\n\n\n``search(sub_bitarray, limit=<none>, /)`` -> list\n   searches for given sub_bitarray in self, and return list of start\n   positions.\n   the optional argument limits the number of search results to the integer\n   specified.  by default, all search results are returned.\n\n\n``setall(value, /)``\n   set all elements in bitarray to ``value``.\n   note that ``a.setall(value)`` is equivalent to ``a[:] = value``.\n\n\n``sort(reverse=false)``\n   sort all bits in bitarray (in-place).\n\n\n``to01()`` -> str\n   return a string containing '0's and '1's, representing the bits in the\n   bitarray.\n\n\n``tobytes()`` -> bytes\n   return the bitarray buffer in bytes (pad bits are set to zero).\n\n\n``tofile(f, /)``\n   write byte representation of bitarray to file object f.\n\n\n``tolist()`` -> list\n   return bitarray as list of integer items.\n   ``a.tolist()`` is equal to ``list(a)``.\n\n   note that the list object being created will require 32 or 64 times more\n   memory (depending on the machine architecture) than the bitarray object,\n   which may cause a memory error if the bitarray is very large.\n\n\n``unpack(zero=b'\\x00', one=b'\\x01')`` -> bytes\n   return bytes containing one character for each bit in the bitarray,\n   using specified mapping.\n\n\nbitarray data descriptors:\n--------------------------\n\ndata descriptors were added in version 2.6.\n\n``nbytes`` -> int\n   buffer size in bytes\n\n\n``padbits`` -> int\n   number of pad bits\n\n\n``readonly`` -> bool\n   bool indicating whether buffer is read-only\n\n\nother objects:\n--------------\n\n``frozenbitarray(initializer=0, /, endian='big', buffer=none)`` -> frozenbitarray\n   return a ``frozenbitarray`` object.  initialized the same way a ``bitarray``\n   object is initialized.  a ``frozenbitarray`` is immutable and hashable,\n   and may therefore be used as a dictionary key.\n\n   new in version 1.1.\n\n\n``decodetree(code, /)`` -> decodetree\n   given a prefix code (a dict mapping symbols to bitarrays),\n   create a binary tree object to be passed to ``.decode()`` or ``.iterdecode()``.\n\n   new in version 1.6.\n\n\nfunctions defined in the `bitarray` module:\n-------------------------------------------\n\n``bits2bytes(n, /)`` -> int\n   return the number of bytes necessary to store n bits.\n\n\n``get_default_endian()`` -> str\n   return the default endianness for new bitarray objects being created.\n   unless ``_set_default_endian('little')`` was called, the default endianness\n   is ``big``.\n\n   new in version 1.3.\n\n\n``test(verbosity=1)`` -> texttestresult\n   run self-test, and return unittest.runner.texttestresult object.\n\n\nfunctions defined in `bitarray.util` module:\n--------------------------------------------\n\nthis sub-module was added in version 1.2.\n\n``zeros(length, /, endian=none)`` -> bitarray\n   create a bitarray of length, with all values 0, and optional\n   endianness, which may be 'big', 'little'.\n\n\n``ones(length, /, endian=none)`` -> bitarray\n   create a bitarray of length, with all values 1, and optional\n   endianness, which may be 'big', 'little'.\n\n   new in version 2.9.\n\n\n``urandom(length, /, endian=none)`` -> bitarray\n   return a bitarray of ``length`` random bits (uses ``os.urandom``).\n\n   new in version 1.7.\n\n\n``pprint(bitarray, /, stream=none, group=8, indent=4, width=80)``\n   prints the formatted representation of object on ``stream`` (which defaults\n   to ``sys.stdout``).  by default, elements are grouped in bytes (8 elements),\n   and 8 bytes (64 elements) per line.\n   non-bitarray objects are printed by the standard library\n   function ``pprint.pprint()``.\n\n   new in version 1.8.\n\n\n``make_endian(bitarray, /, endian)`` -> bitarray\n   when the endianness of the given bitarray is different from ``endian``,\n   return a new bitarray, with endianness ``endian`` and the same elements\n   as the original bitarray.\n   otherwise (endianness is already ``endian``) the original bitarray is returned\n   unchanged.\n\n   new in version 1.3.\n\n   new in version 2.9: deprecated - use ``bitarray()``.\n\n\n``rindex(bitarray, sub_bitarray=1, start=0, stop=<end>, /)`` -> int\n   return rightmost (highest) index where sub_bitarray (or item - defaults\n   to 1) is found in bitarray (``a``), such that sub_bitarray is contained\n   within ``a[start:stop]``.\n   raises ``valueerror`` when the sub_bitarray is not present.\n\n   new in version 2.3.0: optional start and stop arguments.\n\n   new in version 2.9: deprecated - use ``.index(..., right=1)``.\n\n\n``strip(bitarray, /, mode='right')`` -> bitarray\n   return a new bitarray with zeros stripped from left, right or both ends.\n   allowed values for mode are the strings: ``left``, ``right``, ``both``\n\n\n``count_n(a, n, value=1, /)`` -> int\n   return lowest index ``i`` for which ``a[:i].count(value) == n``.\n   raises ``valueerror`` when ``n`` exceeds total count (``a.count(value)``).\n\n   new in version 2.3.6: optional value argument.\n\n\n``parity(a, /)`` -> int\n   return parity of bitarray ``a``.\n   ``parity(a)`` is equivalent to ``a.count() % 2`` but more efficient.\n\n   new in version 1.9.\n\n\n``count_and(a, b, /)`` -> int\n   return ``(a & b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n\n``count_or(a, b, /)`` -> int\n   return ``(a | b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n\n``count_xor(a, b, /)`` -> int\n   return ``(a ^ b).count()`` in a memory efficient manner,\n   as no intermediate bitarray object gets created.\n\n   this is also known as the hamming distance.\n\n\n``any_and(a, b, /)`` -> bool\n   efficient implementation of ``any(a & b)``.\n\n   new in version 2.7.\n\n\n``subset(a, b, /)`` -> bool\n   return ``true`` if bitarray ``a`` is a subset of bitarray ``b``.\n   ``subset(a, b)`` is equivalent to ``a | b == b`` (and equally ``a & b == a``) but\n   more efficient as no intermediate bitarray object is created and the buffer\n   iteration is stopped as soon as one mismatch is found.\n\n\n``intervals(bitarray, /)`` -> iterator\n   compute all uninterrupted intervals of 1s and 0s, and return an\n   iterator over tuples ``(value, start, stop)``.  the intervals are guaranteed\n   to be in order, and their size is always non-zero (``stop - start > 0``).\n\n   new in version 2.7.\n\n\n``ba2hex(bitarray, /)`` -> hexstr\n   return a string containing the hexadecimal representation of\n   the bitarray (which has to be multiple of 4 in length).\n\n\n``hex2ba(hexstr, /, endian=none)`` -> bitarray\n   bitarray of hexadecimal representation.  hexstr may contain any number\n   (including odd numbers) of hex digits (upper or lower case).\n\n\n``ba2base(n, bitarray, /)`` -> str\n   return a string containing the base ``n`` ascii representation of\n   the bitarray.  allowed values for ``n`` are 2, 4, 8, 16, 32 and 64.\n   the bitarray has to be multiple of length 1, 2, 3, 4, 5 or 6 respectively.\n   for ``n=16`` (hexadecimal), ``ba2hex()`` will be much faster, as ``ba2base()``\n   does not take advantage of byte level operations.\n   for ``n=32`` the rfc 4648 base32 alphabet is used, and for ``n=64`` the\n   standard base 64 alphabet is used.\n\n   see also: `bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   new in version 1.9.\n\n\n``base2ba(n, asciistr, /, endian=none)`` -> bitarray\n   bitarray of base ``n`` ascii representation.\n   allowed values for ``n`` are 2, 4, 8, 16, 32 and 64.\n   for ``n=16`` (hexadecimal), ``hex2ba()`` will be much faster, as ``base2ba()``\n   does not take advantage of byte level operations.\n   for ``n=32`` the rfc 4648 base32 alphabet is used, and for ``n=64`` the\n   standard base 64 alphabet is used.\n\n   see also: `bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   new in version 1.9.\n\n\n``ba2int(bitarray, /, signed=false)`` -> int\n   convert the given bitarray to an integer.\n   the bit-endianness of the bitarray is respected.\n   ``signed`` indicates whether two's complement is used to represent the integer.\n\n\n``int2ba(int, /, length=none, endian=none, signed=false)`` -> bitarray\n   convert the given integer to a bitarray (with given endianness,\n   and no leading (big-endian) / trailing (little-endian) zeros), unless\n   the ``length`` of the bitarray is provided.  an ``overflowerror`` is raised\n   if the integer is not representable with the given number of bits.\n   ``signed`` determines whether two's complement is used to represent the integer,\n   and requires ``length`` to be provided.\n\n\n``serialize(bitarray, /)`` -> bytes\n   return a serialized representation of the bitarray, which may be passed to\n   ``deserialize()``.  it efficiently represents the bitarray object (including\n   its bit-endianness) and is guaranteed not to change in future releases.\n\n   see also: `bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   new in version 1.8.\n\n\n``deserialize(bytes, /)`` -> bitarray\n   return a bitarray given a bytes-like representation such as returned\n   by ``serialize()``.\n\n   see also: `bitarray representations <https://github.com/ilanschnell/bitarray/blob/master/doc/represent.rst>`__\n\n   new in version 1.8.\n\n   new in version 2.5.0: allow bytes-like argument.\n\n\n``sc_encode(bitarray, /)`` -> bytes\n   compress a sparse bitarray and return its binary representation.\n   this representation is useful for efficiently storing sparse bitarrays.\n   use ``sc_decode()`` for decompressing (decoding).\n\n   see also: `compression of sparse bitarrays <https://github.com/ilanschnell/bitarray/blob/master/doc/sparse_compression.rst>`__\n\n   new in version 2.7.\n\n\n``sc_decode(stream)`` -> bitarray\n   decompress binary stream (an integer iterator, or bytes-like object) of a\n   sparse compressed (``sc``) bitarray, and return the decoded  bitarray.\n   this function consumes only one bitarray and leaves the remaining stream\n   untouched.  use ``sc_encode()`` for compressing (encoding).\n\n   see also: `compression of sparse bitarrays <https://github.com/ilanschnell/bitarray/blob/master/doc/sparse_compression.rst>`__\n\n   new in version 2.7.\n\n\n``vl_encode(bitarray, /)`` -> bytes\n   return variable length binary representation of bitarray.\n   this representation is useful for efficiently storing small bitarray\n   in a binary stream.  use ``vl_decode()`` for decoding.\n\n   see also: `variable length bitarray format <https://github.com/ilanschnell/bitarray/blob/master/doc/variable_length.rst>`__\n\n   new in version 2.2.\n\n\n``vl_decode(stream, /, endian=none)`` -> bitarray\n   decode binary stream (an integer iterator, or bytes-like object), and\n   return the decoded bitarray.  this function consumes only one bitarray and\n   leaves the remaining stream untouched.  use ``vl_encode()`` for encoding.\n\n   see also: `variable length bitarray format <https://github.com/ilanschnell/bitarray/blob/master/doc/variable_length.rst>`__\n\n   new in version 2.2.\n\n\n``huffman_code(dict, /, endian=none)`` -> dict\n   given a frequency map, a dictionary mapping symbols to their frequency,\n   calculate the huffman code, i.e. a dict mapping those symbols to\n   bitarrays (with given endianness).  note that the symbols are not limited\n   to being strings.  symbols may may be any hashable object (such as ``none``).\n\n\n``canonical_huffman(dict, /)`` -> tuple\n   given a frequency map, a dictionary mapping symbols to their frequency,\n   calculate the canonical huffman code.  returns a tuple containing:\n\n   0. the canonical huffman code as a dict mapping symbols to bitarrays\n   1. a list containing the number of symbols of each code length\n   2. a list of symbols in canonical order\n\n   note: the two lists may be used as input for ``canonical_decode()``.\n\n   see also: `canonical huffman coding <https://github.com/ilanschnell/bitarray/blob/master/doc/canonical.rst>`__\n\n   new in version 2.5.\n\n\n``canonical_decode(bitarray, count, symbol, /)`` -> iterator\n   decode bitarray using canonical huffman decoding tables\n   where ``count`` is a sequence containing the number of symbols of each length\n   and ``symbol`` is a sequence of symbols in canonical order.\n\n   see also: `canonical huffman coding <https://github.com/ilanschnell/bitarray/blob/master/doc/canonical.rst>`__\n\n   new in version 2.5.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "psf",
  "name": "bitarray",
  "package_url": "https://pypi.org/project/bitarray/",
  "project_url": "https://pypi.org/project/bitarray/",
  "project_urls": {
    "Homepage": "https://github.com/ilanschnell/bitarray"
  },
  "release_url": "https://pypi.org/project/bitarray/2.9.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "efficient arrays of booleans -- c extension",
  "version": "2.9.1",
  "releases": [],
  "developers": [
    "ilan_schnell",
    "ilanschnell@gmail.com"
  ],
  "kwds": "bitarrays bitarray sub_bitarray bitarrayobject binary",
  "license_kwds": "psf",
  "libtype": "pypi",
  "id": "pypi_bitarray",
  "homepage": "https://github.com/ilanschnell/bitarray",
  "release_count": 95,
  "dependency_ids": []
}