{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "[![build status](https://github.com/py-why/econml/actions/workflows/ci.yml/badge.svg)](https://github.com/py-why/econml/actions/workflows/ci.yml)\n[![pypi version](https://img.shields.io/pypi/v/econml.svg)](https://pypi.org/project/econml/)\n[![pypi wheel](https://img.shields.io/pypi/wheel/econml.svg)](https://pypi.org/project/econml/)\n[![supported python versions](https://img.shields.io/pypi/pyversions/econml.svg)](https://pypi.org/project/econml/)\n\n\n\n<h1><img src=\"doc/econml-logo-icon.png\" width=\"80px\" align=\"left\" style=\"margin-right: 10px;\"> econml: a python package for ml-based heterogeneous treatment effects estimation</h1>\n\n**econml** is a python package for estimating heterogeneous treatment effects from observational data via machine learning. this package was designed and built as part of the [alice project](https://www.microsoft.com/en-us/research/project/alice/) at microsoft research with the goal to combine state-of-the-art machine learning \ntechniques with econometrics to bring automation to complex causal inference problems. the promise of econml:\n\n* implement recent techniques in the literature at the intersection of econometrics and machine learning\n* maintain flexibility in modeling the effect heterogeneity (via techniques such as random forests, boosting, lasso and neural nets), while preserving the causal interpretation of the learned model and often offering valid confidence intervals\n* use a unified api\n* build on standard python packages for machine learning and data analysis\n\none of the biggest promises of machine learning is to automate decision making in a multitude of domains. at the core of many data-driven personalized decision scenarios is the estimation of heterogeneous treatment effects: what is the causal effect of an intervention on an outcome of interest for a sample with a particular set of features? in a nutshell, this toolkit is designed to measure the causal effect of some treatment variable(s) `t` on an outcome \nvariable `y`, controlling for a set of features `x, w` and how does that effect vary as a function of `x`. the methods implemented are applicable even with observational (non-experimental or historical) datasets. for the estimation results to have a causal interpretation, some methods assume no unobserved confounders (i.e. there is no unobserved variable not included in `x, w` that simultaneously has an effect on both `t` and `y`), while others assume access to an instrument `z` (i.e. an observed variable `z` that has an effect on the treatment `t` but no direct effect on the outcome `y`). most methods provide confidence intervals and inference results.\n\nfor detailed information about the package, consult the documentation at https://econml.azurewebsites.net/.\n\nfor information on use cases and background material on causal inference and heterogeneous treatment effects see our webpage at https://www.microsoft.com/en-us/research/project/econml/\n\n<details>\n<summary><strong><em>table of contents</em></strong></summary>\n\n- [news](#news)\n- [getting started](#getting-started)\n  - [installation](#installation)\n  - [usage examples](#usage-examples)\n    - [estimation methods](#estimation-methods)\n    - [interpretability](#interpretability)\n    - [causal model selection and cross-validation](#causal-model-selection-and-cross-validation)\n    - [inference](#inference)\n    - [policy learning](#policy-learning)\n- [for developers](#for-developers)\n  - [running the tests](#running-the-tests)\n  - [generating the documentation](#generating-the-documentation)\n- [blogs and publications](#blogs-and-publications)\n- [citation](#citation)\n- [contributing and feedback](#contributing-and-feedback)\n- [references](#references)\n\n</details>\n\n# news\n\n**may 19, 2023:** release v0.14.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.14.1)\n\n<details><summary>previous releases</summary>\n\n**november 16, 2022:** release v0.14.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.14.0)\n\n**june 17, 2022:** release v0.13.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.13.1)\n\n**january 31, 2022:** release v0.13.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.13.0)\n\n**august 13, 2021:** release v0.12.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0)\n\n**august 5, 2021:** release v0.12.0b6, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b6)\n\n**august 3, 2021:** release v0.12.0b5, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b5)\n\n**july 9, 2021:** release v0.12.0b4, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b4)\n\n**june 25, 2021:** release v0.12.0b3, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b3)\n\n**june 18, 2021:** release v0.12.0b2, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b2)\n\n**june 7, 2021:** release v0.12.0b1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.12.0b1)\n\n**may 18, 2021:** release v0.11.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.11.1)\n\n**may 8, 2021:** release v0.11.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.11.0)\n\n**march 22, 2021:** release v0.10.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.10.0)\n\n**march 11, 2021:** release v0.9.2, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.9.2)\n\n**march 3, 2021:** release v0.9.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.9.1)\n\n**february 20, 2021:** release v0.9.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.9.0)\n\n**january 20, 2021:** release v0.9.0b1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.9.0b1)\n\n**november 20, 2020:** release v0.8.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.8.1)\n\n**november 18, 2020:** release v0.8.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.8.0)\n\n**september 4, 2020:** release v0.8.0b1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.8.0b1)\n\n**march 6, 2020:** release v0.7.0, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.7.0)\n\n**february 18, 2020:** release v0.7.0b1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.7.0b1)\n\n**january 10, 2020:** release v0.6.1, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.6.1)\n\n**december 6, 2019:** release v0.6, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.6)\n\n**november 21, 2019:** release v0.5, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.5). \n\n**june 3, 2019:** release v0.4, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.4). \n\n**may 3, 2019:** release v0.3, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.3).\n\n**april 10, 2019:** release v0.2, see release notes [here](https://github.com/py-why/econml/releases/tag/v0.2).\n\n**march 6, 2019:** release v0.1, welcome to have a try and provide feedback.\n\n</details>\n\n# getting started\n\n## installation\n\ninstall the latest release from [pypi](https://pypi.org/project/econml/):\n```\npip install econml\n```\nto install from source, see [for developers](#for-developers) section below.\n\n## usage examples\n### estimation methods\n\n<details>\n  <summary>double machine learning (aka rlearner) (click to expand)</summary>\n\n  * linear final stage\n\n  ```python\n  from econml.dml import lineardml\n  from sklearn.linear_model import lassocv\n  from econml.inference import bootstrapinference\n\n  est = lineardml(model_y=lassocv(), model_t=lassocv())\n  ### estimate with ols confidence intervals\n  est.fit(y, t, x=x, w=w) # w -> high-dimensional confounders, x -> features\n  treatment_effects = est.effect(x_test)\n  lb, ub = est.effect_interval(x_test, alpha=0.05) # ols confidence intervals\n\n  ### estimate with bootstrap confidence intervals\n  est.fit(y, t, x=x, w=w, inference='bootstrap')  # with default bootstrap parameters\n  est.fit(y, t, x=x, w=w, inference=bootstrapinference(n_bootstrap_samples=100))  # or customized\n  lb, ub = est.effect_interval(x_test, alpha=0.05) # bootstrap confidence intervals\n  ```\n\n  * sparse linear final stage\n\n  ```python\n  from econml.dml import sparselineardml\n  from sklearn.linear_model import lassocv\n\n  est = sparselineardml(model_y=lassocv(), model_t=lassocv())\n  est.fit(y, t, x=x, w=w) # x -> high dimensional features\n  treatment_effects = est.effect(x_test)\n  lb, ub = est.effect_interval(x_test, alpha=0.05) # confidence intervals via debiased lasso\n  ```\n\n  * generic machine learning last stage\n  \n  ```python\n  from econml.dml import nonparamdml\n  from sklearn.ensemble import randomforestregressor, randomforestclassifier\n\n  est = nonparamdml(model_y=randomforestregressor(),\n                    model_t=randomforestclassifier(),\n                    model_final=randomforestregressor(),\n                    discrete_treatment=true)\n  est.fit(y, t, x=x, w=w) \n  treatment_effects = est.effect(x_test)\n  ```\n\n</details>\n\n<details>\n  <summary>dynamic double machine learning (click to expand)</summary>\n\n  ```python\n  from econml.panel.dml import dynamicdml\n  # use defaults\n  est = dynamicdml()\n  # or specify hyperparameters\n  est = dynamicdml(model_y=lassocv(cv=3), \n                   model_t=lassocv(cv=3), \n                   cv=3)\n  est.fit(y, t, x=x, w=none, groups=groups, inference=\"auto\")\n  # effects\n  treatment_effects = est.effect(x_test)\n  # confidence intervals\n  lb, ub = est.effect_interval(x_test, alpha=0.05)\n  ```\n</details>\n\n<details>\n  <summary>causal forests (click to expand)</summary>\n\n  ```python\n  from econml.dml import causalforestdml\n  from sklearn.linear_model import lassocv\n  # use defaults\n  est = causalforestdml()\n  # or specify hyperparameters\n  est = causalforestdml(criterion='het', n_estimators=500,       \n                        min_samples_leaf=10, \n                        max_depth=10, max_samples=0.5,\n                        discrete_treatment=false,\n                        model_t=lassocv(), model_y=lassocv())\n  est.fit(y, t, x=x, w=w)\n  treatment_effects = est.effect(x_test)\n  # confidence intervals via bootstrap-of-little-bags for forests\n  lb, ub = est.effect_interval(x_test, alpha=0.05)\n  ```\n</details>\n\n\n<details>\n  <summary>orthogonal random forests (click to expand)</summary>\n\n  ```python\n  from econml.orf import dmlorthoforest, drorthoforest\n  from econml.sklearn_extensions.linear_model import weightedlasso, weightedlassocv\n  # use defaults\n  est = dmlorthoforest()\n  est = drorthoforest()\n  # or specify hyperparameters\n  est = dmlorthoforest(n_trees=500, min_leaf_size=10,\n                       max_depth=10, subsample_ratio=0.7,\n                       lambda_reg=0.01,\n                       discrete_treatment=false,\n                       model_t=weightedlasso(alpha=0.01), model_y=weightedlasso(alpha=0.01),\n                       model_t_final=weightedlassocv(cv=3), model_y_final=weightedlassocv(cv=3))\n  est.fit(y, t, x=x, w=w)\n  treatment_effects = est.effect(x_test)\n  # confidence intervals via bootstrap-of-little-bags for forests\n  lb, ub = est.effect_interval(x_test, alpha=0.05)\n  ```\n</details>\n\n<details>\n\n<summary>meta-learners (click to expand)</summary>\n  \n  * xlearner\n\n  ```python\n  from econml.metalearners import xlearner\n  from sklearn.ensemble import gradientboostingclassifier, gradientboostingregressor\n\n  est = xlearner(models=gradientboostingregressor(),\n                propensity_model=gradientboostingclassifier(),\n                cate_models=gradientboostingregressor())\n  est.fit(y, t, x=np.hstack([x, w]))\n  treatment_effects = est.effect(np.hstack([x_test, w_test]))\n\n  # fit with bootstrap confidence interval construction enabled\n  est.fit(y, t, x=np.hstack([x, w]), inference='bootstrap')\n  treatment_effects = est.effect(np.hstack([x_test, w_test]))\n  lb, ub = est.effect_interval(np.hstack([x_test, w_test]), alpha=0.05) # bootstrap cis\n  ```\n  \n  * slearner\n\n  ```python\n  from econml.metalearners import slearner\n  from sklearn.ensemble import gradientboostingregressor\n\n  est = slearner(overall_model=gradientboostingregressor())\n  est.fit(y, t, x=np.hstack([x, w]))\n  treatment_effects = est.effect(np.hstack([x_test, w_test]))\n  ```\n\n  * tlearner\n\n  ```python\n  from econml.metalearners import tlearner\n  from sklearn.ensemble import gradientboostingregressor\n\n  est = tlearner(models=gradientboostingregressor())\n  est.fit(y, t, x=np.hstack([x, w]))\n  treatment_effects = est.effect(np.hstack([x_test, w_test]))\n  ```\n</details>\n\n<details>\n<summary>doubly robust learners (click to expand)\n</summary>\n\n* linear final stage\n\n```python\nfrom econml.dr import lineardrlearner\nfrom sklearn.ensemble import gradientboostingregressor, gradientboostingclassifier\n\nest = lineardrlearner(model_propensity=gradientboostingclassifier(),\n                      model_regression=gradientboostingregressor())\nest.fit(y, t, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05)\n```\n\n* sparse linear final stage\n\n```python\nfrom econml.dr import sparselineardrlearner\nfrom sklearn.ensemble import gradientboostingregressor, gradientboostingclassifier\n\nest = sparselineardrlearner(model_propensity=gradientboostingclassifier(),\n                            model_regression=gradientboostingregressor())\nest.fit(y, t, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05)\n```\n\n* nonparametric final stage\n\n```python\nfrom econml.dr import forestdrlearner\nfrom sklearn.ensemble import gradientboostingregressor, gradientboostingclassifier\n\nest = forestdrlearner(model_propensity=gradientboostingclassifier(),\n                      model_regression=gradientboostingregressor())\nest.fit(y, t, x=x, w=w) \ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05)\n```\n</details>\n\n<details>\n<summary>double machine learning with instrumental variables (click to expand)</summary>\n\n* orthogonal instrumental variable learner\n\n```python\nfrom econml.iv.dml import orthoiv\n\nest = orthoiv(projection=false, \n              discrete_treatment=true, \n              discrete_instrument=true)\nest.fit(y, t, z=z, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05) # ols confidence intervals\n```\n* nonparametric double machine learning with instrumental variable\n\n```python\nfrom econml.iv.dml import nonparamdmliv\n\nest = nonparamdmliv(projection=false, \n                    discrete_treatment=true, \n                    discrete_instrument=true)\nest.fit(y, t, z=z, x=x, w=w) # no analytical confidence interval available\ntreatment_effects = est.effect(x_test)\n```\n</details>\n\n<details>\n<summary>doubly robust machine learning with instrumental variables (click to expand)</summary>\n\n* linear final stage\n```python\nfrom econml.iv.dr import lineardriv\n\nest = lineardriv(discrete_instrument=true, discrete_treatment=true)\nest.fit(y, t, z=z, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05) # ols confidence intervals\n```\n\n* sparse linear final stage\n\n```python\nfrom econml.iv.dr import sparselineardriv\n\nest = sparselineardriv(discrete_instrument=true, discrete_treatment=true)\nest.fit(y, t, z=z, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05) # debiased lasso confidence intervals\n```\n\n* nonparametric final stage\n```python\nfrom econml.iv.dr import forestdriv\n\nest = forestdriv(discrete_instrument=true, discrete_treatment=true)\nest.fit(y, t, z=z, x=x, w=w)\ntreatment_effects = est.effect(x_test)\n# confidence intervals via bootstrap-of-little-bags for forests\nlb, ub = est.effect_interval(x_test, alpha=0.05) \n```\n\n* linear intent-to-treat (discrete instrument, discrete treatment)\n\n```python\nfrom econml.iv.dr import linearintenttotreatdriv\nfrom sklearn.ensemble import gradientboostingregressor, gradientboostingclassifier\n\nest = linearintenttotreatdriv(model_y_xw=gradientboostingregressor(),\n                              model_t_xwz=gradientboostingclassifier(),\n                              flexible_model_effect=gradientboostingregressor())\nest.fit(y, t, z=z, x=x, w=w)\ntreatment_effects = est.effect(x_test)\nlb, ub = est.effect_interval(x_test, alpha=0.05) # ols confidence intervals\n```\n</details>\n\n<details>\n<summary>deep instrumental variables (click to expand)</summary>\n\n```python\nimport keras\nfrom econml.iv.nnet import deepiv\n\ntreatment_model = keras.sequential([keras.layers.dense(128, activation='relu', input_shape=(2,)),\n                                    keras.layers.dropout(0.17),\n                                    keras.layers.dense(64, activation='relu'),\n                                    keras.layers.dropout(0.17),\n                                    keras.layers.dense(32, activation='relu'),\n                                    keras.layers.dropout(0.17)])\nresponse_model = keras.sequential([keras.layers.dense(128, activation='relu', input_shape=(2,)),\n                                  keras.layers.dropout(0.17),\n                                  keras.layers.dense(64, activation='relu'),\n                                  keras.layers.dropout(0.17),\n                                  keras.layers.dense(32, activation='relu'),\n                                  keras.layers.dropout(0.17),\n                                  keras.layers.dense(1)])\nest = deepiv(n_components=10, # number of gaussians in the mixture density networks)\n             m=lambda z, x: treatment_model(keras.layers.concatenate([z, x])), # treatment model\n             h=lambda t, x: response_model(keras.layers.concatenate([t, x])), # response model\n             n_samples=1 # number of samples used to estimate the response\n             )\nest.fit(y, t, x=x, z=z) # z -> instrumental variables\ntreatment_effects = est.effect(x_test)\n```\n</details>\n\nsee the <a href=\"#references\">references</a> section for more details.\n\n### interpretability\n<details>\n  <summary>tree interpreter of the cate model (click to expand)</summary>\n  \n  ```python\n  from econml.cate_interpreter import singletreecateinterpreter\n  intrp = singletreecateinterpreter(include_model_uncertainty=true, max_depth=2, min_samples_leaf=10)\n  # we interpret the cate model's behavior based on the features used for heterogeneity\n  intrp.interpret(est, x)\n  # plot the tree\n  plt.figure(figsize=(25, 5))\n  intrp.plot(feature_names=['a', 'b', 'c', 'd'], fontsize=12)\n  plt.show()\n  ```\n  ![image](notebooks/images/dr_cate_tree.png)\n  \n</details>\n\n<details>\n  <summary>policy interpreter of the cate model (click to expand)</summary>\n\n  ```python\n  from econml.cate_interpreter import singletreepolicyinterpreter\n  # we find a tree-based treatment policy based on the cate model\n  intrp = singletreepolicyinterpreter(risk_level=0.05, max_depth=2, min_samples_leaf=1,min_impurity_decrease=.001)\n  intrp.interpret(est, x, sample_treatment_costs=0.2)\n  # plot the tree\n  plt.figure(figsize=(25, 5))\n  intrp.plot(feature_names=['a', 'b', 'c', 'd'], fontsize=12)\n  plt.show()\n  ```\n  ![image](notebooks/images/dr_policy_tree.png)\n\n</details>\n\n<details>\n  <summary>shap values for the cate model (click to expand)</summary>\n\n  ```python\n  import shap\n  from econml.dml import causalforestdml\n  est = causalforestdml()\n  est.fit(y, t, x=x, w=w)\n  shap_values = est.shap_values(x)\n  shap.summary_plot(shap_values['y0']['t0'])\n  ```\n\n</details>\n\n\n### causal model selection and cross-validation\n\n\n<details>\n  <summary>causal model selection with the `rscorer` (click to expand)</summary>\n\n  ```python\n  from econml.score import rscorer\n\n  # split data in train-validation\n  x_train, x_val, t_train, t_val, y_train, y_val = train_test_split(x, t, y, test_size=.4)\n\n  # define list of cate estimators to select among\n  reg = lambda: randomforestregressor(min_samples_leaf=20)\n  clf = lambda: randomforestclassifier(min_samples_leaf=20)\n  models = [('ldml', lineardml(model_y=reg(), model_t=clf(), discrete_treatment=true,\n                               linear_first_stages=false, cv=3)),\n            ('xlearner', xlearner(models=reg(), cate_models=reg(), propensity_model=clf())),\n            ('dalearner', domainadaptationlearner(models=reg(), final_models=reg(), propensity_model=clf())),\n            ('slearner', slearner(overall_model=reg())),\n            ('drlearner', drlearner(model_propensity=clf(), model_regression=reg(),\n                                    model_final=reg(), cv=3)),\n            ('rlearner', nonparamdml(model_y=reg(), model_t=clf(), model_final=reg(),\n                                     discrete_treatment=true, cv=3)),\n            ('dml3dlasso', dml(model_y=reg(), model_t=clf(),\n                               model_final=lassocv(cv=3, fit_intercept=false),\n                               discrete_treatment=true,\n                               featurizer=polynomialfeatures(degree=3),\n                               linear_first_stages=false, cv=3))\n  ]\n\n  # fit cate models on train data\n  models = [(name, mdl.fit(y_train, t_train, x=x_train)) for name, mdl in models]\n\n  # score cate models on validation data\n  scorer = rscorer(model_y=reg(), model_t=clf(),\n                   discrete_treatment=true, cv=3, mc_iters=2, mc_agg='median')\n  scorer.fit(y_val, t_val, x=x_val)\n  rscore = [scorer.score(mdl) for _, mdl in models]\n  # select the best model\n  mdl, _ = scorer.best_model([mdl for _, mdl in models])\n  # create weighted ensemble model based on score performance\n  mdl, _ = scorer.ensemble([mdl for _, mdl in models])\n  ```\n\n</details>\n\n<details>\n  <summary>first stage model selection (click to expand)</summary>\n\nfirst stage models can be selected either by passing in cross-validated models (e.g. `sklearn.linear_model.lassocv`) to econml's estimators or perform the first stage model selection outside of econml and pass in the selected model. unless selecting among a large set of hyperparameters, choosing first stage models externally is the preferred method due to statistical and computational advantages.\n\n```python\nfrom econml.dml import lineardml\nfrom sklearn import clone\nfrom sklearn.ensemble import randomforestregressor\nfrom sklearn.model_selection import gridsearchcv\n\ncv_model = gridsearchcv(\n              estimator=randomforestregressor(),\n              param_grid={\n                  \"max_depth\": [3, none],\n                  \"n_estimators\": (10, 30, 50, 100, 200),\n                  \"max_features\": (2, 4, 6),\n              },\n              cv=5,\n           )\n# first stage model selection within econml\n# this is more direct, but computationally and statistically less efficient\nest = lineardml(model_y=cv_model, model_t=cv_model)\n# first stage model selection ouside of econml\n# this is the most efficient, but requires boilerplate code\nmodel_t = clone(cv_model).fit(w, t).best_estimator_\nmodel_y = clone(cv_model).fit(w, y).best_estimator_\nest = lineardml(model_y=model_t, model_t=model_y)\n```\n\n\n</details>\n\n### inference\n\nwhenever inference is enabled, then one can get a more structure `inferenceresults` object with more elaborate inference information, such\nas p-values and z-statistics. when the cate model is linear and parametric, then a `summary()` method is also enabled. for instance:\n\n  ```python\n  from econml.dml import lineardml\n  # use defaults\n  est = lineardml()\n  est.fit(y, t, x=x, w=w)\n  # get the effect inference summary, which includes the standard error, z test score, p value, and confidence interval given each sample x[i]\n  est.effect_inference(x_test).summary_frame(alpha=0.05, value=0, decimals=3)\n  # get the population summary for the entire sample x\n  est.effect_inference(x_test).population_summary(alpha=0.1, value=0, decimals=3, tol=0.001)\n  #  get the parameter inference summary for the final model\n  est.summary()\n  ```\n  \n  <details><summary>example output (click to expand)</summary>\n  \n  ```python\n  # get the effect inference summary, which includes the standard error, z test score, p value, and confidence interval given each sample x[i]\n  est.effect_inference(x_test).summary_frame(alpha=0.05, value=0, decimals=3)\n  ```\n  ![image](notebooks/images/summary_frame.png)\n  \n  ```python\n  # get the population summary for the entire sample x\n  est.effect_inference(x_test).population_summary(alpha=0.1, value=0, decimals=3, tol=0.001)\n  ```\n  ![image](notebooks/images/population_summary.png)\n  \n  ```python\n  #  get the parameter inference summary for the final model\n  est.summary()\n  ```\n  ![image](notebooks/images/summary.png)\n  \n  </details>\n  \n\n### policy learning\n\nyou can also perform direct policy learning from observational data, using the doubly robust method for offline\npolicy learning. these methods directly predict a recommended treatment, without internally fitting an explicit\nmodel of the conditional average treatment effect.\n\n<details>\n  <summary>doubly robust policy learning (click to expand)</summary>\n\n```python\nfrom econml.policy import drpolicytree, drpolicyforest\nfrom sklearn.ensemble import randomforestregressor\n\n# fit a single binary decision tree policy\npolicy = drpolicytree(max_depth=1, min_impurity_decrease=0.01, honest=true)\npolicy.fit(y, t, x=x, w=w)\n# predict the recommended treatment\nrecommended_t = policy.predict(x)\n# plot the binary decision tree\nplt.figure(figsize=(10,5))\npolicy.plot()\n# get feature importances\nimportances = policy.feature_importances_\n\n# fit a binary decision forest\npolicy = drpolicyforest(max_depth=1, min_impurity_decrease=0.01, honest=true)\npolicy.fit(y, t, x=x, w=w)\n# predict the recommended treatment\nrecommended_t = policy.predict(x)\n# plot the first tree in the ensemble\nplt.figure(figsize=(10,5))\npolicy.plot(0)\n# get feature importances\nimportances = policy.feature_importances_\n```\n\n\n  ![image](images/policy_tree.png)\n</details>\n\nto see more complex examples, go to the [notebooks](https://github.com/py-why/econml/tree/main/notebooks) section of the repository. for a more detailed description of the treatment effect estimation algorithms, see the econml [documentation](https://econml.azurewebsites.net/).\n\n# for developers\n\nyou can get started by cloning this repository. we use \n[setuptools](https://setuptools.readthedocs.io/en/latest/index.html) for building and distributing our package.\nwe rely on some recent features of setuptools, so make sure to upgrade to a recent version with\n`pip install setuptools --upgrade`.  then from your local copy of the repository you can run `pip install -e .` to get started (but depending on what you're doing you might want to install with extras instead, like `pip install -e .[plt]` if you want to use matplotlib integration, or you can use  `pip install -e .[all]` to include all extras).\n\n## running the tests\n\nthis project uses [pytest](https://docs.pytest.org/) for testing.  to run tests locally after installing the package, you can use `pip install pytest-runner` followed by `python setup.py pytest`.\n\nwe have added pytest marks to some tests to make it easier to run a subset, and you can set the pytest_addopts environment variable to take advantage of this.  for instance, you can set it to `-m \"not (notebook or automl)\"` to skip notebook and automl tests that have some additional dependencies. \n\n## generating the documentation\n\nthis project's documentation is generated via [sphinx](https://www.sphinx-doc.org/en/main/index.html).  note that we use [graphviz](https://graphviz.org/)'s \n`dot` application to produce some of the images in our documentation, so you should make sure that `dot` is installed and in your path.\n\nto generate a local copy of the documentation from a clone of this repository, just run `python setup.py build_sphinx -w -e -a`, which will build the documentation and place it under the `build/sphinx/html` path. \n\nthe restructuredtext files that make up the documentation are stored in the [docs directory](https://github.com/py-why/econml/tree/main/doc); module documentation is automatically generated by the sphinx build process.\n\n## release process\n\nwe use github actions to build and publish the package and documentation.  to create a new release, an admin should perform the following steps:\n\n1. update the version number in `econml/_version.py` and add a mention of the new version in the news section of this file and commit the changes.\n2. manually run the publish_package.yml workflow to build and publish the package to pypi.\n3. manually run the publish_docs.yml workflow to build and publish the documentation.\n4. under https://github.com/py-why/econml/releases, create a new release with a corresponding tag, and update the release notes.\n\n# blogs and publications\n\n* june 2019: [treatment effects with instruments paper](https://arxiv.org/pdf/1905.10176.pdf)\n\n* may 2019: [open data science conference workshop](https://odsc.com/speakers/machine-learning-estimation-of-heterogeneous-treatment-effect-the-microsoft-econml-library/) \n\n* 2018: [orthogonal random forests paper](http://proceedings.mlr.press/v97/oprescu19a.html)\n\n* 2017: [deepiv paper](http://proceedings.mlr.press/v70/hartford17a/hartford17a.pdf)\n\n# citation\n\nif you use econml in your research, please cite us as follows:\n\n   keith battocchi, eleanor dillon, maggie hei, greg lewis, paul oka, miruna oprescu, vasilis syrgkanis. **econml: a python package for ml-based heterogeneous treatment effects estimation.** https://github.com/py-why/econml, 2019. version 0.x.\n\nbibtex:\n\n```\n@misc{econml,\n  author={keith battocchi, eleanor dillon, maggie hei, greg lewis, paul oka, miruna oprescu, vasilis syrgkanis},\n  title={{econml}: {a python package for ml-based heterogeneous treatment effects estimation}},\n  howpublished={https://github.com/py-why/econml},\n  note={version 0.x},\n  year={2019}\n}\n```\n\n# contributing and feedback\n\nthis project welcomes contributions and suggestions.  we use the [dco bot](https://github.com/apps/dco) to enforce a [developer certificate of origin](https://developercertificate.org/) which requires users to sign-off on their commits.  this is a simple way to certify that you wrote or otherwise have the right to submit the code you are contributing to the project.  git provides a `-s` command line option to include this automatically when you commit via `git commit`.\n\nwhen you submit a pull request, a cla-bot will automatically determine whether you need to provide\na cla and decorate the pr appropriately (e.g., label, comment). simply follow the instructions\nprovided by the bot. you will only need to do this once across all repos using our cla.\n\nthis project has adopted the [pywhy code of conduct](https://github.com/py-why/governance/blob/main/code-of-conduct.md).\n\n# references\n\nathey, susan, and stefan wager.\n**policy learning with observational data.**\neconometrica 89.1 (2021): 133-161.\n\nx nie, s wager.\n**quasi-oracle estimation of heterogeneous treatment effects.**\n[*biometrika*](https://doi.org/10.1093/biomet/asaa076), 2020\n\nv. syrgkanis, v. lei, m. oprescu, m. hei, k. battocchi, g. lewis.\n**machine learning estimation of heterogeneous treatment effects with instruments.**\n[*proceedings of the 33rd conference on neural information processing systems (neurips)*](https://arxiv.org/abs/1905.10176), 2019\n**(spotlight presentation)**\n\nd. foster, v. syrgkanis.\n**orthogonal statistical learning.**\n[*proceedings of the 32nd annual conference on learning theory (colt)*](https://arxiv.org/pdf/1901.09036.pdf), 2019\n**(best paper award)**\n\nm. oprescu, v. syrgkanis and z. s. wu.\n**orthogonal random forest for causal inference.**\n[*proceedings of the 36th international conference on machine learning (icml)*](http://proceedings.mlr.press/v97/oprescu19a.html), 2019.\n\ns. k\u00fcnzel, j. sekhon, j. bickel and b. yu.\n**metalearners for estimating heterogeneous treatment effects using machine learning.**\n[*proceedings of the national academy of sciences, 116(10), 4156-4165*](https://www.pnas.org/content/116/10/4156), 2019.\n\ns. athey, j. tibshirani, s. wager.\n**generalized random forests.**\n[*annals of statistics, 47, no. 2, 1148--1178*](https://projecteuclid.org/euclid.aos/1547197251), 2019.\n\nv. chernozhukov, d. nekipelov, v. semenova, v. syrgkanis.\n**plug-in regularized estimation of high-dimensional parameters in nonlinear semiparametric models.**\n[*arxiv preprint arxiv:1806.04823*](https://arxiv.org/abs/1806.04823), 2018.\n\ns. wager, s. athey.\n**estimation and inference of heterogeneous treatment effects using random forests.**\n[*journal of the american statistical association, 113:523, 1228-1242*](https://www.tandfonline.com/doi/citedby/10.1080/01621459.2017.1319839), 2018.\n\njason hartford, greg lewis, kevin leyton-brown, and matt taddy. **deep iv: a flexible approach for counterfactual prediction.** [*proceedings of the 34th international conference on machine learning, icml'17*](http://proceedings.mlr.press/v70/hartford17a/hartford17a.pdf), 2017.\n\nv. chernozhukov, d. chetverikov, m. demirer, e. duflo, c. hansen, and a. w. newey. **double machine learning for treatment and causal parameters.** [*arxiv preprint arxiv:1608.00060*](https://arxiv.org/abs/1608.00060), 2016.\n\ndudik, m., erhan, d., langford, j., & li, l.\n**doubly robust policy evaluation and optimization.**\nstatistical science, 29(4), 485-511, 2014.\n",
  "docs_url": null,
  "keywords": "treatment-effect",
  "license": "mit",
  "name": "econml",
  "package_url": "https://pypi.org/project/econml/",
  "project_url": "https://pypi.org/project/econml/",
  "project_urls": {
    "Bug Tracker": "https://github.com/py-why/EconML/Issues",
    "Documentation": "https://econml.azurewebsites.net/",
    "Homepage": "https://github.com/py-why/EconML",
    "Source Code": "https://github.com/py-why/EconML"
  },
  "release_url": "https://pypi.org/project/econml/0.14.1/",
  "requires_dist": [
    "numpy",
    "scipy (>1.4.0)",
    "scikit-learn (<1.3,>0.22.0)",
    "sparse",
    "joblib (>=0.13.0)",
    "statsmodels (>=0.10)",
    "pandas",
    "shap (<0.42.0,>=0.38.1)",
    "lightgbm",
    "azure-cli ; extra == 'all'",
    "keras (<2.4) ; extra == 'all'",
    "tensorflow (<2.3,>1.10) ; extra == 'all'",
    "protobuf (<4) ; extra == 'all'",
    "numpy (<1.24) ; extra == 'all'",
    "matplotlib (<3.6.0) ; extra == 'all'",
    "dowhy (<0.9) ; extra == 'all'",
    "azure-cli ; extra == 'automl'",
    "dowhy (<0.9) ; extra == 'dowhy'",
    "graphviz ; extra == 'plt'",
    "matplotlib (<3.6.0) ; extra == 'plt'",
    "protobuf (<4) ; extra == 'tf'",
    "numpy (<1.24) ; extra == 'tf'",
    "keras (<2.4) ; (python_version < \"3.9\") and extra == 'tf'",
    "tensorflow (<2.3,>1.10) ; (python_version < \"3.9\") and extra == 'tf'"
  ],
  "requires_python": "",
  "summary": "this package contains several methods for calculating conditional average treatment effects",
  "version": "0.14.1",
  "releases": [],
  "developers": [
    "pywhy_contributors"
  ],
  "kwds": "econml pypi dr_policy_tree pytest policy_tree",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_econml",
  "homepage": "https://github.com/py-why/econml",
  "release_count": 31,
  "dependency_ids": [
    "pypi_azure_cli",
    "pypi_dowhy",
    "pypi_graphviz",
    "pypi_joblib",
    "pypi_keras",
    "pypi_lightgbm",
    "pypi_matplotlib",
    "pypi_numpy",
    "pypi_pandas",
    "pypi_protobuf",
    "pypi_scikit_learn",
    "pypi_scipy",
    "pypi_shap",
    "pypi_sparse",
    "pypi_statsmodels",
    "pypi_tensorflow"
  ]
}