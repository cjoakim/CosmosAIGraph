{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: financial and insurance industry",
    "intended audience :: information technology",
    "intended audience :: science/research",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering :: information analysis",
    "topic :: text processing",
    "topic :: text processing :: filters",
    "topic :: utilities"
  ],
  "description": "fastnumbers\n===========\n\n.. image:: https://img.shields.io/pypi/v/fastnumbers.svg\n    :target: https://pypi.org/project/fastnumbers/\n\n.. image:: https://img.shields.io/pypi/pyversions/fastnumbers.svg\n    :target: https://pypi.org/project/fastnumbers/\n\n.. image:: https://img.shields.io/pypi/l/fastnumbers.svg\n    :target: https://github.com/sethmmorton/fastnumbers/blob/main/license\n\n.. image:: https://github.com/sethmmorton/fastnumbers/workflows/tests/badge.svg\n    :target: https://github.com/sethmmorton/fastnumbers/actions\n\n.. image:: https://codecov.io/gh/sethmmorton/fastnumbers/branch/main/graph/badge.svg\n    :target: https://codecov.io/gh/sethmmorton/fastnumbers\n\n.. image:: https://img.shields.io/pypi/dw/fastnumbers.svg\n    :target: https://pypi.org/project/fastnumbers/\n\nsuper-fast and clean conversions to numbers.\n\n    - source code: https://github.com/sethmmorton/fastnumbers\n    - downloads: https://pypi.org/project/fastnumbers/\n    - documentation: https://fastnumbers.readthedocs.io/\n    - `quick start`_\n    - `timing`_\n    - `high-level algorithm`_\n    - `how to run tests`_\n    - `history`_\n\n``fastnumbers`` is a module with the following three objectives (in order\nof decreasing importance as to why the module was created):\n\n    #. provide a set of convenience functions that wrap calls to\n       ``int`` and ``float`` and provides easy, concise, powerful, fast\n       and flexible error handling.\n    #. provide a set of functions that can be used to rapidly identify if\n       an input *could* be converted to *int* or *float*.\n    #. provide drop-in replacements for the python built-in ``int`` and\n       ``float`` that are on par or faster with the python equivalents\n       (see the `timing`_ section for details). these functions\n       should behave *identically* to the python built-ins except for a few\n       specific corner-cases as mentioned in the\n       `api documentation for those functions <https://fastnumbers.readthedocs.io/en/stable/api.html#the-built-in-replacement-functions>`_.\n\n       - **please** read the quick start for these functions to fully\n         understand the caveats before using them.\n\n**what kind of speedups can you expect?** here are some highlights, but please\nsee the `timing`_ section for the raw data if you want details.\n\n    - up to 2x faster conversion of strings to integers than the built-in\n      ``int()`` function\n    - up to 5x faster conversion of strings to floats than the built-in\n      ``float()`` function (possibly greater for very long strings)\n    - up to 10x faster handling of errors during conversion than using\n      user-side error handling\n    - on top of the above, operations to convert a list of strings\n      (with the ``map`` option or ``try_array`` function) is 2x faster\n      than the equivalent list comprehension.\n\n**notice**: as of ``fastnumbers`` version 4.0.0, only python >= 3.7 is\nsupported.\n\n**notice**: as of ``fastnumbers`` version 4.0.0, the functions ``fast_real``,\n``fast_float``, ``fast_int``, ``fast_forceint``, ``isreal``, ``isfloat``,\n``isint``, and ``isintlike`` have been deprecated and are replaced with\n``try_real``, ``try_float``, ``try_int``, ``try_forceint``, ``check_real``,\n``check_float``, ``check_int``, and ``check_intlike``, respectively. these\nnew functions have more flexible apis and have names that better reflect\nthe intent of the functions. the old functions can still be used (they will\n*never* be removed from ``fastnumbers``), but the new ones should be\npreferred for new development.\n\n**notice**: as of ``fastnumbers`` version 4.0.0, ``query_type`` now sets\n``allow_underscores`` to ``false`` by default instead of ``true``.\n\nquick start\n-----------\n\n- `error-handling functions`_\n- `checking functions`_\n- `drop-in replacement functions`_\n\nthere are three broad categories of functions exposed by ``fastnumbers``.\nthe below quick start will demonstrate each of these categories. the\nquick start is \"by example\", and will show a sample interactive session\nusing the ``fastnumbers`` api.\n\nerror-handling functions\n++++++++++++++++++++++++\n\n- `error-handling function api <https://fastnumbers.readthedocs.io/en/stable/api.html#the-error-handling-functions>`_\n- `fast operations on lists and other iterables`_\n- `about the on_fail option`_\n- `about the denoise option`_\n\n``try_float`` will be used to demonstrate the functionality of the\n``try_*`` functions.\n\n.. code-block:: python\n\n    >>> from fastnumbers import raise, try_float\n    >>> # convert string to a float\n    >>> try_float('56.07')\n    56.07\n    >>> # integers are converted to floats\n    >>> try_float(54)\n    54.0\n    >>>\n    >>> # unconvertable string returned as-is by default\n    >>> try_float('bad input')\n    'bad input'\n    >>> # unconvertable strings can trigger a default value\n    >>> try_float('bad input', on_fail=0)\n    0\n    >>>\n    >>> # one can ask inf or nan to be substituted with another value\n    >>> try_float('nan')\n    nan\n    >>> try_float('nan', nan=0.0)\n    0.0\n    >>> try_float(float('nan'), nan=0.0)\n    0.0\n    >>> try_float('56.07', nan=0.0)\n    56.07\n    >>>\n    >>> # the default built-in float behavior can be triggered with\n    >>> # raise given to \"on_fail\".\n    >>> try_float('bad input', on_fail=raise) #doctest: +ignore_exception_detail\n    traceback (most recent call last):\n      ...\n    valueerror: invalid literal for float(): bad input\n    >>>\n    >>> # a function can be used to return an alternate value for invalid input\n    >>> try_float('bad input', on_fail=len)\n    9\n    >>> try_float(54, on_fail=len)\n    54.0\n    >>>\n    >>> # single unicode characters can be converted.\n    >>> try_float('\\u2164')  # roman numeral 5 (v)\n    5.0\n    >>> try_float('\\u2466')  # 7 enclosed in a circle\n    7.0\n\n``try_int`` behaves the same as ``try_float``, but for integers.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_int\n    >>> try_int('1234')\n    1234\n    >>> try_int('\\u2466')\n    7\n\n``try_real`` is like ``try_float`` or ``try_int`` depending\non if there is any fractional component of thi return value.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_real\n    >>> try_real('56')\n    56\n    >>> try_real('56.0')\n    56\n    >>> try_real('56.0', coerce=false)\n    56.0\n    >>> try_real('56.07')\n    56.07\n    >>> try_real(56.07)\n    56.07\n    >>> try_real(56.0)\n    56\n    >>> try_real(56.0, coerce=false)\n    56.0\n\n``try_forceint`` always returns an integer.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_forceint\n    >>> try_forceint('56')\n    56\n    >>> try_forceint('56.0')\n    56\n    >>> try_forceint('56.07')\n    56\n    >>> try_forceint(56.07)\n    56\n\nfast operations on lists and other iterables\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\neach of the ``try_*`` functions have a ``map`` option causes the function\nto accept an iterable of items to convert and returns a list. using\n``try_float`` as an example, the following are all functionally equivalent.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_float\n    >>> iterable = [\"5\", \"4.5\", \"34567.6\", \"32\"]\n    >>> try_float(iterable, map=list) == list(map(try_float, iterable))\n    true\n    >>> try_float(iterable, map=list) == [try_float(x) for x in iterable]\n    true\n    >>> try_float(iterable, map=list) == list(try_float(iterable, map=true))\n    true\n\nthe difference is that the ``map`` option is 2x the speed of the list\ncomprehension method, and 1.5x the speed of the ``map`` method. the reason\nis that it avoids python function call overhead on each iteration. note that\n*true* causes the function to return an iterator, and *list* causes it to\nreturn a ``list``. in practice the performance of these are similar\n(see `timing`_ for raw data).\n\nif you need to store your output in a ``numpy`` array, you can use\n``try_array`` to do this conversion directly. this function has some\nadditional handling for overflow that is not present in the other\n``fastnumbers`` functions that may come in handy when dealing with\n``numpy`` arrays.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_array\n    >>> import numpy as np\n    >>> iterable = [\"5\", \"4.5\", \"34567.6\", \"32\"]\n    >>> np.array_equal(np.array(try_float(iterable, map=list), dtype=np.float64), try_array(iterable))\n    true\n\nyou will see about a 2x speedup of doing this in one step over converting\nto a list then converting that list to an array.\n\nabout the ``on_fail`` option\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``on_fail`` option is a way for you to do *anything* in the event that\nthe given input cannot be converted to a number. it can\n\n* return given object as-is if set to ``fastnumbers.input`` (this is the default)\n* raise a ``valueerror`` if set to ``fastnumbers.raise``\n* return a default value if given any non-callable object\n* call a function with the given object if given a single-argument callable\n\nbelow are a couple of ideas to get you thinking.\n\n**note**:: there is also an ``on_type_error`` option that behaves the same as\n``on_fail`` except that a) it is triggered when the given object is of an\ninvalid type and b) the default value is ``fastnumbers.raise``, not\n``fastnumbers.input``.\n\n.. code-block:: python\n\n    >>> from fastnumbers import input, raise, try_float\n    >>> # you want to convert strings that can be converted to numbers, but\n    >>> # leave the rest as strings. use fastnumbers.input (the default)\n    >>> try_float('45.6')\n    45.6\n    >>> try_float('invalid input')\n    'invalid input'\n    >>> try_float('invalid input', on_fail=input)\n    'invalid input'\n    >>>\n    >>>\n    >>>\n    >>> # you want to convert any invalid string to nan\n    >>> try_float('45.6', on_fail=float('nan'))\n    45.6\n    >>> try_float('invalid input', on_fail=float('nan'))\n    nan\n    >>>\n    >>>\n    >>>\n    >>> # simple callable case, send the input through some function to generate a number.\n    >>> try_float('invalid input', on_fail=lambda x: float(x.count('i')))  # count the 'i's\n    3.0\n    >>>\n    >>>\n    >>>\n    >>> # suppose we know that our input could either be a number, or if not\n    >>> # then we know we just have to strip off parens to get to the number\n    >>> # e.g. the input could be '45' or '(45)'. also, suppose that if it\n    >>> # still cannot be converted to a number we want to raise an exception.\n    >>> def strip_parens_and_try_again(x):\n    ...     return try_float(x.strip('()'), on_fail=raise)\n    ...\n    >>> try_float('45', on_fail=strip_parens_and_try_again)\n    45.0\n    >>> try_float('(45)', on_fail=strip_parens_and_try_again)\n    45.0\n    >>> try_float('invalid input', on_fail=strip_parens_and_try_again) #doctest: +ignore_exception_detail\n    traceback (most recent call last):\n      ...\n    valueerror: invalid literal for float(): invalid input\n    >>>\n    >>>\n    >>>\n    >>> # suppose that whenever an invalid input is given, it needs to be\n    >>> # logged and then a default value is returned.\n    >>> def log_and_default(x, log_method=print, default=0.0):\n    ...     log_method(\"the input {!r} is not valid!\".format(x))\n    ...     return default\n    ...\n    >>> try_float('45', on_fail=log_and_default)\n    45.0\n    >>> try_float('invalid input', on_fail=log_and_default)\n    the input 'invalid input' is not valid!\n    0.0\n    >>> try_float('invalid input', on_fail=lambda x: log_and_default(x, default=float('nan')))\n    the input 'invalid input' is not valid!\n    nan\n\nabout the ``denoise`` option\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe ``denoise`` option is available on the ``try_real`` and ``try_forceint`` options.\nto best understand its usage, consider the following native python behavior:\n\n.. code-block:: python\n\n    >>> int(3.453e21)\n    3452999999999999737856\n    >>> int(float(\"3.453e21\"))\n    3452999999999999737856\n    >>> # most users would likely expect this result from decimal.decimal\n    >>> import decimal\n    >>> int(decimal.decimal(\"3.453e21\"))\n    3453000000000000000000\n    >>> # but watch out, even decimal.decimal doesn't help for float input\n    >>> import decimal\n    >>> int(decimal.decimal(3.453e21))\n    3452999999999999737856\n\nbecause the conversion of a float to an int goes through the c ``double`` data type which\nhas inherent limitations on accuracy (see\n`this stack overflow question for examples <https://stackoverflow.com/questions/588004/is-floating-point-math-broken>`_)\nthe resulting ``int`` result has \"noise\" digits that are not part of the original float\nrepresentation.\n\nfor functions where this makes sense, ``fastnumbers`` provides the ``denoise`` option to\ngive you the results that ``decimal.decimal`` would give for strings containing floats.\n\n.. code-block:: python\n\n    >>> from fastnumbers import try_real\n    >>> try_real(3.453e21)\n    3452999999999999737856\n    >>> try_real(\"3.453e21\")\n    3452999999999999737856\n    >>> try_real(3.453e21, denoise=true)\n    3453000000000000000000\n    >>> try_real(\"3.453e21\", denoise=true)\n    3453000000000000000000\n\ntwo things to keep in mind:\n\n1. the ``denoise`` option adds additional overhead to the conversion calculation, so please consider\n   the trade-offs between speed and accuracy when determining whether or not to use it. it is\n   *significantly* faster than using ``decimal.decimal``, but much slower than not using it at all.\n2. for string input, ``denoise`` will return results identical to ``decimal.decimal``. for float\n   input, ``denoise`` will return results that are accurate to about 15 digits (c ``double`` can\n   only store 16 decimal digits, so this means that only the last possible digit may not be accurate).\n\nchecking functions\n++++++++++++++++++\n\n- `checking function api <https://fastnumbers.readthedocs.io/en/stable/api.html#the-checking-functions>`_\n\n``check_float`` will be used to demonstrate the functionality of the\n``check_*`` functions. there is also the ``query_type`` function.\n\n.. code-block:: python\n\n    >>> from fastnumbers import check_float\n    >>> from fastnumbers import allowed, disallowed, number_only, string_only\n    >>> # check that a string can be converted to a float\n    >>> check_float('56')\n    true\n    >>> check_float('56', strict=true)\n    false\n    >>> check_float('56.07')\n    true\n    >>> check_float('56.07 lb')\n    false\n    >>>\n    >>> # check if a given number is a float\n    >>> check_float(56.07)\n    true\n    >>> check_float(56)\n    false\n    >>>\n    >>> # specify if only strings or only numbers are allowed\n    >>> check_float(56.07, consider=string_only)\n    false\n    >>> check_float('56.07', consider=number_only)\n    false\n    >>>\n    >>> # customize handling for nan or inf (see api for more details)\n    >>> check_float('nan')\n    false\n    >>> check_float('nan', nan=allowed)\n    true\n    >>> check_float(float('nan'))\n    true\n    >>> check_float(float('nan'), nan=disallowed)\n    false\n\n``check_int`` works the same as ``check_float``, but for integers.\n\n.. code-block:: python\n\n    >>> from fastnumbers import check_int\n    >>> check_int('56')\n    true\n    >>> check_int(56)\n    true\n    >>> check_int('56.0')\n    false\n    >>> check_int(56.0)\n    false\n\n``check_real`` is very permissive - any float or integer is accepted.\n\n.. code-block:: python\n\n    >>> from fastnumbers import check_real\n    >>> check_real('56.0')\n    true\n    >>> check_real('56')\n    true\n    >>> check_real(56.0)\n    true\n    >>> check_real(56)\n    true\n\n``check_intlike`` checks if a number is \"int-like\", if it has no\nfractional component.\n\n.. code-block:: python\n\n    >>> from fastnumbers import check_intlike\n    >>> check_intlike('56.0')\n    true\n    >>> check_intlike('56.7')\n    false\n    >>> check_intlike(56.0)\n    true\n    >>> check_intlike(56.7)\n    false\n\nthe ``query_type`` function can be used if you need to determine if\na value is one of many types, rather than whether or not it is one specific\ntype.\n\n.. code-block:: python\n\n    >>> from fastnumbers import query_type\n    >>> query_type('56.0')\n    <class 'float'>\n    >>> query_type('56')\n    <class 'int'>\n    >>> query_type(56.0)\n    <class 'float'>\n    >>> query_type(56)\n    <class 'int'>\n    >>> query_type(56.0, coerce=true)\n    <class 'int'>\n    >>> query_type('56.0', allowed_types=(float, int))\n    <class 'float'>\n    >>> query_type('hey')\n    <class 'str'>\n    >>> query_type('hey', allowed_types=(float, int))  # returns none\n\ndrop-in replacement functions\n+++++++++++++++++++++++++++++\n\n- `drop-in replacement function api <https://fastnumbers.readthedocs.io/en/stable/api.html#the-built-in-replacement-functions>`_\n\n**please** do not take it for granted that these functions will provide you\nwith a speedup - they may not. every platform, compiler, and data-set is\ndifferent, and you should perform a timing test on your system with your data\nto evaluate if you will see a benefit. as you can see from the data linked in\nthe `timing`_ section, the amount of speedup you will get is particularly\ndata-dependent. *in general* you will see a performance boost for floats (and\nthis boost increases as the size of the float increases), but for integers it\nis largely dependent on the length of the integer. you will likely *not* see\na performance boost if the input are already numbers instead of strings.\n\n**note**: in the below examples, we use ``from fastnumbers import int`` instead\nof ``import fastnumbers``. this is because calling ``fastnumbers.int()`` is a\nbit slower than just ``int()`` because python has to first find ``fastnumbers``\nin your namespace, then find ``int`` in the ``fastnumbers`` namespace, instead\nof just finding ``int`` in your namespace - this will slow down the function\ncall and defeat the purpose of using ``fastnumbers``. if you do not want to\nactually shadow the built-in ``int`` function, you can do\n``from fastnumbers import int as fn_int`` or something like that.\n\n.. code-block:: python\n\n    >>> # use is identical to the built-in functions\n    >>> from fastnumbers import float, int\n    >>> float('10')\n    10.0\n    >>> int('10')\n    10\n    >>> float('bad input') #doctest: +ignore_exception_detail\n    traceback (most recent call last):\n      ...\n    valueerror: invalid literal for float(): bad input\n\n``real`` is provided to give a float or int depending\non the fractional component of the input.\n\n.. code-block:: python\n\n    >>> from fastnumbers import real\n    >>> real('56.0')\n    56\n    >>> real('56.7')\n    56.7\n    >>> real('56.0', coerce=false)\n    56.0\n\ntiming\n------\n\njust how much faster is ``fastnumbers`` than a pure python implementation?\nplease look https://github.com/sethmmorton/fastnumbers/tree/main/profiling.\n\nhigh-level algorithm\n--------------------\n\nfor integers, cpython goes to great lengths to ensure that your string input\nis converted to a number *correctly* and *losslessly* (you can prove this to\nyourself by examining the source code for\n`integer conversions <https://github.com/python/cpython/blob/e349bf23584eef20e0d1e1b2989d9b1430f15507/objects/longobject.c#l2213>`_).\nthis extra effort is only needed for integers that cannot fit into a 64-bit\ninteger data type - for those that can, a naive algorithm of < 10 lines\nof c code is sufficient and significantly faster. ``fastnumbers`` uses a\nheuristic to determine if the input can be safely converted with the much\nfaster naive algorithm, and if so it does so, falling back on\nthe cpython implementation for longer input strings.\nmost real-world numbers pass the heuristic and so you should generally see\nimproved performance with ``fastnumbers`` for integers.\n\nfor floats, ``fastnumbers`` utilizes the ultra-fast\n`fast_float::from_chars <https://github.com/fastfloat/fast_float>`_ function\nto convert strings representing floats into a c ``double`` both quickly *and\nsafely* - the conversion provides the same accuracy as the cpython\n`float conversion function <https://github.com/python/cpython/blob/e349bf23584eef20e0d1e1b2989d9b1430f15507/python/dtoa.c#l1434>`_\nbut instead of scaling linearly with length of the input string it seems\nto have roughly constant performance. by completely bypassing the cpython\nconverter we get significant performance gains with no penalty, so you\nshould always see improved performance with ``fastnumbers`` for floats.\n\ninstallation\n------------\n\nuse ``pip``!\n\n.. code-block::\n\n    $ pip install fastnumbers\n\nhow to run tests\n----------------\n\nplease note that ``fastnumbers`` is not set-up to support\n``python setup.py test``.\n\nthe recommended way to run tests is with\n`tox <https://tox.readthedocs.io/en/latest/>`_.\nsuppose you want to run tests for python 3.8 - you can run tests by simply\nexecuting the following:\n\n.. code-block:: sh\n\n    $ tox run -e py38\n\n``tox`` will create virtual a virtual environment for your tests and install\nall the needed testing requirements for you.\n\nif you want to run testing on all supported python versions you can simply execute\n\n.. code-block:: sh\n\n    $ tox run\n\nyou can change the how much \"random\" input your tests will try with\n\n.. code-block:: sh\n\n    # run fewer tests with \"random\" input - much faster\n    $ tox run -- --hypothesis-profile fast\n\n    # run more tests with \"random\" input - takes much longer but is more thorough\n    $ tox run -- --hypothesis-profile thorough\n\nif you want to run the performce analysis yourself, you can execute\n\n.. code-block:: sh\n\n    # this assumes python 3.9 - adjust for the version you want to profile\n    $ tox run -e py39-prof\n\nif you do not wish to use ``tox``, you can install the testing dependencies with the\n``dev-requirements.txt`` file and then run the tests manually using\n`pytest <https://docs.pytest.org/en/latest/>`_.\n\n.. code-block:: sh\n\n    $ pip install -r dev/requirements.txt\n    $ pytest\n\nauthor\n------\n\nseth m. morton\n\nhistory\n-------\n\nplease visit the changelog `on github <https://github.com/sethmmorton/fastnumbers/blob/main/changelog.md>`_.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "fastnumbers",
  "package_url": "https://pypi.org/project/fastnumbers/",
  "project_url": "https://pypi.org/project/fastnumbers/",
  "project_urls": {
    "Homepage": "https://github.com/SethMMorton/fastnumbers"
  },
  "release_url": "https://pypi.org/project/fastnumbers/5.1.0/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "super-fast and clean conversions to numbers.",
  "version": "5.1.0",
  "releases": [],
  "developers": [
    "drtuba78@gmail.com",
    "seth_m"
  ],
  "kwds": "fastnumbers fast_forceint fast_int svg fast_float",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_fastnumbers",
  "homepage": "https://github.com/sethmmorton/fastnumbers",
  "release_count": 39,
  "dependency_ids": []
}