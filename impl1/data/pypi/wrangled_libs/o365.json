{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.9",
    "topic :: office/business :: office suites",
    "topic :: software development :: libraries"
  ],
  "description": "[![downloads](https://pepy.tech/badge/o365)](https://pepy.tech/project/o365)\r\n[![pypi](https://img.shields.io/pypi/v/o365.svg)](https://pypi.python.org/pypi/o365)\r\n[![pypi pyversions](https://img.shields.io/pypi/pyversions/o365.svg)](https://pypi.python.org/pypi/o365/)\r\n[![build status](https://travis-ci.org/o365/python-o365.svg?branch=master)](https://travis-ci.org/o365/python-o365)\r\n\r\n# o365 - microsoft graph and office 365 api made easy\r\n\r\n\r\n> detailed usage documentation is [still in progress](https://o365.github.io/python-o365/latest/index.html)\r\n\r\nthis project aims to make interacting with microsoft graph and office 365 easy to do in a pythonic way.\r\naccess to email, calendar, contacts, onedrive, etc. are easy to do in a way that feel easy and straight forward to beginners and feels just right to seasoned python programmer.\r\n\r\nthe project is currently developed and maintained by [janscas](https://github.com/janscas).\r\n\r\n#### core developers\r\n- [janscas](https://github.com/janscas)\r\n- [toben archer](https://github.com/narcolapser)\r\n- [geethanadh](https://github.com/geethanadhp)\r\n\r\n**we are always open to new pull requests!**\r\n\r\n#### rebuilding html docs\r\n- install `sphinx` python library\r\n\r\n    `pip install sphinx==2.2.2`\r\n\r\n- run the shell script `build_docs.sh`, or copy the command from the file when using on windows\r\n\r\n\r\n#### quick example on sending a message:\r\n\r\n```python\r\nfrom o365 import account\r\n\r\ncredentials = ('client_id', 'client_secret')\r\n\r\naccount = account(credentials)\r\nm = account.new_message()\r\nm.to.add('to_example@example.com')\r\nm.subject = 'testing!'\r\nm.body = \"george best quote: i've stopped drinking, but only while i'm asleep.\"\r\nm.send()\r\n```\r\n\r\n\r\n### why choose o365?\r\n- almost full support for msgraph and office 365 rest api.\r\n- good abstraction layer between each api. change the api (graph vs office365) and don't worry about the api internal implementation.\r\n- full oauth support with automatic handling of refresh tokens.\r\n- automatic handling between local datetimes and server datetimes. work with your local datetime and let this library do the rest.\r\n- change between different resource with ease: access shared mailboxes, other users resources, sharepoint resources, etc.\r\n- pagination support through a custom iterator that handles future requests automatically. request infinite items!\r\n- a query helper to help you build custom odata queries (filter, order, select and search).\r\n- modular apicomponents can be created and built to achieve further functionality.\r\n\r\n___\r\n\r\nthis project was also a learning resource for us. this is a list of not so common python idioms used in this project:\r\n- new unpacking technics: `def method(argument, *, with_name=none, **other_params):`\r\n- enums: `from enum import enum`\r\n- factory paradigm\r\n- package organization\r\n- timezone conversion and timezone aware datetimes\r\n- etc. ([see the code!](https://github.com/o365/python-o365/tree/master/o365))\r\n\r\n\r\nwhat follows is kind of a wiki...\r\n\r\n## table of contents\r\n\r\n- [install](#install)\r\n- [usage](#usage)\r\n- [authentication](#authentication)\r\n- [protocols](#protocols)\r\n- [account class and modularity](#account)\r\n- [mailbox](#mailbox)\r\n- [addressbook](#addressbook)\r\n- [directory and users](#directory-and-users)\r\n- [calendar](#calendar)\r\n- [tasks](#tasks)\r\n- [onedrive](#onedrive)\r\n- [excel](#excel)\r\n- [sharepoint](#sharepoint)\r\n- [planner](#planner)\r\n- [outlook categories](#outlook-categories)\r\n- [utils](#utils)\r\n\r\n\r\n## install\r\no365 is available on pypi.org. simply run `pip install o365` to install it.\r\n\r\nrequirements: >= python 3.4\r\n\r\nproject dependencies installed by pip:\r\n - requests\r\n - requests-oauthlib\r\n - beatifulsoup4\r\n - stringcase\r\n - python-dateutil\r\n - tzlocal\r\n - pytz\r\n\r\n\r\n## usage\r\nthe first step to be able to work with this library is to register an application and retrieve the auth token. see [authentication](#authentication).\r\n\r\nit is highly recommended to add the \"offline_access\" permission and request this scope when authenticating. otherwise the library will only have access to the user resources for 1 hour. see [permissions and scopes](#permissions-and-scopes).\r\n\r\nwith the access token retrieved and stored you will be able to perform api calls to the service.\r\n\r\na common pattern to check for authentication and use the library is this one:\r\n\r\n```python\r\nscopes = ['my_required_scopes']  # you can use scope helpers here (see permissions and scopes section)\r\n\r\naccount = account(credentials)\r\n\r\nif not account.is_authenticated:  # will check if there is a token and has not expired\r\n    # ask for a login\r\n    # console based authentication see authentication for other flows\r\n    account.authenticate(scopes=scopes)\r\n\r\n# now we are autheticated\r\n# use the library from now on\r\n\r\n# ...\r\n```\r\n\r\n## authentication\r\nyou can only authenticate using oauth athentication as microsoft deprecated basic auth on november 1st 2018.\r\n\r\nthere are currently three authentication methods:\r\n\r\n- [authenticate on behalf of a user](https://docs.microsoft.com/en-us/graph/auth-v2-user?context=graph%2fapi%2f1.0&view=graph-rest-1.0):\r\nany user will give consent to the app to access it's resources.\r\nthis oauth flow is called **authorization code grant flow**. this is the default authentication method used by this library.\r\n- [authenticate on behalf of a user (public)](https://docs.microsoft.com/en-us/graph/auth-v2-user?context=graph%2fapi%2f1.0&view=graph-rest-1.0):\r\nsame as the former but for public apps where the client secret can't be secured. client secret is not required.\r\n- [authenticate with your own identity](https://docs.microsoft.com/en-us/graph/auth-v2-service?context=graph%2fapi%2f1.0&view=graph-rest-1.0):\r\nthis will use your own identity (the app identity). this oauth flow is called **client credentials grant flow**.\r\n\r\n    > 'authenticate with your own identity' is not an allowed method for **microsoft personal accounts**.\r\n\r\nwhen to use one or the other and requirements:\r\n\r\n  topic                             | on behalf of a user *(auth_flow_type=='authorization')*  | on behalf of a user (public) *(auth_flow_type=='public')*  | with your own identity *(auth_flow_type=='credentials')*\r\n :---:                              | :---:                                                    | :---:                                                      | :---:\r\n **register the app**               | required                                                 | required                                                   | required\r\n **requires admin consent**         | only on certain advanced permissions                     | only on certain advanced permissions                       | yes, for everything\r\n **app permission type**            | delegated permissions (on behalf of the user)            | delegated permissions (on behalf of the user)              | application permissions\r\n **auth requirements**              | client id, client secret, authorization code             | client id, authorization code                              | client id, client secret\r\n **authentication**                 | 2 step authentication with user consent                  | 2 step authentication with user consent                    | 1 step authentication\r\n **auth scopes**                    | required                                                 | required                                                   | none\r\n **token expiration**               | 60 minutes without refresh token or 90 days*             | 60 minutes without refresh token or 90 days*               | 60 minutes*\r\n **login expiration**               | unlimited if there is a refresh token and as long as a refresh is done within the 90 days | unlimited if there is a refresh token and as long as a refresh is done within the 90 days          | unlimited\r\n **resources**                      | access the user resources, and any shared resources      | access the user resources, and any shared resources        | all azure ad users the app has access to\r\n **microsoft account type**         | any                                                      | any                                                        | not allowed for personal accounts\r\n **tenant id required**             | defaults to \"common\"                                     | defaults to \"common\"                                       | required (can't be \"common\")\r\n\r\n**o365 will automatically refresh the token for you on either authentication method. the refresh token lasts 90 days but it's refreshed on each connection so as long as you connect within 90 days you can have unlimited access.*\r\n\r\nthe `connection` class handles the authentication.\r\n\r\n\r\n#### oauth authentication\r\nthis section is explained using microsoft graph protocol, almost the same applies to the office 365 rest api.\r\n\r\n##### authentication steps\r\n1. to allow authentication you first need to register your application at [azure app registrations](https://portal.azure.com/#blade/microsoft_aad_registeredapps/applicationslistblade).\r\n\r\n    1. login at [azure portal (app registrations)](https://portal.azure.com/#blade/microsoft_aad_registeredapps/applicationslistblade)\r\n    1. create an app. set a name.\r\n    1. in supported account types choose \"accounts in any organizational directory and personal microsoft accounts (e.g. skype, xbox, outlook.com)\", if you are using a personal account.\r\n    1. set the redirect uri (web) to: `https://login.microsoftonline.com/common/oauth2/nativeclient` and click register. this needs to be inserted into the \"redirect uri\" text box as simply checking the check box next to this link seems to be insufficent. this is the default redirect uri used by this library, but you can use any other if you want.\r\n    1. write down the application (client) id. you will need this value.\r\n    1. under \"certificates & secrets\", generate a new client secret. set the expiration preferably to never. write down the value of the client secret created now. it will be hidden later on.\r\n    1. under api permissions:\r\n        - when authenticating \"on behalf of a user\":\r\n            1. add the **delegated permissions** for microsoft graph you want (see scopes).\r\n            1. it is highly recommended to add \"offline_access\" permission. if not the user you will have to re-authenticate every hour.\r\n        - when authenticating \"with your own identity\":\r\n            1. add the **application permissions** for microsoft graph you want.\r\n            1. click on the grant admin consent button (if you have admin permissions) or wait until the admin has given consent to your application.\r\n\r\n        as an example, to read and send emails use:\r\n        1. mail.readwrite\r\n        1. mail.send\r\n        1. user.read\r\n\r\n1. then you need to login for the first time to get the access token that will grant access to the user resources.\r\n\r\n    to authenticate (login) you can use [different authentication interfaces](#different-authentication-interfaces). on the following examples we will be using the console based interface but you can use any one.\r\n\r\n    - when authenticating on behalf of a user:\r\n\r\n        > **important:** in case you can't secure the client secret you can use the auth flow type 'public' which only requires the client id.\r\n\r\n        1. instantiate an `account` object with the credentials (client id and client secret).\r\n        1. call `account.authenticate` and pass the scopes you want (the ones you previously added on the app registration portal).\r\n\r\n            > note: when using the \"on behalf of a user\" authentication, you can pass the scopes to either the `account` init or to the authenticate method. either way is correct.\r\n\r\n            you can pass \"protocol scopes\" (like: \"https://graph.microsoft.com/calendars.readwrite\") to the method or use \"[scope helpers](https://github.com/o365/python-o365/blob/master/o365/connection.py#l34)\" like (\"message_all\").\r\n            if you pass protocol scopes, then the `account` instance must be initialized with the same protocol used by the scopes. by using scope helpers you can abstract the protocol from the scopes and let this library work for you.\r\n            finally, you can mix and match \"protocol scopes\" with \"scope helpers\".\r\n            go to the [procotol section](#protocols) to know more about them.\r\n\r\n            for example (following the previous permissions added):\r\n\r\n            ```python\r\n            from o365 import account\r\n            credentials = ('my_client_id', 'my_client_secret')\r\n\r\n            # the default protocol will be microsoft graph\r\n            # the default authentication method will be \"on behalf of a user\"\r\n\r\n            account = account(credentials)\r\n            if account.authenticate(scopes=['basic', 'message_all']):\r\n               print('authenticated!')\r\n\r\n            # 'basic' adds: 'offline_access' and 'https://graph.microsoft.com/user.read'\r\n            # 'message_all' adds: 'https://graph.microsoft.com/mail.readwrite' and 'https://graph.microsoft.com/mail.send'\r\n            ```\r\n            when using the \"on behalf of the user\" authentication method, this method call will print a url that the user must visit to give consent to the app on the required permissions.\r\n\r\n            the user must then visit this url and give consent to the application. when consent is given, the page will rediret to: \"https://login.microsoftonline.com/common/oauth2/nativeclient\" by default (you can change this) with a url query param called 'code'.\r\n\r\n            then the user must copy the resulting page url and paste it back on the console.\r\n            the method will then return true if the login attempt was succesful.\r\n\r\n    - when authenticating with your own identity:\r\n\r\n        1. instantiate an `account` object with the credentials (client id and client secret), specifying the parameter `auth_flow_type` to *\"credentials\"*. you also need to provide a 'tenant_id'. you don't need to specify any scopes.\r\n        1. call `account.authenticate`. this call will request a token for you and store it in the backend. no user interaction is needed. the method will store the token in the backend and return true if the authentication succeeded.\r\n\r\n            for example:\r\n            ```python\r\n            from o365 import account\r\n\r\n            credentials = ('my_client_id', 'my_client_secret')\r\n\r\n            # the default protocol will be microsoft graph\r\n\r\n            account = account(credentials, auth_flow_type='credentials', tenant_id='my-tenant-id')\r\n            if account.authenticate():\r\n               print('authenticated!')\r\n            ```\r\n\r\n1. at this point you will have an access token stored that will provide valid credentials when using the api.\r\n\r\n    the access token only lasts **60 minutes**, but the app try will automatically request new access tokens.\r\n\r\n    when using the \"on behalf of a user\" authentication method this is accomplished through the refresh tokens (if and only if you added the \"offline_access\" permission), but note that a refresh token only lasts for 90 days. so you must use it before or you will need to request a new access token again (no new consent needed by the user, just a login).\r\n    if your application needs to work for more than 90 days without user interaction and without interacting with the api, then you must implement a periodic call to `connection.refresh_token` before the 90 days have passed.\r\n\r\n    **take care: the access (and refresh) token must remain protected from unauthorized users.**\r\n\r\n    under the \"on behalf of a user\" authentication method, if you change the scope requested, then the current token won't work, and you will need the user to give consent again on the application to gain access to the new scopes requested.\r\n\r\n\r\n##### different authentication interfaces\r\n\r\nto acomplish the authentication you can basically use different approaches.\r\nthe following apply to the \"on behalf of a user\" authentication method as this is 2-step authentication flow.\r\nfor the \"with your own identity\" authentication method, you can just use `account.authenticate` as it's not going to require a console input.\r\n\r\n1. console based authentication interface:\r\n\r\n    you can authenticate using a console. the best way to achieve this is by using the `authenticate` method of the `account` class.\r\n\r\n    ```python\r\n    account = account(credentials)\r\n    account.authenticate(scopes=['basic', 'message_all'])\r\n    ```\r\n\r\n    the `authenticate` method will print into the console a url that you will have to visit to achieve authentication.\r\n    then after visiting the link and authenticate you will have to paste back the resulting url into the console.\r\n    the method will return `true` and print a message if it was succesful.\r\n\r\n    **tip:** when using macos the console is limited to 1024 characters. if your url has multiple scopes it can exceed this limit. to solve this. just `import readline` a the top of your script.\r\n\r\n1. web app based authentication interface:\r\n\r\n    you can authenticate your users in a web environment by following this steps:\r\n\r\n    1. first ensure you are using an appropiate tokenbackend to store the auth tokens (see token storage below).\r\n    1. from a handler redirect the user to the microsoft login url. provide a callback. store the state.\r\n    1. from the callback handler complete the authentication with the state and other data.\r\n\r\n    the following example is done using flask.\r\n    ```python\r\n    from flask import request\r\n    from o365 import account\r\n    \r\n    \r\n    @route('/stepone')\r\n    def auth_step_one():\r\n        # callback = absolute url to auth_step_two_callback() page, https://domain.tld/steptwo\r\n        callback = url_for('auth_step_two_callback', _external=true)  # flask example\r\n\r\n        account = account(credentials)\r\n        url, state = account.con.get_authorization_url(requested_scopes=my_scopes,\r\n                                                       redirect_uri=callback)\r\n\r\n        # the state must be saved somewhere as it will be needed later\r\n        my_db.store_state(state) # example...\r\n\r\n        return redirect(url)\r\n\r\n    @route('/steptwo')\r\n    def auth_step_two_callback():\r\n        account = account(credentials)\r\n\r\n        # retreive the state saved in auth_step_one\r\n        my_saved_state = my_db.get_state()  # example...\r\n\r\n        # rebuild the redirect_uri used in auth_step_one\r\n        callback = 'my absolute url to auth_step_two_callback'\r\n\r\n        # get the request url of the page which will include additional auth information\r\n        # example request: /steptwo?code=abc123&state=xyz456\r\n        requested_url = request.url  # uses flask's request() method\r\n\r\n        result = account.con.request_token(requested_url,\r\n                                           state=my_saved_state,\r\n                                           redirect_uri=callback)\r\n        # if result is true, then authentication was succesful\r\n        #  and the auth token is stored in the token backend\r\n        if result:\r\n            return render_template('auth_complete.html')\r\n        # else ....\r\n    ```\r\n\r\n1. other authentication interfaces:\r\n\r\n    finally you can configure any other flow by using `connection.get_authorization_url` and `connection.request_token` as you want.\r\n\r\n\r\n##### permissions and scopes:\r\n\r\n###### permissions\r\n\r\nwhen using oauth, you create an application and allow some resources to be accessed and used by its users.\r\nthese resources are managed with permissions. these can either be delegated (on behalf of a user) or aplication permissions.\r\nthe former are used when the authentication method is \"on behalf of a user\". some of these require administrator consent.\r\nthe latter when using the \"with your own identity\" authentication method. all of these require administrator consent.\r\n\r\n###### scopes\r\n\r\nthe scopes only matter when using the \"on behalf of a user\" authentication method.\r\n\r\n> note: you only need the scopes when login as those are kept stored within the token on the token backend.\r\n\r\nthe user of this library can then request access to one or more of this resources by providing scopes to the oauth provider.\r\n\r\n> note: if you latter on change the scopes requested, the current token will be invaled and you will have to re-authenticate. the user that logins will be asked for consent.\r\n\r\nfor example your application can have calendar.read, mail.readwrite and mail.send permissions, but the application can request access only to the mail.readwrite and mail.send permission.\r\nthis is done by providing scopes to the `account` instance or `account.authenticate` method like so:\r\n\r\n```python\r\nfrom o365 import account\r\n\r\ncredentials = ('client_id', 'client_secret')\r\n\r\nscopes = ['https://graph.microsoft.com/mail.readwrite', 'https://graph.microsoft.com/mail.send']\r\n\r\naccount = account(credentials, scopes=scopes)\r\naccount.authenticate()\r\n\r\n# the latter is exactly the same as passing scopes to the authenticate method like so:\r\n# account = account(credentials)\r\n# account.authenticate(scopes=scopes)\r\n```\r\n\r\nscope implementation depends on the protocol used. so by using protocol data you can automatically set the scopes needed.\r\nthis is implemented by using 'scope helpers'. those are little helpers that group scope functionality and abstract the protocol used.\r\n\r\nscope helper                       | scopes included\r\n:---                               | :---\r\nbasic                              | 'offline_access' and 'user.read'\r\nmailbox                            | 'mail.read'\r\nmailbox_shared                     | 'mail.read.shared'\r\nmailbox_settings                   | 'mailboxsettings.readwrite'\r\nmessage_send                       | 'mail.send'\r\nmessage_send_shared                | 'mail.send.shared'\r\nmessage_all                        | 'mail.readwrite' and 'mail.send'\r\nmessage_all_shared                 | 'mail.readwrite.shared' and 'mail.send.shared'\r\naddress_book                       | 'contacts.read'\r\naddress_book_shared                | 'contacts.read.shared'\r\naddress_book_all                   | 'contacts.readwrite'\r\naddress_book_all_shared            | 'contacts.readwrite.shared'\r\ncalendar                           | 'calendars.read'\r\ncalendar_shared                    | 'calendars.read.shared'\r\ncalendar_all                       | 'calendars.readwrite'\r\ncalendar_shared_all                | 'calendars.readwrite.shared'\r\ntasks                              | 'tasks.read'\r\ntasks_all                          | 'tasks.readwrite'\r\nusers                              | 'user.readbasic.all'\r\nonedrive                           | 'files.read.all'\r\nonedrive_all                       | 'files.readwrite.all'\r\nsharepoint                         | 'sites.read.all'\r\nsharepoint_dl                      | 'sites.readwrite.all'\r\n\r\n\r\nyou can get the same scopes as before using protocols and scope helpers like this:\r\n\r\n```python\r\nprotocol_graph = msgraphprotocol()\r\n\r\nscopes_graph = protocol.get_scopes_for('message all')\r\n# scopes here are: ['https://graph.microsoft.com/mail.readwrite', 'https://graph.microsoft.com/mail.send']\r\n\r\naccount = account(credentials, scopes=scopes_graph)\r\n```\r\n\r\n```python\r\nprotocol_office = msoffice365protocol()\r\n\r\nscopes_office = protocol.get_scopes_for('message all')\r\n# scopes here are: ['https://outlook.office.com/mail.readwrite', 'https://outlook.office.com/mail.send']\r\n\r\naccount = account(credentials, scopes=scopes_office)\r\n```\r\n\r\n> note: when passing scopes at the `account` initialization or on the `account.authenticate` method, the scope helpers are autommatically converted to the protocol flavor.\r\n>those are the only places where you can use scope helpers. any other object using scopes (such as the `connection` object) expects scopes that are already set for the protocol.\r\n\r\n\r\n\r\n##### token storage:\r\nwhen authenticating you will retrieve oauth tokens. if you don't want a one time access you will have to store the token somewhere.\r\no365 makes no assumptions on where to store the token and tries to abstract this from the library usage point of view.\r\n\r\nyou can choose where and how to store tokens by using the proper token backend.\r\n\r\n**take care: the access (and refresh) token must remain protected from unauthorized users.**\r\n\r\nthe library will call (at different stages) the token backend methods to load and save the token.\r\n\r\nmethods that load tokens:\r\n- `account.is_authenticated` property will try to load the token if is not already loaded.\r\n- `connection.get_session`: this method is called when there isn't a request session set. by default it will not try to load the token. set `load_token=true` to load it.\r\n\r\nmethods that stores tokens:\r\n- `connection.request_token`: by default will store the token, but you can set `store_token=false` to avoid it.\r\n- `connection.refresh_token`: by default will store the token. to avoid it change `connection.store_token` to false. this however it's a global setting (that only affects the `refresh_token` method). if you only want the next refresh operation to not store the token you will have to set it back to true afterwards.\r\n\r\nto store the token you will have to provide a properly configured tokenbackend.\r\n\r\nthere are a few `tokenbackend` classes implemented (and you can easily implement more like a cookiebackend, redisbackend, etc.):\r\n- `filesystemtokenbackend` (default backend): stores and retrieves tokens from the file system. tokens are stored as files.\r\n- `envtokenbackend`: stores and retrieves tokens from environment variables.\r\n- `firestoretokenbackend`: stores and retrives tokens from a google firestore datastore. tokens are stored as documents within a collection.\r\n- `awss3backend`: stores and retrieves tokens from an aws s3 bucket. tokens are stored as a file within a s3 bucket.\r\n- `awssecretsbackend`: stores and retrieves tokens from an aws secrets management vault.\r\n\r\nfor example using the filesystem token backend:\r\n\r\n```python\r\nfrom o365 import account, filesystemtokenbackend\r\n\r\ncredentials = ('id', 'secret')\r\n\r\n# this will store the token under: \"my_project_folder/my_folder/my_token.txt\".\r\n# you can pass strings to token_path or path instances from pathlib\r\ntoken_backend = filesystemtokenbackend(token_path='my_folder', token_filename='my_token.txt')\r\naccount = account(credentials, token_backend=token_backend)\r\n\r\n# this account instance tokens will be stored on the token_backend configured before.\r\n# you don't have to do anything more\r\n# ...\r\n```\r\n\r\nand now using the same example using firestoretokenbackend:\r\n\r\n```python\r\nfrom o365 import account\r\nfrom o365.utils import firestorebackend\r\nfrom google.cloud import firestore\r\n\r\ncredentials = ('id', 'secret')\r\n\r\n# this will store the token on firestore under the tokens collection on the defined doc_id.\r\n# you can pass strings to token_path or path instances from pathlib\r\nuser_id = 'whatever the user id is'  # used to create the token document id\r\ndocument_id = f\"token_{user_id}\"  # used to uniquely store this token\r\ntoken_backend = firestorebackend(client=firestore.client(), collection='tokens', doc_id=document_id)\r\naccount = account(credentials, token_backend=token_backend)\r\n\r\n# this account instance tokens will be stored on the token_backend configured before.\r\n# you don't have to do anything more\r\n# ...\r\n```\r\n\r\nto implement a new tokenbackend:\r\n\r\n 1. subclass `basetokenbackend`\r\n 1. implement the following methods:\r\n\r\n     - `__init__` (don't forget to call `super().__init__`)\r\n     - `load_token`: this should load the token from the desired backend and return a `token` instance or none\r\n     - `save_token`: this should store the `self.token` in the desired backend.\r\n     - optionally you can implement: `check_token`, `delete_token` and `should_refresh_token`\r\n\r\nthe `should_refresh_token` method is intended to be implemented for environments where multiple connection instances are running on paralel.\r\nthis method should check if it's time to refresh the token or not.\r\nthe chosen backend can store a flag somewhere to answer this question.\r\nthis can avoid race conditions between different instances trying to refresh the token at once, when only one should make the refresh.\r\nthe method should return three posible values:\r\n- **true**: then the connection will refresh the token.\r\n- **false**: then the connection will not refresh the token.\r\n- **none**: then this method already executed the refresh and therefore the connection does not have to.\r\n\r\nby default this always returns true as it's asuming there is are no parallel connections running at once.\r\n\r\nthere are two examples of this method in the examples folder [here](https://github.com/o365/python-o365/blob/master/examples/token_backends.py).\r\n\r\n\r\n## protocols\r\nprotocols handles the aspects of communications between different apis.\r\nthis project uses either the microsoft graph apis (by default) or the office 365 apis.\r\nbut, you can use many other microsoft apis as long as you implement the protocol needed.\r\n\r\nyou can use one or the other:\r\n\r\n- `msgraphprotocol` to use the [microsoft graph api](https://developer.microsoft.com/en-us/graph/docs/concepts/overview)\r\n- `msoffice365protocol` to use the [office 365 api](https://msdn.microsoft.com/en-us/office/office365/api/api-catalog)\r\n\r\nboth protocols are similar but consider the following:\r\n\r\nreasons to use `msgraphprotocol`:\r\n- it is the recommended protocol by microsoft.\r\n- it can access more resources over office 365 (for example onedrive)\r\n\r\nreasons to use `msoffice365protocol`:\r\n- it can send emails with attachments up to 150 mb. msgraph only allows 4mb on each request (update: starting 22 october'19 you can [upload files up to 150mb with msgraphprotocol **beta** version](https://developer.microsoft.com/en-us/office/blogs/attaching-large-files-to-outlook-messages-in-microsoft-graph-preview/))\r\n\r\nthe default protocol used by the `account` class is `msgraphprotocol`.\r\n\r\nyou can implement your own protocols by inheriting from `protocol` to communicate with other microsoft apis.\r\n\r\nyou can instantiate and use protocols like this:\r\n```python\r\nfrom o365 import account, msgraphprotocol  # same as from o365.connection import msgraphprotocol\r\n\r\n# ...\r\n\r\n# try the api version beta of the microsoft graph endpoint.\r\nprotocol = msgraphprotocol(api_version='beta')  # msgraphprotocol defaults to v1.0 api version\r\naccount = account(credentials, protocol=protocol)\r\n```\r\n\r\n##### resources:\r\neach api endpoint requires a resource. this usually defines the owner of the data.\r\nevery protocol defaults to resource 'me'. 'me' is the user which has given consent, but you can change this behaviour by providing a different default resource to the protocol constructor.\r\n\r\n> note: when using the \"with your own identity\" authentication method the resource 'me' is overwritten to be blank as the authentication method already states that you are login with your own identity.\r\n\r\nfor example when accessing a shared mailbox:\r\n\r\n\r\n```python\r\n# ...\r\naccount = account(credentials=my_credentials, main_resource='shared_mailbox@example.com')\r\n# any instance created using account will inherit the resource defined for account.\r\n```\r\n\r\nthis can be done however at any point. for example at the protocol level:\r\n```python\r\n# ...\r\nprotocol = msgraphprotocol(default_resource='shared_mailbox@example.com')\r\n\r\naccount = account(credentials=my_credentials, protocol=protocol)\r\n\r\n# now account is accesing the shared_mailbox@example.com in every api call.\r\nshared_mailbox_messages = account.mailbox().get_messages()\r\n```\r\n\r\ninstead of defining the resource used at the account or protocol level, you can provide it per use case as follows:\r\n```python\r\n# ...\r\naccount = account(credentials=my_credentials)  # account defaults to 'me' resource\r\n\r\nmailbox = account.mailbox('shared_mailbox@example.com')  # mailbox is using 'shared_mailbox@example.com' resource instead of 'me'\r\n\r\n# or:\r\n\r\nmessage = message(parent=account, main_resource='shared_mailbox@example.com')  # message is using 'shared_mailbox@example.com' resource\r\n```\r\n\r\nusually you will work with the default 'me' resource, but you can also use one of the following:\r\n\r\n- **'me'**: the user which has given consent. the default for every protocol. overwritten when using \"with your own identity\" authentication method (only available on the authorization auth_flow_type).\r\n- **'user:user@domain.com'**: a shared mailbox or a user account for which you have permissions. if you don't provide 'user:' will be infered anyways.\r\n- **'site:sharepoint-site-id'**: a sharepoint site id.\r\n- **'group:group-site-id'**: a office365 group id.\r\n\r\nby setting the resource prefix (such as **'user:'** or **'group:'**) you help the library understand the type of resource. you can also pass it like 'users/example@exampl.com'. same applies to the other resource prefixes.\r\n\r\n\r\n## account class and modularity <a name=\"account\"></a>\r\nusually you will only need to work with the `account` class. this is a wrapper around all functionality.\r\n\r\nbut you can also work only with the pieces you want.\r\n\r\nfor example, instead of:\r\n```python\r\nfrom o365 import account\r\n\r\naccount = account(('client_id', 'client_secret'))\r\nmessage = account.new_message()\r\n# ...\r\nmailbox = account.mailbox()\r\n# ...\r\n```\r\n\r\nyou can work only with the required pieces:\r\n\r\n```python\r\nfrom o365 import connection, msgraphprotocol\r\nfrom o365.message import message\r\nfrom o365.mailbox import mailbox\r\n\r\nprotocol = msgraphprotocol()\r\nscopes = ['...']\r\ncon = connection(('client_id', 'client_secret'), scopes=scopes)\r\n\r\nmessage = message(con=con, protocol=protocol)\r\n# ...\r\nmailbox = mailbox(con=con, protocol=protocol)\r\nmessage2 = message(parent=mailbox)  # message will inherit the connection and protocol from mailbox when using parent.\r\n# ...\r\n```\r\n\r\nit's also easy to implement a custom class.\r\n\r\njust inherit from `apicomponent`, define the endpoints, and use the connection to make requests. if needed also inherit from protocol to handle different comunications aspects with the api server.\r\n\r\n```python\r\nfrom o365.utils import apicomponent\r\n\r\nclass customclass(apicomponent):\r\n    _endpoints = {'my_url_key': '/customendpoint'}\r\n\r\n    def __init__(self, *, parent=none, con=none, **kwargs):\r\n        # connection is only needed if you want to communicate with the api provider\r\n        self.con = parent.con if parent else con\r\n        protocol = parent.protocol if parent else kwargs.get('protocol')\r\n        main_resource = parent.main_resource\r\n\r\n        super().__init__(protocol=protocol, main_resource=main_resource)\r\n        # ...\r\n\r\n    def do_some_stuff(self):\r\n\r\n        # self.build_url just merges the protocol service_url with the enpoint passed as a parameter\r\n        # to change the service_url implement your own protocol inherinting from protocol class\r\n        url = self.build_url(self._endpoints.get('my_url_key'))\r\n\r\n        my_params = {'param1': 'param1'}\r\n\r\n        response = self.con.get(url, params=my_params)  # note the use of the connection here.\r\n\r\n        # handle response and return to the user...\r\n\r\n# the use it as follows:\r\nfrom o365 import connection, msgraphprotocol\r\n\r\nprotocol = msgraphprotocol()  # or maybe a user defined protocol\r\ncon = connection(('client_id', 'client_secret'), scopes=protocol.get_scopes_for(['...']))\r\ncustom_class = customclass(con=con, protocol=protocol)\r\n\r\ncustom_class.do_some_stuff()\r\n```\r\n\r\n## mailbox\r\nmailbox groups the funcionality of both the messages and the email folders.\r\n\r\nthese are the scopes needed to work with the `mailbox` and `message` classes.\r\n\r\n raw scope                   |  included in scope helper                  | description\r\n :---:                       |  :---:                                     | ---\r\n *mail.read*                 |  *mailbox*                                 | to only read my mailbox\r\n *mail.read.shared*          |  *mailbox_shared*                          | to only read another user / shared mailboxes\r\n *mail.send*                 |  *message_send, message_all*               | to only send message\r\n *mail.send.shared*          |  *message_send_shared, message_all_shared* | to only send message as another user / shared mailbox\r\n *mail.readwrite*            |  *message_all*                             | to read and save messages in my mailbox\r\n *mailboxsettings.readwrite* |  *mailbox_settings*                        | to read and write suer mailbox settings\r\n\r\n```python\r\nmailbox = account.mailbox()\r\n\r\ninbox = mailbox.inbox_folder()\r\n\r\nfor message in inbox.get_messages():\r\n    print(message)\r\n\r\nsent_folder = mailbox.sent_folder()\r\n\r\nfor message in sent_folder.get_messages():\r\n    print(message)\r\n\r\nm = mailbox.new_message()\r\n\r\nm.to.add('to_example@example.com')\r\nm.body = 'george best quote: in 1969 i gave up women and alcohol - it was the worst 20 minutes of my life.'\r\nm.save_draft()\r\n```\r\n\r\n#### email folder\r\nrepresents a `folder` within your email mailbox.\r\n\r\nyou can get any folder in your mailbox by requesting child folders or filtering by name.\r\n\r\n```python\r\nmailbox = account.mailbox()\r\n\r\narchive = mailbox.get_folder(folder_name='archive')  # get a folder with 'archive' name\r\n\r\nchild_folders = archive.get_folders(25) # get at most 25 child folders of 'archive' folder\r\n\r\nfor folder in child_folders:\r\n    print(folder.name, folder.parent_id)\r\n\r\nnew_folder = archive.create_child_folder('george best quotes')\r\n```\r\n\r\n#### message\r\nan email object with all its data and methods.\r\n\r\ncreating a draft message is as easy as this:\r\n```python\r\nmessage = mailbox.new_message()\r\nmessage.to.add(['example1@example.com', 'example2@example.com'])\r\nmessage.sender.address = 'my_shared_account@example.com'  # changing the from address\r\nmessage.body = 'george best quote: i might go to alcoholics anonymous, but i think it would be difficult for me to remain anonymous'\r\nmessage.attachments.add('george_best_quotes.txt')\r\nmessage.save_draft()  # save the message on the cloud as a draft in the drafts folder\r\n```\r\n\r\nworking with saved emails is also easy:\r\n```python\r\nquery = mailbox.new_query().on_attribute('subject').contains('george best')  # see query object in utils\r\nmessages = mailbox.get_messages(limit=25, query=query)\r\n\r\nmessage = messages[0]  # get the first one\r\n\r\nmessage.mark_as_read()\r\nreply_msg = message.reply()\r\n\r\nif 'example@example.com' in reply_msg.to:  # magic methods implemented\r\n    reply_msg.body = 'george best quote: i spent a lot of money on booze, birds and fast cars. the rest i just squandered.'\r\nelse:\r\n    reply_msg.body = 'george best quote: i used to go missing a lot... miss canada, miss united kingdom, miss world.'\r\n\r\nreply_msg.send()\r\n```\r\n\r\n##### sending inline images\r\nyou can send inline images by doing this:\r\n\r\n```python\r\n# ...\r\nmsg = account.new_message()\r\nmsg.to.add('george@best.com')\r\nmsg.attachments.add('my_image.png')\r\natt = msg.attachments[0]  # get the attachment object\r\n\r\n# this is super important for this to work.\r\natt.is_inline = true\r\natt.content_id = 'image.png'\r\n\r\n# notice we insert an image tag with source to: \"cid:{content_id}\"\r\nbody = \"\"\"\r\n    <html>\r\n        <body>\r\n            <strong>there should be an image here:</strong>\r\n            <p>\r\n                <img src=\"cid:image.png\">\r\n            </p>\r\n        </body>\r\n    </html>\r\n    \"\"\"\r\nmsg.body = body\r\nmsg.send()\r\n```\r\n\r\n##### retrieving message headers\r\nyou can retrieve message headers by doing this:\r\n\r\n```python\r\n# ...\r\nmb = account.mailbox()\r\nmsg = mb.get_message(query=mb.q().select('internet_message_headers'))\r\nprint(msg.message_headers)  # returns a list of dicts.\r\n```\r\n\r\nnote that only message headers and other properties added to the select statement will be present.\r\n\r\n##### saving as eml\r\nmessages and attached messages can be saved as *.eml.\r\n\r\n - save message as \"eml\":\r\n    ```python\r\n        msg.save_as_eml(to_path=path('my_saved_email.eml'))\r\n    ```\r\n- save attached message as \"eml\":\r\n\r\n    carefull: there's no way to identify that an attachment is in fact a message. you can only check if the attachment.attachment_type == 'item'.\r\n    if is of type \"item\" then it can be a message (or an event, etc...). you will have to determine this yourself.\r\n\r\n    ```python\r\n        msg_attachment = msg.attachments[0]  # the first attachment is attachment.attachment_type == 'item' and i know it's a message.\r\n        msg.attachments.save_as_eml(msg_attachment, to_path=path('my_saved_email.eml'))\r\n    ```\r\n\r\n#### mailbox settings\r\nthe mailbox settings and associated methods.\r\n\r\nretrieve and update mailbox auto reply settings:\r\n```python\r\nfrom o365.mailbox import autoreplystatus, externalaudience\r\n\r\nmailboxsettings = mailbox.get_settings()\r\nars = mailboxsettings.automaticrepliessettings\r\n\r\nars.scheduled_startdatetime = start # sets the start date/time\r\nars.scheduled_enddatetime = end # sets the end date/time\r\nars.status = autoreplystatus.scheduled # disabled/scheduled/alwaysenabled - uses start/end date/time if scheduled.\r\nars.external_audience = externalaudience.none # none/contactsonly/all\r\nars.internal_reply_message = \"ars internal\" # internal message\r\nars.external_reply_message = \"ars external\" # external message\r\nmailboxsettings.save()\r\n```\r\n\r\nalternatively to enable and disable\r\n```python\r\nmailboxsettings.save()\r\n\r\nmailbox.set_automatic_reply(\r\n    \"internal\",\r\n    \"external\",\r\n    scheduled_start_date_time=start, # status will be 'scheduled' if start/end supplied, otherwise 'alwaysenabled'\r\n    scheduled_end_date_time=end,\r\n    externalaudience=externalaudience.none, # defaults to all\r\n)\r\nmailbox.set_disable_reply()\r\n```\r\n\r\n## addressbook\r\naddressbook groups the functionality of both the contact folders and contacts. outlook distribution groups are not supported (by the microsoft api's).\r\n\r\nthese are the scopes needed to work with the `addressbook` and `contact` classes.\r\n\r\n raw scope                       |  included in scope helper                        | description\r\n :---:                           |  :---:                                          | ---\r\n *contacts.read*                 |  *address_book*                                 | to only read my personal contacts\r\n *contacts.read.shared*          |  *address_book_shared*                          | to only read another user / shared mailbox contacts\r\n *contacts.readwrite*            |  *address_book_all*                             | to read and save personal contacts\r\n *contacts.readwrite.shared*     |  *address_book_all_shared*                      | to read and save contacts from another user / shared mailbox\r\n *user.readbasic.all*            |  *users*                                        | to only read basic properties from users of my organization (user.read.all requires administrator consent).\r\n\r\n#### contact folders\r\nrepresents a folder within your contacts section in office 365.\r\naddressbook class represents the parent folder (it's a folder itself).\r\n\r\nyou can get any folder in your address book by requesting child folders or filtering by name.\r\n\r\n```python\r\naddress_book = account.address_book()\r\n\r\ncontacts = address_book.get_contacts(limit=none)  # get all the contacts in the personal contacts root folder\r\n\r\nwork_contacts_folder = address_book.get_folder(folder_name='work contacts')  # get a folder with 'work contacts' name\r\n\r\nmessage_to_all_contats_in_folder = work_contacts_folder.new_message()  # creates a draft message with all the contacts as recipients\r\n\r\nmessage_to_all_contats_in_folder.subject = 'hallo!'\r\nmessage_to_all_contats_in_folder.body = \"\"\"\r\ngeorge best quote:\r\n\r\nif you'd given me the choice of going out and beating four men and smashing a goal in\r\nfrom thirty yards against liverpool or going to bed with miss world,\r\nit would have been a difficult choice. luckily, i had both.\r\n\"\"\"\r\nmessage_to_all_contats_in_folder.send()\r\n\r\n# querying folders is easy:\r\nchild_folders = address_book.get_folders(25) # get at most 25 child folders\r\n\r\nfor folder in child_folders:\r\n    print(folder.name, folder.parent_id)\r\n\r\n# creating a contact folder:\r\naddress_book.create_child_folder('new folder')\r\n```\r\n\r\n#### the global address list\r\noffice 365 api (nor ms graph api) has no concept such as the outlook global address list.\r\nhowever you can use the [users api](https://developer.microsoft.com/en-us/graph/docs/api-reference/v1.0/resources/users) to access all the users within your organization.\r\n\r\nwithout admin consent you can only access a few properties of each user such as name and email and litte more.\r\nyou can search by name or retrieve a contact specifying the complete email.\r\n\r\n- basic permision needed is users.readbasic.all (limit info)\r\n- full permision is users.read.all but needs admin consent.\r\n\r\nto search the global address list (users api):\r\n\r\n```python\r\nglobal_address_list = account.directory()\r\n\r\n# for backwards compatibilty only this also works and returns a directory object:\r\n# global_address_list = account.address_book(address_book='gal')\r\n\r\n# start a new query:\r\nq = global_address_list.new_query('display_name')\r\nq.startswith('george best')\r\n\r\nfor user in global_address_list.get_users(query=q):\r\n    print(user)\r\n```\r\n\r\n\r\nto retrieve a contact by their email:\r\n\r\n```python\r\ncontact = global_address_list.get_user('example@example.com')\r\n```\r\n\r\n#### contacts\r\neverything returned from an `addressbook` instance is a `contact` instance.\r\ncontacts have all the information stored as attributes\r\n\r\ncreating a contact from an `addressbook`:\r\n\r\n```python\r\nnew_contact = address_book.new_contact()\r\n\r\nnew_contact.name = 'george best'\r\nnew_contact.job_title = 'football player'\r\nnew_contact.emails.add('george@best.com')\r\n\r\nnew_contact.save()  # saved on the cloud\r\n\r\nmessage = new_contact.new_message()  #  bonus: send a message to this contact\r\n\r\n# ...\r\n\r\nnew_contact.delete()  # bonus: deteled from the cloud\r\n```\r\n\r\n\r\n## directory and users\r\nthe directory object can retrieve users.\r\n\r\na user instance contains by default the [basic properties of the user](https://docs.microsoft.com/en-us/graph/api/user-list?view=graph-rest-1.0&tabs=http#optional-query-parameters).\r\nif you want to include more, you will have to select the desired properties manually.\r\n\r\ncheck [the global address list](#the-global-address-list) for further information.\r\n\r\nthese are the scopes needed to work with the `directory` class.\r\n\r\n raw scope                        |  included in scope helper                       | description\r\n :---:                            |  :---:                                          | ---\r\n *user.readbasic.all*             |  *users*                                        | to read a basic set of profile properties of other users in your organization on behalf of the signed-in user. this includes display name, first and last name, email address, open extensions and photo. also allows the app to read the full profile of the signed-in user.\r\n *user.read.all*                  |  *\u00e2\u20ac\u201d*                                            | to read the full set of profile properties, reports, and managers of other users in your organization, on behalf of the signed-in user.\r\n *user.readwrite.all*             |  *\u00e2\u20ac\u201d*                                            | to read and write the full set of profile properties, reports, and managers of other users in your organization, on behalf of the signed-in user. also allows the app to create and delete users as well as reset user passwords on behalf of the signed-in user.\r\n *directory.read.all*             |  *\u00e2\u20ac\u201d*                                            | to read data in your organization's directory, such as users, groups and apps, without a signed-in user.\r\n *directory.readwrite.all*        |  *\u00e2\u20ac\u201d*                                            | to read and write data in your organization's directory, such as users, and groups, without a signed-in user. does not allow user or group deletion.\r\n\r\nnote: to get authorized with the above scopes you need a work or school account, it doesn't work with personal account.\r\n\r\nworking with the `directory` instance to read the active directory users:\r\n\r\n```python\r\ndirectory = account.directory()\r\nfor user in directory.get_users():\r\n    print(user)\r\n```\r\n\r\n\r\n## calendar\r\nthe calendar and events functionality is group in a `schedule` object.\r\n\r\na `schedule` instance can list and create calendars. it can also list or create events on the default user calendar.\r\nto use other calendars use a `calendar` instance.\r\n\r\nthese are the scopes needed to work with the `schedule`, `calendar` and `event` classes.\r\n\r\n raw scope                        |  included in scope helper                        | description\r\n :---:                            |  :---:                                          | ---\r\n *calendars.read*                 |  *calendar*                                     | to only read my personal calendars\r\n *calendars.read.shared*          |  *calendar_shared*                              | to only read another user / shared mailbox calendars\r\n *calendars.readwrite*            |  *calendar_all*                                 | to read and save personal calendars\r\n *calendars.readwrite.shared*     |  *calendar_shared_all*                          | to read and save calendars from another user / shared mailbox\r\n\r\n\r\nworking with the `schedule` instance:\r\n```python\r\nimport datetime as dt\r\n\r\n# ...\r\nschedule = account.schedule()\r\n\r\ncalendar = schedule.get_default_calendar()\r\nnew_event = calendar.new_event()  # creates a new unsaved event\r\nnew_event.subject = 'recruit george best!'\r\nnew_event.location = 'england'\r\n\r\n# naive datetimes will automatically be converted to timezone aware datetime\r\n#  objects using the local timezone detected or the protocol provided timezone\r\n\r\nnew_event.start = dt.datetime(2019, 9, 5, 19, 45)\r\n# so new_event.start becomes: datetime.datetime(2018, 9, 5, 19, 45, tzinfo=<dsttzinfo 'europe/paris' cest+2:00:00 dst>)\r\n\r\nnew_event.recurrence.set_daily(1, end=dt.datetime(2019, 9, 10))\r\nnew_event.remind_before_minutes = 45\r\n\r\nnew_event.save()\r\n```\r\n\r\nworking with `calendar` instances:\r\n\r\n```python\r\ncalendar = schedule.get_calendar(calendar_name='birthdays')\r\n\r\ncalendar.name = 'football players birthdays'\r\ncalendar.update()\r\n\r\nq = calendar.new_query('start').greater_equal(dt.datetime(2018, 5, 20))\r\nq.chain('and').on_attribute('end').less_equal(dt.datetime(2018, 5, 24))\r\n\r\nbirthdays = calendar.get_events(query=q, include_recurring=true)  # include_recurring=true will include repeated events on the result set.\r\n\r\nfor event in birthdays:\r\n    if event.subject == 'george best birthday':\r\n        # he died in 2005... but we celebrate anyway!\r\n        event.accept(\"i'll attend!\")  # send a response accepting\r\n    else:\r\n        event.decline(\"no way i'm comming, i'll be in spain\", send_response=false)  # decline the event but don't send a reponse to the organizer\r\n```\r\n\r\n#### notes regarding calendars and events:\r\n\r\n1. include_recurring=true:\r\n    > it's important to know that when querying events with `include_recurring=true` (which is the default), it is required that you must provide a query parameter with the start and end attributes defined.\r\n    > unlike when using `include_recurring=false` those attributes will not filter the data based on the operations you set on the query (greater_equal, less, etc.) but just filter the events start datetime between the provided start and end datetimes.\r\n\r\n1. shared calendars:\r\n\r\n    there are some known issues when working with [shared calendars](https://docs.microsoft.com/en-us/graph/known-issues#calendars) in microsoft graph.\r\n\r\n1. event attachments:\r\n\r\n    for some unknow reason, microsoft does not allow to upload an attachment at the event creation time (as opposed with message attachments).\r\n    see [this](https://stackoverflow.com/questions/46438302/office365-rest-api-creating-a-calendar-event-with-attachments?rq=1).\r\n    so, to upload attachments to events, first save the event, then attach the message and save again.\r\n\r\n## tasks\r\n\r\nthe tasks functionality is grouped in a `todo` object.\r\n\r\na `todo` instance can list and create task folders. it can also list or create tasks on the default user folder. to use other folders use a `folder` instance.\r\n\r\nthese are the scopes needed to work with the `todo`, `folder` and `task` classes.\r\n\r\n raw scope                        |  included in scope helper                       | description\r\n :---:                            |  :---:                                          | ---\r\n *tasks.read*                     |  *tasks*                                        | to only read my personal tasks\r\n *tasks.readwrite*                |  *tasks_all*                                    | to read and save personal calendars\r\n\r\n working with the `todo` instance:\r\n```python\r\nimport datetime as dt\r\n\r\n# ...\r\ntodo = account.tasks()\r\n\r\n#list current tasks\r\nfolder = todo.get_default_folder()\r\nnew_task = folder.new_task()  # creates a new unsaved task\r\nnew_task.subject = 'send contract to george best'\r\nnew_task.due = dt.datetime(2020, 9, 25, 18, 30) \r\nnew_task.save()\r\n\r\n#some time later....\r\n\r\nnew_task.mark_completed()\r\nnew_task.save()\r\n\r\n# naive datetimes will automatically be converted to timezone aware datetime\r\n#  objects using the local timezone detected or the protocol provided timezone\r\n#  as with the calendar functionality\r\n\r\n```\r\n\r\nworking with `folder` instances:\r\n\r\n```python\r\n#create a new folder\r\nnew_folder = todo.new_folder('defenders')\r\n\r\n#rename a folder\r\nfolder = todo.get_folder(folder_name='strikers')\r\nfolder.name = 'forwards'\r\nfolder.update()\r\n\r\n#list current tasks\r\ntask_list = folder.get_tasks()\r\nfor task in task_list:\r\n    print(task)\r\n    print('')\r\n```\r\n\r\n## onedrive\r\nthe `storage` class handles all functionality around one drive and document library storage in sharepoint.\r\n\r\nthe `storage` instance allows to retrieve `drive` instances which handles all the files and folders from within the selected `storage`.\r\nusually you will only need to work with the default drive. but the `storage` instances can handle multiple drives.\r\n\r\na `drive` will allow you to work with folders and files.\r\n\r\nthese are the scopes needed to work with the `storage`, `drive` and `driveitem` classes.\r\n\r\n raw scope                  |  included in scope helper     | description\r\n :---:                      |  :---:                       | ---\r\n *files.read*               |                              | to only read my files\r\n *files.read.all*           |  *onedrive*                  | to only read all the files the user has access\r\n *files.readwrite*          |                              | to read and save my files\r\n *files.readwrite.all*      |  *onedrive_all*              | to read and save all the files the user has access\r\n\r\n\r\n```python\r\naccount = account(credentials=my_credentials)\r\n\r\nstorage = account.storage()  # here we get the storage instance that handles all the storage options.\r\n\r\n# list all the drives:\r\ndrives = storage.get_drives()\r\n\r\n# get the default drive\r\nmy_drive = storage.get_default_drive()  # or get_drive('drive-id')\r\n\r\n# get some folders:\r\nroot_folder = my_drive.get_root_folder()\r\nattachments_folder = my_drive.get_special_folder('attachments')\r\n\r\n# iterate over the first 25 items on the root folder\r\nfor item in root_folder.get_items(limit=25):\r\n    if item.is_folder:\r\n        print(list(item.get_items(2)))  # print the first to element on this folder.\r\n    elif item.is_file:\r\n        if item.is_photo:\r\n            print(item.camera_model)  # print some metadata of this photo\r\n        elif item.is_image:\r\n            print(item.dimensions)  # print the image dimensions\r\n        else:\r\n            # regular file:\r\n            print(item.mime_type)  # print the mime type\r\n```\r\n\r\nboth files and folders are driveitems. both image and photo are files, but photo is also an image. all have some different methods and properties.\r\ntake care when using 'is_xxxx'.\r\n\r\nwhen copying a driveitem the api can return a direct copy of the item or a pointer to a resource that will inform on the progress of the copy operation.\r\n\r\n```python\r\n# copy a file to the documents special folder\r\n\r\ndocuments_folder = my_drive.get_special_folder('documents')\r\n\r\nfiles = my_drive.search('george best quotes', limit=1)\r\n\r\nif files:\r\n    george_best_quotes = files[0]\r\n    operation = george_best_quotes.copy(target=documents_folder)  # operation here is an instance of copyoperation\r\n\r\n    # to check for the result just loop over check_status.\r\n    # check_status is a generator that will yield a new status and progress until the file is finally copied\r\n    for status, progress in operation.check_status():  # if it's an async operations, this will request to the api for the status in every loop\r\n        print(f\"{status} - {progress}\")  # prints 'in progress - 77.3' until finally completed: 'completed - 100.0'\r\n    copied_item = operation.get_item()  # the copy operation is completed so you can get the item.\r\n    if copied_item:\r\n        copied_item.delete()  # ... oops!\r\n```\r\n\r\nyou can also work with share permissions:\r\n\r\n```python\r\ncurrent_permisions = file.get_permissions()  # get all the current permissions on this drive_item (some may be inherited)\r\n\r\n# share with link\r\npermission = file.share_with_link(share_type='edit')\r\nif permission:\r\n    print(permission.share_link)  # the link you can use to share this drive item\r\n# share with invite\r\npermission = file.share_with_invite(recipients='george_best@best.com', send_email=true, message='greetings!!', share_type='edit')\r\nif permission:\r\n    print(permission.granted_to)  # the person you share this item with\r\n```\r\n\r\nyou can also:\r\n```python\r\n# download files:\r\nfile.download(to_path='/quotes/')\r\n\r\n# upload files:\r\n\r\n# if the uploaded file is bigger than 4mb the file will be uploaded in chunks of 5 mb until completed.\r\n# this can take several requests and can be time consuming.\r\nuploaded_file = folder.upload_file(item='path_to_my_local_file')\r\n\r\n# restore versions:\r\nversions = file.get_versions()\r\nfor version in versions:\r\n    if version.name == '2.0':\r\n        version.restore()  # restore the version 2.0 of this file\r\n\r\n# ... and much more ...\r\n```\r\n\r\n\r\n## excel\r\nyou can interact with new excel files (.xlsx) stored in onedrive or a sharepoint document library.\r\nyou can retrieve workbooks, worksheets, tables, and even cell data.\r\nyou can also write to any excel online.\r\n\r\nto work with excel files, first you have to retrieve a `file` instance using the onedrive or sharepoint functionallity.\r\n\r\nthe scopes needed to work with the `workbook` and excel related classes are the same used by onedrive.\r\n\r\nthis is how you update a cell value:\r\n\r\n```python\r\nfrom o365.excel import workbook\r\n\r\n# given a file instance that is a xlsx file ...\r\nexcel_file = workbook(my_file_instance)  # my_file_instance should be an instance of file.\r\n\r\nws = excel_file.get_worksheet('my_worksheet')\r\ncella1 = ws.get_range('a1')\r\ncella1.values = 35\r\ncella1.update()\r\n```\r\n\r\n#### workbook sessions\r\nwhen interacting with excel, you can use a workbook session to efficiently make changes in a persistent or nonpersistent way.\r\nthis sessions become usefull if you perform numerous changes to the excel file.\r\n\r\nthe default is to use a session in a persistent way.\r\nsessions expire after some time of inactivity. when working with persistent sessions, new sessions will automatically be created when old ones expire.\r\n\r\nyou can however change this when creating the `workbook` instance:\r\n\r\n```python\r\nexcel_file = workbook(my_file_instance, use_session=false, persist=false)\r\n```\r\n\r\n#### available objects\r\n\r\nafter creating the `workbook` instance you will have access to the following objects:\r\n\r\n- worksheet\r\n- range and namedrange\r\n- table, tablecolumn and tablerow\r\n- rangeformat (to format ranges)\r\n- charts (not available for now)\r\n\r\nsome examples:\r\n\r\nset format for a given range\r\n```python\r\n# ...\r\nmy_range = ws.get_range('b2:c10')\r\nfmt = myrange.get_format()\r\nfmt.font.bold = true\r\nfmt.update()\r\n```\r\nautofit columns:\r\n```python\r\nws.get_range('b2:c10').get_format().auto_fit_columns()\r\n```\r\n\r\nget values from table:\r\n```python\r\ntable = ws.get_table('my_table')\r\ncolumn = table.get_column_at_index(1)\r\nvalues = column.values[0]  # values returns a two dimensional array.\r\n```\r\n\r\n## sharepoint\r\nthe sharepoint api is done but there are no docs yet. look at the sharepoint.py file to get insights.\r\n\r\nthese are the scopes needed to work with the `sharepoint` and `site` classes.\r\n\r\n raw scope                  |  included in scope helper    | description\r\n :---:                      |  :---:                       | ---\r\n *sites.read.all*           |  *sharepoint*                | to only read sites, lists and items\r\n *sites.readwrite.all*      |  *sharepoint_dl*             | to read and save sites, lists and items\r\n\r\n## planner\r\nthe planner api is done but there are no docs yet. look at the planner.py file to get insights.\r\n\r\nthe planner functionality requires administrator permission.\r\n\r\n## outlook categories\r\nyou can retrive, update, create and delete outlook categories.\r\nthese categories can be used to categorize messages, events and contacts.\r\n\r\nthese are the scopes needed to work with the `sharepoint` and `site` classes.\r\n\r\n raw scope                      |  included in scope helper     | description\r\n :---:                          |  :---:                        | ---\r\n *mailboxsettings.read*         |  *-*                          | to only read outlook settingss\r\n *mailboxsettings.readwrite*    |  *settings_all*               | to read and write outlook settings\r\n\r\nexample:\r\n\r\n```python\r\nfrom o365.category import categorycolor\r\n\r\noc = account.outlook_categories()\r\ncategories = oc.get_categories()\r\nfor category in categories:\r\n    print(category.name, category.color)\r\n\r\nmy_category = oc.create_category('important category', color=categorycolor.red)\r\nmy_category.update_color(categorycolor.darkgreen)\r\n\r\nmy_category.delete()  # oops!\r\n```\r\n\r\n## utils\r\n\r\n#### pagination\r\n\r\nwhen using certain methods, it is possible that you request more items than the api can return in a single api call.\r\nin this case the api, returns a \"next link\" url where you can pull more data.\r\n\r\nwhen this is the case, the methods in this library will return a `pagination` object which abstracts all this into a single iterator.\r\nthe pagination object will request \"next links\" as soon as they are needed.\r\n\r\nfor example:\r\n\r\n```python\r\nmailbox = account.mailbox()\r\n\r\nmessages = mailbox.get_messages(limit=1500)  # the office 365 and ms graph api have a 999 items limit returned per api call.\r\n\r\n# here messages is a pagination instance. it's an iterator so you can iterate over.\r\n\r\n# the first 999 iterations will be normal list iterations, returning one item at a time.\r\n# when the iterator reaches the 1000 item, the pagination instance will call the api again requesting exactly 500 items\r\n# or the items specified in the batch parameter (see later).\r\n\r\nfor message in messages:\r\n    print(message.subject)\r\n```\r\n\r\nwhen using certain methods you will have the option to specify not only a limit option (the number of items to be returned) but a batch option.\r\nthis option will indicate the method to request data to the api in batches until the limit is reached or the data consumed.\r\nthis is usefull when you want to optimize memory or network latency.\r\n\r\nfor example:\r\n\r\n```python\r\nmessages = mailbox.get_messages(limit=100, batch=25)\r\n\r\n# messages here is a pagination instance\r\n# when iterating over it will call the api 4 times (each requesting 25 items).\r\n\r\nfor message in messages:  # 100 loops with 4 requests to the api server\r\n    print(message.subject)\r\n```\r\n\r\n#### the query helper\r\n\r\nwhen using the office 365 api you can filter, order, select, expand or search on some fields.\r\nthis filtering is tedious as is using [open data protocol (odata)](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part2-url-conventions/odata-v4.0-errata03-os-part2-url-conventions-complete.html).\r\n\r\nevery `apicomponent` (such as `mailbox`) implements a new_query method that will return a `query` instance.\r\nthis `query` instance can handle the filtering, sorting, selecting, expanding and search very easily.\r\n\r\nfor example:\r\n\r\n```python\r\nquery = mailbox.new_query()  # you can use the shorthand: mailbox.q()\r\n\r\nquery = query.on_attribute('subject').contains('george best').chain('or').startswith('quotes')\r\n\r\n# 'created_date_time' will automatically be converted to the protocol casing.\r\n# for example when using ms graph this will become 'createddatetime'.\r\n\r\nquery = query.chain('and').on_attribute('created_date_time').greater(datetime(2018, 3, 21))\r\n\r\nprint(query)\r\n\r\n# contains(subject, 'george best') or startswith(subject, 'quotes') and createddatetime gt '2018-03-21t00:00:00z'\r\n# note you can pass naive datetimes and those will be converted to you local timezone and then send to the api as utc in iso8601 format\r\n\r\n# to use query objetcs just pass it to the query parameter:\r\nfiltered_messages = mailbox.get_messages(query=query)\r\n```\r\n\r\nyou can also specify specific data to be retrieved with \"select\":\r\n\r\n```python\r\n# select only some properties for the retrieved messages:\r\nquery = mailbox.new_query().select('subject', 'to_recipients', 'created_date_time')\r\n\r\nmessages_with_selected_properties = mailbox.get_messages(query=query)\r\n```\r\n\r\nyou can also search content. as said in the graph docs:\r\n\r\n> you can currently search only message and person collections. a $search request returns up to 250 results. you cannot use $filter or $orderby in a search request.\r\n\r\n> if you do a search on messages and specify only a value without specific message properties, the search is carried out on the default search properties of from, subject, and body.\r\n\r\n```python\r\n# searching is the easy part ;)\r\nquery = mailbox.q().search('george best is da boss')\r\nmessages = mailbox.get_messages(query=query)\r\n```\r\n\r\n#### request error handling\r\n\r\nwhenever a request error raises, the connection object will raise an exception.\r\nthen the exception will be captured and logged it to the stdout with it's message, an return falsy (none, false, [], etc...)\r\n\r\nhttperrors 4xx (bad request) and 5xx (internal server error) are considered exceptions and raised also by the connection.\r\nyou can tell the `connection` to not raise http errors by passing `raise_http_errors=false` (defaults to true).\r\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license 2.0",
  "name": "o365",
  "package_url": "https://pypi.org/project/O365/",
  "project_url": "https://pypi.org/project/O365/",
  "project_urls": {
    "Homepage": "https://github.com/O365/python-o365"
  },
  "release_url": "https://pypi.org/project/O365/2.0.31/",
  "requires_dist": [
    "requests (>=2.18.0)",
    "requests-oauthlib (>=1.2.0)",
    "python-dateutil (>=2.7)",
    "tzlocal (<5.0,>=4.0)",
    "beautifulsoup4 (>=4.0.0)",
    "stringcase (>=1.2.0)"
  ],
  "requires_python": ">=3.9",
  "summary": "microsoft graph and office 365 api made easy",
  "version": "2.0.31",
  "releases": [],
  "developers": [
    "janscas",
    "janscas@users.noreply.github.com"
  ],
  "kwds": "documentation office365 protocol_office o365 pyversions",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_o365",
  "homepage": "https://github.com/o365/python-o365",
  "release_count": 77,
  "dependency_ids": [
    "pypi_beautifulsoup4",
    "pypi_python_dateutil",
    "pypi_requests",
    "pypi_requests_oauthlib",
    "pypi_stringcase",
    "pypi_tzlocal"
  ]
}