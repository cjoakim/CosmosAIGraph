{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries"
  ],
  "description": "# relay library for graphql python\n\ngraphql-relay-py is the [relay](https://relay.dev/) library for\n[graphql-core](https://github.com/graphql-python/graphql-core).\n\nit allows the easy creation of relay-compliant servers using graphql-core.\n\ngraphql-relay-py is a python port of\n[graphql-relay-js](https://github.com/graphql/graphql-relay-js),\nwhile graphql-core is a python port of\n[graphql.js](https://github.com/graphql/graphql-js),\nthe reference implementation of graphql for javascript.\n\nsince version 3, graphql-relay-py and graphql-core support python 3.6 and above only.\nfor older versions of python, you can use version 2 of these libraries.\n\n[![pypi version](https://badge.fury.io/py/graphql-relay.svg)](https://badge.fury.io/py/graphql-relay)\n![test status](https://github.com/graphql-python/graphql-relay-py/actions/workflows/test.yml/badge.svg)\n![lint status](https://github.com/graphql-python/graphql-relay-py/actions/workflows/lint.yml/badge.svg)\n[![dependency updates](https://pyup.io/repos/github/graphql-python/graphql-relay-py/shield.svg)](https://pyup.io/repos/github/graphql-python/graphql-relay-py/)\n[![python 3 status](https://pyup.io/repos/github/graphql-python/graphql-relay-py/python-3-shield.svg)](https://pyup.io/repos/github/graphql-python/graphql-relay-py/)\n[![code style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\n## getting started\n\na basic understanding of graphql and of the graphql python implementation is needed\nto provide context for this library.\n\nan overview of graphql in general is available in the\n[readme](https://github.com/graphql-python/graphql-core/blob/master/readme.md) for the\n[specification for graphql](https://github.com/graphql-python/graphql-core).\n\nthis library is designed to work with the\nthe [graphql-core](https://github.com/graphql-python/graphql-core)\npython reference implementation of a graphql server.\n\nan overview of the functionality that a relay-compliant graphql server should provide\nis in the [graphql relay specification](https://facebook.github.io/relay/docs/graphql-relay-specification.html)\non the [relay website](https://facebook.github.io/relay/).\nthat overview describes a simple set of examples that exist\nas [tests](tests) in this repository.\na good way to get started with this repository is to walk through that documentation\nand the corresponding tests in this library together.\n\n## using relay library for graphql python (graphql-core)\n\ninstall relay library for graphql python\n\n```sh\npip install graphql-core\npip install graphql-relay\n```\n\nwhen building a schema for [graphql](https://github.com/graphql-python/graphql-core),\nthe provided library functions can be used to simplify the creation of relay patterns.\n\nall the functions that are explained in the following sections must be\nimported from the top level of the `graphql_relay` package, like this:\n```python\nfrom graphql_relay import connection_definitions\n```\n\n### connections\n\nhelper functions are provided for both building the graphql types\nfor connections and for implementing the `resolve` method for fields\nreturning those types.\n\n - `connection_args` returns the arguments that fields should provide when\nthey return a connection type that supports bidirectional pagination.\n - `forward_connection_args` returns the arguments that fields should provide when\nthey return a connection type that only supports forward pagination.\n - `backward_connection_args` returns the arguments that fields should provide when\nthey return a connection type that only supports backward pagination.\n - `connection_definitions` returns a `connection_type` and its associated\n`edgetype`, given a name and a node type.\n - `connection_from_array` is a helper method that takes an array and the\narguments from `connection_args`, does pagination and filtering, and returns\nan object in the shape expected by a `connection_type`'s `resolve` function.\n - `cursor_for_object_in_connection` is a helper method that takes an array and a\nmember object, and returns a cursor for use in the mutation payload.\n - `offset_to_cursor` takes the index of a member object in an array\n and returns an opaque cursor for use in the mutation payload.\n - `cursor_to_offset` takes an opaque cursor (created with `offset_to_cursor`)\nand returns the corresponding array index.\n\nan example usage of these methods from the [test schema](tests/star_wars_schema.py):\n\n```python\nship_edge, ship_connection = connection_definitions(ship_type, \"ship\")\n\nfaction_type = graphqlobjecttype(\n    name=\"faction\",\n    description=\"a faction in the star wars saga\",\n    fields=lambda: {\n        \"id\": global_id_field(\"faction\"),\n        \"name\": graphqlfield(graphqlstring, description=\"the name of the faction.\"),\n        \"ships\": graphqlfield(\n            ship_connection,\n            description=\"the ships used by the faction.\",\n            args=connection_args,\n            resolve=lambda faction, _info, **args: connection_from_array(\n                [get_ship(ship) for ship in faction.ships], args\n            ),\n        ),\n    },\n    interfaces=[node_interface],\n)\n```\n\nthis shows adding a `ships` field to the `faction` object that is a connection.\nit uses `connection_definitions(ship_type, \"ship\")` to create the connection\ntype, adds `connection_args` as arguments on this function, and then implements\nthe resolver function by passing the array of ships and the arguments to\n`connection_from_array`.\n\n### object identification\n\nhelper functions are provided for both building the graphql types\nfor nodes and for implementing global ids around local ids.\n\n - `node_definitions` returns the `node` interface that objects can implement,\n    and returns the `node` root field to include on the query type.\n    to implement this, it takes a function to resolve an id to an object,\n    and to determine the type of a given object.\n - `to_global_id` takes a type name and an id specific to that type name,\n    and returns a \"global id\" that is unique among all types.\n - `from_global_id` takes the \"global id\" created by `to_global_id`, and\n    returns the type name and id used to create it.\n - `global_id_field` creates the configuration for an `id` field on a node.\n - `plural_identifying_root_field` creates a field that accepts a list of\n    non-id identifiers (like a username) and maps then to their corresponding\n    objects.\n\nan example usage of these methods from the [test schema](tests/star_wars_schema.py):\n\n```python\ndef get_node(global_id, _info):\n    type_, id_ = from_global_id(global_id)\n    if type_ == \"faction\":\n        return get_faction(id_)\n    if type_ == \"ship\":\n        return get_ship(id_)\n    return none  # pragma: no cover\n\ndef get_node_type(obj, _info, _type):\n    if isinstance(obj, faction):\n        return faction_type.name\n    return ship_type.name\n\nnode_interface, node_field = node_definitions(get_node, get_node_type)[:2]\n\nfaction_type = graphqlobjecttype(\n    name=\"faction\",\n    description=\"a faction in the star wars saga\",\n    fields=lambda: {\n        \"id\": global_id_field(\"faction\"),\n        \"name\": graphqlfield(graphqlstring, description=\"the name of the faction.\"),\n        \"ships\": graphqlfield(\n            ship_connection,\n            description=\"the ships used by the faction.\",\n            args=connection_args,\n            resolve=lambda faction, _info, **args: connection_from_array(\n                [get_ship(ship) for ship in faction.ships], args\n            ),\n        ),\n    },\n    interfaces=[node_interface],\n)\n\nquery_type = graphqlobjecttype(\n    name=\"query\",\n    fields=lambda: {\n        \"rebels\": graphqlfield(faction_type, resolve=lambda _obj, _info: get_rebels()),\n        \"empire\": graphqlfield(faction_type, resolve=lambda _obj, _info: get_empire()),\n        \"node\": node_field,\n    },\n)\n```\n\nthis uses `node_definitions` to construct the `node` interface and the `node`\nfield; it uses `from_global_id` to resolve the ids passed in the implementation\nof the function mapping id to object. it then uses the `global_id_field` method to\ncreate the `id` field on `faction`, which also ensures implements the\n`node_interface`. finally, it adds the `node` field to the query type, using the\n`node_field` returned by `node_definitions`.\n\n### mutations\n\na helper function is provided for building mutations with\nsingle inputs and client mutation ids.\n\n - `mutation_with_client_mutation_id` takes a name, input fields, output fields,\nand a mutation method to map from the input fields to the output fields,\nperforming the mutation along the way. it then creates and returns a field\nconfiguration that can be used as a top-level field on the mutation type.\n\nan example usage of these methods from the [test schema](tests/star_wars_schema.py):\n\n```python\nclass introduceshipmutation:\n\n    def __init__(self, shipid, factionid, clientmutationid=none):\n        self.shipid = shipid\n        self.factionid = factionid\n        self.clientmutationid = clientmutationid\n\ndef mutate_and_get_payload(_info, shipname, factionid, **_input):\n    new_ship = create_ship(shipname, factionid)\n    return introduceshipmutation(shipid=new_ship.id, factionid=factionid)\n\nship_mutation = mutation_with_client_mutation_id(\n    \"introduceship\",\n    input_fields={\n        \"shipname\": graphqlinputfield(graphqlnonnull(graphqlstring)),\n        \"factionid\": graphqlinputfield(graphqlnonnull(graphqlid)),\n    },\n    output_fields={\n        \"ship\": graphqlfield(\n            ship_type, resolve=lambda payload, _info: get_ship(payload.shipid)\n        ),\n        \"faction\": graphqlfield(\n            faction_type, resolve=lambda payload, _info: get_faction(payload.factionid)\n        ),\n    },\n    mutate_and_get_payload=mutate_and_get_payload,\n)\n\nmutation_type = graphqlobjecttype(\n    \"mutation\", fields=lambda: {\"introduceship\": ship_mutation}\n)\n```\n\nthis code creates a mutation named `introduceship`, which takes a faction\nid and a ship name as input. it outputs the `faction` and the `ship` in\nquestion. `mutate_and_get_payload` then gets each input field as keyword\nparameter, performs the mutation by constructing the new ship, then returns\nan object that will be resolved by the output fields.\n\nour mutation type then creates the `introduceship` field using the return\nvalue of `mutation_with_client_mutation_id`.\n\n## contributing\n\nafter cloning this repository from github,\nwe recommend using [poetry](https://poetry.eustace.io/)\nto create a test environment. with poetry installed,\nyou do this with the following command:\n\n```sh\npoetry install\n```\n\nyou can then run the complete test suite like this:\n\n```sh\npoetry run pytest\n```\n\nin order to run only a part of the tests with increased verbosity,\nyou can add pytest options, like this:\n\n```sh\npoetry run pytest tests/node -vv\n```\n\nin order to check the code style with flake8, use this:\n\n```sh\npoetry run flake8\n```\n\nuse the `tox` command to run the test suite with different\npython versions and perform all additional source code checks.\nyou can also restrict tox to an individual environment, like this:\n\n```sh\npoetry run tox -e py39\n```\n\n\n",
  "docs_url": null,
  "keywords": "graphql relay api",
  "license": "mit",
  "name": "graphql-relay",
  "package_url": "https://pypi.org/project/graphql-relay/",
  "project_url": "https://pypi.org/project/graphql-relay/",
  "project_urls": {
    "Homepage": "https://github.com/graphql-python/graphql-relay-py"
  },
  "release_url": "https://pypi.org/project/graphql-relay/3.2.0/",
  "requires_dist": [
    "graphql-core (<3.3,>=3.2)",
    "typing-extensions (<5,>=4.1) ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.6,<4",
  "summary": "relay library for graphql-core",
  "version": "3.2.0",
  "releases": [],
  "developers": [
    "me@syrusakbary.com",
    "syrus_akbary"
  ],
  "kwds": "graphql_relay graphql graphqlid graphqlinputfield graphqlstring",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_graphql_relay",
  "homepage": "https://github.com/graphql-python/graphql-relay-py",
  "release_count": 26,
  "dependency_ids": [
    "pypi_graphql_core",
    "pypi_typing_extensions"
  ]
}