{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: utilities"
  ],
  "description": "*******\nmartian\n*******\n\n.. image:: https://github.com/zopefoundation/martian/actions/workflows/tests.yml/badge.svg\n        :target: https://github.com/zopefoundation/martian/actions/workflows/tests.yml\n\n.. image:: https://img.shields.io/pypi/v/martian.svg\n        :target: https://pypi.python.org/pypi/martian\n        :alt: pypi\n\n.. image:: https://img.shields.io/pypi/pyversions/martian.svg\n        :target: https://pypi.python.org/pypi/martian\n        :alt: python versions\n\n\na library to grok configuration from python code.\n\nmartian tutorial\n****************\n\nintroduction\n============\n\n\"there was so much to grok, so little to grok from.\" -- stranger in a\nstrange land, by robert a. heinlein\n\nmartian provides infrastructure for declarative configuration of\npython code. martian is especially useful for the construction of\nframeworks that need to provide a flexible plugin\ninfrastructure. martian doesn't actually provide infrastructure for\nplugin registries (except for itself). many frameworks have their own\nsystems for this, and if you need a generic one, you might want to\nconsider ``zope.component``. martian just allows you to make the\nregistration of plugins less verbose.\n\nyou can see martian as doing something that you can also solve with\nmetaclasses, with the following advantages:\n\n* the developer of the framework doesn't have to write a lot of ad-hoc\n  metaclasses anymore; instead we offer an infrastructure to make life\n  easier.\n\n* configuration doesn't need to happen at import time, but can happen at\n  program startup time. this also makes configuration more tractable for\n  a developer.\n\n* we don't bother the developer that *uses* the framework with the\n  surprising behavior that metaclasses sometimes bring. the classes\n  the user has to deal with are normal classes.\n\nwhy is this package named ``martian``? in the novel \"stranger in a\nstrange land\", the verb *grok* is introduced:\n\n  grok means to understand so thoroughly that the observer becomes a\n  part of the observed -- to merge, blend, intermarry, lose identity\n  in group experience.\n\nin the context of this package, \"grokking\" stands for the process of\ndeducing declarative configuration actions from python code. in the\nnovel, grokking is originally a concept that comes from the planet\nmars. martians *grok*. since this package helps you grok code, it's\ncalled martian.\n\nmartian provides a framework that allows configuration to be expressed\nin declarative python code. these declarations can often be deduced\nfrom the structure of the code itself. the idea is to make these\ndeclarations so minimal and easy to read that even extensive\nconfiguration does not overly burden the programmers working with the\ncode.\n\nthe ``martian`` package is a spin-off from the `grok project`_, in the\ncontext of which this codebase was first developed. while grok uses\nit, the code is completely independent of grok.\n\n.. _`grok project`: http://grok.zope.org\n\nmotivation\n==========\n\n\"deducing declarative configuration actions from python code\" - that\nsounds very abstract. what does it actually mean? what is\nconfiguration?  what is declarative configuration? in order to explain\nthis, we'll first take a look at configuration.\n\nlarger frameworks often offer a lot of points where you can modify\ntheir behavior: ways to combine its own components with components you\nprovide yourself to build a larger application. a framework offers\npoints where it can be *configured* with plugin code. when you plug\nsome code into a plugin point, it results in the updating of some\nregistry somewhere with the new plugin. when the framework uses a\nplugin, it will first look it up in the registry. the action of\nregistering some component into a registry can be called\n*configuration*.\n\nlet's look at an example framework that offers a plugin point. we\nintroduce a very simple framework for plugging in different template\nlanguages, where each template language uses its own extension. you\ncan then supply the framework with the template body and the template\nextension and some data, and render the template.\n\nlet's look at the framework::\n\n  >>> import string\n  >>> class templating(fakemodule):\n  ...\n  ...   class interpolationtemplate(object):\n  ...      \"use %(foo)s for dictionary interpolation.\"\n  ...      def __init__(self, text):\n  ...          self.text = text\n  ...      def render(self, **kw):\n  ...          return self.text % kw\n  ...\n  ...   class templatestringtemplate(object):\n  ...      \"pep 292 string substitutions.\"\n  ...      def __init__(self, text):\n  ...          self.template = string.template(text)\n  ...      def render(self, **kw):\n  ...          return self.template.substitute(**kw)\n  ...\n  ...   # the registry, we plug in the two templating systems right away\n  ...   extension_handlers = { '.txt': interpolationtemplate,\n  ...                          '.tmpl': templatestringtemplate }\n  ...\n  ...   def render(data, extension, **kw):\n  ...      \"\"\"render the template at filepath with arguments.\n  ...\n  ...      data - the data in the file\n  ...      extension - the extension of the file\n  ...      keyword arguments - variables to interpolate\n  ...\n  ...      in a real framework you could pass in the file path instead of\n  ...      data and extension, but we don't want to open files in our\n  ...      example.\n  ...\n  ...      returns the rendered template\n  ...      \"\"\"\n  ...      template = extension_handlers[extension](data)\n  ...      return template.render(**kw)\n\nsince normally we cannot create modules in a doctest, we have emulated\nthe ``templating`` python module using the ``fakemodule``\nclass. whenever you see ``fakemodule`` subclasses, imagine you're\nlooking at a module definition in a ``.py`` file. now that we have\ndefined a module ``templating``, we also need to be able to import\nit. fake modules are always placed automatically into the\n``martiantest.fake`` namespace so you can import them from there::\n\n  >>> from martiantest.fake import templating\n\nnow let's try the ``render`` function for the registered template\ntypes, to demonstrate that our framework works::\n\n  >>> templating.render('hello %(name)s!', '.txt', name=\"world\")\n  'hello world!'\n  >>> templating.render('hello ${name}!', '.tmpl', name=\"universe\")\n  'hello universe!'\n\nfile extensions that we do not recognize cause a ``keyerror`` to be\nraised::\n\n  >>> templating.render('hello', '.silly', name=\"test\")\n  traceback (most recent call last):\n  ...\n  keyerror: '.silly'\n\nwe now want to plug into this filehandler framework and provide a\nhandler for ``.silly`` files. since we are writing a plugin, we cannot\nchange the ``templating`` module directly. let's write an extension\nmodule instead::\n\n  >>> class sillytemplating(fakemodule):\n  ...   class sillytemplate(object):\n  ...      \"replace {key} with dictionary values.\"\n  ...      def __init__(self, text):\n  ...          self.text = text\n  ...      def render(self, **kw):\n  ...          text = self.text\n  ...          for key, value in kw.items():\n  ...              text = text.replace('{%s}' % key, value)\n  ...          return text\n  ...\n  ...   templating.extension_handlers['.silly'] = sillytemplate\n  >>> from martiantest.fake import sillytemplating\n\nin the extension module, we manipulate the ``extension_handlers``\ndictionary of the ``templating`` module (in normal code we'd need to\nimport it first), and plug in our own function. ``.silly`` handling\nworks now::\n\n  >>> templating.render('hello {name}!', '.silly', name=\"galaxy\")\n  'hello galaxy!'\n\nabove we plug into our ``extension_handler`` registry using python\ncode. using separate code to manually hook components into registries\ncan get rather cumbersome - each time you write a plugin, you also\nneed to remember you need to register it.\n\ndoing template registration in python code also poses a maintenance\nrisk. it is tempting to start doing fancy things in python code such\nas conditional configuration, making the configuration state of a\nprogram hard to understand. another problem is that doing\nconfiguration at import time can also lead to unwanted side effects\nduring import, as well as ordering problems, where you want to import\nsomething that really needs configuration state in another module that\nis imported later. finally, it can also make code harder to test, as\nconfiguration is loaded always when you import the module, even if in\nyour test perhaps you don't want it to be.\n\nmartian provides a framework that allows configuration to be expressed\nin declarative python code. martian is based on the realization that\nwhat to configure where can often be deduced from the structure of\npython code itself, especially when it can be annotated with\nadditional declarations. the idea is to make it so easy to write and\nregister a plugin so that even extensive configuration does not overly\nburden the developer.\n\nconfiguration actions are executed during a separate phase (\"grok\ntime\"), not at import time, which makes it easier to reason about and\neasier to test.\n\nconfiguration the martian way\n=============================\n\nlet's now transform the above ``templating`` module and the\n``sillytemplating`` module to use martian. first we must recognize\nthat every template language is configured to work for a particular\nextension. with martian, we annotate the classes themselves with this\nconfiguration information. annotations happen using *directives*,\nwhich look like function calls in the class body.\n\nlet's create an ``extension`` directive that can take a single string\nas an argument, the file extension to register the template class\nfor::\n\n  >>> import martian\n  >>> class extension(martian.directive):\n  ...   scope = martian.class\n  ...   store = martian.once\n  ...   default = none\n\nwe also need a way to easily recognize all template classes. the normal\npattern for this in martian is to use a base class, so let's define a\n``template`` base class::\n\n  >>> class template(object):\n  ...   pass\n\nwe now have enough infrastructure to allow us to change the code to use\nmartian style base class and annotations::\n\n  >>> class templating(fakemodule):\n  ...\n  ...   class interpolationtemplate(template):\n  ...      \"use %(foo)s for dictionary interpolation.\"\n  ...      extension('.txt')\n  ...      def __init__(self, text):\n  ...          self.text = text\n  ...      def render(self, **kw):\n  ...          return self.text % kw\n  ...\n  ...   class templatestringtemplate(template):\n  ...      \"pep 292 string substitutions.\"\n  ...      extension('.tmpl')\n  ...      def __init__(self, text):\n  ...          self.template = string.template(text)\n  ...      def render(self, **kw):\n  ...          return self.template.substitute(**kw)\n  ...\n  ...   # the registry, empty to start with\n  ...   extension_handlers = {}\n  ...\n  ...   def render(data, extension, **kw):\n  ...      # this hasn't changed\n  ...      template = extension_handlers[extension](data)\n  ...      return template.render(**kw)\n  >>> from martiantest.fake import templating\n\nas you can see, there have been very few changes:\n\n* we made the template classes inherit from ``template``.\n\n* we use the ``extension`` directive in the template classes.\n\n* we stopped pre-filling the ``extension_handlers`` dictionary.\n\nso how do we fill the ``extension_handlers`` dictionary with the right\ntemplate languages? now we can use martian. we define a *grokker* for\n``template`` that registers the template classes in the\n``extension_handlers`` registry::\n\n  >>> class meta(fakemodule):\n  ...   class templategrokker(martian.classgrokker):\n  ...     martian.component(template)\n  ...     martian.directive(extension)\n  ...     def execute(self, class_, extension, **kw):\n  ...       templating.extension_handlers[extension] = class_\n  ...       return true\n  >>> from martiantest.fake import meta\n\nwhat does this do? a ``classgrokker`` has its ``execute`` method\ncalled for subclasses of what's indicated by the ``martian.component``\ndirective. you can also declare what directives a ``classgrokker``\nexpects on this component by using ``martian.directive()`` (the\n``directive`` directive!) one or more times.\n\nthe ``execute`` method takes the class to be grokked as the first\nargument, and the values of the directives used will be passed in as\nadditional parameters into the ``execute`` method. the framework can\nalso pass along an arbitrary number of extra keyword arguments during\nthe grokking process, so we need to declare ``**kw`` to make sure we\ncan handle these.\n\nall our grokkers will be collected in a special martian-specific\nregistry::\n\n  >>> reg = martian.grokkerregistry()\n\nwe will need to make sure the system is aware of the\n``templategrokker`` defined in the ``meta`` module first, so let's\nregister it first. we can do this by simply grokking the ``meta``\nmodule::\n\n  >>> reg.grok('meta', meta)\n  true\n\nbecause ``templategrokker`` is now registered, our registry now knows\nhow to grok ``template`` subclasses. let's grok the ``templating``\nmodule::\n\n  >>> reg.grok('templating', templating)\n  true\n\nlet's try the ``render`` function of templating again, to demonstrate\nwe have successfully grokked the template classes::\n\n  >>> templating.render('hello %(name)s!', '.txt', name=\"world\")\n  'hello world!'\n  >>> templating.render('hello ${name}!', '.tmpl', name=\"universe\")\n  'hello universe!'\n\n``.silly`` hasn't been registered yet::\n\n  >>> templating.render('hello', '.silly', name=\"test\")\n  traceback (most recent call last):\n  ...\n  keyerror: '.silly'\n\nlet's now register ``.silly`` from an extension module::\n\n  >>> class sillytemplating(fakemodule):\n  ...   class sillytemplate(template):\n  ...      \"replace {key} with dictionary values.\"\n  ...      extension('.silly')\n  ...      def __init__(self, text):\n  ...          self.text = text\n  ...      def render(self, **kw):\n  ...          text = self.text\n  ...          for key, value in kw.items():\n  ...              text = text.replace('{%s}' % key, value)\n  ...          return text\n  >>> from martiantest.fake import sillytemplating\n\nas you can see, the developer that uses the framework has no need\nanymore to know about ``templating.extension_handlers``. instead we can\nsimply grok the module to have ``sillytemplate`` be register appropriately::\n\n  >>> reg.grok('sillytemplating', sillytemplating)\n  true\n\nwe can now use the ``.silly`` templating engine too::\n\n  >>> templating.render('hello {name}!', '.silly', name=\"galaxy\")\n  'hello galaxy!'\n\nadmittedly it is hard to demonstrate martian well with a small example\nlike this. in the end we have actually written more code than in the\nbasic framework, after all. but even in this small example, the\n``templating`` and ``sillytemplating`` module have become more\ndeclarative in nature. the developer that uses the framework will not\nneed to know anymore about things like\n``templating.extension_handlers`` or an api to register things\nthere. instead the developer can registering a new template system\nanywhere, as long as he subclasses from ``template``, and as long as\nhis code is grokked by the system.\n\nfinally note how martian was used to define the ``templategrokker`` as\nwell. in this way martian can use itself to extend itself.\n\ngrokking instances\n==================\n\nabove we've seen how you can grok classes. martian also supplies a way\nto grok instances. this is less common in typical frameworks, and has\nthe drawback that no class-level directives can be used, but can still\nbe useful.\n\nlet's imagine a case where we have a zoo framework with an ``animal``\nclass, and we want to track instances of it::\n\n  >>> class animal(object):\n  ...   def __init__(self, name):\n  ...     self.name = name\n  >>> class zoo(fakemodule):\n  ...   horse = animal('horse')\n  ...   chicken = animal('chicken')\n  ...   elephant = animal('elephant')\n  ...   lion = animal('lion')\n  ...   animals = {}\n  >>> from martiantest.fake import zoo\n\nwe define an ``instancegrokker`` subclass to grok ``animal`` instances::\n\n  >>> class meta(fakemodule):\n  ...   class animalgrokker(martian.instancegrokker):\n  ...     martian.component(animal)\n  ...     def execute(self, instance, **kw):\n  ...       zoo.animals[instance.name] = instance\n  ...       return true\n  >>> from martiantest.fake import meta\n\nlet's create a new registry with the ``animalgrokker`` in it::\n\n  >>> reg = martian.grokkerregistry()\n  >>> reg.grok('meta', meta)\n  true\n\nwe can now grok the ``zoo`` module::\n\n  >>> reg.grok('zoo', zoo)\n  true\n\nthe animals will now be in the ``animals`` dictionary::\n\n  >>> sorted(zoo.animals.items())\n  [('chicken', <animal object at ...>),\n   ('elephant', <animal object at ...>),\n   ('horse', <animal object at ...>),\n   ('lion', <animal object at ...>)]\n\nmore information\n================\n\nfor many more details and examples of more kinds of grokkers, please\nsee ``src/martian/core.txt``. for more information on directives see\n``src/martian/directive.txt``.\n\nchanges\n*******\n\n2.0.post1 (2023-03-23)\n======================\n\n- add missing ``python_requires`` in ``setup.py`` to prevent installing on too\n  old versions.\n\n\n2.0 (2023-03-23)\n================\n\n- add support for python 3.11.\n\n- drop support for python 2.7, 3.5, 3.6.\n\n- fix test suite incompatibility with ``zope.interface >= 6.0``.\n\n\n1.5 (2022-02-11)\n================\n\n- title directive now correctly handles non-ascii characters.\n\n- fix test suite incompatibility with zope.interface >= 5.0.\n\n- drop support for python 3.4.\n\n- add support for python 3.9 and 3.10.\n\n\n1.4 (2020-02-23)\n================\n\n- check for ``builtins`` (python 3) everywhere that we check for\n  ``__builtin__`` (python 2).\n\n\n1.3.post1 (2019-03-14)\n======================\n\n- fix rendering of pypi page.\n\n\n1.3 (2019-03-14)\n================\n\n- add support for python 3.7 and 3.8.\n\n\n1.2 (2018-05-09)\n================\n\n- add a new directive ``martian.ignore()`` to explicitly not grok\n  something in a module::\n\n    class example:\n        pass\n\n    martian.ignore('example')\n\n- fix the code to be pep 8 compliant.\n\n1.1 (2018-01-25)\n================\n\n- bypass bootstrap, add coverage to tox\n\n- fix ``inspect.getargspec()`` deprecation in python3\n\n\n1.0 (2017-10-19)\n================\n\n- add support for python 3.5, 3.6, pypy2 and pypy3.\n\n- drop support for python 2.6 and 3.3.\n\n\n0.15 (2015-04-21)\n=================\n\n- compatibility for python 3\n- adjust egg to work with newer version of setuptools\n- fix an encoding issue under python-2.7 in the doctests.\n\n\n0.14 (2010-11-03)\n=================\n\nfeature changes\n---------------\n\n* the computation of the default value for a directive can now be defined inside\n  the directive class definition. whenever there is a ``get_default``\n  classmethod, it is used for computing the default::\n\n      class name(directive):\n          scope = class\n          store = once\n\n          @classmethod\n          def get_default(cls, component, module=none, **data):\n             return component.__name__.lower()\n\n  when binding the directive, the default-default behaviour can still be\n  overriden by passing a ``get_default`` function::\n\n      def another_default(component, module=none, **data):\n         return component.__name__.lower()\n\n      name.bind(get_default=another_default).get(some_component)\n\n  making the default behaviour intrinsic to the directive, prevents having to\n  pass the ``get_default`` function over and over when getting values, for\n  example in the grokkers.\n\n0.13 (2010-11-01)\n=================\n\nfeature changes\n---------------\n\n* ignore all __main__ modules.\n\n* list zope.testing as a test dependency.\n\n0.12 (2009-06-29)\n=================\n\nfeature changes\n---------------\n\n* changes to better support various inheritance scenarios in combination with\n  directives. details follow.\n\n* ``class_or_module`` scope directives will be aware of inheritance of\n  values that are defined in module-scope. consider the following case::\n\n    module a:\n      some_directive('a')\n      class foo(object):\n        pass\n\n    module b:\n      import a\n      class bar(a.foo):\n        pass\n\n  as before, ``foo`` will have the value ``a`` configured for it. ``bar``,\n  since it inherits from ``foo``, will inherit this value.\n\n* ``class_or_module`` and ``class`` scope directives will be aware of\n  inheritance of computed default values. consider the following case::\n\n    module a:\n      class foo(object):\n         pass\n\n    module b:\n      import a\n      class bar(a.foo):\n         pass\n\n    def get_default(component, module, **data):\n        if module.__name__ == 'a':\n           return \"we have a default value for module a\"\n        return martian.unknown\n\n  when we now do this::\n\n    some_directive.bind(get_default=get_default).get(b.bar)\n\n  we will get the value \"we have a default value for module a\". this\n  is because when trying to compute the default value for ``bar`` we\n  returned ``martian.unknown`` to indicate the value couldn't be found\n  yet. the system then looks at the base class and tries again, and in\n  this case it succeeds (as the module-name is ``a``).\n\n* ``martian.once_iface`` storage option to allow the creation of\n  directives that store their value on ``zope.interface``\n  interfaces. this was originally in ``grokcore.view`` but was of\n  wider usefulness.\n\nbugs fixed\n----------\n\n* ignore things that look like python modules and packages but aren't.\n  these are sometimes created by editors, operating systems and\n  network file systems and we don't want to confuse them.\n\n* ignore .pyc and .pyo files that don't have a matching .py file via\n  ``module_info_from_dotted_name`` if its ``ignore_nonsource``\n  parameter is ``true``.  the default is ``true``.  to revert to the\n  older behavior where .pyc files were honored, pass\n  ``ignore_nonsource=false``.\n\n* pass along ``exclude_filter`` (and the new ``ignore_nonsource``\n  flag) to moduleinfo constructor when it calls itself recursively.\n\n* replace ``fake_import`` to import fake modules in tests with a real\n  python import statement (``from martiantest.fake import\n  my_fake_module``). this works by introducing a metaclass for\n  ``fakemodule`` that automatically registers it as a module. the\n  irony does not escape us. this also means that\n  ``martian.scan.resolve()`` will now work on fake modules.\n\n0.11 (2008-09-24)\n=================\n\nfeature changes\n---------------\n\n* added multiple_nobase option for directive store. this is like multiple\n  but doesn't inherit information from the base class.\n\n0.10 (2008-06-06)\n=================\n\nfeature changes\n---------------\n\n* add a ``validateclass`` validate function for directives.\n\n* moved ``fakemodule`` and ``fake_import`` into a ``martian.testing``\n  module so that they can be reused by external packages.\n\n* introduce new tutorial text as readme.txt. the text previously in\n  ``readme.txt`` was rather too detailed for a tutorial, so has been\n  moved into ``core.txt``.\n\n* introduce a ``grokkerregistry`` class that is a ``modulegrokker``\n  with a ``metamultigrokker`` in it. this is the convenient thing to\n  instantiate to start working with grok and is demonstrated in the\n  tutorial.\n\n* introduced three new martian-specific directives:\n  ``martian.component``, ``martian.directive`` and\n  ``martian.priority``. these replace the ``component_class``,\n  ``directives`` and ``priority`` class-level attributes. this way\n  grokkers look the same as what they grok. this breaks backwards\n  compatibility again, but it's an easy replace operation. note that\n  ``martian.directive`` takes the directive itself as an argument, and\n  then optionally the same arguments as the ``bind`` method of\n  directives (``name``, ``default`` and ``get_default``). it may be\n  used multiple times. note that ``martian.baseclass`` was already a\n  martian-specific directive and this has been unchanged.\n\n* for symmetry, add an ``execute`` method to ``instancegrokker``.\n\n0.9.7 (2008-05-29)\n==================\n\nfeature changes\n---------------\n\n* added a ``methodgrokker`` base class for grokkers that want to grok\n  methods of a class rather than the whole class itself.  it works\n  quite similar to the ``classgrokker`` regarding directive\n  definition, except that directives evaluated not only on class (and\n  possibly module) level but also for each method.  that way,\n  directives can also be applied to methods (as decorators) in case\n  they support it.\n\n0.9.6 (2008-05-14)\n==================\n\nfeature changes\n---------------\n\n* refactored the ``martian.directive`` base class yet again to allow\n  more declarative (rather than imperative) usage in grokkers.\n  directives themselves no longer have a ``get()`` method nor a\n  default value factory (``get_default()``).  instead you will have to\n  \"bind\" the directive first which is typically done in a grokker.\n\n* extended the ``classgrokker`` baseclass with a standard ``grok()``\n  method that allows you to simply declare a set of directives that\n  are used on the grokked classes.  then you just have to implement an\n  ``execute()`` method that will receive the data from those\n  directives as keyword arguments.  this simplifies the implementation\n  of class grokkers a lot.\n\n0.9.5 (2008-05-04)\n==================\n\n* ``scan_for_classes`` just needs a single second argument specifying\n  an interface. the support for scanning for subclasses directly has\n  been removed as it became unnecessary (due to changes in\n  grokcore.component).\n\n0.9.4 (2008-05-04)\n==================\n\nfeatures changes\n----------------\n\n* replaced the various directive base classes with a single\n  ``martian.directive`` base class:\n\n  - the directive scope is now defined with the ``scope`` class\n    attribute using one of ``martian.class``, ``martian.module``,\n    ``martian.class_or_module``.\n\n  - the type of storage is defined with the ``store`` class attribute\n    using one of ``martian.once``, ``martian.multiple``,\n    ``martian.dict``.\n\n  - directives have now gained the ability to read the value that they\n    have set on a component or module using a ``get()`` method.  the\n    ``class_annotation`` and ``class_annotation_list`` helpers have\n    been removed as a consequence.\n\n* moved the ``baseclass()`` directive from grok to martian.\n\n* added a ``martian.util.check_provides_one`` helper, in analogy to\n  ``check_implements_one``.\n\n* the ``scan_for_classes`` helper now also accepts an ``interface``\n  argument which allows you to scan for classes based on interface\n  rather than base classes.\n\nbug fixes\n---------\n\n* added dummy ``package_dotted_name`` to ``builtinmoduleinfo``. this\n  allows the grokking of views in test code using grok's\n  ``grok.testing.grok_component`` without a failure when it sets up the\n  ``static`` attribute.\n\n* no longer use the convention that classes ending in -base will be considered\n  base classes. you must now explicitly use the grok.baseclass() directive.\n\n* the type check of classes uses isinstance() instead of type(). this means\n  grok can work with zope 2 extensionclasses and metaclass programming.\n\n0.9.3 (2008-01-26)\n==================\n\nfeature changes\n---------------\n\n* added an optionalvaluedirective which allows the construction of\n  directives that take either zero or one argument. if no arguments\n  are given, the ``default_value`` method on the directive is\n  called. subclasses need to override this to return the default value\n  to use.\n\nrestructuring\n-------------\n\n* move some util functions that were really grok-specific out of martian\n  back into grok.\n\n0.9.2 (2007-11-20)\n==================\n\nbug fixes\n---------\n\n* scan.module_info_from_dotted_name() now has special behavior when it\n  runs into __builtin__. previously, it would crash with an error. now\n  it will return an instance of builtinmoduleinfo. this is a very\n  simple implementation which provides just enough information to make\n  client code work. typically this client code is test-related so that\n  the module context will be __builtin__.\n\n0.9.1 (2007-10-30)\n==================\n\nfeature changes\n---------------\n\n* grokkers now receive a ``module_info`` keyword argument.  this\n  change is completely backwards-compatible since grokkers which don't\n  take ``module_info`` explicitly will absorb the extra argument in\n  ``**kw``.\n\n0.9 (2007-10-02)\n=================\n\nfeature changes\n---------------\n\n* reverted the behaviour where modules called tests or ftests were skipped\n  by default and added an api to provides a filtering function for skipping\n  modules to be grokked.\n\n0.8.1 (2007-08-13)\n==================\n\nfeature changes\n---------------\n\n* don't grok tests or ftests modules.\n\nbugs fixed\n----------\n\n* fix a bug where if a class had multiple base classes, this could end up\n  in the resultant list multiple times.\n\n0.8 (2007-07-02)\n================\n\nfeature changes\n---------------\n\n* initial public release.\n",
  "docs_url": null,
  "keywords": "",
  "license": "zpl",
  "name": "martian",
  "package_url": "https://pypi.org/project/martian/",
  "project_url": "https://pypi.org/project/martian/",
  "project_urls": {
    "Homepage": "https://github.com/zopefoundation/martian"
  },
  "release_url": "https://pypi.org/project/martian/2.0.post1/",
  "requires_dist": [
    "zope.interface",
    "setuptools",
    "zope.testing ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "embedding of configuration information in python code.",
  "version": "2.0.post1",
  "releases": [],
  "developers": [
    "grok-dev@zope.org",
    "grok_project"
  ],
  "kwds": "grok_component grok grokcore grokker grokkerregistry",
  "license_kwds": "zpl",
  "libtype": "pypi",
  "id": "pypi_martian",
  "homepage": "https://github.com/zopefoundation/martian",
  "release_count": 28,
  "dependency_ids": [
    "pypi_setuptools",
    "pypi_zope.interface",
    "pypi_zope.testing"
  ]
}