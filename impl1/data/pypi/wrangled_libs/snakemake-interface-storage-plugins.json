{
  "classifiers": [
    "programming language :: python :: 3",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12"
  ],
  "description": "# snakemake-interface-storage-plugins\n\nthis package provides a stable interface for interactions between snakemake and its storage plugins.\n\nplugins should implement the following skeleton to comply with this interface.\nit is recommended to use snakemake's poetry plugin to set up this skeleton (and automated testing) within a python package, see https://github.com/snakemake/poetry-snakemake-plugin.\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import any, iterable, optional, list\nfrom snakemake_interface_storage_plugins.settings import storageprovidersettingsbase\nfrom snakemake_interface_storage_plugins.storage_provider import (\n    storageproviderbase,\n    storagequeryvalidationresult,\n    examplequery,\n    operation,\n)\nfrom snakemake_interface_storage_plugins.storage_object import (\n    storageobjectread,\n    storageobjectwrite,\n    storageobjectglob,\n    retry_decorator,\n)\nfrom snakemake_interface_storage_plugins.io import iocachestorageinterface\n\n\n# optional:\n# define settings for your storage plugin (e.g. host url, credentials).\n# they will occur in the snakemake cli as --storage-<storage-plugin-name>-<param-name>\n# make sure that all defined fields are 'optional' and specify a default value\n# of none or anything else that makes sense in your case.\n# note that we allow storage plugin settings to be tagged by the user. that means,\n# that each of them can be specified multiple times (an implicit nargs=+), and\n# the user can add a tag in front of each value (e.g. tagname1:value1 tagname2:value2).\n# this way, a storage plugin can be used multiple times within a workflow with different\n# settings.\n@dataclass\nclass storageprovidersettings(storageprovidersettingsbase):\n    myparam: optional[int] = field(\n        default=none,\n        metadata={\n            \"help\": \"some help text\",\n            # optionally request that setting is also available for specification\n            # via an environment variable. the variable will be named automatically as\n            # snakemake_<storage-plugin-name>_<param-name>, all upper case.\n            # this mechanism should only be used for passwords, usernames, and other\n            # credentials.\n            # for other items, we rather recommend to let people use a profile\n            # for setting defaults\n            # (https://snakemake.readthedocs.io/en/stable/executing/cli.html#profiles).\n            \"env_var\": false,\n            # optionally specify a function that parses the value given by the user.\n            # this is useful to create complex types from the user input.\n            \"parse_func\": ...,\n            # if a parse_func is specified, you also have to specify an unparse_func\n            # that converts the parsed value back to a string.\n            \"unparse_func\": ...,\n            # optionally specify that setting is required when the executor is in use.\n            \"required\": true,\n        },\n    )\n\n\n# required:\n# implementation of your storage provider\n# this class can be empty as the one below.\n# you can however use it to store global information or maintain e.g. a connection\n# pool.\nclass storageprovider(storageproviderbase):\n    # for compatibility with future changes, you should not overwrite the __init__\n    # method. instead, use __post_init__ to set additional attributes and initialize\n    # futher stuff.\n\n    def __post_init__(self):\n        # this is optional and can be removed if not needed.\n        # alternatively, you can e.g. prepare a connection to your storage backend here.\n        # and set additional attributes.\n        pass\n\n    @classmethod\n    def example_queries(cls) -> list[examplequery]:\n        \"\"\"return valid example queries (at least one) with description.\"\"\"\n        ...\n\n    def rate_limiter_key(self, query: str, operation: operation) -> any:\n        \"\"\"return a key for identifying a rate limiter given a query and an operation.\n\n        this is used to identify a rate limiter for the query.\n        e.g. for a storage provider like http that would be the host name.\n        for s3 it might be just the endpoint url.\n        \"\"\"\n        ...\n\n    def default_max_requests_per_second(self) -> float:\n        \"\"\"return the default maximum number of requests per second for this storage\n        provider.\"\"\"\n        ...\n\n    def use_rate_limiter(self) -> bool:\n        \"\"\"return false if no rate limiting is needed for this provider.\"\"\"\n        ...\n\n    @classmethod\n    def is_valid_query(cls, query: str) -> storagequeryvalidationresult:\n        \"\"\"return whether the given query is valid for this storage provider.\"\"\"\n        # ensure that also queries containing wildcards (e.g. {sample}) are accepted\n        # and considered valid. the wildcards will be resolved before the storage\n        # object is actually used.\n        ...\n\n\n# required:\n# implementation of storage object. if certain methods cannot be supported by your\n# storage (e.g. because it is read-only see\n# snakemake-storage-http for comparison), remove the corresponding base classes\n# from the list of inherited items.\nclass storageobject(storageobjectread, storageobjectwrite, storageobjectglob):\n    # for compatibility with future changes, you should not overwrite the __init__\n    # method. instead, use __post_init__ to set additional attributes and initialize\n    # futher stuff.\n\n    def __post_init__(self):\n        # this is optional and can be removed if not needed.\n        # alternatively, you can e.g. prepare a connection to your storage backend here.\n        # and set additional attributes.\n        pass\n\n    async def inventory(self, cache: iocachestorageinterface):\n        \"\"\"from this file, try to find as much existence and modification date\n        information as possible. only retrieve that information that comes for free\n        given the current object.\n        \"\"\"\n        # this is optional and can be left as is\n\n        # if this is implemented in a storage object, results have to be stored in\n        # the given iocache object, using self.cache_key() as key.\n        # optionally, this can take a custom local suffix, needed e.g. when you want \n        # to cache more items than the current query: self.cache_key(local_suffix=...)\n        pass\n\n    def get_inventory_parent(self) -> optional[str]:\n        \"\"\"return the parent directory of this object.\"\"\"\n        # this is optional and can be left as is\n        return none\n\n    def local_suffix(self) -> str:\n        \"\"\"return a unique suffix for the local path, determined from self.query.\"\"\"\n        ...\n\n    def cleanup(self):\n        \"\"\"perform local cleanup of any remainders of the storage object.\"\"\"\n        # self.local_path() should not be removed, as this is taken care of by\n        # snakemake.\n        ...\n\n    # fallible methods should implement some retry logic.\n    # the easiest way to do this (but not the only one) is to use the retry_decorator\n    # provided by snakemake-interface-storage-plugins.\n    @retry_decorator\n    def exists(self) -> bool:\n        # return true if the object exists\n        ...\n\n    @retry_decorator\n    def mtime(self) -> float:\n        # return the modification time\n        ...\n\n    @retry_decorator\n    def size(self) -> int:\n        # return the size in bytes\n        ...\n\n    @retry_decorator\n    def retrieve_object(self):\n        # ensure that the object is accessible locally under self.local_path()\n        ...\n\n    # the following to methods are only required if the class inherits from\n    # storageobjectreadwrite.\n\n    @retry_decorator\n    def store_object(self):\n        # ensure that the object is stored at the location specified by\n        # self.local_path().\n        ...\n\n    @retry_decorator\n    def remove(self):\n        # remove the object from the storage.\n        ...\n\n    # the following to methods are only required if the class inherits from\n    # storageobjectglob.\n\n    @retry_decorator\n    def list_candidate_matches(self) -> iterable[str]:\n        \"\"\"return a list of candidate matches in the storage for the query.\"\"\"\n        # this is used by glob_wildcards() to find matches for wildcards in the query.\n        # the method has to return concretized queries without any remaining wildcards.\n        # use snakemake_executor_plugins.io.get_constant_prefix(self.query) to get the\n        # prefix of the query before the first wildcard.\n        ...\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "snakemake-interface-storage-plugins",
  "package_url": "https://pypi.org/project/snakemake-interface-storage-plugins/",
  "project_url": "https://pypi.org/project/snakemake-interface-storage-plugins/",
  "project_urls": {
    "Homepage": "https://github.com/snakemake/snakemake-interface-storage-plugins"
  },
  "release_url": "https://pypi.org/project/snakemake-interface-storage-plugins/3.0.0/",
  "requires_dist": [
    "snakemake-interface-common (>=1.12.0,<2.0.0)",
    "wrapt (>=1.15.0,<2.0.0)",
    "reretry (>=0.11.8,<0.12.0)",
    "throttler (>=1.2.2,<2.0.0)"
  ],
  "requires_python": ">=3.11,<4.0",
  "summary": "this package provides a stable interface for interactions between snakemake and its storage plugins.",
  "version": "3.0.0",
  "releases": [],
  "developers": [
    "johannes.koester@uni-due.de",
    "johannes_koester"
  ],
  "kwds": "snakemake_interface_storage_plugins snakemake_executor_plugins storageobject storage_object storage_provider",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_snakemake_interface_storage_plugins",
  "homepage": "https://github.com/snakemake/snakemake-interface-storage-plugins",
  "release_count": 15,
  "dependency_ids": [
    "pypi_reretry",
    "pypi_snakemake_interface_common",
    "pypi_throttler",
    "pypi_wrapt"
  ]
}