{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon relational database service construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\n```python\nimport aws_cdk.aws_rds as rds\n```\n\n## starting a clustered database\n\nto set up a clustered database (like aurora), define a `databasecluster`. you must\nalways launch a database in a vpc. use the `vpcsubnets` attribute to control whether\nyour instances will be launched privately or publicly:\n\n```python\n# vpc: ec2.vpc\n\ncluster = rds.databasecluster(self, \"database\",\n    engine=rds.databaseclusterengine.aurora_mysql(version=rds.auroramysqlengineversion.ver_2_08_1),\n    credentials=rds.credentials.from_generated_secret(\"clusteradmin\"),  # optional - will default to 'admin' username and generated password\n    instance_props=rds.instanceprops(\n        # optional , defaults to t3.medium\n        instance_type=ec2.instancetype.of(ec2.instanceclass.burstable2, ec2.instancesize.small),\n        vpc_subnets=ec2.subnetselection(\n            subnet_type=ec2.subnettype.private_with_nat\n        ),\n        vpc=vpc\n    )\n)\n```\n\nif there isn't a constant for the exact version you want to use,\nall of the `version` classes have a static `of` method that can be used to create an arbitrary version.\n\n```python\ncustom_engine_version = rds.auroramysqlengineversion.of(\"5.7.mysql_aurora.2.08.1\")\n```\n\nby default, the master password will be generated and stored in aws secrets manager with auto-generated description.\n\nyour cluster will be empty by default. to add a default database upon construction, specify the\n`defaultdatabasename` attribute.\n\nuse `databaseclusterfromsnapshot` to create a cluster from a snapshot:\n\n```python\n# vpc: ec2.vpc\n\nrds.databaseclusterfromsnapshot(self, \"database\",\n    engine=rds.databaseclusterengine.aurora(version=rds.auroraengineversion.ver_1_22_2),\n    instance_props=rds.instanceprops(\n        vpc=vpc\n    ),\n    snapshot_identifier=\"mysnapshot\"\n)\n```\n\n## starting an instance database\n\nto set up a instance database, define a `databaseinstance`. you must\nalways launch a database in a vpc. use the `vpcsubnets` attribute to control whether\nyour instances will be launched privately or publicly:\n\n```python\n# vpc: ec2.vpc\n\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    # optional, defaults to m5.large\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable3, ec2.instancesize.small),\n    credentials=rds.credentials.from_generated_secret(\"syscdk\"),  # optional - will default to 'admin' username and generated password\n    vpc=vpc,\n    vpc_subnets=ec2.subnetselection(\n        subnet_type=ec2.subnettype.private_with_nat\n    )\n)\n```\n\nif there isn't a constant for the exact engine version you want to use,\nall of the `version` classes have a static `of` method that can be used to create an arbitrary version.\n\n```python\ncustom_engine_version = rds.oracleengineversion.of(\"19.0.0.0.ru-2020-04.rur-2020-04.r1\", \"19\")\n```\n\nby default, the master password will be generated and stored in aws secrets manager.\n\nto use the storage auto scaling option of rds you can specify the maximum allocated storage.\nthis is the upper limit to which rds can automatically scale the storage. more info can be found\n[here](https://docs.aws.amazon.com/amazonrds/latest/userguide/user_piops.storagetypes.html#user_piops.autoscaling)\nexample for max storage configuration:\n\n```python\n# vpc: ec2.vpc\n\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.postgres(version=rds.postgresengineversion.ver_12_3),\n    # optional, defaults to m5.large\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable2, ec2.instancesize.small),\n    vpc=vpc,\n    max_allocated_storage=200\n)\n```\n\nuse `databaseinstancefromsnapshot` and `databaseinstancereadreplica` to create an instance from snapshot or\na source database respectively:\n\n```python\n# vpc: ec2.vpc\n\n# source_instance: rds.databaseinstance\n\nrds.databaseinstancefromsnapshot(self, \"instance\",\n    snapshot_identifier=\"my-snapshot\",\n    engine=rds.databaseinstanceengine.postgres(version=rds.postgresengineversion.ver_12_3),\n    # optional, defaults to m5.large\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable2, ec2.instancesize.large),\n    vpc=vpc\n)\nrds.databaseinstancereadreplica(self, \"readreplica\",\n    source_database_instance=source_instance,\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable2, ec2.instancesize.large),\n    vpc=vpc\n)\n```\n\nautomatic backups of read replica instances are only supported for mysql and mariadb. by default,\nautomatic backups are disabled for read replicas and can only be enabled (using `backupretention`)\nif also enabled on the source instance.\n\ncreating a \"production\" oracle database instance with option and parameter groups:\n\n```python\n# set open cursors with parameter group\nparameter_group = rds.parametergroup(self, \"parametergroup\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    parameters={\n        \"open_cursors\": \"2500\"\n    }\n)\n\noption_group = rds.optiongroup(self, \"optiongroup\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    configurations=[rds.optionconfiguration(\n        name=\"locator\"\n    ), rds.optionconfiguration(\n        name=\"oem\",\n        port=1158,\n        vpc=vpc\n    )\n    ]\n)\n\n# allow connections to oem\noption_group.option_connections.oem.connections.allow_default_port_from_any_ipv4()\n\n# database instance with production values\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    license_model=rds.licensemodel.bring_your_own_license,\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable3, ec2.instancesize.medium),\n    multi_az=true,\n    storage_type=rds.storagetype.io1,\n    credentials=rds.credentials.from_username(\"syscdk\"),\n    vpc=vpc,\n    database_name=\"orcl\",\n    storage_encrypted=true,\n    backup_retention=cdk.duration.days(7),\n    monitoring_interval=cdk.duration.seconds(60),\n    enable_performance_insights=true,\n    cloudwatch_logs_exports=[\"trace\", \"audit\", \"alert\", \"listener\"\n    ],\n    cloudwatch_logs_retention=logs.retentiondays.one_month,\n    auto_minor_version_upgrade=true,  # required to be true if locator is used in the option group\n    option_group=option_group,\n    parameter_group=parameter_group,\n    removal_policy=removalpolicy.destroy\n)\n\n# allow connections on default port from any ipv4\ninstance.connections.allow_default_port_from_any_ipv4()\n\n# rotate the master user password every 30 days\ninstance.add_rotation_single_user()\n\n# add alarm for high cpu\ncloudwatch.alarm(self, \"highcpu\",\n    metric=instance.metric_cpuutilization(),\n    threshold=90,\n    evaluation_periods=1\n)\n\n# trigger lambda function on instance availability events\nfn = lambda_.function(self, \"function\",\n    code=lambda_.code.from_inline(\"exports.handler = (event) => console.log(event);\"),\n    handler=\"index.handler\",\n    runtime=lambda_.runtime.nodejs_14_x\n)\n\navailability_rule = instance.on_event(\"availability\", target=targets.lambdafunction(fn))\navailability_rule.add_event_pattern(\n    detail={\n        \"eventcategories\": [\"availability\"\n        ]\n    }\n)\n```\n\nadd xmldb and oem with option group\n\n```python\n# set open cursors with parameter group\nparameter_group = rds.parametergroup(self, \"parametergroup\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    parameters={\n        \"open_cursors\": \"2500\"\n    }\n)\n\noption_group = rds.optiongroup(self, \"optiongroup\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    configurations=[rds.optionconfiguration(\n        name=\"locator\"\n    ), rds.optionconfiguration(\n        name=\"oem\",\n        port=1158,\n        vpc=vpc\n    )\n    ]\n)\n\n# allow connections to oem\noption_group.option_connections.oem.connections.allow_default_port_from_any_ipv4()\n\n# database instance with production values\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.oracle_se2(version=rds.oracleengineversion.ver_19_0_0_0_2020_04_r1),\n    license_model=rds.licensemodel.bring_your_own_license,\n    instance_type=ec2.instancetype.of(ec2.instanceclass.burstable3, ec2.instancesize.medium),\n    multi_az=true,\n    storage_type=rds.storagetype.io1,\n    credentials=rds.credentials.from_username(\"syscdk\"),\n    vpc=vpc,\n    database_name=\"orcl\",\n    storage_encrypted=true,\n    backup_retention=cdk.duration.days(7),\n    monitoring_interval=cdk.duration.seconds(60),\n    enable_performance_insights=true,\n    cloudwatch_logs_exports=[\"trace\", \"audit\", \"alert\", \"listener\"\n    ],\n    cloudwatch_logs_retention=logs.retentiondays.one_month,\n    auto_minor_version_upgrade=true,  # required to be true if locator is used in the option group\n    option_group=option_group,\n    parameter_group=parameter_group,\n    removal_policy=removalpolicy.destroy\n)\n\n# allow connections on default port from any ipv4\ninstance.connections.allow_default_port_from_any_ipv4()\n\n# rotate the master user password every 30 days\ninstance.add_rotation_single_user()\n\n# add alarm for high cpu\ncloudwatch.alarm(self, \"highcpu\",\n    metric=instance.metric_cpuutilization(),\n    threshold=90,\n    evaluation_periods=1\n)\n\n# trigger lambda function on instance availability events\nfn = lambda_.function(self, \"function\",\n    code=lambda_.code.from_inline(\"exports.handler = (event) => console.log(event);\"),\n    handler=\"index.handler\",\n    runtime=lambda_.runtime.nodejs_14_x\n)\n\navailability_rule = instance.on_event(\"availability\", target=targets.lambdafunction(fn))\navailability_rule.add_event_pattern(\n    detail={\n        \"eventcategories\": [\"availability\"\n        ]\n    }\n)\n```\n\n## setting public accessibility\n\nyou can set public accessibility for the database instance or cluster using the `publiclyaccessible` property.\nif you specify `true`, it creates an instance with a publicly resolvable dns name, which resolves to a public ip address.\nif you specify `false`, it creates an internal instance with a dns name that resolves to a private ip address.\nthe default value depends on `vpcsubnets`.\nit will be `true` if `vpcsubnets` is `subnettype: subnettype.public`, `false` otherwise.\n\n```python\n# vpc: ec2.vpc\n\n# setting public accessibility for db instance\nrds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.mysql(\n        version=rds.mysqlengineversion.ver_8_0_19\n    ),\n    vpc=vpc,\n    vpc_subnets=ec2.subnetselection(\n        subnet_type=ec2.subnettype.private_with_nat\n    ),\n    publicly_accessible=true\n)\n\n# setting public accessibility for db cluster\nrds.databasecluster(self, \"databasecluster\",\n    engine=rds.databaseclusterengine.aurora,\n    instance_props=rds.instanceprops(\n        vpc=vpc,\n        vpc_subnets=ec2.subnetselection(\n            subnet_type=ec2.subnettype.private_with_nat\n        ),\n        publicly_accessible=true\n    )\n)\n```\n\n## instance events\n\nto define amazon cloudwatch event rules for database instances, use the `onevent`\nmethod:\n\n```python\n# instance: rds.databaseinstance\n# fn: lambda.function\n\nrule = instance.on_event(\"instanceevent\", target=targets.lambdafunction(fn))\n```\n\n## login credentials\n\nby default, database instances and clusters (with the exception of `databaseinstancefromsnapshot` and `serverlessclusterfromsnapshot`) will have `admin` user with an auto-generated password.\nan alternative username (and password) may be specified for the admin user instead of the default.\n\nthe following examples use a `databaseinstance`, but the same usage is applicable to `databasecluster`.\n\n```python\n# vpc: ec2.vpc\n\nengine = rds.databaseinstanceengine.postgres(version=rds.postgresengineversion.ver_12_3)\nrds.databaseinstance(self, \"instancewithusername\",\n    engine=engine,\n    vpc=vpc,\n    credentials=rds.credentials.from_generated_secret(\"postgres\")\n)\n\nrds.databaseinstance(self, \"instancewithusernameandpassword\",\n    engine=engine,\n    vpc=vpc,\n    credentials=rds.credentials.from_password(\"postgres\", secretvalue.ssm_secure(\"/dbpassword\", \"1\"))\n)\n\nmy_secret = secretsmanager.secret.from_secret_name(self, \"dbsecret\", \"mydblogininfo\")\nrds.databaseinstance(self, \"instancewithsecretlogin\",\n    engine=engine,\n    vpc=vpc,\n    credentials=rds.credentials.from_secret(my_secret)\n)\n```\n\nsecrets generated by `fromgeneratedsecret()` can be customized:\n\n```python\n# vpc: ec2.vpc\n\nengine = rds.databaseinstanceengine.postgres(version=rds.postgresengineversion.ver_12_3)\nmy_key = kms.key(self, \"mykey\")\n\nrds.databaseinstance(self, \"instancewithcustomizedsecret\",\n    engine=engine,\n    vpc=vpc,\n    credentials=rds.credentials.from_generated_secret(\"postgres\",\n        secret_name=\"my-cool-name\",\n        encryption_key=my_key,\n        exclude_characters=\"!&*^#@()\",\n        replica_regions=[secretsmanager.replicaregion(region=\"eu-west-1\"), secretsmanager.replicaregion(region=\"eu-west-2\")]\n    )\n)\n```\n\n### snapshot credentials\n\nas noted above, databases created with `databaseinstancefromsnapshot` or `serverlessclusterfromsnapshot` will not create user and auto-generated password by default because it's not possible to change the master username for a snapshot. instead, they will use the existing username and password from the snapshot. you can still generate a new password - to generate a secret similarly to the other constructs, pass in credentials with `fromgeneratedsecret()` or `fromgeneratedpassword()`.\n\n```python\n# vpc: ec2.vpc\n\nengine = rds.databaseinstanceengine.postgres(version=rds.postgresengineversion.ver_12_3)\nmy_key = kms.key(self, \"mykey\")\n\nrds.databaseinstancefromsnapshot(self, \"instancefromsnapshotwithcustomizedsecret\",\n    engine=engine,\n    vpc=vpc,\n    snapshot_identifier=\"mysnapshot\",\n    credentials=rds.snapshotcredentials.from_generated_secret(\"username\",\n        encryption_key=my_key,\n        exclude_characters=\"!&*^#@()\",\n        replica_regions=[secretsmanager.replicaregion(region=\"eu-west-1\"), secretsmanager.replicaregion(region=\"eu-west-2\")]\n    )\n)\n```\n\n## connecting\n\nto control who can access the cluster or instance, use the `.connections` attribute. rds databases have\na default port, so you don't need to specify the port:\n\n```python\n# cluster: rds.databasecluster\n\ncluster.connections.allow_from_any_ipv4(ec2.port.all_traffic(), \"open to the world\")\n```\n\nthe endpoints to access your database cluster will be available as the `.clusterendpoint` and `.readerendpoint`\nattributes:\n\n```python\n# cluster: rds.databasecluster\n\nwrite_address = cluster.cluster_endpoint.socket_address\n```\n\nfor an instance database:\n\n```python\n# instance: rds.databaseinstance\n\naddress = instance.instance_endpoint.socket_address\n```\n\n## rotating credentials\n\nwhen the master password is generated and stored in aws secrets manager, it can be rotated automatically:\n\n```python\nimport aws_cdk.core as cdk\n\n# instance: rds.databaseinstance\n\ninstance.add_rotation_single_user(\n    automatically_after=cdk.duration.days(7),  # defaults to 30 days\n    exclude_characters=\"!@#$%^&*\"\n)\n```\n\n```python\ncluster = rds.databasecluster(stack, \"database\",\n    engine=rds.databaseclusterengine.aurora,\n    instance_props=rds.instanceprops(\n        instance_type=ec2.instancetype.of(ec2.instanceclass.burstable3, ec2.instancesize.small),\n        vpc=vpc\n    )\n)\n\ncluster.add_rotation_single_user()\n```\n\nthe multi user rotation scheme is also available:\n\n```python\n# instance: rds.databaseinstance\n# my_imported_secret: rds.databasesecret\n\ninstance.add_rotation_multi_user(\"myuser\",\n    secret=my_imported_secret\n)\n```\n\nit's also possible to create user credentials together with the instance/cluster and add rotation:\n\n```python\n# instance: rds.databaseinstance\n\nmy_user_secret = rds.databasesecret(self, \"myusersecret\",\n    username=\"myuser\",\n    secret_name=\"my-user-secret\",  # optional, defaults to a cloudformation-generated name\n    master_secret=instance.secret,\n    exclude_characters=\"{}[]()'\\\"/\\\\\"\n)\nmy_user_secret_attached = my_user_secret.attach(instance) # adds db connections information in the secret\n\ninstance.add_rotation_multi_user(\"myuser\",  # add rotation using the multi user scheme\n    secret=my_user_secret_attached)\n```\n\n**note**: this user must be created manually in the database using the master credentials.\nthe rotation will start as soon as this user exists.\n\naccess to the secrets manager api is required for the secret rotation. this can be achieved either with\ninternet connectivity (through nat) or with a vpc interface endpoint. by default, the rotation lambda function\nis deployed in the same subnets as the instance/cluster. if access to the secrets manager api is not possible from\nthose subnets or using the default api endpoint, use the `vpcsubnets` and/or `endpoint` options:\n\n```python\n# instance: rds.databaseinstance\n# my_endpoint: ec2.interfacevpcendpoint\n\n\ninstance.add_rotation_single_user(\n    vpc_subnets=ec2.subnetselection(subnet_type=ec2.subnettype.private_with_nat),  # place rotation lambda in private subnets\n    endpoint=my_endpoint\n)\n```\n\nsee also [@aws-cdk/aws-secretsmanager](https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-secretsmanager/readme.md) for credentials rotation of existing clusters/instances.\n\n## iam authentication\n\nyou can also authenticate to a database instance using aws identity and access management (iam) database authentication;\nsee [https://docs.aws.amazon.com/amazonrds/latest/userguide/usingwithrds.iamdbauth.html](https://docs.aws.amazon.com/amazonrds/latest/userguide/usingwithrds.iamdbauth.html) for more information\nand a list of supported versions and limitations.\n\n**note**: `grantconnect()` does not currently work - see [this github issue](https://github.com/aws/aws-cdk/issues/11851).\n\nthe following example shows enabling iam authentication for a database instance and granting connection access to an iam role.\n\n```python\n# vpc: ec2.vpc\n\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.mysql(version=rds.mysqlengineversion.ver_8_0_19),\n    vpc=vpc,\n    iam_authentication=true\n)\nrole = iam.role(self, \"dbrole\", assumed_by=iam.accountprincipal(self.account))\ninstance.grant_connect(role)\n```\n\nthe following example shows granting connection access for rds proxy to an iam role.\n\n```python\n# vpc: ec2.vpc\n\ncluster = rds.databasecluster(self, \"database\",\n    engine=rds.databaseclusterengine.aurora,\n    instance_props=rds.instanceprops(vpc=vpc)\n)\n\nproxy = rds.databaseproxy(self, \"proxy\",\n    proxy_target=rds.proxytarget.from_cluster(cluster),\n    secrets=[cluster.secret],\n    vpc=vpc\n)\n\nrole = iam.role(self, \"dbproxyrole\", assumed_by=iam.accountprincipal(self.account))\nproxy.grant_connect(role, \"admin\")\n```\n\n**note**: in addition to the setup above, a database user will need to be created to support iam auth.\nsee [https://docs.aws.amazon.com/amazonrds/latest/userguide/usingwithrds.iamdbauth.dbaccounts.html](https://docs.aws.amazon.com/amazonrds/latest/userguide/usingwithrds.iamdbauth.dbaccounts.html) for setup instructions.\n\n## kerberos authentication\n\nyou can also authenticate using kerberos to a database instance using aws managed microsoft ad for authentication;\nsee [https://docs.aws.amazon.com/amazonrds/latest/userguide/kerberos-authentication.html](https://docs.aws.amazon.com/amazonrds/latest/userguide/kerberos-authentication.html) for more information\nand a list of supported versions and limitations.\n\nthe following example shows enabling domain support for a database instance and creating an iam role to access\ndirectory services.\n\n```python\n# vpc: ec2.vpc\n\nrole = iam.role(self, \"rdsdirectoryservicesrole\",\n    assumed_by=iam.serviceprincipal(\"rds.amazonaws.com\"),\n    managed_policies=[\n        iam.managedpolicy.from_aws_managed_policy_name(\"service-role/amazonrdsdirectoryserviceaccess\")\n    ]\n)\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.mysql(version=rds.mysqlengineversion.ver_8_0_19),\n    vpc=vpc,\n    domain=\"d-????????\",  # the id of the domain for the instance to join.\n    domain_role=role\n)\n```\n\n**note**: in addition to the setup above, you need to make sure that the database instance has network connectivity\nto the domain controllers. this includes enabling cross-vpc traffic if in a different vpc and setting up the\nappropriate security groups/network acl to allow traffic between the database instance and domain controllers.\nonce configured, see [https://docs.aws.amazon.com/amazonrds/latest/userguide/kerberos-authentication.html](https://docs.aws.amazon.com/amazonrds/latest/userguide/kerberos-authentication.html) for details\non configuring users for each available database engine.\n\n## metrics\n\ndatabase instances and clusters both expose metrics (`cloudwatch.metric`):\n\n```python\n# the number of database connections in use (average over 5 minutes)\n# instance: rds.databaseinstance\n\n# average cpu utilization over 5 minutes\n# cluster: rds.databasecluster\n\ndb_connections = instance.metric_database_connections()\ncpu_utilization = cluster.metric_cpuutilization()\n\n# the average amount of time taken per disk i/o operation (average over 1 minute)\nread_latency = instance.metric(\"readlatency\", statistic=\"average\", period=duration.seconds(60))\n```\n\n## enabling s3 integration\n\ndata in s3 buckets can be imported to and exported from certain database engines using sql queries. to enable this\nfunctionality, set the `s3importbuckets` and `s3exportbuckets` properties for import and export respectively. when\nconfigured, the cdk automatically creates and configures iam roles as required.\nadditionally, the `s3importrole` and `s3exportrole` properties can be used to set this role directly.\n\nyou can read more about loading data to (or from) s3 here:\n\n* aurora mysql - [import](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/auroramysql.integrating.loadfroms3.html)\n  and [export](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/auroramysql.integrating.saveintos3.html).\n* aurora postgresql - [import](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/aurorapostgresql.migrating.html#user_postgresql.s3import)\n  and [export](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/postgresql-s3-export.html).\n* microsoft sql server - [import and export](https://docs.aws.amazon.com/amazonrds/latest/userguide/sqlserver.procedural.importing.html)\n* postgresql - [import](https://docs.aws.amazon.com/amazonrds/latest/userguide/postgresql.procedural.importing.html)\n  and [export](https://docs.aws.amazon.com/amazonrds/latest/userguide/postgresql-s3-export.html)\n* oracle - [import and export](https://docs.aws.amazon.com/amazonrds/latest/userguide/oracle-s3-integration.html)\n\nthe following snippet sets up a database cluster with different s3 buckets where the data is imported and exported -\n\n```python\nimport aws_cdk.aws_s3 as s3\n\n# vpc: ec2.vpc\n\nimport_bucket = s3.bucket(self, \"importbucket\")\nexport_bucket = s3.bucket(self, \"exportbucket\")\nrds.databasecluster(self, \"dbcluster\",\n    engine=rds.databaseclusterengine.aurora,\n    instance_props=rds.instanceprops(\n        vpc=vpc\n    ),\n    s3_import_buckets=[import_bucket],\n    s3_export_buckets=[export_bucket]\n)\n```\n\n## creating a database proxy\n\namazon rds proxy sits between your application and your relational database to efficiently manage\nconnections to the database and improve scalability of the application. learn more about at [amazon rds proxy](https://aws.amazon.com/rds/proxy/)\n\nthe following code configures an rds proxy for a `databaseinstance`.\n\n```python\n# vpc: ec2.vpc\n# security_group: ec2.securitygroup\n# secrets: list[secretsmanager.secret[]]\n# db_instance: rds.databaseinstance\n\n\nproxy = db_instance.add_proxy(\"proxy\",\n    borrow_timeout=duration.seconds(30),\n    max_connections_percent=50,\n    secrets=secrets,\n    vpc=vpc\n)\n```\n\n## exporting logs\n\nyou can publish database logs to amazon cloudwatch logs. with cloudwatch logs, you can perform real-time analysis of the log data,\nstore the data in highly durable storage, and manage the data with the cloudwatch logs agent. this is available for both database\ninstances and clusters; the types of logs available depend on the database type and engine being used.\n\n```python\nimport aws_cdk.aws_logs as logs\n# my_logs_publishing_role: iam.role\n# vpc: ec2.vpc\n\n\n# exporting logs from a cluster\ncluster = rds.databasecluster(self, \"database\",\n    engine=rds.databaseclusterengine.aurora(\n        version=rds.auroraengineversion.ver_1_17_9\n    ),\n    instance_props=rds.instanceprops(\n        vpc=vpc\n    ),\n    cloudwatch_logs_exports=[\"error\", \"general\", \"slowquery\", \"audit\"],  # export all available mysql-based logs\n    cloudwatch_logs_retention=logs.retentiondays.three_months,  # optional - default is to never expire logs\n    cloudwatch_logs_retention_role=my_logs_publishing_role\n)\n\n# exporting logs from an instance\ninstance = rds.databaseinstance(self, \"instance\",\n    engine=rds.databaseinstanceengine.postgres(\n        version=rds.postgresengineversion.ver_12_3\n    ),\n    vpc=vpc,\n    cloudwatch_logs_exports=[\"postgresql\"]\n)\n```\n\n## option groups\n\nsome db engines offer additional features that make it easier to manage data and databases, and to provide additional security for your database.\namazon rds uses option groups to enable and configure these features. an option group can specify features, called options,\nthat are available for a particular amazon rds db instance.\n\n```python\n# vpc: ec2.vpc\n# security_group: ec2.securitygroup\n\n\nrds.optiongroup(self, \"options\",\n    engine=rds.databaseinstanceengine.oracle_se2(\n        version=rds.oracleengineversion.ver_19\n    ),\n    configurations=[rds.optionconfiguration(\n        name=\"oem\",\n        port=5500,\n        vpc=vpc,\n        security_groups=[security_group]\n    )\n    ]\n)\n```\n\n## parameter groups\n\ndatabase parameters specify how the database is configured.\nfor example, database parameters can specify the amount of resources, such as memory, to allocate to a database.\nyou manage your database configuration by associating your db instances with parameter groups.\namazon rds defines parameter groups with default settings.\n\nyou can create your own parameter group for your cluster or instance and associate it with your database:\n\n```python\n# vpc: ec2.vpc\n\n\nparameter_group = rds.parametergroup(self, \"parametergroup\",\n    engine=rds.databaseinstanceengine.sql_server_ee(\n        version=rds.sqlserverengineversion.ver_11\n    ),\n    parameters={\n        \"locks\": \"100\"\n    }\n)\n\nrds.databaseinstance(self, \"database\",\n    engine=rds.databaseinstanceengine.sql_server_ee,\n    vpc=vpc,\n    parameter_group=parameter_group\n)\n```\n\nanother way to specify parameters is to use the inline field `parameters` that creates an rds parameter group for you.\nyou can use this if you do not want to reuse the parameter group instance for different instances:\n\n```python\n# vpc: ec2.vpc\n\n\nrds.databaseinstance(self, \"database\",\n    engine=rds.databaseinstanceengine.sql_server_ee(version=rds.sqlserverengineversion.ver_11),\n    vpc=vpc,\n    parameters={\n        \"locks\": \"100\"\n    }\n)\n```\n\nyou cannot specify a parameter map and a parameter group at the same time.\n\n## serverless\n\n[amazon aurora serverless](https://aws.amazon.com/rds/aurora/serverless/) is an on-demand, auto-scaling configuration for amazon\naurora. the database will automatically start up, shut down, and scale capacity\nup or down based on your application's needs. it enables you to run your database\nin the cloud without managing any database instances.\n\nthe following example initializes an aurora serverless postgresql cluster.\naurora serverless clusters can specify scaling properties which will be used to\nautomatically scale the database cluster seamlessly based on the workload.\n\n```python\n# vpc: ec2.vpc\n\n\ncluster = rds.serverlesscluster(self, \"anothercluster\",\n    engine=rds.databaseclusterengine.aurora_postgresql,\n    parameter_group=rds.parametergroup.from_parameter_group_name(self, \"parametergroup\", \"default.aurora-postgresql10\"),\n    vpc=vpc,\n    scaling=rds.serverlessscalingoptions(\n        auto_pause=duration.minutes(10),  # default is to pause after 5 minutes of idle time\n        min_capacity=rds.auroracapacityunit.acu_8,  # default is 2 aurora capacity units (acus)\n        max_capacity=rds.auroracapacityunit.acu_32\n    )\n)\n```\n\naurora serverless clusters do not support the following features:\n\n* loading data from an amazon s3 bucket\n* saving data to an amazon s3 bucket\n* invoking an aws lambda function with an aurora mysql native function\n* aurora replicas\n* backtracking\n* multi-master clusters\n* database cloning\n* iam database cloning\n* iam database authentication\n* restoring a snapshot from mysql db instance\n* performance insights\n* rds proxy\n\nread more about the [limitations of aurora serverless](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/aurora-serverless.html#aurora-serverless.limitations)\n\nlearn more about using amazon aurora serverless by reading the [documentation](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/aurora-serverless.html)\n\nuse `serverlessclusterfromsnapshot` to create a serverless cluster from a snapshot:\n\n```python\n# vpc: ec2.vpc\n\nrds.serverlessclusterfromsnapshot(self, \"cluster\",\n    engine=rds.databaseclusterengine.aurora_mysql,\n    vpc=vpc,\n    snapshot_identifier=\"mysnapshot\"\n)\n```\n\n### data api\n\nyou can access your aurora serverless db cluster using the built-in data api. the data api doesn't require a persistent connection to the db cluster. instead, it provides a secure http endpoint and integration with aws sdks.\n\nthe following example shows granting data api access to a lamba function.\n\n```python\n# vpc: ec2.vpc\n\n# code: lambda.code\n\n\ncluster = rds.serverlesscluster(self, \"anothercluster\",\n    engine=rds.databaseclusterengine.aurora_mysql,\n    vpc=vpc,  # this parameter is optional for serverless clusters\n    enable_data_api=true\n)\nfn = lambda_.function(self, \"myfunction\",\n    runtime=lambda_.runtime.nodejs_14_x,\n    handler=\"index.handler\",\n    code=code,\n    environment={\n        \"cluster_arn\": cluster.cluster_arn,\n        \"secret_arn\": cluster.secret.secret_arn\n    }\n)\ncluster.grant_data_api_access(fn)\n```\n\n**note**: to invoke the data api, the resource will need to read the secret associated with the cluster.\n\nto learn more about using the data api, see the [documentation](https://docs.aws.amazon.com/amazonrds/latest/aurorauserguide/data-api.html).\n\n### default vpc\n\nthe `vpc` parameter is optional.\n\nif not provided, the cluster will be created in the default vpc of the account and region.\nas this vpc is not deployed with aws cdk, you can't configure the `vpcsubnets`, `subnetgroup` or `securitygroups` of the aurora serverless cluster.\nif you want to provide one of `vpcsubnets`, `subnetgroup` or `securitygroups` parameter, please provide a `vpc`.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-rds",
  "package_url": "https://pypi.org/project/aws-cdk.aws-rds/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-rds/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-rds/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-events (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-kms (==1.204.0)",
    "aws-cdk.aws-logs (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.aws-secretsmanager (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.cx-api (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::rds",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk aws_rds auroramysql aws_s3 aws",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_rds",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_events",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_kms",
    "pypi_aws_cdk.aws_logs",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.aws_secretsmanager",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.cx_api",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}