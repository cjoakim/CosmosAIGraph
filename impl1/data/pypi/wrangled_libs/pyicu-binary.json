{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: c++",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: internationalization",
    "topic :: software development :: localization"
  ],
  "description": "# readme file for pyicu\n\n## welcome\n\nwelcome to pyicu, a python extension wrapping the icu c++ libraries.\n\nicu stands for \"international components for unicode\".\nthese are the i18n libraries of the unicode consortium.\nthey implement much of the unicode standard,\nmany of its companion unicode technical standards,\nand much of unicode cldr.\n\nthe pyicu source code is hosted at https://gitlab.pyicu.org/main/pyicu.\n\nthe icu homepage is http://site.icu-project.org/\n\nsee also the cldr homepage at http://cldr.unicode.org/\n\n## installing pyicu\n\npyicu is a python extension implemented in c++ that wraps the c/c++ icu library.\nit is known to also work as a [pypy](https://www.pypy.org/) extension.\nunless ``pkg-config`` and the icu libraries and headers are already installed,\nbuilding pyicu from the sources on [pypi](https://pypi.org/project/pyicu/)\ninvolves more than just a ``pip`` call. many operating systems distribute\npre-built binary packages of icu and pyicu, see below.\n\n  - mac os x\n    - ensure icu is installed and can be found by `pkg-config` (as `icu-config` was [deprecated](http://userguide.icu-project.org/howtouseicu#toc-c-makefiles) as of icu 63.1), either by following [icu build instructions](https://unicode-org.github.io/icu/userguide/icu4c/build.html), or by using homebrew:\n      ```sh\n      # install libicu (keg-only)\n      brew install pkg-config icu4c\n\n      # let setup.py discover keg-only icu4c via pkg-config\n      export path=\"/usr/local/opt/icu4c/bin:/usr/local/opt/icu4c/sbin:$path\"\n      export pkg_config_path=\"$pkg_config_path:/usr/local/opt/icu4c/lib/pkgconfig\"\n      ```\n    - install pyicu **with the same c++ compiler as your python distribution**\n      ([more info](https://gitlab.pyicu.org/main/pyicu/merge_requests/140#issuecomment-782283491)):\n      ```sh\n      # either - when using a gcc-built cpython (e.g. from homebrew)\n      export cc=\"$(which gcc)\" cxx=\"$(which g++)\"\n      # or - when using system cpython or another clang-based cpython, ensure system clang is used (for proper libstdc++ https://gitlab.pyicu.org/main/pyicu/issues/5#issuecomment-291631507):\n      unset cc cxx\n\n      # avoid wheels from previous runs or pypi\n      pip install --no-binary=:pyicu: pyicu\n      ```\n\n    - icu and pyicu binaries are both available via [macports](https://www.macports.org/) as well. the same limitations about mixing binaries may apply.\n      ```sh\n      # see versions available\n      /opt/local/bin/port search pyicu\n      sudo /opt/local/bin/port install ...\n      ```\n\n  - debian\n    ```sh\n    apt-get update\n    \n    # either - from apt directly https://packages.debian.org/source/stable/pyicu\n    apt-get install python3-icu\n    # or - from source\n    apt-get install pkg-config libicu-dev\n    pip install --no-binary=:pyicu: pyicu\n    ```\n\n  - ubuntu: similar to debian, there is a pyicu\n    [package](https://packages.ubuntu.com/source/xenial/python/pyicu)\n    available via ``apt``.\n\n  - alpine linux: there is a pyicu\n    [package](https://pkgs.alpinelinux.org/package/edge/community/x86/py3-icu)\n    available via ``apk``.\n\n  - netbsd: there is a pyicu [package](https://pkgsrc.se/textproc/py-icu)\n    available via ``pkg_add``.\n\n  - openbsd: there is a pyicu [package](https://openports.se/textproc/py-icu)\n    available via ``pkg_add``.\n\n  - other operating systems: see below.\n\n## building pyicu\n\nbefore building pyicu the icu libraries must be built and installed. refer\nto each system's [instructions](https://unicode-org.github.io/icu/userguide/icu4c/build.html) for more information.\n\npyicu is built with setuptools:\n\n   - verify that ``pkg-config`` is available (the ``icu-config`` program is\n     [deprecated](http://userguide.icu-project.org/howtouseicu#toc-c-makefiles)\n     as of icu 63.1)\n     ```sh\n     pkg-config --cflags --libs icu-i18n\n     ```\n     if this command returns an error or doesn't return the paths expected\n     then ensure that the ``includes``, ``lflags``, ``cflags`` and ``libraries``\n     dictionaries in ``setup.py`` contain correct values for your platform.\n     starting with icu 60, ``-std=c++11`` must appear in your cflags or be the\n     default for your c++ compiler.\n\n   - build and install pyicu\n     ```sh\n     python setup.py build\n     sudo python setup.py install\n     ```\n\n## running pyicu\n\n  - mac os x\n    make sure that ``dyld_library_path`` contains paths to the directory(ies)\n    containing the icu libs.\n\n  - linux & solaris\n    make sure that ``ld_library_path`` contains paths to the directory(ies)\n    containing the icu libs or that you added the corresponding ``-rpath``\n    argument to ``lflags``.\n\n  - windows\n    make sure that ``path`` contains paths to the directory(ies)\n    containing the icu dlls.\n\n\n## what's available\n\nsee the [changes](https://gitlab.pyicu.org/main/pyicu/blob/main/changes) file\nfor an up to date log of changes and additions.\n\n\n## api documentation\n\nthere is no api documentation for pyicu. the api for icu is documented at\nhttps://unicode-org.github.io/icu-docs/apidoc/released/icu4c/ and the\nfollowing patterns can be used to translate from the c++ apis to the\ncorresponding python apis.\n\n### strings\n\nthe icu string type, [unicodestring](https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1unicodestring.html), is a type pointing at a mutable array of [uchar](https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac) unicode 16-bit wide characters and is described [here](https://unicode-org.github.io/icu-docs/apidoc/dev/icu4c/classicu_1_1unicodestring.html#details). the python 3 [str](https://docs.python.org/3/library/stdtypes.html#str) type is described [here](https://docs.python.org/3/library/stdtypes.html#index-26) and [here](https://docs.python.org/3/howto/unicode.html). the python 2 [unicode](https://docs.python.org/2.7/reference/datamodel.html#index-23) type is described [here](https://docs.python.org/2.7/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange).\n\nbecause of their differences, icu's and python's string objects are not merged\ninto the same type when crossing the c++ boundary but converted.\n\nicu apis taking ``unicodestring`` arguments have been overloaded to also\naccept arguments that are python 3 ``str`` or python 2 ``unicode`` objects.\npython 2 ``str`` objects are auto-decoded into icu strings using the ``utf-8``\nencoding.\n\nto convert a python 3 ``bytes`` or a python 2 ``str`` object encoded in an\nencoding other than ``utf-8`` to an icu ``unicodestring`` use the\n``unicodestring(str, encodingname)`` constructor.\n\nicu's c++ apis accept and return ``unicodestring`` arguments in several\nways: by value, by pointer or by reference.\nwhen an icu c++ api is documented to accept a ``unicodestring`` reference\nparameter, it is safe to assume that there are several corresponding\npyicu python apis making it accessible in simpler ways:\n\nfor example, the ``'unicodestring &locale::getdisplayname(unicodestring &)'``\napi, documented\n[here](https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1locale.html#a61def321a9cfd9904b59e3f1897f835e),\ncan be invoked from python in several ways:\n\n1. the icu way\n\n        >>> from icu import unicodestring, locale\n        >>> locale = locale('pt_br')\n        >>> string = unicodestring()\n        >>> name = locale.getdisplayname(string)\n        >>> name\n        <unicodestring: 'portuguese (brazil)'>\n        >>> name is string\n        true                  <-- string arg was returned, modified in place\n\n2. the python way\n\n        >>> from icu import locale\n        >>> locale = locale('pt_br')\n        >>> name = locale.getdisplayname()\n        >>> name\n        'portuguese (brazil)'\n\n    a ``unicodestring`` object was allocated and converted to a python\n    ``str`` object.\n\na unicodestring can be converted to a python unicode string with python 3's\n``str()`` or python 2's ``unicode()`` constructor. the usual ``len()``,\ncomparison, `[]`` and ``[:]`` operators are all available, with the additional\ntwists that slicing is not read-only and that ``+=`` is also available since a\nunicodestring is mutable. for example:\n\n    >>> name = locale.getdisplayname()\n    'portuguese (brazil)'\n    >>> name = unicodestring(name)\n    >>> name\n    <unicodestring: 'portuguese (brazil)'>\n    >>> str(name)\n    'portuguese (brazil)'\n    >>> len(name)\n    19\n    >>> str(name)\n    'portuguese (brazil)'\n    >>> name[3]\n    't'\n    >>> name[12:18]\n    <unicodestring: 'brazil'>\n    >>> name[12:18] = 'the country of brasil'\n    >>> name\n    <unicodestring: 'portuguese (the country of brasil)'>\n    >>> name += ' oh joy'\n    >>> name\n    <unicodestring: 'portuguese (the country of brasil) oh joy'>\n\n### error reporting\n\nthe c++ icu library does not use c++ exceptions to report errors. icu\nc++ apis return errors via a ``uerrorcode`` reference argument. all such\napis are wrapped by python apis that omit this argument and throw an\n``icuerror`` python exception instead. the same is true for icu apis\ntaking both a ``parseerror`` and a ``uerrorcode``, they are both to be\nomitted.\n\nfor example, the ``'unicodestring &dateformat::format(const formattable &, unicodestring &, fieldposition &, uerrorcode &)'`` api, documented [here](https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1dateformat.html#aae63209f1202550c91e2beed5691b062) is invoked from python with:\n\n    >>> from icu import dateformat, formattable\n    >>> df = dateformat.createinstance()\n    >>> df\n    <simpledateformat: m/d/yy h:mm a>\n    >>> f = formattable(940284258.0, formattable.kisdate)\n    >>> df.format(f)\n    '10/18/99 3:04 pm'\n\nof course, the simpler ``'unicodestring &dateformat::format(udate, unicodestring &)'`` documented [here](https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1dateformat.html#a5940ccf5676d3fa043d8255c55b7ddd1) can be used too:\n\n    >>> from icu import dateformat\n    >>> df = dateformat.createinstance()\n    >>> df\n    <simpledateformat: m/d/yy h:mm a>\n    >>> df.format(940284258.0)\n    '10/18/99 3:04 pm'\n\n### dates\n\nicu uses a double floating point type called ``udate`` that represents the\nnumber of milliseconds elapsed since 1970-jan-01 utc for dates.\n\nin python, the value returned by the ``time`` module's ``time()``\nfunction is the number of seconds since 1970-jan-01 utc. because of this\ndifference, floating point values are multiplied by 1000 when passed to\napis taking ``udate`` and divided by 1000 when returned as ``udate``.\n\npython's ``datetime`` objects, with or without timezone information, can\nalso be used with apis taking ``udate`` arguments. the ``datetime``\nobjects get converted to ``udate`` when crossing into the c++ layer.\n\n### arrays\n\nmany icu api take array arguments. a list of elements of the array\nelement types is to be passed from python.\n\n### stringenumeration\n\nan icu ``stringenumeration`` has three ``next`` methods: ``next()`` which\nreturns ``str`` objects, ``unext()`` which returns ``str`` objects in python 3\nor ``unicode`` objects in python 2 and ``snext()`` which returns\n``unicodestring`` objects. any of these methods can be used as an iterator,\nusing the python built-in ``iter`` function.\n\nfor example, let ``e`` be a ``stringenumeration`` instance:\n\n```python\ne = timezone.createenumeration()\n[s for s in e] # a list of 'str' objects\n[s for s in iter(e.unext, '')] # a list of 'str' or 'unicode' objects\n[s for s in iter(e.snext, '')] # a list of 'unicodestring' objects\n```\n\n### timezones\n\nthe icu ``timezone`` type may be wrapped with an ``icutzinfo`` type for\nusage with python's ``datetime`` type. for example:\n\n```python\nfrom datetime import datetime\ntz = icutzinfo(timezone.createtimezone('us/mountain'))\ndatetime.now(tz)\n```\n\nor, even simpler:\n\n```python\ntz = icutzinfo.getinstance('pacific/fiji')\ndatetime.now(tz)\n```\n\nto get the default time zone use:\n\n```python\ndefaulttz = icutzinfo.getdefault()\n```\n\nto get the time zone's id, use the ``tzid`` attribute or coerce the time\nzone to a string:\n\n```python\nicutzinfo.getinstance('pacific/fiji').tzid -> 'pacific/fiji'\nstr(icutzinfo.getinstance('pacific/fiji')) -> 'pacific/fiji'\n```\n\n## further reading\n\nthe [unit tests](https://gitlab.pyicu.org/main/pyicu/-/tree/main/test) have\nmore examples of actual pyicu usage.\n\nthere are also a few\n[samples](https://gitlab.pyicu.org/main/pyicu/-/tree/main/samples) ported from\nicu c/c++.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "pyicu-binary",
  "package_url": "https://pypi.org/project/PyICU-binary/",
  "project_url": "https://pypi.org/project/PyICU-binary/",
  "project_urls": {
    "Homepage": "https://gitlab.pyicu.org/main/pyicu"
  },
  "release_url": "https://pypi.org/project/PyICU-binary/2.7.4/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python extension wrapping the icu c++ api",
  "version": "2.7.4",
  "releases": [],
  "developers": [
    "andi_vajda",
    "vajda@pyicu.org"
  ],
  "kwds": "pyicu py3 python3 pypy cpython",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pyicu_binary",
  "homepage": "https://gitlab.pyicu.org/main/pyicu",
  "release_count": 3,
  "dependency_ids": []
}