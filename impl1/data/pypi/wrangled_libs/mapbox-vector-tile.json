{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "mapbox vector tile\n==================\n\n[![ci](https://github.com/tilezen/mapbox-vector-tile/actions/workflows/ci.yml/badge.svg)](https://github.com/tilezen/mapbox-vector-tile/actions/workflows/ci.yml)\n[![pre-commit](https://github.com/tilezen/mapbox-vector-tile/actions/workflows/pre-commit.yml/badge.svg)](https://github.com/tilezen/mapbox-vector-tile/actions/workflows/pre-commit.yml)\n[![coverage status](https://coveralls.io/repos/github/tilezen/mapbox-vector-tile/badge.svg?branch=master)](https://coveralls.io/github/tilezen/mapbox-vector-tile?branch=master)\n\ninstallation\n------------\n\nmapbox-vector-tile is compatible with python 3.8 or newer. it is listed on pypi as `mapbox-vector-tile`. the\nrecommended way to install is via `pip`:\n\n```shell\npip install mapbox-vector-tile\n```\n\nan extra dependency has been defined to install [`pyproj`](https://pyproj4.github.io/pyproj/stable/). this is useful\nwhen changing the coordinate reference system when encoding or decoding tiles.\n\n```shell\npip install mapbox-vector-tile[proj]\n```\n\nencoding\n--------\n\nencode method expects an array of layers or at least a single valid layer. a valid layer is a dictionary with the\nfollowing keys\n\n* `name`: layer name\n* `features`: an array of features. a feature is a dictionary with the following keys:\n\n  * `geometry`: representation of the feature geometry in wkt, wkb, or a shapely geometry. coordinates are relative to the tile, scaled in the range `[0, 4096)`. see below for example code to perform the necessary transformation. *note* that `geometrycollection` types are not supported, and will trigger a `valueerror`.\n  * `properties`: a dictionary with a few keys and their corresponding values.\n\nthe encoding operation accepts options which can be defined per layer using the `per_layer_options` argument. if\nthere is missing layer or missing options values in the `per_layer_options`, the options of `default_options` are\ntaken into account. finally, global default values are used. see the docstring of the `encode` method for more\ndetails about the available options and their global default values.\n\n\n```python\n\n  >>> import mapbox_vector_tile\n\n  # using wkt\n  >>> mapbox_vector_tile.encode([\n      {\n        \"name\": \"water\",\n        \"features\": [\n          {\n            \"geometry\":\"polygon ((0 0, 0 1, 1 1, 1 0, 0 0))\",\n            \"properties\":{\n              \"uid\":123,\n              \"foo\":\"bar\",\n              \"cat\":\"flew\"\n            }\n          }\n        ]\n      },\n      {\n        \"name\": \"air\",\n        \"features\": [\n          {\n            \"geometry\":\"linestring(159 3877, -1570 3877)\",\n            \"properties\":{\n              \"uid\":1234,\n              \"foo\":\"bar\",\n              \"cat\":\"flew\"\n            }\n          }\n        ]\n      }\n    ])\n\n  b'\\x1ah\\n\\x05water\\x12\\x18\\x12\\x06\\x00\\x00\\x01\\x01\\x02\\x02\\x18\\x03\"\\x0c\\t\\x00\\x80@\\x1a\\x00\\x01\\x02\\x00\\x00\\x02\\x0f\\x1a\\x03uid\\x1a\\x03foo\\x1a\\x03cat\"\\x02 {\"\\x05\\n\\x03bar\"\\x06\\n\\x04flew(\\x80 x\\x02\\x1ad\\n\\x03air\\x12\\x15\\x12\\x06\\x00\\x00\\x01\\x01\\x02\\x02\\x18\\x02\"\\t\\t\\xbe\\x02\\xb6\\x03\\n\\x81\\x1b\\x00\\x1a\\x03uid\\x1a\\x03foo\\x1a\\x03cat\"\\x03 \\xd2\\t\"\\x05\\n\\x03bar\"\\x06\\n\\x04flew(\\x80 x\\x02'\n\n\n  # using wkb\n  >>> mapbox_vector_tile.encode([\n      {\n        \"name\": \"water\",\n        \"features\": [\n          {\n            \"geometry\":b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n            \"properties\":{\n              \"uid\":123,\n              \"foo\":\"bar\",\n              \"cat\":\"flew\"\n            }\n          }\n        ]\n      },\n      {\n        \"name\": \"air\",\n        \"features\": [\n          {\n            \"geometry\":b\"\\x01\\x03\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\xf0?\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n            \"properties\":{\n              \"uid\":1234,\n              \"foo\":\"bar\",\n              \"cat\":\"flew\"\n            }\n          }\n        ]\n      }\n      ])\n\n    b'\\x1ah\\n\\x05water\\x12\\x18\\x12\\x06\\x00\\x00\\x01\\x01\\x02\\x02\\x18\\x03\"\\x0c\\t\\x00\\x80@\\x1a\\x00\\x01\\x02\\x00\\x00\\x02\\x0f\\x1a\\x03uid\\x1a\\x03foo\\x1a\\x03cat\"\\x02 {\"\\x05\\n\\x03bar\"\\x06\\n\\x04flew(\\x80 x\\x02\\x1ag\\n\\x03air\\x12\\x18\\x12\\x06\\x00\\x00\\x01\\x01\\x02\\x02\\x18\\x03\"\\x0c\\t\\x00\\x80@\\x1a\\x00\\x01\\x02\\x00\\x00\\x02\\x0f\\x1a\\x03uid\\x1a\\x03foo\\x1a\\x03cat\"\\x03 \\xd2\\t\"\\x05\\n\\x03bar\"\\x06\\n\\x04flew(\\x80 x\\x02'\n```\n\n### coordinate transformations for encoding\n\nthe encoder expects geometries either:\n\n1. in tile-relative coordinates, where the lower left corner is origin and values grow up and to the right, and the tile is 4096 pixels square. for example, `point(0 0)` is the lower left corner of the tile and `point(4096, 4096)` is the upper right corner of the tile. in this case, the library does no projection, and coordinates are encoded as-is.\n2. in another coordinate system, with the tile bounds given by the `quantize_bounds` parameter. in this case, the library will scale coordinates so that the `quantize_bounds` fit within the range (0, 4096) in both `x` and `y` directions. aside than the affine transformation, the library does no other projection.\n\nit is possible to control whether the tile is in a \"y down\" coordinate system by setting the parameter `y_coord_down=true` on the call to `encode()`. the default is \"y up\".\n\nit is possible to control the tile extents (by default, 4096 as used in the examples above), by setting the `extents` parameter on the call to `encode()`. the default is 4096.\n\nif you have geometries in longitude and latitude (epsg:4326), you can convert to tile-based coordinates by first projecting to spherical mercator (epsg:3857) and then computing the pixel location within the tile. this example code uses django's included geos library to do the transformation for `linestring` objects:\n\n```python\n  srid_spherical_mercator = 3857\n\n  def linestring_in_tile(tile_bounds, line):\n      # `mapbox-vector-tile` has a hardcoded tile extent of 4096 units.\n      mvt_extent = 4096\n      from django.contrib.gis.geos import linestring\n\n      # we need tile bounds in spherical mercator\n      assert tile_bounds.srid == srid_spherical_mercator\n\n      # and we need the line to be in a known projection so we can re-project\n      assert line.srid is not none\n      line.transform(srid_spherical_mercator)\n\n      (x0, y0, x_max, y_max) = tile_bounds.extent\n      x_span = x_max - x0\n      y_span = y_max - y0\n\n      tile_based_coords = []\n      for x_merc, y_merc in line:\n          tile_based_coord = (int((x_merc - x0) * mvt_extent / x_span),\n                              int((y_merc - y0) * mvt_extent / y_span))\n          tile_based_coords.append(tile_based_coord)\n      return linestring(*tile_based_coords)\n```\n\nthe tile bounds can be found with `mercantile`, so a complete usage example might look like this:\n\n```python\n  from django.contrib.gis.geos import linestring, polygon\n  import mercantile\n  import mapbox_vector_tile\n\n  srid_lnglat = 4326\n  srid_spherical_mercator = 3857\n\n  tile_xyz = (2452, 3422, 18)\n  tile_bounds = polygon.from_bbox(mercantile.bounds(*tile_xyz))\n  tile_bounds.srid = srid_lnglat\n  tile_bounds.transform(srid_spherical_mercator)\n\n  lnglat_line = linestring(((-122.1, 45.1), (-122.2, 45.2)), srid=srid_lnglat)\n  tile_line = linestring_in_tile(tile_bounds, lnglat_line)\n  tile_pbf = mapbox_vector_tile.encode({\n    \"name\": \"my-layer\",\n    \"features\": [ {\n      \"geometry\": tile_line.wkt,\n      \"properties\": { \"stuff\": \"things\" },\n    } ]\n  })\n```\n\nnote that this example may not have anything visible within the tile when rendered. it's up to you to make sure you put the right data in the tile!\n\nalso note that the spec allows the extents to be modified, even though they are often set to 4096 by convention. `mapbox-vector-tile` assumes an extent of 4096.\n\n```python\n  import mapbox_vector_tile\n  from pyproj import transformer\n  from shapely.geometry import linestring\n\n  srid_lnglat = 4326\n  srid_spherical_mercator = 3857\n  direct_transformer = transformer.from_crs(crs_from=srid_lnglat, crs_to=srid_spherical_mercator, always_xy=true)\n\n  lnglat_line = linestring(((-122.1, 45.1), (-122.2, 45.2)))\n\n  # encode the tile\n  tile_pbf = mapbox_vector_tile.encode({\n    \"name\": \"my-layer\",\n    \"features\": [{\n      \"geometry\": lnglat_line.wkt,\n      \"properties\": {\"stuff\": \"things\"},\n    }]\n  },\n    default_options={\"transformer\": direct_transformer.transform})\n\n  # decode the tile\n  reverse_transformer = transformer.from_crs(crs_from=srid_spherical_mercator, crs_to=srid_lnglat, always_xy=true)\n  mapbox_vector_tile.decode(tile=tile_pbf, default_options={\"transformer\": reverse_transformer.transform})\n\n  {\n      \"my-layer\": {\n          \"extent\": 4096,\n          \"version\": 1,\n          \"features\": [\n              {\n                  \"geometry\": {\n                      \"type\": \"linestring\",\n                      \"coordinates\": [\n                          [-122.10000156433787, 45.09999871982179],\n                          [-122.20000202176608, 45.20000292038091]\n                      ]\n                  },\n                  \"properties\": {\n                      \"stuff\": \"things\"\n                  },\n                  \"id\": 0,\n                  \"type\": \"feature\"\n              }\n          ],\n          \"type\": \"featurecollection\"\n      }\n  }\n```\n\n### quantization\n\nthe encoder also has options to quantize the data for you via the `quantize_bounds` option. when encoding, pass in the bounds in the form (minx, miny, maxx, maxy) and the coordinates will be scaled appropriately during encoding.\n\n```python\nmapbox_vector_tile.encode([\n      {\n        \"name\": \"water\",\n        \"features\": [\n          {\n            \"geometry\":\"point(15 15)\",\n            \"properties\":{\n              \"foo\":\"bar\",\n            }\n          }\n        ]\n      }\n    ], default_options={\"quantize_bounds\": (10.0, 10.0, 20.0, 20.0)})\n```\n\nin this example, the coordinate that would get encoded would be (2048, 2048)\n\nadditionally, if the data is already in a coordinate system with y values going down, the encoder supports an\noption, `y_coord_down`, that can be set to true. this will suppress flipping the y coordinate values during encoding.\n\n### custom extents\n\nthe encoder also supports passing in custom extents. these will be passed through to the layer in the pbf, and honored during any quantization or y coordinate flipping.\n\n```python\nmapbox_vector_tile.encode([\n      {\n        \"name\": \"water\",\n        \"features\": [\n          {\n            \"geometry\":\"point(15 15)\",\n            \"properties\":{\n              \"foo\":\"bar\",\n            }\n          }\n        ]\n      }\n    ], default_options={\"quantize_bounds\": (0.0, 0.0, 10.0, 10.0), \"extents\":50})\n```\n\ndecoding\n--------\n\ndecode method takes in a valid google.protobuf.message tile and returns decoded string in the following format:\n\n```python\n  {\n    layername: {\n        'extent': 'integer layer extent'\n        'version': 'integer'\n        'features': [{\n          'geometry': 'list of points',\n          'properties': 'dictionary of key/value pairs',\n          'id': 'unique id for the given feature within the layer '\n          }, ...\n        ]\n    },\n    layername2: {\n      # ...\n    }\n  }\n```\n\nthe decoding operation accepts options which can be defined per layer using the `per_layer_options` argument. if\nthere is missing layer or missing options values in the `per_layer_options`, the options of `default_options` are\ntaken into account. finally, global default values are used. see the docstring of the `decode` method for more\ndetails about the available options and their global default values.\n\n```python\n  >>> import mapbox_vector_tile\n\n  >>> mapbox_vector_tile.decode(b'\\x1aj\\n\\x05water\\x12\\x1a\\x08\\x01\\x12\\x06\\x00\\x00\\x01\\x01\\x02\\x02\\x18\\x03\"\\x0c\\t\\x00\\x80@\\x1a\\x00\\x01\\x02\\x00\\x00\\x02\\x0f\\x1a\\x03foo\\x1a\\x03uid\\x1a\\x03cat\"\\x05\\n\\x03bar\"\\x02 {\"\\x06\\n\\x04flew(\\x80 x\\x02\\x1ay\\n\\x03air\\x12\\x1c\\x08\\x01\\x12\\x08\\x00\\x00\\x01\\x01\\x02\\x02\\x03\\x03\\x18\\x03\"\\x0c\\t\\x00\\x80@\\x1a\\x00\\x01\\x02\\x00\\x00\\x02\\x0f\\x1a\\x03foo\\x1a\\x03uid\\x1a\\x05balls\\x1a\\x03cat\"\\x05\\n\\x03bar\"\\x03 \\xd2\\t\"\\x05\\n\\x03foo\"\\x06\\n\\x04flew(\\x80 x\\x02')\n\n  {\n      \"water\": {\n          \"extent\": 4096,\n          \"version\": 2,\n          \"features\": [\n              {\n                  \"geometry\": {\n                      \"type\": \"polygon\",\n                      \"coordinates\": [[[0,0],[0,1],[1,1],[1,0],[0,0]]]\n                  },\n                  \"properties\": {\n                      \"foo\": \"bar\",\n                      \"uid\": 123,\n                      \"cat\": \"flew\"\n                  },\n                  \"id\": 1,\n                  \"type\": \"feature\"\n              }\n          ],\n          \"type\": \"featurecollection\"\n      },\n      \"air\": {\n          \"extent\": 4096,\n          \"version\": 2,\n          \"features\": [\n              {\n                  \"geometry\": {\n                      \"type\": \"polygon\",\n                      \"coordinates\": [[[0,0],[0,1],[1,1],[1,0],[0,0]]]\n                  },\n                  \"properties\": {\n                      \"foo\": \"bar\",\n                      \"uid\": 1234,\n                      \"balls\": \"foo\",\n                      \"cat\": \"flew\"\n                  },\n                  \"id\": 1,\n                  \"type\": \"feature\"\n              }\n          ],\n          \"type\": \"featurecollection\"\n      }\n  }\n\n```\n\nhere's how you might decode a tile from a file.\n\n```python\n  >>> import mapbox_vector_tile\n  >>> with open('tile.mvt', 'rb') as f:\n  >>>     data = f.read()\n  >>> decoded_data = mapbox_vector_tile.decode(data)\n  >>> with open('out.txt', 'w') as f:\n  >>>     f.write(repr(decoded_data))\n```\n\nthe `decode` function has a `geojson` option which enforces a geojson rfc7946 compatible result. its default value\nis `true`. to enforce the behaviour of versions <2.0.0, please use `geojson=false`.\n\n\nuse native protobuf library for performance\n------------------------------------------\n\nthe c++ implementation of the underlying protobuf library is more performant than the pure python one. depending on your operating system, you might need to [compile the c++ library](https://github.com/google/protobuf/tree/master/python#c-implementation) or install it.\n\nsince may 6, 2022, the python `profobuf` library is based on the udp library and thus, the generated python code\nrequires `protoc` 3.19.0 or newer. cf. [here](https://developers.google.com/protocol-buffers/docs/news/2022-05-06). on\ndebian bullseye, the version of `protoc` available in the package registry is too old. please install it from [protobuf\n+github repository](https://github.com/protocolbuffers/protobuf/releases).\n\nto compile the `proto` file, you have to enable two environnement variables before running your python program :\n\n    $  sudo apt-get install libprotoc9 libprotobuf9 protobuf-compiler python-protobuf\n\nthen, you'll have to enable two environnement variable before runing your python program :\n\n     $ export protocol_buffers_python_implementation=cpp\n     $ export protocol_buffers_python_implementation_version=2\n\nand then:\n\n    $ protoc -i=mapbox_vector_tile/mapbox/ --python_out=mapbox_vector_tile/mapbox/ mapbox_vector_tile/mapbox/vector_tile.proto\n\nchangelog\n---------\n\nclick [here](https://github.com/tilezen/mapbox-vector-tile/blob/master/changelog.md) to see what changed over time in various versions.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "mapbox-vector-tile",
  "package_url": "https://pypi.org/project/mapbox-vector-tile/",
  "project_url": "https://pypi.org/project/mapbox-vector-tile/",
  "project_urls": {
    "Homepage": "https://github.com/tilezen/mapbox-vector-tile",
    "Repository": "https://github.com/tilezen/mapbox-vector-tile"
  },
  "release_url": "https://pypi.org/project/mapbox-vector-tile/2.0.1/",
  "requires_dist": [
    "protobuf (>=4.21,<5.0)",
    "shapely (>=2.0.0,<3.0.0)",
    "pyclipper (>=1.3.0,<2.0.0)",
    "pyproj (>=3.4.1,<4.0.0) ; extra == \"proj\""
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "mapbox vector tile encoding and decoding.",
  "version": "2.0.1",
  "releases": [],
  "developers": [
    "rob@marianski.com",
    "rob_marianski"
  ],
  "kwds": "mapbox_vector_tile vector_tile tile_pbf mapbox tilezen",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_mapbox_vector_tile",
  "homepage": "https://github.com/tilezen/mapbox-vector-tile",
  "release_count": 23,
  "dependency_ids": [
    "pypi_protobuf",
    "pypi_pyclipper",
    "pypi_pyproj",
    "pypi_shapely"
  ]
}