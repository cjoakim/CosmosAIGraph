{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# pathy: a path interface for local and cloud bucket storage\n\n[![build](https://github.com/justindujardin/pathy/actions/workflows/python-package.yml/badge.svg)](https://github.com/justindujardin/pathy/actions/workflows/python-package.yml)\n[![codecov](https://codecov.io/gh/justindujardin/pathy/branch/master/graph/badge.svg)](https://codecov.io/gh/justindujardin/pathy)\n[![pypi version](https://badgen.net/pypi/v/pathy)](https://pypi.org/project/pathy/)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\npathy is a python package (_with type annotations_) for working with cloud bucket storage providers using a pathlib interface. it provides an easy-to-use api bundled with a cli app for basic file operations between local files and remote buckets. it enables a smooth developer experience by letting developers work against the local file system during development and only switch over to live apis for deployment. it also makes converting bucket blobs into local files a snap with optional local file caching.\n\n## \ud83d\ude80 quickstart\n\nyou can install `pathy` from pip:\n\n```bash\npip install pathy\n```\n\nthe package exports the `pathy` class and utilities for configuring the bucket storage provider to use.\n\n```python\nfrom pathy import pathy, use_fs\n# use the local file-system for quicker development\nuse_fs()\n# create a bucket\npathy(\"gs://my_bucket\").mkdir(exist_ok=true)\n# an excellent blob\ngreeting = pathy(f\"gs://my_bucket/greeting.txt\")\n# but it doesn't exist yet\nassert not greeting.exists()\n# create it by writing some text\ngreeting.write_text(\"hello world!\")\n# now it exists\nassert greeting.exists()\n# delete it\ngreeting.unlink()\n# now it doesn't\nassert not greeting.exists()\n```\n\n## supported clouds\n\nthe table below details the supported cloud provider apis.\n\n| cloud service        | support |       install extras       |\n| :------------------- | :-----: | :------------------------: |\n| google cloud storage |   \u2705    |  `pip install pathy[gcs]`  |\n| amazon s3            |   \u2705    |  `pip install pathy[s3]`   |\n| azure                |   \u2705    | `pip install pathy[azure]` |\n\n### google cloud storage\n\ngoogle recommends using a json credentials file, which you can specify by path:\n\n```python\nfrom google.oauth2 import service_account\nfrom pathy import set_client_params\n\ncredentials = service_account.credentials.from_service_account_file(\"./my-creds.json\")\nset_client_params(\"gs\", credentials=credentials)\n```\n\n### amazon s3\n\ns3 uses a json credentials file, which you can specify by path:\n\n```python\nfrom pathy import set_client_params\n\nset_client_params(\"s3\", key_id=\"your_access_key_id\", key_secret=\"your_access_secret\")\n```\n\n### azure\n\nazure blob storage can be passed a `connection_string`:\n\n```python\nfrom pathy import set_client_params\n\nset_client_params(\"azure\", connection_string=\"your_connection_string\")\n```\n\nor a `blobserviceclient` instance:\n\n```python\nfrom azure.storage.blob import blobserviceclient\nfrom pathy import set_client_params\n\nservice: blobserviceclient = blobserviceclient.from_connection_string(\n    \"your_connection_string\"\n)\nset_client_params(\"azure\", service=service)\n```\n\n## semantic versioning\n\nbefore pathy reaches v1.0 the project is not guaranteed to have a consistent api, which means that types and classes may move around or be removed. that said, we try to be predictable when it comes to breaking changes, so the project uses semantic versioning to help users avoid breakage.\n\nspecifically, new releases increase the `patch` semver component for new features and fixes, and the `minor` component when there are breaking changes. if you don't know much about semver strings, they're usually formatted `{major}.{minor}.{patch}` so increasing the `patch` component means incrementing the last number.\n\nconsider a few examples:\n\n| from version | to version | changes are breaking |\n| :----------: | :--------: | :------------------: |\n|    0.2.0     |   0.2.1    |          no          |\n|    0.3.2     |   0.3.6    |          no          |\n|    0.3.1     |   0.3.17   |          no          |\n|    0.2.2     |   0.3.0    |         yes          |\n\nif you are concerned about breaking changes, you can pin the version in your requirements so that it does not go beyond the current semver `minor` component, for example if the current version was `0.1.37`:\n\n```\npathy>=0.1.37,<0.2.0\n```\n\n## \ud83c\udf9b api\n\n<!-- note: the below code is auto-generated. update source files to change api documentation. -->\n<!-- auto_docz_start -->\n\n# pathy <kbd>class</kbd>\n\n```python (doc)\npathy(self, args, kwargs)\n```\n\nsubclass of `pathlib.path` that works with bucket apis.\n\n## exists <kbd>method</kbd>\n\n```python (doc)\npathy.exists(self) -> bool\n```\n\nreturns true if the path points to an existing bucket, blob, or prefix.\n\n## fluid <kbd>classmethod</kbd>\n\n```python (doc)\npathy.fluid(\n    path_candidate: union[str, pathy, basepath],\n) -> union[pathy, basepath]\n```\n\ninfer either a pathy or pathlib.path from an input path or string.\n\nthe returned type is a union of the potential `fluidpath` types and will\ntype-check correctly against the minimum overlapping apis of all the input\ntypes.\n\nif you need to use specific implementation details of a type, \"narrow\" the\nreturn of this function to the desired type, e.g.\n\n```python\nfrom pathy import fluidpath, pathy\n\nfluid_path: fluidpath = pathy.fluid(\"gs://my_bucket/foo.txt\")\n# narrow the type to a specific class\nassert isinstance(fluid_path, pathy), \"must be pathy\"\n# use a member specific to that class\nassert fluid_path.prefix == \"foo.txt/\"\n```\n\n## from_bucket <kbd>classmethod</kbd>\n\n```python (doc)\npathy.from_bucket(bucket_name: str, scheme: str = 'gs') -> 'pathy'\n```\n\ninitialize a pathy from a bucket name. this helper adds a trailing slash and\nthe appropriate prefix.\n\n```python\nfrom pathy import pathy\n\nassert str(pathy.from_bucket(\"one\")) == \"gs://one/\"\nassert str(pathy.from_bucket(\"two\")) == \"gs://two/\"\n```\n\n## glob <kbd>method</kbd>\n\n```python (doc)\npathy.glob(\n    self: 'pathy',\n    pattern: str,\n) -> generator[pathy, nonetype, nonetype]\n```\n\nperform a glob match relative to this pathy instance, yielding all matched\nblobs.\n\n## is_dir <kbd>method</kbd>\n\n```python (doc)\npathy.is_dir(self: 'pathy') -> bool\n```\n\ndetermine if the path points to a bucket or a prefix of a given blob\nin the bucket.\n\nreturns true if the path points to a bucket or a blob prefix.\nreturns false if it points to a blob or the path doesn't exist.\n\n## is_file <kbd>method</kbd>\n\n```python (doc)\npathy.is_file(self: 'pathy') -> bool\n```\n\ndetermine if the path points to a blob in the bucket.\n\nreturns true if the path points to a blob.\nreturns false if it points to a bucket or blob prefix, or if the path doesn\u2019t\nexist.\n\n## iterdir <kbd>method</kbd>\n\n```python (doc)\npathy.iterdir(\n    self: 'pathy',\n) -> generator[pathy, nonetype, nonetype]\n```\n\niterate over the blobs found in the given bucket or blob prefix path.\n\n## ls <kbd>method</kbd>\n\n```python (doc)\npathy.ls(self: 'pathy') -> generator[blobstat, nonetype, nonetype]\n```\n\nlist blob names with stat information under the given path.\n\nthis is considerably faster than using iterdir if you also need\nthe stat information for the enumerated blobs.\n\nyields blobstat objects for each found blob.\n\n## mkdir <kbd>method</kbd>\n\n```python (doc)\npathy.mkdir(\n    self,\n    mode: int = 511,\n    parents: bool = false,\n    exist_ok: bool = false,\n) -> none\n```\n\ncreate a bucket from the given path. since bucket apis only have implicit\nfolder structures (determined by the existence of a blob with an overlapping\nprefix) this does nothing other than create buckets.\n\nif parents is false, the bucket will only be created if the path points to\nexactly the bucket and nothing else. if parents is true the bucket will be\ncreated even if the path points to a specific blob.\n\nthe mode param is ignored.\n\nraises fileexistserror if exist_ok is false and the bucket already exists.\n\n## open <kbd>method</kbd>\n\n```python (doc)\npathy.open(\n    self: 'pathy',\n    mode: str = 'r',\n    buffering: int = 8192,\n    encoding: optional[str] = none,\n    errors: optional[str] = none,\n    newline: optional[str] = none,\n) -> io[any]\n```\n\nopen the given blob for streaming. this delegates to the `smart_open`\nlibrary that handles large file streaming for a number of bucket api\nproviders.\n\n## owner <kbd>method</kbd>\n\n```python (doc)\npathy.owner(self: 'pathy') -> optional[str]\n```\n\nreturns the name of the user that owns the bucket or blob\nthis path points to. returns none if the owner is unknown or\nnot supported by the bucket api provider.\n\n## rename <kbd>method</kbd>\n\n```python (doc)\npathy.rename(self: 'pathy', target: union[str, pathlib.purepath]) -> 'pathy'\n```\n\nrename this path to the given target.\n\nif the target exists and is a file, it will be replaced silently if the user\nhas permission.\n\nif path is a blob prefix, it will replace all the blobs with the same prefix\nto match the target prefix.\n\n## replace <kbd>method</kbd>\n\n```python (doc)\npathy.replace(self: 'pathy', target: union[str, pathlib.purepath]) -> 'pathy'\n```\n\nrenames this path to the given target.\n\nif target points to an existing path, it will be replaced.\n\n## resolve <kbd>method</kbd>\n\n```python (doc)\npathy.resolve(self, strict: bool = false) -> 'pathy'\n```\n\nresolve the given path to remove any relative path specifiers.\n\n```python\nfrom pathy import pathy\n\npath = pathy(\"gs://my_bucket/folder/../blob\")\nassert path.resolve() == pathy(\"gs://my_bucket/blob\")\n```\n\n## rglob <kbd>method</kbd>\n\n```python (doc)\npathy.rglob(\n    self: 'pathy',\n    pattern: str,\n) -> generator[pathy, nonetype, nonetype]\n```\n\nperform a recursive glob match relative to this pathy instance, yielding\nall matched blobs. imagine adding \"\\*\\*/\" before a call to glob.\n\n## rmdir <kbd>method</kbd>\n\n```python (doc)\npathy.rmdir(self: 'pathy') -> none\n```\n\nremoves this bucket or blob prefix. it must be empty.\n\n## samefile <kbd>method</kbd>\n\n```python (doc)\npathy.samefile(\n    self: 'pathy',\n    other_path: union[str, bytes, int, pathlib.path],\n) -> bool\n```\n\ndetermine if this path points to the same location as other_path.\n\n## stat <kbd>method</kbd>\n\n```python (doc)\npathy.stat(self: 'pathy') -> pathy.blobstat\n```\n\nreturns information about this bucket path.\n\n## to_local <kbd>classmethod</kbd>\n\n```python (doc)\npathy.to_local(\n    blob_path: union[pathy, str],\n    recurse: bool = true,\n) -> pathlib.path\n```\n\ndownload and cache either a blob or a set of blobs matching a prefix.\n\nthe cache is sensitive to the file updated time, and downloads new blobs\nas their updated timestamps change.\n\n## touch <kbd>method</kbd>\n\n```python (doc)\npathy.touch(self: 'pathy', mode: int = 438, exist_ok: bool = true) -> none\n```\n\ncreate a blob at this path.\n\nif the blob already exists, the function succeeds if exist_ok is true\n(and its modification time is updated to the current time), otherwise\nfileexistserror is raised.\n\n# blobstat <kbd>dataclass</kbd>\n\n```python (doc)\nblobstat(\n    self,\n    name: str,\n    size: optional[int],\n    last_modified: optional[int],\n) -> none\n```\n\nstat for a bucket item\n\n# use_fs <kbd>function</kbd>\n\n```python (doc)\nuse_fs(\n    root: optional[str, pathlib.path, bool] = none,\n) -> optional[pathy.bucketclientfs]\n```\n\nuse a path in the local file-system to store blobs and buckets.\n\nthis is useful for development and testing situations, and for embedded\napplications.\n\n# get_fs_client <kbd>function</kbd>\n\n```python (doc)\nget_fs_client() -> optional[pathy.bucketclientfs]\n```\n\nget the file-system client (or none)\n\n# use_fs_cache <kbd>function</kbd>\n\n```python (doc)\nuse_fs_cache(\n    root: optional[str, pathlib.path, bool] = none,\n) -> optional[pathlib.path]\n```\n\nuse a path in the local file-system to cache blobs and buckets.\n\nthis is useful for when you want to avoid fetching large blobs multiple\ntimes, or need to pass a local file path to a third-party library.\n\n# get_fs_cache <kbd>function</kbd>\n\n```python (doc)\nget_fs_cache() -> optional[pathlib.path]\n```\n\nget the folder that holds file-system cached blobs and timestamps.\n\n# set_client_params <kbd>function</kbd>\n\n```python (doc)\nset_client_params(scheme: str, kwargs: any) -> none\n```\n\nspecify args to pass when instantiating a service-specific client\nobject. this allows for passing credentials in whatever way your underlying\nclient library prefers.\n\n# cli\n\npathy command line interface. (v0.5.2)\n\n**usage**:\n\n```console\n$ [options] command [args]...\n```\n\n**options**:\n\n- `--install-completion`: install completion for the current shell.\n- `--show-completion`: show completion for the current shell, to copy it or customize the installation.\n- `--help`: show this message and exit.\n\n**commands**:\n\n- `cp`: copy a blob or folder of blobs from one...\n- `ls`: list the blobs that exist at a given...\n- `mv`: move a blob or folder of blobs from one path...\n- `rm`: remove a blob or folder of blobs from a given...\n\n## `cp`\n\ncopy a blob or folder of blobs from one bucket to another.\n\n**usage**:\n\n```console\n$ cp [options] from_location to_location\n```\n\n**arguments**:\n\n- `from_location`: [required]\n- `to_location`: [required]\n\n**options**:\n\n- `--help`: show this message and exit.\n\n## `ls`\n\nlist the blobs that exist at a given location.\n\n**usage**:\n\n```console\n$ ls [options] location\n```\n\n**arguments**:\n\n- `location`: [required]\n\n**options**:\n\n- `-l, --long`: print long style entries with updated time and size shown. [default: false]\n- `--help`: show this message and exit.\n\n## `mv`\n\nmove a blob or folder of blobs from one path to another.\n\n**usage**:\n\n```console\n$ mv [options] from_location to_location\n```\n\n**arguments**:\n\n- `from_location`: [required]\n- `to_location`: [required]\n\n**options**:\n\n- `--help`: show this message and exit.\n\n## `rm`\n\nremove a blob or folder of blobs from a given location.\n\n**usage**:\n\n```console\n$ rm [options] location\n```\n\n**arguments**:\n\n- `location`: [required]\n\n**options**:\n\n- `-r, --recursive`: recursively remove files and folders. [default: false]\n- `-v, --verbose`: print removed files and folders. [default: false]\n- `--help`: show this message and exit.\n\n<!-- auto_docz_end -->\n\n# credits\n\npathy is originally based on the [s3path](https://github.com/liormizr/s3path) project, which provides a path interface for s3 buckets.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "pathy",
  "package_url": "https://pypi.org/project/pathy/",
  "project_url": "https://pypi.org/project/pathy/",
  "project_urls": {
    "Homepage": "https://github.com/justindujardin/pathy"
  },
  "release_url": "https://pypi.org/project/pathy/0.10.3/",
  "requires_dist": [
    "smart-open <7.0.0,>=5.2.1",
    "typer <1.0.0,>=0.3.0",
    "dataclasses <1.0,>=0.6 ; python_version < \"3.7\"",
    "google-cloud-storage <2.0.0,>=1.26.0 ; extra == 'all'",
    "boto3 ; extra == 'all'",
    "azure-storage-blob ; extra == 'all'",
    "pytest ; extra == 'all'",
    "pytest-coverage ; extra == 'all'",
    "mock ; extra == 'all'",
    "typer-cli ; extra == 'all'",
    "azure-storage-blob ; extra == 'azure'",
    "google-cloud-storage <2.0.0,>=1.26.0 ; extra == 'gcs'",
    "boto3 ; extra == 's3'",
    "pytest ; extra == 'test'",
    "pytest-coverage ; extra == 'test'",
    "mock ; extra == 'test'",
    "typer-cli ; extra == 'test'"
  ],
  "requires_python": ">= 3.6",
  "summary": "pathlib.path subclasses for local and cloud bucket storage",
  "version": "0.10.3",
  "releases": [],
  "developers": [
    "justin@dujardinconsulting.com",
    "justin_dujardin"
  ],
  "kwds": "pathlib bucketclientfs other_path pathy path",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_pathy",
  "homepage": "https://github.com/justindujardin/pathy",
  "release_count": 29,
  "dependency_ids": [
    "pypi_azure_storage_blob",
    "pypi_boto3",
    "pypi_dataclasses",
    "pypi_google_cloud_storage",
    "pypi_mock",
    "pypi_pytest",
    "pypi_pytest_coverage",
    "pypi_smart_open",
    "pypi_typer",
    "pypi_typer_cli"
  ]
}