{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mozilla public license 2.0 (mpl 2.0)",
    "programming language :: c++",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries"
  ],
  "description": "ufal.udpipe\n============\n\nthe ``ufal.udpipe`` is a python binding to udpipe library <http://ufal.mff.cuni.cz/udpipe>.\n\nthe bindings is a straightforward conversion of the ``c++`` bindings api.\nin python 2, strings can be both ``unicode`` and utf-8 encoded ``str``, and the\nlibrary always produces ``unicode``. in python 3, strings must be only ``str``.\n\n\nwrapped c++ api\n---------------\n\nthe c++ api being wrapped follows. for a api reference of the original\nc++ api, see <http://ufal.mff.cuni.cz/udpipe/api-reference>.\n\n::\n\n  helper structures\n  -----------------\n  \n    typedef vector<int> children;\n  \n    typedef vector<uint8_t> bytes;\n  \n    typedef vector<string> comments;\n  \n    class processingerror {\n    public:\n      bool occurred();\n      string message;\n    };\n  \n    class token {\n     public:\n      string form;\n      string misc;\n  \n      token(const string& form = string(), const string& misc = string());\n  \n      // conll-u defined spaceafter=no feature\n      bool getspaceafter() const;\n      void setspaceafter(bool space_after);\n  \n      // udpipe-specific all-spaces-preserving spacesbefore and spacesafter features\n      string getspacesbefore() const;\n      void setspacesbefore(const string& spaces_before);\n      string getspacesafter() const;\n      void setspacesafter(const string& spaces_after);\n      string getspacesintoken() const;\n      void setspacesintoken(const string& spaces_in_token);\n  \n      // udpipe-specific tokenrange feature\n      bool gettokenrange() const;\n      size_t gettokenrangestart() const;\n      size_t gettokenrangeend() const;\n      void settokenrange(size_t start, size_t end);\n    };\n  \n    class word : public token {\n     public:\n      // form and misc are inherited from token\n      int id;         // 0 is root, >0 is sentence word, <0 is undefined\n      string lemma;   // lemma\n      string upostag; // universal part-of-speech tag\n      string xpostag; // language-specific part-of-speech tag\n      string feats;   // list of morphological features\n      int head;       // head, 0 is root, <0 is undefined\n      string deprel;  // dependency relation to the head\n      string deps;    // secondary dependencies\n  \n      children children;\n  \n      word(int id = -1, const string& form = string());\n    };\n    typedef vector<word> words;\n  \n    class multiwordtoken : public token {\n     public:\n      // form and misc are inherited from token\n      int idfirst, idlast;\n  \n      multiwordtoken(int id_first = -1, int id_last = -1, const string& form = string(), const string& misc = string());\n    };\n    typedef vector<multiwordtoken> multiwordtokens;\n  \n    class emptynode {\n     public:\n      int id;          // 0 is root, >0 is sentence word, <0 is undefined\n      int index;       // index for the current id, should be numbered from 1, 0=undefined\n      string form;     // form\n      string lemma;    // lemma\n      string upostag;  // universal part-of-speech tag\n      string xpostag;  // language-specific part-of-speech tag\n      string feats;    // list of morphological features\n      string deps;     // secondary dependencies\n      string misc;     // miscellaneous information\n  \n      emptynode(int id = -1, int index = 0) : id(id), index(index) {}\n    };\n    typedef vector<empty_node> emptynodes;\n  \n    class sentence {\n     public:\n      sentence();\n  \n      words words;\n      multiwordtokens multiwordtokens;\n      emptynodes emptynodes;\n      comments comments;\n      static const string rootform;\n  \n      // basic sentence modifications\n      bool empty();\n      void clear();\n      virtual word& addword(const char* form);\n      void sethead(int id, int head, const string& deprel);\n      void unlinkallwords();\n  \n      // conll-u defined comments\n      bool getnewdoc() const;\n      string getnewdocid() const;\n      void setnewdoc(bool new_doc, const string& id = string());\n      bool getnewpar() const;\n      string getnewparid() const;\n      void setnewpar(bool new_par, const string& id = string());\n  \n      string getsentid() const;\n      void setsentid(const string& id);\n      string gettext() const;\n      void settext(const string& id);\n    };\n    typedef vector<sentence> sentences;\n  \n  \n  main classes\n  ------------\n  \n    class inputformat {\n     public:\n      virtual void resetdocument(const string& id = string());\n      virtual void settext(const char* text);\n      virtual bool nextsentence(sentence& s, processingerror* error = nullptr);\n  \n      static inputformat* newinputformat(const string& name);\n      static inputformat* newconlluinputformat(const string& id = string());\n      static inputformat* newgenerictokenizerinputformat(const string& id = string());\n      static inputformat* newhorizontalinputformat(const string& id = string());\n      static inputformat* newverticalinputformat(const string& id = string());\n  \n      static inputformat* newpresegmentedtokenizer(inputformat tokenizer);\n  \n      static const string conllu_v1;\n      static const string conllu_v2;\n      static const string generic_tokenizer_normalized_spaces;\n      static const string generic_tokenizer_presegmented;\n      static const string generic_tokenizer_ranges;\n    };\n  \n    class outputformat {\n     public:\n      virtual string writesentence(const sentence& s);\n      virtual string finishdocument();\n  \n      static outputformat* newoutputformat(const string& name);\n      static outputformat* newconlluoutputformat(const string& options = string());\n      static outputformat* newepeoutputformat(const string& options = string());\n      static outputformat* newmatxinoutputformat(const string& options = string());\n      static outputformat* newhorizontaloutputformat(const string& options = string());\n      static outputformat* newplaintextoutputformat(const string& options = string());\n      static outputformat* newverticaloutputformat(const string& options = string());\n  \n      static const string conllu_v1;\n      static const string conllu_v2;\n      static const string horizontal_paragraphs;\n      static const string plaintext_normalized_spaces;\n      static const string vertical_paragraphs;\n    };\n  \n    class model {\n     public:\n      static model* load(const char* fname);\n  \n      virtual inputformat* newtokenizer(const string& options) const;\n      virtual bool tag(sentence& s, const string& options, processingerror* error = nullptr) const;\n      virtual bool parse(sentence& s, const string& options, processingerror* error) const;\n  \n      static const string default;\n      static const string tokenizer_presegmented;\n    };\n  \n    class pipeline {\n     public:\n      pipeline(const model* m, const string& input, const string& tagger, const string& parser, const string& output);\n  \n      void setmodel(const model* m);\n      void setinput(const string& input);\n      void settagger(const string& tagger);\n      void setparser(const string& parser);\n      void setoutput(const string& output);\n  \n      void setimmediate(bool immediate);\n      void setdocumentid(const string& document_id);\n  \n      string process(const string& data, processingerror* error = nullptr) const;\n  \n      static const string default;\n      static const string none;\n    };\n  \n    class trainer {\n     public:\n  \n      static bytes* train(const string& method, const sentences& train, const sentences& heldout,\n                          const string& tokenizer, const string& tagger, const string& parser,\n                          processingerror* error = nullptr);\n  \n      static const string default;\n      static const string none;\n    };\n  \n    class evaluator {\n     public:\n      evaluator(const model* m, const string& tokenizer, const string& tagger, const string& parser);\n  \n      void setmodel(const model* m);\n      void settokenizer(const string& tokenizer);\n      void settagger(const string& tagger);\n      void setparser(const string& parser);\n  \n      string evaluate(const string& data, processingerror* error = nullptr) const;\n  \n      static const string default;\n      static const string none;\n    };\n  \n    class version {\n     public:\n      unsigned major;\n      unsigned minor;\n      unsigned patch;\n      string prerelease;\n  \n      // returns current version.\n      static version current();\n    };\n\n\nexamples\n========\n\nrun_udpipe\n--------------\n\nsimple pipeline loading data (tokenizing on request), tagging, parsing and\nwriting to specified output format::\n\n\n  import sys\n  \n  from ufal.udpipe import model, pipeline, processingerror # pylint: disable=no-name-in-module\n  \n  # in python2, wrap sys.stdin and sys.stdout to work with unicode.\n  if sys.version_info[0] < 3:\n      import codecs\n      import locale\n      encoding = locale.getpreferredencoding()\n      sys.stdin = codecs.getreader(encoding)(sys.stdin)\n      sys.stdout = codecs.getwriter(encoding)(sys.stdout)\n  \n  if len(sys.argv) < 4:\n      sys.stderr.write('usage: %s input_format(tokenize|conllu|horizontal|vertical) output_format(conllu) model_file\\n' % sys.argv[0])\n      sys.exit(1)\n  \n  sys.stderr.write('loading model: ')\n  model = model.load(sys.argv[3])\n  if not model:\n      sys.stderr.write(\"cannot load model from file '%s'\\n\" % sys.argv[3])\n      sys.exit(1)\n  sys.stderr.write('done\\n')\n  \n  pipeline = pipeline(model, sys.argv[1], pipeline.default, pipeline.default, sys.argv[2])\n  error = processingerror()\n  \n  # read whole input\n  text = ''.join(sys.stdin.readlines())\n  \n  # process data\n  processed = pipeline.process(text, error)\n  if error.occurred():\n      sys.stderr.write(\"an error occurred when running run_udpipe: \")\n      sys.stderr.write(error.message)\n      sys.stderr.write(\"\\n\")\n      sys.exit(1)\n  sys.stdout.write(processed)\n\n\nauthors\n=======\n\nmilan straka <straka@ufal.mff.cuni.cz>\n\n\ncopyright and licence\n=====================\n\ncopyright 2016 institute of formal and applied linguistics, faculty of\nmathematics and physics, charles university in prague, czech republic.\n\nthis source code form is subject to the terms of the mozilla public\nlicense, v. 2.0. if a copy of the mpl was not distributed with this\nfile, you can obtain one at http://mozilla.org/mpl/2.0/.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mpl 2.0",
  "name": "ufal.udpipe",
  "package_url": "https://pypi.org/project/ufal.udpipe/",
  "project_url": "https://pypi.org/project/ufal.udpipe/",
  "project_urls": {
    "Homepage": "https://ufal.mff.cuni.cz/udpipe"
  },
  "release_url": "https://pypi.org/project/ufal.udpipe/1.3.1.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "bindings to udpipe library",
  "version": "1.3.1.1",
  "releases": [],
  "developers": [
    "milan_straka",
    "straka@ufal.mff.cuni.cz"
  ],
  "kwds": "unicode run_udpipe udpipe encoding python2",
  "license_kwds": "mpl 2.0",
  "libtype": "pypi",
  "id": "pypi_ufal.udpipe",
  "homepage": "https://ufal.mff.cuni.cz/udpipe",
  "release_count": 8,
  "dependency_ids": []
}