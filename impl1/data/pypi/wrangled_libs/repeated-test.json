{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing"
  ],
  "description": ".. |ut| replace:: unittest\n.. _ut: http://docs.python.org/3/library/unittest.html\n\n.. |tc| replace:: unittest.testcase\n.. _tc: http://docs.python.org/3/library/unittest.html#unittest.testcase\n\n.. |subtests| replace:: subtests\n.. _subtests: https://docs.python.org/3/library/unittest.html#subtests\n\n.. |pyt| replace:: pytest\n.. _pyt: https://docs.pytest.org/en/stable/contents.html\n\n.. |pytest-subtests| replace:: pytest-subtests\n.. _pytest-subtests: https://pypi.org/project/pytest-subtests/\n\n.. _repeated_test:\n\n*************\nrepeated_test\n*************\n\n.. image:: https://badges.gitter.im/epsy/repeated_test.svg\n   :alt: join the chat at https://gitter.im/epsy/repeated_test\n   :target: https://gitter.im/epsy/repeated_test?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n.. image:: https://github.com/epsy/repeated_test/actions/workflows/ci.yml/badge.svg?branch=master\n    :target: https://github.com/epsy/repeated_test/actions/workflows/ci.yml\n.. image:: https://coveralls.io/repos/github/epsy/repeated_test/badge.svg?branch=master\n    :target: https://coveralls.io/github/epsy/repeated_test?branch=master\n\n``repeated_test`` lets you write tests that apply the same function to\nmany sets of parameters.\n\n\n.. _example:\n\nfor instance:\n\n.. code-block:: python\n\n    from repeated_test import fixtures\n\n    class myfixtures(fixtures):\n        def _test(self, expected, *terms):\n            self.assertequal(expected, sum(terms))\n\n        a = 10, 5, 5\n        b = 15, 7, 8\n        c = 42, 1, 1\n\nthe result is unittest-compatible, and provides useful context in the\ntraceback in case of errors:\n\n.. code-block:: console\n\n    $ python -m unittest my_tests\n    ..f\n    ======================================================================\n    fail: test_c (my_tests.myfixtures)\n    ----------------------------------------------------------------------\n    traceback (most recent call last):\n      file \"my_tests.py\", line 9, in myfixtures\n        c = 42, 1, 1\n      file \"my_tests.py\", line 5, in _test\n        self.assertequal(expected, sum(terms))\n    assertionerror: 42 != 2\n\n    ----------------------------------------------------------------------\n    ran 3 tests in 0.002s\n\n    failed (failures=1)\n\n.. _install:\n\nyou can install it using:\n\n.. code-block:: console\n\n    $ pip install --user repeated_test\n\n\n.. _help:\n\nhelp / issues\n=============\n\nyou can get help in the\n`gitter.im chatroom <https://gitter.im/epsy/repeated_test>`_.\n\nif you find any issues or have any requests, use\n`github issues <https://github.com/epsy/repeated_test/issues>`_.\n\n\n.. _reference:\n\nreference\n=========\n\n.. _intro:\n\nintroduction\n------------\n\npython's |ut|_ modules helps in performing various forms of automated testing.\none writes a class deriving from |tc|_ and adds various ``test_xyz`` methods.\ntest runners run these tests, keeping count of successful and failed tests,\nand produces a trace with the causes of these failures.\n\nsometimes it makes sense to have one test be carried out for a large amount\nof different inputs.\nthis module aims to provide an efficient way to do this.\n\nit allows you to write fixtures (inputs) as plain members of a\nclass, and bind a test function to them. this test function is called for each\nfixture as you will see below. the produced class is a |tc|_ subclass, so it is\ncompatible with |ut|_ and other |ut|-compatible test runners.\n\n\n.. _testcase:\n\nbuilding a test case\n--------------------\n\nin order to produce a |tc|_, ``repeated_test`` requires you to:\n\n* subclass ``repeated_test.fixtures``\n* write a ``_test`` method that takes a few parameters, making use of any\n  |tc|_ method it needs\n* assign fixtures directly in the class body, which are then unpacked as\n  arguments to the ``_test`` method (as in ``_test(*args)``)\n\nyou can use any |tc|_ methods in your test function, such as ``assertequal()``\nand so forth.\n\n.. code-block:: python\n\n    from repeated_test import fixtures\n\n    class myfixtures(fixtures):\n        def _test(self, arg1, arg2, arg3):\n            self.assertequal(..., ...)\n\n        ps = 'p1', 'p2', 'p3'\n        # _test(*ps) will be called, ie. _test('p1', p2', 'p3')\n\n        qs = 'q1', 'q2', 'q3'\n        # _test(*qs) will be called, ie. _test('q1', q2', 'q3')\n\nmake sure that your fixture tuples provide the correct amount of arguments\nfor your ``_test`` method, unless it has an ``*args`` parameter.\n\n\n.. _running:\n\nrunning a test case\n-------------------\n\nyou can run a ``repeated_test`` test case like any other |tc|_ class:\n\n.. code-block:: shell\n\n    python -m unittest\n    python -m unittest my_test_module\n    python -m unittest my_test_module.myfixtures\n\n    # to refer to an individual test, prefix the name of the fixture with \"test_\"\n    python -m unittest my_test_module.myfixtures.test_ps\n\nlearn more in the `official unittest docs <https://docs.python.org/3/library/unittest.html#command-line-interface>`_.\n\nyou can also use a |ut|-compatible test runer, like |pyt|_:\n\n.. code-block:: shell\n\n    python -m pytest\n    python -m pytest my_test_module.py\n    python -m pytest my_test_module.py -k myfixtures\n    python -m pytest my_test_module.py -k test_ps\n    python -m pytest my_test_module.py::myfixtures::test_ps\n\nlearn more in the `official pytest docs <https://docs.pytest.org/en/stable/how-to/usage.html>`_\n\n.. _options:\n\npassing in keyword arguments\n----------------------------\n\nyou can pass in keyword arguments using ``repeated_test.options``:\n\n.. code-block:: python\n\n    import sys\n\n    from repeated_test import fixtures, options\n\n    class myfixtures(fixtures):\n        def _test(self, arg1, arg2, *, min_version=none, max_version=none):\n            ...\n\n        not_using_versions = \"abc\", \"abc\"\n        # -> _test(\"abc\", \"abc\")\n\n        using_max_version = \"abc\", \"abc\", options(max_version=(3, 9))\n        # -> _test(\"abc\", \"abc\", max_version=(3, 9))\n\n        using_both_versions = \"abc\", \"abc\", options(min_version=(3, 8), max_version=(3, 9))\n        # -> _test(\"abc\", \"abc\", min_version=(3, 8), max_version=(3, 9))\n\n        using_both_versions_2 = \"abc\", \"abc\", options(min_version=(3, 8)), options(max_version=(3, 9))\n        # same, but by specifying options separately\n\nthis can be useful if you have multiple options that are only used some of the time.\n\n.. _manage-options:\n\npassing in keyword arguments to multiple tests\n----------------------------------------------\n\nif you are re-using the same keyword arguments across multiple tests,\nthere are several ways to do so:\n\n- using ``@repeated_test.with_options(...)`` lets you\n  specify options for every fixture within a class.\n- using ``with repeated_test.options(...)`` lets you\n  specify options for every fixture within the ``with`` block.\n- you can continue using ``options()`` on individual fixtures,\n  and override values provided by surrounding code.\n- you can use ``repeated_test.skip_option`` to stop supplying any argument.\n  the argument won't be supplied to the function,\n  which is useful for using a default value,\n  or for removing common options from a class whose test function doesn't handle\n\n.. code-block:: python\n\n    from repeated_test import fixtures, options, with_options\n\n    @with_options(kwarg1=\"value from decorator\")\n    class myfixtures(fixtures):\n        def _test(self, arg1, arg2, *, kwarg1, kwarg2=\"default\"):\n            ...\n\n        using_provided_values = \"arg1\", \"arg2\"\n        # -> _test(\"arg1\", \"arg2\", kwarg1=\"value from decorator\", kwarg2=\"default\")\n\n        overriding_provided_values = \"arg1\", \"arg2\", options(kwarg1=\"kwarg1\", kwarg2=\"kwarg2\")\n        # -> _test(\"arg1\", \"arg2\", kwarg1=\"kwarg1\", kwarg2=\"kwarg2\")\n\n        with options(kwarg1=\"value from context manager\"):\n            using_value_from_context_manager = \"arg1\", \"arg2\"\n            # -> _test(\"arg1\", \"arg2\", kwarg1=\"value from context manager\", kwarg2=\"default\")\n\n            overriding_value_from_context_manager = \"arg1\", \"arg2\", options(kwarg1=\"kwarg1\")\n            # -> _test(\"arg1\", \"arg2\", kwarg1=\"kwarg1\", kwarg2=\"default\")\n\n        with options(kwarg2=\"value from context manager\"):\n            removing_value = \"arg1\", \"arg2\"\n            # -> _test(\"arg1\", \"arg2\", kwarg1=\"value from decorator\", kwarg2=\"value from context manager\")\n            removing_value = \"arg1\", \"arg2\", options(kwarg2=skip_option)\n            # -> _test(\"arg1\", \"arg2\", kwarg1=\"value from decorator\", kwarg2=\"default\")\n\n.. _options-matrix:\n\ntesting multiple values for a keyword parameter\n-----------------------------------------------\n\nyou can also use ``@with_options_matrix``\nto provide multiple values for a keyword parameter.\n``repeated_test`` will run every combination\nexcept for parameters that are overridden.\n\n.. code-block:: python\n\n    from repeated_test import fixtures, options, with_options_matrix\n\n\n    @with_options_matrix(\n        spam=[\"spam1\", \"spam2\"],\n        ham=[\"ham1\", \"ham2\"],\n    )\n    class myfixtures(fixtures):\n        def _test(self, arg1, arg2, *, spam, ham):\n            ...\n\n        using_provided_values = \"arg1\", \"arg2\"\n        # -> _test(\"arg1\", \"arg2\", spam=\"spam1\", ham=\"ham1\")\n        # -> _test(\"arg1\", \"arg2\", spam=\"spam1\", ham=\"ham2\")\n        # -> _test(\"arg1\", \"arg2\", spam=\"spam2\", ham=\"ham1\")\n        # -> _test(\"arg1\", \"arg2\", spam=\"spam2\", ham=\"ham2\")\n\n        with options(spam=\"spam\"):\n            overriding_one_value = \"arg1\", \"arg2\"\n            # -> _test(\"arg1\", \"arg2\", spam=\"spam\", ham=\"ham1\")\n            # -> _test(\"arg1\", \"arg2\", spam=\"spam\", ham=\"ham2\")\n\n``repeated_test`` will report each combination using unittest's |subtests|_ feature.\n|pyt| does not have this feature built-in, but the |pytest-subtests|_ plugin adds support.\n\n.. code-block:: console\n\n    ======================================================================\n    fail: test_overriding_one_value (example_options._test) (ham='ham1')\n    ----------------------------------------------------------------------\n    traceback (most recent call last):\n      file \"/home/myself/repeated_test/example_options.py\", line 41, in myfixtures\n        overriding_one_value = \"arg1\", \"arg2\"\n      file \"/home/myself/repeated_test/example_options.py\", line 32, in _test\n        self.fail(\"example failure\")\n    assertionerror: example failure\n\n    ======================================================================\n    fail: test_overriding_one_value (example_options._test) (ham='ham2')\n    ----------------------------------------------------------------------\n    traceback (most recent call last):\n      file \"/home/myself/repeated_test/example_options.py\", line 41, in myfixtures\n        overriding_one_value = \"arg1\", \"arg2\"\n      file \"/home/myself/repeated_test/example_options.py\", line 32, in _test\n        self.fail(\"example failure\")\n    assertionerror: example failure\n\n.. _evaluated:\n\nevaluated test case input\n-------------------------\n\nyou can use ``@evaluated`` to make\na function that can be inserted in a test case tuple.\nwhen running the test,\nthe function will be called,\nand the result will be spliced into the test case tuple:\n\n.. code-block:: python\n\n    from repeated_test import fixtures, evaluated\n\n    class evaluatedfixtures(fixtures):\n        def _test(self, a, b, c):\n            pass\n\n        @evaluated\n        def fully_evaluated(self):\n            return (1 + 1, 2, 3)\n        # -> _test(2, 2, 3)\n\n        @evaluated\n        def _helper():\n            return (1 + 2, 3)\n        partly_evaluated = _helper(), 4\n        # -> _test(3, 3, 4)\n\nthe wrapped function must always return a tuple.\n\nthe wrapped function will also receive options as keyword arguments:\n\n.. code-block:: python\n\n    from repeated_test import fixtures, evaluated, with_options_matrix\n\n    @with_options_matrix(\n        option=[\n            \"option 1\",\n            \"option 2\",\n        ],\n    )\n    class evaluatedfixtureswithoptions(fixtures):\n        def _test(self, a, *, option):\n            pass\n\n        @evaluated\n        def _helper(arg, *, option):\n            return (f\"{arg}-{option}\",)\n\n        using_option_in_evaluated = _helper(\"arg\")\n        # -> _test(\"arg-option 1\", option=\"option 1\")\n        # -> _test(\"arg-option 2\", option=\"option 2\")\n\n.. _named alternative:\n\nnamed alternatives\n------------------\n\nwhen using ``with_options_matrix``,\nsometimes the repr generated by those options is difficult to read.\nthis can be the case with functions,\nwhich can end up showing as something like\n``<function myfunc at 0x7f9f5e506280>``.\n\nyou can use ``namedalternative`` to give them a name:\n\n.. code-block:: python\n\n    from repeated_test import namedalternative\n\n    value1 = namedalternative(\"name for value1\", \"value1\")\n\n    @namedalternative(\"name for func1\")\n    def func1():\n        pass\n\n.. _naming:\n.. _escaping:\n\nnaming and escaping\n-------------------\n\nyou may name your test tuples however you like, though they may not start with\n``test_`` or ``_``. they are copied to the resulting |tc|_ class, and test\nmethods are created for them. their name is that of the tuple, prefixed with\n``test_``.\n\n.. _regular test methods:\n.. _regular:\n\nmembers starting with ``test_`` or ``_`` are directly copied over to the\nresulting |tc|_ class, without being treated as fixtures. you can use this to\ninsert regular tests amongst your fixtures, or constants that you do not wish\nto be treated as tests:\n\n.. code-block:: python\n\n    from repeated_test import fixtures\n\n    class myfixtures(fixtures):\n        def _test(self, arg1, arg2, arg3):\n            self.assertequal(..., ...)\n\n        def test_other(self):\n            self.assertequal(3, 1+2)\n\n        _spam = 'spam, bacon and eggs'\n        # _spam won't be treated as a fixture, so _test(*_spam) won't be called\n\n        ham = _spam, _spam, _spam\n\nyou may even call the test function using ``self._test(...)`` if necessary.\n\n\n.. _separate:\n\nseparating tests and fixtures\n-----------------------------\n\nyou can apply a fixtures class to a different test function using its\n``with_test`` method:\n\n.. code-block:: python\n\n    class myfixtures(fixtures):\n        _test = none\n        ...\n\n    @myfixtures.with_test\n    def other_test(self, arg1, arg2, arg3):\n        self.assertequal(..., ...)\n\nwhile the function appears out of any class, it will be used as a method of\nthe resulting |tc|_ class, so keep in mind that it takes a ``self`` parameter.\n\nyou can reuse a fixture class however many times you like.\n\nif you specify a test function this way, you can set ``_test = none``\nin your fixtures definition. however, it will not be discovered by |ut|_,\nso `regular test methods`_ won't be run.\nomitting ``_test`` completely raises an error in order to prevent accidentally\ndisabling your tests.\n\n\n.. _decorator:\n\nworking with functions as fixtures\n----------------------------------\n\nit can be fairly impractical to use functions in your fixture tuples in this\nscheme. if your fixture tuple is meant to have one function in it, you can\nuse the ``tup`` decorator:\n\n.. code-block:: python\n\n    from repeated_test import fixtures, tup\n\n    class my_tests(fixtures):\n        def _test(self, func, arg1, arg2):\n            self.assertequal(..., ...)\n\n        @tup('arg1', 'arg2')\n        def ham():\n            pass\n        # equivalent to\n        def _ham():\n            pass\n        ham = _ham, 'arg1', 'arg2'\n\n\n.. _non-unittest:\n\nreplacing |tc| with another class\n---------------------------------\n\nyou can replace |tc| with another class using ``withtestclass(cls)``.\n\nfor instance, if you wish to use ``unittest2``:\n\n.. code-block:: python\n\n    import unittest2\n    from repeated_test import withtestclass\n\n    class my_tests(withtestclass(unittest2.testcase)):\n        ...\n",
  "docs_url": null,
  "keywords": "test,testing,unittest,fixtures",
  "license": "mit",
  "name": "repeated-test",
  "package_url": "https://pypi.org/project/repeated-test/",
  "project_url": "https://pypi.org/project/repeated-test/",
  "project_urls": {
    "Homepage": "https://github.com/epsy/repeated_test"
  },
  "release_url": "https://pypi.org/project/repeated-test/2.3.3/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "a quick unittest-compatible framework for repeating a test function over many fixtures",
  "version": "2.3.3",
  "releases": [],
  "developers": [
    "kaiser.yann@gmail.com",
    "yann_kaiser"
  ],
  "kwds": "pytest _subtests _pytest my_test_module subtests",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_repeated_test",
  "homepage": "https://github.com/epsy/repeated_test",
  "release_count": 18,
  "dependency_ids": []
}