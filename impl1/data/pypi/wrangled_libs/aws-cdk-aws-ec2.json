{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon ec2 construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthe `@aws-cdk/aws-ec2` package contains primitives for setting up networking and\ninstances.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\n```\n\n## vpc\n\nmost projects need a virtual private cloud to provide security by means of\nnetwork partitioning. this is achieved by creating an instance of\n`vpc`:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n```\n\nall default constructs require ec2 instances to be launched inside a vpc, so\nyou should generally start by defining a vpc whenever you need to launch\ninstances for your project.\n\n### subnet types\n\na vpc consists of one or more subnets that instances can be placed into. cdk\ndistinguishes three different subnet types:\n\n* **public (`subnettype.public`)** - public subnets connect directly to the internet using an\n  internet gateway. if you want your instances to have a public ip address\n  and be directly reachable from the internet, you must place them in a\n  public subnet.\n* **private with internet access (`subnettype.private_with_nat`)** - instances in private subnets are not directly routable from the\n  internet, and connect out to the internet via a nat gateway. by default, a\n  nat gateway is created in every public subnet for maximum availability. be\n  aware that you will be charged for nat gateways.\n* **isolated (`subnettype.private_isolated`)** - isolated subnets do not route from or to the internet, and\n  as such do not require nat gateways. they can only connect to or be\n  connected to from other instances in the same vpc. a default vpc configuration\n  will not include isolated subnets,\n\na default vpc configuration will create public and **private** subnets. however, if\n`natgateways:0` **and** `subnetconfiguration` is undefined, default vpc configuration\nwill create public and **isolated** subnets. see [*advanced subnet configuration*](#advanced-subnet-configuration)\nbelow for information on how to change the default subnet configuration.\n\nconstructs using the vpc will \"launch instances\" (or more accurately, create\nelastic network interfaces) into one or more of the subnets. they all accept\na property called `subnetselection` (sometimes called `vpcsubnets`) to allow\nyou to select in what subnet to place the enis, usually defaulting to\n*private* subnets if the property is omitted.\n\nif you would like to save on the cost of nat gateways, you can use\n*isolated* subnets instead of *private* subnets (as described in advanced\n*subnet configuration*). if you need private instances to have\ninternet connectivity, another option is to reduce the number of nat gateways\ncreated by setting the `natgateways` property to a lower value (the default\nis one nat gateway per availability zone). be aware that this may have\navailability implications for your application.\n\n[read more about\nsubnets](https://docs.aws.amazon.com/amazonvpc/latest/userguide/vpc_subnets.html).\n\n### control over availability zones\n\nby default, a vpc will spread over at most 3 availability zones available to\nit. to change the number of availability zones that the vpc will spread over,\nspecify the `maxazs` property when defining it.\n\nthe number of availability zones that are available depends on the *region*\nand *account* of the stack containing the vpc. if the [region and account are\nspecified](https://docs.aws.amazon.com/cdk/latest/guide/environments.html) on\nthe stack, the cli will [look up the existing availability\nzones](https://docs.aws.amazon.com/awsec2/latest/userguide/using-regions-availability-zones.html#using-regions-availability-zones-describe)\nand get an accurate count. if region and account are not specified, the stack\ncould be deployed anywhere and it will have to make a safe choice, limiting\nitself to 2 availability zones.\n\ntherefore, to get the vpc to spread over 3 or more availability zones, you\nmust specify the environment where the stack will be deployed.\n\nyou can gain full control over the availability zones selection strategy by overriding the stack's [`get availabilityzones()`](https://github.com/aws/aws-cdk/blob/master/packages/@aws-cdk/core/lib/stack.ts) method:\n\n```text\n// this example is only available in typescript\n\nclass mystack extends stack {\n\n  constructor(scope: construct, id: string, props?: stackprops) {\n    super(scope, id, props);\n\n    // ...\n  }\n\n  get availabilityzones(): string[] {\n    return ['us-west-2a', 'us-west-2b'];\n  }\n\n}\n```\n\nnote that overriding the `get availabilityzones()` method will override the default behavior for all constructs defined within the stack.\n\n### choosing subnets for resources\n\nwhen creating resources that create elastic network interfaces (such as\ndatabases or instances), there is an option to choose which subnets to place\nthem in. for example, a vpc endpoint by default is placed into a subnet in\nevery availability zone, but you can override which subnets to use. the property\nis typically called one of `subnets`, `vpcsubnets` or `subnetselection`.\n\nthe example below will place the endpoint into two azs (`us-east-1a` and `us-east-1c`),\nin isolated subnets:\n\n```python\n# vpc: ec2.vpc\n\n\nec2.interfacevpcendpoint(self, \"vpc endpoint\",\n    vpc=vpc,\n    service=ec2.interfacevpcendpointservice(\"com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc\", 443),\n    subnets=ec2.subnetselection(\n        subnet_type=ec2.subnettype.private_isolated,\n        availability_zones=[\"us-east-1a\", \"us-east-1c\"]\n    )\n)\n```\n\nyou can also specify specific subnet objects for granular control:\n\n```python\n# vpc: ec2.vpc\n# subnet1: ec2.subnet\n# subnet2: ec2.subnet\n\n\nec2.interfacevpcendpoint(self, \"vpc endpoint\",\n    vpc=vpc,\n    service=ec2.interfacevpcendpointservice(\"com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc\", 443),\n    subnets=ec2.subnetselection(\n        subnets=[subnet1, subnet2]\n    )\n)\n```\n\nwhich subnets are selected is evaluated as follows:\n\n* `subnets`: if specific subnet objects are supplied, these are selected, and no other\n  logic is used.\n* `subnettype`/`subnetgroupname`: otherwise, a set of subnets is selected by\n  supplying either type or name:\n\n  * `subnettype` will select all subnets of the given type.\n  * `subnetgroupname` should be used to distinguish between multiple groups of subnets of\n    the same type (for example, you may want to separate your application instances and your\n    rds instances into two distinct groups of isolated subnets).\n  * if neither are given, the first available subnet group of a given type that\n    exists in the vpc will be used, in this order: private, then isolated, then public.\n    in short: by default enis will preferentially be placed in subnets not connected to\n    the internet.\n* `availabilityzones`/`oneperaz`: finally, some availability-zone based filtering may be done.\n  this filtering by availability zones will only be possible if the vpc has been created or\n  looked up in a non-environment agnostic stack (so account and region have been set and\n  availability zones have been looked up).\n\n  * `availabilityzones`: only the specific subnets from the selected subnet groups that are\n    in the given availability zones will be returned.\n  * `oneperaz`: per availability zone, a maximum of one subnet will be returned (useful for resource\n    types that do not allow creating two enis in the same availability zone).\n* `subnetfilters`: additional filtering on subnets using any number of user-provided filters which\n  extend `subnetfilter`.  the following methods on the `subnetfilter` class can be used to create\n  a filter:\n\n  * `byids`: chooses subnets from a list of ids\n  * `availabilityzones`: chooses subnets in the provided list of availability zones\n  * `oneperaz`: chooses at most one subnet per availability zone\n  * `containsipaddresses`: chooses a subnet which contains *any* of the listed ip addresses\n  * `bycidrmask`: chooses subnets that have the provided cidr netmask\n\n### using nat instances\n\nby default, the `vpc` construct will create nat *gateways* for you, which\nare managed by aws. if you would prefer to use your own managed nat\n*instances* instead, specify a different value for the `natgatewayprovider`\nproperty, as follows:\n\n```python\n# configure the `natgatewayprovider` when defining a vpc\nnat_gateway_provider = ec2.natprovider.instance(\n    instance_type=ec2.instancetype(\"t3.small\")\n)\n\nvpc = ec2.vpc(self, \"myvpc\",\n    nat_gateway_provider=nat_gateway_provider,\n\n    # the 'natgateways' parameter now controls the number of nat instances\n    nat_gateways=2\n)\n```\n\nthe construct will automatically search for the most recent nat gateway ami.\nif you prefer to use a custom ami, use `machineimage: machineimage.genericlinux({ ... })` and configure the right ami id for the\nregions you want to deploy to.\n\nby default, the nat instances will route all traffic. to control what traffic\ngets routed, pass a custom value for `defaultallowedtraffic` and access the\n`natinstanceprovider.connections` member after having passed the nat provider to\nthe vpc:\n\n```python\n# instance_type: ec2.instancetype\n\n\nprovider = ec2.natprovider.instance(\n    instance_type=instance_type,\n    default_allowed_traffic=ec2.nattrafficdirection.outbound_only\n)\nec2.vpc(self, \"thevpc\",\n    nat_gateway_provider=provider\n)\nprovider.connections.allow_from(ec2.peer.ipv4(\"1.2.3.4/8\"), ec2.port.tcp(80))\n```\n\n### advanced subnet configuration\n\nif the default vpc configuration (public and private subnets spanning the\nsize of the vpc) don't suffice for you, you can configure what subnets to\ncreate by specifying the `subnetconfiguration` property. it allows you\nto configure the number and size of all subnets. specifying an advanced\nsubnet configuration could look like this:\n\n```python\nvpc = ec2.vpc(self, \"thevpc\",\n    # 'cidr' configures the ip range and size of the entire vpc.\n    # the ip space will be divided over the configured subnets.\n    cidr=\"10.0.0.0/21\",\n\n    # 'maxazs' configures the maximum number of availability zones to use\n    max_azs=3,\n\n    # 'subnetconfiguration' specifies the \"subnet groups\" to create.\n    # every subnet group will have a subnet for each az, so this\n    # configuration will create `3 groups \u00d7 3 azs = 9` subnets.\n    subnet_configuration=[ec2.subnetconfiguration(\n        # 'subnettype' controls internet access, as described above.\n        subnet_type=ec2.subnettype.public,\n\n        # 'name' is used to name this particular subnet group. you will have to\n        # use the name for subnet selection if you have more than one subnet\n        # group of the same type.\n        name=\"ingress\",\n\n        # 'cidrmask' specifies the ip addresses in the range of of individual\n        # subnets in the group. each of the subnets in this group will contain\n        # `2^(32 address bits - 24 subnet bits) - 2 reserved addresses = 254`\n        # usable ip addresses.\n        #\n        # if 'cidrmask' is left out the available address space is evenly\n        # divided across the remaining subnet groups.\n        cidr_mask=24\n    ), ec2.subnetconfiguration(\n        cidr_mask=24,\n        name=\"application\",\n        subnet_type=ec2.subnettype.private_with_nat\n    ), ec2.subnetconfiguration(\n        cidr_mask=28,\n        name=\"database\",\n        subnet_type=ec2.subnettype.private_isolated,\n\n        # 'reserved' can be used to reserve ip address space. no resources will\n        # be created for this subnet, but the ip range will be kept available for\n        # future creation of this subnet, or even for future subdivision.\n        reserved=true\n    )\n    ]\n)\n```\n\nthe example above is one possible configuration, but the user can use the\nconstructs above to implement many other network configurations.\n\nthe `vpc` from the above configuration in a region with three\navailability zones will be the following:\n\nsubnet name       |type      |ip block      |az|features\n------------------|----------|--------------|--|--------\ningresssubnet1    |`public`  |`10.0.0.0/24` |#1|nat gateway\ningresssubnet2    |`public`  |`10.0.1.0/24` |#2|nat gateway\ningresssubnet3    |`public`  |`10.0.2.0/24` |#3|nat gateway\napplicationsubnet1|`private` |`10.0.3.0/24` |#1|route to nat in ingresssubnet1\napplicationsubnet2|`private` |`10.0.4.0/24` |#2|route to nat in ingresssubnet2\napplicationsubnet3|`private` |`10.0.5.0/24` |#3|route to nat in ingresssubnet3\ndatabasesubnet1   |`isolated`|`10.0.6.0/28` |#1|only routes within the vpc\ndatabasesubnet2   |`isolated`|`10.0.6.16/28`|#2|only routes within the vpc\ndatabasesubnet3   |`isolated`|`10.0.6.32/28`|#3|only routes within the vpc\n\n### accessing the internet gateway\n\nif you need access to the internet gateway, you can get its id like so:\n\n```python\n# vpc: ec2.vpc\n\n\nigw_id = vpc.internet_gateway_id\n```\n\nfor a vpc with only `isolated` subnets, this value will be undefined.\n\nthis is only supported for vpcs created in the stack - currently you're\nunable to get the id for imported vpcs. to do that you'd have to specifically\nlook up the internet gateway by name, which would require knowing the name\nbeforehand.\n\nthis can be useful for configuring routing using a combination of gateways:\nfor more information see [routing](#routing) below.\n\n#### routing\n\nit's possible to add routes to any subnets using the `addroute()` method. if for\nexample you want an isolated subnet to have a static route via the default\ninternet gateway created for the public subnet - perhaps for routing a vpn\nconnection - you can do so like this:\n\n```python\nvpc = ec2.vpc(self, \"vpc\",\n    subnet_configuration=[ec2.subnetconfiguration(\n        subnet_type=ec2.subnettype.public,\n        name=\"public\"\n    ), ec2.subnetconfiguration(\n        subnet_type=ec2.subnettype.private_isolated,\n        name=\"isolated\"\n    )]\n)\n\n(vpc.isolated_subnets[0]).add_route(\"staticroute\",\n    router_id=vpc.internet_gateway_id,\n    router_type=ec2.routertype.gateway,\n    destination_cidr_block=\"8.8.8.8/32\"\n)\n```\n\n*note that we cast to `subnet` here because the list of subnets only returns an\n`isubnet`.*\n\n### reserving subnet ip space\n\nthere are situations where the ip space for a subnet or number of subnets\nwill need to be reserved. this is useful in situations where subnets would\nneed to be added after the vpc is originally deployed, without causing ip\nrenumbering for existing subnets. the ip space for a subnet may be reserved\nby setting the `reserved` subnetconfiguration property to true, as shown\nbelow:\n\n```python\nvpc = ec2.vpc(self, \"thevpc\",\n    nat_gateways=1,\n    subnet_configuration=[ec2.subnetconfiguration(\n        cidr_mask=26,\n        name=\"public\",\n        subnet_type=ec2.subnettype.public\n    ), ec2.subnetconfiguration(\n        cidr_mask=26,\n        name=\"application1\",\n        subnet_type=ec2.subnettype.private_with_nat\n    ), ec2.subnetconfiguration(\n        cidr_mask=26,\n        name=\"application2\",\n        subnet_type=ec2.subnettype.private_with_nat,\n        reserved=true\n    ), ec2.subnetconfiguration(\n        cidr_mask=27,\n        name=\"database\",\n        subnet_type=ec2.subnettype.private_isolated\n    )\n    ]\n)\n```\n\nin the example above, the subnet for application2 is not actually provisioned\nbut its ip space is still reserved. if in the future this subnet needs to be\nprovisioned, then the `reserved: true` property should be removed. reserving\nparts of the ip space prevents the other subnets from getting renumbered.\n\n### sharing vpcs between stacks\n\nif you are creating multiple `stack`s inside the same cdk application, you\ncan reuse a vpc defined in one stack in another by simply passing the vpc\ninstance around:\n\n```python\n#\n# stack1 creates the vpc\n#\nclass stack1(cdk.stack):\n\n    def __init__(self, scope, id, *, description=none, env=none, stackname=none, tags=none, synthesizer=none, terminationprotection=none, analyticsreporting=none):\n        super().__init__(scope, id, description=description, env=env, stackname=stackname, tags=tags, synthesizer=synthesizer, terminationprotection=terminationprotection, analyticsreporting=analyticsreporting)\n\n        self.vpc = ec2.vpc(self, \"vpc\")\n\n#\n# stack2 consumes the vpc\n#\nclass stack2(cdk.stack):\n    def __init__(self, scope, id, *, vpc, description=none, env=none, stackname=none, tags=none, synthesizer=none, terminationprotection=none, analyticsreporting=none):\n        super().__init__(scope, id, vpc=vpc, description=description, env=env, stackname=stackname, tags=tags, synthesizer=synthesizer, terminationprotection=terminationprotection, analyticsreporting=analyticsreporting)\n\n        # pass the vpc to a construct that needs it\n        constructthattakesavpc(self, \"construct\",\n            vpc=vpc\n        )\n\nstack1 = stack1(app, \"stack1\")\nstack2 = stack2(app, \"stack2\",\n    vpc=stack1.vpc\n)\n```\n\n### importing an existing vpc\n\nif your vpc is created outside your cdk app, you can use `vpc.fromlookup()`.\nthe cdk cli will search for the specified vpc in the the stack's region and\naccount, and import the subnet configuration. looking up can be done by vpc\nid, but more flexibly by searching for a specific tag on the vpc.\n\nsubnet types will be determined from the `aws-cdk:subnet-type` tag on the\nsubnet if it exists, or the presence of a route to an internet gateway\notherwise. subnet names will be determined from the `aws-cdk:subnet-name` tag\non the subnet if it exists, or will mirror the subnet type otherwise (i.e.\na public subnet will have the name `\"public\"`).\n\nthe result of the `vpc.fromlookup()` operation will be written to a file\ncalled `cdk.context.json`. you must commit this file to source control so\nthat the lookup values are available in non-privileged environments such\nas ci build steps, and to ensure your template builds are repeatable.\n\nhere's how `vpc.fromlookup()` can be used:\n\n```python\nvpc = ec2.vpc.from_lookup(stack, \"vpc\",\n    # this imports the default vpc but you can also\n    # specify a 'vpcname' or 'tags'.\n    is_default=true\n)\n```\n\n`vpc.fromlookup` is the recommended way to import vpcs. if for whatever\nreason you do not want to use the context mechanism to look up a vpc at\nsynthesis time, you can also use `vpc.fromvpcattributes`. this has the\nfollowing limitations:\n\n* every subnet group in the vpc must have a subnet in each availability zone\n  (for example, each az must have both a public and private subnet). asymmetric\n  vpcs are not supported.\n* all vpcid, subnetid, routetableid, ... parameters must either be known at\n  synthesis time, or they must come from deploy-time list parameters whose\n  deploy-time lengths are known at synthesis time.\n\nusing `vpc.fromvpcattributes()` looks like this:\n\n```python\nvpc = ec2.vpc.from_vpc_attributes(self, \"vpc\",\n    vpc_id=\"vpc-1234\",\n    availability_zones=[\"us-east-1a\", \"us-east-1b\"],\n\n    # either pass literals for all ids\n    public_subnet_ids=[\"s-12345\", \"s-67890\"],\n\n    # or: import a list of known length\n    private_subnet_ids=fn.import_list_value(\"privatesubnetids\", 2),\n\n    # or: split an imported string to a list of known length\n    isolated_subnet_ids=fn.split(\",\", ssm.stringparameter.value_for_string_parameter(self, \"myparameter\"), 2)\n)\n```\n\n## allowing connections\n\nin aws, all network traffic in and out of **elastic network interfaces** (enis)\nis controlled by **security groups**. you can think of security groups as a\nfirewall with a set of rules. by default, security groups allow no incoming\n(ingress) traffic and all outgoing (egress) traffic. you can add ingress rules\nto them to allow incoming traffic streams. to exert fine-grained control over\negress traffic, set `allowalloutbound: false` on the `securitygroup`, after\nwhich you can add egress traffic rules.\n\nyou can manipulate security groups directly:\n\n```python\nmy_security_group = ec2.securitygroup(self, \"securitygroup\",\n    vpc=vpc,\n    description=\"allow ssh access to ec2 instances\",\n    allow_all_outbound=true\n)\nmy_security_group.add_ingress_rule(ec2.peer.any_ipv4(), ec2.port.tcp(22), \"allow ssh access from the world\")\n```\n\nall constructs that create enis on your behalf (typically constructs that create\nec2 instances or other vpc-connected resources) will all have security groups\nautomatically assigned. those constructs have an attribute called\n**connections**, which is an object that makes it convenient to update the\nsecurity groups. if you want to allow connections between two constructs that\nhave security groups, you have to add an **egress** rule to one security group,\nand an **ingress** rule to the other. the connections object will automatically\ntake care of this for you:\n\n```python\n# load_balancer: elbv2.applicationloadbalancer\n# app_fleet: autoscaling.autoscalinggroup\n# db_fleet: autoscaling.autoscalinggroup\n\n\n# allow connections from anywhere\nload_balancer.connections.allow_from_any_ipv4(ec2.port.tcp(443), \"allow inbound https\")\n\n# the same, but an explicit ip address\nload_balancer.connections.allow_from(ec2.peer.ipv4(\"1.2.3.4/32\"), ec2.port.tcp(443), \"allow inbound https\")\n\n# allow connection between autoscalinggroups\napp_fleet.connections.allow_to(db_fleet, ec2.port.tcp(443), \"app can call database\")\n```\n\n### connection peers\n\nthere are various classes that implement the connection peer part:\n\n```python\n# app_fleet: autoscaling.autoscalinggroup\n# db_fleet: autoscaling.autoscalinggroup\n\n\n# simple connection peers\npeer = ec2.peer.ipv4(\"10.0.0.0/16\")\npeer = ec2.peer.any_ipv4()\npeer = ec2.peer.ipv6(\"::0/0\")\npeer = ec2.peer.any_ipv6()\npeer = ec2.peer.prefix_list(\"pl-12345\")\napp_fleet.connections.allow_to(peer, ec2.port.tcp(443), \"allow outbound https\")\n```\n\nany object that has a security group can itself be used as a connection peer:\n\n```python\n# fleet1: autoscaling.autoscalinggroup\n# fleet2: autoscaling.autoscalinggroup\n# app_fleet: autoscaling.autoscalinggroup\n\n\n# these automatically create appropriate ingress and egress rules in both security groups\nfleet1.connections.allow_to(fleet2, ec2.port.tcp(80), \"allow between fleets\")\n\napp_fleet.connections.allow_from_any_ipv4(ec2.port.tcp(80), \"allow from load balancer\")\n```\n\n### port ranges\n\nthe connections that are allowed are specified by port ranges. a number of classes provide\nthe connection specifier:\n\n```python\nec2.port.tcp(80)\nec2.port.tcp_range(60000, 65535)\nec2.port.all_tcp()\nec2.port.all_traffic()\n```\n\n> note: this set is not complete yet; for example, there is no library support for icmp at the moment.\n> however, you can write your own classes to implement those.\n\n### default ports\n\nsome constructs have default ports associated with them. for example, the\nlistener of a load balancer does (it's the public port), or instances of an\nrds database (it's the port the database is accepting connections on).\n\nif the object you're calling the peering method on has a default port associated with it, you can call\n`allowdefaultportfrom()` and omit the port specifier. if the argument has an associated default port, call\n`allowdefaultportto()`.\n\nfor example:\n\n```python\n# listener: elbv2.applicationlistener\n# app_fleet: autoscaling.autoscalinggroup\n# rds_database: rds.databasecluster\n\n\n# port implicit in listener\nlistener.connections.allow_default_port_from_any_ipv4(\"allow public\")\n\n# port implicit in peer\napp_fleet.connections.allow_default_port_to(rds_database, \"fleet can access database\")\n```\n\n### security group rules\n\nby default, security group wills be added inline to the security group in the output cloud formation\ntemplate, if applicable.  this includes any static rules by ip address and port range.  this\noptimization helps to minimize the size of the template.\n\nin some environments this is not desirable, for example if your security group access is controlled\nvia tags. you can disable inline rules per security group or globally via the context key\n`@aws-cdk/aws-ec2.securitygroupdisableinlinerules`.\n\n```python\nmy_security_group_without_inline_rules = ec2.securitygroup(self, \"securitygroup\",\n    vpc=vpc,\n    description=\"allow ssh access to ec2 instances\",\n    allow_all_outbound=true,\n    disable_inline_rules=true\n)\n# this will add the rule as an external cloud formation construct\nmy_security_group_without_inline_rules.add_ingress_rule(ec2.peer.any_ipv4(), ec2.port.tcp(22), \"allow ssh access from the world\")\n```\n\n### importing an existing security group\n\nif you know the id and the configuration of the security group to import, you can use `securitygroup.fromsecuritygroupid`:\n\n```python\nsg = ec2.securitygroup.from_security_group_id(self, \"securitygroupimport\", \"sg-1234\",\n    allow_all_outbound=true\n)\n```\n\nalternatively, use lookup methods to import security groups if you do not know the id or the configuration details. method `securitygroup.fromlookupbyname` looks up a security group if the secruity group id is unknown.\n\n```python\nsg = ec2.securitygroup.from_lookup_by_name(self, \"securitygrouplookup\", \"security-group-name\", vpc)\n```\n\nif the security group id is known and configuration details are unknown, use method `securitygroup.fromlookupbyid` instead. this method will lookup property `allowalloutbound` from the current configuration of the security group.\n\n```python\nsg = ec2.securitygroup.from_lookup_by_id(self, \"securitygrouplookup\", \"sg-1234\")\n```\n\nthe result of `securitygroup.fromlookupbyname` and `securitygroup.fromlookupbyid` operations will be written to a file called `cdk.context.json`. you must commit this file to source control so that the lookup values are available in non-privileged environments such as ci build steps, and to ensure your template builds are repeatable.\n\n### cross stack connections\n\nif you are attempting to add a connection from a peer in one stack to a peer in a different stack, sometimes it is necessary to ensure that you are making the connection in\na specific stack in order to avoid a cyclic reference. if there are no other dependencies between stacks then it will not matter in which stack you make\nthe connection, but if there are existing dependencies (i.e. stack1 already depends on stack2), then it is important to make the connection in the dependent stack (i.e. stack1).\n\nwhenever you make a `connections` function call, the ingress and egress security group rules will be added to the stack that the calling object exists in.\nso if you are doing something like `peer1.connections.allowfrom(peer2)`, then the security group rules (both ingress and egress) will be created in `peer1`'s stack.\n\nas an example, if we wanted to allow a connection from a security group in one stack (egress) to a security group in a different stack (ingress),\nwe would make the connection like:\n\n**if stack1 depends on stack2**\n\n```python\n# stack 1\n# stack1: stack\n# stack2: stack\n\n\nsg1 = ec2.securitygroup(stack1, \"sg1\",\n    allow_all_outbound=false,  # if this is `true` then no egress rule will be created\n    vpc=vpc\n)\n\n# stack 2\nsg2 = ec2.securitygroup(stack2, \"sg2\",\n    allow_all_outbound=false,  # if this is `true` then no egress rule will be created\n    vpc=vpc\n)\n\n# `connections.allowto` on `sg1` since we want the\n# rules to be created in stack1\nsg1.connections.allow_to(sg2, ec2.port.tcp(3333))\n```\n\nin this case both the ingress rule for `sg2` and the egress rule for `sg1` will both be created\nin `stack 1` which avoids the cyclic reference.\n\n**if stack2 depends on stack1**\n\n```python\n# stack 1\n# stack1: stack\n# stack2: stack\n\n\nsg1 = ec2.securitygroup(stack1, \"sg1\",\n    allow_all_outbound=false,  # if this is `true` then no egress rule will be created\n    vpc=vpc\n)\n\n# stack 2\nsg2 = ec2.securitygroup(stack2, \"sg2\",\n    allow_all_outbound=false,  # if this is `true` then no egress rule will be created\n    vpc=vpc\n)\n\n# `connections.allowfrom` on `sg2` since we want the\n# rules to be created in stack2\nsg2.connections.allow_from(sg1, ec2.port.tcp(3333))\n```\n\nin this case both the ingress rule for `sg2` and the egress rule for `sg1` will both be created\nin `stack 2` which avoids the cyclic reference.\n\n## machine images (amis)\n\namis control the os that gets launched when you start your ec2 instance. the ec2\nlibrary contains constructs to select the ami you want to use.\n\ndepending on the type of ami, you select it a different way. here are some\nexamples of things you might want to use:\n\n```python\n# pick the right amazon linux edition. all arguments shown are optional\n# and will default to these values when omitted.\namzn_linux = ec2.machineimage.latest_amazon_linux(\n    generation=ec2.amazonlinuxgeneration.amazon_linux,\n    edition=ec2.amazonlinuxedition.standard,\n    virtualization=ec2.amazonlinuxvirt.hvm,\n    storage=ec2.amazonlinuxstorage.general_purpose,\n    cpu_type=ec2.amazonlinuxcputype.x86_64\n)\n\n# pick a windows edition to use\nwindows = ec2.machineimage.latest_windows(ec2.windowsversion.windows_server_2019_english_full_base)\n\n# read ami id from ssm parameter store\nssm = ec2.machineimage.from_ssm_parameter(\"/my/ami\", os=ec2.operatingsystemtype.linux)\n\n# look up the most recent image matching a set of ami filters.\n# in this case, look up the nat instance ami, by using a wildcard\n# in the 'name' field:\nnat_ami = ec2.machineimage.lookup(\n    name=\"amzn-ami-vpc-nat-*\",\n    owners=[\"amazon\"]\n)\n\n# for other custom (linux) images, instantiate a `genericlinuximage` with\n# a map giving the ami to in for each region:\nlinux = ec2.machineimage.generic_linux({\n    \"us-east-1\": \"ami-97785bed\",\n    \"eu-west-1\": \"ami-12345678\"\n})\n\n# for other custom (windows) images, instantiate a `genericwindowsimage` with\n# a map giving the ami to in for each region:\ngeneric_windows = ec2.machineimage.generic_windows({\n    \"us-east-1\": \"ami-97785bed\",\n    \"eu-west-1\": \"ami-12345678\"\n})\n```\n\n> note: the amis selected by `machineimage.lookup()` will be cached in\n> `cdk.context.json`, so that your autoscalinggroup instances aren't replaced while\n> you are making unrelated changes to your cdk app.\n>\n> to query for the latest ami again, remove the relevant cache entry from\n> `cdk.context.json`, or use the `cdk context` command. for more information, see\n> [runtime context](https://docs.aws.amazon.com/cdk/latest/guide/context.html) in the cdk\n> developer guide.\n>\n> `machineimage.genericlinux()`, `machineimage.genericwindows()` will use `cfnmapping` in\n> an agnostic stack.\n\n## special vpc configurations\n\n### vpn connections to a vpc\n\ncreate your vpc with vpn connections by specifying the `vpnconnections` props (keys are construct `id`s):\n\n```python\nvpc = ec2.vpc(self, \"myvpc\",\n    vpn_connections={\n        \"dynamic\": ec2.vpnconnectionoptions( # dynamic routing (bgp)\n            ip=\"1.2.3.4\"),\n        \"static\": ec2.vpnconnectionoptions( # static routing\n            ip=\"4.5.6.7\",\n            static_routes=[\"192.168.10.0/24\", \"192.168.20.0/24\"\n            ])\n    }\n)\n```\n\nto create a vpc that can accept vpn connections, set `vpngateway` to `true`:\n\n```python\nvpc = ec2.vpc(self, \"myvpc\",\n    vpn_gateway=true\n)\n```\n\nvpn connections can then be added:\n\n```python\nvpc.add_vpn_connection(\"dynamic\",\n    ip=\"1.2.3.4\"\n)\n```\n\nby default, routes will be propagated on the route tables associated with the private subnets. if no\nprivate subnets exist, isolated subnets are used. if no isolated subnets exist, public subnets are\nused. use the `vpc` property `vpnroutepropagation` to customize this behavior.\n\nvpn connections expose [metrics (cloudwatch.metric)](https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-cloudwatch/readme.md) across all tunnels in the account/region and per connection:\n\n```python\n# across all tunnels in the account/region\nall_data_out = ec2.vpnconnection.metric_all_tunnel_data_out()\n\n# for a specific vpn connection\nvpn_connection = vpc.add_vpn_connection(\"dynamic\",\n    ip=\"1.2.3.4\"\n)\nstate = vpn_connection.metric_tunnel_state()\n```\n\n### vpc endpoints\n\na vpc endpoint enables you to privately connect your vpc to supported aws services and vpc endpoint services powered by privatelink without requiring an internet gateway, nat device, vpn connection, or aws direct connect connection. instances in your vpc do not require public ip addresses to communicate with resources in the service. traffic between your vpc and the other service does not leave the amazon network.\n\nendpoints are virtual devices. they are horizontally scaled, redundant, and highly available vpc components that allow communication between instances in your vpc and services without imposing availability risks or bandwidth constraints on your network traffic.\n\n```python\n# add gateway endpoints when creating the vpc\nvpc = ec2.vpc(self, \"myvpc\",\n    gateway_endpoints={\n        \"s3\": ec2.gatewayvpcendpointoptions(\n            service=ec2.gatewayvpcendpointawsservice.s3\n        )\n    }\n)\n\n# alternatively gateway endpoints can be added on the vpc\ndynamo_db_endpoint = vpc.add_gateway_endpoint(\"dynamodbendpoint\",\n    service=ec2.gatewayvpcendpointawsservice.dynamodb\n)\n\n# this allows to customize the endpoint policy\ndynamo_db_endpoint.add_to_policy(\n    iam.policystatement( # restrict to listing and describing tables\n        principals=[iam.anyprincipal()],\n        actions=[\"dynamodb:describetable\", \"dynamodb:listtables\"],\n        resources=[\"*\"]))\n\n# add an interface endpoint\nvpc.add_interface_endpoint(\"ecrdockerendpoint\",\n    service=ec2.interfacevpcendpointawsservice.ecr_docker\n)\n```\n\nby default, cdk will place a vpc endpoint in one subnet per az. if you wish to override the azs cdk places the vpc endpoint in,\nuse the `subnets` parameter as follows:\n\n```python\n# vpc: ec2.vpc\n\n\nec2.interfacevpcendpoint(self, \"vpc endpoint\",\n    vpc=vpc,\n    service=ec2.interfacevpcendpointservice(\"com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc\", 443),\n    # choose which availability zones to place the vpc endpoint in, based on\n    # available azs\n    subnets=ec2.subnetselection(\n        availability_zones=[\"us-east-1a\", \"us-east-1c\"]\n    )\n)\n```\n\nper the [aws documentation](https://aws.amazon.com/premiumsupport/knowledge-center/interface-endpoint-availability-zone/), not all\nvpc endpoint services are available in all azs. if you specify the parameter `lookupsupportedazs`, cdk attempts to discover which\nazs an endpoint service is available in, and will ensure the vpc endpoint is not placed in a subnet that doesn't match those azs.\nthese azs will be stored in cdk.context.json.\n\n```python\n# vpc: ec2.vpc\n\n\nec2.interfacevpcendpoint(self, \"vpc endpoint\",\n    vpc=vpc,\n    service=ec2.interfacevpcendpointservice(\"com.amazonaws.vpce.us-east-1.vpce-svc-uuddlrlrbastrtsvc\", 443),\n    # choose which availability zones to place the vpc endpoint in, based on\n    # available azs\n    lookup_supported_azs=true\n)\n```\n\npre-defined aws services are defined in the [interfacevpcendpointawsservice](lib/vpc-endpoint.ts) class, and can be used to\ncreate vpc endpoints without having to configure name, ports, etc. for example, a keyspaces endpoint can be created for\nuse in your vpc:\n\n```python\n# vpc: ec2.vpc\n\n\nec2.interfacevpcendpoint(self, \"vpc endpoint\",\n    vpc=vpc,\n    service=ec2.interfacevpcendpointawsservice.keyspaces\n)\n```\n\n#### security groups for interface vpc endpoints\n\nby default, interface vpc endpoints create a new security group and traffic is **not**\nautomatically allowed from the vpc cidr.\n\nuse the `connections` object to allow traffic to flow to the endpoint:\n\n```python\n# my_endpoint: ec2.interfacevpcendpoint\n\n\nmy_endpoint.connections.allow_default_port_from_any_ipv4()\n```\n\nalternatively, existing security groups can be used by specifying the `securitygroups` prop.\n\n### vpc endpoint services\n\na vpc endpoint service enables you to expose a network load balancer(s) as a provider service to consumers, who connect to your service over a vpc endpoint. you can restrict access to your service via allowed principals (anything that extends arnprincipal), and require that new connections be manually accepted.\n\n```python\n# network_load_balancer1: elbv2.networkloadbalancer\n# network_load_balancer2: elbv2.networkloadbalancer\n\n\nec2.vpcendpointservice(self, \"endpointservice\",\n    vpc_endpoint_service_load_balancers=[network_load_balancer1, network_load_balancer2],\n    acceptance_required=true,\n    allowed_principals=[iam.arnprincipal(\"arn:aws:iam::123456789012:root\")]\n)\n```\n\nendpoint services support private dns, which makes it easier for clients to connect to your service by automatically setting up dns in their vpc.\nyou can enable private dns on an endpoint service like so:\n\n```python\nfrom aws_cdk.aws_route53 import hostedzone, vpcendpointservicedomainname\n# zone: hostedzone\n# vpces: ec2.vpcendpointservice\n\n\nvpcendpointservicedomainname(self, \"endpointdomain\",\n    endpoint_service=vpces,\n    domain_name=\"my-stuff.aws-cdk.dev\",\n    public_hosted_zone=zone\n)\n```\n\nnote: the domain name must be owned (registered through route53) by the account the endpoint service is in, or delegated to the account.\nthe vpcendpointservicedomainname will handle the aws side of domain verification, the process for which can be found\n[here](https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-services-dns-validation.html)\n\n### client vpn endpoint\n\naws client vpn is a managed client-based vpn service that enables you to securely access your aws\nresources and resources in your on-premises network. with client vpn, you can access your resources\nfrom any location using an openvpn-based vpn client.\n\nuse the `addclientvpnendpoint()` method to add a client vpn endpoint to a vpc:\n\n```python\nvpc.add_client_vpn_endpoint(\"endpoint\",\n    cidr=\"10.100.0.0/16\",\n    server_certificate_arn=\"arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id\",\n    # mutual authentication\n    client_certificate_arn=\"arn:aws:acm:us-east-1:123456789012:certificate/client-certificate-id\",\n    # user-based authentication\n    user_based_authentication=ec2.clientvpnuserbasedauthentication.federated(saml_provider)\n)\n```\n\nthe endpoint must use at least one [authentication method](https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/client-authentication.html):\n\n* mutual authentication with a client certificate\n* user-based authentication (directory or federated)\n\nif user-based authentication is used, the [self-service portal url](https://docs.aws.amazon.com/vpn/latest/clientvpn-user/self-service-portal.html)\nis made available via a cloudformation output.\n\nby default, a new security group is created, and logging is enabled. moreover, a rule to\nauthorize all users to the vpc cidr is created.\n\nto customize authorization rules, set the `authorizealluserstovpccidr` prop to `false`\nand use `addauthorizationrule()`:\n\n```python\nendpoint = vpc.add_client_vpn_endpoint(\"endpoint\",\n    cidr=\"10.100.0.0/16\",\n    server_certificate_arn=\"arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id\",\n    user_based_authentication=ec2.clientvpnuserbasedauthentication.federated(saml_provider),\n    authorize_all_users_to_vpc_cidr=false\n)\n\nendpoint.add_authorization_rule(\"rule\",\n    cidr=\"10.0.10.0/32\",\n    group_id=\"group-id\"\n)\n```\n\nuse `addroute()` to configure network routes:\n\n```python\nendpoint = vpc.add_client_vpn_endpoint(\"endpoint\",\n    cidr=\"10.100.0.0/16\",\n    server_certificate_arn=\"arn:aws:acm:us-east-1:123456789012:certificate/server-certificate-id\",\n    user_based_authentication=ec2.clientvpnuserbasedauthentication.federated(saml_provider)\n)\n\n# client-to-client access\nendpoint.add_route(\"route\",\n    cidr=\"10.100.0.0/16\",\n    target=ec2.clientvpnroutetarget.local()\n)\n```\n\nuse the `connections` object of the endpoint to allow traffic to other security groups.\n\n## instances\n\nyou can use the `instance` class to start up a single ec2 instance. for production setups, we recommend\nyou use an `autoscalinggroup` from the `aws-autoscaling` module instead, as autoscalinggroups will take\ncare of restarting your instance if it ever fails.\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n\n\n# aws linux\nec2.instance(self, \"instance1\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=ec2.amazonlinuximage()\n)\n\n# aws linux 2\nec2.instance(self, \"instance2\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=ec2.amazonlinuximage(\n        generation=ec2.amazonlinuxgeneration.amazon_linux_2\n    )\n)\n\n# aws linux 2 with kernel 5.x\nec2.instance(self, \"instance3\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=ec2.amazonlinuximage(\n        generation=ec2.amazonlinuxgeneration.amazon_linux_2,\n        kernel=ec2.amazonlinuxkernel.kernel5_x\n    )\n)\n\n# aws linux 2022\nec2.instance(self, \"instance4\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=ec2.amazonlinuximage(\n        generation=ec2.amazonlinuxgeneration.amazon_linux_2022\n    )\n)\n```\n\n### configuring instances using cloudformation init (cfn-init)\n\ncloudformation init allows you to configure your instances by writing files to them, installing software\npackages, starting services and running arbitrary commands. by default, if any of the instance setup\ncommands throw an error; the deployment will fail and roll back to the previously known good state.\nthe following documentation also applies to `autoscalinggroup`s.\n\nfor the full set of capabilities of this system, see the documentation for\n[`aws::cloudformation::init`](https://docs.aws.amazon.com/awscloudformation/latest/userguide/aws-resource-init.html).\nhere is an example of applying some configuration to an instance:\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n# machine_image: ec2.imachineimage\n\n\nec2.instance(self, \"instance\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=machine_image,\n\n    # showing the most complex setup, if you have simpler requirements\n    # you can use `cloudformationinit.fromelements()`.\n    init=ec2.cloudformationinit.from_config_sets(\n        config_sets={\n            # applies the configs below in this order\n            \"default\": [\"yumpreinstall\", \"config\"]\n        },\n        configs={\n            \"yum_preinstall\": ec2.initconfig([\n                # install an amazon linux package using yum\n                ec2.initpackage.yum(\"git\")\n            ]),\n            \"config\": ec2.initconfig([\n                # create a json file from tokens (can also create other files)\n                ec2.initfile.from_object(\"/etc/stack.json\", {\n                    \"stack_id\": stack.of(self).stack_id,\n                    \"stack_name\": stack.of(self).stack_name,\n                    \"region\": stack.of(self).region\n                }),\n\n                # create a group and user\n                ec2.initgroup.from_name(\"my-group\"),\n                ec2.inituser.from_name(\"my-user\"),\n\n                # install an rpm from the internet\n                ec2.initpackage.rpm(\"http://mirrors.ukfast.co.uk/sites/dl.fedoraproject.org/pub/epel/8/everything/x86_64/packages/r/rubygem-git-1.5.0-2.el8.noarch.rpm\")\n            ])\n        }\n    ),\n    init_options=ec2.applycloudformationinitoptions(\n        # optional, which configsets to activate (['default'] by default)\n        config_sets=[\"default\"],\n\n        # optional, how long the installation is expected to take (5 minutes by default)\n        timeout=duration.minutes(30),\n\n        # optional, whether to include the --url argument when running cfn-init and cfn-signal commands (false by default)\n        include_url=true,\n\n        # optional, whether to include the --role argument when running cfn-init and cfn-signal commands (false by default)\n        include_role=true\n    )\n)\n```\n\nyou can have services restarted after the init process has made changes to the system.\nto do that, instantiate an `initservicerestarthandle` and pass it to the config elements\nthat need to trigger the restart and the service itself. for example, the following\nconfig writes a config file for nginx, extracts an archive to the root directory, and then\nrestarts nginx so that it picks up the new config and files:\n\n```python\n# my_bucket: s3.bucket\n\n\nhandle = ec2.initservicerestarthandle()\n\nec2.cloudformationinit.from_elements(\n    ec2.initfile.from_string(\"/etc/nginx/nginx.conf\", \"...\", service_restart_handles=[handle]),\n    ec2.initsource.from_s3_object(\"/var/www/html\", my_bucket, \"html.zip\", service_restart_handles=[handle]),\n    ec2.initservice.enable(\"nginx\",\n        service_restart_handle=handle\n    ))\n```\n\n### bastion hosts\n\na bastion host functions as an instance used to access servers and resources in a vpc without open up the complete vpc on a network level.\nyou can use bastion hosts using a standard ssh connection targeting port 22 on the host. as an alternative, you can connect the ssh connection\nfeature of aws systems manager session manager, which does not need an opened security group. (https://aws.amazon.com/about-aws/whats-new/2019/07/session-manager-launches-tunneling-support-for-ssh-and-scp/)\n\na default bastion host for use via ssm can be configured like:\n\n```python\nhost = ec2.bastionhostlinux(self, \"bastionhost\", vpc=vpc)\n```\n\nif you want to connect from the internet using ssh, you need to place the host into a public subnet. you can then configure allowed source hosts.\n\n```python\nhost = ec2.bastionhostlinux(self, \"bastionhost\",\n    vpc=vpc,\n    subnet_selection=ec2.subnetselection(subnet_type=ec2.subnettype.public)\n)\nhost.allow_ssh_access_from(ec2.peer.ipv4(\"1.2.3.4/32\"))\n```\n\nas there are no ssh public keys deployed on this machine, you need to use [ec2 instance connect](https://aws.amazon.com/de/blogs/compute/new-using-amazon-ec2-instance-connect-for-ssh-access-to-your-ec2-instances/)\nwith the command `aws ec2-instance-connect send-ssh-public-key` to provide your ssh public key.\n\nebs volume for the bastion host can be encrypted like:\n\n```python\nhost = ec2.bastionhostlinux(self, \"bastionhost\",\n    vpc=vpc,\n    block_devices=[ec2.blockdevice(\n        device_name=\"ebsbastionhost\",\n        volume=ec2.blockdevicevolume.ebs(10,\n            encrypted=true\n        )\n    )]\n)\n```\n\n### block devices\n\nto add ebs block device mappings, specify the `blockdevices` property. the following example sets the ebs-backed\nroot device (`/dev/sda1`) size to 50 gib, and adds another ebs-backed device mapped to `/dev/sdm` that is 100 gib in\nsize:\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n# machine_image: ec2.imachineimage\n\n\nec2.instance(self, \"instance\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=machine_image,\n\n    # ...\n\n    block_devices=[ec2.blockdevice(\n        device_name=\"/dev/sda1\",\n        volume=ec2.blockdevicevolume.ebs(50)\n    ), ec2.blockdevice(\n        device_name=\"/dev/sdm\",\n        volume=ec2.blockdevicevolume.ebs(100)\n    )\n    ]\n)\n```\n\nit is also possible to encrypt the block devices. in this example we will create an customer managed key encrypted ebs-backed root device:\n\n```python\nfrom aws_cdk.aws_kms import key\n\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n# machine_image: ec2.imachineimage\n\n\nkms_key = key(self, \"kmskey\")\n\nec2.instance(self, \"instance\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=machine_image,\n\n    # ...\n\n    block_devices=[ec2.blockdevice(\n        device_name=\"/dev/sda1\",\n        volume=ec2.blockdevicevolume.ebs(50,\n            encrypted=true,\n            kms_key=kms_key\n        )\n    )\n    ]\n)\n```\n\n### volumes\n\nwhereas a `blockdevicevolume` is an ebs volume that is created and destroyed as part of the creation and destruction of a specific instance. a `volume` is for when you want an ebs volume separate from any particular instance. a `volume` is an ebs block device that can be attached to, or detached from, any instance at any time. some types of `volume`s can also be attached to multiple instances at the same time to allow you to have shared storage between those instances.\n\na notable restriction is that a volume can only be attached to instances in the same availability zone as the volume itself.\n\nthe following demonstrates how to create a 500 gib encrypted volume in the `us-west-2a` availability zone, and give a role the ability to attach that volume to a specific instance:\n\n```python\n# instance: ec2.instance\n# role: iam.role\n\n\nvolume = ec2.volume(self, \"volume\",\n    availability_zone=\"us-west-2a\",\n    size=size.gibibytes(500),\n    encrypted=true\n)\n\nvolume.grant_attach_volume(role, [instance])\n```\n\n#### instances attaching volumes to themselves\n\nif you need to grant an instance the ability to attach/detach an ebs volume to/from itself, then using `grantattachvolume` and `grantdetachvolume` as outlined above\nwill lead to an unresolvable circular reference between the instance role and the instance. in this case, use `grantattachvolumebyresourcetag` and `grantdetachvolumebyresourcetag` as follows:\n\n```python\n# instance: ec2.instance\n# volume: ec2.volume\n\n\nattach_grant = volume.grant_attach_volume_by_resource_tag(instance.grant_principal, [instance])\ndetach_grant = volume.grant_detach_volume_by_resource_tag(instance.grant_principal, [instance])\n```\n\n#### attaching volumes\n\nthe amazon ec2 documentation for\n[linux instances](https://docs.aws.amazon.com/awsec2/latest/userguide/amazonebs.html) and\n[windows instances](https://docs.aws.amazon.com/awsec2/latest/windowsguide/ebs-volumes.html) contains information on how\nto attach and detach your volumes to/from instances, and how to format them for use.\n\nthe following is a sample skeleton of ec2 userdata that can be used to attach a volume to the linux instance that it is running on:\n\n```python\n# instance: ec2.instance\n# volume: ec2.volume\n\n\nvolume.grant_attach_volume_by_resource_tag(instance.grant_principal, [instance])\ntarget_device = \"/dev/xvdz\"\ninstance.user_data.add_commands(\"token=$(curl -ssfx put \\\"http://169.254.169.254/latest/api/token\\\" -h \\\"x-aws-ec2-metadata-token-ttl-seconds: 21600\\\")\", \"instance_id=$(curl -ssfh \\\"x-aws-ec2-metadata-token: $token\\\" http://169.254.169.254/latest/meta-data/instance-id)\", f\"aws --region {stack.of(this).region} ec2 attach-volume --volume-id {volume.volumeid} --instance-id $instance_id --device {targetdevice}\", f\"while ! test -e {targetdevice}; do sleep 1; done\")\n```\n\n#### tagging volumes\n\nyou can configure [tag propagation on volume creation](https://docs.aws.amazon.com/awscloudformation/latest/userguide/aws-properties-ec2-instance.html#cfn-ec2-instance-propagatetagstovolumeoncreation).\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n# machine_image: ec2.imachineimage\n\n\nec2.instance(self, \"instance\",\n    vpc=vpc,\n    machine_image=machine_image,\n    instance_type=instance_type,\n    propagate_tags_to_volume_on_creation=true\n)\n```\n\n### configuring instance metadata service (imds)\n\n#### toggling imdsv1\n\nyou can configure [ec2 instance metadata service](https://docs.aws.amazon.com/awsec2/latest/userguide/ec2-instance-metadata.html) options to either\nallow both imdsv1 and imdsv2 or enforce imdsv2 when interacting with the imds.\n\nto do this for a single `instance`, you can use the `requireimdsv2` property.\nthe example below demonstrates imdsv2 being required on a single `instance`:\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n# machine_image: ec2.imachineimage\n\n\nec2.instance(self, \"instance\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=machine_image,\n\n    # ...\n\n    require_imdsv2=true\n)\n```\n\nyou can also use the either the `instancerequireimdsv2aspect` for ec2 instances or the `launchtemplaterequireimdsv2aspect` for ec2 launch templates\nto apply the operation to multiple instances or launch templates, respectively.\n\nthe following example demonstrates how to use the `instancerequireimdsv2aspect` to require imdsv2 for all ec2 instances in a stack:\n\n```python\naspect = ec2.instancerequireimdsv2aspect()\naspects.of(self).add(aspect)\n```\n\n## vpc flow logs\n\nvpc flow logs is a feature that enables you to capture information about the ip traffic going to and from network interfaces in your vpc. flow log data can be published to amazon cloudwatch logs and amazon s3. after you've created a flow log, you can retrieve and view its data in the chosen destination. ([https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html](https://docs.aws.amazon.com/vpc/latest/userguide/flow-logs.html)).\n\nby default, a flow log will be created with cloudwatch logs as the destination.\n\nyou can create a flow log like this:\n\n```python\n# vpc: ec2.vpc\n\n\nec2.flowlog(self, \"flowlog\",\n    resource_type=ec2.flowlogresourcetype.from_vpc(vpc)\n)\n```\n\nor you can add a flow log to a vpc by using the addflowlog method like this:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n\nvpc.add_flow_log(\"flowlog\")\n```\n\nyou can also add multiple flow logs with different destinations.\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n\nvpc.add_flow_log(\"flowlogs3\",\n    destination=ec2.flowlogdestination.to_s3()\n)\n\nvpc.add_flow_log(\"flowlogcloudwatch\",\n    traffic_type=ec2.flowlogtraffictype.reject\n)\n```\n\nby default, the cdk will create the necessary resources for the destination. for the cloudwatch logs destination\nit will create a cloudwatch logs log group as well as the iam role with the necessary permissions to publish to\nthe log group. in the case of an s3 destination, it will create the s3 bucket.\n\nif you want to customize any of the destination resources you can provide your own as part of the `destination`.\n\n*cloudwatch logs*\n\n```python\n# vpc: ec2.vpc\n\n\nlog_group = logs.loggroup(self, \"mycustomloggroup\")\n\nrole = iam.role(self, \"mycustomrole\",\n    assumed_by=iam.serviceprincipal(\"vpc-flow-logs.amazonaws.com\")\n)\n\nec2.flowlog(self, \"flowlog\",\n    resource_type=ec2.flowlogresourcetype.from_vpc(vpc),\n    destination=ec2.flowlogdestination.to_cloud_watch_logs(log_group, role)\n)\n```\n\n*s3*\n\n```python\n# vpc: ec2.vpc\n\n\nbucket = s3.bucket(self, \"mycustombucket\")\n\nec2.flowlog(self, \"flowlog\",\n    resource_type=ec2.flowlogresourcetype.from_vpc(vpc),\n    destination=ec2.flowlogdestination.to_s3(bucket)\n)\n\nec2.flowlog(self, \"flowlogwithkeyprefix\",\n    resource_type=ec2.flowlogresourcetype.from_vpc(vpc),\n    destination=ec2.flowlogdestination.to_s3(bucket, \"prefix/\")\n)\n```\n\n## user data\n\nuser data enables you to run a script when your instances start up.  in order to configure these scripts you can add commands directly to the script\nor you can use the userdata's convenience functions to aid in the creation of your script.\n\na user data could be configured to run a script found in an asset through the following:\n\n```python\nfrom aws_cdk.aws_s3_assets import asset\n\n# instance: ec2.instance\n\n\nasset = asset(self, \"asset\",\n    path=\"./configure.sh\"\n)\n\nlocal_path = instance.user_data.add_s3_download_command(\n    bucket=asset.bucket,\n    bucket_key=asset.s3_object_key,\n    region=\"us-east-1\"\n)\ninstance.user_data.add_execute_file_command(\n    file_path=local_path,\n    arguments=\"--verbose -y\"\n)\nasset.grant_read(instance.role)\n```\n\n### multipart user data\n\nin addition, to above the `multipartuserdata` can be used to change instance startup behavior. multipart user data are composed\nfrom separate parts forming archive. the most common parts are scripts executed during instance set-up. however, there are other\nkinds, too.\n\nthe advantage of multipart archive is in flexibility when it's needed to add additional parts or to use specialized parts to\nfine tune instance startup. some services (like aws batch) support only `multipartuserdata`.\n\nthe parts can be executed at different moment of instance start-up and can serve a different purpose. this is controlled by `contenttype` property.\nfor common scripts, `text/x-shellscript; charset=\"utf-8\"` can be used as content type.\n\nin order to create archive the `multipartuserdata` has to be instantiated. than, user can add parts to multipart archive using `addpart`. the `multipartbody` contains methods supporting creation of body parts.\n\nif the very custom part is required, it can be created using `multipartuserdata.fromrawbody`, in this case full control over content type,\ntransfer encoding, and body properties is given to the user.\n\nbelow is an example for creating multipart user data with single body part responsible for installing `awscli` and configuring maximum size\nof storage used by docker containers:\n\n```python\nboot_hook_conf = ec2.userdata.for_linux()\nboot_hook_conf.add_commands(\"cloud-init-per once docker_options echo 'options=\\\"${options} --storage-opt dm.basesize=40g\\\"' >> /etc/sysconfig/docker\")\n\nsetup_commands = ec2.userdata.for_linux()\nsetup_commands.add_commands(\"sudo yum install awscli && echo packages installed \u3089\u3068 > /var/tmp/setup\")\n\nmultipart_user_data = ec2.multipartuserdata()\n# the docker has to be configured at early stage, so content type is overridden to boothook\nmultipart_user_data.add_part(ec2.multipartbody.from_user_data(boot_hook_conf, \"text/cloud-boothook; charset=\\\"us-ascii\\\"\"))\n# execute the rest of setup\nmultipart_user_data.add_part(ec2.multipartbody.from_user_data(setup_commands))\n\nec2.launchtemplate(self, \"\",\n    user_data=multipart_user_data,\n    block_devices=[]\n)\n```\n\nfor more information see\n[specifying multiple user data blocks using a mime multi part archive](https://docs.aws.amazon.com/amazonecs/latest/developerguide/bootstrap_container_instance.html#multi-part_user_data)\n\n#### using add*command on multipartuserdata\n\nto use the `add*command` methods, that are inherited from the `userdata` interface, on `multipartuserdata` you must add a part\nto the `multipartuserdata` and designate it as the reciever for these methods. this is accomplished by using the `adduserdatapart()`\nmethod on `multipartuserdata` with the `makedefault` argument set to `true`:\n\n```python\nmultipart_user_data = ec2.multipartuserdata()\ncommands_user_data = ec2.userdata.for_linux()\nmultipart_user_data.add_user_data_part(commands_user_data, ec2.multipartbody.shell_script, true)\n\n# adding commands to the multipartuserdata adds them to commandsuserdata, and vice-versa.\nmultipart_user_data.add_commands(\"touch /root/multi.txt\")\ncommands_user_data.add_commands(\"touch /root/userdata.txt\")\n```\n\nwhen used on an ec2 instance, the above `multipartuserdata` will create both `multi.txt` and `userdata.txt` in `/root`.\n\n## importing existing subnet\n\nto import an existing subnet, call `subnet.fromsubnetattributes()` or\n`subnet.fromsubnetid()`. only if you supply the subnet's availability zone\nand route table ids when calling `subnet.fromsubnetattributes()` will you be\nable to use the cdk features that use these values (such as selecting one\nsubnet per az).\n\nimporting an existing subnet looks like this:\n\n```python\n# supply all properties\nsubnet1 = ec2.subnet.from_subnet_attributes(self, \"subnetfromattributes\",\n    subnet_id=\"s-1234\",\n    availability_zone=\"pub-az-4465\",\n    route_table_id=\"rt-145\"\n)\n\n# supply only subnet id\nsubnet2 = ec2.subnet.from_subnet_id(self, \"subnetfromid\", \"s-1234\")\n```\n\n## launch templates\n\na launch template is a standardized template that contains the configuration information to launch an instance.\nthey can be used when launching instances on their own, through amazon ec2 auto scaling, ec2 fleet, and spot fleet.\nlaunch templates enable you to store launch parameters so that you do not have to specify them every time you launch\nan instance. for information on launch templates please see the\n[official documentation](https://docs.aws.amazon.com/awsec2/latest/userguide/ec2-launch-templates.html).\n\nthe following demonstrates how to create a launch template with an amazon machine image, and security group.\n\n```python\n# vpc: ec2.vpc\n\n\ntemplate = ec2.launchtemplate(self, \"launchtemplate\",\n    machine_image=ec2.machineimage.latest_amazon_linux(),\n    security_group=ec2.securitygroup(self, \"launchtemplatesg\",\n        vpc=vpc\n    )\n)\n```\n\n## detailed monitoring\n\nthe following demonstrates how to enable [detailed monitoring](https://docs.aws.amazon.com/awsec2/latest/userguide/using-cloudwatch-new.html) for an ec2 instance. keep in mind that detailed monitoring results in [additional charges](http://aws.amazon.com/cloudwatch/pricing/).\n\n```python\n# vpc: ec2.vpc\n# instance_type: ec2.instancetype\n\n\nec2.instance(self, \"instance1\",\n    vpc=vpc,\n    instance_type=instance_type,\n    machine_image=ec2.amazonlinuximage(),\n    detailed_monitoring=true\n)\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-ec2",
  "package_url": "https://pypi.org/project/aws-cdk.aws-ec2/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-ec2/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-ec2/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-kms (==1.204.0)",
    "aws-cdk.aws-logs (==1.204.0)",
    "aws-cdk.aws-s3-assets (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.aws-ssm (==1.204.0)",
    "aws-cdk.cloud-assembly-schema (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.cx-api (==1.204.0)",
    "aws-cdk.region-info (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::ec2",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk aws_ec2 aws_kms ec2 amazon_linux_2",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_ec2",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_kms",
    "pypi_aws_cdk.aws_logs",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.aws_s3_assets",
    "pypi_aws_cdk.aws_ssm",
    "pypi_aws_cdk.cloud_assembly_schema",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.cx_api",
    "pypi_aws_cdk.region_info",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}