{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: markup",
    "topic :: utilities"
  ],
  "description": "=============\nanytemplate\n=============\n\nabout\n======\n\n.. image:: https://img.shields.io/pypi/v/anytemplate.svg\n   :target: https://pypi.python.org/pypi/anytemplate/\n   :alt: [latest version]\n\n.. image:: https://img.shields.io/pypi/pyversions/anytemplate.svg\n   :target: https://pypi.python.org/pypi/anytemplate/\n   :alt: [python versions]\n\n.. .. image:: https://img.shields.io/pypi/l/anytemplate.svg\n   :target: https://pypi.python.org/pypi/anytemplate/\n   :alt: [mit license]\n\n.. image:: https://api.travis-ci.org/ssato/python-anytemplate.png?branch=master\n   :target: https://travis-ci.org/ssato/python-anytemplate\n   :alt: [test status]\n\n.. image:: https://coveralls.io/repos/ssato/python-anytemplate/badge.png\n   :target: https://coveralls.io/r/ssato/python-anytemplate\n   :alt: [coverage status]\n\n.. image:: https://landscape.io/github/ssato/python-anytemplate/master/landscape.png\n   :target: https://landscape.io/github/ssato/python-anytemplate/master\n   :alt: [code health]\n\nthis is a python library works as an abstraction layer for various python\ntemplate engines and rendering libraries, and provide a few very simple and\neasily understandable apis to render templates.\n\nalso a cli tool called anytemplate_cli is provided to render templates written\nin these template languages.\n\n- author: satoru satoh <ssato@redhat.com>\n- license: mit\n\nthe following template engines are supported currently:\n\n.. csv-table::\n   :header: \"name\", \"notes\"\n   :widths: 15, 65\n\n   `string.template <https://www.python.org>`_ , always available as it's included in python standard lib.\n   `jinja2 <http://jinja.pocoo.org>`_ , highest priory will be given and becomes default if found\n   `mako <http://www.makotemplates.org>`_ ,\n   `tenjin <http://www.kuwata-lab.com/tenjin/>`_ , renders() api is not supported\n   `cheetah <http://cheetahtemplate.org>`_ , `cheetah3 <https://pypi.python.org/pypi/cheetah3/>`_ is needed to use with python 3.x\n   `pystache <https://github.com/defunkt/pystache>`_ ,\n\n.. .. [#] https://pypi.python.org/pypi/cheetah3/ , which is not yet available in stable fedora release according to https://apps.fedoraproject.org/packages/python-cheetah.\n\nfeatures\n==========\n\n- provides very simple and unified apis for various template engines:\n\n  - anytemplate.renders() to render given template string\n  - anytemplate.render() to render given template file\n\n- can process template engine specific options:\n\n  - anytemplate.render{s,} allow passing option parameters specific to each template rendering functions behind this library\n  - anytemplate.find_engine() returns an 'engine' object to allow some more fine tunes of template engine specific customization by passing option parameters to them\n\n- provide a cli tool called anytemplate_cli to process templates in command line\n\napi usage\n============\n\napi examples\n--------------\n\ncall 'anytemplate.renders' to render given template strings like this:\n\n.. code-block:: python\n\n    result = anytemplate.renders(\"{{ x|default('aaa') }}\", {'x': 'bbb'},\n                                 at_engine=\"jinja2\")\n\nthe first parameter is a template string itself. and the second one is a dict\nor dict-like object which is generally called as 'context' object to\ninstantiate templates. the third one, keyword parameter 'at_engine' is needed\nto find the appropriate template engine to render given template string. this\nkeyword parameter is necessary because it's very difficult and should be almost\nimpossible for any template languages to detect correct template engine only by\ngiven template string itself.\n\nif 'at_engine' is omitted, a template engine of highest priority is choosen.\nonly available template engines and libraries are enabled automatically in\nanytemplate, so that that engine will be vary in accordance with your\nenvironment. for example, 'jinja2' is the engine of highest priority in my\ndevelopment envrionment with all supported template engines and libraries\ninstalled:\n\n.. code-block:: python\n\n   in [6]: import anytemplate\n\n   in [7]: anytemplate.find_engine()   # it will return the highest priority one.\n   out[7]: anytemplate.engines.jinja2.engine\n\n   in [8]: anytemplate.find_engine().name()\n   out[8]: 'jinja2'\n\nit's also possible to some option parameters specific to the template engine\nchoosen with keyword parameters like this:\n\n.. code-block:: python\n\n    # 'strict_undefined' is a parameter for mako.template.template.__init__().\n    result = anytemplate.renders(\"${x}\", {'x': 'bbb'},\n                                 at_engine=\"mako\",\n                                 strict_undefined=false)\n\nfor details such as generic option parameters list of 'anytemplate.renders',\nsee its help:\n\n.. code-block:: python\n\n  in [20]: help(anytemplate.renders)\n  help on function renders in module anytemplate.api:\n\n  renders(template_content, context=none, at_paths=none, at_encoding='utf-8', at_engine=none, at_ask_missing=false, at_cls_args=none, **kwargs)\n      compile and render given template content and return the result string.\n\n      :param template_content: template content\n      :param context: a dict or dict-like object to instantiate given\n          template file\n      :param at_paths: template search paths\n      :param at_encoding: template encoding\n      :param at_engine: specify the name of template engine to use explicitly or\n          none to find it automatically anyhow.\n      :param at_cls_args: arguments passed to instantiate template engine class\n      :param kwargs: keyword arguments passed to the template engine to\n          render templates with specific features enabled.\n\n      :return: rendered string\n\n  in [21]:\n\ncall 'anytemplate.render' to render given template file like this:\n\n.. code-block:: python\n\n    result1 = anytemplate.render(\"/path/to/a_template.tmpl\", {'x': 'bbb'},\n                                 at_engine=\"mako\")\n\n    result2 = anytemplate.render(\"another_template.t\", {'y': 'ccc'},\n                                 at_engine=\"tenjin\",\n                                 at_paths=['/path/to/templates/', '.'])\n\nthe parameters are similar to the previous example except for the first one.\n\nthe first parameter is not a template string but a path of template file, may\nbe relative or absolute path, or basename with template search paths\n(at_paths=[path_0, path_1, ...]) given.\n\nsome module wraps actual template engines in anytemplate supports automatic\ndetection of the engine by file extensions of template files. for example,\njinja2 template files of which expected file extensions are '.j2' or '.jinja2'\ntypically. so i made that such files are automatically detected as jinja2\ntemplate file and you don't need to specify the engine by 'at_engine' parameter\nlike this:\n\n.. code-block:: python\n\n    # 'jinaj2' template engine is automatically choosen because the extension\n    # of template file is '.j2'.\n    result = anytemplate.render(\"/path/to/a_template.j2\", {'x': 'bbb'})\n\nfor details such as option parameters list of 'anytemplate.render',\nsee its help:\n\n.. code-block:: python\n\n  in [21]: help(anytemplate.render)\n  help on function render in module anytemplate.api:\n\n  render(filepath, context=none, at_paths=none, at_encoding='utf-8', at_engine=none, at_ask_missing=false, at_cls_args=none, **kwargs)\n      compile and render given template file and return the result string.\n\n      :param template: template file path\n      :param context: a dict or dict-like object to instantiate given\n          template file\n      :param at_paths: template search paths\n      :param at_encoding: template encoding\n      :param at_engine: specify the name of template engine to use explicitly or\n          none to find it automatically anyhow.\n      :param at_cls_args: arguments passed to instantiate template engine class\n      :param kwargs: keyword arguments passed to the template engine to\n          render templates with specific features enabled.\n\n      :return: rendered string\n\n  in [22]:\n\ncli usage\n============\n\ncli help\n-----------\n\n.. code-block:: console\n\n  ssato@localhost% pythonpath=. python anytemplate/cli.py -h\n  usage: anytemplate/cli.py [option ...] template_file\n\n  options:\n    -h, --help            show this help message and exit\n    -t template_paths, --template-path=template_paths\n                          template search path can be specified multiple times.\n                          note: dir in which given template exists is always\n                          included in the search paths (at the end of the path\n                          list) regardless of this option.\n    -c contexts, --context=contexts\n                          specify file path and optionally its filetype, to\n                          provides context data to instantiate templates.  the\n                          option argument's format is\n                          [type:]<file_name_or_path_or_glob_pattern> ex. -c\n                          json:common.json -c ./specific.yaml -c yaml:test.dat,\n                          -c yaml:/etc/foo.d/*.conf\n    -e engine, --engine=engine\n                          specify template engine name such as 'jinja2'\n    -l, --list-engines    list supported template engines in your environment\n    -o output, --output=output\n                          output filename [stdout]\n    -v, --verbose         verbose mode\n    -q, --quiet           quiet mode\n  ssato@localhost% cat examples/ctx.yml\n  xs:\n    - name: alice\n    - name: bob\n    - name: john\n\n  ssato@localhost% cat examples/jinja2.j2\n  {% include \"jinja2-incl.j2\" %}\n  ssato@localhost% cat examples/jinja2-incl.j2\n  {# jinja2 example: #}\n  {% for x in xs if x.name -%}\n  {{ x.name }}\n  {% endfor %}\n  ssato@localhost% pythonpath=. python anytemplate/cli.py -e jinja2 \\\n  > -c examples/ctx.yml examples/jinja2.j2\n\n  alice\n  bob\n  john\n\n  ssato@localhost%\n\ncli features\n-----------------\n\nmultiple context files support to define template parameters\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe cli tool (anytemplate_cli) supports to load multiple context files in yaml\nor json or others to give template parameters with -c|--context option.\n\nloading and composing of context files are handled by my another python library\ncalled anyconfig (python-anyconfig) if installed and available on your system.\n\n- anyconfig on pypi: http://pypi.python.org/pypi/anyconfig/\n- python-anyconfig on github: https://github.com/ssato/python-anyconfig\n\nif anyconfig is not found on your system, only json context files are supported\nformat of context files, by help of python standard json or simplejson library.\n\ntemplate search paths\n^^^^^^^^^^^^^^^^^^^^^^^\n\ntemplate search paths are specified with -t|--template-path option of the cli\ntool (anytemplate_cli).  this is useful when using 'include' directive in\ntemplates; ex. -t .:templates/.\n\nnote: the default search path will be ['.',\ndir_in_which_given_template_file_is] where templatedir is the directory in\nwhich the given template file exists if -t option is not given.  and even if -t\noption is used, templatedir will be appended to that search paths at the end.\n\nbuild & install\n================\n\nif you're fedora or red hat enterprise linux user, you can build and install\n[s]rpm by yourself:\n\n.. code-block:: console\n\n   $ python setup.py srpm && mock dist/python-anytemplate-<ver_dist>.src.rpm\n\nor:\n\n.. code-block:: console\n\n   $ python setup.py rpm\n\nor you can install pre-built rpms from one of my copr repos, https://copr.fedorainfracloud.org/coprs/ssato/python-anyconfig/\n\n.. code-block:: console\n\n   # fedora\n   $ sudo dnf copr enable ssato/python-anyconfig\n   $ sudo dnf install -y python-anytemplate   # or python3-anytemplate (python3 version)\n\n.. code-block:: console\n\n   # rhel, centos\n   $ (cd /etc/yum.repos.d; sudo curl -o https://copr.fedorainfracloud.org/coprs/ssato/python-anyconfig/repo/epel-7/ssato-python-anyconfig-epel-7.repo)\n   $ sudo dnf install -y python-anytemplate   # or python3-anytemplate (python3 version)\n\notherwise, try usual ways to build and/or install python modules such like 'pip\ninstall git+https://github.com/ssato/python-anytemplate' and 'python setup.py\nbdist', etc.\n\nhacking\n===========\n\nhow to test\n-------------\n\ni choose tox for manual tests and ci. try to run 'tox [-e py27]' for example.\n\ntodo & issues\n===============\n\n- add descriptions (doctext) of template engine and library specific options: wip\n- add descriptions (doctext) how anytemplate wraps each template engine and library: wip\n- complete unit tests:\n\n  - add test cases of each template engine specific options: wip\n\n- stablize public and private (internal) apis:\n\n  - private apis still needs a lot of work especially. it's very vague how it should be as each template engine have its own concept and design and i'm not sure how to abstract them yet.\n  - i don't think public apis have large issues but these be affected by changes of private apis more or less; i'm thinking to deprecate the keyword parameter 'at_cls_args' for example.\n\nmisc\n======\n\nalternatives\n---------------\n\nthere are a few libraries works like this:\n\n- templatealchemy: https://pypi.python.org/pypi/templatealchemy/\n- collective.templateengines: https://pypi.python.org/pypi/collective.templateengines\n\nthese look more feature-rich and comprehensive, but i prefer a lot more\nlightweight and thin wrapper library along with cli tool (template renderer) so\nthat i made anytemplate.\n\nand:\n\n- python-jinja2-cli: https://github.com/ssato/python-jinja2-cli\n\nanytemplate is a successor of python-jinja2-cli.\n\n.. vim:sw=2:ts=2:et:\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "anytemplate",
  "package_url": "https://pypi.org/project/anytemplate/",
  "project_url": "https://pypi.org/project/anytemplate/",
  "project_urls": {
    "Bug Tracker": "https://github.com/ssato/python-anytemplate/issues",
    "CI: Travis": "https://travis-ci.org/ssato/python-anytemplate",
    "Download": "https://pypi.python.org/pypi/anytemplate",
    "Download RPMs": "https://copr.fedoraproject.org/coprs/ssato/python-anyconfig/",
    "Homepage": "https://github.com/ssato/python-anytemplate",
    "Source": "https://github.com/ssato/python-anytemplate"
  },
  "release_url": "https://pypi.org/project/anytemplate/0.1.6/",
  "requires_dist": [
    "anyconfig",
    "jinja2"
  ],
  "requires_python": "",
  "summary": "a module to abstract template engines and provide common apis",
  "version": "0.1.6",
  "releases": [],
  "developers": [
    "satoru.satoh@gmail.com",
    "satoru_satoh"
  ],
  "kwds": "anytemplate_cli pyversions anytemplate pypi python3",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_anytemplate",
  "homepage": "https://github.com/ssato/python-anytemplate",
  "release_count": 11,
  "dependency_ids": [
    "pypi_anyconfig",
    "pypi_jinja2"
  ]
}