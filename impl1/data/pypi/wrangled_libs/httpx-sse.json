{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# httpx-sse\n\n[![build status](https://dev.azure.com/florimondmanca/public/_apis/build/status/florimondmanca.httpx-sse?branchname=master)](https://dev.azure.com/florimondmanca/public/_build?definitionid=19)\n[![coverage](https://codecov.io/gh/florimondmanca/httpx-sse/branch/master/graph/badge.svg)](https://codecov.io/gh/florimondmanca/httpx-sse)\n[![package version](https://badge.fury.io/py/httpx-sse.svg)](https://pypi.org/project/httpx-sse)\n\nconsume [server-sent event (sse)](https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events) messages with [httpx](https://www.python-httpx.org).\n\n**table of contents**\n\n- [installation](#installation)\n- [quickstart](#quickstart)\n- [how-to](#how-to)\n- [api reference](#api-reference)\n\n## installation\n\n**note**: this is beta software. please be sure to pin your dependencies.\n\n```bash\npip install httpx-sse==\"0.4.*\"\n```\n\n## quickstart\n\n`httpx-sse` provides the [`connect_sse`](#connect_sse) and [`aconnect_sse`](#aconnect_sse) helpers for connecting to an sse endpoint. the resulting [`eventsource`](#eventsource) object exposes the [`.iter_sse()`](#iter_sse) and [`.aiter_sse()`](#aiter_sse) methods to iterate over the server-sent events.\n\nexample usage:\n\n```python\nimport httpx\nfrom httpx_sse import connect_sse\n\nwith httpx.client() as client:\n    with connect_sse(client, \"get\", \"http://localhost:8000/sse\") as event_source:\n        for sse in event_source.iter_sse():\n            print(sse.event, sse.data, sse.id, sse.retry)\n```\n\nyou can try this against this example starlette server ([credit](https://sysid.github.io/sse/)):\n\n```python\n# requirements: pip install uvicorn starlette sse-starlette\nimport asyncio\nimport uvicorn\nfrom starlette.applications import starlette\nfrom starlette.routing import route\nfrom sse_starlette.sse import eventsourceresponse\n\nasync def numbers(minimum, maximum):\n    for i in range(minimum, maximum + 1):\n        await asyncio.sleep(0.9)\n        yield {\"data\": i}\n\nasync def sse(request):\n    generator = numbers(1, 5)\n    return eventsourceresponse(generator)\n\nroutes = [\n    route(\"/sse\", endpoint=sse)\n]\n\napp = starlette(routes=routes)\n\nif __name__ == \"__main__\":\n    uvicorn.run(app)\n```\n\n## how-to\n\n### calling into python web apps\n\nyou can [call into python web apps](https://www.python-httpx.org/async/#calling-into-python-web-apps) with httpx and `httpx-sse` to test sse endpoints directly.\n\nhere's an example of calling into a starlette asgi app...\n\n```python\nimport asyncio\n\nimport httpx\nfrom httpx_sse import aconnect_sse\nfrom sse_starlette.sse import eventsourceresponse\nfrom starlette.applications import starlette\nfrom starlette.routing import route\n\nasync def auth_events(request):\n    async def events():\n        yield {\n            \"event\": \"login\",\n            \"data\": '{\"user_id\": \"4135\"}',\n        }\n\n    return eventsourceresponse(events())\n\napp = starlette(routes=[route(\"/sse/auth/\", endpoint=auth_events)])\n\nasync def main():\n    async with httpx.asyncclient(app=app) as client:\n        async with aconnect_sse(\n            client, \"get\", \"http://localhost:8000/sse/auth/\"\n        ) as event_source:\n            events = [sse async for sse in event_source.aiter_sse()]\n            (sse,) = events\n            assert sse.event == \"login\"\n            assert sse.json() == {\"user_id\": \"4135\"}\n\nasyncio.run(main())\n```\n\n### handling reconnections\n\n_(advanced)_\n\n`ssetransport` and `asyncssetransport` don't have reconnection built-in. this is because how to perform retries is generally dependent on your use case. as a result, if the connection breaks while attempting to read from the server, you will get an `httpx.readerror` from `iter_sse()` (or `aiter_sse()`).\n\nhowever, `httpx-sse` does allow implementing reconnection by using the `last-event-id` and reconnection time (in milliseconds), exposed as `sse.id` and `sse.retry` respectively.\n\nhere's how you might achieve this using [`stamina`](https://github.com/hynek/stamina)...\n\n```python\nimport time\nfrom typing import iterator\n\nimport httpx\nfrom httpx_sse import connect_sse, serversentevent\nfrom stamina import retry\n\ndef iter_sse_retrying(client, method, url):\n    last_event_id = \"\"\n    reconnection_delay = 0.0\n\n    # `stamina` will apply jitter and exponential backoff on top of\n    # the `retry` reconnection delay sent by the server.\n    @retry(on=httpx.readerror)\n    def _iter_sse():\n        nonlocal last_event_id, reconnection_delay\n\n        time.sleep(reconnection_delay)\n\n        headers = {\"accept\": \"text/event-stream\"}\n\n        if last_event_id:\n            headers[\"last-event-id\"] = last_event_id\n\n        with connect_sse(client, method, url, headers=headers) as event_source:\n            for sse in event_source.iter_sse():\n                last_event_id = sse.id\n\n                if sse.retry is not none:\n                    reconnection_delay = sse.retry / 1000\n\n                yield sse\n\n    return _iter_sse()\n```\n\nusage:\n\n```python\nwith httpx.client() as client:\n    for sse in iter_sse_retrying(client, \"get\", \"http://localhost:8000/sse\"):\n        print(sse.event, sse.data)\n```\n\n## api reference\n\n### `connect_sse`\n\n```python\ndef connect_sse(\n    client: httpx.client,\n    method: str,\n    url: union[str, httpx.url],\n    **kwargs,\n) -> contextmanager[eventsource]\n```\n\nconnect to an sse endpoint and return an [`eventsource`](#eventsource) context manager.\n\nthis sets `cache-control: no-store` on the request, as per the sse spec, as well as `accept: text/event-stream`.\n\nif the response `content-type` is not `text/event-stream`, this will raise an [`sseerror`](#sseerror).\n\n### `aconnect_sse`\n\n```python\nasync def aconnect_sse(\n    client: httpx.asyncclient,\n    method: str,\n    url: union[str, httpx.url],\n    **kwargs,\n) -> asynccontextmanager[eventsource]\n```\n\nan async equivalent to [`connect_sse`](#connect_sse).\n\n### `eventsource`\n\n```python\ndef __init__(response: httpx.response)\n```\n\nhelper for working with an sse response.\n\n#### `response`\n\nthe underlying [`httpx.response`](https://www.python-httpx.org/api/#response).\n\n#### `iter_sse`\n\n```python\ndef iter_sse() -> iterator[serversentevent]\n```\n\ndecode the response content and yield corresponding [`serversentevent`](#serversentevent).\n\nexample usage:\n\n```python\nfor sse in event_source.iter_sse():\n    ...\n```\n\n#### `aiter_sse`\n\n```python\nasync def iter_sse() -> asynciterator[serversentevent]\n```\n\nan async equivalent to `iter_sse`.\n\n### `serversentevent`\n\nrepresents a server-sent event.\n\n* `event: str` - defaults to `\"message\"`.\n* `data: str` - defaults to `\"\"`.\n* `id: str` - defaults to `\"\"`.\n* `retry: str | none` - defaults to `none`.\n\nmethods:\n\n* `json() -> any` - returns `sse.data` decoded as json.\n\n### `sseerror`\n\nan error that occurred while making a request to an sse endpoint.\n\nparents:\n\n* `httpx.transporterror`\n\n## license\n\nmit\n\n# changelog\n\nall notable changes to this project will be documented in this file.\n\nthe format is based on [keep a changelog](https://keepachangelog.com/en/1.0.0/).\n\n## 0.4.0 - 2023-12-22\n\n### removed\n\n* dropped python 3.7 support, as it has reached eol. (pull #21)\n\n### added\n\n* add official support for python 3.12. (pull #21)\n\n### fixed\n\n* allow `content-type` that contain but are not strictly `text/event-stream`. (pull #22 by @dbuades)\n* improve error message when `content-type` is missing. (pull #20 by @jamesbraza)\n\n## 0.3.1 - 2023-06-01\n\n### added\n\n* add `__repr__()` for `serversentevent` model, which may help with debugging and other tasks. (pull #16)\n\n## 0.3.0 - 2023-04-27\n\n### changed\n\n* raising an `sseerror` if the response content type is not `text/event-stream` is now performed as part of `iter_sse()` / `aiter_sse()`, instead of `connect_sse()` / `aconnect_sse()`. this allows inspecting the response before iterating on server-sent events, such as checking for error responses. (pull #12)\n\n## 0.2.0 - 2023-03-27\n\n### changed\n\n* `connect_sse()` and `aconnect_sse()` now require a `method` argument: `connect_sse(client, \"get\", \"https://example.org\")`. this provides support for sse requests with http verbs other than `get`. (pull #7)\n\n## 0.1.0 - 2023-02-05\n\n_initial release_\n\n### added\n\n* add `connect_sse`, `aconnect_sse()`, `serversentevent` and `sseerror`.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "httpx-sse",
  "package_url": "https://pypi.org/project/httpx-sse/",
  "project_url": "https://pypi.org/project/httpx-sse/",
  "project_urls": {
    "Homepage": "https://github.com/florimondmanca/httpx-sse"
  },
  "release_url": "https://pypi.org/project/httpx-sse/0.4.0/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "consume server-sent event (sse) messages with httpx.",
  "version": "0.4.0",
  "releases": [],
  "developers": [
    "florimond.manca@protonmail.com"
  ],
  "kwds": "httpx_sse httpx connect_sse azure sse",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_httpx_sse",
  "homepage": "",
  "release_count": 5,
  "dependency_ids": []
}