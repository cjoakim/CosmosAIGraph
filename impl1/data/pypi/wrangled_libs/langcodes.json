{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# langcodes: a library for language codes\n\n**langcodes** knows what languages are. it knows the standardized codes that\nrefer to them, such as `en` for english, `es` for spanish and `hi` for hindi.\n\nthese are [ietf language tags][]. you may know them by their old name, iso 639\nlanguage codes. ietf has done some important things for backward compatibility\nand supporting language variations that you won't find in the iso standard.\n\n[ietf language tags]: https://www.w3.org/international/articles/language-tags/\n\nit may sound to you like langcodes solves a pretty boring problem. at one\nlevel, that's right. sometimes you have a boring problem, and it's great when a\nlibrary solves it for you.\n\nbut there's an interesting problem hiding in here. how do you work with\nlanguage codes? how do you know when two different codes represent the same\nthing? how should your code represent relationships between codes, like the\nfollowing?\n\n* `eng` is equivalent to `en`.\n* `fra` and `fre` are both equivalent to `fr`.\n* `en-gb` might be written as `en-gb` or `en_gb`. or as 'en-uk', which is\n  erroneous, but should be treated as the same.\n* `en-ca` is not exactly equivalent to `en-us`, but it's really, really close.\n* `en-latn-us` is equivalent to `en-us`, because written english must be written\n  in the latin alphabet to be understood.\n* the difference between `ar` and `arb` is the difference between \"arabic\" and\n  \"modern standard arabic\", a difference that may not be relevant to you.\n* you'll find mandarin chinese tagged as `cmn` on wiktionary, but many other\n  resources would call the same language `zh`.\n* chinese is written in different scripts in different territories. some\n  software distinguishes the script. other software distinguishes the territory.\n  the result is that `zh-cn` and `zh-hans` are used interchangeably, as are\n  `zh-tw` and `zh-hant`, even though occasionally you'll need something\n  different such as `zh-hk` or `zh-latn-pinyin`.\n* the indonesian (`id`) and malaysian (`ms` or `zsm`) languages are mutually\n  intelligible.\n* `jp` is not a language code. (the language code for japanese is `ja`, but\n  people confuse it with the country code for japan.)\n\none way to know is to read ietf standards and unicode technical reports.\nanother way is to use a library that implements those standards and guidelines\nfor you, which langcodes does.\n\nwhen you're working with these short language codes, you may want to see the\nname that the language is called _in_ a language: `fr` is called \"french\" in\nenglish. that language doesn't have to be english: `fr` is called \"fran\u00e7ais\" in\nfrench. a supplement to langcodes, [`language_data`][language-data], provides\nthis information.\n\n[language-data]: https://github.com/rspeer/language_data\n\nlangcodes is maintained by elia robyn lake a.k.a. robyn speer, and is released\nas free software under the mit license.\n\n\n## standards implemented\n\nalthough this is not the only reason to use it, langcodes will make you more\nacronym-compliant.\n\nlangcodes implements [bcp 47](http://tools.ietf.org/html/bcp47), the ietf best\ncurrent practices on tags for identifying languages. bcp 47 is also known as\nrfc 5646. it subsumes iso 639 and is backward compatible with it, and it also\nimplements recommendations from the [unicode cldr](http://cldr.unicode.org).\n\nlangcodes can also refer to a database of language properties and names, built\nfrom unicode cldr and the iana subtag registry, if you install `language_data`.\n\nin summary, langcodes takes language codes and does the right thing with them,\nand if you want to know exactly what the right thing is, there are some\ndocuments you can go read.\n\n\n# documentation\n\n## standardizing language tags\n\nthis function standardizes tags, as strings, in several ways.\n\nit replaces overlong tags with their shortest version, and also formats them\naccording to the conventions of bcp 47:\n\n    >>> from langcodes import *\n    >>> standardize_tag('eng_us')\n    'en-us'\n\nit removes script subtags that are redundant with the language:\n\n    >>> standardize_tag('en-latn')\n    'en'\n\nit replaces deprecated values with their correct versions, if possible:\n\n    >>> standardize_tag('en-uk')\n    'en-gb'\n\nsometimes this involves complex substitutions, such as replacing serbo-croatian\n(`sh`) with serbian in latin script (`sr-latn`), or the entire tag `sgn-us`\nwith `ase` (american sign language).\n\n    >>> standardize_tag('sh-qu')\n    'sr-latn-eu'\n\n    >>> standardize_tag('sgn-us')\n    'ase'\n\nif *macro* is true, it uses macrolanguage codes as a replacement for the most\ncommon standardized language within that macrolanguage.\n\n    >>> standardize_tag('arb-arab', macro=true)\n    'ar'\n\neven when *macro* is false, it shortens tags that contain both the\nmacrolanguage and the language:\n\n    >>> standardize_tag('zh-cmn-hans-cn')\n    'zh-hans-cn'\n\nif the tag can't be parsed according to bcp 47, this will raise a\nlanguagetagerror (a subclass of valueerror):\n\n    >>> standardize_tag('spa-latn-mx')\n    'es-mx'\n\n    >>> standardize_tag('spa-mx-latn')\n    traceback (most recent call last):\n        ...\n    langcodes.tag_parser.languagetagerror: this script subtag, 'latn', is out of place. expected variant, extension, or end of string.\n\n\n## language objects\n\nthis package defines one class, named language, which contains the results\nof parsing a language tag. language objects have the following fields,\nany of which may be unspecified:\n\n- *language*: the code for the language itself.\n- *script*: the 4-letter code for the writing system being used.\n- *territory*: the 2-letter or 3-digit code for the country or similar region\n  whose usage of the language appears in this text.\n- *extlangs*: a list of more specific language codes that follow the language\n  code. (this is allowed by the language code syntax, but deprecated.)\n- *variants*: codes for specific variations of language usage that aren't\n  covered by the *script* or *territory* codes.\n- *extensions*: information that's attached to the language code for use in\n  some specific system, such as unicode collation orders.\n- *private*: a code starting with `x-` that has no defined meaning.\n\nthe `language.get` method converts a string to a language instance, and the\n`language.make` method makes a language instance from its fields.  these values\nare cached so that calling `language.get` or `language.make` again with the\nsame values returns the same object, for efficiency.\n\nby default, it will replace non-standard and overlong tags as it interprets\nthem. to disable this feature and get the codes that literally appear in the\nlanguage tag, use the *normalize=false* option.\n\n    >>> language.get('en-latn-us')\n    language.make(language='en', script='latn', territory='us')\n\n    >>> language.get('sgn-us', normalize=false)\n    language.make(language='sgn', territory='us')\n\n    >>> language.get('und')\n    language.make()\n\nhere are some examples of replacing non-standard tags:\n\n    >>> language.get('sh-qu')\n    language.make(language='sr', script='latn', territory='eu')\n\n    >>> language.get('sgn-us')\n    language.make(language='ase')\n\n    >>> language.get('zh-cmn-hant')\n    language.make(language='zh', script='hant')\n\nuse the `str()` function on a language object to convert it back to its\nstandard string form:\n\n    >>> str(language.get('sh-qu'))\n    'sr-latn-eu'\n\n    >>> str(language.make(territory='in'))\n    'und-in'\n\n\n### checking validity\n\na language code is _valid_ when every part of it is assigned a meaning by iana.\nthat meaning could be \"private use\".\n\nin langcodes, we check the language subtag, script, territory, and variants for\nvalidity. we don't check other parts such as extlangs or unicode extensions.\n\nfor example, `ja` is a valid language code, and `jp` is not:\n\n    >>> language.get('ja').is_valid()\n    true\n\n    >>> language.get('jp').is_valid()\n    false\n\nthe top-level function `tag_is_valid(tag)` is possibly more convenient to use,\nbecause it can return false even for tags that don't parse:\n\n    >>> tag_is_valid('c')\n    false\n\nif one subtag is invalid, the entire code is invalid:\n\n    >>> tag_is_valid('en-000')\n    false\n\n`iw` is valid, though it's a deprecated alias for `he`:\n\n    >>> tag_is_valid('iw')\n    true\n\nthe empty language tag (`und`) is valid:\n\n    >>> tag_is_valid('und')\n    true\n\nprivate use codes are valid:\n\n    >>> tag_is_valid('x-other')\n    true\n\n    >>> tag_is_valid('qaa-qaai-aa-x-what-even-is-this')\n    true\n\nlanguage tags that are very unlikely are still valid:\n\n    >>> tag_is_valid('fr-cyrl')\n    true\n\ntags with non-ascii characters are invalid, because they don't parse:\n\n   >>> tag_is_valid('zh-\u666e\u901a\u8bdd')\n   false\n\n\n### getting alpha3 codes\n\nbefore there was bcp 47, there was iso 639-2. the iso tried to make room for the\nvariety of human languages by assigning every language a 3-letter code,\nincluding the ones that already had 2-letter codes.\n\nunfortunately, this just led to more confusion. some languages ended up with two\ndifferent 3-letter codes for legacy reasons, such as french, which is `fra` as a\n\"terminology\" code, and `fre` as a \"biblographic\" code. and meanwhile, `fr` was\nstill a code that you'd be using if you followed iso 639-1.\n\nin bcp 47, you should use 2-letter codes whenever they're available, and that's\nwhat langcodes does. fortunately, all the languages that have two different\n3-letter codes also have a 2-letter code, so if you prefer the 2-letter code,\nyou don't have to worry about the distinction.\n\nbut some applications want the 3-letter code in particular, so langcodes\nprovides a method for getting those, `language.to_alpha3()`. it returns the\n'terminology' code by default, and passing `variant='b'` returns the\nbibliographic code.\n\nwhen this method returns, it always returns a 3-letter string.\n\n    >>> language.get('fr').to_alpha3()\n    'fra'\n    >>> language.get('fr-ca').to_alpha3()\n    'fra'\n    >>> language.get('fr-ca').to_alpha3(variant='b')\n    'fre'\n    >>> language.get('de').to_alpha3()\n    'deu'\n    >>> language.get('no').to_alpha3()\n    'nor'\n    >>> language.get('un').to_alpha3()\n    traceback (most recent call last):\n        ...\n    lookuperror: 'un' is not a known language code, and has no alpha3 code.\n\nfor many languages, the terminology and bibliographic alpha3 codes are the same.\n\n    >>> language.get('en').to_alpha3(variant='t')\n    'eng'\n    >>> language.get('en').to_alpha3(variant='b')\n    'eng'\n\nwhen you use any of these \"overlong\" alpha3 codes in langcodes, they normalize\nback to the alpha2 code:\n\n    >>> language.get('zho')\n    language.make(language='zh')\n\n\n## working with language names\n\nthe methods in this section require an optional package called `language_data`.\nyou can install it with `pip install language_data`, or request the optional\n\"data\" feature of langcodes with `pip install langcodes[data]`.\n\nthe dependency that you put in setup.py should be `langcodes[data]`.\n\n### describing language objects in natural language\n\nit's often helpful to be able to describe a language code in a way that a user\n(or you) can understand, instead of in inscrutable short codes. the\n`display_name` method lets you describe a language object *in a language*.\n\nthe `.display_name(language, min_score)` method will look up the name of the\nlanguage. the names come from the iana language tag registry, which is only in\nenglish, plus cldr, which names languages in many commonly-used languages.\n\nthe default language for naming things is english:\n\n    >>> language.make(language='fr').display_name()\n    'french'\n\n    >>> language.make().display_name()\n    'unknown language'\n\n    >>> language.get('zh-hans').display_name()\n    'chinese (simplified)'\n\n    >>> language.get('en-us').display_name()\n    'english (united states)'\n\nbut you can ask for language names in numerous other languages:\n\n    >>> language.get('fr').display_name('fr')\n    'fran\u00e7ais'\n\n    >>> language.get('fr').display_name('es')\n    'franc\u00e9s'\n\n    >>> language.make().display_name('es')\n    'lengua desconocida'\n\n    >>> language.get('zh-hans').display_name('de')\n    'chinesisch (vereinfacht)'\n\n    >>> language.get('en-us').display_name('zh-hans')\n    '\u82f1\u8bed\uff08\u7f8e\u56fd\uff09'\n\nwhy does everyone get slovak and slovenian confused? let's ask them.\n\n    >>> language.get('sl').display_name('sl')\n    'sloven\u0161\u010dina'\n    >>> language.get('sk').display_name('sk')\n    'sloven\u010dina'\n    >>> language.get('sl').display_name('sk')\n    'slovin\u010dina'\n    >>> language.get('sk').display_name('sl')\n    'slova\u0161\u010dina'\n\nif the language has a script or territory code attached to it, these will be\ndescribed in parentheses:\n\n    >>> language.get('en-us').display_name()\n    'english (united states)'\n\nsometimes these can be the result of tag normalization, such as in this case\nwhere the legacy tag 'sh' becomes 'sr-latn':\n\n    >>> language.get('sh').display_name()\n    'serbian (latin)'\n\n    >>> language.get('sh', normalize=false).display_name()\n    'serbo-croatian'\n\nnaming a language in itself is sometimes a useful thing to do, so the\n`.autonym()` method makes this easy, providing the display name of a language\nin the language itself:\n\n    >>> language.get('fr').autonym()\n    'fran\u00e7ais'\n    >>> language.get('es').autonym()\n    'espa\u00f1ol'\n    >>> language.get('ja').autonym()\n    '\u65e5\u672c\u8a9e'\n    >>> language.get('en-au').autonym()\n    'english (australia)'\n    >>> language.get('sr-latn').autonym()\n    'srpski (latinica)'\n    >>> language.get('sr-cyrl').autonym()\n    '\u0441\u0440\u043f\u0441\u043a\u0438 (\u045b\u0438\u0440\u0438\u043b\u0438\u0446\u0430)'\n\nthe names come from the unicode cldr data files, and in english they can\nalso come from the iana language subtag registry. together, they can give\nyou language names in the 196 languages that cldr supports.\n\n\n### describing components of language codes\n\nyou can get the parts of the name separately with the methods `.language_name()`,\n`.script_name()`, and `.territory_name()`, or get a dictionary of all the parts\nthat are present using the `.describe()` method. these methods also accept a\nlanguage code for what language they should be described in.\n\n    >>> shaw = language.get('en-shaw-gb')\n    >>> shaw.describe('en')\n    {'language': 'english', 'script': 'shavian', 'territory': 'united kingdom'}\n\n    >>> shaw.describe('es')\n    {'language': 'ingl\u00e9s', 'script': 'shaviano', 'territory': 'reino unido'}\n\n\n### recognizing language names in natural language\n\nas the reverse of the above operations, you may want to look up a language by\nits name, converting a natural language name such as \"french\" to a code such as\n'fr'.\n\nthe name can be in any language that cldr supports (see \"ambiguity\" below).\n\n    >>> import langcodes\n    >>> langcodes.find('french')\n    language.make(language='fr')\n\n    >>> langcodes.find('franc\u00e9s')\n    language.make(language='fr')\n\nhowever, this method currently ignores the parenthetical expressions that come from\n`.display_name()`:\n\n    >>> langcodes.find('english (canada)')\n    language.make(language='en')\n\nthere is still room to improve the way that language names are matched, because\nsome languages are not consistently named the same way. the method currently\nworks with hundreds of language names that are used on wiktionary.\n\n#### ambiguity\n\nfor the sake of usability, `langcodes.find()` doesn't require you to specify what\nlanguage you're looking up a language in by name. this could potentially lead to\na conflict: what if name \"x\" is language a's name for language b, and language c's\nname for language d?\n\nwe can collect the language codes from cldr and see how many times this\nhappens. in the majority of cases like that, b and d are codes whose names are\nalso overlapping in the _same_ language and can be resolved by some general\nprinciple.\n\nfor example, no matter whether you decide \"tagalog\" refers to the language code\n`tl` or the largely overlapping code `fil`, that distinction doesn't depend on\nthe language you're saying \"tagalog\" in. we can just return `tl` consistently.\n\n    >>> langcodes.find('tagalog')\n    language.make(language='tl')\n\nin the few cases of actual interlingual ambiguity, langcodes won't match a result.\nyou can pass in a `language=` parameter to say what language the name is in.\n\nfor example, there are two distinct languages called \"tonga\" in various languages.\nthey are `to`, the language of tonga which is called \"tongan\" in english; and `tog`,\na language of malawi that can be called \"nyasa tonga\" in english.\n\n    >>> langcodes.find('tongan')\n    language.make(language='to')\n\n    >>> langcodes.find('nyasa tonga')\n    language.make(language='tog')\n\n    >>> langcodes.find('tonga')\n    traceback (most recent call last):\n    ...\n    lookuperror: can't find any language named 'tonga'\n\n    >>> langcodes.find('tonga', language='id')\n    language.make(language='to')\n\n    >>> langcodes.find('tonga', language='ca')\n    language.make(language='tog')\n\nother ambiguous names written in latin letters are \"kiga\", \"mbundu\", \"roman\", and \"ruanda\".\n\n\n## demographic language data\n\nthe `language.speaking_population()` and `language.writing_population()`\nmethods get unicode's estimates of how many people in the world use a\nlanguage.\n\nas with the language name data, this requires the optional `language_data`\npackage to be installed.\n\n`.speaking_population()` estimates how many people speak a language. it can\nbe limited to a particular territory with a territory code (such as a country\ncode).\n\n    >>> language.get('es').speaking_population()\n    487664083\n\n    >>> language.get('pt').speaking_population()\n    237135429\n\n    >>> language.get('es-br').speaking_population()\n    76218\n\n    >>> language.get('pt-br').speaking_population()\n    192661560\n\n    >>> language.get('vo').speaking_population()\n    0\n\nscript codes will be ignored, because the script is not involved in speaking:\n\n    >>> language.get('es-hant').speaking_population() ==\\\n    ... language.get('es').speaking_population()\n    true\n\n`.writing_population()` estimates how many people write a language.\n        \n    >>> all = language.get('zh').writing_population()\n    >>> all\n    1240326057\n\n    >>> traditional = language.get('zh-hant').writing_population()\n    >>> traditional\n    37019589\n\n    >>> simplified = language.get('zh-hans').writing_population()\n    >>> all == traditional + simplified\n    true\n\nthe estimates for \"writing population\" are often overestimates, as described\nin the [cldr documentation on territory data][overestimates]. in most cases,\nthey are derived from published data about literacy rates in the places where\nthose languages are spoken. this doesn't take into account that many literate\npeople around the world speak a language that isn't typically written, and\nwrite in a _different_ language.\n\n[overestimates]: https://unicode-org.github.io/cldr-staging/charts/39/supplemental/territory_language_information.html\n\nlike `.speaking_population()`, this can be limited to a particular territory:\n\n    >>> language.get('zh-hant-hk').writing_population()\n    6439733\n    >>> language.get('zh-hans-hk').writing_population()\n    338933\n\n\n## comparing and matching languages\n\nthe `tag_distance` function returns a number from 0 to 134 indicating the\ndistance between the language the user desires and a supported language.\n\nthe distance data comes from cldr v38.1 and involves a lot of judgment calls\nmade by the unicode consortium.\n\n\n### distance values\n\nthis table summarizes the language distance values:\n\n| value | meaning                                                                                                       | example\n| ----: | :------                                                                                                       | :------\n|     0 | these codes represent the same language, possibly after filling in values and normalizing.                    | norwegian bokm\u00e5l \u2192 norwegian\n|   1-3 | these codes indicate a minor regional difference.                                                             | australian english \u2192 british english\n|   4-9 | these codes indicate a significant but unproblematic regional difference.                                     | american english \u2192 british english\n| 10-24 | a gray area that depends on your use case. there may be problems with understanding or usability.             | afrikaans \u2192 dutch, wu chinese \u2192 mandarin chinese\n| 25-50 | these languages aren't similar, but there are demographic reasons to expect some intelligibility.             | tamil \u2192 english, marathi \u2192 hindi\n| 51-79 | there are large barriers to understanding.                                                                    | japanese \u2192 japanese in hepburn romanization\n| 80-99 | these are different languages written in the same script.                                                     | english \u2192 french, arabic \u2192 urdu\n|  100+ | these languages have nothing particularly in common.                                                          | english \u2192 japanese, english \u2192 tamil\n\nsee the docstring of `tag_distance` for more explanation and examples.\n\n\n### finding the best matching language\n\nsuppose you have software that supports any of the `supported_languages`. the\nuser wants to use `desired_language`.\n\nthe function `closest_supported_match(desired_language, supported_languages)`\nlets you choose the right language, even if there isn't an exact match.\nit returns the language tag of the best-supported language, even if there\nisn't an exact match.\n\nthe `max_distance` parameter lets you set a cutoff on what counts as language\nsupport. it has a default of 25, a value that is probably okay for simple\ncases of i18n, but you might want to set it lower to require more precision.\n\n    >>> closest_supported_match('fr', ['de', 'en', 'fr'])\n    'fr'\n\n    >>> closest_supported_match('pt', ['pt-br', 'pt-pt'])\n    'pt-br'\n\n    >>> closest_supported_match('en-au', ['en-gb', 'en-us'])\n    'en-gb'\n\n    >>> closest_supported_match('af', ['en', 'nl', 'zu'])\n    'nl'\n\n    >>> closest_supported_match('und', ['en', 'und'])\n    'und'\n\n    >>> print(closest_supported_match('af', ['en', 'nl', 'zu'], max_distance=10))\n    none\n\na similar function is `closest_match(desired_language, supported_language)`,\nwhich returns both the best matching language tag and the distance. if there is\nno match, it returns ('und', 1000).\n\n    >>> closest_match('fr', ['de', 'en', 'fr'])\n    ('fr', 0)\n\n    >>> closest_match('sh', ['hr', 'bs', 'sr-latn', 'sr-cyrl'])\n    ('sr-latn', 0)\n\n    >>> closest_match('id', ['zsm', 'mhp'])\n    ('zsm', 14)\n\n    >>> closest_match('ja', ['ja-latn-hepburn', 'en'])\n    ('und', 1000)\n\n    >>> closest_match('ja', ['ja-latn-hepburn', 'en'], max_distance=60)\n    ('ja-latn-hepburn', 50)\n\n## further api documentation\n\nthere are many more methods for manipulating and comparing language codes,\nand you will find them documented thoroughly in [the code itself][code].\n\nthe interesting functions all live in this one file, with extensive docstrings\nand annotations. making a separate sphinx page out of the docstrings would be\nthe traditional thing to do, but here it just seems redundant. you can go read\nthe docstrings in context, in their native habitat, and they'll always be up to\ndate.\n\n[code with documentation][code]\n\n[code]: https://github.com/rspeer/langcodes/blob/master/langcodes/__init__.py\n\n# changelog\n\n## version 3.3 (november 2021)\n\n- updated to cldr v40.\n\n- updated the iana subtag registry to version 2021-08-06.\n\n- bug fix: recognize script codes that appear in the iana registry even if\n  they're missing from cldr for some reason. 'cu-cyrs' is valid, for example.\n\n- switched the build system from `setuptools` to `poetry`.\n\nto install the package in editable mode before pep 660 is better supported, use\n`poetry install` instead of `pip install -e .`.\n\n## version 3.2 (october 2021)\n\n- supports python 3.6 through 3.10.\n\n- added the top-level function `tag_is_valid(tag)`, for determining if a string\n  is a valid language tag without having to parse it first.\n\n- added the top-level function `closest_supported_match(desired, supported)`,\n  which is similar to `closest_match` but with a simpler return value. it\n  returns the language tag of the closest match, or none if no match is close\n  enough.\n\n- bug fix: a lot of well-formed but invalid language codes appeared to be\n  valid, such as 'aaj' or 'en-latnx', because the regex could match a prefix of\n  a subtag. the validity regex is now required to match completely.\n\n- bug fixes that address some edge cases of validity:\n\n  - a language tag that is entirely private use, like 'x-private', is valid\n  - a language tag that uses the same extension twice, like 'en-a-bbb-a-ccc',\n    is invalid\n  - a language tag that uses the same variant twice, like 'de-1901-1901', is\n    invalid\n  - a language tag with two extlangs, like 'sgn-ase-bfi', is invalid\n\n- updated dependencies so they are compatible with python 3.10, including\n  switching back from `marisa-trie-m` to `marisa-trie` in `language_data`.\n\n- in bugfix release 3.2.1, corrected cases where the parser accepted\n  ill-formed language tags:\n\n  - all subtags must be made of between 1 and 8 alphanumeric ascii characters\n  - tags with two extension 'singletons' in a row (`en-a-b-ccc`) should be\n    rejected\n\n## version 3.1 (february 2021)\n\n- added the `language.to_alpha3()` method, for getting a three-letter code for a\n  language according to iso 639-2.\n\n- updated the type annotations from obiwan-style to mypy-style.\n\n\n## version 3.0 (february 2021)\n\n- moved bulky data, particularly language names, into a separate\n  `language_data` package. in situations where the data isn't needed,\n  `langcodes` becomes a smaller, pure-python package with no dependencies.\n\n- language codes where the language segment is more than 4 letters no longer\n  parse: language.get('nonsense') now returns an error.\n\n  (this is technically stricter than the parse rules of bcp 47, but there are\n  no valid language codes of this form and there should never be any. an\n  attempt to parse a language code with 5-8 letters is most likely a mistake or\n  an attempt to make up a code.)\n\n- added a method for checking the validity of a language code.\n\n- added methods for estimating language population.\n\n- updated to cldr 38.1, which includes differences in language matching.\n\n- tested on python 3.6 through 3.9; no longer tested on python 3.5.\n\n\n## version 2.2 (february 2021)\n\n- replaced `marisa-trie` dependency with `marisa-trie-m`, to achieve\n  compatibility with python 3.9.\n\n\n## version 2.1 (june 2020)\n\n- added the `display_name` method to be a more intuitive way to get a string\n  describing a language code, and made the `autonym` method use it instead of\n  `language_name`.\n\n- updated to cldr v37.\n\n- previously, some attempts to get the name of a language would return its\n  language code instead, perhaps because the name was being requested in a\n  language for which cldr doesn't have name data. this is unfortunate because\n  names and codes should not be interchangeable.\n\n  now we fall back on english names instead, which exists for all iana codes.\n  if the code is unknown, we return a string such as \"unknown language [xx]\".\n\n\n## version 2.0 (april 2020)\n\nversion 2.0 involves some significant changes that may break compatibility with 1.4,\nin addition to updating to version 36.1 of the unicode cldr data and the april 2020\nversion of the iana subtag registry.\n\nthis version requires python 3.5 or later.\n\n### match scores replaced with distances\n\noriginally, the goodness of a match between two different language codes was defined\nin terms of a \"match score\" with a maximum of 100. around 2016, unicode started\nreplacing this with a different measure, the \"match distance\", which was defined\nmuch more clearly, but we had to keep using the \"match score\".\n\nas of langcodes version 2.0, the \"score\" functions (such as\n`language.match_score`, `tag_match_score`, and `best_match`) are deprecated.\nthey'll keep using the deprecated language match tables from around cldr 27.\n\nfor a better measure of the closeness of two language codes, use `language.distance`,\n`tag_distance`, and `closest_match`.\n\n### 'region' renamed to 'territory'\n\nwe were always out of step with cldr here. following the example of the iana\ndatabase, we referred to things like the 'us' in 'en-us' as a \"region code\",\nbut the unicode standards consistently call it a \"territory code\".\n\nin langcodes 2.0, parameters, dictionary keys, and attributes named `region`\nhave been renamed to `territory`.  we try to support a few common cases with\ndeprecation warnings, such as looking up the `region` property of a language\nobject.\n\na nice benefit of this is that when a dictionary is displayed with 'language',\n'script', and 'territory' keys in alphabetical order, they are in the same\norder as they are in a language code.\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "langcodes",
  "package_url": "https://pypi.org/project/langcodes/",
  "project_url": "https://pypi.org/project/langcodes/",
  "project_urls": {
    "Homepage": "https://github.com/rspeer/langcodes"
  },
  "release_url": "https://pypi.org/project/langcodes/3.3.0/",
  "requires_dist": [
    "language-data (>=1.1,<2.0); extra == \"data\""
  ],
  "requires_python": ">=3.6",
  "summary": "tools for labeling human languages with ietf language tags",
  "version": "3.3.0",
  "releases": [],
  "developers": [
    "elia_robyn_speer",
    "rspeer@arborelia.net"
  ],
  "kwds": "langcodes languages language_data macrolanguage language",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_langcodes",
  "homepage": "https://github.com/rspeer/langcodes",
  "release_count": 17,
  "dependency_ids": [
    "pypi_language_data"
  ]
}