{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.9"
  ],
  "description": "read and write tiff files\r\n=========================\r\n\r\ntifffile is a python library to\r\n\r\n(1) store numpy arrays in tiff (tagged image file format) files, and\r\n(2) read image and metadata from tiff-like files used in bioimaging.\r\n\r\nimage and metadata can be read from tiff, bigtiff, ome-tiff, dng, stk, lsm,\r\nsgi, nihimage, imagej, mmstack, ndtiff, fluoview, scanimage, seq, gel,\r\nsvs, scn, sis, bif, zif (zoomable image file format), qptiff (qpi, pki), ndpi,\r\nand geotiff formatted files.\r\n\r\nimage data can be read as numpy arrays or zarr arrays/groups from strips,\r\ntiles, pages (ifds), subifds, higher order series, and pyramidal levels.\r\n\r\nimage data can be written to tiff, bigtiff, ome-tiff, and imagej hyperstack\r\ncompatible files in multi-page, volumetric, pyramidal, memory-mappable,\r\ntiled, predicted, or compressed form.\r\n\r\nmany compression and predictor schemes are supported via the imagecodecs\r\nlibrary, including lzw, packbits, deflate, pixtiff, lzma, lerc, zstd,\r\njpeg (8 and 12-bit, lossless), jpeg 2000, jpeg xr, jpeg xl, webp, png, eer,\r\njetraw, 24-bit floating-point, and horizontal differencing.\r\n\r\ntifffile can also be used to inspect tiff structures, read image data from\r\nmulti-dimensional file sequences, write fsspec referencefilesystem for\r\ntiff files and image file sequences, patch tiff tag values, and parse\r\nmany proprietary metadata formats.\r\n\r\n:author: `christoph gohlke <https://www.cgohlke.com>`_\r\n:license: bsd 3-clause\r\n:version: 2023.12.9\r\n:doi: `10.5281/zenodo.6795860 <https://doi.org/10.5281/zenodo.6795860>`_\r\n\r\nquickstart\r\n----------\r\n\r\ninstall the tifffile package and all dependencies from the\r\n`python package index <https://pypi.org/project/tifffile/>`_::\r\n\r\n    python -m pip install -u tifffile[all]\r\n\r\ntifffile is also available in other package repositories such as anaconda,\r\ndebian, and msys2.\r\n\r\nthe tifffile library is type annotated and documented via docstrings::\r\n\r\n    python -c \"import tifffile; help(tifffile)\"\r\n\r\ntifffile can be used as a console script to inspect and preview tiff files::\r\n\r\n    python -m tifffile --help\r\n\r\nsee `examples`_ for using the programming interface.\r\n\r\nsource code and support are available on\r\n`github <https://github.com/cgohlke/tifffile>`_.\r\n\r\nsupport is also provided on the\r\n`image.sc <https://forum.image.sc/tag/tifffile>`_ forum.\r\n\r\nrequirements\r\n------------\r\n\r\nthis revision was tested with the following requirements and dependencies\r\n(other versions may work):\r\n\r\n- `cpython <https://www.python.org>`_ 3.9.13, 3.10.11, 3.11.7, 3.12.1, 64-bit\r\n- `numpy <https://pypi.org/project/numpy/>`_ 1.26.2\r\n- `imagecodecs <https://pypi.org/project/imagecodecs/>`_ 2023.9.18\r\n  (required for encoding or decoding lzw, jpeg, etc. compressed segments)\r\n- `matplotlib <https://pypi.org/project/matplotlib/>`_ 3.8.2\r\n  (required for plotting)\r\n- `lxml <https://pypi.org/project/lxml/>`_ 4.9.3\r\n  (required only for validating and printing xml)\r\n- `zarr <https://pypi.org/project/zarr/>`_ 2.16.1\r\n  (required only for opening zarr stores)\r\n- `fsspec <https://pypi.org/project/fsspec/>`_ 2023.12.1\r\n  (required only for opening referencefilesystem files)\r\n\r\nrevisions\r\n---------\r\n\r\n2023.12.9\r\n\r\n- pass 5071 tests.\r\n- read 32-bit indica labs tiff as float32.\r\n- fix unboundlocalerror reading big lsm files without time axis.\r\n- use os.sched_getaffinity, if available, to get the number of cpus (#231).\r\n- limit the number of default worker threads to 32.\r\n\r\n2023.9.26\r\n\r\n- lazily convert dask array to ndarray when writing.\r\n- allow to specify buffersize for reading and writing.\r\n- fix indexerror reading some corrupted files with zarrtiffstore (#227).\r\n\r\n2023.9.18\r\n\r\n- raise exception when writing non-volume data with volumetric tiles (#225).\r\n- improve multi-threaded writing of compressed multi-page files.\r\n- fix fsspec reference for big-endian files with predictors.\r\n\r\n2023.8.30\r\n\r\n- support exclusive file creation mode (#221, #223).\r\n\r\n2023.8.25\r\n\r\n- verify shaped metadata is compatible with page shape.\r\n- support out parameter when returning selection from imread (#222).\r\n\r\n2023.8.12\r\n\r\n- support decompressing eer frames.\r\n- facilitate filtering logged warnings (#216).\r\n- read more tags from uic1tag (#217).\r\n- fix premature closing of files in main (#218).\r\n- don't force matplotlib backend to tkagg in main (#219).\r\n- add py.typed marker.\r\n- drop support for imagecodecs < 2023.3.16.\r\n\r\n2023.7.18\r\n\r\n- limit threading via tifffile_num_threads environment variable (#215).\r\n- remove maxworkers parameter from tiff2fsspec (breaking).\r\n\r\n2023.7.10\r\n\r\n- increase default strip size to 256 kb when writing with compression.\r\n- fix zarrtiffstore with non-default chunkmode.\r\n\r\n2023.7.4\r\n\r\n- add option to return selection from imread (#200).\r\n- fix reading ome series with missing trailing frames (#199).\r\n- fix fsspec reference for webp compressed segments missing alpha channel.\r\n- fix linting issues.\r\n- detect files written by agilent technologies.\r\n- drop support for python 3.8 and numpy < 1.21 (nep29).\r\n\r\n2023.4.12\r\n\r\n- do not write duplicate imagedescription tags from extratags (breaking).\r\n- support multifocal svs files (#193).\r\n- log warning when filtering out extratags.\r\n- fix writing ome-tiff with image description in extratags.\r\n- ignore invalid predictor tag value if prediction is not used.\r\n- raise keyerror if zarrstore is missing requested chunk.\r\n\r\n2023.3.21\r\n\r\n- fix reading mmstack with missing data (#187).\r\n\r\n2023.3.15\r\n\r\n- fix corruption using tile generators with prediction/compression (#185).\r\n- add parser for micro-manager mmstack series (breaking).\r\n- return micromanager_metadata indexmap as numpy array (breaking).\r\n- revert optimizations for micro-manager ome series.\r\n- do not use numcodecs zstd in write_fsspec (kerchunk issue 317).\r\n- more type annotations.\r\n\r\n2023.2.28\r\n\r\n- fix reading some micro-manager metadata from corrupted files.\r\n- speed up reading micro-manager indexmap for creation of ome series.\r\n\r\n2023.2.27\r\n\r\n- use micro-manager indexmap offsets to create virtual tiffframes.\r\n- fixes for future imagecodecs.\r\n\r\n2023.2.3\r\n\r\n- fix overflow in calculation of databytecounts for large ndpi files.\r\n\r\n2023.2.2\r\n\r\n- fix regression reading layered ndpi files.\r\n- add option to specify offset in filehandle.read_array.\r\n\r\n2023.1.23\r\n\r\n- support reading ndtiffstorage.\r\n- support reading pixtiff compression.\r\n- support lerc with zstd or deflate compression.\r\n- do not write duplicate and select extratags.\r\n- allow to write uncompressed image data beyond 4 gb in classic tiff.\r\n- add option to specify chunkshape and dtype in filesequence.asarray.\r\n- add option for imread to write to output in filesequence.asarray (#172).\r\n- add function to read gdal structural metadata.\r\n- add function to read ndtiff.index files.\r\n- fix indexerror accessing tifffile.mdgel_metadata in non-mdgel files.\r\n- fix unclosed file resourcewarning in tiffwriter.\r\n- fix non-bool predictor arguments (#167).\r\n- relax detection of ome-xml (#173).\r\n- rename some tiffframe parameters (breaking).\r\n- deprecate squeeze_axes (will change signature).\r\n- use defusexml in xml2dict.\r\n\r\n2022.10.10\r\n\r\n- \u2026\r\n\r\nrefer to the changes file for older revisions.\r\n\r\nnotes\r\n-----\r\n\r\ntiff, the tagged image file format, was created by the aldus corporation and\r\nadobe systems incorporated. stk, lsm, fluoview, sgi, seq, gel, qptiff, ndpi,\r\nscn, svs, zif, bif, and ome-tiff, are custom extensions defined by molecular\r\ndevices (universal imaging corporation), carl zeiss microimaging, olympus,\r\nsilicon graphics international, media cybernetics, molecular dynamics,\r\nperkinelmer, hamamatsu, leica, objectivepathology, roche digital pathology,\r\nand the open microscopy environment consortium, respectively.\r\n\r\ntifffile supports a subset of the tiff6 specification, mainly 8, 16, 32, and\r\n64-bit integer, 16, 32 and 64-bit float, grayscale and multi-sample images.\r\nspecifically, ccitt and ojpeg compression, chroma subsampling without jpeg\r\ncompression, color space transformations, samples with differing types, or\r\niptc, icc, and xmp metadata are not implemented.\r\n\r\nbesides classic tiff, tifffile supports several tiff-like formats that do not\r\nstrictly adhere to the tiff6 specification. some formats allow file and data\r\nsizes to exceed the 4 gb limit of the classic tiff:\r\n\r\n- **bigtiff** is identified by version number 43 and uses different file\r\n  header, ifd, and tag structures with 64-bit offsets. the format also adds\r\n  64-bit data types. tifffile can read and write bigtiff files.\r\n- **imagej hyperstacks** store all image data, which may exceed 4 gb,\r\n  contiguously after the first ifd. files > 4 gb contain one ifd only.\r\n  the size and shape of the up to 6-dimensional image data can be determined\r\n  from the imagedescription tag of the first ifd, which is latin-1 encoded.\r\n  tifffile can read and write imagej hyperstacks.\r\n- **ome-tiff** files store up to 8-dimensional image data in one or multiple\r\n  tiff or bigtiff files. the utf-8 encoded ome-xml metadata found in the\r\n  imagedescription tag of the first ifd defines the position of tiff ifds in\r\n  the high dimensional image data. tifffile can read ome-tiff files (except\r\n  multi-file pyramidal) and write numpy arrays to single-file ome-tiff.\r\n- **micro-manager ndtiff** stores multi-dimensional image data in one\r\n  or more classic tiff files. metadata contained in a separate ndtiff.index\r\n  binary file defines the position of the tiff ifds in the image array.\r\n  each tiff file also contains metadata in a non-tiff binary structure at\r\n  offset 8. downsampled image data of pyramidal datasets are stored in\r\n  separate folders. tifffile can read ndtiff files. version 0 and 1 series,\r\n  tiling, stitching, and multi-resolution pyramids are not supported.\r\n- **micro-manager mmstack** stores 6-dimensional image data in one or more\r\n  classic tiff files. metadata contained in non-tiff binary structures and\r\n  json strings define the image stack dimensions and the position of the image\r\n  frame data in the file and the image stack. the tiff structures and metadata\r\n  are often corrupted or wrong. tifffile can read mmstack files.\r\n- **carl zeiss lsm** files store all ifds below 4 gb and wrap around 32-bit\r\n  stripoffsets pointing to image data above 4 gb. the stripoffsets of each\r\n  series and position require separate unwrapping. the stripbytecounts tag\r\n  contains the number of bytes for the uncompressed data. tifffile can read\r\n  lsm files of any size.\r\n- **metamorph stack, stk** files contain additional image planes stored\r\n  contiguously after the image data of the first page. the total number of\r\n  planes is equal to the count of the uic2tag. tifffile can read stk files.\r\n- **zif**, the zoomable image file format, is a subspecification of bigtiff\r\n  with sgi's imagedepth extension and additional compression schemes.\r\n  only little-endian, tiled, interleaved, 8-bit per sample images with\r\n  jpeg, png, jpeg xr, and jpeg 2000 compression are allowed. tifffile can\r\n  read and write zif files.\r\n- **hamamatsu ndpi** files use some 64-bit offsets in the file header, ifd,\r\n  and tag structures. single, long typed tag values can exceed 32-bit.\r\n  the high bytes of 64-bit tag values and offsets are stored after ifd\r\n  structures. tifffile can read ndpi files > 4 gb.\r\n  jpeg compressed segments with dimensions >65530 or missing restart markers\r\n  cannot be decoded with common jpeg libraries. tifffile works around this\r\n  limitation by separately decoding the mcus between restart markers, which\r\n  performs poorly. bitspersample, samplesperpixel, and\r\n  photometricinterpretation tags may contain wrong values, which can be\r\n  corrected using the value of tag 65441.\r\n- **philips tiff** slides store wrong imagewidth and imagelength tag values\r\n  for tiled pages. the values can be corrected using the dicom_pixel_spacing\r\n  attributes of the xml formatted description of the first page. tifffile can\r\n  read philips slides.\r\n- **ventana/roche bif** slides store tiles and metadata in a bigtiff container.\r\n  tiles may overlap and require stitching based on the tilejointinfo elements\r\n  in the xmp tag. volumetric scans are stored using the imagedepth extension.\r\n  tifffile can read bif and decode individual tiles but does not perform\r\n  stitching.\r\n- **scanimage** optionally allows corrupted non-bigtiff files > 2 gb.\r\n  the values of stripoffsets and stripbytecounts can be recovered using the\r\n  constant differences of the offsets of ifd and tag values throughout the\r\n  file. tifffile can read such files if the image data are stored contiguously\r\n  in each page.\r\n- **geotiff sparse** files allow strip or tile offsets and byte counts to be 0.\r\n  such segments are implicitly set to 0 or the nodata value on reading.\r\n  tifffile can read geotiff sparse files.\r\n- **tifffile shaped** files store the array shape and user-provided metadata\r\n  of multi-dimensional image series in json format in the imagedescription tag\r\n  of the first page of the series. the format allows for multiple series,\r\n  subifds, sparse segments with zero offset and byte count, and truncated\r\n  series, where only the first page of a series is present, and the image data\r\n  are stored contiguously. no other software besides tifffile supports the\r\n  truncated format.\r\n\r\nother libraries for reading, writing, inspecting, or manipulating scientific\r\ntiff files from python are\r\n`aicsimageio <https://pypi.org/project/aicsimageio>`_,\r\n`apeer-ometiff-library\r\n<https://github.com/apeer-micro/apeer-ometiff-library>`_,\r\n`bigtiff <https://pypi.org/project/bigtiff>`_,\r\n`fabio.tiffio <https://github.com/silx-kit/fabio>`_,\r\n`gdal <https://github.com/osgeo/gdal/>`_,\r\n`imread <https://github.com/luispedro/imread>`_,\r\n`large_image <https://github.com/girder/large_image>`_,\r\n`openslide-python <https://github.com/openslide/openslide-python>`_,\r\n`opentile <https://github.com/imi-bigpicture/opentile>`_,\r\n`pylibtiff <https://github.com/pearu/pylibtiff>`_,\r\n`pylsm <https://launchpad.net/pylsm>`_,\r\n`pymimage <https://github.com/ardoi/pymimage>`_,\r\n`python-bioformats <https://github.com/cellprofiler/python-bioformats>`_,\r\n`pytiff <https://github.com/fzj-inm1-bda/pytiff>`_,\r\n`scanimagetiffreader-python\r\n<https://gitlab.com/vidriotech/scanimagetiffreader-python>`_,\r\n`simpleitk <https://github.com/simpleitk/simpleitk>`_,\r\n`slideio <https://gitlab.com/bioslide/slideio>`_,\r\n`tiffslide <https://github.com/bayer-science-for-a-better-life/tiffslide>`_,\r\n`tifftools <https://github.com/digitalslidearchive/tifftools>`_,\r\n`tyf <https://github.com/moustikitos/tyf>`_,\r\n`xtiff <https://github.com/bodenmillergroup/xtiff>`_, and\r\n`ndtiff <https://github.com/micro-manager/ndtiffstorage>`_.\r\n\r\nreferences\r\n----------\r\n\r\n- tiff 6.0 specification and supplements. adobe systems incorporated.\r\n  https://www.adobe.io/open/standards/tiff.html\r\n- tiff file format faq. https://www.awaresystems.be/imaging/tiff/faq.html\r\n- the bigtiff file format.\r\n  https://www.awaresystems.be/imaging/tiff/bigtiff.html\r\n- metamorph stack (stk) image file format.\r\n  http://mdc.custhelp.com/app/answers/detail/a_id/18862\r\n- image file format description lsm 5/7 release 6.0 (zen 2010).\r\n  carl zeiss microimaging gmbh. biosciences. may 10, 2011\r\n- the ome-tiff format.\r\n  https://docs.openmicroscopy.org/ome-model/latest/\r\n- ultraquant(r) version 6.0 for windows start-up guide.\r\n  http://www.ultralum.com/images%20ultralum/pdf/uqstart%20up%20guide.pdf\r\n- micro-manager file formats.\r\n  https://micro-manager.org/wiki/micro-manager_file_formats\r\n- scanimage bigtiff specification.\r\n  https://docs.scanimage.org/appendix/scanimage+bigtiff+specification.html\r\n- zif, the zoomable image file format. https://zif.photo/\r\n- geotiff file format https://gdal.org/drivers/raster/gtiff.html\r\n- cloud optimized geotiff.\r\n  https://github.com/cogeotiff/cog-spec/blob/master/spec.md\r\n- tags for tiff and related specifications. digital preservation.\r\n  https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\r\n- cipa dc-008-2016: exchangeable image file format for digital still cameras:\r\n  exif version 2.31.\r\n  http://www.cipa.jp/std/documents/e/dc-008-translation-2016-e.pdf\r\n- the eer (electron event representation) file format.\r\n  https://github.com/fei-company/eerreaderlib\r\n- digital negative (dng) specification. version 1.5.0.0, june 2012.\r\n  https://www.adobe.com/content/dam/acom/en/products/photoshop/pdfs/\r\n  dng_spec_1.5.0.0.pdf\r\n- roche digital pathology. bif image file format for digital pathology.\r\n  https://diagnostics.roche.com/content/dam/diagnostics/blueprint/en/pdf/rmd/\r\n  roche-digital-pathology-bif-whitepaper.pdf\r\n- astro-tiff specification. https://astro-tiff.sourceforge.io/\r\n- aperio technologies, inc. digital slides and third-party data interchange.\r\n  aperio_digital_slides_and_third-party_data_interchange.pdf\r\n- perkinelmer image format.\r\n  https://downloads.openmicroscopy.org/images/vectra-qptiff/perkinelmer/\r\n  pki_image%20format.docx\r\n- ndtiffstorage. https://github.com/micro-manager/ndtiffstorage\r\n\r\nexamples\r\n--------\r\n\r\nwrite a numpy array to a single-page rgb tiff file:\r\n\r\n>>> data = numpy.random.randint(0, 255, (256, 256, 3), 'uint8')\r\n>>> imwrite('temp.tif', data, photometric='rgb')\r\n\r\nread the image from the tiff file as numpy array:\r\n\r\n>>> image = imread('temp.tif')\r\n>>> image.shape\r\n(256, 256, 3)\r\n\r\nuse the `photometric` and `planarconfig` arguments to write a 3x3x3 numpy\r\narray to an interleaved rgb, a planar rgb, or a 3-page grayscale tiff:\r\n\r\n>>> data = numpy.random.randint(0, 255, (3, 3, 3), 'uint8')\r\n>>> imwrite('temp.tif', data, photometric='rgb')\r\n>>> imwrite('temp.tif', data, photometric='rgb', planarconfig='separate')\r\n>>> imwrite('temp.tif', data, photometric='minisblack')\r\n\r\nuse the `extrasamples` argument to specify how extra components are\r\ninterpreted, for example, for an rgba image with unassociated alpha channel:\r\n\r\n>>> data = numpy.random.randint(0, 255, (256, 256, 4), 'uint8')\r\n>>> imwrite('temp.tif', data, photometric='rgb', extrasamples=['unassalpha'])\r\n\r\nwrite a 3-dimensional numpy array to a multi-page, 16-bit grayscale tiff file:\r\n\r\n>>> data = numpy.random.randint(0, 2**12, (64, 301, 219), 'uint16')\r\n>>> imwrite('temp.tif', data, photometric='minisblack')\r\n\r\nread the whole image stack from the multi-page tiff file as numpy array:\r\n\r\n>>> image_stack = imread('temp.tif')\r\n>>> image_stack.shape\r\n(64, 301, 219)\r\n>>> image_stack.dtype\r\ndtype('uint16')\r\n\r\nread the image from the first page in the tiff file as numpy array:\r\n\r\n>>> image = imread('temp.tif', key=0)\r\n>>> image.shape\r\n(301, 219)\r\n\r\nread images from a selected range of pages:\r\n\r\n>>> images = imread('temp.tif', key=range(4, 40, 2))\r\n>>> images.shape\r\n(18, 301, 219)\r\n\r\niterate over all pages in the tiff file and successively read images:\r\n\r\n>>> with tifffile('temp.tif') as tif:\r\n...     for page in tif.pages:\r\n...         image = page.asarray()\r\n\r\nget information about the image stack in the tiff file without reading\r\nany image data:\r\n\r\n>>> tif = tifffile('temp.tif')\r\n>>> len(tif.pages)  # number of pages in the file\r\n64\r\n>>> page = tif.pages[0]  # get shape and dtype of image in first page\r\n>>> page.shape\r\n(301, 219)\r\n>>> page.dtype\r\ndtype('uint16')\r\n>>> page.axes\r\n'yx'\r\n>>> series = tif.series[0]  # get shape and dtype of first image series\r\n>>> series.shape\r\n(64, 301, 219)\r\n>>> series.dtype\r\ndtype('uint16')\r\n>>> series.axes\r\n'qyx'\r\n>>> tif.close()\r\n\r\ninspect the \"xresolution\" tag from the first page in the tiff file:\r\n\r\n>>> with tifffile('temp.tif') as tif:\r\n...     tag = tif.pages[0].tags['xresolution']\r\n>>> tag.value\r\n(1, 1)\r\n>>> tag.name\r\n'xresolution'\r\n>>> tag.code\r\n282\r\n>>> tag.count\r\n1\r\n>>> tag.dtype\r\n<datatype.rational: 5>\r\n\r\niterate over all tags in the tiff file:\r\n\r\n>>> with tifffile('temp.tif') as tif:\r\n...     for page in tif.pages:\r\n...         for tag in page.tags:\r\n...             tag_name, tag_value = tag.name, tag.value\r\n\r\noverwrite the value of an existing tag, for example, xresolution:\r\n\r\n>>> with tifffile('temp.tif', mode='r+') as tif:\r\n...     _ = tif.pages[0].tags['xresolution'].overwrite((96000, 1000))\r\n\r\nwrite a 5-dimensional floating-point array using bigtiff format, separate\r\ncolor components, tiling, zlib compression level 8, horizontal differencing\r\npredictor, and additional metadata:\r\n\r\n>>> data = numpy.random.rand(2, 5, 3, 301, 219).astype('float32')\r\n>>> imwrite(\r\n...     'temp.tif',\r\n...     data,\r\n...     bigtiff=true,\r\n...     photometric='rgb',\r\n...     planarconfig='separate',\r\n...     tile=(32, 32),\r\n...     compression='zlib',\r\n...     compressionargs={'level': 8},\r\n...     predictor=true,\r\n...     metadata={'axes': 'tzcyx'}\r\n... )\r\n\r\nwrite a 10 fps time series of volumes with xyz voxel size 2.6755x2.6755x3.9474\r\nmicron^3 to an imagej hyperstack formatted tiff file:\r\n\r\n>>> volume = numpy.random.randn(6, 57, 256, 256).astype('float32')\r\n>>> image_labels = [f'{i}' for i in range(volume.shape[0] * volume.shape[1])]\r\n>>> imwrite(\r\n...     'temp.tif',\r\n...     volume,\r\n...     imagej=true,\r\n...     resolution=(1./2.6755, 1./2.6755),\r\n...     metadata={\r\n...         'spacing': 3.947368,\r\n...         'unit': 'um',\r\n...         'finterval': 1/10,\r\n...         'fps': 10.0,\r\n...         'axes': 'tzyx',\r\n...         'labels': image_labels,\r\n...     }\r\n... )\r\n\r\nread the volume and metadata from the imagej hyperstack file:\r\n\r\n>>> with tifffile('temp.tif') as tif:\r\n...     volume = tif.asarray()\r\n...     axes = tif.series[0].axes\r\n...     imagej_metadata = tif.imagej_metadata\r\n>>> volume.shape\r\n(6, 57, 256, 256)\r\n>>> axes\r\n'tzyx'\r\n>>> imagej_metadata['slices']\r\n57\r\n>>> imagej_metadata['frames']\r\n6\r\n\r\nmemory-map the contiguous image data in the imagej hyperstack file:\r\n\r\n>>> memmap_volume = memmap('temp.tif')\r\n>>> memmap_volume.shape\r\n(6, 57, 256, 256)\r\n>>> del memmap_volume\r\n\r\ncreate a tiff file containing an empty image and write to the memory-mapped\r\nnumpy array (note: this does not work with compression or tiling):\r\n\r\n>>> memmap_image = memmap(\r\n...     'temp.tif',\r\n...     shape=(256, 256, 3),\r\n...     dtype='float32',\r\n...     photometric='rgb'\r\n... )\r\n>>> type(memmap_image)\r\n<class 'numpy.memmap'>\r\n>>> memmap_image[255, 255, 1] = 1.0\r\n>>> memmap_image.flush()\r\n>>> del memmap_image\r\n\r\nwrite two numpy arrays to a multi-series tiff file (note: other tiff readers\r\nwill not recognize the two series; use the ome-tiff format for better\r\ninteroperability):\r\n\r\n>>> series0 = numpy.random.randint(0, 255, (32, 32, 3), 'uint8')\r\n>>> series1 = numpy.random.randint(0, 255, (4, 256, 256), 'uint16')\r\n>>> with tiffwriter('temp.tif') as tif:\r\n...     tif.write(series0, photometric='rgb')\r\n...     tif.write(series1, photometric='minisblack')\r\n\r\nread the second image series from the tiff file:\r\n\r\n>>> series1 = imread('temp.tif', series=1)\r\n>>> series1.shape\r\n(4, 256, 256)\r\n\r\nsuccessively write the frames of one contiguous series to a tiff file:\r\n\r\n>>> data = numpy.random.randint(0, 255, (30, 301, 219), 'uint8')\r\n>>> with tiffwriter('temp.tif') as tif:\r\n...     for frame in data:\r\n...         tif.write(frame, contiguous=true)\r\n\r\nappend an image series to the existing tiff file (note: this does not work\r\nwith imagej hyperstack or ome-tiff files):\r\n\r\n>>> data = numpy.random.randint(0, 255, (301, 219, 3), 'uint8')\r\n>>> imwrite('temp.tif', data, photometric='rgb', append=true)\r\n\r\ncreate a tiff file from a generator of tiles:\r\n\r\n>>> data = numpy.random.randint(0, 2**12, (31, 33, 3), 'uint16')\r\n>>> def tiles(data, tileshape):\r\n...     for y in range(0, data.shape[0], tileshape[0]):\r\n...         for x in range(0, data.shape[1], tileshape[1]):\r\n...             yield data[y : y + tileshape[0], x : x + tileshape[1]]\r\n>>> imwrite(\r\n...     'temp.tif',\r\n...     tiles(data, (16, 16)),\r\n...     tile=(16, 16),\r\n...     shape=data.shape,\r\n...     dtype=data.dtype,\r\n...     photometric='rgb'\r\n... )\r\n\r\nwrite a multi-dimensional, multi-resolution (pyramidal), multi-series ome-tiff\r\nfile with metadata. sub-resolution images are written to subifds. limit\r\nparallel encoding to 2 threads. write a thumbnail image as a separate image\r\nseries:\r\n\r\n>>> data = numpy.random.randint(0, 255, (8, 2, 512, 512, 3), 'uint8')\r\n>>> subresolutions = 2\r\n>>> pixelsize = 0.29  # micrometer\r\n>>> with tiffwriter('temp.ome.tif', bigtiff=true) as tif:\r\n...     metadata={\r\n...         'axes': 'tcyxs',\r\n...         'significantbits': 8,\r\n...         'timeincrement': 0.1,\r\n...         'timeincrementunit': 's',\r\n...         'physicalsizex': pixelsize,\r\n...         'physicalsizexunit': '\u00b5m',\r\n...         'physicalsizey': pixelsize,\r\n...         'physicalsizeyunit': '\u00b5m',\r\n...         'channel': {'name': ['channel 1', 'channel 2']},\r\n...         'plane': {'positionx': [0.0] * 16, 'positionxunit': ['\u00b5m'] * 16}\r\n...     }\r\n...     options = dict(\r\n...         photometric='rgb',\r\n...         tile=(128, 128),\r\n...         compression='jpeg',\r\n...         resolutionunit='centimeter',\r\n...         maxworkers=2\r\n...     )\r\n...     tif.write(\r\n...         data,\r\n...         subifds=subresolutions,\r\n...         resolution=(1e4 / pixelsize, 1e4 / pixelsize),\r\n...         metadata=metadata,\r\n...         **options\r\n...     )\r\n...     # write pyramid levels to the two subifds\r\n...     # in production use resampling to generate sub-resolution images\r\n...     for level in range(subresolutions):\r\n...         mag = 2**(level + 1)\r\n...         tif.write(\r\n...             data[..., ::mag, ::mag, :],\r\n...             subfiletype=1,\r\n...             resolution=(1e4 / mag / pixelsize, 1e4 / mag / pixelsize),\r\n...             **options\r\n...         )\r\n...     # add a thumbnail image as a separate series\r\n...     # it is recognized by qupath as an associated image\r\n...     thumbnail = (data[0, 0, ::8, ::8] >> 2).astype('uint8')\r\n...     tif.write(thumbnail, metadata={'name': 'thumbnail'})\r\n\r\naccess the image levels in the pyramidal ome-tiff file:\r\n\r\n>>> baseimage = imread('temp.ome.tif')\r\n>>> second_level = imread('temp.ome.tif', series=0, level=1)\r\n>>> with tifffile('temp.ome.tif') as tif:\r\n...     baseimage = tif.series[0].asarray()\r\n...     second_level = tif.series[0].levels[1].asarray()\r\n\r\niterate over and decode single jpeg compressed tiles in the tiff file:\r\n\r\n>>> with tifffile('temp.ome.tif') as tif:\r\n...     fh = tif.filehandle\r\n...     for page in tif.pages:\r\n...         for index, (offset, bytecount) in enumerate(\r\n...             zip(page.dataoffsets, page.databytecounts)\r\n...         ):\r\n...             _ = fh.seek(offset)\r\n...             data = fh.read(bytecount)\r\n...             tile, indices, shape = page.decode(\r\n...                 data, index, jpegtables=page.jpegtables\r\n...             )\r\n\r\nuse zarr to read parts of the tiled, pyramidal images in the tiff file:\r\n\r\n>>> import zarr\r\n>>> store = imread('temp.ome.tif', aszarr=true)\r\n>>> z = zarr.open(store, mode='r')\r\n>>> z\r\n<zarr.hierarchy.group '/' read-only>\r\n>>> z[0]  # base layer\r\n<zarr.core.array '/0' (8, 2, 512, 512, 3) uint8 read-only>\r\n>>> z[0][2, 0, 128:384, 256:].shape  # read a tile from the base layer\r\n(256, 256, 3)\r\n>>> store.close()\r\n\r\nload the base layer from the zarr store as a dask array:\r\n\r\n>>> import dask.array\r\n>>> store = imread('temp.ome.tif', aszarr=true)\r\n>>> dask.array.from_zarr(store, 0)\r\ndask.array<...shape=(8, 2, 512, 512, 3)...chunksize=(1, 1, 128, 128, 3)...\r\n>>> store.close()\r\n\r\nwrite the zarr store to a fsspec referencefilesystem in json format:\r\n\r\n>>> store = imread('temp.ome.tif', aszarr=true)\r\n>>> store.write_fsspec('temp.ome.tif.json', url='file://')\r\n>>> store.close()\r\n\r\nopen the fsspec referencefilesystem as a zarr group:\r\n\r\n>>> import fsspec\r\n>>> import imagecodecs.numcodecs\r\n>>> imagecodecs.numcodecs.register_codecs()\r\n>>> mapper = fsspec.get_mapper(\r\n...     'reference://', fo='temp.ome.tif.json', target_protocol='file'\r\n... )\r\n>>> z = zarr.open(mapper, mode='r')\r\n>>> z\r\n<zarr.hierarchy.group '/' read-only>\r\n\r\ncreate an ome-tiff file containing an empty, tiled image series and write\r\nto it via the zarr interface (note: this does not work with compression):\r\n\r\n>>> imwrite(\r\n...     'temp.ome.tif',\r\n...     shape=(8, 800, 600),\r\n...     dtype='uint16',\r\n...     photometric='minisblack',\r\n...     tile=(128, 128),\r\n...     metadata={'axes': 'cyx'}\r\n... )\r\n>>> store = imread('temp.ome.tif', mode='r+', aszarr=true)\r\n>>> z = zarr.open(store, mode='r+')\r\n>>> z\r\n<zarr.core.array (8, 800, 600) uint16>\r\n>>> z[3, 100:200, 200:300:2] = 1024\r\n>>> store.close()\r\n\r\nread images from a sequence of tiff files as numpy array using two i/o worker\r\nthreads:\r\n\r\n>>> imwrite('temp_c001t001.tif', numpy.random.rand(64, 64))\r\n>>> imwrite('temp_c001t002.tif', numpy.random.rand(64, 64))\r\n>>> image_sequence = imread(\r\n...     ['temp_c001t001.tif', 'temp_c001t002.tif'], ioworkers=2, maxworkers=1\r\n... )\r\n>>> image_sequence.shape\r\n(2, 64, 64)\r\n>>> image_sequence.dtype\r\ndtype('float64')\r\n\r\nread an image stack from a series of tiff files with a file name pattern\r\nas numpy or zarr arrays:\r\n\r\n>>> image_sequence = tiffsequence(\r\n...     'temp_c0*.tif', pattern=r'_(c)(\\d+)(t)(\\d+)'\r\n... )\r\n>>> image_sequence.shape\r\n(1, 2)\r\n>>> image_sequence.axes\r\n'ct'\r\n>>> data = image_sequence.asarray()\r\n>>> data.shape\r\n(1, 2, 64, 64)\r\n>>> store = image_sequence.aszarr()\r\n>>> zarr.open(store, mode='r')\r\n<zarr.core.array (1, 2, 64, 64) float64 read-only>\r\n>>> image_sequence.close()\r\n\r\nwrite the zarr store to a fsspec referencefilesystem in json format:\r\n\r\n>>> store = image_sequence.aszarr()\r\n>>> store.write_fsspec('temp.json', url='file://')\r\n\r\nopen the fsspec referencefilesystem as a zarr array:\r\n\r\n>>> import fsspec\r\n>>> import tifffile.numcodecs\r\n>>> tifffile.numcodecs.register_codec()\r\n>>> mapper = fsspec.get_mapper(\r\n...     'reference://', fo='temp.json', target_protocol='file'\r\n... )\r\n>>> zarr.open(mapper, mode='r')\r\n<zarr.core.array (1, 2, 64, 64) float64 read-only>\r\n\r\ninspect the tiff file from the command line::\r\n\r\n    $ python -m tifffile temp.ome.tif\r\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "tifffile",
  "package_url": "https://pypi.org/project/tifffile/",
  "project_url": "https://pypi.org/project/tifffile/",
  "project_urls": {
    "Bug Tracker": "https://github.com/cgohlke/tifffile/issues",
    "Homepage": "https://www.cgohlke.com",
    "Source Code": "https://github.com/cgohlke/tifffile"
  },
  "release_url": "https://pypi.org/project/tifffile/2023.12.9/",
  "requires_dist": [
    "numpy",
    "imagecodecs >=2023.8.12 ; extra == 'all'",
    "matplotlib ; extra == 'all'",
    "defusedxml ; extra == 'all'",
    "lxml ; extra == 'all'",
    "zarr ; extra == 'all'",
    "fsspec ; extra == 'all'"
  ],
  "requires_python": ">=3.9",
  "summary": "read and write tiff files",
  "version": "2023.12.9",
  "releases": [],
  "developers": [
    "cgohlke@cgohlke.com",
    "christoph_gohlke"
  ],
  "kwds": "tifffile tiff_tags geotiff tiffwriter bioimaging",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_tifffile",
  "homepage": "https://www.cgohlke.com",
  "release_count": 122,
  "dependency_ids": [
    "pypi_defusedxml",
    "pypi_fsspec",
    "pypi_imagecodecs",
    "pypi_lxml",
    "pypi_matplotlib",
    "pypi_numpy",
    "pypi_zarr"
  ]
}