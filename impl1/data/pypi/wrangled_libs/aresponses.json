{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "\n\n# aresponses\n\n[![image](https://img.shields.io/pypi/v/aresponses.svg)](https://pypi.org/project/aresponses/)\n[![image](https://img.shields.io/pypi/pyversions/aresponses.svg)](https://pypi.org/project/aresponses/)\n[![build status](https://github.com/circleup/aresponses/workflows/python%20checks/badge.svg)](https://github.com/circleup/aresponses/actions?query=branch%3amaster)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\n\nan asyncio testing server for mocking external services\n\n## features\n - fast mocks using actual network connections\n - allows mocking some types of network issues\n - use regular expression matching for domain, path, method, or body\n - works with https requests as well (by switching them to http requests)\n - works with callables\n\n## usage\n\nadd routes and responses via the `aresponses.add` method:\n\n```python\ndef add(\n    host_pattern=any, \n    path_pattern=any, \n    method_pattern=any, \n    response=\"\", \n    *, \n    route=none, \n    body_pattern=any, m\n    match_querystring=false, \n    repeat=1\n    )\n```\n\nwhen a request is received the first matching response will be returned\nand removed from the routing table.  the `response` argument can be\neither a string, response, dict, or list.  use `aresponses.response`\nwhen you need to do something more complex.\n\n\n**note that version >=2.0 requires explicit assertions!**\n```python\n@pytest.mark.asyncio\nasync def test_simple(aresponses):\n    aresponses.add(\"google.com\", \"/api/v1/\", \"get\", response=\"ok\")\n    aresponses.add('foo.com', '/', 'get', aresponses.response(text='error', status=500))\n\n    async with aiohttp.clientsession() as session:\n        async with session.get(\"http://google.com/api/v1/\") as response:\n            text = await response.text()\n            assert text == \"ok\"\n\n        async with session.get(\"https://foo.com\") as response:\n            text = await response.text()\n            assert text == \"error\"\n\n    aresponses.assert_plan_strictly_followed()\n```\n\n#### assertions\nin aresponses 1.x requests that didn't match a route stopped the event\nloop and thus forced an exception.  in aresponses >2.x it's required to\nmake assertions at the end of the test.\n\nthere are three assertions functions provided:\n- `aresponses.assert_no_unused_routes` raises `unusedrouteerror` if all\nthe routes defined were not used up.\n- `aresponses.assert_called_in_order` - raises `unorderedroutecallerror`\nif the routes weren't called in the order they were defined.\n- `aresponses.assert_all_requests_matched` - raises `noroutefounderror`\nif any requests were made that didn't match to a route.  it's likely\nbut not guaranteed that your code will throw an exception in this\nsituation before the assertion is reached.\n\ninstead of calling these individually, **it's recommended to call\n`aresponses.assert_plan_strictly_followed()` at the end of each test as\nit runs all three of the above assertions.**\n\n\n#### regex and repeat\n`host_pattern`, `path_pattern`, `method_pattern` and `body_pattern` may\nbe either strings (exact match) or regular expressions.\n\nthe repeat argument permits a route to be used multiple times.\n\nif you want to just blanket mock a service, without concern for how many\ntimes its called you could set repeat to a large number and not call\n`aresponses.assert_plan_strictly_followed` or\n`arespones.assert_no_unused_routes`.\n\n```python\n@pytest.mark.asyncio\nasync def test_regex_repetition(aresponses):\n    aresponses.add(re.compile(r\".*\\.?google\\.com\"), response=\"ok\", repeat=2)\n\n    async with aiohttp.clientsession() as session:\n        async with session.get(\"http://google.com\") as response:\n            text = await response.text()\n            assert text == \"ok\"\n\n        async with session.get(\"http://api.google.com\") as response:\n            text = await response.text()\n            assert text == \"ok\"\n\n    aresponses.assert_plan_strictly_followed()\n```\n\n#### json responses\nas a convenience, if a dict or list is passed to `response` then it will\ncreate a json response. a `aiohttp.web_response.json_response` object\ncan be used for more complex situations.\n\n```python\n@pytest.mark.asyncio\nasync def test_json(aresponses):\n    aresponses.add(\"google.com\", \"/api/v1/\", \"get\", response={\"status\": \"ok\"})\n\n    async with aiohttp.clientsession() as session:\n        async with session.get(\"http://google.com/api/v1/\") as response:\n            assert {\"status\": \"ok\"} == await response.json()\n\n    aresponses.assert_plan_strictly_followed()\n```\n\n#### custom handler\n\ncustom functions can be used for whatever other complex logic is\ndesired. in example below the handler is set to repeat infinitely\nand always return 500.\n\n```python\nimport math\n\n@pytest.mark.asyncio\nasync def test_handler(aresponses):\n    def break_everything(request):\n        return aresponses.response(status=500, text=str(request.url))\n\n    aresponses.add(response=break_everything, repeat=math.inf)\n\n    async with aiohttp.clientsession() as session:\n        async with session.get(\"http://google.com/api/v1/\") as response:\n            assert response.status == 500\n```\n\n\n#### passthrough\npass `aresponses.passthrough` into the response argument to allow a\nrequest to bypass mocking.\n\n```python\n    aresponses.add('httpstat.us', '/200', 'get', aresponses.passthrough)\n```\n\n#### inspecting history\nhistory of calls can be inspected via `aresponses.history` which returns\nthe namedtuple `routinglog(request, route, response)`\n\n```python\n@pytest.mark.asyncio\nasync def test_history(aresponses):\n    aresponses.add(response=aresponses.response(text=\"hi\"), repeat=2)\n\n    async with aiohttp.clientsession() as session:\n        async with session.get(\"http://foo.com/b\") as response:\n            await response.text()\n        async with session.get(\"http://bar.com/a\") as response:\n            await response.text()\n\n    assert len(aresponses.history) == 2\n    assert aresponses.history[0].request.host == \"foo.com\"\n    assert aresponses.history[1].request.host == \"bar.com\"\n    assert \"route(\" in repr(aresponses.history[0].route)\n    aresponses.assert_plan_strictly_followed()\n```\n\n#### context manager usage\n```python\nimport aiohttp\nimport pytest\nimport aresponses\n\n\n@pytest.mark.asyncio\nasync def test_foo(event_loop):\n    async with aresponses.responsesmockserver(loop=event_loop) as arsps:\n        arsps.add('foo.com', '/', 'get', 'hi there!!')\n        arsps.add(arsps.any, '/', 'get', arsps.response(text='hey!'))\n\n        async with aiohttp.clientsession(loop=event_loop) as session:\n            async with session.get('http://foo.com') as response:\n                text = await response.text()\n                assert text == 'hi'\n\n            async with session.get('https://google.com') as response:\n                text = await response.text()\n                assert text == 'hey!'\n\n```\n\n#### working with [pytest-aiohttp](https://github.com/aio-libs/pytest-aiohttp)\n\nif you need to use aresponses together with pytest-aiohttp, you should re-initialize main aresponses fixture with `loop` fixture\n```python\nfrom aresponses import responsesmockserver\n\n@pytest.fixture\nasync def aresponses(loop):\n    async with responsesmockserver(loop=loop) as server:\n        yield server\n```\n\nif you're trying to use the `aiohttp_client` test fixture then you'll need to mock out the aiohttp `loop` fixture\ninstead:\n```python\n@pytest.fixture\ndef loop(event_loop):\n    \"\"\"replace aiohttp loop fixture with pytest-asyncio fixture\"\"\"\n    return event_loop\n```\n\n## contributing\n\n### dev environment setup\n  - **install pyenv and pyenv-virtualenv**  - makes it easy to install specific versions of python and switch between them. make sure you install the virtualenv bash hook\n  - `git clone` the repo and `cd` into it.\n  - `make init` - installs proper version of python, creates the virtual environment, activates it and installs all the requirements\n\n### submitting a feature request  \n  - **`git checkout -b my-feature-branch`** \n  - **make some cool changes**\n  - **`make autoformat`**\n  - **`make test`**\n  - **`make lint`**\n  - **create pull request**\n\n### updating package on pypi\n  - `make deploy`\n\n\n## changelog\n\n#### 2.1.6\n- fix: incorrect pytest plugin entrypoint name (#72)\n\n#### 2.1.5\n- support asyncio_mode = strict (#68)\n\n#### 2.1.4\n- fix: don't assume utf8 request contents\n\n#### 2.1.3\n- accidental no-op release\n\n#### 2.1.2\n- documentation: add pypi documentation\n\n#### 2.1.1\n\n- bugfix: recursionerror when aresponses is used in more than 1000 tests (#63)\n\n#### 2.1.0\n- feature: add convenience method `add_local_passthrough`\n- bugfix: fix https subrequest mocks. support aiohttp_client compatibility\n\n#### 2.0.2\n- bugfix: ensure request body is available in history\n\n#### 2.0.0\n**warning! breaking changes!**\n- breaking change: require explicit assertions for test failures\n- feature: autocomplete works in intellij/pycharm\n- feature: can match on body of request\n- feature: store calls made\n- feature: repeated responses\n- bugfix: no longer stops event loop\n- feature: if dict or list is passed into `response`, a json response\nwill be generated\n\n\n#### 1.1.2\n- make passthrough feature work with binary data\n\n#### 1.1.1\n- regex fix for python 3.7.0\n\n#### 1.1.0\n- added passthrough option to permit live network calls\n- added example of using a callable as a response\n\n#### 1.0.0\n\n- added an optional `match_querystring` argument that lets you match on querystring as well\n\n\n## contributors\n* bryce drennan, circleup <aresponses@brycedrennan.com>\n* marco castelluccio, mozilla <mcastelluccio@mozilla.com>\n* jesse vogt, circleup <jesse.vogt@gmail.com>\n* pavol vargovcik, kiwi.com <pavol.vargovcik@gmail.com>\n\n\n",
  "docs_url": null,
  "keywords": "asyncio,testing,responses",
  "license": "",
  "name": "aresponses",
  "package_url": "https://pypi.org/project/aresponses/",
  "project_url": "https://pypi.org/project/aresponses/",
  "project_urls": {
    "Download": "https://github.com/circleup/aresponses/tarball/2.1.6",
    "Homepage": "https://github.com/circleup/aresponses"
  },
  "release_url": "https://pypi.org/project/aresponses/2.1.6/",
  "requires_dist": [
    "aiohttp (==3.*,>=3.1.0)",
    "pytest-asyncio"
  ],
  "requires_python": ">=3.6",
  "summary": "asyncio response mocking. similar to the responses library used for 'requests'",
  "version": "2.1.6",
  "releases": [],
  "developers": [
    "aresponses@brycedrennan.com",
    "bryce_drennan"
  ],
  "kwds": "asyncio_mode asyncio pytest assert_all_requests_matched badge",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_aresponses",
  "homepage": "https://github.com/circleup/aresponses",
  "release_count": 24,
  "dependency_ids": [
    "pypi_aiohttp",
    "pypi_pytest_asyncio"
  ]
}