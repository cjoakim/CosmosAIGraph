{
  "classifiers": [
    "intended audience :: developers",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6"
  ],
  "description": "# flasgger\n## easy swagger ui for your flask api\n\n[![build status](https://travis-ci.com/flasgger/flasgger.svg?branch=master)](https://travis-ci.com/flasgger/flasgger)\n[![code health](https://landscape.io/github/rochacbruno/flasgger/master/landscape.svg?style=flat)](https://landscape.io/github/rochacbruno/flasgger/master)\n[![coverage status](https://coveralls.io/repos/github/rochacbruno/flasgger/badge.svg?branch=master)](https://coveralls.io/github/rochacbruno/flasgger?branch=master)\n[![pypi](https://img.shields.io/pypi/v/flasgger.svg)](https://pypi.python.org/pypi/flasgger)\n <a target=\"_blank\" href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;business=rochacbruno%40gmail%2ecom&amp;lc=br&amp;item_name=flasgger&amp;no_note=0&amp;currency_code=usd&amp;bn=pp%2ddonationsbf%3abtn_donate_sm%2egif%3anonhostedguest\"><img alt='donate with paypal' src='http://www.paypalobjects.com/en_us/i/btn/btn_donate_sm.gif' /></a>\n\n\n![flasgger](docs/flasgger.png)\n\nflasgger is a flask extension to **extract [openapi-specification](https://github.com/oai/openapi-specification/blob/master/versions/2.0.md#operation-object)** from all flask views registered in your api.\n\nflasgger also comes with **[swaggerui](http://swagger.io/swagger-ui/) embedded** so you can access [http://localhost:5000/apidocs](localhost:5000/apidocs) and visualize and interact with your api resources.\n\nflasgger also **provides validation** of the incoming data, using the same specification it can validates if the data received as as a post, put, patch is valid against the schema defined using **yaml**, **python dictionaries** or **marshmallow schemas**.\n\nflasgger can work with simple function views or methodviews using docstring as specification, or using `@swag_from` decorator to get specification from **yaml** or **dict** and also provides **swaggerview** which can use **marshmallow schemas**  as specification.\n\nflasgger is compatible with `flask-restful` so you can use `resources` and `swag` specifications together, take a look at [restful example.](examples/restful.py)\n\nflasgger also supports `marshmallow apispec` as base template for specification, if you are using apispec from marshmallow take a look at [apispec example.](examples/apispec_example.py)\n\ntable of contents\n=================\n\n* [top contributors](#top-contributors)\n* [examples and demo app](#examples-and-demo-app)\n  * [docker](#docker)\n* [installation](#installation)\n* [getting started](#getting-started)\n  * [using docstrings as specification](#using-docstrings-as-specification)\n  * [using external yaml files](#using-external-yaml-files)\n  * [using dictionaries as raw specs](#using-dictionaries-as-raw-specs)\n  * [using marshmallow schemas](#using-marshmallow-schemas)\n  * [using <strong>flask restful</strong> resources](#using-flask-restful-resources)\n  * [auto-parsing external yaml docs and methodviews](#auto-parsing-external-yaml-docs-and-methodviews)\n  * [handling multiple http methods and routes for a single function](#handling-multiple-http-methods-and-routes-for-a-single-function)\n* [use the same data to validate your api post body.](#use-the-same-data-to-validate-your-api-post-body)\n     * [custom validation](#custom-validation)\n     * [validation error handling](#validation-error-handling)\n* [get defined schemas as python dictionaries](#get-defined-schemas-as-python-dictionaries)\n* [html sanitizer](#html-sanitizer)\n* [swagger ui and templates](#swagger-ui-and-templates)\n* [openapi 3.0 support](#openapi-30-support)\n  * [externally loading swagger ui and jquery js/css](#externally-loading-swagger-ui-and-jquery-jscss)\n* [initializing flasgger with default data.](#initializing-flasgger-with-default-data)\n  * [getting default data at runtime](#getting-default-data-at-runtime)\n  * [behind a reverse proxy](#behind-a-reverse-proxy)\n* [customize default configurations](#customize-default-configurations)\n  * [extracting definitions](#extracting-definitions)\n  * [python2 compatibility](#python2-compatibility)\n\ncreated by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)\n\n# top contributors\n\n[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/0)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/0)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/1)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/1)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/2)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/2)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/3)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/3)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/4)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/4)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/5)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/5)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/6)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/6)[![](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/images/7)](https://sourcerer.io/fame/rochacbruno/rochacbruno/flasgger/links/7)\n\n# examples and demo app\n\nthere are some [example applications](examples/) and you can also play with examples in [flasgger demo app](http://flasgger.pythonanywhere.com/)\n\n> note: all the examples apps are also test cases and run automatically in travis ci to ensure quality and coverage.\n\n## docker\n\nthe examples and demo app can also be built and run as a docker image/container:\n\n```\ndocker build -t flasgger .\ndocker run -it --rm -p 5000:5000 --name flasgger flasgger\n```\nthen access the flasgger demo app at http://localhost:5000 .\n\n# installation\n\n> under your virtualenv do:\n\nensure you have latest setuptools\n```\npip install -u setuptools\n```\n\nthen install beta version (recommended)\n\n```\npip install flasgger==0.9.7b2\n```\n\nor (latest stable for legacy apps)\n\n```\npip install flasgger==0.9.5\n```\n\nor (dev version)\n\n```\npip install https://github.com/flasgger/flasgger/tarball/master\n```\n\n> note: if you want to use **marshmallow schemas** you also need to run `pip install marshmallow apispec`\n\n## how to run tests\n\n(you may see the command in [.travis.yml](./.travis.yml) for `before_install` part)\n\nin your virtualenv:\n\n```\npip install -r requirements.txt\npip install -r requirements-dev.txt\nmake test\n```\n\n# getting started\n\n## using docstrings as specification\n\ncreate a file called for example `colors.py`\n\n```python\nfrom flask import flask, jsonify\nfrom flasgger import swagger\n\napp = flask(__name__)\nswagger = swagger(app)\n\n@app.route('/colors/<palette>/')\ndef colors(palette):\n    \"\"\"example endpoint returning a list of colors by palette\n    this is using docstrings for specifications.\n    ---\n    parameters:\n      - name: palette\n        in: path\n        type: string\n        enum: ['all', 'rgb', 'cmyk']\n        required: true\n        default: all\n    definitions:\n      palette:\n        type: object\n        properties:\n          palette_name:\n            type: array\n            items:\n              $ref: '#/definitions/color'\n      color:\n        type: string\n    responses:\n      200:\n        description: a list of colors (may be filtered by palette)\n        schema:\n          $ref: '#/definitions/palette'\n        examples:\n          rgb: ['red', 'green', 'blue']\n    \"\"\"\n    all_colors = {\n        'cmyk': ['cyan', 'magenta', 'yellow', 'black'],\n        'rgb': ['red', 'green', 'blue']\n    }\n    if palette == 'all':\n        result = all_colors\n    else:\n        result = {palette: all_colors.get(palette)}\n\n    return jsonify(result)\n\napp.run(debug=true)\n```\n\nnow run:\n\n```\npython colors.py\n```\n\nand go to: [http://localhost:5000/apidocs/](http://localhost:5000/apidocs/)\n\nyou should get:\n\n![colors](docs/colors.png)\n\n## using external yaml files\n\nsave a new file `colors.yml`\n\n```yaml\nexample endpoint returning a list of colors by palette\nin this example the specification is taken from external yaml file\n---\nparameters:\n  - name: palette\n    in: path\n    type: string\n    enum: ['all', 'rgb', 'cmyk']\n    required: true\n    default: all\ndefinitions:\n  palette:\n    type: object\n    properties:\n      palette_name:\n        type: array\n        items:\n          $ref: '#/definitions/color'\n  color:\n    type: string\nresponses:\n  200:\n    description: a list of colors (may be filtered by palette)\n    schema:\n      $ref: '#/definitions/palette'\n    examples:\n      rgb: ['red', 'green', 'blue']\n```\n\n\nlets use the same example changing only the view function.\n\n```python\nfrom flasgger import swag_from\n\n@app.route('/colors/<palette>/')\n@swag_from('colors.yml')\ndef colors(palette):\n    ...\n```\n\nif you do not want to use the decorator you can use the docstring `file:` shortcut.\n\n```python\n@app.route('/colors/<palette>/')\ndef colors(palette):\n    \"\"\"\n    file: colors.yml\n    \"\"\"\n    ...\n```\n\n\n## using dictionaries as raw specs\n\ncreate a python dictionary as:\n\n```python\nspecs_dict = {\n  \"parameters\": [\n    {\n      \"name\": \"palette\",\n      \"in\": \"path\",\n      \"type\": \"string\",\n      \"enum\": [\n        \"all\",\n        \"rgb\",\n        \"cmyk\"\n      ],\n      \"required\": \"true\",\n      \"default\": \"all\"\n    }\n  ],\n  \"definitions\": {\n    \"palette\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"palette_name\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/definitions/color\"\n          }\n        }\n      }\n    },\n    \"color\": {\n      \"type\": \"string\"\n    }\n  },\n  \"responses\": {\n    \"200\": {\n      \"description\": \"a list of colors (may be filtered by palette)\",\n      \"schema\": {\n        \"$ref\": \"#/definitions/palette\"\n      },\n      \"examples\": {\n        \"rgb\": [\n          \"red\",\n          \"green\",\n          \"blue\"\n        ]\n      }\n    }\n  }\n}\n```\n\nnow take the same function and use the dict in the place of yaml file.\n\n```python\n@app.route('/colors/<palette>/')\n@swag_from(specs_dict)\ndef colors(palette):\n    \"\"\"example endpoint returning a list of colors by palette\n    in this example the specification is taken from specs_dict\n    \"\"\"\n    ...\n```\n\n## using marshmallow schemas\n\n> first: `pip install marshmallow apispec`\n\n> usage #1: `swaggerview`\n\n```python\nfrom flask import flask, jsonify\nfrom flasgger import swagger, swaggerview, schema, fields\n\n\nclass color(schema):\n    name = fields.str()\n\nclass palette(schema):\n    pallete_name = fields.str()\n    colors = fields.nested(color, many=true)\n\nclass paletteview(swaggerview):\n    parameters = [\n        {\n            \"name\": \"palette\",\n            \"in\": \"path\",\n            \"type\": \"string\",\n            \"enum\": [\"all\", \"rgb\", \"cmyk\"],\n            \"required\": true,\n            \"default\": \"all\"\n        }\n    ]\n    responses = {\n        200: {\n            \"description\": \"a list of colors (may be filtered by palette)\",\n            \"schema\": palette\n        }\n    }\n\n    def get(self, palette):\n        \"\"\"\n        colors api using schema\n        this example is using marshmallow schemas\n        \"\"\"\n        all_colors = {\n            'cmyk': ['cyan', 'magenta', 'yellow', 'black'],\n            'rgb': ['red', 'green', 'blue']\n        }\n        if palette == 'all':\n            result = all_colors\n        else:\n            result = {palette: all_colors.get(palette)}\n        return jsonify(result)\n\napp = flask(__name__)\nswagger = swagger(app)\n\napp.add_url_rule(\n    '/colors/<palette>',\n    view_func=paletteview.as_view('colors'),\n    methods=['get']\n)\n\napp.run(debug=true)\n\n```\n\n> usage #2: `custom schema from flasgger`\n\n- `body` - support all fields in marshmallow\n- `query` - support simple fields in marshmallow (int, string and etc)\n- `path` - support only int and str\n\n```python\nfrom flask import flask, abort\nfrom flasgger import swagger, schema, fields\nfrom marshmallow.validate import length, oneof\n\napp = flask(__name__)\nswagger(app)\n\nswag = {\"swag\": true,\n        \"tags\": [\"demo\"],\n        \"responses\": {200: {\"description\": \"success request\"},\n                      400: {\"description\": \"validation error\"}}}\n\n\nclass body(schema):\n    color = fields.list(fields.string(), required=true, validate=length(max=5), example=[\"white\", \"blue\", \"red\"])\n\n    def swag_validation_function(self, data, main_def):\n        self.load(data)\n\n    def swag_validation_error_handler(self, err, data, main_def):\n        abort(400, err)\n\n\nclass query(schema):\n    color = fields.string(required=true, validate=oneof([\"white\", \"blue\", \"red\"]))\n\n    def swag_validation_function(self, data, main_def):\n        self.load(data)\n\n    def swag_validation_error_handler(self, err, data, main_def):\n        abort(400, err)\n\n    swag_in = \"query\"\n\n\n@app.route(\"/color/<id>/<name>\", methods=[\"post\"], **swag)\ndef index(body: body, query: query, id: int, name: str):\n    return {\"body\": body, \"query\": query, \"id\": id, \"name\": name}\n\nif __name__ == \"__main__\":\n    app.run(debug=true)\n```\n\n\n> note: take a look at `examples/validation.py` for a more complete example.\n\n\n> note: when catching arguments in path rule always use explicit types, bad: ``/api/<username>`` good: ``/api/<string:username>``\n\n\n## using **flask restful** resources\n\nflasgger is compatible with flask-restful you only need to install `pip install flask-restful` and then:\n\n```python\nfrom flask import flask\nfrom flasgger import swagger\nfrom flask_restful import api, resource\n\napp = flask(__name__)\napi = api(app)\nswagger = swagger(app)\n\nclass username(resource):\n    def get(self, username):\n        \"\"\"\n        this examples uses flaskrestful resource\n        it works also with swag_from, schemas and spec_dict\n        ---\n        parameters:\n          - in: path\n            name: username\n            type: string\n            required: true\n        responses:\n          200:\n            description: a single user item\n            schema:\n              id: user\n              properties:\n                username:\n                  type: string\n                  description: the name of the user\n                  default: steven wilson\n        \"\"\"\n        return {'username': username}, 200\n\n\napi.add_resource(username, '/username/<username>')\n\napp.run(debug=true)\n```\n\n## auto-parsing external yaml docs and `methodview`s\n\nflasgger can be configured to auto-parse external yaml api docs.  [set a `doc_dir`](https://github.com/rochacbruno/flasgger/blob/aaef05c17cc559d01b7436211093463642eb6ae2/examples/parsed_view_func.py#l16) in your `app.config['swagger']` and swagger will load api docs by looking in `doc_dir` for yaml files stored by endpoint-name and method-name.  for example, `'doc_dir': './examples/docs/'` and a file `./examples/docs/items/get.yml` will provide a swagger doc for `itemsview` method `get`.\n\nadditionally, when using **flask restful** per above, by passing `parse=true` when constructing `swagger`, flasgger will use  `flask_restful.reqparse.requestparser`, locate all `methodview`s and parsed and validated data will be stored in `flask.request.parsed_data`.\n\n## handling multiple http methods and routes for a single function\n\nyou can separate specifications by endpoint or methods\n\n```python\nfrom flasgger.utils import swag_from\n\n@app.route('/api/<string:username>', endpoint='with_user_name', methods=['put', 'get'])\n@app.route('/api/', endpoint='without_user_name')\n@swag_from('path/to/external_file.yml', endpoint='with_user_name')\n@swag_from('path/to/external_file_no_user_get.yml', endpoint='without_user_name', methods=['get'])\n@swag_from('path/to/external_file_no_user_put.yml', endpoint='without_user_name', methods=['put'])\ndef fromfile_decorated(username=none):\n    if not username:\n        return \"no user!\"\n    return jsonify({'username': username})\n```\n\nand the same can be achieved with multiple methods in a `methodview` or `swaggerview` by\nregistering the `url_rule` many times. take a look at `examples/example_app`\n\n\n# use the same data to validate your api post body.\n\nsetting `swag_from`'s _validation_ parameter to `true` will validate incoming data automatically:\n\n```python\nfrom flasgger import swag_from\n\n@swag_from('defs.yml', validation=true)\ndef post():\n    # if not validate returns validationerror response with status 400\n    # also returns the validation message.\n```\n\nusing `swagger.validate` annotation is also possible:\n\n```python\nfrom flasgger import swagger\n\nswagger = swagger(app)\n\n@swagger.validate('userschema')\ndef post():\n    '''\n    file: defs.yml\n    '''\n    # if not validate returns validationerror response with status 400\n    # also returns the validation message.\n```\n\nyet you can call `validate` manually:\n\n```python\nfrom flasgger import swag_from, validate\n\n@swag_from('defs.yml')\ndef post():\n    validate(request.json, 'userschema', 'defs.yml')\n    # if not validate returns validationerror response with status 400\n    # also returns the validation message.\n```\n\nit is also possible to define `validation=true` in `swaggerview` and also use\n`specs_dict` for validation.\n\ntake a look at `examples/validation.py` for more information.\n\nall validation options can be found at http://json-schema.org/latest/json-schema-validation.html\n\n### custom validation\n\nby default flasgger will use [python-jsonschema](https://python-jsonschema.readthedocs.io/en/latest/)\nto perform validation.\n\ncustom validation functions are supported as long as they meet the requirements:\n - take two, and only two, positional arguments:\n    - the data to be validated as the first; and\n    - the schema to validate against as the second argument\n - raise any kind of exception when validation fails.\n\nany return value is discarded.\n\n\nproviding the function to the swagger instance will make it the default:\n\n```python\nfrom flasgger import swagger\n\nswagger = swagger(app, validation_function=my_validation_function)\n```\n\nproviding the function as parameter of `swag_from` or `swagger.validate`\nannotations or directly to the `validate` function will force it's use\nover the default validation function for swagger:\n\n```python\nfrom flasgger import swag_from\n\n@swag_from('spec.yml', validation=true, validation_function=my_function)\n...\n```\n\n```python\nfrom flasgger import swagger\n\nswagger = swagger(app)\n\n@swagger.validate('pet', validation_function=my_function)\n...\n```\n\n```python\nfrom flasgger import validate\n\n...\n\n    validate(\n        request.json, 'pet', 'defs.yml', validation_function=my_function)\n```\n\n### validation error handling\n\nby default flasgger will handle validation errors by aborting the\nrequest with a 400 bad request response with the error message.\n\na custom validation error handling function can be provided to\nsupersede default behavior as long as it meets the requirements:\n - take three, and only three, positional arguments:\n    - the error raised as the first;\n    - the data which failed validation as the second; and\n    - the schema used in to validate as the third argument\n\n\nproviding the function to the swagger instance will make it the default:\n\n```python\nfrom flasgger import swagger\n\nswagger = swagger(app, validation_error_handler=my_handler)\n```\n\nproviding the function as parameter of `swag_from` or `swagger.validate`\nannotations or directly to the `validate` function will force it's use\nover the default validation function for swagger:\n\n```python\nfrom flasgger import swag_from\n\n@swag_from(\n    'spec.yml', validation=true, validation_error_handler=my_handler)\n...\n```\n\n```python\nfrom flasgger import swagger\n\nswagger = swagger(app)\n\n@swagger.validate('pet', validation_error_handler=my_handler)\n...\n```\n\n```python\nfrom flasgger import validate\n\n...\n\n    validate(\n        request.json, 'pet', 'defs.yml',\n        validation_error_handler=my_handler)\n```\n\nexamples of use of a custom validation error handler function can be\nfound at [example validation_error_handler.py](examples/validation_error_handler.py)\n\n# get defined schemas as python dictionaries\n\nyou may wish to use schemas you defined in your swagger specs as dictionaries\nwithout replicating the specification. for that you can use the `get_schema`\nmethod:\n\n```python\nfrom flask import flask, jsonify\nfrom flasgger import swagger, swag_from\n\napp = flask(__name__)\nswagger = swagger(app)\n\n@swagger.validate('product')\ndef post():\n    \"\"\"\n    post endpoint\n    ---\n    tags:\n      - products\n    parameters:\n      - name: body\n        in: body\n        required: true\n        schema:\n          id: product\n          required:\n            - name\n          properties:\n            name:\n              type: string\n              description: the product's name.\n              default: \"guarana\"\n    responses:\n      200:\n        description: the product inserted in the database\n        schema:\n          $ref: '#/definitions/product'\n    \"\"\"\n    rv = db.insert(request.json)\n    return jsonify(rv)\n\n...\n\nproduct_schema = swagger.get_schema('product')\n```\n\nthis method returns a dictionary which contains the flasgger schema id,\nall defined parameters and a list of required parameters.\n\n# html sanitizer\n\nby default flasgger will try to sanitize the content in yaml definitions\nreplacing every ```\\n``` with ```<br>``` but you can change this behaviour\nsetting another kind of sanitizer.\n\n```python\nfrom flasgger import swagger, no_sanitizer\n\napp =flask()\nswagger = swagger(app, sanitizer=no_sanitizer)\n```\n\nyou can write your own sanitizer\n\n```python\nswagger = swagger(app, sanitizer=lambda text: do_anything_with(text))\n```\n\nthere is also a markdown parser available, if you want to be able to render\nmarkdown in your specs description use **mk_sanitizer**\n\n\n# swagger ui and templates\n\nyou can override the `templates/flasgger/index.html` in your application and\nthis template will be the `index.html` for swaggerui. use `flasgger/ui2/templates/index.html`\nas base for your customization.\n\nflasgger supports swagger ui versions 2 and 3, the version 3 is still experimental but you\ncan try setting `app.config['swagger']['uiversion']`.\n\n```python\napp = flask(__name__)\napp.config['swagger'] = {\n    'title': 'my api',\n    'uiversion': 3\n}\nswagger = swagger(app)\n\n```\n\n# openapi 3.0 support\n\nthere is experimental support for openapi 3.0 that should work when using swaggerui 3. to use openapi 3.0, set `app.config['swagger']['openapi']` to a version that the current swaggerui 3 supports such as `'3.0.2'`.\n\nfor an example of this that uses `callbacks` and `requestbody`, see the [callbacks example](examples/callbacks.py).\n\n## externally loading swagger ui and jquery js/css\n\nstarting with flasgger 0.9.2 you can specify external url locations for loading the javascript and css for the swagger and jquery libraries loaded in the flasgger default templates.  if the configuration properties below are omitted, flasgger will serve static versions it includes - these versions may be older than the current swagger ui v2 or v3 releases.\n\nthe following example loads swagger ui and jquery versions from unpkg.com:\n\n```\nswagger_config = swagger.default_config\nswagger_config['swagger_ui_bundle_js'] = '//unpkg.com/swagger-ui-dist@3/swagger-ui-bundle.js'\nswagger_config['swagger_ui_standalone_preset_js'] = '//unpkg.com/swagger-ui-dist@3/swagger-ui-standalone-preset.js'\nswagger_config['jquery_js'] = '//unpkg.com/jquery@2.2.4/dist/jquery.min.js'\nswagger_config['swagger_ui_css'] = '//unpkg.com/swagger-ui-dist@3/swagger-ui.css'\nswagger(app, config=swagger_config)\n```\n\n# initializing flasgger with default data.\n\nyou can start your swagger spec with any default data providing a template:\n\n```python\ntemplate = {\n  \"swagger\": \"2.0\",\n  \"info\": {\n    \"title\": \"my api\",\n    \"description\": \"api for my data\",\n    \"contact\": {\n      \"responsibleorganization\": \"me\",\n      \"responsibledeveloper\": \"me\",\n      \"email\": \"me@me.com\",\n      \"url\": \"www.me.com\",\n    },\n    \"termsofservice\": \"http://me.com/terms\",\n    \"version\": \"0.0.1\"\n  },\n  \"host\": \"mysite.com\",  # overrides localhost:500\n  \"basepath\": \"/api\",  # base bash for blueprint registration\n  \"schemes\": [\n    \"http\",\n    \"https\"\n  ],\n  \"operationid\": \"getmydata\"\n}\n\nswagger = swagger(app, template=template)\n\n```\n\nand then the template is the default data unless some view changes it. you\ncan also provide all your specs as template and have no views. or views in\nexternal app.\n\n## getting default data at runtime\n\nsometimes you need to get some data at runtime depending on dynamic values ex: you want to check `request.is_secure` to decide if `schemes` will be `https` you can do that by using `lazystring`.\n\n```py\nfrom flask import flask\nfrom flasgger import, swagger, lazystring, lazyjsonencoder\n\napp = flask(__init__)\n\n# set the custom encoder (inherit it if you need to customize)\napp.json_encoder = lazyjsonencoder\n\n\ntemplate = dict(\n    info={\n        'title': lazystring(lambda: 'lazy title'),\n        'version': lazystring(lambda: '99.9.9'),\n        'description': lazystring(lambda: 'hello lazy world'),\n        'termsofservice': lazystring(lambda: '/there_is_no_tos')\n    },\n    host=lazystring(lambda: request.host),\n    schemes=[lazystring(lambda: 'https' if request.is_secure else 'http')],\n    foo=lazystring(lambda: \"bar\")\n)\nswagger(app, template=template)\n\n```\n\nthe `lazystring` values will be evaluated only when `jsonify` encodes the value at runtime, so you have access to flask `request, session, g, etc..` and also may want to access a database.\n\n## behind a reverse proxy\n\nsometimes you're serving your swagger docs behind an reverse proxy (e.g. nginx).  when following the [flask guidance](http://flask.pocoo.org/snippets/35/),\nthe swagger docs will load correctly, but the \"try it out\" button points to the wrong place.  this can be fixed with the following code:\n\n```python\nfrom flask import flask, request\nfrom flasgger import swagger, lazystring, lazyjsonencoder\n\napp = flask(__name__)\napp.json_encoder = lazyjsonencoder\n\ntemplate = dict(swaggeruiprefix=lazystring(lambda : request.environ.get('http_x_script_name', '')))\nswagger = swagger(app, template=template)\n\n```\n\n# customize default configurations\n\ncustom configurations such as a different specs route or disabling swagger ui can be provided to flasgger:\n\n```python\nswagger_config = {\n    \"headers\": [\n    ],\n    \"specs\": [\n        {\n            \"endpoint\": 'apispec_1',\n            \"route\": '/apispec_1.json',\n            \"rule_filter\": lambda rule: true,  # all in\n            \"model_filter\": lambda tag: true,  # all in\n        }\n    ],\n    \"static_url_path\": \"/flasgger_static\",\n    # \"static_folder\": \"static\",  # must be set by user\n    \"swagger_ui\": true,\n    \"specs_route\": \"/apidocs/\"\n}\n\nswagger = swagger(app, config=swagger_config)\n\n```\n\n## extracting definitions\n\ndefinitions can be extracted when `id` is found in spec, example:\n\n```python\nfrom flask import flask, jsonify\nfrom flasgger import swagger\n\napp = flask(__name__)\nswagger = swagger(app)\n\n@app.route('/colors/<palette>/')\ndef colors(palette):\n    \"\"\"example endpoint returning a list of colors by palette\n    ---\n    parameters:\n      - name: palette\n        in: path\n        type: string\n        enum: ['all', 'rgb', 'cmyk']\n        required: true\n        default: all\n    responses:\n      200:\n        description: a list of colors (may be filtered by palette)\n        schema:\n          id: palette\n          type: object\n          properties:\n            palette_name:\n              type: array\n              items:\n                schema:\n                  id: color\n                  type: string\n        examples:\n          rgb: ['red', 'green', 'blue']\n    \"\"\"\n    all_colors = {\n        'cmyk': ['cyan', 'magenta', 'yellow', 'black'],\n        'rgb': ['red', 'green', 'blue']\n    }\n    if palette == 'all':\n        result = all_colors\n    else:\n        result = {palette: all_colors.get(palette)}\n\n    return jsonify(result)\n\napp.run(debug=true)\n```\n\nin this example you do not have to pass `definitions` but need to add `id` to\nyour schemas.\n\n## python2 compatibility\n\nversion `0.9.5.*` will be the last verison that supports python2.\nplease direct discussions to [#399](https://github.com/flasgger/flasgger/issues/399).\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "flasgger",
  "package_url": "https://pypi.org/project/flasgger/",
  "project_url": "https://pypi.org/project/flasgger/",
  "project_urls": {
    "Homepage": "https://github.com/flasgger/flasgger/"
  },
  "release_url": "https://pypi.org/project/flasgger/0.9.7.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "extract swagger specs from your flask project",
  "version": "0.9.7.1",
  "releases": [],
  "developers": [
    "bruno_rocha",
    "flasgger@flasgger.org"
  ],
  "kwds": "flasgger flasgger_static swaggeruiprefix swagger_ui swaggerui",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_flasgger",
  "homepage": "https://github.com/flasgger/flasgger/",
  "release_count": 54,
  "dependency_ids": []
}