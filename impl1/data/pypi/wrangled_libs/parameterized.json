{
  "classifiers": [
    "license :: osi approved :: bsd license",
    "programming language :: python :: 3"
  ],
  "description": "parameterized testing with any python test framework\n====================================================\n\n.. image:: https://img.shields.io/pypi/v/parameterized\n    :alt: pypi\n    :target: https://pypi.org/project/parameterized/\n\n.. image:: https://img.shields.io/pypi/dm/parameterized\n    :alt: pypi - downloads\n    :target: https://pypi.org/project/parameterized/\n\n.. image:: https://circleci.com/gh/wolever/parameterized.svg?style=svg\n    :alt: circle ci\n    :target: https://circleci.com/gh/wolever/parameterized\n\n\nparameterized testing in python sucks.\n\n``parameterized`` fixes that. for everything. parameterized testing for nose,\nparameterized testing for py.test, parameterized testing for unittest.\n\n.. code:: python\n\n   # test_math.py\n   from nose.tools import assert_equal\n   from parameterized import parameterized, parameterized_class\n\n   import unittest\n   import math\n\n   @parameterized([\n       (2, 2, 4),\n       (2, 3, 8),\n       (1, 9, 1),\n       (0, 9, 0),\n   ])\n   def test_pow(base, exponent, expected):\n      assert_equal(math.pow(base, exponent), expected)\n\n   class testmathunittest(unittest.testcase):\n      @parameterized.expand([\n          (\"negative\", -1.5, -2.0),\n          (\"integer\", 1, 1.0),\n          (\"large fraction\", 1.6, 1),\n      ])\n      def test_floor(self, name, input, expected):\n          assert_equal(math.floor(input), expected)\n\n   @parameterized_class(('a', 'b', 'expected_sum', 'expected_product'), [\n      (1, 2, 3, 2),\n      (5, 5, 10, 25),\n   ])\n   class testmathclass(unittest.testcase):\n      def test_add(self):\n         assert_equal(self.a + self.b, self.expected_sum)\n\n      def test_multiply(self):\n         assert_equal(self.a * self.b, self.expected_product)\n\n   @parameterized_class([\n      { \"a\": 3, \"expected\": 2 },\n      { \"b\": 5, \"expected\": -4 },\n   ])\n   class testmathclassdict(unittest.testcase):\n      a = 1\n      b = 1\n\n      def test_subtract(self):\n         assert_equal(self.a - self.b, self.expected)\n\n\nwith nose (and nose2)::\n\n    $ nosetests -v test_math.py\n    test_floor_0_negative (test_math.testmathunittest) ... ok\n    test_floor_1_integer (test_math.testmathunittest) ... ok\n    test_floor_2_large_fraction (test_math.testmathunittest) ... ok\n    test_math.test_pow(2, 2, 4, {}) ... ok\n    test_math.test_pow(2, 3, 8, {}) ... ok\n    test_math.test_pow(1, 9, 1, {}) ... ok\n    test_math.test_pow(0, 9, 0, {}) ... ok\n    test_add (test_math.testmathclass_0) ... ok\n    test_multiply (test_math.testmathclass_0) ... ok\n    test_add (test_math.testmathclass_1) ... ok\n    test_multiply (test_math.testmathclass_1) ... ok\n    test_subtract (test_math.testmathclassdict_0) ... ok\n\n    ----------------------------------------------------------------------\n    ran 12 tests in 0.015s\n\n    ok\n\nas the package name suggests, nose is best supported and will be used for all\nfurther examples.\n\n\nwith py.test (version 2.0 and above)::\n\n    $ py.test -v test_math.py\n    ============================= test session starts ==============================\n    platform darwin -- python 3.6.1, pytest-3.1.3, py-1.4.34, pluggy-0.4.0\n    collecting ... collected 13 items\n\n    test_math.py::test_pow::[0] passed\n    test_math.py::test_pow::[1] passed\n    test_math.py::test_pow::[2] passed\n    test_math.py::test_pow::[3] passed\n    test_math.py::testmathunittest::test_floor_0_negative passed\n    test_math.py::testmathunittest::test_floor_1_integer passed\n    test_math.py::testmathunittest::test_floor_2_large_fraction passed\n    test_math.py::testmathclass_0::test_add passed\n    test_math.py::testmathclass_0::test_multiply passed\n    test_math.py::testmathclass_1::test_add passed\n    test_math.py::testmathclass_1::test_multiply passed\n    test_math.py::testmathclassdict_0::test_subtract passed\n    ==================== 12 passed, 4 warnings in 0.16 seconds =====================\n\nwith unittest (and unittest2)::\n\n    $ python -m unittest -v test_math\n    test_floor_0_negative (test_math.testmathunittest) ... ok\n    test_floor_1_integer (test_math.testmathunittest) ... ok\n    test_floor_2_large_fraction (test_math.testmathunittest) ... ok\n    test_add (test_math.testmathclass_0) ... ok\n    test_multiply (test_math.testmathclass_0) ... ok\n    test_add (test_math.testmathclass_1) ... ok\n    test_multiply (test_math.testmathclass_1) ... ok\n    test_subtract (test_math.testmathclassdict_0) ... ok\n\n    ----------------------------------------------------------------------\n    ran 8 tests in 0.001s\n\n    ok\n\n(note: because unittest does not support test decorators, only tests created\nwith ``@parameterized.expand`` will be executed)\n\nwith green::\n\n    $ green test_math.py -vvv\n    test_math\n      testmathclass_1\n    .   test_method_a\n    .   test_method_b\n      testmathclass_2\n    .   test_method_a\n    .   test_method_b\n      testmathclass_3\n    .   test_method_a\n    .   test_method_b\n      testmathunittest\n    .   test_floor_0_negative\n    .   test_floor_1_integer\n    .   test_floor_2_large_fraction\n      testmathclass_0\n    .   test_add\n    .   test_multiply\n      testmathclass_1\n    .   test_add\n    .   test_multiply\n      testmathclassdict_0\n    .   test_subtract\n\n    ran 12 tests in 0.121s\n\n    ok (passes=9)\n\n\ninstallation\n------------\n\n::\n\n    $ pip install parameterized\n\n\ncompatibility\n-------------\n\n`yes`__ (mostly).\n\n__ https://app.circleci.com/pipelines/github/wolever/parameterized?branch=master\n\n.. list-table::\n   :header-rows: 1\n   :stub-columns: 1\n\n   * -\n     - py3.7\n     - py3.8\n     - py3.9\n     - py3.10\n     - py3.11\n     - pypy3\n     - ``@mock.patch``\n   * - nose\n     - yes\n     - yes\n     - yes\n     - yes\n     - no\u00a7\n     - no\u00a7\n     - yes\n   * - nose2\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - py.test 2\n     - no*\n     - no*\n     - no*\n     - no*\n     - no*\n     - no*\n     - no*\n   * - py.test 3\n     - yes\n     - yes\n     - yes\n     - yes\n     - no*\n     - no*\n     - yes\n   * - py.test 4\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n     - no**\n   * - py.test fixtures\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n     - no\u2020\n   * - | unittest\n       | (``@parameterized.expand``)\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n     - yes\n   * - | unittest2\n       | (``@parameterized.expand``)\n     - yes\n     - yes\n     - yes\n     - yes\n     - no\u00a7\n     - no\u00a7\n     - yes\n\n\u00a7: nose and unittest2 - both of which were last updated in 2015 - sadly do not\nappear to support python 3.10 or 3.11.\n\n\\*: `py.test 2 does not appear to work under python 3 (#71)`__, and\n`py.test 3 does not appear to work under python 3.10 or 3.11 (#154)`__.\n\n\\*\\*: py.test 4 is not yet supported (but coming!) in `issue #34`__\n\n\u2020: py.test fixture support is documented in `issue #81`__\n\n\n__ https://github.com/wolever/parameterized/issues/71\n__ https://github.com/wolever/parameterized/issues/154\n__ https://github.com/wolever/parameterized/issues/34\n__ https://github.com/wolever/parameterized/issues/81\n\ndependencies\n------------\n\n(this section left intentionally blank)\n\n\nexhaustive usage examples\n--------------------------\n\nthe ``@parameterized`` and ``@parameterized.expand`` decorators accept a list\nor iterable of tuples or ``param(...)``, or a callable which returns a list or\niterable:\n\n.. code:: python\n\n    from parameterized import parameterized, param\n\n    # a list of tuples\n    @parameterized([\n        (2, 3, 5),\n        (3, 5, 8),\n    ])\n    def test_add(a, b, expected):\n        assert_equal(a + b, expected)\n\n    # a list of params\n    @parameterized([\n        param(\"10\", 10),\n        param(\"10\", 16, base=16),\n    ])\n    def test_int(str_val, expected, base=10):\n        assert_equal(int(str_val, base=base), expected)\n\n    # an iterable of params\n    @parameterized(\n        param.explicit(*json.loads(line))\n        for line in open(\"testcases.jsons\")\n    )\n    def test_from_json_file(...):\n        ...\n\n    # a callable which returns a list of tuples\n    def load_test_cases():\n        return [\n            (\"test1\", ),\n            (\"test2\", ),\n        ]\n    @parameterized(load_test_cases)\n    def test_from_function(name):\n        ...\n\n.. **\n\nnote that, when using an iterator or a generator, all the items will be loaded\ninto memory before the start of the test run (we do this explicitly to ensure\nthat generators are exhausted exactly once in multi-process or multi-threaded\ntesting environments).\n\nthe ``@parameterized`` decorator can be used test class methods, and standalone\nfunctions:\n\n.. code:: python\n\n    from parameterized import parameterized\n\n    class addtest(object):\n        @parameterized([\n            (2, 3, 5),\n        ])\n        def test_add(self, a, b, expected):\n            assert_equal(a + b, expected)\n\n    @parameterized([\n        (2, 3, 5),\n    ])\n    def test_add(a, b, expected):\n        assert_equal(a + b, expected)\n\n\nand ``@parameterized.expand`` can be used to generate test methods in\nsituations where test generators cannot be used (for example, when the test\nclass is a subclass of ``unittest.testcase``):\n\n.. code:: python\n\n    import unittest\n    from parameterized import parameterized\n\n    class addtestcase(unittest.testcase):\n        @parameterized.expand([\n            (\"2 and 3\", 2, 3, 5),\n            (\"3 and 5\", 3, 5, 8),\n        ])\n        def test_add(self, _, a, b, expected):\n            assert_equal(a + b, expected)\n\nwill create the test cases::\n\n    $ nosetests example.py\n    test_add_0_2_and_3 (example.addtestcase) ... ok\n    test_add_1_3_and_5 (example.addtestcase) ... ok\n\n    ----------------------------------------------------------------------\n    ran 2 tests in 0.001s\n\n    ok\n\nnote that ``@parameterized.expand`` works by creating new methods on the test\nclass. if the first parameter is a string, that string will be added to the end\nof the method name. for example, the test case above will generate the methods\n``test_add_0_2_and_3`` and ``test_add_1_3_and_5``.\n\nthe names of the test cases generated by ``@parameterized.expand`` can be\ncustomized using the ``name_func`` keyword argument. the value should\nbe a function which accepts three arguments: ``testcase_func``, ``param_num``,\nand ``params``, and it should return the name of the test case.\n``testcase_func`` will be the function to be tested, ``param_num`` will be the\nindex of the test case parameters in the list of parameters, and ``param``\n(an instance of ``param``) will be the parameters which will be used.\n\n.. code:: python\n\n    import unittest\n    from parameterized import parameterized\n\n    def custom_name_func(testcase_func, param_num, param):\n        return \"%s_%s\" %(\n            testcase_func.__name__,\n            parameterized.to_safe_name(\"_\".join(str(x) for x in param.args)),\n        )\n\n    class addtestcase(unittest.testcase):\n        @parameterized.expand([\n            (2, 3, 5),\n            (2, 3, 5),\n        ], name_func=custom_name_func)\n        def test_add(self, a, b, expected):\n            assert_equal(a + b, expected)\n\nwill create the test cases::\n\n    $ nosetests example.py\n    test_add_1_2_3 (example.addtestcase) ... ok\n    test_add_2_3_5 (example.addtestcase) ... ok\n\n    ----------------------------------------------------------------------\n    ran 2 tests in 0.001s\n\n    ok\n\n\nthe ``param(...)`` helper class stores the parameters for one specific test\ncase.  it can be used to pass keyword arguments to test cases:\n\n.. code:: python\n\n    from parameterized import parameterized, param\n\n    @parameterized([\n        param(\"10\", 10),\n        param(\"10\", 16, base=16),\n    ])\n    def test_int(str_val, expected, base=10):\n        assert_equal(int(str_val, base=base), expected)\n\n\nif test cases have a docstring, the parameters for that test case will be\nappended to the first line of the docstring. this behavior can be controlled\nwith the ``doc_func`` argument:\n\n.. code:: python\n\n    from parameterized import parameterized\n\n    @parameterized([\n        (1, 2, 3),\n        (4, 5, 9),\n    ])\n    def test_add(a, b, expected):\n        \"\"\" test addition. \"\"\"\n        assert_equal(a + b, expected)\n\n    def my_doc_func(func, num, param):\n        return \"%s: %s with %s\" %(num, func.__name__, param)\n\n    @parameterized([\n        (5, 4, 1),\n        (9, 6, 3),\n    ], doc_func=my_doc_func)\n    def test_subtraction(a, b, expected):\n        assert_equal(a - b, expected)\n\n::\n\n    $ nosetests example.py\n    test addition. [with a=1, b=2, expected=3] ... ok\n    test addition. [with a=4, b=5, expected=9] ... ok\n    0: test_subtraction with param(*(5, 4, 1)) ... ok\n    1: test_subtraction with param(*(9, 6, 3)) ... ok\n\n    ----------------------------------------------------------------------\n    ran 4 tests in 0.001s\n\n    ok\n\nfinally ``@parameterized_class`` parameterizes an entire class, using\neither a list of attributes, or a list of dicts that will be applied to the\nclass:\n\n.. code:: python\n\n    from yourapp.models import user\n    from parameterized import parameterized_class\n\n    @parameterized_class([\n       { \"username\": \"user_1\", \"access_level\": 1 },\n       { \"username\": \"user_2\", \"access_level\": 2, \"expected_status_code\": 404 },\n    ])\n    class testuseraccesslevel(testcase):\n       expected_status_code = 200\n\n       def setup(self):\n          self.client.force_login(user.objects.get(username=self.username)[0])\n\n       def test_url_a(self):\n          response = self.client.get('/url')\n          self.assertequal(response.status_code, self.expected_status_code)\n\n       def teardown(self):\n          self.client.logout()\n\n\n    @parameterized_class((\"username\", \"access_level\", \"expected_status_code\"), [\n       (\"user_1\", 1, 200),\n       (\"user_2\", 2, 404)\n    ])\n    class testuseraccesslevel(testcase):\n       def setup(self):\n          self.client.force_login(user.objects.get(username=self.username)[0])\n\n       def test_url_a(self):\n          response = self.client.get(\"/url\")\n          self.assertequal(response.status_code, self.expected_status_code)\n\n       def teardown(self):\n          self.client.logout()\n\n\nthe ``@parameterized_class`` decorator accepts a ``class_name_func`` argument,\nwhich controls the name of the parameterized classes generated by\n``@parameterized_class``:\n\n.. code:: python\n\n    from parameterized import parameterized, parameterized_class\n\n    def get_class_name(cls, num, params_dict):\n        # by default the generated class named includes either the \"name\"\n        # parameter (if present), or the first string value. this example shows\n        # multiple parameters being included in the generated class name:\n        return \"%s_%s_%s%s\" %(\n            cls.__name__,\n            num,\n            parameterized.to_safe_name(params_dict['a']),\n            parameterized.to_safe_name(params_dict['b']),\n        )\n\n    @parameterized_class([\n       { \"a\": \"hello\", \"b\": \" world!\", \"expected\": \"hello world!\" },\n       { \"a\": \"say \", \"b\": \" cheese :)\", \"expected\": \"say cheese :)\" },\n    ], class_name_func=get_class_name)\n    class testconcatenation(testcase):\n      def test_concat(self):\n          self.assertequal(self.a + self.b, self.expected)\n\n::\n\n    $ nosetests -v test_math.py\n    test_concat (test_concat.testconcatenation_0_hello_world_) ... ok\n    test_concat (test_concat.testconcatenation_0_say_cheese__) ... ok\n\n\n\nusing with single parameters\n............................\n\nif a test function only accepts one parameter and the value is not iterable,\nthen it is possible to supply a list of values without wrapping each one in a\ntuple:\n\n.. code:: python\n\n   @parameterized([1, 2, 3])\n   def test_greater_than_zero(value):\n      assert value > 0\n\nnote, however, that if the single parameter *is* iterable (such as a list or\ntuple), then it *must* be wrapped in a tuple, list, or the ``param(...)``\nhelper:\n\n.. code:: python\n\n   @parameterized([\n      ([1, 2, 3], ),\n      ([3, 3], ),\n      ([6], ),\n   ])\n   def test_sums_to_6(numbers):\n      assert sum(numbers) == 6\n\n(note, also, that python requires single element tuples to be defined with a\ntrailing comma: ``(foo, )``)\n\n\nusing with ``@mock.patch``\n..........................\n\n``parameterized`` can be used with ``mock.patch``, but the argument ordering\ncan be confusing. the ``@mock.patch(...)`` decorator must come *below* the\n``@parameterized(...)``, and the mocked parameters must come *last*:\n\n.. code:: python\n\n   @mock.patch(\"os.getpid\")\n   class testos(object):\n      @parameterized(...)\n      @mock.patch(\"os.fdopen\")\n      @mock.patch(\"os.umask\")\n      def test_method(self, param1, param2, ..., mock_umask, mock_fdopen, mock_getpid):\n         ...\n\nnote: the same holds true when using ``@parameterized.expand``.\n\n\nmigrating from ``nose-parameterized`` to ``parameterized``\n----------------------------------------------------------\n\nto migrate a codebase from ``nose-parameterized`` to ``parameterized``:\n\n1. update your requirements file, replacing ``nose-parameterized`` with\n   ``parameterized``.\n\n2. replace all references to ``nose_parameterized`` with ``parameterized``::\n\n    $ perl -pi -e 's/nose_parameterized/parameterized/g' your-codebase/\n\n3. you're done!\n\n\nfaq\n---\n\nwhat happened to python 2.x, 3.5, and 3.6 support?\n    as of version 0.9.0, ``parameterized`` no longer supports python 2.x, 3.5,\n    or 3.6.  previous versions of ``parameterized`` - 0.8.1 being the latest -\n    will continue to work, but will not receive any new features or bug fixes.\n\nwhat do you mean when you say \"nose is best supported\"?\n    there are small caveates with ``py.test`` and ``unittest``: ``py.test``\n    does not show the parameter values (ex, it will show ``test_add[0]``\n    instead of ``test_add[1, 2, 3]``), and ``unittest``/``unittest2`` do not\n    support test generators so ``@parameterized.expand`` must be used.\n\nwhy not use ``@pytest.mark.parametrize``?\n    because spelling is difficult. also, ``parameterized`` doesn't require you\n    to repeat argument names, and (using ``param``) it supports optional\n    keyword arguments.\n\nwhy do i get an ``attributeerror: 'function' object has no attribute 'expand'`` with ``@parameterized.expand``?\n    you've likely installed the ``parametrized`` (note the missing *e*)\n    package. use ``parameterized`` (with the *e*) instead and you'll be all\n    set.\n\nwhat happened to ``nose-parameterized``?\n    originally only nose was supported. but now everything is supported, and it\n    only made sense to change the name!\n",
  "docs_url": null,
  "keywords": "",
  "license": "freebsd",
  "name": "parameterized",
  "package_url": "https://pypi.org/project/parameterized/",
  "project_url": "https://pypi.org/project/parameterized/",
  "project_urls": {
    "Homepage": "https://github.com/wolever/parameterized"
  },
  "release_url": "https://pypi.org/project/parameterized/0.9.0/",
  "requires_dist": [
    "jinja2 ; extra == 'dev'"
  ],
  "requires_python": ">=3.7",
  "summary": "parameterized testing with any python test framework",
  "version": "0.9.0",
  "releases": [],
  "developers": [
    "david@wolever.net"
  ],
  "kwds": "nose_parameterized testmathclassdict_0 parameterizes testmathclass_0 test_method",
  "license_kwds": "freebsd",
  "libtype": "pypi",
  "id": "pypi_parameterized",
  "homepage": "",
  "release_count": 11,
  "dependency_ids": [
    "pypi_jinja2"
  ]
}