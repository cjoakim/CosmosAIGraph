{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "operating system :: macos",
    "operating system :: microsoft",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: internet",
    "topic :: software development",
    "topic :: software development :: libraries",
    "topic :: system :: clustering"
  ],
  "description": "======\naiormq\n======\n\n.. image:: https://coveralls.io/repos/github/mosquito/aiormq/badge.svg?branch=master\n   :target: https://coveralls.io/github/mosquito/aiormq?branch=master\n   :alt: coveralls\n\n.. image:: https://img.shields.io/pypi/status/aiormq.svg\n   :target: https://github.com/mosquito/aiormq\n   :alt: status\n\n.. image:: https://github.com/mosquito/aiormq/workflows/tests/badge.svg\n   :target: https://github.com/mosquito/aiormq/actions?query=workflow%3atests\n   :alt: build status\n\n.. image:: https://img.shields.io/pypi/v/aiormq.svg\n   :target: https://pypi.python.org/pypi/aiormq/\n   :alt: latest version\n\n.. image:: https://img.shields.io/pypi/wheel/aiormq.svg\n   :target: https://pypi.python.org/pypi/aiormq/\n\n.. image:: https://img.shields.io/pypi/pyversions/aiormq.svg\n   :target: https://pypi.python.org/pypi/aiormq/\n\n.. image:: https://img.shields.io/pypi/l/aiormq.svg\n   :target: https://github.com/mosquito/aiormq/blob/master/license.md\n\n\naiormq is a pure python amqp client library.\n\n.. contents:: table of contents\n\nstatus\n======\n\n* 3.x.x branch - production/stable\n* 4.x.x branch - unstable (experimental)\n* 5.x.x and greater is only production/stable releases.\n\nfeatures\n========\n\n* connecting by url\n\n * amqp example: **amqp://user:password@server.host/vhost**\n * secure amqp example: **amqps://user:password@server.host/vhost?cafile=ca.pem&keyfile=key.pem&certfile=cert.pem&no_verify_ssl=0**\n\n* buffered queue for received frames\n* only `plain`_ auth mechanism support\n* `publisher confirms`_ support\n* `transactions`_ support\n* channel based asynchronous locks\n\n  .. note::\n      amqp 0.9.1 requires serialize sending for some frame types\n      on the channel. e.g. content body must be following after\n      content header. but frames might be sent asynchronously\n      on another channels.\n\n* tracking unroutable messages\n  (use **connection.channel(on_return_raises=false)** for disabling)\n* full ssl/tls support, using your choice of:\n    * ``amqps://`` url query parameters:\n        * ``cafile=`` - string contains path to ca certificate file\n        * ``capath=`` - string contains path to ca certificates\n        * ``cadata=`` - base64 encoded ca certificate data\n        * ``keyfile=`` - string contains path to key file\n        * ``certfile=`` - string contains path to certificate file\n        * ``no_verify_ssl`` - boolean disables certificates validation\n    * ``context=`` `sslcontext`_ keyword argument to ``connect()``.\n* python `type hints`_\n* uses `pamqp`_ as an amqp 0.9.1 frame encoder/decoder\n\n\n.. _publisher confirms: https://www.rabbitmq.com/confirms.html\n.. _transactions: https://www.rabbitmq.com/semantics.html\n.. _plain: https://www.rabbitmq.com/authentication.html\n.. _type hints: https://docs.python.org/3/library/typing.html\n.. _pamqp: https://pypi.org/project/pamqp/\n.. _sslcontext: https://docs.python.org/3/library/ssl.html#ssl.sslcontext\n\ntutorial\n========\n\nintroduction\n------------\n\nsimple consumer\n***************\n\n.. code-block:: python\n\n    import asyncio\n    import aiormq\n\n    async def on_message(message):\n        \"\"\"\n        on_message doesn't necessarily have to be defined as async.\n        here it is to show that it's possible.\n        \"\"\"\n        print(f\" [x] received message {message!r}\")\n        print(f\"message body is: {message.body!r}\")\n        print(\"before sleep!\")\n        await asyncio.sleep(5)   # represents async i/o operations\n        print(\"after sleep!\")\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        # declaring queue\n        declare_ok = await channel.queue_declare('helo')\n        consume_ok = await channel.basic_consume(\n            declare_ok.queue, on_message, no_ack=true\n        )\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n    loop.run_forever()\n\n\nsimple publisher\n****************\n\n.. code-block:: python\n    :name: test_simple_publisher\n\n    import asyncio\n    from typing import optional\n\n    import aiormq\n    from aiormq.abc import deliveredmessage\n\n\n    message: optional[deliveredmessage] = none\n\n\n    async def main():\n        global message\n\n        body = b'hello world!'\n\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost//\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        declare_ok = await channel.queue_declare(\"hello\", auto_delete=true)\n\n        # sending the message\n        await channel.basic_publish(body, routing_key='hello')\n        print(f\" [x] sent {body}\")\n\n        message = await channel.basic_get(declare_ok.queue)\n        print(f\" [x] received message from {declare_ok.queue!r}\")\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n    assert message is not none\n    assert message.routing_key == \"hello\"\n    assert message.body == b'hello world!'\n\n\nwork queues\n-----------\n\ncreate new task\n***************\n\n.. code-block:: python\n\n    import sys\n    import asyncio\n    import aiormq\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        body = b' '.join(sys.argv[1:]) or b\"hello world!\"\n\n        # sending the message\n        await channel.basic_publish(\n            body,\n            routing_key='task_queue',\n            properties=aiormq.spec.basic.properties(\n                delivery_mode=1,\n            )\n        )\n\n        print(f\" [x] sent {body!r}\")\n\n        await connection.close()\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n\nsimple worker\n*************\n\n.. code-block:: python\n\n    import asyncio\n    import aiormq\n    import aiormq.abc\n\n\n    async def on_message(message: aiormq.abc.deliveredmessage):\n        print(f\" [x] received message {message!r}\")\n        print(f\"     message body is: {message.body!r}\")\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n\n        # creating a channel\n        channel = await connection.channel()\n        await channel.basic_qos(prefetch_count=1)\n\n        # declaring queue\n        declare_ok = await channel.queue_declare('task_queue', durable=true)\n\n        # start listening the queue with name 'task_queue'\n        await channel.basic_consume(declare_ok.queue, on_message, no_ack=true)\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n    # we enter a never-ending loop that waits for data and runs\n    # callbacks whenever necessary.\n    print(\" [*] waiting for messages. to exit press ctrl+c\")\n    loop.run_forever()\n\n\npublish subscribe\n-----------------\n\npublisher\n*********\n\n.. code-block:: python\n\n    import sys\n    import asyncio\n    import aiormq\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        await channel.exchange_declare(\n            exchange='logs', exchange_type='fanout'\n        )\n\n        body = b' '.join(sys.argv[1:]) or b\"hello world!\"\n\n        # sending the message\n        await channel.basic_publish(\n            body, routing_key='info', exchange='logs'\n        )\n\n        print(f\" [x] sent {body!r}\")\n\n        await connection.close()\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n\nsubscriber\n**********\n\n.. code-block:: python\n\n    import asyncio\n    import aiormq\n    import aiormq.abc\n\n\n    async def on_message(message: aiormq.abc.deliveredmessage):\n        print(f\"[x] {message.body!r}\")\n\n        await message.channel.basic_ack(\n            message.delivery.delivery_tag\n        )\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n        await channel.basic_qos(prefetch_count=1)\n\n        await channel.exchange_declare(\n            exchange='logs', exchange_type='fanout'\n        )\n\n        # declaring queue\n        declare_ok = await channel.queue_declare(exclusive=true)\n\n        # binding the queue to the exchange\n        await channel.queue_bind(declare_ok.queue, 'logs')\n\n        # start listening the queue with name 'task_queue'\n        await channel.basic_consume(declare_ok.queue, on_message)\n\n\n    loop = asyncio.get_event_loop()\n    loop.create_task(main())\n\n    # we enter a never-ending loop that waits for data\n    # and runs callbacks whenever necessary.\n    print(' [*] waiting for logs. to exit press ctrl+c')\n    loop.run_forever()\n\n\nrouting\n-------\n\ndirect consumer\n***************\n\n.. code-block:: python\n\n    import sys\n    import asyncio\n    import aiormq\n    import aiormq.abc\n\n\n    async def on_message(message: aiormq.abc.deliveredmessage):\n        print(f\" [x] {message.delivery.routing_key!r}:{message.body!r}\"\n        await message.channel.basic_ack(\n            message.delivery.delivery_tag\n        )\n\n\n    async def main():\n        # perform connection\n        connection = aiormq.connection(\"amqp://guest:guest@localhost/\")\n        await connection.connect()\n\n        # creating a channel\n        channel = await connection.channel()\n        await channel.basic_qos(prefetch_count=1)\n\n        severities = sys.argv[1:]\n\n        if not severities:\n            sys.stderr.write(f\"usage: {sys.argv[0]} [info] [warning] [error]\\n\")\n            sys.exit(1)\n\n        # declare an exchange\n        await channel.exchange_declare(\n            exchange='logs', exchange_type='direct'\n        )\n\n        # declaring random queue\n        declare_ok = await channel.queue_declare(durable=true, auto_delete=true)\n\n        for severity in severities:\n            await channel.queue_bind(\n                declare_ok.queue, 'logs', routing_key=severity\n            )\n\n        # start listening the random queue\n        await channel.basic_consume(declare_ok.queue, on_message)\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n    # we enter a never-ending loop that waits for data\n    # and runs callbacks whenever necessary.\n    print(\" [*] waiting for messages. to exit press ctrl+c\")\n    loop.run_forever()\n\n\nemitter\n*******\n\n.. code-block:: python\n\n    import sys\n    import asyncio\n    import aiormq\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        await channel.exchange_declare(\n            exchange='logs', exchange_type='direct'\n        )\n\n        body = (\n            b' '.join(arg.encode() for arg in sys.argv[2:])\n            or\n            b\"hello world!\"\n        )\n\n        # sending the message\n        routing_key = sys.argv[1] if len(sys.argv) > 2 else 'info'\n\n        await channel.basic_publish(\n            body, exchange='logs', routing_key=routing_key,\n            properties=aiormq.spec.basic.properties(\n                delivery_mode=1\n            )\n        )\n\n        print(f\" [x] sent {body!r}\")\n\n        await connection.close()\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\ntopics\n------\n\npublisher\n*********\n\n.. code-block:: python\n\n    import sys\n    import asyncio\n    import aiormq\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        await channel.exchange_declare('topic_logs', exchange_type='topic')\n\n        routing_key = (\n            sys.argv[1] if len(sys.argv) > 2 else 'anonymous.info'\n        )\n\n        body = (\n            b' '.join(arg.encode() for arg in sys.argv[2:])\n            or\n            b\"hello world!\"\n        )\n\n        # sending the message\n        await channel.basic_publish(\n            body, exchange='topic_logs', routing_key=routing_key,\n            properties=aiormq.spec.basic.properties(\n                delivery_mode=1\n            )\n        )\n\n        print(f\" [x] sent {body!r}\")\n\n        await connection.close()\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\nconsumer\n********\n\n.. code-block:: python\n\n    import asyncio\n    import sys\n    import aiormq\n    import aiormq.abc\n\n\n    async def on_message(message: aiormq.abc.deliveredmessage):\n        print(f\" [x] {message.delivery.routing_key!r}:{message.body!r}\")\n        await message.channel.basic_ack(\n            message.delivery.delivery_tag\n        )\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\n            \"amqp://guest:guest@localhost/\", loop=loop\n        )\n\n        # creating a channel\n        channel = await connection.channel()\n        await channel.basic_qos(prefetch_count=1)\n\n        # declare an exchange\n        await channel.exchange_declare('topic_logs', exchange_type='topic')\n\n        # declaring queue\n        declare_ok = await channel.queue_declare('task_queue', durable=true)\n\n        binding_keys = sys.argv[1:]\n\n        if not binding_keys:\n            sys.stderr.write(\n                f\"usage: {sys.argv[0]} [binding_key]...\\n\"\n            )\n            sys.exit(1)\n\n        for binding_key in binding_keys:\n            await channel.queue_bind(\n                declare_ok.queue, 'topic_logs', routing_key=binding_key\n            )\n\n        # start listening the queue with name 'task_queue'\n        await channel.basic_consume(declare_ok.queue, on_message)\n\n\n    loop = asyncio.get_event_loop()\n    loop.create_task(main())\n\n    # we enter a never-ending loop that waits for\n    # data and runs callbacks whenever necessary.\n    print(\" [*] waiting for messages. to exit press ctrl+c\")\n    loop.run_forever()\n\nremote procedure call (rpc)\n---------------------------\n\nrpc server\n**********\n\n.. code-block:: python\n\n    import asyncio\n    import aiormq\n    import aiormq.abc\n\n\n    def fib(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return fib(n-1) + fib(n-2)\n\n\n    async def on_message(message:aiormq.abc.deliveredmessage):\n        n = int(message.body.decode())\n\n        print(f\" [.] fib({n})\")\n        response = str(fib(n)).encode()\n\n        await message.channel.basic_publish(\n            response, routing_key=message.header.properties.reply_to,\n            properties=aiormq.spec.basic.properties(\n                correlation_id=message.header.properties.correlation_id\n            ),\n\n        )\n\n        await message.channel.basic_ack(message.delivery.delivery_tag)\n        print('request complete')\n\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        # declaring queue\n        declare_ok = await channel.queue_declare('rpc_queue')\n\n        # start listening the queue with name 'hello'\n        await channel.basic_consume(declare_ok.queue, on_message)\n\n\n    loop = asyncio.get_event_loop()\n    loop.create_task(main())\n\n    # we enter a never-ending loop that waits for data\n    # and runs callbacks whenever necessary.\n    print(\" [x] awaiting rpc requests\")\n    loop.run_forever()\n\n\nrpc client\n**********\n\n.. code-block:: python\n\n    import asyncio\n    import uuid\n    import aiormq\n    import aiormq.abc\n\n\n    class fibonaccirpcclient:\n        def __init__(self):\n            self.connection = none      # type: aiormq.connection\n            self.channel = none         # type: aiormq.channel\n            self.callback_queue = ''\n            self.futures = {}\n            self.loop = loop\n\n        async def connect(self):\n            self.connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n            self.channel = await self.connection.channel()\n            declare_ok = await self.channel.queue_declare(\n                exclusive=true, auto_delete=true\n            )\n\n            await self.channel.basic_consume(declare_ok.queue, self.on_response)\n\n            self.callback_queue = declare_ok.queue\n\n            return self\n\n        async def on_response(self, message: aiormq.abc.deliveredmessage):\n            future = self.futures.pop(message.header.properties.correlation_id)\n            future.set_result(message.body)\n\n        async def call(self, n):\n            correlation_id = str(uuid.uuid4())\n            future = loop.create_future()\n\n            self.futures[correlation_id] = future\n\n            await self.channel.basic_publish(\n                str(n).encode(), routing_key='rpc_queue',\n                properties=aiormq.spec.basic.properties(\n                    content_type='text/plain',\n                    correlation_id=correlation_id,\n                    reply_to=self.callback_queue,\n                )\n            )\n\n            return int(await future)\n\n\n    async def main():\n        fibonacci_rpc = await fibonaccirpcclient().connect()\n        print(\" [x] requesting fib(30)\")\n        response = await fibonacci_rpc.call(30)\n        print(r\" [.] got {response!r}\")\n\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n",
  "docs_url": null,
  "keywords": "rabbitmq,asyncio,amqp,amqp 0.9.1,driver,pamqp",
  "license": "apache-2.0",
  "name": "aiormq",
  "package_url": "https://pypi.org/project/aiormq/",
  "project_url": "https://pypi.org/project/aiormq/",
  "project_urls": {
    "Documentation": "https://github.com/mosquito/aiormq/blob/master/README.rst",
    "Homepage": "https://github.com/mosquito/aiormq",
    "Source": "https://github.com/mosquito/aiormq",
    "Tracker": "https://github.com/mosquito/aiormq/issues"
  },
  "release_url": "https://pypi.org/project/aiormq/6.7.7/",
  "requires_dist": [
    "pamqp (==3.2.1)",
    "setuptools ; python_version < \"3.8\"",
    "yarl"
  ],
  "requires_python": ">=3.7,<4.0",
  "summary": "pure python amqp asynchronous client library",
  "version": "6.7.7",
  "releases": [],
  "developers": [
    "dmitry_orlov",
    "me@mosquito.su"
  ],
  "kwds": "aiormq rabbitmq uuid uuid4 badge",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aiormq",
  "homepage": "https://github.com/mosquito/aiormq",
  "release_count": 106,
  "dependency_ids": [
    "pypi_pamqp",
    "pypi_setuptools",
    "pypi_yarl"
  ]
}