{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon elastic load balancing v2 construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthe `@aws-cdk/aws-elasticloadbalancingv2` package provides constructs for\nconfiguring application and network load balancers.\n\nfor more information, see the aws documentation for\n[application load balancers](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html)\nand [network load balancers](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html).\n\n## defining an application load balancer\n\nyou define an application load balancer by creating an instance of\n`applicationloadbalancer`, adding a listener to the load balancer\nand adding targets to the listener:\n\n```python\nfrom aws_cdk.aws_autoscaling import autoscalinggroup\n# asg: autoscalinggroup\n\n# vpc: ec2.vpc\n\n\n# create the load balancer in a vpc. 'internetfacing' is 'false'\n# by default, which creates an internal load balancer.\nlb = elbv2.applicationloadbalancer(self, \"lb\",\n    vpc=vpc,\n    internet_facing=true\n)\n\n# add a listener and open up the load balancer's security group\n# to the world.\nlistener = lb.add_listener(\"listener\",\n    port=80,\n\n    # 'open: true' is the default, you can leave it out if you want. set it\n    # to 'false' and use `listener.connections` if you want to be selective\n    # about who can access the load balancer.\n    open=true\n)\n\n# create an autoscaling group and add it as a load balancing\n# target to the listener.\nlistener.add_targets(\"applicationfleet\",\n    port=8080,\n    targets=[asg]\n)\n```\n\nthe security groups of the load balancer and the target are automatically\nupdated to allow the network traffic.\n\none (or more) security groups can be associated with the load balancer;\nif a security group isn't provided, one will be automatically created.\n\n```python\n# vpc: ec2.vpc\n\n\nsecurity_group1 = ec2.securitygroup(self, \"securitygroup1\", vpc=vpc)\nlb = elbv2.applicationloadbalancer(self, \"lb\",\n    vpc=vpc,\n    internet_facing=true,\n    security_group=security_group1\n)\n\nsecurity_group2 = ec2.securitygroup(self, \"securitygroup2\", vpc=vpc)\nlb.add_security_group(security_group2)\n```\n\n### conditions\n\nit's possible to route traffic to targets based on conditions in the incoming\nhttp request. for example, the following will route requests to the indicated\nautoscalinggroup only if the requested host in the request is either for\n`example.com/ok` or `example.com/path`:\n\n```python\n# listener: elbv2.applicationlistener\n# asg: autoscaling.autoscalinggroup\n\n\nlistener.add_targets(\"example.com fleet\",\n    priority=10,\n    conditions=[\n        elbv2.listenercondition.host_headers([\"example.com\"]),\n        elbv2.listenercondition.path_patterns([\"/ok\", \"/path\"])\n    ],\n    port=8080,\n    targets=[asg]\n)\n```\n\na target with a condition contains either `pathpatterns` or `hostheader`, or\nboth. if both are specified, both conditions must be met for the requests to\nbe routed to the given target. `priority` is a required field when you add\ntargets with conditions. the lowest number wins.\n\nevery listener must have at least one target without conditions, which is\nwhere all requests that didn't match any of the conditions will be sent.\n\n### convenience methods and more complex actions\n\nrouting traffic from a load balancer to a target involves the following steps:\n\n* create a target group, register the target into the target group\n* add an action to the listener which forwards traffic to the target group.\n\na new listener can be added to the load balancer by calling `addlistener()`.\nlisteners that have been added to the load balancer can be listed using the\n`listeners` property.  note that the `listeners` property will throw an error\nfor imported or looked up load balancers.\n\nvarious methods on the `listener` take care of this work for you to a greater\nor lesser extent:\n\n* `addtargets()` performs both steps: automatically creates a target group and the\n  required action.\n* `addtargetgroups()` gives you more control: you create the target group (or\n  target groups) yourself and the method creates action that routes traffic to\n  the target groups.\n* `addaction()` gives you full control: you supply the action and wire it up\n  to the target groups yourself (or access one of the other elb routing features).\n\nusing `addaction()` gives you access to some of the features of an elastic load\nbalancer that the other two convenience methods don't:\n\n* **routing stickiness**: use `listeneraction.forward()` and supply a\n  `stickinessduration` to make sure requests are routed to the same target group\n  for a given duration.\n* **weighted target groups**: use `listeneraction.weightedforward()`\n  to give different weights to different target groups.\n* **fixed responses**: use `listeneraction.fixedresponse()` to serve\n  a static response (alb only).\n* **redirects**: use `listeneraction.redirect()` to serve an http\n  redirect response (alb only).\n* **authentication**: use `listeneraction.authenticateoidc()` to\n  perform openid authentication before serving a request (see the\n  `@aws-cdk/aws-elasticloadbalancingv2-actions` package for direct authentication\n  integration with cognito) (alb only).\n\nhere's an example of serving a fixed response at the `/ok` url:\n\n```python\n# listener: elbv2.applicationlistener\n\n\nlistener.add_action(\"fixed\",\n    priority=10,\n    conditions=[\n        elbv2.listenercondition.path_patterns([\"/ok\"])\n    ],\n    action=elbv2.listeneraction.fixed_response(200,\n        content_type=elbv2.contenttype.text_plain,\n        message_body=\"ok\"\n    )\n)\n```\n\nhere's an example of using oidc authentication before forwarding to a targetgroup:\n\n```python\n# listener: elbv2.applicationlistener\n# my_target_group: elbv2.applicationtargetgroup\n\n\nlistener.add_action(\"defaultaction\",\n    action=elbv2.listeneraction.authenticate_oidc(\n        authorization_endpoint=\"https://example.com/openid\",\n        # other oidc properties here\n        client_id=\"...\",\n        client_secret=secretvalue.secrets_manager(\"...\"),\n        issuer=\"...\",\n        token_endpoint=\"...\",\n        user_info_endpoint=\"...\",\n\n        # next\n        next=elbv2.listeneraction.forward([my_target_group])\n    )\n)\n```\n\nif you just want to redirect all incoming traffic on one port to another port, you can use the following code:\n\n```python\n# lb: elbv2.applicationloadbalancer\n\n\nlb.add_redirect(\n    source_protocol=elbv2.applicationprotocol.https,\n    source_port=8443,\n    target_protocol=elbv2.applicationprotocol.http,\n    target_port=8080\n)\n```\n\nif you do not provide any options for this method, it redirects http port 80 to https port 443.\n\nby default all ingress traffic will be allowed on the source port. if you want to be more selective with your\ningress rules then set `open: false` and use the listener's `connections` object to selectively grant access to the listener.\n\n## defining a network load balancer\n\nnetwork load balancers are defined in a similar way to application load\nbalancers:\n\n```python\n# vpc: ec2.vpc\n# asg: autoscaling.autoscalinggroup\n\n\n# create the load balancer in a vpc. 'internetfacing' is 'false'\n# by default, which creates an internal load balancer.\nlb = elbv2.networkloadbalancer(self, \"lb\",\n    vpc=vpc,\n    internet_facing=true\n)\n\n# add a listener on a particular port.\nlistener = lb.add_listener(\"listener\",\n    port=443\n)\n\n# add targets on a particular port.\nlistener.add_targets(\"appfleet\",\n    port=443,\n    targets=[asg]\n)\n```\n\none thing to keep in mind is that network load balancers do not have security\ngroups, and no automatic security group configuration is done for you. you will\nhave to configure the security groups of the target yourself to allow traffic by\nclients and/or load balancer instances, depending on your target types.  see\n[target groups for your network load\nbalancers](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html)\nand [register targets with your target\ngroup](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html)\nfor more information.\n\n## targets and target groups\n\napplication and network load balancers organize load balancing targets in target\ngroups. if you add your balancing targets (such as autoscalinggroups, ecs\nservices or individual instances) to your listener directly, the appropriate\n`targetgroup` will be automatically created for you.\n\nif you need more control over the target groups created, create an instance of\n`applicationtargetgroup` or `networktargetgroup`, add the members you desire,\nand add it to the listener by calling `addtargetgroups` instead of `addtargets`.\n\n`addtargets()` will always return the target group it just created for you:\n\n```python\n# listener: elbv2.networklistener\n# asg1: autoscaling.autoscalinggroup\n# asg2: autoscaling.autoscalinggroup\n\n\ngroup = listener.add_targets(\"appfleet\",\n    port=443,\n    targets=[asg1]\n)\n\ngroup.add_target(asg2)\n```\n\n### sticky sessions for your application load balancer\n\nby default, an application load balancer routes each request independently to a registered target based on the chosen load-balancing algorithm. however, you can use the sticky session feature (also known as session affinity) to enable the load balancer to bind a user's session to a specific target. this ensures that all requests from the user during the session are sent to the same target. this feature is useful for servers that maintain state information in order to provide a continuous experience to clients. to use sticky sessions, the client must support cookies.\n\napplication load balancers support both duration-based cookies (`lb_cookie`) and application-based cookies (`app_cookie`). the key to managing sticky sessions is determining how long your load balancer should consistently route the user's request to the same target. sticky sessions are enabled at the target group level. you can use a combination of duration-based stickiness, application-based stickiness, and no stickiness across all of your target groups.\n\n```python\n# vpc: ec2.vpc\n\n\n# target group with duration-based stickiness with load-balancer generated cookie\ntg1 = elbv2.applicationtargetgroup(self, \"tg1\",\n    target_type=elbv2.targettype.instance,\n    port=80,\n    stickiness_cookie_duration=duration.minutes(5),\n    vpc=vpc\n)\n\n# target group with application-based stickiness\ntg2 = elbv2.applicationtargetgroup(self, \"tg2\",\n    target_type=elbv2.targettype.instance,\n    port=80,\n    stickiness_cookie_duration=duration.minutes(5),\n    stickiness_cookie_name=\"mydeliciouscookie\",\n    vpc=vpc\n)\n```\n\nfor more information see: https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html#application-based-stickiness\n\n### setting the target group protocol version\n\nby default, application load balancers send requests to targets using http/1.1. you can use the [protocol version](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-protocol-version) to send requests to targets using http/2 or grpc.\n\n```python\n# vpc: ec2.vpc\n\n\ntg = elbv2.applicationtargetgroup(self, \"tg\",\n    target_type=elbv2.targettype.ip,\n    port=50051,\n    protocol=elbv2.applicationprotocol.http,\n    protocol_version=elbv2.applicationprotocolversion.grpc,\n    health_check=elbv2.healthcheck(\n        enabled=true,\n        healthy_grpc_codes=\"0-99\"\n    ),\n    vpc=vpc\n)\n```\n\n## using lambda targets\n\nto use a lambda function as a target, use the integration class in the\n`@aws-cdk/aws-elasticloadbalancingv2-targets` package:\n\n```python\nimport aws_cdk.aws_lambda as lambda_\nimport aws_cdk.aws_elasticloadbalancingv2_targets as targets\n\n# lambda_function: lambda.function\n# lb: elbv2.applicationloadbalancer\n\n\nlistener = lb.add_listener(\"listener\", port=80)\nlistener.add_targets(\"targets\",\n    targets=[targets.lambdatarget(lambda_function)],\n\n    # for lambda targets, you need to explicitly enable health checks if you\n    # want them.\n    health_check=elbv2.healthcheck(\n        enabled=true\n    )\n)\n```\n\nonly a single lambda function can be added to a single listener rule.\n\n## using application load balancer targets\n\nto use a single application load balancer as a target for the network load balancer, use the integration class in the\n`@aws-cdk/aws-elasticloadbalancingv2-targets` package:\n\n```python\nimport aws_cdk.aws_elasticloadbalancingv2_targets as targets\nimport aws_cdk.aws_ecs as ecs\nimport aws_cdk.aws_ecs_patterns as patterns\n\n# vpc: ec2.vpc\n\n\ntask = ecs.fargatetaskdefinition(self, \"task\", cpu=256, memory_limit_mi_b=512)\ntask.add_container(\"nginx\",\n    image=ecs.containerimage.from_registry(\"public.ecr.aws/nginx/nginx:latest\"),\n    port_mappings=[ecs.portmapping(container_port=80)]\n)\n\nsvc = patterns.applicationloadbalancedfargateservice(self, \"service\",\n    vpc=vpc,\n    task_definition=task,\n    public_load_balancer=false\n)\n\nnlb = elbv2.networkloadbalancer(self, \"nlb\",\n    vpc=vpc,\n    cross_zone_enabled=true,\n    internet_facing=true\n)\n\nlistener = nlb.add_listener(\"listener\", port=80)\n\nlistener.add_targets(\"targets\",\n    targets=[targets.albtarget(svc.load_balancer, 80)],\n    port=80\n)\n\ncfnoutput(self, \"nlbendpoint\", value=f\"http://{nlb.loadbalancerdnsname}\")\n```\n\nonly the network load balancer is allowed to add the application load balancer as the target.\n\n## configuring health checks\n\nhealth checks are configured upon creation of a target group:\n\n```python\n# listener: elbv2.applicationlistener\n# asg: autoscaling.autoscalinggroup\n\n\nlistener.add_targets(\"appfleet\",\n    port=8080,\n    targets=[asg],\n    health_check=elbv2.healthcheck(\n        path=\"/ping\",\n        interval=duration.minutes(1)\n    )\n)\n```\n\nthe health check can also be configured after creation by calling\n`configurehealthcheck()` on the created object.\n\nno attempts are made to configure security groups for the port you're\nconfiguring a health check for, but if the health check is on the same port\nyou're routing traffic to, the security group already allows the traffic.\nif not, you will have to configure the security groups appropriately:\n\n```python\n# lb: elbv2.applicationloadbalancer\n# listener: elbv2.applicationlistener\n# asg: autoscaling.autoscalinggroup\n\n\nlistener.add_targets(\"appfleet\",\n    port=8080,\n    targets=[asg],\n    health_check=elbv2.healthcheck(\n        port=\"8088\"\n    )\n)\n\nasg.connections.allow_from(lb, ec2.port.tcp(8088))\n```\n\n## using a load balancer from a different stack\n\nif you want to put your load balancer and the targets it is load balancing to in\ndifferent stacks, you may not be able to use the convenience methods\n`loadbalancer.addlistener()` and `listener.addtargets()`.\n\nthe reason is that these methods will create resources in the same stack as the\nobject they're called on, which may lead to cyclic references between stacks.\ninstead, you will have to create an `applicationlistener` in the target stack,\nor an empty `targetgroup` in the load balancer stack that you attach your\nservice to.\n\nfor an example of the alternatives while load balancing to an ecs service, see the\n[ecs/cross-stack-load-balancer\nexample](https://github.com/aws-samples/aws-cdk-examples/tree/master/typescript/ecs/cross-stack-load-balancer/).\n\n## protocol for load balancer targets\n\nconstructs that want to be a load balancer target should implement\n`iapplicationloadbalancertarget` and/or `inetworkloadbalancertarget`, and\nprovide an implementation for the function `attachtoxxxtargetgroup()`, which can\ncall functions on the load balancer and should return metadata about the\nload balancing target:\n\n```python\nclass mytarget(elbv2.iapplicationloadbalancertarget):\n    def attach_to_application_target_group(self, target_group):\n        # if we need to add security group rules\n        # targetgroup.registerconnectable(...);\n        return elbv2.loadbalancertargetprops(\n            target_type=elbv2.targettype.ip,\n            target_json={\"id\": \"1.2.3.4\", \"port\": 8080}\n        )\n```\n\n`targettype` should be one of `instance` or `ip`. if the target can be\ndirectly added to the target group, `targetjson` should contain the `id` of\nthe target (either instance id or ip address depending on the type) and\noptionally a `port` or `availabilityzone` override.\n\napplication load balancer targets can call `registerconnectable()` on the\ntarget group to register themselves for addition to the load balancer's security\ngroup rules.\n\nif your load balancer target requires that the targetgroup has been\nassociated with a loadbalancer before registration can happen (such as is the\ncase for ecs services for example), take a resource dependency on\n`targetgroup.loadbalancerattached` as follows:\n\n```python\n# resource: resource\n# target_group: elbv2.applicationtargetgroup\n\n\n# make sure that the listener has been created, and so the targetgroup\n# has been associated with the loadbalancer, before 'resource' is created.\n\nnode.of(resource).add_dependency(target_group.load_balancer_attached)\n```\n\n## looking up load balancers and listeners\n\nyou may look up load balancers and load balancer listeners by using one of the\nfollowing lookup methods:\n\n* `applicationloadbalancer.fromlookup(options)` - look up an application load\n  balancer.\n* `applicationlistener.fromlookup(options)` - look up an application load\n  balancer listener.\n* `networkloadbalancer.fromlookup(options)` - look up a network load balancer.\n* `networklistener.fromlookup(options)` - look up a network load balancer\n  listener.\n\n### load balancer lookup options\n\nyou may look up a load balancer by arn or by associated tags. when you look a\nload balancer up by arn, that load balancer will be returned unless cdk detects\nthat the load balancer is of the wrong type. when you look up a load balancer by\ntags, cdk will return the load balancer matching all specified tags. if more\nthan one load balancer matches, cdk will throw an error requesting that you\nprovide more specific criteria.\n\n**look up a application load balancer by arn**\n\n```python\nload_balancer = elbv2.applicationloadbalancer.from_lookup(self, \"alb\",\n    load_balancer_arn=\"arn:aws:elasticloadbalancing:us-east-2:123456789012:loadbalancer/app/my-load-balancer/1234567890123456\"\n)\n```\n\n**look up an application load balancer by tags**\n\n```python\nload_balancer = elbv2.applicationloadbalancer.from_lookup(self, \"alb\",\n    load_balancer_tags={\n        # finds a load balancer matching all tags.\n        \"some\": \"tag\",\n        \"someother\": \"tag\"\n    }\n)\n```\n\n## load balancer listener lookup options\n\nyou may look up a load balancer listener by the following criteria:\n\n* associated load balancer arn\n* associated load balancer tags\n* listener arn\n* listener port\n* listener protocol\n\nthe lookup method will return the matching listener. if more than one listener\nmatches, cdk will throw an error requesting that you specify additional\ncriteria.\n\n**look up a listener by associated load balancer, port, and protocol**\n\n```python\nlistener = elbv2.applicationlistener.from_lookup(self, \"alblistener\",\n    load_balancer_arn=\"arn:aws:elasticloadbalancing:us-east-2:123456789012:loadbalancer/app/my-load-balancer/1234567890123456\",\n    listener_protocol=elbv2.applicationprotocol.https,\n    listener_port=443\n)\n```\n\n**look up a listener by associated load balancer tag, port, and protocol**\n\n```python\nlistener = elbv2.applicationlistener.from_lookup(self, \"alblistener\",\n    load_balancer_tags={\n        \"cluster\": \"myclustername\"\n    },\n    listener_protocol=elbv2.applicationprotocol.https,\n    listener_port=443\n)\n```\n\n**look up a network listener by associated load balancer tag, port, and protocol**\n\n```python\nlistener = elbv2.networklistener.from_lookup(self, \"alblistener\",\n    load_balancer_tags={\n        \"cluster\": \"myclustername\"\n    },\n    listener_protocol=elbv2.protocol.tcp,\n    listener_port=12345\n)\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-elasticloadbalancingv2",
  "package_url": "https://pypi.org/project/aws-cdk.aws-elasticloadbalancingv2/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-elasticloadbalancingv2/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-elasticloadbalancingv2/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-certificatemanager (==1.204.0)",
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-lambda (==1.204.0)",
    "aws-cdk.aws-route53 (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.cloud-assembly-schema (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.cx-api (==1.204.0)",
    "aws-cdk.region-info (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::elasticloadbalancingv2",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_elasticloadbalancingv2_targets elasticloadbalancingv2 aws_cdk elasticloadbalancing load_balancer",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_elasticloadbalancingv2",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_certificatemanager",
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_lambda",
    "pypi_aws_cdk.aws_route53",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.cloud_assembly_schema",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.cx_api",
    "pypi_aws_cdk.region_info",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}