{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# aws batch construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthis module is part of the [aws cloud development kit](https://github.com/aws/aws-cdk) project.\n\naws batch is a batch processing tool for efficiently running hundreds of thousands computing jobs in aws. batch can dynamically provision different types of compute resources based on the resource requirements of submitted jobs.\n\naws batch simplifies the planning, scheduling, and executions of your batch workloads across a full range of compute services like [amazon ec2](https://aws.amazon.com/ec2/) and [spot resources](https://aws.amazon.com/ec2/spot/).\n\nbatch achieves this by utilizing queue processing of batch job requests. to successfully submit a job for execution, you need the following resources:\n\n1. [job definition](#job-definition) - *group various job properties (container image, resource requirements, env variables...) into a single definition. these definitions are used at job submission time.*\n2. [compute environment](#compute-environment) - *the execution runtime of submitted batch jobs*\n3. [job queue](#job-queue) - *the queue where batch jobs can be submitted to via aws sdk/cli*\n\nfor more information on **aws batch** visit the [aws docs for batch](https://docs.aws.amazon.com/batch/index.html).\n\n## compute environment\n\nat the core of aws batch is the compute environment. all batch jobs are processed within a compute environment, which uses resource like ondemand/spot ec2 instances or fargate.\n\nin **managed** mode, aws will handle the provisioning of compute resources to accommodate the demand. otherwise, in **unmanaged** mode, you will need to manage the provisioning of those resources.\n\nbelow is an example of each available type of compute environment:\n\n```python\n# vpc: ec2.vpc\n\n\n# default is managed\naws_managed_environment = batch.computeenvironment(self, \"aws-managed-compute-env\",\n    compute_resources=batch.computeresources(\n        vpc=vpc\n    )\n)\n\ncustomer_managed_environment = batch.computeenvironment(self, \"customer-managed-compute-env\",\n    managed=false\n)\n```\n\n### spot-based compute environment\n\nit is possible to have aws batch submit spotfleet requests for obtaining compute resources. below is an example of how this can be done:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n\nspot_environment = batch.computeenvironment(self, \"myspotenvironment\",\n    compute_resources=batch.computeresources(\n        type=batch.computeresourcetype.spot,\n        bid_percentage=75,  # bids for resources at 75% of the on-demand price\n        vpc=vpc\n    )\n)\n```\n\n### fargate compute environment\n\nit is possible to have aws batch submit jobs to be run on fargate compute resources. below is an example of how this can be done:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n\nfargate_spot_environment = batch.computeenvironment(self, \"myfargateenvironment\",\n    compute_resources=batch.computeresources(\n        type=batch.computeresourcetype.fargate_spot,\n        vpc=vpc\n    )\n)\n```\n\n### understanding progressive allocation strategies\n\naws batch uses an [allocation strategy](https://docs.aws.amazon.com/batch/latest/userguide/allocation-strategies.html) to determine what compute resource will efficiently handle incoming job requests. by default, **best_fit** will pick an available compute instance based on vcpu requirements. if none exist, the job will wait until resources become available. however, with this strategy, you may have jobs waiting in the queue unnecessarily despite having more powerful instances available. below is an example of how that situation might look like:\n\n```plaintext\ncompute environment:\n\n1. m5.xlarge => 4 vcpu\n2. m5.2xlarge => 8 vcpu\n```\n\n```plaintext\njob queue:\n---------\n| a | b |\n---------\n\njob requirements:\na => 4 vcpu - allocated to m5.xlarge\nb => 2 vcpu - waiting\n```\n\nin this situation, batch will allocate **job a** to compute resource #1 because it is the most cost efficient resource that matches the vcpu requirement. however, with this `best_fit` strategy, **job b** will not be allocated to our other available compute resource even though it is strong enough to handle it. instead, it will wait until the first job is finished processing or wait a similar `m5.xlarge` resource to be provisioned.\n\nthe alternative would be to use the `best_fit_progressive` strategy in order for the remaining job to be handled in larger containers regardless of vcpu requirement and costs.\n\n### launch template support\n\nsimply define your launch template:\n\n```text\n// this example is only available in typescript\nconst mylaunchtemplate = new ec2.cfnlaunchtemplate(this, 'launchtemplate', {\n  launchtemplatename: 'extra-storage-template',\n  launchtemplatedata: {\n    blockdevicemappings: [\n      {\n        devicename: '/dev/xvdcz',\n        ebs: {\n          encrypted: true,\n          volumesize: 100,\n          volumetype: 'gp2',\n        },\n      },\n    ],\n  },\n});\n```\n\nand use it:\n\n```python\n# vpc: ec2.vpc\n# my_launch_template: ec2.cfnlaunchtemplate\n\n\nmy_compute_env = batch.computeenvironment(self, \"computeenv\",\n    compute_resources=batch.computeresources(\n        launch_template=batch.launchtemplatespecification(\n            launch_template_name=my_launch_template.launch_template_name\n        ),\n        vpc=vpc\n    ),\n    compute_environment_name=\"mystoragecapablecomputeenvironment\"\n)\n```\n\n### importing an existing compute environment\n\nto import an existing batch compute environment, call `computeenvironment.fromcomputeenvironmentarn()`.\n\nbelow is an example:\n\n```python\ncompute_env = batch.computeenvironment.from_compute_environment_arn(self, \"imported-compute-env\", \"arn:aws:batch:us-east-1:555555555555:compute-environment/my-compute-env\")\n```\n\n### change the baseline ami of the compute resources\n\noccasionally, you will need to deviate from the default processing ami.\n\necs optimized amazon linux 2 example:\n\n```python\n# vpc: ec2.vpc\n\nmy_compute_env = batch.computeenvironment(self, \"computeenv\",\n    compute_resources=batch.computeresources(\n        image=ecs.ecsoptimizedami(\n            generation=ec2.amazonlinuxgeneration.amazon_linux_2\n        ),\n        vpc=vpc\n    )\n)\n```\n\ncustom based ami example:\n\n```python\n# vpc: ec2.vpc\n\nmy_compute_env = batch.computeenvironment(self, \"computeenv\",\n    compute_resources=batch.computeresources(\n        image=ec2.machineimage.generic_linux({\n            \"[aws-region]\": \"[ami-id]\"\n        }),\n        vpc=vpc\n    )\n)\n```\n\n## job queue\n\njobs are always submitted to a specific queue. this means that you have to create a queue before you can start submitting jobs. each queue is mapped to at least one (and no more than three) compute environment. when the job is scheduled for execution, aws batch will select the compute environment based on ordinal priority and available capacity in each environment.\n\n```python\n# compute_environment: batch.computeenvironment\n\njob_queue = batch.jobqueue(self, \"jobqueue\",\n    compute_environments=[batch.jobqueuecomputeenvironment(\n        # defines a collection of compute resources to handle assigned batch jobs\n        compute_environment=compute_environment,\n        # order determines the allocation order for jobs (i.e. lower means higher preference for job assignment)\n        order=1\n    )\n    ]\n)\n```\n\n### priorty-based queue example\n\nsometimes you might have jobs that are more important than others, and when submitted, should take precedence over the existing jobs. to achieve this, you can create a priority based execution strategy, by assigning each queue its own priority:\n\n```python\n# shared_compute_envs: batch.computeenvironment\n\nhigh_prio_queue = batch.jobqueue(self, \"jobqueue\",\n    compute_environments=[batch.jobqueuecomputeenvironment(\n        compute_environment=shared_compute_envs,\n        order=1\n    )],\n    priority=2\n)\n\nlow_prio_queue = batch.jobqueue(self, \"jobqueue\",\n    compute_environments=[batch.jobqueuecomputeenvironment(\n        compute_environment=shared_compute_envs,\n        order=1\n    )],\n    priority=1\n)\n```\n\nby making sure to use the same compute environments between both job queues, we will give precedence to the `highprioqueue` for the assigning of jobs to available compute environments.\n\n### importing an existing job queue\n\nto import an existing batch job queue, call `jobqueue.fromjobqueuearn()`.\n\nbelow is an example:\n\n```python\njob_queue = batch.jobqueue.from_job_queue_arn(self, \"imported-job-queue\", \"arn:aws:batch:us-east-1:555555555555:job-queue/high-prio-queue\")\n```\n\n## job definition\n\na batch job definition helps aws batch understand important details about how to run your application in the scope of a batch job. this involves key information like resource requirements, what containers to run, how the compute environment should be prepared, and more. below is a simple example of how to create a job definition:\n\n```python\nimport aws_cdk.aws_ecr as ecr\n\n\nrepo = ecr.repository.from_repository_name(self, \"batch-job-repo\", \"todo-list\")\n\nbatch.jobdefinition(self, \"batch-job-def-from-ecr\",\n    container=batch.jobdefinitioncontainer(\n        image=ecs.ecrimage(repo, \"latest\")\n    )\n)\n```\n\n### using a local docker project\n\nbelow is an example of how you can create a batch job definition from a local docker application.\n\n```python\nbatch.jobdefinition(self, \"batch-job-def-from-local\",\n    container=batch.jobdefinitioncontainer(\n        # todo-list is a directory containing a dockerfile to build the application\n        image=ecs.containerimage.from_asset(\"../todo-list\")\n    )\n)\n```\n\n### providing custom log configuration\n\nyou can provide custom log driver and its configuration for the container.\n\n```python\nimport aws_cdk.aws_ssm as ssm\n\n\nbatch.jobdefinition(self, \"job-def\",\n    container=batch.jobdefinitioncontainer(\n        image=ecs.ecrimage.from_registry(\"docker/whalesay\"),\n        log_configuration=batch.logconfiguration(\n            log_driver=batch.logdriver.awslogs,\n            options={\"awslogs-region\": \"us-east-1\"},\n            secret_options=[\n                batch.exposedsecret.from_parameters_store(\"xyz\", ssm.stringparameter.from_string_parameter_name(self, \"parameter\", \"xyz\"))\n            ]\n        )\n    )\n)\n```\n\n### importing an existing job definition\n\n#### from arn\n\nto import an existing batch job definition from its arn, call `jobdefinition.fromjobdefinitionarn()`.\n\nbelow is an example:\n\n```python\njob = batch.jobdefinition.from_job_definition_arn(self, \"imported-job-definition\", \"arn:aws:batch:us-east-1:555555555555:job-definition/my-job-definition\")\n```\n\n#### from name\n\nto import an existing batch job definition from its name, call `jobdefinition.fromjobdefinitionname()`.\nif name is specified without a revision then the latest active revision is used.\n\nbelow is an example:\n\n```python\n# without revision\njob1 = batch.jobdefinition.from_job_definition_name(self, \"imported-job-definition\", \"my-job-definition\")\n\n# with revision\njob2 = batch.jobdefinition.from_job_definition_name(self, \"imported-job-definition\", \"my-job-definition:3\")\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-batch",
  "package_url": "https://pypi.org/project/aws-cdk.aws-batch/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-batch/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-batch/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-ecr (==1.204.0)",
    "aws-cdk.aws-ecs (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-secretsmanager (==1.204.0)",
    "aws-cdk.aws-ssm (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::batch",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk aws_ssm aws batch aws_ecr",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_batch",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_ecr",
    "pypi_aws_cdk.aws_ecs",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_secretsmanager",
    "pypi_aws_cdk.aws_ssm",
    "pypi_aws_cdk.core",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}