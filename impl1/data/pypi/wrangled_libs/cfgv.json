{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "[![build status](https://github.com/asottile/cfgv/actions/workflows/main.yml/badge.svg)](https://github.com/asottile/cfgv/actions/workflows/main.yml)\n[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/asottile/cfgv/main.svg)](https://results.pre-commit.ci/latest/github/asottile/cfgv/main)\n\ncfgv\n====\n\nvalidate configuration and produce human readable error messages.\n\n## installation\n\n```bash\npip install cfgv\n```\n\n## sample error messages\n\nthese are easier to see by example.  here's an example where i typo'd `true`\nin a [pre-commit](https://pre-commit.com) configuration.\n\n```\npre_commit.clientlib.invalidconfigerror:\n==> file /home/asottile/workspace/pre-commit/.pre-commit-config.yaml\n==> at config()\n==> at key: repos\n==> at repository(repo='https://github.com/pre-commit/pre-commit-hooks')\n==> at key: hooks\n==> at hook(id='flake8')\n==> at key: always_run\n=====> expected bool got str\n```\n\n## api\n\n### `cfgv.validate(value, schema)`\n\nperform validation on the schema:\n- raises `validationerror` on failure\n- returns the value on success (for convenience)\n\n### `cfgv.apply_defaults(value, schema)`\n\nreturns a new value which sets all missing optional values to their defaults.\n\n### `cfgv.remove_defaults(value, schema)`\n\nreturns a new value which removes all optional values that are set to their\ndefaults.\n\n### `cfgv.load_from_filename(filename, schema, load_strategy, exc_tp=validationerror)`\n\nload a file given the `load_strategy`.  reraise any errors as `exc_tp`.  all\ndefaults will be populated in the resulting value.\n\nmost useful when used with `functools.partial` as follows:\n\n```python\nload_my_cfg = functools.partial(\n    cfgv.load_from_filename,\n    schema=my_schema,\n    load_strategy=json.loads,\n    exc_tp=myerror,\n)\n```\n\n## making a schema\n\na schema validates a container -- `cfgv` provides `map` and `array` for\nmost normal cases.\n\n### writing your own schema container\n\nif the built-in containers below don't quite satisfy your usecase, you can\nalways write your own.  containers use the following interface:\n\n```python\nclass container(object):\n    def check(self, v):\n        \"\"\"check the passed in value (do not modify `v`)\"\"\"\n\n    def apply_defaults(self, v):\n        \"\"\"return a new value with defaults applied (do not modify `v`)\"\"\"\n\n    def remove_defaults(self, v):\n        \"\"\"return a new value with defaults removed (do not modify `v`)\"\"\"\n```\n\n### `map(object_name, id_key, *items)`\n\nthe most basic building block for creating a schema is a `map`\n\n- `object_name`: will be displayed in error messages\n- `id_key`: will be used to identify the object in error messages.  set to\n  `none` if there is no identifying key for the object.\n- `items`: validator objects such as `required` or `optional`\n\nconsider the following schema:\n\n```python\nmap(\n    'repo', 'url',\n    required('url', check_any),\n)\n```\n\nin an error message, the map may be displayed as:\n\n- `repo(url='https://github.com/pre-commit/pre-commit')`\n- `repo(url=missing)` (if the key is not present)\n\n### `array(of, allow_empty=true)`\n\nused to nest maps inside of arrays.  for arrays of scalars, see `check_array`.\n\n- `of`: a `map` / `array` or other sub-schema.\n- `allow_empty`: when `false`, `array` will ensure at least one element.\n\nwhen validated, this will check that each element adheres to the sub-schema.\n\n## validator objects\n\nvalidator objects are used to validate key-value-pairs of a `map`.\n\n### writing your own validator\n\nif the built-in validators below don't quite satisfy your usecase, you can\nalways write your own.  validators use the following interface:\n\n```python\nclass validator(object):\n    def check(self, dct):\n        \"\"\"check that your specific key has the appropriate value in `dct`\"\"\"\n\n    def apply_default(self, dct):\n        \"\"\"modify `dct` and set the default value if it is missing\"\"\"\n\n    def remove_default(self, dct):\n        \"\"\"modify `dct` and remove the default value if it is present\"\"\"\n```\n\nit may make sense to _borrow_ functions from the built in validators.  they\nadditionally use the following interface(s):\n\n- `self.key`: the key to check\n- `self.check_fn`: the [check function](#check-functions)\n- `self.default`: a default value to set.\n\n### `required(key, check_fn)`\n\nensure that a key is present in a `map` and adheres to the\n[check function](#check-functions).\n\n### `requiredrecurse(key, schema)`\n\nsimilar to `required`, but uses a [schema](#making-a-schema).\n\n### `optional(key, check_fn, default)`\n\nif a key is present, check that it adheres to the\n[check function](#check-functions).\n\n- `apply_defaults` will set the `default` if it is not present.\n- `remove_defaults` will remove the value if it is equal to `default`.\n\n### `optionalrecurse(key, schema, default)`\n\nsimilar to `optional` but uses a [schema](#making-a-schema).\n\n- `apply_defaults` will set the `default` if it is not present and then\n  validate it with the schema.\n- `remove_defaults` will remove defaults using the schema, and then remove the\n  value it if it is equal to `default`.\n\n### `optionalnodefault(key, check_fn)`\n\nlike `optional`, but does not `apply_defaults` or `remove_defaults`.\n\n### `conditional(key, check_fn, condition_key, condition_value, ensure_absent=false)`\n\n- if `condition_key` is equal to the `condition_value`, the specific `key`\nwill be checked using the [check function](#check-functions).\n- if `ensure_absent` is `true` and the condition check fails, the `key` will\nbe checked for absense.\n\nnote that the `condition_value` is checked for equality, so any object\nimplementing `__eq__` may be used.  a few are provided out of the box\nfor this purpose, see [equality helpers](#equality-helpers).\n\n### `conditionaloptional(key, check_fn, default, condition_key, condition_value, ensure_absent=false)`\n\nsimilar to ``conditional`` and ``optional``.\n\n### `conditionalrecurse(key, schema, condition_key, condition_value, ensure_absent=true)`\n\nsimilar to `conditional`, but uses a [schema](#making-a-schema).\n\n### `noadditionalkeys(keys)`\n\nuse in a mapping to ensure that only the `keys` specified are present.\n\n## equality helpers\n\nequality helpers at the very least implement `__eq__` for their behaviour.\n\nthey may also implement `def describe_opposite(self):` for use in the\n`ensure_absent=true` error message (otherwise, the `__repr__` will be used).\n\n### `not(val)`\n\nreturns `true` if the value is not equal to `val`.\n\n### `in(*values)`\n\nreturns `true` if the value is contained in `values`.\n\n### `notin(*values)`\n\nreturns `true` if the value is not contained in `values`.\n\n## check functions\n\na number of check functions are provided out of the box.\n\na check function takes a single parameter, the `value`, and either raises a\n`validationerror` or returns nothing.\n\n### `check_any(_)`\n\na noop check function.\n\n### `check_type(tp, typename=none)`\n\nreturns a check function to check for a specific type.  setting `typename`\nwill replace the type's name in the error message.\n\nfor example:\n\n```python\nrequired('key', check_type(int))\n# 'expected bytes' in both python2 and python3.\nrequired('key', check_type(bytes, typename='bytes'))\n```\n\nseveral type checking functions are provided out of the box:\n\n- `check_bool`\n- `check_bytes`\n- `check_int`\n- `check_string`\n- `check_text`\n\n### `check_one_of(possible)`\n\nreturns a function that checks that the value is contained in `possible`.\n\nfor example:\n\n```python\nrequired('language', check_one_of(('javascript', 'python', 'ruby')))\n```\n\n### `check_regex(v)`\n\nensures that `v` is a valid python regular expression.\n\n### `check_array(inner_check)`\n\nreturns a function that checks that a value is a sequence and that each\nvalue in that sequence adheres to the `inner_check`.\n\nfor example:\n\n```python\nrequired('args', check_array(check_string))\n```\n\n### `check_and(*fns)`\n\nreturns a function that performs multiple checks on a value.\n\nfor example:\n\n```python\nrequired('language', check_and(check_string, my_check_language))\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "cfgv",
  "package_url": "https://pypi.org/project/cfgv/",
  "project_url": "https://pypi.org/project/cfgv/",
  "project_urls": {
    "Homepage": "https://github.com/asottile/cfgv"
  },
  "release_url": "https://pypi.org/project/cfgv/3.4.0/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "validate configuration and produce human readable error messages.",
  "version": "3.4.0",
  "releases": [],
  "developers": [
    "anthony_sottile",
    "asottile@umich.edu"
  ],
  "kwds": "cfgv load_my_cfg pip pre_commit badge",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_cfgv",
  "homepage": "https://github.com/asottile/cfgv",
  "release_count": 19,
  "dependency_ids": []
}