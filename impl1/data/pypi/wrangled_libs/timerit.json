{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "\n|githubactions| |appveyor| |codecov| |pypi| |downloads| |readthedocs|\n\n\ntimerit\n=======\n\na powerful multiline alternative to python's builtin ``timeit`` module.\n\ndocs are published at https://timerit.readthedocs.io/en/latest/ but this readme\nand code comments contain a walkthrough.\n\n+---------------+--------------------------------------------+\n| github        | https://github.com/erotemic/timerit        |\n+---------------+--------------------------------------------+\n| pypi          | https://pypi.org/project/timerit           |\n+---------------+--------------------------------------------+\n| readthedocs   | https://timerit.readthedocs.io/en/latest/  |\n+---------------+--------------------------------------------+\n\ndescription\n-----------\n\neasily do robust timings on existing blocks of code by simply indenting\nthem. there is no need to refactor into a string representation or\nconvert to a single line.\n\ninstallation\n------------\n\n.. code:: bash\n\n    pip install timerit\n\n\ninteractive use\n---------------\n\nthe ``timerit`` library provides a succinct api for interactive use:\n\n.. code:: python\n\n    >>> import timerit\n    >>> for _ in timerit:\n    ...     sum(range(100000))\n    timed for: 288 loops, best of 5\n        time per loop: best=616.740 \u00b5s, mean=668.933 \u00b1 124.2 \u00b5s\n\ncompare to ``timeit``:\n\n.. code:: bash\n\n    $ python -m timeit 'sum(range(100000))'\n    500 loops, best of 5: 721 usec per loop\n\nby default, any code within the loop will be repeatedly executed until at least\n200 ms have elapsed.  the timing results are then printed out.\n\nhere's what each of the numbers means:\n\n- \"288 loops\": the code in the loop was run 288 times before the time limit was\n  reached.\n\n- \"best of 5\": consider only the fastest of every 5 measured times, when\n  calculating the mean and standard deviation.  the reason for doing this is\n  that you can get slow times if the something in the background is consuming\n  resources, so you're generally only interested in the fastest times.  this\n  idea is also described in the\n  `timeit <https://docs.python.org/3/library/timeit.html#timeit.timer.repeat>`_ docs.\n\n- \"best=616.740 \u00b5s\": how long the fastest iteration took to run.  for the reasons\n  described above, this is usually the most consistent number, and the primary\n  number you should focus on.\n\n- \"mean=668.933 \u00b1 124.2 \u00b5s\": the mean and the standard deviation of the \"best of 5\"\n  iterations.  this statistic is usually not as robust or useful as the fastest\n  time, but sometimes its helpful to know if there's high variance.\n\nthe loop variable can be used as a context manager to only time a part of each\nloop (e.g. to make the timings more accurate, or to incorporate a setup phase\nthat is not timed):\n\n.. code:: python\n\n    >>> for timer in timerit:\n    ...     n = 100 * 1000\n    ...     with timer:\n    ...         sum(range(n))\n    timed for: 318 loops, best of 5\n        time per loop: best=616.673 \u00b5s, mean=617.545 \u00b1 0.9 \u00b5s\n\nit is also possible to provide arguments controlling how the timing\nmeasurements are made.  see the online documentation for more information on\nthese arguments, but the snippet below runs for exactly 100 iterations, instead\nof however many fit in 200 ms.\n\n.. code:: python\n\n    >>> for _ in timerit(num=100):\n    ...     sum(range(100000))\n    timed for: 100 loops, best of 5\n        time per loop: best=616.866 \u00b5s, mean=619.120 \u00b1 5.3 \u00b5s\n\n\nautomatic import\n~~~~~~~~~~~~~~~~\nif you want to make ``timerit`` even easier to use interactively, you can move\nthe import to the pythonstartup_ file.  if defined, this environment variable\ngives the path to a python script that will be executed just before every\ninteractive session.  for example:\n\n.. code:: bash\n\n    $ export pythonstartup=~/.pythonrc\n    $ cat $pythonstartup\n    import timerit\n    $ python\n    >>> for _ in timerit:\n    ...     sum(range(100000))\n    ...\n    timed for: 59 loops, best of 3\n        time per loop: best=2.532 ms, mean=3.309 \u00b1 1.0 ms\n\n\nprogrammatic use\n----------------\n\nthe timerit library also provides a ``timerit`` class that can be used\nprogrammatically.\n\n.. code:: python\n\n    >>> import math, timerit\n    >>> for timer in timerit:\n    >>>     setup_vars = 10000\n    >>>     with timer:\n    >>>         math.factorial(setup_vars)\n    >>> print('t1.total_time = %r' % (t1.total_time,))\n    timing for 200 loops\n    timed for: 200 loops, best of 3\n        time per loop: best=2.064 ms, mean=2.115 \u00b1 0.05 ms\n    t1.total_time = 0.4427177629695507\n\na common pattern is to create a single ``timerit`` instance, then to repeatedly\n\"reset\" it with different labels to test a number of different algorithms.  the\nlabels assigned in this way will be incorporated into the report strings that\nthe ``timerit`` instance produces.  the \"benchmark recipe\" below shows an example\nof this pattern.  so do all of the scripts in the ``examples/`` directory.\n\nthere is also a simple one-liner that is comparable to ``timeit``'s ipython magic:\n\ncompare the timeit version:\n\n.. code:: python\n\n    >>> %timeit math.factorial(100)\n    564 ns \u00b1 5.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n\nwith the timerit version:\n\n.. code:: python\n\n    >>> timerit(100000).call(math.factorial, 100).print()\n    timed for: 1 loops, best of 1\n        time per loop: best=4.828 \u00b5s, mean=4.828 \u00b1 0.0 \u00b5s\n\n\nhow it works\n------------\n\nthe timerit module defines ``timerit.timerit``, which is an iterable object\nthat yields ``timerit.timer`` context managers.\n\n.. code:: python\n\n    >>> import math\n    >>> from timerit import timerit\n    >>> for timer in timerit(num=200, verbose=2):\n    >>>     with timer:\n    >>>         math.factorial(10000)\n\nthe timer context manager measures how much time the body of it takes by\n\"tic\"-ing on ``__enter__`` and \"toc\"-ing on ``__exit__``. the parent\n``timerit`` object has access to the context manager, so it is able to read its\nmeasurement. these measurements are stored and then we compute some statistics\non them. notably the minimum, mean, and standard-deviation of grouped (batched)\nrunning times.\n\nusing the with statement inside the loop is nice because you can run untimed\nsetup code before you enter the context manager.\n\nin the case where no setup code is required, a more concise version of the\nsyntax is available.\n\n.. code:: python\n\n    >>> import math\n    >>> from timerit import timerit\n    >>> for _ in timerit(num=200, verbose=2):\n    >>>     math.factorial(10000)\n\nif the context manager is never called, the ``timerit`` object detects this and\nthe measurement is made in the ``__iter__`` method in the ``timerit`` object\nitself. i believe that this concise method contains slightly more overhead than\nthe with-statement version. (i have seen evidence that this might actually be\nmore accurate, but it needs further testing).\n\nbenchmark recipe\n----------------\n\n.. code:: python\n\n    import ubelt as ub\n    import pandas as pd\n    import timerit\n\n    def method1(x):\n        ret = []\n        for i in range(x):\n            ret.append(i)\n        return ret\n\n    def method2(x):\n        ret = [i for i in range(x)]\n        return ret\n\n    method_lut = locals()  # can populate this some other way\n\n    ti = timerit.timerit(100, bestof=10, verbose=2)\n\n    basis = {\n        'method': ['method1', 'method2'],\n        'x': list(range(7)),\n        # 'param_name': [param values],\n    }\n    grid_iter = ub.named_product(basis)\n\n    # for each variation of your experiment, create a row.\n    rows = []\n    for params in grid_iter:\n        key = ub.repr2(params, compact=1, si=1)\n        kwargs = params.copy()\n        method_key = kwargs.pop('method')\n        method = method_lut[method_key]\n        # timerit will run some user-specified number of loops.\n        # and compute time stats with similar methodology to timeit\n        for timer in ti.reset(key):\n            # put any setup logic you dont want to time here.\n            # ...\n            with timer:\n                # put the logic you want to time here\n                method(**kwargs)\n        row = {\n            'mean': ti.mean(),\n            'min': ti.min(),\n            'key': key,\n            **params,\n        }\n        rows.append(row)\n\n    # the rows define a long-form pandas data array.\n    # data in long-form makes it very easy to use seaborn.\n    data = pd.dataframe(rows)\n    print(data)\n\n    plot = true\n    if plot:\n        # import seaborn as sns\n        # kwplot autosns works well for ipython and script execution.\n        # not sure about notebooks.\n        import kwplot\n        sns = kwplot.autosns()\n\n        # your variables may change\n        ax = kwplot.figure(fnum=1, doclf=true).gca()\n        sns.lineplot(data=data, x='x', y='min', hue='method', marker='o', ax=ax)\n        ax.set_title('benchmark name')\n        ax.set_xlabel('x-variable description')\n        ax.set_ylabel('y-variable description')\n\n\n.. |travis| image:: https://img.shields.io/travis/erotemic/timerit/master.svg?label=travis%20ci\n   :target: https://travis-ci.org/erotemic/timerit?branch=master\n.. |codecov| image:: https://codecov.io/github/erotemic/timerit/badge.svg?branch=master&service=github\n   :target: https://codecov.io/github/erotemic/timerit?branch=master\n.. |appveyor| image:: https://ci.appveyor.com/api/projects/status/github/erotemic/timerit?branch=master&svg=true\n   :target: https://ci.appveyor.com/project/erotemic/timerit/branch/master\n.. |pypi| image:: https://img.shields.io/pypi/v/timerit.svg\n   :target: https://pypi.python.org/pypi/timerit\n.. |downloads| image:: https://img.shields.io/pypi/dm/timerit.svg\n   :target: https://pypistats.org/packages/timerit\n.. |circleci| image:: https://circleci.com/gh/erotemic/timerit.svg?style=svg\n    :target: https://circleci.com/gh/erotemic/timerit\n.. |readthedocs| image:: https://readthedocs.org/projects/timerit/badge/?version=latest\n    :target: http://timerit.readthedocs.io/en/latest/\n.. |codequality| image:: https://api.codacy.com/project/badge/grade/fdcedca723f24ec4be9c7067d91cb43b\n    :target: https://www.codacy.com/manual/erotemic/timerit?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=erotemic/timerit&amp;utm_campaign=badge_grade\n.. |githubactions| image:: https://github.com/erotemic/timerit/actions/workflows/tests.yml/badge.svg?branch=main\n    :target: https://github.com/erotemic/timerit/actions?query=branch%3amain\n\n.. _pythonstartup: https://docs.python.org/3/using/cmdline.html?highlight=pythonstartup#envvar-pythonstartup\n\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2",
  "name": "timerit",
  "package_url": "https://pypi.org/project/timerit/",
  "project_url": "https://pypi.org/project/timerit/",
  "project_urls": {
    "Homepage": "https://github.com/Erotemic/timerit"
  },
  "release_url": "https://pypi.org/project/timerit/1.1.0/",
  "requires_dist": [
    "xdoctest (>=1.1.0) ; extra == 'all'",
    "xdoctest (==1.1.0) ; extra == 'all-strict'",
    "pytest-cov (==2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all-strict'",
    "pytest (<=4.6.11,==4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all-strict'",
    "pytest (==4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'all-strict'",
    "pytest-cov (==2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all-strict'",
    "pytest (<=4.6.11,==4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all-strict'",
    "pytest-cov (==2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all-strict'",
    "pytest (<=6.1.2,==4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all-strict'",
    "pytest (==4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'all-strict'",
    "pytest (==6.2.5) ; (python_version >= \"3.10.0\") and extra == 'all-strict'",
    "pytest-cov (==3.0.0) ; (python_version >= \"3.6.0\") and extra == 'all-strict'",
    "pytest-cov (>=2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all'",
    "pytest (<=4.6.11,>=4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'all'",
    "pytest (>=4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'all'",
    "pytest-cov (>=2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all'",
    "pytest (<=4.6.11,>=4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'all'",
    "pytest-cov (>=2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all'",
    "pytest (<=6.1.2,>=4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'all'",
    "pytest (>=4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'all'",
    "pytest (>=6.2.5) ; (python_version >= \"3.10.0\") and extra == 'all'",
    "pytest-cov (>=3.0.0) ; (python_version >= \"3.6.0\") and extra == 'all'",
    "xdoctest (>=1.1.0) ; extra == 'tests'",
    "xdoctest (==1.1.0) ; extra == 'tests-strict'",
    "pytest-cov (==2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests-strict'",
    "pytest (<=4.6.11,==4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests-strict'",
    "pytest (==4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'tests-strict'",
    "pytest-cov (==2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests-strict'",
    "pytest (<=4.6.11,==4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests-strict'",
    "pytest-cov (==2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests-strict'",
    "pytest (<=6.1.2,==4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests-strict'",
    "pytest (==4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'tests-strict'",
    "pytest (==6.2.5) ; (python_version >= \"3.10.0\") and extra == 'tests-strict'",
    "pytest-cov (==3.0.0) ; (python_version >= \"3.6.0\") and extra == 'tests-strict'",
    "pytest-cov (>=2.8.1) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests'",
    "pytest (<=4.6.11,>=4.6.0) ; (python_version < \"2.8.0\" and python_version >= \"2.7.0\") and extra == 'tests'",
    "pytest (>=4.6.0) ; (python_version < \"3.10.0\" and python_version >= \"3.7.0\") and extra == 'tests'",
    "pytest-cov (>=2.8.1) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests'",
    "pytest (<=4.6.11,>=4.6.0) ; (python_version < \"3.5.0\" and python_version >= \"3.4.0\") and extra == 'tests'",
    "pytest-cov (>=2.9.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests'",
    "pytest (<=6.1.2,>=4.6.0) ; (python_version < \"3.6.0\" and python_version >= \"3.5.0\") and extra == 'tests'",
    "pytest (>=4.6.0) ; (python_version < \"3.7.0\" and python_version >= \"3.6.0\") and extra == 'tests'",
    "pytest (>=6.2.5) ; (python_version >= \"3.10.0\") and extra == 'tests'",
    "pytest-cov (>=3.0.0) ; (python_version >= \"3.6.0\") and extra == 'tests'"
  ],
  "requires_python": ">=3.6",
  "summary": "a powerful multiline alternative to timeit",
  "version": "1.1.0",
  "releases": [],
  "developers": [
    "erotemic@gmail.com",
    "jon_crall"
  ],
  "kwds": "timerit _pythonstartup pythonstartup pythonstartup_ pythonrc",
  "license_kwds": "apache 2",
  "libtype": "pypi",
  "id": "pypi_timerit",
  "homepage": "https://github.com/erotemic/timerit",
  "release_count": 9,
  "dependency_ids": [
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_xdoctest"
  ]
}