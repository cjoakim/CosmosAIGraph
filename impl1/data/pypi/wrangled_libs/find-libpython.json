{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "topic :: software development :: libraries"
  ],
  "description": "# find_libpython\n\na pypi project version of [this](https://gist.github.com/tkf/d980eee120611604c0b9b5fef5b8dae6) gist, which also appears\nwithin the [pycall](https://github.com/juliapy/pycall.jl/blob/master/deps/find_libpython.py) library.\n\nthe library is designed to find the path to the libpython dynamic library for the current python environment.\nit should work with many types of installations, whether it be conda-managed, system-managed, or otherwise.\nand it should function on windows, mac os/os x, and any linux distribution.\n\nthis code is useful in several contexts, including projects that embed a python interpreter into another process,\nor python library build systems.\n\n## usage\n\n`find_libpython` is both a script and a python package.\nusage as a script is useful in contexts like obtaining the path to libpython for linking in makefile-based build systems.\nit could also be used to determine the path to libpython for embedding a python interpreter in a process written in another language.\nin that case the recommended usage is to simply call the script in a subprocess with no arguments and parse the output.\n\n```\n> find_libpython\n/home/kaleb/miniconda3/envs/test/lib/libpython3.8.so.1.0\n```\n\nthe full help message:\n```\n> find_libpython --help\nusage: find_libpython [-h] [--verbose] [--list-all | --candidate-names | --candidate-paths]\n\nlocate libpython associated with this python executable.\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --verbose, -v      print debugging information.\n  --list-all         print list of all paths found.\n  --candidate-names  print list of candidate names of libpython.\n  --candidate-paths  print list of candidate paths of libpython.\n```\n\nusage as a library might occur when you need to obtain the path to the library in a python-based build system like distutils.\nit is recommended to use the `find_libpython` method which will return the path to libpython as a string, or `none` if it cannot be found.\n\n```python\n>>> from find_libpython import find_libpython\n>>> find_libpython()\n'/home/kaleb/miniconda3/envs/test/lib/libpython3.8.so.1.0'\n```\n",
  "docs_url": null,
  "keywords": "libpython",
  "license": "mit",
  "name": "find-libpython",
  "package_url": "https://pypi.org/project/find-libpython/",
  "project_url": "https://pypi.org/project/find-libpython/",
  "project_urls": {
    "Homepage": "https://github.com/ktbarrett/find_libpython"
  },
  "release_url": "https://pypi.org/project/find-libpython/0.3.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "finds the libpython associated with your environment, wherever it may be hiding",
  "version": "0.3.1",
  "releases": [],
  "developers": [
    "dev.ktbarrett@gmail.com",
    "kaleb_barrett",
    "takafumi_arakaki"
  ],
  "kwds": "find_libpython libpython libpython3 juliapy pycall",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_find_libpython",
  "homepage": "https://github.com/ktbarrett/find_libpython",
  "release_count": 5,
  "dependency_ids": []
}