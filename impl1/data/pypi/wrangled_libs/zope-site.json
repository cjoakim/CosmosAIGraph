{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: zope :: 3",
    "intended audience :: developers",
    "license :: osi approved :: zope public license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: internet :: www/http"
  ],
  "description": "===============\n ``zope.site``\n===============\n\n.. image:: https://img.shields.io/pypi/v/zope.site.svg\n        :target: https://pypi.python.org/pypi/zope.site/\n        :alt: latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/zope.site.svg\n        :target: https://pypi.org/project/zope.site/\n        :alt: supported python versions\n\n.. image:: https://github.com/zopefoundation/zope.site/workflows/tests/badge.svg\n   :target: https://github.com/zopefoundation/zope.site/actions?query=workflow%3atests\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/zope.site/badge.svg?branch=master\n        :target: https://coveralls.io/github/zopefoundation/zope.site?branch=master\n\n.. image:: https://readthedocs.org/projects/zopesite/badge/?version=latest\n        :target: httpl://zopesite.readthedocs.io/en/latest/\n        :alt: documentation status\n\n\nthis package provides a local and persistent site manager\nimplementation, so that one can register local utilities and\nadapters. it uses local adapter registries for its adapter and utility\nregistry. the module also provides some facilities to organize the\nlocal software and ensures the correct behavior inside the zodb.\n\ndocumentation is hosted at https://zopesite.readthedocs.io\n\n\nsites and local site managers\n=============================\n\nthis is an introduction of location-based component architecture.\n\ncreating and accessing sites\n----------------------------\n\n*sites* are used to provide custom component setups for parts of your\napplication or web site. every folder:\n\n  >>> from zope.site import folder\n  >>> myfolder = folder.rootfolder()\n\nhas the potential to become a site:\n\n  >>> from zope.component.interfaces import isite, ipossiblesite\n  >>> ipossiblesite.providedby(myfolder)\n  true\n\nbut is not yet one:\n\n  >>> isite.providedby(myfolder)\n  false\n\nif you would like your custom content component to be able to become a site,\nyou can use the `sitemanagercontainer` mix-in class:\n\n  >>> from zope import site\n  >>> class mycontentcomponent(site.sitemanagercontainer):\n  ...     pass\n\n  >>> mycontent = mycontentcomponent()\n  >>> ipossiblesite.providedby(mycontent)\n  true\n  >>> isite.providedby(mycontent)\n  false\n\nto convert a possible site to a real site, we have to provide a site manager:\n\n  >>> sm = site.localsitemanager(myfolder)\n  >>> myfolder.setsitemanager(sm)\n  >>> isite.providedby(myfolder)\n  true\n  >>> myfolder.getsitemanager() is sm\n  true\n\nnote that an event is generated when a local site manager is created:\n\n  >>> from zope.component.eventtesting import getevents\n  >>> from zope.site.interfaces import inewlocalsite\n  >>> [event] = getevents(inewlocalsite)\n  >>> event.manager is sm\n  true\n\nif one tries to set a bogus site manager, a `valueerror` will be raised:\n\n   >>> myfolder2 = folder.folder()\n   >>> myfolder2.setsitemanager(object)\n   traceback (most recent call last):\n   ...\n   valueerror: setsitemanager requires an icomponentlookup\n\nif the possible site has been changed to a site already, a `typeerror`\nis raised when one attempts to add a new site manager:\n\n  >>> myfolder.setsitemanager(site.localsitemanager(myfolder))\n  traceback (most recent call last):\n  ...\n  typeerror: already a site\n\nthere is also an adapter you can use to get the next site manager from any\nlocation:\n\n  >>> myfolder['mysubfolder'] = folder.folder()\n  >>> import zope.interface.interfaces\n  >>> zope.interface.interfaces.icomponentlookup(myfolder['mysubfolder']) is sm\n  true\n\nif the location passed is a site, the site manager of that site is returned:\n\n  >>> zope.interface.interfaces.icomponentlookup(myfolder) is sm\n  true\n\n\nusing the site manager\n----------------------\n\na site manager contains several *site management folders*, which are used to\nlogically organize the software. when a site manager is initialized, a default\nsite management folder is created:\n\n  >>> sm = myfolder.getsitemanager()\n  >>> default = sm['default']\n  >>> default.__class__\n  <class 'zope.site.site.sitemanagementfolder'>\n\nhowever, you can tell not to create the default site manager folder on\nlocalsitemanager creation:\n\n  >>> nodefault = site.localsitemanager(myfolder, default_folder=false)\n  >>> 'default' in nodefault\n  false\n\nalso, note that when creating localsitemanager, its __parent__ is set to\nsite that was passed to constructor and the __name__ is set to ++etc++site.\n\n  >>> nodefault.__parent__ is myfolder\n  true\n  >>> nodefault.__name__ == '++etc++site'\n  true\n\nyou can easily create a new site management folder:\n\n  >>> sm['mysmf'] = site.sitemanagementfolder()\n  >>> sm['mysmf'].__class__\n  <class 'zope.site.site.sitemanagementfolder'>\n\nonce you have your site management folder -- let's use the default one -- we\ncan register some components. let's start with a utility (we define it\nin a ``__module__`` that can be pickled):\n\n  >>> import zope.interface\n  >>> __name__ = 'zope.site.tests'\n  >>> class imyutility(zope.interface.interface):\n  ...     pass\n\n  >>> import persistent\n  >>> from zope.container.contained import contained\n  >>> @zope.interface.implementer(imyutility)\n  ... class myutility(persistent.persistent, contained):\n  ...     def __init__(self, title):\n  ...         self.title = title\n  ...     def __repr__(self):\n  ...         return \"%s('%s')\" %(self.__class__.__name__, self.title)\n\nnow we can create an instance of our utility and put it in the site\nmanagement folder and register it:\n\n  >>> myutil = myutility('my custom utility')\n  >>> default['myutil'] = myutil\n  >>> sm.registerutility(myutil, imyutility, 'u1')\n\nnow we can ask the site manager for the utility:\n\n  >>> sm.queryutility(imyutility, 'u1')\n  myutility('my custom utility')\n\nof course, the local site manager has also access to the global component\nregistrations:\n\n  >>> gutil = myutility('global utility')\n  >>> from zope.component import getglobalsitemanager\n  >>> gsm = getglobalsitemanager()\n  >>> gsm.registerutility(gutil, imyutility, 'gutil')\n\n  >>> sm.queryutility(imyutility, 'gutil')\n  myutility('global utility')\n\nnext let's see whether we can also successfully register an adapter as\nwell. here the adapter will provide the size of a file:\n\n  >>> class ifile(zope.interface.interface):\n  ...     pass\n\n  >>> class isized(zope.interface.interface):\n  ...     pass\n\n  >>> @zope.interface.implementer(ifile)\n  ... class file(object):\n  ...     pass\n\n  >>> @zope.interface.implementer(isized)\n  ... class filesize(object):\n  ...     def __init__(self, context):\n  ...         self.context = context\n\nnow that we have the adapter we need to register it:\n\n  >>> sm.registeradapter(filesize, [ifile])\n\nfinally, we can get the adapter for a file:\n\n  >>> file = file()\n  >>> size = sm.queryadapter(file, isized, name='')\n  >>> isinstance(size, filesize)\n  true\n  >>> size.context is file\n  true\n\nby the way, once you set a site\n\n  >>> from zope.component import hooks\n  >>> hooks.setsite(myfolder)\n\nyou can simply use the zope.component's `getsitemanager()` method to get\nthe nearest site manager:\n\n  >>> from zope.component import getsitemanager\n  >>> getsitemanager() is sm\n  true\n\nthis also means that you can simply use zope.component to look up your utility\n\n  >>> from zope.component import getutility\n  >>> getutility(imyutility, 'gutil')\n  myutility('global utility')\n\nor the adapter via the interface's `__call__` method:\n\n  >>> size = isized(file)\n  >>> isinstance(size, filesize)\n  true\n  >>> size.context is file\n  true\n\n\nmultiple sites\n--------------\n\nuntil now we have only dealt with one local and the global site. but things\nreally become interesting, once we have multiple sites. we can override other\nlocal configuration.\n\nthis behaviour uses the notion of location, therefore we need to configure the\nzope.location package first:\n\n  >>> import zope.configuration.xmlconfig\n  >>> _  = zope.configuration.xmlconfig.string(\"\"\"\n  ... <configure xmlns=\"http://namespaces.zope.org/zope\">\n  ...   <include package=\"zope.component\" file=\"meta.zcml\"/>\n  ...   <include package=\"zope.location\" />\n  ... </configure>\n  ... \"\"\")\n\nlet's now create a new folder called `folder11`, add it to `myfolder` and make\nit a site:\n\n  >>> myfolder11 = folder.folder()\n  >>> myfolder['myfolder11'] = myfolder11\n  >>> myfolder11.setsitemanager(site.localsitemanager(myfolder11))\n  >>> sm11 = myfolder11.getsitemanager()\n\nif we ask the second site manager for its next, we get\n\n  >>> sm11.__bases__ == (sm, )\n  true\n\nand the first site manager should have the folling sub manager:\n\n  >>> sm.subs == (sm11,)\n  true\n\nif we now register a second utility with the same name and interface with the\nnew site manager folder,\n\n  >>> default11 = sm11['default']\n  >>> myutil11 = myutility('utility, uno & uno')\n  >>> default11['myutil'] = myutil11\n\n  >>> sm11.registerutility(myutil11, imyutility, 'u1')\n\nthen it will will be available in the second site manager\n\n  >>> sm11.queryutility(imyutility, 'u1')\n  myutility('utility, uno & uno')\n\nbut not in the first one:\n\n  >>> sm.queryutility(imyutility, 'u1')\n  myutility('my custom utility')\n\nit is also interesting to look at the use cases of moving and copying a\nsite. to do that we create a second root folder and make it a site, so that\nsite hierarchy is as follows:\n\n::\n\n           _____ global site _____\n          /                       \\\n      myfolder                 myfolder2\n          |\n      myfolder11\n\n\n  >>> myfolder2 = folder.rootfolder()\n  >>> myfolder2.setsitemanager(site.localsitemanager(myfolder2))\n\nbefore we can move or copy sites, we need to register two event subscribers\nthat manage the wiring of site managers after moving or copying:\n\n  >>> import zope.lifecycleevent.interfaces\n  >>> gsm.registerhandler(\n  ...    site.changesiteconfigurationaftermove,\n  ...    (isite, zope.lifecycleevent.interfaces.iobjectmovedevent),\n  ...    )\n\nwe only have to register one event listener, since the copy action causes an\n`iobjectaddedevent` to be created, which is just a special type of\n`iobjectmovedevent`.\n\nfirst, make sure that everything is setup correctly in the first place:\n\n  >>> myfolder11.getsitemanager().__bases__ == (myfolder.getsitemanager(), )\n  true\n  >>> myfolder.getsitemanager().subs[0] is myfolder11.getsitemanager()\n  true\n  >>> myfolder2.getsitemanager().subs\n  ()\n\nlet's now move ``myfolder11`` from ``myfolder`` to ``myfolder2``:\n\n  >>> myfolder2['myfolder21'] = myfolder11\n  >>> del myfolder['myfolder11']\n\nnow the next site manager for ``myfolder11``'s site manager should have changed:\n\n  >>> myfolder21 = myfolder11\n  >>> myfolder21.getsitemanager().__bases__ == (myfolder2.getsitemanager(), )\n  true\n  >>> myfolder2.getsitemanager().subs[0] is myfolder21.getsitemanager()\n  true\n  >>> myfolder.getsitemanager().subs\n  ()\n\nmake sure that our interfaces and classes are picklable:\n\n  >>> import sys\n  >>> sys.modules['zope.site.tests'].imyutility = imyutility\n  >>> sys.modules['zope.site.tests'].myutility = myutility\n\n  >>> from pickle import dumps, loads\n  >>> data = dumps(myfolder2['myfolder21'])\n  >>> myfolder['myfolder11'] = loads(data)\n\n  >>> myfolder11 = myfolder['myfolder11']\n  >>> myfolder11.getsitemanager().__bases__ == (myfolder.getsitemanager(), )\n  true\n  >>> myfolder.getsitemanager().subs[0] is myfolder11.getsitemanager()\n  true\n  >>> myfolder2.getsitemanager().subs[0] is myfolder21.getsitemanager()\n  true\n\nfinally, let's check that everything works fine when our folder is moved\nto the folder that doesn't contain any site manager. our folder's\nsitemanager's bases should be set to global site manager.\n\n  >>> myfolder11.getsitemanager().__bases__ == (myfolder.getsitemanager(), )\n  true\n\n  >>> nosm = folder.folder()\n  >>> nosm['root'] = myfolder11\n  >>> myfolder11.getsitemanager().__bases__ == (gsm, )\n  true\n\ndeleting a site unregisters its site manger from its parent site manager:\n\n  >>> del myfolder2['myfolder21']\n  >>> myfolder2.getsitemanager().subs\n  ()\n\nthe removed site manager now has no bases:\n\n  >>> myfolder21.getsitemanager().__bases__\n  ()\n\n\n=========\n changes\n=========\n\n5.0 (2023-06-30)\n================\n\n- drop support for python 2.7, 3.5, 3.6.\n\n- add support for python 3.11.\n\n\n4.6.1 (2022-09-02)\n==================\n\n- fix more deprecation warnings.\n\n\n4.6 (2022-08-23)\n================\n\n- add support for python 3.9, 3.10.\n\n- fix deprecation warning.\n\n\n4.5.0 (2021-03-04)\n==================\n\n- fix the interface definition of ``irootfolder`` to give ``iroot``\n  higher priority than the folder and container interfaces. this is\n  what is usually expected, but not what the code defined. commonly,\n  in the past, this problem was hidden because the factory function\n  ``rootfolder()`` re-arranged the interfaces to put ``iroot`` at the\n  front. under zope.interface 5's c3 resolution order, however, this\n  rearrangement was not taking place; thus, looking up adapters for a\n  ``rootfolder()`` object was likely to find adapters for\n  ``iitemcontainer``  instead of adapters for ``iroot`` as intended.\n\n  with this change, users of ``rootfolder()`` should notice no changes\n  compared with zope.interface 4. code that has classes defined to\n  implement ``irootfolder`` directly, though, may notice a different\n  resolution order on those objects (consistent with what\n  ``rootfolder()`` generates).\n\n  see `issue 17 <https://github.com/zopefoundation/zope.site/issues/17>`_.\n\n\n4.4.0 (2020-09-10)\n==================\n\n- on removal of a site, clear the bases of its site manager. this fixes a reference leak\n  from a parent site manager. see\n  `issue 1 <https://github.com/zopefoundation/zope.site/issues/1>`_.\n\n\n4.3.0 (2020-04-01)\n==================\n\n- add support for python 3.8.\n\n- drop support for python 3.4.\n\n- drop support for the deprecated ``python setup.py test`` command.\n\n- fix tests with zope.interface 5.0. see `issue 12\n  <https://github.com/zopefoundation/zope.site/issues/12>`_.\n\n\n4.2.2 (2018-10-19)\n==================\n\n- fix more ``deprecationwarnings``. see `issue 10\n  <https://github.com/zopefoundation/zope.site/issues/10>`_.\n\n\n4.2.1 (2018-10-11)\n==================\n\n- use current import location for ``utilityregistration`` and ``iutilityregistration``\n  classes to avoid ``deprecationwarning``.\n\n\n4.2.0 (2018-10-09)\n==================\n\n- add support for python 3.7.\n\n\n4.1.0 (2017-08-08)\n==================\n\n- add support for python 3.5 and 3.6.\n\n- drop support for python 2.6 and 3.3.\n\n- deprecate ``zope.site.hooks.*``, ``zope.site.site.setsite``,\n  ``zope.site.next.getnextutility`` and ``zope.site.next.querynextutility``\n  with ``zope.deprecation``.  these will be removed in version 5.0.\n  they all have replacements in ``zope.component``.\n\n- added implementation for _p_repr in localsitemanager. for further\n  information see `issue 8\n  <https://github.com/zopefoundation/zope.site/issues/8>`_.\n\n- reach 100% test coverage and ensure we remain there.\n\n\n4.0.0 (2014-12-24)\n==================\n\n- add support for pypy.\n\n- add support for python 3.4.\n\n- add support for testing on travis.\n\n\n4.0.0a1 (2013-02-20)\n====================\n\n- added support for python 3.3.\n\n- replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- dropped support for python 2.4 and 2.5.\n\n- include zcml dependencies in configure.zcml, added tests for zcml.\n\n\n3.9.2 (2010-09-25)\n==================\n\n- added not declared, but needed test dependency on `zope.testing`.\n\n3.9.1 (2010-04-30)\n==================\n\n- removed use of 'zope.testing.doctest' in favor of stdlib's 'doctest.\n\n- removed use of 'zope.testing.doctestunit' in favor of stdlib's 'doctest.\n\n3.9.0 (2009-12-29)\n==================\n\n- avoid a test dependency on zope.copypastemove by testing the correct\n  persistent behavior of a site manager using the normal pickle module.\n\n3.8.0 (2009-12-15)\n==================\n\n- removed functional testing setup and dependency on zope.app.testing.\n\n3.7.1 (2009-11-18)\n==================\n\n- moved the zope.site.hooks functionality to zope.component.hooks as it isn't\n  actually dealing with zope.site's concept of a site.\n\n- import isite and ipossiblesite from zope.component after they were moved\n  there from zope.location.\n\n3.7.0 (2009-09-29)\n==================\n\n- cleaned up the undeclared dependency on zope.app.publication by moving the\n  two relevant subscriber registrations and their tests to that package.\n\n- dropped the dependency on zope.traversing which was only used to access\n  zope.location functionality. configure zope.location for some tests.\n\n- demoted zope.configuration to a testing dependency.\n\n3.6.4 (2009-09-01)\n==================\n\n- set __parent__ and __name__ in the localsitemanager's constructor\n  after calling constructor of its superclasses, so __name__ doesn't\n  get overwritten with empty string by the components constructor.\n\n- don't set __parent__ and __name__ attributes of site manager in\n  sitemanagercontainer's ``setsitemanager`` method, as they're\n  already set for localsitemanager. other site manager implementations\n  are not required to have those attributes at all, so we're not\n  adding them anymore.\n\n3.6.3 (2009-07-27)\n==================\n\n- propagate an objectremovedevent to the sitemanager upon removal of a\n  sitemanagercontainer.\n\n3.6.2 (2009-07-24)\n==================\n\n- fixed tests to pass with latest packages.\n\n- removed failing test of persistent interfaces, since it did not test\n  anything in this package and used the deprecated ``zodbcode`` module.\n\n- fix nameerror when calling ``zope.site.testing.sitesetup(site=true)``.\n\n- the ``getnextutility`` and ``querynextutility`` functions was moved to\n  ``zope.component``.  while backward-compatibility imports are provided, it's\n  strongly recommended to update your imports.\n\n3.6.1 (2009-02-28)\n==================\n\n- import symbols moved from zope.traversing to zope.location from the new\n  location.\n\n- don't fail when changing component registry bases while moving isite\n  object to non-isite object.\n\n- allow specify whether to create 'default' sitemanagementfolder on\n  initializing localsitemanager. use the ``default_folder`` argument.\n\n- add a containment constraint to the sitemanagementfolder that makes\n  it only available to be contained in ilocalsitemanagers and other\n  isitemanagementfolders.\n\n- change package's mailing list address to zope-dev at zope.org, as\n  zope3-dev at zope.org is now retired.\n\n- remove old unused code. update package description.\n\n3.6.0 (2009-01-31)\n==================\n\n- use zope.container instead of zope.app.container.\n\n3.5.1 (2009-01-27)\n==================\n\n- extracted from zope.app.component (trunk, 3.5.1 under development)\n  as part of an effort to clean up dependencies between zope packages.\n",
  "docs_url": null,
  "keywords": "zope component architecture local",
  "license": "zpl 2.1",
  "name": "zope.site",
  "package_url": "https://pypi.org/project/zope.site/",
  "project_url": "https://pypi.org/project/zope.site/",
  "project_urls": {
    "Homepage": "http://zopesite.readthedocs.io"
  },
  "release_url": "https://pypi.org/project/zope.site/5.0/",
  "requires_dist": [
    "setuptools",
    "zope.annotation",
    "zope.container",
    "zope.deprecation",
    "zope.security",
    "zope.component (>=4.5.0)",
    "zope.event",
    "zope.interface (>=4.5.0)",
    "zope.lifecycleevent",
    "zope.location",
    "sphinx ; extra == 'docs'",
    "repoze.sphinx.autointerface ; extra == 'docs'",
    "sphinx-rtd-theme ; extra == 'docs'",
    "ZODB ; extra == 'test'",
    "zope.component[zcml] ; extra == 'test'",
    "zope.configuration ; extra == 'test'",
    "zope.security[zcml] ; extra == 'test'",
    "zope.testing ; extra == 'test'",
    "zope.testrunner ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "local registries for zope component architecture",
  "version": "5.0",
  "releases": [],
  "developers": [
    "zope-dev@zope.dev",
    "zope_foundation_and_contributors"
  ],
  "kwds": "zope3 zope zodb zodbcode zcml",
  "license_kwds": "zpl 2.1",
  "libtype": "pypi",
  "id": "pypi_zope.site",
  "homepage": "http://zopesite.readthedocs.io",
  "release_count": 25,
  "dependency_ids": [
    "pypi_repoze.sphinx.autointerface",
    "pypi_setuptools",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme",
    "pypi_zodb",
    "pypi_zope.annotation",
    "pypi_zope.component",
    "pypi_zope.configuration",
    "pypi_zope.container",
    "pypi_zope.deprecation",
    "pypi_zope.event",
    "pypi_zope.interface",
    "pypi_zope.lifecycleevent",
    "pypi_zope.location",
    "pypi_zope.security",
    "pypi_zope.testing",
    "pypi_zope.testrunner"
  ]
}