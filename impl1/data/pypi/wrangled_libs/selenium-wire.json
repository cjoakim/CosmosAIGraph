{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "selenium wire\n=============\n\nselenium wire extends `selenium's <https://www.selenium.dev/documentation/en/>`_ python bindings to give you access to the underlying requests made by the browser. you author your code in the same way as you do with selenium, but you get extra apis for inspecting requests and responses and making changes to them on the fly.\n\n.. image:: https://github.com/wkeeling/selenium-wire/workflows/build/badge.svg\n        :target: https://github.com/wkeeling/selenium-wire/actions\n\n.. image:: https://codecov.io/gh/wkeeling/selenium-wire/branch/master/graph/badge.svg\n        :target: https://codecov.io/gh/wkeeling/selenium-wire\n\n.. image:: https://img.shields.io/badge/python-3.7%2c%203.8%2c%203.9%2c%203.10-blue.svg\n        :target: https://pypi.python.org/pypi/selenium-wire\n\n.. image:: https://img.shields.io/pypi/v/selenium-wire.svg\n        :target: https://pypi.python.org/pypi/selenium-wire\n\n.. image:: https://img.shields.io/pypi/l/selenium-wire.svg\n        :target: https://pypi.python.org/pypi/selenium-wire\n\n.. image:: https://pepy.tech/badge/selenium-wire/month\n        :target: https://pepy.tech/project/selenium-wire\n\nsimple example\n~~~~~~~~~~~~~~\n\n.. code:: python\n\n    from seleniumwire import webdriver  # import from seleniumwire\n\n    # create a new instance of the chrome driver\n    driver = webdriver.chrome()\n\n    # go to the google home page\n    driver.get('https://www.google.com')\n\n    # access requests via the `requests` attribute\n    for request in driver.requests:\n        if request.response:\n            print(\n                request.url,\n                request.response.status_code,\n                request.response.headers['content-type']\n            )\n\nprints:\n\n.. code:: bash\n\n    https://www.google.com/ 200 text/html; charset=utf-8\n    https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_120x44dp.png 200 image/png\n    https://consent.google.com/status?continue=https://www.google.com&pc=s&timestamp=1531511954&gl=gb 204 text/html; charset=utf-8\n    https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png 200 image/png\n    https://ssl.gstatic.com/gb/images/i2_2ec824b0.png 200 image/png\n    https://www.google.com/gen_204?s=webaft&t=aft&atyp=csi&ei=kgrjw7dbonktlwtk77wq&rt=wsrt.366,aft.58,prt.58 204 text/html; charset=utf-8\n    ...\n\nfeatures\n~~~~~~~~\n\n* pure python, user-friendly api\n* http and https requests captured\n* intercept requests and responses\n* modify headers, parameters, body content on the fly\n* capture websocket messages\n* har format supported\n* proxy server support\n\ncompatibilty\n~~~~~~~~~~~~\n\n* python 3.7+\n* selenium 4.0.0+\n* chrome, firefox, edge and remote webdriver supported\n\ntable of contents\n~~~~~~~~~~~~~~~~~\n\n- `installation`_\n\n  * `browser setup`_\n\n  * `openssl`_\n\n- `creating the webdriver`_\n\n- `accessing requests`_\n\n- `request objects`_\n\n- `response objects`_\n\n- `intercepting requests and responses`_\n\n  * `example: add a request header`_\n  * `example: replace an existing request header`_\n  * `example: add a response header`_\n  * `example: add a request parameter`_\n  * `example: update json in a post request body`_\n  * `example: basic authentication`_\n  * `example: block a request`_\n  * `example: mock a response`_\n  * `unset an interceptor`_\n\n- `limiting request capture`_\n\n- `request storage`_\n\n  * `in-memory storage`_\n\n- `proxies`_\n\n  * `socks`_\n\n  * `switching dynamically`_\n\n- `bot detection`_\n\n- `certificates`_\n\n  * `using your own certificate`_\n\n- `all options`_\n\n- `license`_\n\ninstallation\n~~~~~~~~~~~~\n\ninstall using pip:\n\n.. code:: bash\n\n    pip install selenium-wire\n\nif you get an error about not being able to build cryptography you may be running an old version of pip. try upgrading pip with ``python -m pip install --upgrade pip`` and then re-run the above command.\n\nbrowser setup\n-------------\n\nno specific configuration should be necessary except to ensure that you have downloaded the relevent webdriver executable for your browser and placed it somewhere on your system path.\n\n- `download <https://sites.google.com/chromium.org/driver/>`__ webdriver for chrome\n- `download <https://github.com/mozilla/geckodriver/>`__ webdriver for firefox\n- `download <https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/>`__ webdriver for edge\n\nopenssl\n-------\n\nselenium wire requires openssl for decrypting https requests. this is probably already installed on your system (you can check by running ``openssl version`` on the command line). if it's not installed you can install it with:\n\n**linux**\n\n.. code:: bash\n\n    # for apt based linux systems\n    sudo apt install openssl\n\n    # for rpm based linux systems\n    sudo yum install openssl\n\n    # for linux alpine\n    sudo apk add openssl\n\n**macos**\n\n.. code:: bash\n\n    brew install openssl\n\n**windows**\n\nno installation is required.\n\ncreating the webdriver\n~~~~~~~~~~~~~~~~~~~~~~\n\nensure that you import ``webdriver`` from the ``seleniumwire`` package:\n\n.. code:: python\n\n    from seleniumwire import webdriver\n\nthen just instantiate the webdriver as you would if you were using selenium directly. you can pass in any desired capabilities or browser specific options - such as the executable path, headless mode etc. selenium wire also has it's `own options`_ that can be passed in the ``seleniumwire_options`` attribute.\n\n.. code:: python\n\n    # create the driver with no options (use defaults)\n    driver = webdriver.chrome()\n\n    # or create using browser specific options and/or seleniumwire_options options\n    driver = webdriver.chrome(\n        options = webdriver.chromeoptions(...),\n        seleniumwire_options={...}\n    )\n\n.. _`own options`: #all-options\n\nnote that for sub-packages of ``webdriver``, you should continue to import these directly from ``selenium``. for example, to import ``webdriverwait``:\n\n.. code:: python\n\n    # sub-packages of webdriver must still be imported from `selenium` itself\n    from selenium.webdriver.support.ui import webdriverwait\n\n**remote webdriver**\n\nselenium wire has limited support for using the remote webdriver client. when you create an instance of the remote webdriver, you need to specify the hostname or ip address of the machine (or container) running selenium wire. this allows the remote instance to communicate back to selenium wire with its requests and responses.\n\n.. code:: python\n\n    options = {\n        'addr': 'hostname_or_ip'  # address of the machine running selenium wire. explicitly use 127.0.0.1 rather than localhost if remote session is running locally.\n    }\n    driver = webdriver.remote(\n        command_executor='http://www.example.com',\n        seleniumwire_options=options\n    )\n\nif the machine running the browser needs to use a different address to talk to the machine running selenium wire you need to configure the browser manually. `this issue <https://github.com/wkeeling/selenium-wire/issues/220>`_ goes into more detail.\n\naccessing requests\n~~~~~~~~~~~~~~~~~~\n\nselenium wire captures all http/https traffic made by the browser [1]_. the following attributes provide access to requests and responses.\n\n``driver.requests``\n    the list of captured requests in chronological order.\n\n``driver.last_request``\n    convenience attribute for retrieving the most recently captured request. this is more efficient than using ``driver.requests[-1]``.\n\n``driver.wait_for_request(pat, timeout=10)``\n    this method will wait until it sees a request matching a pattern. the ``pat`` attribute will be matched within the request url. ``pat`` can be a simple substring or a regular expression. note that ``driver.wait_for_request()`` doesn't *make* a request, it just *waits* for a previous request made by some other action and it will return the first request it finds. also note that since ``pat`` can be a regular expression, you must escape special characters such as question marks with a slash. a ``timeoutexception`` is raised if no match is found within the timeout period.\n\n    for example, to wait for an ajax request to return after a button is clicked:\n\n    .. code:: python\n\n        # click a button that triggers a background request to https://server/api/products/12345/\n        button_element.click()\n\n        # wait for the request/response to complete\n        request = driver.wait_for_request('/api/products/12345/')\n\n``driver.har``\n    a json formatted har archive of http transactions that have taken place. har capture is turned off by default and you must set the ``enable_har`` `option`_ to ``true`` before using ``driver.har``.\n\n``driver.iter_requests()``\n    returns an iterator over captured requests. useful when dealing with a large number of requests.\n\n``driver.request_interceptor``\n    used to set a request interceptor. see `intercepting requests and responses`_.\n\n``driver.response_interceptor``\n    used to set a response interceptor.\n\n**clearing requests**\n\nto clear previously captured requests and har entries, use ``del``:\n\n.. code:: python\n\n    del driver.requests\n\n.. [1] selenium wire ignores options requests by default, as these are typically uninteresting and just add overhead. if you want to capture options requests, you need to set the ``ignore_http_methods`` `option`_ to ``[]``.\n\n.. _`option`: #all-options\n\nrequest objects\n~~~~~~~~~~~~~~~\n\nrequest objects have the following attributes.\n\n``body``\n    the request body as ``bytes``. if the request has no body the value of ``body`` will be empty, i.e. ``b''``.\n\n``cert``\n    information about the server ssl certificate in dictionary format. empty for non-https requests.\n\n``date``\n    the datetime the request was made.\n\n``headers``\n    a dictionary-like object of request headers. headers are case-insensitive and duplicates are permitted. asking for ``request.headers['user-agent']`` will return the value of the ``user-agent`` header. if you wish to replace a header, make sure you delete the existing header first with ``del request.headers['header-name']``, otherwise you'll create a duplicate.\n\n``host``\n    the request host, e.g. ``www.example.com``\n\n``method``\n    the http method, e.g. ``get`` or ``post`` etc.\n\n``params``\n    a dictionary of request parameters. if a parameter with the same name appears more than once in the request, it's value in the dictionary will be a list.\n\n``path``\n    the request path, e.g. ``/some/path/index.html``\n\n``querystring``\n    the query string, e.g. ``foo=bar&spam=eggs``\n\n``response``\n   the `response object`_ associated with the request. this will be ``none`` if the request has no response.\n\n``url``\n    the request url, e.g. ``https://www.example.com/some/path/index.html?foo=bar&spam=eggs``\n\n``ws_messages``\n    where the request is a websocket handshake request (normally with a url starting ``wss://``) then ``ws_messages`` will contain a list of any websocket messages sent and received. see `websocketmessage objects`_.\n\nrequest objects have the following methods.\n\n``abort(error_code=403)``\n    trigger immediate termination of the request with the supplied error code. for use within request interceptors. see `example: block a request`_.\n\n``create_response(status_code, headers=(), body=b'')``\n    create a response and return it without sending any data to the remote server. for use within request interceptors. see `example: mock a response`_.\n\n.. _`response object`: #response-objects\n\nwebsocketmessage objects\n------------------------\n\nthese objects represent websocket messages sent between the browser and server and vice versa. they are held in a list by ``request.ws_messages`` on websocket handshake requests. they have the following attributes.\n\n``content``\n    the message content which may be either ``str`` or ``bytes``.\n\n``date``\n    the datetime of the message.\n\n``from_client``\n    ``true`` when the message was sent by the client and ``false`` when sent by the server.\n\nresponse objects\n~~~~~~~~~~~~~~~~\n\nresponse objects have the following attributes.\n\n``body``\n    the response body as ``bytes``. if the response has no body the value of ``body`` will be empty, i.e. ``b''``. sometimes the body may have been compressed by the server. you can prevent this with the ``disable_encoding`` `option`_. to manually decode an encoded response body you can do:\n\n.. code:: python\n\n    from seleniumwire.utils import decode\n\n    body = decode(response.body, response.headers.get('content-encoding', 'identity'))\n\n\n``date``\n    the datetime the response was received.\n\n``headers``\n     a dictionary-like object of response headers. headers are case-insensitive and duplicates are permitted. asking for ``response.headers['content-length']`` will return the value of the ``content-length`` header. if you wish to replace a header, make sure you delete the existing header first with ``del response.headers['header-name']``, otherwise you'll create a duplicate.\n\n``reason``\n    the reason phrase, e.g. ``ok`` or ``not found`` etc.\n\n``status_code``\n    the status code of the response, e.g. ``200`` or ``404`` etc.\n\n\nintercepting requests and responses\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nas well as capturing requests and responses, selenium wire allows you to modify them on the fly using interceptors. an interceptor is a function that gets invoked with requests and responses as they pass through selenium wire. within an interceptor you can modify the request and response as you see fit.\n\nyou set your interceptor functions using the ``driver.request_interceptor`` and ``driver.response_interceptor`` attributes before you start using the driver. a request interceptor should accept a single argument for the request. a response interceptor should accept two arguments, one for the originating request and one for the response.\n\nexample: add a request header\n-----------------------------\n\n.. code:: python\n\n    def interceptor(request):\n        request.headers['new-header'] = 'some value'\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # all requests will now contain new-header\n\nhow can i check that a header has been set correctly? you can print the headers from captured requests after the page has loaded using ``driver.requests``, or alternatively point the webdriver at https://httpbin.org/headers which will echo the request headers back to the browser so you can view them.\n\nexample: replace an existing request header\n-------------------------------------------\n\nduplicate header names are permitted in an http request, so before setting the replacement header you must first delete the existing header using ``del`` like in the following example, otherwise two headers with the same name will exist (``request.headers`` is a special dictionary-like object that allows duplicates).\n\n.. code:: python\n\n    def interceptor(request):\n        del request.headers['referer']  # remember to delete the header first\n        request.headers['referer'] = 'some_referer'  # spoof the referer\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # all requests will now use 'some_referer' for the referer\n\nexample: add a response header\n------------------------------\n\n.. code:: python\n\n    def interceptor(request, response):  # a response interceptor takes two args\n        if request.url == 'https://server.com/some/path':\n            response.headers['new-header'] = 'some value'\n\n    driver.response_interceptor = interceptor\n    driver.get(...)\n\n    # responses from https://server.com/some/path will now contain new-header\n\nexample: add a request parameter\n--------------------------------\n\nrequest parameters work differently to headers in that they are calculated when they are set on the request. that means that you first have to read them, then update them, and then write them back - like in the following example. parameters are held in a regular dictionary, so parameters with the same name will be overwritten.\n\n.. code:: python\n\n    def interceptor(request):\n        params = request.params\n        params['foo'] = 'bar'\n        request.params = params\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # foo=bar will be added to all requests\n\nexample: update json in a post request body\n-----------------------------------------------\n\n.. code:: python\n\n    import json\n\n    def interceptor(request):\n        if request.method == 'post' and request.headers['content-type'] == 'application/json':\n            # the body is in bytes so convert to a string\n            body = request.body.decode('utf-8')\n            # load the json\n            data = json.loads(body)\n            # add a new property\n            data['foo'] = 'bar'\n            # set the json back on the request\n            request.body = json.dumps(data).encode('utf-8')\n            # update the content length\n            del request.headers['content-length']\n            request.headers['content-length'] = str(len(request.body))\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\nexample: basic authentication\n-----------------------------\n\nif a site requires a username/password, you can use a request interceptor to add authentication credentials to each request. this will stop the browser from displaying a username/password pop-up.\n\n.. code:: python\n\n    import base64\n\n    auth = (\n        base64.encodebytes('my_username:my_password'.encode())\n        .decode()\n        .strip()\n    )\n\n    def interceptor(request):\n        if request.host == 'host_that_needs_auth':\n            request.headers['authorization'] = f'basic {auth}'\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # credentials will be transmitted with every request to \"host_that_needs_auth\"\n\nexample: block a request\n------------------------\n\nyou can use ``request.abort()`` to block a request and send an immediate response back to the browser. an optional error code can be supplied. the default is 403 (forbidden).\n\n.. code:: python\n\n    def interceptor(request):\n        # block png, jpeg and gif images\n        if request.path.endswith(('.png', '.jpg', '.gif')):\n            request.abort()\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # requests for png, jpeg and gif images will result in a 403 forbidden\n\nexample: mock a response\n------------------------\n\nyou can use ``request.create_response()`` to send a custom reply back to the browser. no data will be sent to the remote server.\n\n.. code:: python\n\n    def interceptor(request):\n        if request.url == 'https://server.com/some/path':\n            request.create_response(\n                status_code=200,\n                headers={'content-type': 'text/html'},  # optional headers dictionary\n                body='<html>hello world!</html>'  # optional body\n            )\n\n    driver.request_interceptor = interceptor\n    driver.get(...)\n\n    # requests to https://server.com/some/path will have their responses mocked\n\n*have any other examples you think could be useful? feel free to submit a pr.*\n\nunset an interceptor\n--------------------\n\nto unset an interceptor, use ``del``:\n\n.. code:: python\n\n    del driver.request_interceptor\n    del driver.response_interceptor\n\nlimiting request capture\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nselenium wire works by redirecting browser traffic through an internal proxy server it spins up in the background. as requests flow through the proxy they are intercepted and captured. capturing requests can slow things down a little but there are a few things you can do to restrict what gets captured.\n\n``driver.scopes``\n    this accepts a list of regular expressions that will match the urls to be captured. it should be set on the driver before making any requests. when empty (the default) all urls are captured.\n\n    .. code:: python\n\n        driver.scopes = [\n            '.*stackoverflow.*',\n            '.*github.*'\n        ]\n\n        driver.get(...)  # start making requests\n\n        # only request urls containing \"stackoverflow\" or \"github\" will now be captured\n\n    note that even if a request is out of scope and not captured, it will still travel through selenium wire.\n\n``seleniumwire_options.disable_capture``\n    use this option to switch off request capture. requests will still pass through selenium wire and through any upstream proxy you have configured but they won't be intercepted or stored. request interceptors will not execute.\n\n    .. code:: python\n\n        options = {\n            'disable_capture': true  # don't intercept/store any requests\n        }\n        driver = webdriver.chrome(seleniumwire_options=options)\n\n``seleniumwire_options.exclude_hosts``\n    use this option to bypass selenium wire entirely. any requests made to addresses listed here will go direct from the browser to the server without involving selenium wire. note that if you've configured an upstream proxy then these requests will also bypass that proxy.\n\n    .. code:: python\n\n        options = {\n            'exclude_hosts': ['host1.com', 'host2.com']  # bypass selenium wire for these hosts\n        }\n        driver = webdriver.chrome(seleniumwire_options=options)\n\n``request.abort()``\n    you can abort a request early by using ``request.abort()`` from within a `request interceptor`_. this will send an immediate response back to the client without the request travelling any further. you can use this mechanism to block certain types of requests (e.g. images) to improve page load performance.\n\n    .. code:: python\n\n        def interceptor(request):\n            # block png, jpeg and gif images\n            if request.path.endswith(('.png', '.jpg', '.gif')):\n                request.abort()\n\n        driver.request_interceptor = interceptor\n\n        driver.get(...)  # start making requests\n\n.. _`request interceptor`: #intercepting-requests-and-responses\n\nrequest storage\n~~~~~~~~~~~~~~~\n\ncaptured requests and responses are stored in the system temp folder by default (that's ``/tmp`` on linux and usually ``c:\\users\\<username>\\appdata\\local\\temp`` on windows) in a sub-folder called ``.seleniumwire``. to change where the ``.seleniumwire`` folder gets created you can use the ``request_storage_base_dir`` option:\n\n.. code:: python\n\n    options = {\n        'request_storage_base_dir': '/my/storage/folder'  # .seleniumwire will get created here\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nin-memory storage\n-----------------\n\nselenium wire also supports storing requests and responses in memory only, which may be useful in certain situations - e.g. if you're running short lived docker containers and don't want the overhead of disk persistence. you can enable in-memory storage by setting the ``request_storage`` option to ``memory``:\n\n.. code:: python\n\n    options = {\n        'request_storage': 'memory'  # store requests and responses in memory only\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nif you're concerned about the amount of memory that may be consumed, you can restrict the number of requests that are stored with the ``request_storage_max_size`` option:\n\n.. code:: python\n\n    options = {\n        'request_storage': 'memory',\n        'request_storage_max_size': 100  # store no more than 100 requests in memory\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nwhen the max size is reached, older requests are discarded as newer requests arrive. keep in mind that if you restrict the number of requests being stored, requests may have disappeared from storage by the time you come to retrieve them with ``driver.requests`` or ``driver.wait_for_request()`` etc.\n\nproxies\n~~~~~~~\n\nif the site you are accessing sits behind a proxy server you can tell selenium wire about that proxy server in the options you pass to the webdriver.\n\nthe configuration takes the following format:\n\n.. code:: python\n\n    options = {\n        'proxy': {\n            'http': 'http://192.168.10.100:8888',\n            'https': 'https://192.168.10.100:8888',\n            'no_proxy': 'localhost,127.0.0.1'\n        }\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nto use http basic auth with your proxy, specify the username and password in the url:\n\n.. code:: python\n\n    options = {\n        'proxy': {\n            'https': 'https://user:pass@192.168.10.100:8888',\n        }\n    }\n\nfor authentication other than basic, you can supply the full value for the ``proxy-authorization`` header using the ``custom_authorization`` option. for example, if your proxy used the bearer scheme:\n\n.. code:: python\n\n    options = {\n        'proxy': {\n            'https': 'https://192.168.10.100:8888',  # no username or password used\n            'custom_authorization': 'bearer mytoken123'  # custom proxy-authorization header value\n        }\n    }\n\nmore info on the ``proxy-authorization`` header can be found `here <https://developer.mozilla.org/en-us/docs/web/http/headers/proxy-authorization>`__.\n\nthe proxy configuration can also be loaded through environment variables called ``http_proxy``, ``https_proxy`` and ``no_proxy``:\n\n.. code:: bash\n\n    $ export http_proxy=\"http://192.168.10.100:8888\"\n    $ export https_proxy=\"https://192.168.10.100:8888\"\n    $ export no_proxy=\"localhost,127.0.0.1\"\n\nsocks\n-----\n\nusing a socks proxy is the same as using an http based one but you set the scheme to ``socks5``:\n\n.. code:: python\n\n    options = {\n        'proxy': {\n            'http': 'socks5://user:pass@192.168.10.100:8888',\n            'https': 'socks5://user:pass@192.168.10.100:8888',\n            'no_proxy': 'localhost,127.0.0.1'\n        }\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nyou can leave out the ``user`` and ``pass`` if your proxy doesn't require authentication.\n\nas well as ``socks5``, the schemes ``socks4`` and ``socks5h`` are supported. use ``socks5h`` when you want dns resolution to happen on the proxy server rather than on the client.\n\n**using selenium wire with tor**\n\nsee `this example <https://gist.github.com/woswos/38b921f0b82de009c12c6494db3f50c5>`_ if you want to run selenium wire with tor.\n\nswitching dynamically\n---------------------\n\nif you want to change the proxy settings for an existing driver instance, use the ``driver.proxy`` attribute:\n\n.. code:: python\n\n    driver.get(...)  # using some initial proxy\n\n    # change the proxy\n    driver.proxy = {\n        'https': 'https://user:pass@192.168.10.100:8888',\n    }\n\n    driver.get(...)  # these requests will use the new proxy\n\nto clear a proxy, set ``driver.proxy`` to an empty dict ``{}``.\n\nthis mechanism also supports the ``no_proxy`` and ``custom_authorization`` options.\n\nbot detection\n~~~~~~~~~~~~~\n\nselenium wire will integrate with `undetected-chromedriver`_ if it finds it in your environment. this library will transparently modify chromedriver to prevent it from triggering anti-bot measures on websites.\n\n.. _`undetected-chromedriver`: https://github.com/ultrafunkamsterdam/undetected-chromedriver\n\nif you wish to take advantage of this make sure you have undetected_chromedriver installed:\n\n.. code:: bash\n\n    pip install undetected-chromedriver\n\nthen in your code, import the ``seleniumwire.undetected_chromedriver`` package:\n\n.. code:: python\n\n    import seleniumwire.undetected_chromedriver as uc\n\n    chrome_options = uc.chromeoptions()\n\n    driver = uc.chrome(\n        options=chrome_options,\n        seleniumwire_options={}\n    )\n\n\ncertificates\n~~~~~~~~~~~~\n\nselenium wire uses it's own root certificate to decrypt https traffic. it is not normally necessary for the browser to trust this certificate because selenium wire tells the browser to add it as an exception. this will allow the browser to function normally, but it will display a \"not secure\" message (and/or unlocked padlock) in the address bar. if you wish to get rid of this message you can install the root certificate manually.\n\nyou can download the root certificate `here <https://github.com/wkeeling/selenium-wire/raw/master/seleniumwire/ca.crt>`__. once downloaded, navigate to \"certificates\" in your browser settings and import the certificate in the \"authorities\" section.\n\nusing your own certificate\n--------------------------\n\nif you would like to use your own root certificate you can supply the path to the certificate and the private key using the ``ca_cert`` and ``ca_key`` options.\n\nif you do specify your own certificate, be sure to manually delete selenium wire's `temporary storage folder <#request-storage>`_. this will clear out any existing certificates that may have been cached from previous runs.\n\nall options\n~~~~~~~~~~~\n\na summary of all options that can be passed to selenium wire via the ``seleniumwire_options`` webdriver attribute.\n\n``addr``\n    the ip address or hostname of the machine running selenium wire. this defaults to 127.0.0.1. you may want to change this to the public ip of the machine (or container) if you're using the `remote webdriver`_.\n\n.. code:: python\n\n    options = {\n        'addr': '192.168.0.10'  # use the public ip of the machine\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n.. _`remote webdriver`: #creating-the-webdriver\n\n``auto_config``\n    whether selenium wire should auto-configure the browser for request capture. ``true`` by default.\n\n``ca_cert``\n    the path to a root (ca) certificate if you prefer to use your own certificate rather than use the default.\n\n.. code:: python\n\n    options = {\n        'ca_cert': '/path/to/ca.crt'  # use own root certificate\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``ca_key``\n    the path to the private key if you're using your own root certificate. the key must always be supplied when using your own certificate.\n\n.. code:: python\n\n    options = {\n        'ca_key': '/path/to/ca.key'  # path to private key\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``disable_capture``\n    disable request capture. when ``true`` nothing gets intercepted or stored. ``false`` by default.\n\n.. code:: python\n\n    options = {\n        'disable_capture': true  # don't intercept/store any requests.\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``disable_encoding``\n    ask the server to send back uncompressed data. ``false`` by default. when ``true`` this sets the ``accept-encoding`` header to ``identity`` for all outbound requests. note that it won't always work - sometimes the server may ignore it.\n\n.. code:: python\n\n    options = {\n        'disable_encoding': true  # ask the server not to compress the response\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``enable_har``\n    when ``true`` a har archive of http transactions will be kept which can be retrieved with ``driver.har``. ``false`` by default.\n\n.. code:: python\n\n    options = {\n        'enable_har': true  # capture har data, retrieve with driver.har\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``exclude_hosts``\n    a list of addresses for which selenium wire should be bypassed entirely. note that if you have configured an upstream proxy then requests to excluded hosts will also bypass that proxy.\n\n.. code:: python\n\n    options = {\n        'exclude_hosts': ['google-analytics.com']  # bypass these hosts\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``ignore_http_methods``\n    a list of http methods (specified as uppercase strings) that should be ignored by selenium wire and not captured. the default is ``['options']`` which ignores all options requests. to capture all request methods, set ``ignore_http_methods`` to an empty list:\n\n.. code:: python\n\n    options = {\n        'ignore_http_methods': []  # capture all requests, including options requests\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``port``\n    the port number that selenium wire's backend listens on. you don't normally need to specify a port as a random port number is chosen automatically.\n\n.. code:: python\n\n    options = {\n        'port': 9999  # tell the backend to listen on port 9999 (not normally necessary to set this)\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``proxy``\n    the upstream `proxy server <https://github.com/wkeeling/selenium-wire#proxies>`__ configuration if you're using a proxy.\n\n.. code:: python\n\n    options = {\n        'proxy': {\n            'http': 'http://user:pass@192.168.10.100:8888',\n            'https': 'https://user:pass@192.168.10.100:8889',\n            'no_proxy': 'localhost,127.0.0.1'\n        }\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``request_storage``\n    the type of storage to use. selenium wire defaults to disk based storage, but you can switch to in-memory storage by setting this option to ``memory``:\n\n.. code:: python\n\n    options = {\n        'request_storage': 'memory'  # store requests and responses in memory only\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``request_storage_base_dir``\n    the base location where selenium wire stores captured requests and responses when using its default disk based storage. this defaults to the system temp folder (that's ``/tmp`` on linux and usually ``c:\\users\\<username>\\appdata\\local\\temp`` on windows). a sub-folder called ``.seleniumwire`` will get created here to store the captured data.\n\n.. code:: python\n\n    options = {\n        'request_storage_base_dir': '/my/storage/folder'  # .seleniumwire will get created here\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``request_storage_max_size``\n    the maximum number of requests to store when using in-memory storage. unlimited by default. this option currently has no effect when using the default disk based storage.\n\n.. code:: python\n\n    options = {\n        'request_storage': 'memory',\n        'request_storage_max_size': 100  # store no more than 100 requests in memory\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``suppress_connection_errors``\n    whether to suppress connection related tracebacks. ``true`` by default, meaning that harmless errors that sometimes occur at browser shutdown do not alarm users. when suppressed, the connection error message is logged at debug level without a traceback. set to ``false`` to allow exception propagation and see full tracebacks.\n\n.. code:: python\n\n    options = {\n        'suppress_connection_errors': false  # show full tracebacks for any connection errors\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\n``verify_ssl``\n    whether ssl certificates should be verified. ``false`` by default, which prevents errors with self-signed certificates.\n\n.. code:: python\n\n    options = {\n        'verify_ssl': true  # verify ssl certificates but beware of errors with self-signed certificates\n    }\n    driver = webdriver.chrome(seleniumwire_options=options)\n\nlicense\n~~~~~~~\n\nmit\n\n\nhistory\n~~~~~~~\n\n5.1.0 (2022-10-15)\n------------------\n\n* drop support for selenium<4.0.0.\n* drop support for sslv2 and sslv3.\n* fix bug where setting non-string header values would cause an interceptor to fail.\n\n5.0.0 (2022-09-26)\n------------------\n\n* add support for microsoft edge to webdriver\n* drop support for python 3.6\n* fix compatibility issue with pyopenssl\n\n4.6.5 (2022-07-09)\n------------------\n\n* fix compatibility issue with desiredcapabilities and older versions of the chrome webdriver api.\n* fix bug where verify_ssl would assume the inverse of the boolean passed (it was the wrong way round).\n* minor update to support python 3.10.\n* minor readme updates.\n\n4.6.4 (2022-05-11)\n------------------\n\n* fix bug where setting an interceptor would break websocket requests.\n\n4.6.3 (2022-03-13)\n------------------\n\n* fix bug with dynamic switching of upstream proxy.\n\n4.6.2 (2022-02-25)\n------------------\n\n* fix import error with missing touchactions in selenium>4.1.0\n\n4.6.1 (2022-02-21)\n------------------\n\n* fix compatibility issue with undetected_chromedriver.\n* handle occasional unpickle error when loading captured requests from disk.\n\n4.6.0 (2022-01-10)\n------------------\n\n* configurable root certificate and private key.\n* fix bug where it was not possible to clear a proxy once set.\n\n4.5.6 (2021-11-26)\n------------------\n\n* fix bug where using the chrome_options argument would prevent request capture.\n* fix issue where proxy-connection header was being propagated.\n\n4.5.5 (2021-11-13)\n------------------\n\n* fix issue where missing 'packaging' module prevents selenium wire from starting.\n* fix deprecation warnings with desired capabilities.\n\n4.5.4 (2021-10-23)\n------------------\n\n* fix bug preventing request capture when using firefox and selenium >= 4.0.0\n\n4.5.3 (2021-10-03)\n------------------\n\n* fix bug where setting a socket timeout would break the ssl handshake.\n* support for brotli and zstd content encoding.\n* suppress http protocol warning.\n\n4.5.2 (2021-08-23)\n------------------\n\n* fix bug where automatic decoding of response body would break page loading when using response interceptors.\n* fix bug where exclude_hosts had no effect when using undetected_chromedriver.v2.\n* fix occasional unpickle error when stored requests are asked for before they have been fully flushed to disk.\n\n4.5.1 (2021-08-20)\n------------------\n\n* fix attribute error preventing undetected chromedriver from starting.\n\n4.5.0 (2021-08-19)\n------------------\n\n* allow upstream proxy to be changed on the fly.\n\n4.4.1 (2021-08-10)\n------------------\n\n* fix async bug that breaks django orm.\n\n4.4.0 (2021-07-23)\n------------------\n\n* introduce in-memory request storage.\n* default request storage now uses system temp folder by default.\n* remove mitmproxy backend. selenium wire uses mitmproxy by default so a separate mitmproxy backend is redundant.\n\n4.3.3 (2021-07-19)\n------------------\n\n* fix proxy authorization failures when selenium wire is run in multiple threads.\n\n4.3.2 (2021-07-11)\n------------------\n\n* fix bug where the upstream no_proxy setting would be ignored for http hosts.\n* prevent firefox from bypassing selenium wire for localhost addresses.\n* fix bug where dns wasn't being resolved through the proxy for socks5h.\n\n4.3.1 (2021-06-13)\n------------------\n\n* don't fold separate set-cookie response headers into a single header.\n* add additional ssl certificate properties to request.cert\n\n4.3.0 (2021-05-06)\n------------------\n\n* allow selection of undetected_chromedriver version.\n* add new attribute request.host\n\n4.2.5 (2021-05-03)\n------------------\n\n* switch to upstream_cert=true by default, enabling http/2.\n\n4.2.4 (2021-04-13)\n------------------\n\n* fix bug where disable_capture would break upstream proxy authentication.\n\n4.2.3 (2021-04-03)\n------------------\n\n* fix bug where it was not possible to specify socks4 in proxy configuration.\n\n4.2.2 (2021-03-19)\n------------------\n\n* fix concurrency issue in requeststorage that allowed partially stored requests to be retrieved.\n\n4.2.1 (2021-03-09)\n------------------\n\n* make ssl certificate metadata available via request.cert\n* suppress connection aborted error by default.\n* log error on proxy authentication failure.\n\n4.2.0 (2021-03-03)\n------------------\n\n* add support for har format.\n* add disable_capture option.\n* add driver.iter_requests().\n* fix bug where no_proxy was being ignored in proxy configuration.\n\n4.1.1 (2021-02-26)\n------------------\n\n* integration with undetected-chromedriver.\n\n4.1.0 (2021-02-24)\n------------------\n\n* implement websocket message capture.\n* fix bug where closure of event loop externally would trigger exception on shutdown.\n* fix bug preventing use of an empty password for an upstream proxy.\n\n4.0.5 (2021-02-15)\n------------------\n\n* downgrade \"the client may not trust selenium wire's certificate\" to debug.\n* introduce auto_config option.\n\n4.0.4 (2021-02-05)\n------------------\n\n* fix bug where selenium wire would attempt to close running event loop.\n\n4.0.3 (2021-02-04)\n------------------\n\n* fix bug where ipv6 addresses were not being enclosed in square brackets, breaking the local proxy url.\n\n4.0.2 (2021-02-01)\n------------------\n\n* fix additional problems caused by ipv6 socket binding.\n\n4.0.1 (2021-02-01)\n------------------\n\n* fix bug where binding to ipv6 socket would prevent selenium wire from starting.\n\n\n4.0.0 (2021-01-31)\n------------------\n\n* rework the default backend to:\n    * improve performance when connecting to upstream proxies\n    * remove the need for starting an openssl subprocess for certificate generation\n    * fix issue where duplicate headers could not be proxied to the upstream server\n    * fix issue where the response status code was being overridden by the connect status\n    * lay the groundwork for supporting websocket message capture\n    * lay the groundwork for supporting ssl pass-through\n\n3.0.6 (2021-01-30)\n------------------\n\n* fix bug preventing mitmproxy backend from using custom confdir.\n\n3.0.5 (2021-01-18)\n------------------\n\n* suppress upstream connection errors based on configuration.\n\n3.0.4 (2021-01-07)\n------------------\n\n* revert change to capture options requests by default.\n\n\n3.0.3 (2021-01-07)\n------------------\n\n* decode response body on load.\n\n3.0.2 (2021-01-05)\n------------------\n\n* fix issue where remote web driver client was being imported from incorrect package.\n\n3.0.1 (2021-01-03)\n------------------\n\n* create a new event loop if current event loop is closed.\n\n3.0.0 (2021-01-02)\n------------------\n\n* inroduce request and response interceptors.\n* run mitmproxy backend in a thread rather than subprocess.\n* drop internal http admin api.\n* drop support for python 3.4 and 3.5.\n* add support for remote webdriver client.\n* add support for duplicate request and response headers.\n* fixed issue where proxy-connection header was being propagated.\n* fixed issue where desired capabilities could not be reused outside of selenium wire due to addition of proxy config.\n* deprecation of header_overrides, param_overrides, querystring_overrides, rewrite_urls, custom_response_handler\n\n2.1.2 (2020-11-14)\n------------------\n\n* prevent chrome from bypassing selenium wire for localhost addresses.\n\n2.1.1 (2020-08-10)\n------------------\n\n* automatic port number selection for mitmproxy backend.\n\n2.1.0 (2020-07-21)\n------------------\n\n* support regular expressions in driver.wait_for_request().\n\n2.0.0 (2020-07-14)\n------------------\n\n* introduce the mitmproxy backend\n* support for modifying response headers\n* support for modifying request parameters and the query string\n* breaking api changes:\n    * the request.path attribute now returns the path rather than the full url. to retrieve the url, use request.url.\n    * empty request and response bodies are now returned as empty bytes `b''` rather than `none`.\n\n1.2.3 (2020-06-19)\n------------------\n\n* disable connection persistence by default due to side effects in certain cases.\n\n1.2.2 (2020-06-12)\n------------------\n\n* close connection on error rather than send 502 response to permit browser retry.\n\n1.2.1 (2020-06-09)\n------------------\n\n* use sha256 digest when creating site certificates to fix chrome hsts security errors.\n\n1.2.0 (2020-06-07)\n------------------\n\n* add properties to allow easy retrieval of the query string and request parameters.\n* don't verify ssl by default.\n* allow configurable number of request threads.\n* use connection persistance (keep-alive) by default. make configurable.\n\n1.1.2 (2020-05-27)\n------------------\n\n* fix bug where request thread would spin after websocket closure.\n\n\n1.1.1 (2020-05-25)\n------------------\n\n* handle errors occuring on websocket connections.\n\n1.1.0 (2020-05-23)\n------------------\n\n* allow the request storage base directory to be configurable.\n* support proxying websocket connections.\n* fix bug where attempting to filter out non-existent headers would raise an error.\n* handle possibility of zero byte captured request/response files.\n\n1.0.12 (2020-05-16)\n-------------------\n\n* support for socks proxies.\n\n1.0.11 (2019-12-31)\n-------------------\n\n* fix duplication of content-length header when altering body content.\n\n1.0.10 (2019-09-22)\n-------------------\n\n* scope request capture.\n* apply header filtering on a per-url basis.\n\n1.0.9 (2019-08-25)\n------------------\n\n* add ability to provide a custom response handler method.\n\n1.0.8 (2019-08-01)\n------------------\n\n* remove signal handler from adminclient to allow running in multi-threaded environment.\n* make connection timeout configurable.\n\n1.0.7 (2019-07-30)\n------------------\n\n* fix bug where temporary storage cleanup would sometimes fail when running in a multi-threaded environment.\n* don't rely on signal handlers for temporary storage cleanup. signal handlers are not compatible with multiple threads. use driver.quit() for explicit cleanup.\n\n1.0.6 (2019-07-14)\n------------------\n\n* support for disabling ssl verification when using self-signed certificates.\n\n1.0.5 (2019-06-15)\n------------------\n\n* improve performance on windows by explicitly closing the response output stream.\n* capture stderr leaking from openssl to the console.\n* ensure subjectaltname is added to self signed certificates.\n* refactor certificate generation code.\n* more robust handling of socket errors.\n* decode response bodies at the point a client asks for them, not at the point a response is captured.\n\n1.0.4 (2019-04-04)\n------------------\n\n* clean up cached request directory tree on driver.quit().\n* suppress connection related errors by default.\n\n1.0.3 (2019-04-01)\n------------------\n\n* responses are no longer sent chunk by chunk where they are missing a content-type header.\n* ensure delayed responses don't cause errors when server is not explicitly shutdown.\n\n1.0.2 (2019-03-10)\n------------------\n\n* support for authentication when using http based proxies.\n* fix bug where json response bodies were being decoded rather than being sent through as bytes.\n\n1.0.1 (2019-02-07)\n------------------\n\n* support patch requests\n\n1.0.0 (2018-12-31)\n------------------\n\n* ensure stored response body is always retrieved as bytes when asked for by the test.\n* updates to readme.\n* use reverse chronological ordering of history.\n\n0.10.0 (2018-10-30)\n-------------------\n\n* fix issue where ignoring options requests would trigger attributeerror.\n* allow proxy settings to be explicitly set to none.\n\n0.9.0 (2018-10-28)\n------------------\n\n* ignore options requests by default, and allow list of methods to be configurable via the ignore_http_methods option.\n* move default selenium wire request storage from system temp to user home to prevent permission collisions.\n\n0.8.0 (2018-09-20)\n------------------\n\n* fix issue where new headers were not being added to the request when using driver.header_overrides.\n\n0.7.0 (2018-08-29)\n------------------\n\n* readme and doc updates.\n\n0.6.0 (2018-08-21)\n------------------\n\n* bundle openssl.cnf for windows.\n\n0.5.0 (2018-08-19)\n------------------\n\n* clearer readme instructions.\n\n0.4.0 (2018-08-19)\n------------------\n\n* openssl for windows now bundled.\n* setup instructions for edge.\n\n0.3.0 (2018-08-07)\n------------------\n\n* fix remote proxy basic authentication.\n* updates to readme.\n\n0.2.0 (2018-08-04)\n------------------\n\n* load proxy settings from env variables.\n* support disabling of content encoding.\n* updates to readme.\n\n0.1.0 (2018-06-19)\n------------------\n\n* first release on pypi.\n\n\n",
  "docs_url": null,
  "keywords": "selenium-wire",
  "license": "mit",
  "name": "selenium-wire",
  "package_url": "https://pypi.org/project/selenium-wire/",
  "project_url": "https://pypi.org/project/selenium-wire/",
  "project_urls": {
    "Homepage": "https://github.com/wkeeling/selenium-wire"
  },
  "release_url": "https://pypi.org/project/selenium-wire/5.1.0/",
  "requires_dist": [
    "blinker (>=1.4)",
    "brotli (>=1.0.9)",
    "certifi (>=2019.9.11)",
    "kaitaistruct (>=0.7)",
    "pyasn1 (>=0.3.1)",
    "pyOpenSSL (>=22.0.0)",
    "pyparsing (>=2.4.2)",
    "pysocks (>=1.7.1)",
    "selenium (>=4.0.0)",
    "wsproto (>=0.14)",
    "zstandard (>=0.14.1)",
    "dataclasses (>=0.7) ; python_version == \"3.6\"",
    "h2 (>=4.0) ; python_version >= \"3.6.0\"",
    "hyperframe (>=6.0) ; python_version >= \"3.6.0\"",
    "pydivert (>=2.0.3) ; sys_platform == \"win32\"",
    "black ; extra == 'dev'",
    "bumpversion ; extra == 'dev'",
    "coverage ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "gunicorn ; extra == 'dev'",
    "httpbin ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "mypy ; extra == 'dev'",
    "pre-commit ; extra == 'dev'",
    "pytest ; extra == 'dev'",
    "pytest-cov ; extra == 'dev'",
    "tox ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "werkzeug (==2.0.3) ; extra == 'dev'",
    "wheel ; extra == 'dev'",
    "mitmproxy (>5.3.0) ; (python_version >= \"3.8.0\") and extra == 'dev'"
  ],
  "requires_python": ">=3.6",
  "summary": "extends selenium to give you the ability to inspect requests made by the browser.",
  "version": "5.1.0",
  "releases": [],
  "developers": [
    "will@zifferent.com",
    "will_keeling"
  ],
  "kwds": "selenium seleniumwire seleniumwire_options webdriverwait webdriver",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_selenium_wire",
  "homepage": "https://github.com/wkeeling/selenium-wire",
  "release_count": 76,
  "dependency_ids": [
    "pypi_black",
    "pypi_blinker",
    "pypi_brotli",
    "pypi_bumpversion",
    "pypi_certifi",
    "pypi_coverage",
    "pypi_dataclasses",
    "pypi_flake8",
    "pypi_gunicorn",
    "pypi_h2",
    "pypi_httpbin",
    "pypi_hyperframe",
    "pypi_isort",
    "pypi_kaitaistruct",
    "pypi_mitmproxy",
    "pypi_mypy",
    "pypi_pre_commit",
    "pypi_pyasn1",
    "pypi_pydivert",
    "pypi_pyopenssl",
    "pypi_pyparsing",
    "pypi_pysocks",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_selenium",
    "pypi_tox",
    "pypi_twine",
    "pypi_werkzeug",
    "pypi_wheel",
    "pypi_wsproto",
    "pypi_zstandard"
  ]
}