{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet"
  ],
  "description": "spur.py: run commands and manipulate files locally or over ssh using the same interface\n=======================================================================================\n\nto run echo locally:\n\n.. code-block:: python\n\n    import spur\n\n    shell = spur.localshell()\n    result = shell.run([\"echo\", \"-n\", \"hello\"])\n    print(result.output) # prints hello\n\nexecuting the same command over ssh uses the same interface -- the only\ndifference is how the shell is created:\n\n.. code-block:: python\n\n    import spur\n\n    shell = spur.sshshell(hostname=\"localhost\", username=\"bob\", password=\"password1\")\n    with shell:\n        result = shell.run([\"echo\", \"-n\", \"hello\"])\n    print(result.output) # prints hello\n\ninstallation\n------------\n\n``$ pip install spur``\n\nshell constructors\n------------------\n\nlocalshell\n~~~~~~~~~~\n\ntakes no arguments:\n\n.. code-block:: python\n\n    spur.localshell()\n\nsshshell\n~~~~~~~~\n\nrequires a hostname. also requires some combination of a username,\npassword and private key, as necessary to authenticate:\n\n.. code-block:: python\n\n    # use a password\n    spur.sshshell(\n        hostname=\"localhost\",\n        username=\"bob\",\n        password=\"password1\"\n    )\n    # use a private key\n    spur.sshshell(\n        hostname=\"localhost\",\n        username=\"bob\",\n        private_key_file=\"path/to/private.key\"\n    )\n    # use a port other than 22\n    spur.sshshell(\n        hostname=\"localhost\",\n        port=50022,\n        username=\"bob\",\n        password=\"password1\"\n    )\n\noptional arguments:\n\n* ``connect_timeout`` -- a timeout in seconds for establishing an ssh\n  connection. defaults to 60 (one minute).\n\n* ``missing_host_key`` -- by default, an error is raised when a host\n  key is missing. one of the following values can be used to change the\n  behaviour when a host key is missing:\n\n  - ``spur.ssh.missinghostkey.raise_error`` -- raise an error\n  - ``spur.ssh.missinghostkey.warn`` -- accept the host key and log a\n    warning\n  - ``spur.ssh.missinghostkey.accept`` -- accept the host key\n\n* ``shell_type`` -- the type of shell used by the host. defaults to\n  ``spur.ssh.shelltypes.sh``, which should be appropriate for most linux\n  distributions. if the host uses a different shell, such as simpler shells\n  often found on embedded systems, try changing ``shell_type`` to a more\n  appropriate value, such as ``spur.ssh.shelltypes.minimal``. the following\n  shell types are currently supported:\n\n  - ``spur.ssh.shelltypes.sh`` -- the bourne shell. supports all features.\n\n  - ``spur.ssh.shelltypes.minimal`` -- a minimal shell. several features\n    are unsupported:\n\n    - non-existent commands will not raise ``spur.nosuchcommanderror``.\n\n    - the following arguments to ``spawn`` and ``run`` are unsupported unless\n      set to their default values:\n      ``cwd``, ``update_env``, and ``store_pid``.\n\n* ``look_for_private_keys`` -- by default, spur will search for discoverable\n  private key files in ``~/.ssh/``.\n  set to ``false`` to disable this behaviour.\n\n* ``load_system_host_keys`` -- by default, spur will attempt to read host keys\n  from the user's known hosts file, as used by openssh, and no exception will\n  be raised if the file can't be read.\n  set to ``false`` to disable this behaviour.\n\n* ``sock`` -- an open socket or socket-like object to use for communication to\n  the target host. for instance:\n\n  .. code-block:: python\n\n      sock=paramiko.proxy.proxycommand(\n          \"ssh -q -o stricthostkeychecking=no -o userknownhostsfile=/dev/null\"\n          \"bob@proxy.example.com nc -q0 target.example.com 22\"\n      )\n\n  examples of socket-like objects include:\n\n  * |paramiko.channel|_\n  * |paramiko.proxy.proxycommand|_\n    (`unsupported in python 3 <https://github.com/paramiko/paramiko/issues/673>`_ as of writing)\n\n.. |paramiko.channel| replace:: ``paramiko.channel``\n.. _paramiko.channel: http://docs.paramiko.org/en/latest/api/channel.html\n\n.. |paramiko.proxy.proxycommand| replace:: ``paramiko.proxy.proxycommand``\n.. _paramiko.proxy.proxycommand: http://docs.paramiko.org/en/latest/api/proxy.html\n\nshell interface\n---------------\n\nrun(command, cwd, update\\_env, store\\_pid, allow\\_error, stdout, stderr, encoding)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nrun a command and wait for it to complete. the command is expected to be\na list of strings. returns an instance of ``executionresult``.\n\n.. code-block:: python\n\n    result = shell.run([\"echo\", \"-n\", \"hello\"])\n    print(result.output) # prints hello\n\nnote that arguments are passed without any shell expansion. for\ninstance, ``shell.run([\"echo\", \"$path\"])`` will print the literal string\n``$path`` rather than the value of the environment variable ``$path``.\n\nraises ``spur.nosuchcommanderror`` if trying to execute a non-existent\ncommand.\n\nraises ``spur.couldnotchangedirectoryerror`` if changing the current directory\nto ``cwd`` failed.\n\noptional arguments:\n\n* ``cwd`` -- change the current directory to this value before\n  executing the command.\n* ``update_env`` -- a ``dict`` containing environment variables to be\n  set before running the command. if there's an existing environment\n  variable with the same name, it will be overwritten. otherwise, it is\n  unchanged.\n* ``store_pid`` -- if set to ``true`` when calling ``spawn``, store the\n  process id of the spawned process as the attribute ``pid`` on the\n  returned process object. has no effect when calling ``run``.\n* ``allow_error`` -- ``false`` by default. if ``false``, an exception\n  is raised if the return code of the command is anything but 0. if\n  ``true``, a result is returned irrespective of return code.\n* ``stdout`` -- if not ``none``, anything the command prints to\n  standard output during its execution will also be written to\n  ``stdout`` using ``stdout.write``.\n* ``stderr`` -- if not ``none``, anything the command prints to\n  standard error during its execution will also be written to\n  ``stderr`` using ``stderr.write``.\n* ``encoding`` -- if set, this is used to decode any output.\n  by default, any output is treated as raw bytes.\n  if set, the raw bytes are decoded before writing to\n  the passed ``stdout`` and ``stderr`` arguments (if set)\n  and before setting the output attributes on the result.\n\n``shell.run(*args, **kwargs)`` should behave similarly to\n``shell.spawn(*args, **kwargs).wait_for_result()``\n\nspawn(command, cwd, update\\_env, store\\_pid, allow\\_error, stdout, stderr, encoding)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nbehaves the same as ``run`` except that ``spawn`` immediately returns an\nobject representing the running process.\n\nraises ``spur.nosuchcommanderror`` if trying to execute a non-existent\ncommand.\n\nraises ``spur.couldnotchangedirectoryerror`` if changing the current directory\nto ``cwd`` failed.\n\nopen(path, mode=\"r\")\n~~~~~~~~~~~~~~~~~~~~\n\nopen the file at ``path``. returns a file-like object.\n\nby default, files are opened in text mode.\nappending `\"b\"` to the mode will open the file in binary mode.\n\nfor instance, to copy a binary file over ssh,\nassuming you already have an instance of ``sshshell``:\n\n.. code-block:: python\n\n    with ssh_shell.open(\"/path/to/remote\", \"rb\") as remote_file:\n        with open(\"/path/to/local\", \"wb\") as local_file:\n            shutil.copyfileobj(remote_file, local_file)\n\nclose()\n~~~~~~~\n\ncloses and the shell and releases any associated resources.\n``close()`` is called automatically when the shell is used as a context manager.\n\nprocess interface\n-----------------\n\nreturned by calls to ``shell.spawn``. has the following attributes:\n\n* ``pid`` -- the process id of the process. only available if\n  ``store_pid`` was set to ``true`` when calling ``spawn``.\n\nhas the following methods:\n\n* ``is_running()`` -- return ``true`` if the process is still running,\n  ``false`` otherwise.\n* ``stdin_write(value)`` -- write ``value`` to the standard input of\n  the process.\n* ``wait_for_result()`` -- wait for the process to exit, and then\n  return an instance of ``executionresult``. will raise\n  ``runprocesserror`` if the return code is not zero and\n  ``shell.spawn`` was not called with ``allow_error=true``.\n* ``send_signal(signal)`` -- sends the process the signal ``signal``.\n  only available if ``store_pid`` was set to ``true`` when calling\n  ``spawn``.\n\nclasses\n-------\n\nexecutionresult\n~~~~~~~~~~~~~~~\n\n``executionresult`` has the following properties:\n\n* ``return_code`` -- the return code of the command\n* ``output`` -- a string containing the result of capturing stdout\n* ``stderr_output`` -- a string containing the result of capturing\n  stdout\n\nit also has the following methods:\n\n* ``to_error()`` -- return the corresponding runprocesserror. this is\n  useful if you want to conditionally raise runprocesserror, for\n  instance:\n\n.. code-block:: python\n\n    result = shell.run([\"some-command\"], allow_error=true)\n    if result.return_code > 4:\n        raise result.to_error()\n\nrunprocesserror\n~~~~~~~~~~~~~~~\n\na subclass of ``runtimeerror`` with the same properties as\n``executionresult``:\n\n* ``return_code`` -- the return code of the command\n* ``output`` -- a string containing the result of capturing stdout\n* ``stderr_output`` -- a string containing the result of capturing\n  stdout\n\nnosuchcommanderror\n~~~~~~~~~~~~~~~~~~\n\n``nosuchcommanderror`` has the following properties:\n\n* ``command`` -- the command that could not be found\n\ncouldnotchangedirectoryerror\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``couldnotchangedirectoryerror`` has the following properties:\n\n* ``directory`` -- the directory that could not be changed to\n\napi stability\n-------------\n\nusing the the terminology from `semantic\nversioning <http://semver.org/spec/v1.0.0.html>`_, if the version of\nspur is x.y.z, then x is the major version, y is the minor version, and\nz is the patch version.\n\nwhile the major version is 0, incrementing the patch version indicates a\nbackwards compatible change. for instance, if you're using 0.3.1, then\nit should be safe to upgrade to 0.3.2.\n\nincrementing the minor version indicates a change in the api. this means\nthat any code using previous minor versions of spur may need updating\nbefore it can use the current minor version.\n\nundocumented features\n~~~~~~~~~~~~~~~~~~~~~\n\nsome features are undocumented, and should be considered experimental.\nuse them at your own risk. they may not behave correctly, and their\nbehaviour and interface may change at any time.\n\ntroubleshooting\n---------------\n\ni get the error \"connection refused\" when trying to connect to a virtual machine using a forwarded port on ``localhost``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ntry using ``\"127.0.0.1\"`` instead of ``\"localhost\"`` as the hostname.\n\ni get the error \"connection refused\" when trying to execute commands over ssh\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ntry connecting to the machine using ssh on the command line with the\nsame settings. for instance, if you're using the code:\n\n.. code-block:: python\n\n    shell = spur.sshshell(\n            hostname=\"remote\",\n            port=2222,\n            username=\"bob\",\n            private_key_file=\"/home/bob/.ssh/id_rsa\"\n        )\n    with shell:\n        result = shell.run([\"echo\", \"hello\"])\n\ntry running:\n\n.. code-block:: sh\n\n    ssh bob@remote -p 2222 -i /home/bob/.ssh/id_rsa\n\nif the ``ssh`` command succeeds, make sure that the arguments to\n``ssh.sshshell`` and the ``ssh`` command are the same. if any of the\narguments to ``ssh.sshshell`` are dynamically generated, try hard-coding\nthem to make sure they're set to the values you expect.\n\ni can't spawn or run commands over ssh\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif you're having trouble spawning or running commands over ssh, try passing\n``shell_type=spur.ssh.shelltypes.minimal`` as an argument to ``spur.sshshell``.\nfor instance:\n\n.. code-block:: python\n\n    import spur\n    import spur.ssh\n\n    spur.sshshell(\n        hostname=\"localhost\",\n        username=\"bob\",\n        password=\"password1\",\n        shell_type=spur.ssh.shelltypes.minimal,\n    )\n\nthis makes minimal assumptions about the features that the host shell supports,\nand is especially well-suited to minimal shells found on embedded systems. if\nthe host shell is more fully-featured but only works with\n``spur.ssh.shelltypes.minimal``, feel free to submit an issue.\n\nwhy don't shell features such as variables and redirection work?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ncommands are run directly rather than through a shell.\nif you want to use any shell features such as variables and redirection,\nthen you'll need to run those commands within an appropriate shell.\nfor instance:\n\n.. code-block:: python\n\n    shell.run([\"sh\", \"-c\", \"echo $path\"])\n    shell.run([\"sh\", \"-c\", \"ls | grep bananas\"])\n",
  "docs_url": null,
  "keywords": "ssh shell subprocess process",
  "license": "bsd-2-clause",
  "name": "spur",
  "package_url": "https://pypi.org/project/spur/",
  "project_url": "https://pypi.org/project/spur/",
  "project_urls": {
    "Homepage": "https://github.com/mwilliamson/spur.py"
  },
  "release_url": "https://pypi.org/project/spur/0.3.23/",
  "requires_dist": [
    "paramiko (<4,>=1.13.1)"
  ],
  "requires_python": ">=3.6",
  "summary": "run commands and manipulate files locally or over ssh using the same interface",
  "version": "0.3.23",
  "releases": [],
  "developers": [
    "michael_williamson",
    "mike@zwobble.org"
  ],
  "kwds": "ssh_shell subprocess sshshell remote_file openssh",
  "license_kwds": "bsd-2-clause",
  "libtype": "pypi",
  "id": "pypi_spur",
  "homepage": "https://github.com/mwilliamson/spur.py",
  "release_count": 35,
  "dependency_ids": [
    "pypi_paramiko"
  ]
}