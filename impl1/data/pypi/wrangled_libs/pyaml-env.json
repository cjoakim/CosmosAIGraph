{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "[![downloads](https://static.pepy.tech/personalized-badge/pyaml-env?period=total&units=none&left_color=black&right_color=green&left_text=downloads)](https://pepy.tech/project/pyaml-env)\n[![tests and linting](https://github.com/mkaranasou/pyaml_env/actions/workflows/python-app.yml/badge.svg)](https://github.com/mkaranasou/pyaml_env/actions/workflows/python-app.yml)\n[![codeql](https://github.com/mkaranasou/pyaml_env/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/mkaranasou/pyaml_env/actions/workflows/codeql-analysis.yml)\n[![license: mit](https://img.shields.io/badge/license-mit-yellow.svg)](https://opensource.org/licenses/mit)\n[![upload python package](https://github.com/mkaranasou/pyaml_env/actions/workflows/python-publish.yml/badge.svg)](https://github.com/mkaranasou/pyaml_env/actions/workflows/python-publish.yml)\n\n# python yaml configuration with environment variables parsing\n\n## tl;dr\na very small library that parses a yaml configuration file and it resolves the environment variables, \nso that no secrets are kept in text.\n\n### install\n```bash\npip install pyaml-env\n```\n### how to use:\n\n--- \n\n#### basic usage: environment variable parsing\nthis yaml file:\n```yaml\ndatabase:\n  name: test_db\n  username: !env ${db_user}\n  password: !env ${db_pass}\n  url: !env 'http://${db_base_url}:${db_port}'\n```\ngiven that we've set these:\n```bash\nexport $db_user=super_secret_user\nexport $db_pass=extra_super_secret_password\nexport $db_base_url=localhost\nexport $db_port=5432\n```\n\nbecomes this:\n```python\nfrom pyaml_env import parse_config\nconfig = parse_config('path/to/config.yaml')\n\nprint(config)\n# outputs the following, with the environment variables resolved\n{\n    'database': {\n        'name': 'test_db',\n        'username': 'super_secret_user',\n        'password': 'extra_super_secret_password',\n        'url': 'http://localhost:5432',\n    }\n}\n\n```\n\n\n---\n\n#### attribute access using `baseconfig`\nwhich can also become this:\n```python\nfrom pyaml_env import parse_config, baseconfig\nconfig = baseconfig(parse_config('path/to/config.yaml'))\n# you can then access the config properties as atrributes\n# i'll explain why this might be useful in a bit.\nprint(config.database.url)\n```\n---\n\n\n#### default values with `:`\nyou can also set default values for when the environment variables are not set for some reason,\nusing the `default_sep` kwarg (**which is `:` by default**) like this:\n```yaml\ndatabse:\n  name: test_db\n  username: !env ${db_user:paws}\n  password: !env ${db_pass:meaw2}\n  url: !env 'http://${db_base_url:straight_to_production}:${db_port}'\n```\n\nand if no environment variables are found then we get:\n```python\nfrom pyaml_env import parse_config\nconfig = parse_config('path/to/config.yaml')\n\nprint(config)\n{\n    'database': {\n        'name': 'test_db',\n        'username': 'paws',\n        'password': 'meaw2',\n        'url': 'http://straight_to_production:n/a',\n    }\n}\n```\n**note 0**: special characters like `*`, `{` etc. are not currently supported as separators. let me know if you'd like them handled also.\n\n**note 1**: if you set `tag` to `none`, then, the current behavior is that environment variables in all places in the yaml will be resolved (if set).\n\n---\n#### datatype parsing with yaml's tag:yaml.org,2002:<datatype>\n\n```python\n# because this is not allowed:\n# data1: !tag !!float ${env_tag2:27017}\n# use tag:yaml.org,2002:datatype to convert value:\ntest_data = '''\n        data0: !tag ${env_tag1}\n        data1: !tag tag:yaml.org,2002:float ${env_tag2:27017}\n        data2: !!float 1024\n        data3: !tag ${env_tag2:some_value}\n        data4: !tag tag:yaml.org,2002:bool ${env_tag2:false}\n        '''\n```\nwill become:\n```python\nos.environ['env_tag1'] = \"1024\"\nconfig = parse_config(data=test_data, tag='!tag')\nprint(config)\n{\n    'data0': '1024', \n    'data1': 27017.0, \n    'data2': 1024.0, \n    'data3': 'some_value', \n    'data4': false\n}\n```\n\n[reference in yaml code](https://github.com/yaml/pyyaml/blob/master/lib/yaml/parser.py#l78)\n\n---\n#### if nothing matches: `n/a` as `default_value`:\n\nif no defaults are found and no environment variables, the `default_value` (**which is `n/a` by default**)  is used:\n```python\n{\n    'database': {\n        'name': 'test_db',\n        'username': 'n/a',\n        'password': 'n/a',\n        'url': 'http://n/a:n/a',\n    }\n}\n```\nwhich, of course, means something went wrong and we need to set the correct environment variables.\nif you want this process to fail if a *default value* is not found, you can set the `raise_if_na` flag to `true`.\nfor example:\n\n```yaml\ntest1:\n    data0: !test ${env_tag1:has_default}/somethingelse/${env_tag2:also_has_default}\n    data1:  !test ${env_tag2}\n```\nwill raise a `valueerror` because `data1:  !test ${env_tag2}` there is no default value for `env_tag2` in this line.\n\n--- \n\n\n#### using a different loader:\n\nthe default yaml loader is `yaml.safeloader`. if you need to work with serialized python objects, \nyou can specify a different loader.\n\nso given a class:\n```python\nclass otherloadtest:\n    def __init__(self):\n        self.data0 = 'it works!'\n        self.data1 = 'this works too!'\n\n```\n\nwhich has become a yaml output like the following using `yaml.dump(otherloadtest())`:\n```yaml\n!!python/object:__main__.otherloadtest\ndata0: it works!\ndata1: this works too!\n```\n\nyou can use `parse_config` to load the object like this:\n```python\nimport yaml\nfrom pyaml_env import parse_config\n\nother_load_test = parse_config(path='path/to/config.yaml', loader=yaml.unsafeloader)\nprint(other_load_test)\n<__main__.otherloadtest object at 0x7fc38ccd5470>\n```\n---\n\n## long story: load a yaml configuration file and resolve any environment variables\n\n![](https://cdn-images-1.medium.com/max/11700/1*4s_grxe5sn2p2pnd8fs-6a.jpeg)\n\nif you\u2019ve worked with python projects, you\u2019ve probably have stumbled across the many ways to provide configuration. i am not going to go through all the ways here, but a few of them are:\n\n* using .ini files\n\n* using a python class\n\n* using .env files\n\n* using json or xml files\n\n* using a yaml file\n\nand so on. i\u2019ve put some useful links about the different ways below, in case you are interested in digging deeper.\n\nmy preference is working with yaml configuration because i usually find very handy and easy to use and i really like that yaml files are also used in e.g. docker-compose configuration so it is something most are familiar with.\n\nfor yaml parsing i use the [pyyaml](https://pyyaml.org/wiki/pyyamldocumentation) python library.\n\nin this article we\u2019ll talk about the yaml file case and more specifically what you can do to **avoid keeping your secrets, e.g. passwords, hosts, usernames etc, directly on it**.\n\nlet\u2019s say we have a very simple example of a yaml file configuration:\n\n    database:\n     name: database_name\n     user: me\n     password: very_secret_and_complex\n     host: localhost\n     port: 5432\n\n    ws:\n     user: username\n     password: very_secret_and_complex_too\n     host: localhost\n\nwhen you come to a point where you need to deploy your project, it is not really safe to have passwords and sensitive data in a plain text configuration file lying around on your production server. that\u2019s where [**environment variables](https://medium.com/dataseries/hiding-secret-info-in-python-using-environment-variables-a2bab182eea) **come in handy. so the goal here is to be able to easily replace the very_secret_and_complex password with input from an environment variable, e.g. db_pass, so that this variable only exists when you set it and run your program instead of it being hardcoded somewhere.\n\nfor pyyaml to be able to resolve environment variables, we need three main things:\n\n* a regex pattern for the environment variable identification e.g. pattern = re.compile(\u2018.*?\\${(\\w+)}.*?\u2019)\n\n* a tag that will signify that there\u2019s an environment variable (or more) to be parsed, e.g. !env.\n\n* and a function that the loader will use to resolve the environment variables\n\n```python\ndef constructor_env_variables(loader, node):\n    \"\"\"\n    extracts the environment variable from the node's value\n    :param yaml.loader loader: the yaml loader\n    :param node: the current node in the yaml\n    :return: the parsed string that contains the value of the environment\n    variable\n    \"\"\"\n    value = loader.construct_scalar(node)\n    match = pattern.findall(value)\n    if match:\n        full_value = value\n        for g in match:\n            full_value = full_value.replace(\n                f'${{{g}}}', os.environ.get(g, g)\n            )\n        return full_value\n    return value\n```\n\nexample of a yaml configuration with environment variables:\n\n    database:\n     name: database_name\n     user: !env ${db_user}\n     password: !env ${db_pass}\n     host: !env ${db_host}\n     port: 5432\n\n    ws:\n     user: !env ${ws_user}\n     password: !env ${ws_pass}\n     host: !env \u2018[https://${curr_env}.ws.com.local'](https://${curr_env}.ws.com.local')\n\nthis can also work **with more than one environment variables** declared in the same line for the same configuration parameter like this:\n\n    ws:\n     user: !env ${ws_user}\n     password: !env ${ws_pass}\n     host: !env '[https://${curr_env}.ws.com.](https://${curr_env}.ws.com.local')[${mode}](https://${curr_env}.ws.com.local')'  # multiple env var\n\nand how to use this:\n\nfirst set the environment variables. for example, for the db_pass :\n\n    export db_pass=very_secret_and_complex\n\nor even better, so that the password is not echoed in the terminal:\n\n    read -s \u2018database password: \u2018 db_pass\n    export db_pass=$db_pass\n\n```python\n\n# to run this:\n# export db_pass=very_secret_and_complex \n# python use_env_variables_in_config_example.py -c /path/to/yaml\n# do stuff with conf, e.g. access the database password like this: conf['database']['db_pass']\n\nif __name__ == '__main__':\n    parser = argparse.argumentparser(description='my awesome script')\n    parser.add_argument(\n        \"-c\", \"--conf\", action=\"store\", dest=\"conf_file\",\n        help=\"path to config file\"\n    )\n    args = parser.parse_args()\n    conf = parse_config(path=args.conf_file)\n```\n\n\nthen you can run the above script:\n```bash\npython use_env_variables_in_config_example.py -c /path/to/yaml\n```\n\nand in your code, do stuff with conf, e.g. access the database password like this: `conf['database']['db_pass']`\n\ni hope this was helpful. any thoughts, questions, corrections and suggestions are very welcome :)\n\n## useful links\n[**the many faces and files of python configs**\n*as we cling harder and harder to dockerfiles, kubernetes, or any modern preconfigured app environment, our dependency\u2026*hackersandslackers.com](https://hackersandslackers.com/simplify-your-python-projects-configuration/)\n[**4 ways to manage the configuration in python**\n*i\u2019m not a native speaker. sorry for my english. please understand.*hackernoon.com](https://hackernoon.com/4-ways-to-manage-the-configuration-in-python-4623049e841b)\n[**python configuration files**\n*a common need when writing an application is loading and saving configuration values in a human-readable text format\u2026*www.devdungeon.com](https://www.devdungeon.com/content/python-configuration-files)\n[**configuration files in python**\n*most interesting programs need some kind of configuration: content management systems like wordpress blogs, wikimedia\u2026*martin-thoma.com](https://martin-thoma.com/configuration-files-in-python/)\n\n\n\n<a href=\"https://www.buymeacoffee.com/mkaranasou\" target=\"_blank\" style=\"background: #40dca5;\"><img src=\"https://cdn.buymeacoffee.com/buttons/default-orange.png\" alt=\"buy me a coffee\" height=\"41\" width=\"174\"></a>\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "pyaml-env",
  "package_url": "https://pypi.org/project/pyaml-env/",
  "project_url": "https://pypi.org/project/pyaml-env/",
  "project_urls": {
    "Bug Tracker": "https://github.com/mkaranasou/pyaml_env/issues",
    "Homepage": "https://github.com/mkaranasou/pyaml_env"
  },
  "release_url": "https://pypi.org/project/pyaml-env/1.2.1/",
  "requires_dist": [
    "PyYAML (<=7.0,>=5.0)",
    "pytest ; extra == 'test'"
  ],
  "requires_python": ">=3.6",
  "summary": "provides yaml file parsing with environment variable resolution",
  "version": "1.2.1",
  "releases": [],
  "developers": [
    "karanasou@gmail.com",
    "maria_karanasou"
  ],
  "kwds": "badge pyaml_env pyyaml pyyamldocumentation pyaml",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pyaml_env",
  "homepage": "https://github.com/mkaranasou/pyaml_env",
  "release_count": 11,
  "dependency_ids": [
    "pypi_pytest",
    "pypi_pyyaml"
  ]
}