{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "this package provides base classes of basic component types for the\nzope component architecture, as well as means for configuring and\nregistering them directly in python (without zcml).\n\n.. contents::\n\nhow to set up ``grokcore.component``\n====================================\n\nin the following we assume you're writing or extending an application\nthat does bootstrap configuration using zcml.  there's always a single\nzcml file that is executed when the application is started, which then\nincludes everything else.  let's assume this file is called\n``site.zcml`` (that's what it's called in zope), so that file is what\nwe'll be editing.\n\nin order to register the components that you wrote using the base\nclasses and directives available from ``grokcore.component``, we'll\nuse the ``<grok:grok />`` zcml directive.  but before we can use it,\nwe need to make sure it's available to the zcml machinery.  we do this\nby including the meta configuration from ``grokcore.component``::\n\n  <include package=\"grokcore.component\" file=\"meta.zcml\" />\n\nput this line somewhere to the top of ``site.zcml``, next to other\nmeta configuration includes.  now, further down the line, we can tell\nthe machinery in ``grokcore.component`` to register all components in\nyour package (let's say it's called ``helloworld``)::\n\n  <grok:grok package=\"helloworld\" />\n\nto sum up, your ``site.zcml`` file should look like something like this::\n\n  <configure\n      xmlns=\"http://namespaces.zope.org/zope\"\n      xmlns:grok=\"http://namespaces.zope.org/grok\">\n\n    <!-- do the meta configuration to make the zcml directives available -->\n    <include package=\"zope.foobar\" file=\"meta.zcml\" />\n    <include package=\"zope.frobnaz\" file=\"meta.zcml\" />\n    <include package=\"grokcore.component\" file=\"meta.zcml\" />\n\n    <!-- now load the configuration of packages that we depend on -->\n    <include package=\"zope.barfoo\" />\n    <include package=\"zope.somethingorother\" />\n\n    <!-- finally load my components which are based on grokcore.component -->\n    <grok:grok package=\"helloworld\" />\n\n  </configure>\n\nthere is an optional ``exclude`` on the `grok` directive. it allows to specify\nnames of packages or modules that if encountered won't be grokked. these\nnames might contain unix shell-style wildcards.\n\n`implementer()` versus `implements()`\n=====================================\n\nnote how the python 3 compatibility brings a change in how the\n`grokcore.component.implements()` *directive* works. when using this directive\nyou now have to make sure the component is grokkked, to have the underlying\nmechanism to take effect.\n\nalternatively you could start to use the `grokcore.component.implementer()`\n*class decorator* instead. this will do the same thing, but does not require\nyour component to be grokkked and still have your component declare it\nimplements the given interface.\n\nexamples\n========\n\nadapter\n-------\n\nhere's a simple adapter that may be useful in zope.  it extracts the\nlanguages that a user prefers from the request::\n\n  import grokcore.component\n  from zope.publisher.interfaces.browser import ibrowserrequest\n  from zope.i18n.interfaces import iuserpreferredlanguages\n\n  class cookielanguage(grokcore.component.adapter):\n      \"\"\"extract the preferred language from a cookie\"\"\"\n      grokcore.component.context(ibrowserrequest)\n      grokcore.component.implements(iuserpreferredlanguages)\n\n      # no need to implement __init__, it's already provided by the base class.\n\n      def getpreferredlanguages(self):\n          # this an adapter for the request, so self.context is the request.\n          request = self.context\n\n          # extract the preferred language from a cookie:\n          lang = request.cookies.get('language', 'en')\n\n          # according to iuserpreferredlanguages, we must return a list.\n          return [lang]\n\nmulti-adapter\n-------------\n\nhere's a multi-adapter that functions as a content provider as known\nfrom the ``zope.contentprovider`` library.  content providers are\ncomponents that return snippets of html.  they're multi-adapters for\nthe content object (model), the request and the view that they're\nsupposed to be a part of::\n\n  import grokcore.component\n  from zope.publisher.interfaces.browser import ibrowserrequest\n  from zope.publisher.interfaces.browser import ibrowserpage\n  from zope.contentprovider.interfaces import icontentprovider\n\n  class helloworldprovider(grokcore.component.multiadapter):\n      \"\"\"display hello world!\"\"\"\n      grokcore.component.adapts(interface, ibrowserrequest, ibrowserpage)\n      grokcore.component.implements(icontentprovider)\n\n      def __init__(self, context, request, view):\n          pass\n\n      def update(self):\n          pass\n\n      def render(self):\n          return u'<p>hello world!</p>'\n\n\nglobal utility\n--------------\n\nhere's a simple named utility, again from the zope world.  it's a\ntranslation domain.  in other words, it contains translations of user\nmessages and is invoked when the i18n machinery needs to translate\nsomething::\n\n  import grokcore.component\n  from zope.i18n.interfaces import itranslationdomain\n\n  class helloworldtranslationdomain(grokcore.component.globalutility):\n      grokcore.component.implements(itranslationdomain)\n      grokcore.component.name('helloworld')\n\n      domain = u'helloworld'\n\n      def translate(self, msgid, mapping=none, context=none,\n                    target_language=none, default=none):\n          if target_language is none:\n              preferred = iuserpreferredlanguages(context)\n              target_language = preferred.getpreferredlanguages()[0]\n\n          translations = {'de': u'hallo welt',\n                          'nl': u'hallo wereld'}\n          return translations.get(target_language, u'hello world')\n\nof course, it's silly to implement your own translation domain utility\nif there are already implementations available in ``zope.i18n`` (one\nthat reads translations from a gnu gettext message catalog and a\nsimple implementation for tests).  let's try to reuse that\nimplementation and register an instance::\n\n  import grokcore.component\n  from zope.i18n.interfaces import itranslationdomain\n  from zope.i18n.simpletranslationdomain import simpletranslationdomain\n\n  messages = {('de', u'hello world'): u'hallo welt',\n              ('nl', u'hello world'): u'hallo wereld'}\n  helloworld_domain = simpletranslationdomain(u'helloworld', messages)\n\n  grokcore.component.global_utility(helloworld_domain,\n                                    provides=itranslationdomain,\n                                    name='helloworld',\n                                    direct=true)\n\nglobal adapter\n--------------\n\nsometimes, you may have an object that should be registered as an adapter\nfactory. it may have come from some other framework that configured that\nadapter for you, say, or you may have a class that you instantiate many\ntimes to get different variations on a particular adapter factory. in these\ncases, subclassing grokcore.component.adapter or multiadapter is not\npossible. instead, you can use the global_adapter() directive. here is an\nexample drawing on the ``z3c.form`` library, which provides an adapter factory\nfactory for named widget attributes::\n\n  import zope.interface\n  import zope.schema\n  import grokcore.component\n  import z3c.form.widget import computedwidgetattribute\n\n  class ischema(interface):\n      \"\"\"this schema will be used to power a z3c.form form\"\"\"\n\n      field = zope.schema.textline(title=u\"sample field\")\n\n  ...\n\n  label_override = z3c.form.widget.staticwidgetattribute(\n                        u\"override label\", field=ischema['field'])\n\n  grokcore.component.global_adapter(label_override, name=u\"label\")\n\nin the example above, the provided and adapted interfaces are deduced from the\nobject returned by the ``staticwidgetattribute`` factory. the full syntax\nfor global_adapter is::\n\n  global_adapter(factory, (iadapted1, iadapted2,), iprovided, name=u\"name\")\n\nthe factory must be a callable (the adapter factory). adapted interfaces are\ngiven as a tuple. you may use a single interface instead of a one-element\ntuple for single adapters. the provided interface is given as shown. the name\ndefaults to u\"\" (an unnamed adapter).\n\nhandling events\n---------------\n\nhere we see an event handler much like it occurs within zope itself. it\nsubscribes to the modified event for all annotatable objects (in other words,\nobjects that can have metadata associated with them). when invoked, it updates\nthe dublin core 'modified' property accordingly::\n\n  import datetime\n  import grokcore.component\n  from zope.annotation.interfaces import iannotatable\n  from zope.lifecycleevent.interfaces import iobjectmodifiedevent\n  from zope.dublincore.interfaces import izopedublincore\n\n  @grokcore.component.subscribe(iannotatable, iobjectmodifiedevent)\n  def updatedublincoreaftermodification(obj, event):\n      \"\"\"updated the dublin core 'modified' property when a modified\n      event is sent for an object.\"\"\"\n      izopedublincore(obj).modified = datetime.datetime.utcnow()\n\nsubscriptions\n-------------\n\nsubscriptions look similar to adapter, however, unlike regular adapters,\nsubscription adapters are used when we want all of the adapters that adapt an\nobject to a particular adapter.\n\nanalogous to multiadapter, there is a multisubscription component that \"adapts\"\nmultiple objects.\n\nchanges\n=======\n\n4.1 (2023-03-21)\n----------------\n\n- upgrade to support ``zope.interface >= 6.0`` by no longer importing removed\n  functions:\n\n    + ``classprovides``\n    + ``implementsonly``\n\n\n4.0 (2023-02-17)\n----------------\n\n- add support for python 3.10, 3.11.\n\n- drop support for python 2.7, 3.5, 3.6.\n\n\n3.2.0 (2021-03-22)\n------------------\n\n- add support for python 3.7 up to 3.9.\n\n- update to ``zope.component >= 5``.\n\n- drop support for python 3.4.\n\n\n3.1 (2018-05-09)\n----------------\n\n- expose ``martian.ignore`` through our api.\n\n3.0.2 (2018-01-17)\n------------------\n\n- replace the use of `grok.implements()` with the `@grok.implementer()`\n  directive throughout.\n\n3.0.1 (2018-01-12)\n------------------\n\n- rearrange tests such that travis ci can pick up all functional tests too.\n\n3.0 (2017-10-19)\n----------------\n\n- add support for python 3.5, 3.6, pypy2 and pypy3.\n\n- drop support for python 2.6 and 3.3.\n\n2.7 (2016-02-16)\n----------------\n\n- add ability to exclude more than one module or package using\n  ``<grok:grok exclude=\"<names>\" />`` and allow to use unix shell-style\n  wildcards within.\n\n2.6.1 (2016-01-29)\n------------------\n\n- make grokcore.component.implementer compatible with\n  zope.interface.implementer by allowing doing the adapter magic when\n  used on functions.\n\n2.6 (2015-05-12)\n----------------\n\n- compatibility for python 3l\n\n- python 3 doesn't support the directive ``zope.interface.implements``\n  any more and is required to use the ``@implementer`` class decorator instead.\n  this version of grokcore.components provides its own\n  ``grokcore.component.implements`` directive for both python 2 and 3.\n  so this directive can still be used with the help of a grokker.\n  if you use grokcore.components >= 2.6  the new implementation will be used\n  while earlier versions used zope.interface.implements.\n\n2.5 (2012-05-01)\n----------------\n\n- introduce provideutility, provideradapter, providesubscriptionadapter,\n  providehandler and provideinterface in grokcore.component. these by default\n  delegate the registration of components to the global site manager like\n  was done before, but provide the possibility for custom registries for the\n  grokked components.\n\n- fix the `global_adapter` to properly use information annotated by\n  ``grok.adapter``, and using the icontext object if it was not\n  specified. (fix launchpad issue #960097).\n\n- add a ``key`` option to ``sort_components`` that behave like ``key``\n  options available on standard python sort methods.\n\n2.4 (2011-04-27)\n----------------\n\n- fix the `global_adapter` directive implementation to accept an explicit\n  \"empty\" name for nameless adapter registrations (as it used to be that\n  providing an empty name in the registration would actually result in\n  registering a named adapter in case the factory has a `grok.name`).\n\n2.3 (2011-02-14)\n----------------\n\n- implement the generic (multi)subscriptions components.\n\n2.2 (2010-11-03)\n----------------\n\n- the default values computation for the context directive and the provides\n  directive is now defined in the directives themselves. this means that where\n  the values for these directives is being retrieved, the \"default_context\"\n  function does not need to be passed along anymore for general cases.\n\n  analogous to this, when getting values for the provides directive the\n  \"default_provides\" function does not need to be passed along in the general\n  case.\n\n2.1 (2010-11-01)\n----------------\n\n* made package comply to zope.org repository policy.\n\n* moved directives 'order' from grokcore.viewlet and 'path' from\n  grokcore.view to this very package.\n\n* tiny dependency adjustment: moved zope.event to test dependencies.\n\n* port from 1.x branch exclude parameter to the grok zcml directive.\n\n* port from 1.x branch the ignore of testing.py modules.\n\n2.0 (2009-09-16)\n----------------\n\n* use a newer version of martian that has better support for\n  inheritance.  this is demonstrated in ``tests/inherit``.\n\n* the ``contextgrokker`` and the ``scan.py`` module have gone away\n  thanks the newer martian.\n\n* directive implementations (in their factory method) should *not*\n  bind directives. directive binding cannot take place at import time,\n  but only at grok time. binding directives during import time (when\n  directives are executed) can lead to change problems. (we noticed\n  this during our refactoring to use the new martian).\n\n* use 1.0b1 versions.cfg in grok's release info instead of a local\n  copy; a local copy for all grokcore packages is just too hard to\n  maintain.\n\n1.7 (2009-06-01)\n----------------\n\n* add missing provider, global_adapter, implementsonly, classprovides() to\n  the module interface so that they are included in __all__\n\n1.6 (2009-04-10)\n----------------\n\n* add convenience imports for implementsonly() and classprovides() class\n  declarations form zope.interface.\n\n* add support for registering global adapters at module level::\n\n    grok.global_adapter(factory, (iadapted1, iadapted2,), iprovided, name=u\"name\")\n\n  only 'factory' is required. if only a single interface is adapted, the\n  second argument may be a single interface instead of a tuple. if the\n  component has declared adapted/provided interfaces, the second and third\n  arguments may be omitted.\n\n* add support for an @provider decorator to let a function directly provide\n  an interface::\n\n    @grok.provider(ifoo, ibar)\n    def some_function():\n        ...\n\n  this is equivalent to doing alsoprovides(some_function, ifoo, ibar).\n\n* add support for named adapters with the @adapter decorator::\n\n    @grok.adapter(iadaptedone, iadaptedtwo, name=u\"foo\")\n    def some_function(one, two):\n        ...\n\n1.5.1 (2008-07-28)\n------------------\n\n* the ``igrokcorecomponentapi`` interface was missing declarations for\n  the ``title`` and ``description`` directives.\n\n1.5 (2008-07-22)\n----------------\n\n* fix https://bugs.launchpad.net/grok/+bug/242353: grokcore.component\n  contains old-style test setup. there is no `register_all_tests`\n  method in grokcore.component.testing anymore. use z3c.testsetup\n  instead.\n\n* allow functions that have been marked with @grok.subscribe also be\n  registered with ``zope.component.providehandler()`` manually.  this\n  is useful for unit tests where you may not want to grok a whole\n  module.\n\n* document grokcore.component's public api in an interface,\n  ``igrokcorecomponentapi``.  when you now do::\n\n    from grokcore.component import *\n\n  only the items documented in that interface will be imported into\n  your local namespace.\n\n1.4 (2008-06-11)\n----------------\n\n* ported class grokkers to make use of further improvements in martian.\n  this requires martian 0.10.\n\n1.3 (2008-05-14)\n----------------\n\n* ported class grokkers to make use of the new declarative way of\n  retrieving directive information from a class.  this requires\n  martian 0.9.6.\n\n1.2.1 (2008-05-04)\n------------------\n\n* upgrade to martian 0.9.5, which has a slight change in the signature of\n  ``scan_for_classes``.\n\n* remove an unnecessary import ``methods_from_class`` from\n  ``grokcore.component.scan``.\n\n1.2 (2008-05-04)\n----------------\n\n* ported directives to martian's new directive implementation.  as a\n  result, nearly all helper functions that were available from\n  ``grokcore.component.util`` have been removed.  the functionality is\n  mostly available from the directives themselves now.\n\n* the ``baseclass`` directive has been moved to martian.\n\n* the ``order`` directive and its helper functions have been moved\n  back to grok, as it was of no general use, but very specific to\n  viewlets.\n\n1.1 (2008-05-03)\n----------------\n\n* ``determine_module_component`` now looks for classes that implement\n  a certain interface (such as ``icontext``), instead of taking a list\n  of classes.  if looking for ``icontext``, it still will find\n  ``context`` subclasses, as these were also made to implement\n  ``icontext``.\n\n* move the ``public_methods_from_class`` helper function back to grok,\n  it isn't used at all in ``grokcore.component``.\n\n1.0.1 (2008-05-02)\n------------------\n\n* the grokkers for adapters and global utilities did not use the\n  correct value for the *provided* interface in the configuration\n  action discriminator.  because of this, uninformative and\n  potentially wrong conflict errors would occur, as well as no\n  conflict where a conflict should have occurred.\n\n* the grokker for the ``global_utility()`` directive did immediate\n  registrations instead of generating configuration actions.\n  therefore it did not provoke ``conflicterrors`` for conflicting\n  registrations.\n\n* improved documentation\n\n1.0 (2008-05-01)\n----------------\n\n* created ``grokcore.component`` in march 2008 by factoring basic\n  component base classes and their directives and grokkers out of\n  grok.\n",
  "docs_url": null,
  "keywords": "",
  "license": "zpl",
  "name": "grokcore.component",
  "package_url": "https://pypi.org/project/grokcore.component/",
  "project_url": "https://pypi.org/project/grokcore.component/",
  "project_urls": {
    "Homepage": "https://github.com/zopefoundation/grokcore.component"
  },
  "release_url": "https://pypi.org/project/grokcore.component/4.1/",
  "requires_dist": [
    "setuptools",
    "martian (>=1.2)",
    "zope.component",
    "zope.configuration",
    "zope.interface",
    "zope.testing",
    "zope.event ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "grok-like configuration for basic components (adapters, utilities, subscribers)",
  "version": "4.1",
  "releases": [],
  "developers": [
    "grok_team",
    "zope-dev@zope.dev"
  ],
  "kwds": "zcml grokcore default_provides grok default_context",
  "license_kwds": "zpl",
  "libtype": "pypi",
  "id": "pypi_grokcore.component",
  "homepage": "https://github.com/zopefoundation/grokcore.component",
  "release_count": 30,
  "dependency_ids": [
    "pypi_martian",
    "pypi_setuptools",
    "pypi_zope.component",
    "pypi_zope.configuration",
    "pypi_zope.event",
    "pypi_zope.interface",
    "pypi_zope.testing"
  ]
}