{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu library or lesser general public license (lgpl)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8"
  ],
  "description": "..\n   copyright (c) 2008-2013 canonical ltd.\n\n   this file is part of wadllib.\n\n   wadllib is free software: you can redistribute it and/or modify it under\n   the terms of the gnu lesser general public license as published by the\n   free software foundation, version 3 of the license.\n\n   wadllib is distributed in the hope that it will be useful, but without any\n   warranty; without even the implied warranty of merchantability or fitness\n   for a particular purpose. see the gnu lesser general public license for\n   more details.\n\n   you should have received a copy of the gnu lesser general public license\n   along with wadllib. if not, see <http://www.gnu.org/licenses/>.\n\n=======\nwadllib\n=======\n\nan application object represents a web service described by a wadl\nfile.\n\n   >>> import os\n   >>> import sys\n   >>> import pkg_resources\n   >>> from wadllib.application import application\n\nthe first argument to the application constructor is the url at which\nthe wadl file was found. the second argument may be raw wadl markup.\n\n   >>> wadl_string = pkg_resources.resource_string(\n   ...     'wadllib.tests.data', 'launchpad-wadl.xml')\n   >>> wadl = application(\"http://api.launchpad.dev/beta/\", wadl_string)\n\nor the second argument may be an open filehandle containing the markup.\n\n   >>> cleanups = []\n   >>> def application_for(filename, url=\"http://www.example.com/\"):\n   ...    wadl_stream = pkg_resources.resource_stream(\n   ...    'wadllib.tests.data', filename)\n   ...    cleanups.append(wadl_stream)\n   ...    return application(url, wadl_stream)\n   >>> wadl = application_for(\"launchpad-wadl.xml\",\n   ...                        \"http://api.launchpad.dev/beta/\")\n\n\nlink navigation\n===============\n\nthe preferred technique for finding a resource is to start at one of\nthe resources defined in the wadl file, and follow links. this code\nretrieves the definition of the root resource.\n\n   >>> service_root = wadl.get_resource_by_path('')\n   >>> service_root.url\n   'http://api.launchpad.dev/beta/'\n   >>> service_root.type_url\n   '#service-root'\n\nthe service root resource supports get.\n\n   >>> get_method = service_root.get_method('get')\n   >>> get_method.id\n   'service-root-get'\n\n   >>> get_method = service_root.get_method('get')\n   >>> get_method.id\n   'service-root-get'\n\nif we want to invoke this method, we send a get request to the service\nroot url.\n\n   >>> get_method.name\n   'get'\n   >>> get_method.build_request_url()\n   'http://api.launchpad.dev/beta/'\n\nthe wadl description of a resource knows which representations are\navailable for that resource. in this case, the server root resource\nhas a a json representation, and it defines parameters like\n'people_collection_link', a link to a list of people in launchpad. we\nshould be able to use the get_parameter() method to get the wadl\ndefinition of the 'people_collection_link' parameter and find out more\nabout it--for instance, is it a link to another resource?\n\n   >>> def test_raises(exc_class, method, *args, **kwargs):\n   ...     try:\n   ...         method(*args, **kwargs)\n   ...     except exception:\n   ...         # contortion to support python < 2.6 and >= 3 simultaneously.\n   ...         e = sys.exc_info()[1]\n   ...         if isinstance(e, exc_class):\n   ...             print(e)\n   ...             return\n   ...         raise\n   ...     raise exception(\"expected exception %s not raised\" % exc_class)\n\n   >>> from wadllib.application import noboundrepresentationerror\n   >>> link_name = 'people_collection_link'\n   >>> test_raises(\n   ...     noboundrepresentationerror, service_root.get_parameter, link_name)\n   resource is not bound to any representation, and no media media type was specified.\n\noops. the code has no way to know whether 'people_collection_link' is\na parameter of the json representation or some other kind of\nrepresentation. we can pass a media type to get_parameter and let it\nknow which representation the parameter lives in.\n\n   >>> link_parameter = service_root.get_parameter(\n   ...     link_name, 'application/json')\n   >>> test_raises(noboundrepresentationerror, link_parameter.get_value)\n   resource is not bound to any representation.\n\noops again. the parameter is available, but it has no value, because\nthere's no actual data associated with the resource. the browser can\nlook up the description of the get method to make an actual get\nrequest to the service root, and bind the resulting representation to\nthe wadl description of the service root.\n\nyou can't bind just any representation to a wadl resource description.\nit has to be of a media type understood by the wadl description.\n\n   >>> from wadllib.application import unsupportedmediatypeerror\n   >>> test_raises(\n   ...     unsupportedmediatypeerror, service_root.bind,\n   ...     '<html>some html</html>', 'text/html')\n   this resource doesn't define a representation for media type text/html\n\nthe wadl description of the service root resource has a json\nrepresentation. here it is.\n\n   >>> json_representation = service_root.get_representation_definition(\n   ...     'application/json')\n   >>> json_representation.media_type\n   'application/json'\n\nwe already have a wadl representation of the service root resource, so\nlet's try binding it to that json representation. we use test json\ndata from a file to simulate the result of a get request to the\nservice root.\n\n   >>> def get_testdata(filename):\n   ...     return pkg_resources.resource_string(\n   ...         'wadllib.tests.data', filename + '.json')\n\n   >>> def bind_to_testdata(resource, filename):\n   ...     return resource.bind(get_testdata(filename), 'application/json')\n\nthe return value is a new resource object that's \"bound\" to that json\ntest data.\n\n   >>> bound_service_root = bind_to_testdata(service_root, 'root')\n   >>> sorted([param.name for param in bound_service_root.parameters()])\n   ['bugs_collection_link', 'people_collection_link']\n   >>> sorted(bound_service_root.parameter_names())\n   ['bugs_collection_link', 'people_collection_link']\n   >>> [method.id for method in bound_service_root.method_iter]\n   ['service-root-get']\n\nnow the bound resource object has a json representation, and now\n'people_collection_link' makes sense. we can follow the\n'people_collection_link' to a new resource object.\n\n   >>> link_parameter = bound_service_root.get_parameter(link_name)\n   >>> link_parameter.style\n   'plain'\n   >>> print(link_parameter.get_value())\n   http://api.launchpad.dev/beta/people\n   >>> personset_resource = link_parameter.linked_resource\n   >>> personset_resource.__class__\n   <class 'wadllib.application.resource'>\n   >>> print(personset_resource.url)\n   http://api.launchpad.dev/beta/people\n   >>> personset_resource.type_url\n   'http://api.launchpad.dev/beta/#people'\n\nthis new resource is a collection of people.\n\n   >>> personset_resource.id\n   'people'\n\nthe \"collection of people\" resource supports a standard get request as\nwell as a special get and an overloaded post. the get_method() method\nis used to retrieve wadl definitions of the possible http requests you\nmight make. here's how to get the wadl definition of the standard get\nrequest.\n\n   >>> get_method = personset_resource.get_method('get')\n   >>> get_method.id\n   'people-get'\n\nthe method name passed into get_method() is treated case-insensitively.\n\n   >>> personset_resource.get_method('get').id\n   'people-get'\n\nto invoke the special get request, the client sets the 'ws.op' query\nparameter to the fixed string 'findperson'.\n\n   >>> find_method = personset_resource.get_method(\n   ...     query_params={'ws.op' : 'findperson'})\n   >>> find_method.id\n   'people-findperson'\n\ngiven an end-user's values for the non-fixed parameters, it's possible\nto get the url that should be used to invoke the method.\n\n   >>> print(find_method.build_request_url(text='foo'))\n   http://api.launchpad.dev/beta/people?text=foo&ws.op=findperson\n\n   >>> print(find_method.build_request_url(\n   ...     {'ws.op' : 'findperson', 'text' : 'bar'}))\n   http://api.launchpad.dev/beta/people?text=bar&ws.op=findperson\n\nan error occurs if the end-user gives an incorrect value for a fixed\nparameter value, or omits a required parameter.\n\n   >>> find_method.build_request_url()\n   traceback (most recent call last):\n   ...\n   valueerror: no value for required parameter 'text'\n\n   >>> find_method.build_request_url(\n   ...     {'ws.op' : 'findaperson', 'text' : 'foo'})\n   ... # doctest: +ellipsis, +normalize_whitespace\n   traceback (most recent call last):\n   ...\n   valueerror: value 'findaperson' for parameter 'ws.op' conflicts\n   with fixed value 'findperson'\n\nto invoke the overloaded post request, the client sets the 'ws.op'\nquery variable to the fixed string 'newteam':\n\n   >>> create_team_method = personset_resource.get_method(\n   ...     'post', representation_params={'ws.op' : 'newteam'})\n   >>> create_team_method.id\n   'people-newteam'\n\nfindmethod() returns none when there's no wadl method matching the\nname or the fixed parameters.\n\n   >>> print(personset_resource.get_method('nosuchmethod'))\n   none\n\n   >>> print(personset_resource.get_method(\n   ...     'post', query_params={'ws_op' : 'nosuchparam'}))\n   none\n\nlet's say the browser makes a get request to the person set resource\nand gets back a representation. we can bind that representation to our\ndescription of the person set resource.\n\n   >>> bound_personset = bind_to_testdata(personset_resource, 'personset')\n   >>> bound_personset.get_parameter(\"start\").get_value()\n   0\n   >>> bound_personset.get_parameter(\"total_size\").get_value()\n   63\n\nwe can keep following links indefinitely, so long as we bind to a\nrepresentation to each resource as we get it, and use the\nrepresentation to find the next link.\n\n   >>> next_page_link = bound_personset.get_parameter(\"next_collection_link\")\n   >>> print(next_page_link.get_value())\n   http://api.launchpad.dev/beta/people?ws.start=5&ws.size=5\n   >>> page_two = next_page_link.linked_resource\n   >>> bound_page_two = bind_to_testdata(page_two, 'personset-page2')\n   >>> print(bound_page_two.url)\n   http://api.launchpad.dev/beta/people?ws.start=5&ws.size=5\n   >>> bound_page_two.get_parameter(\"start\").get_value()\n   5\n   >>> print(bound_page_two.get_parameter(\"next_collection_link\").get_value())\n   http://api.launchpad.dev/beta/people?ws.start=10&ws.size=5\n\nlet's say the browser makes a post request that invokes the 'newteam'\nnamed operation. the response will include a number of http headers,\nincluding 'location', which points the way to the newly created team.\n\n   >>> headers = { 'location' : 'http://api.launchpad.dev/~newteam' }\n   >>> response = create_team_method.response.bind(headers)\n   >>> location_parameter = response.get_parameter('location')\n   >>> location_parameter.get_value()\n   'http://api.launchpad.dev/~newteam'\n   >>> new_team = location_parameter.linked_resource\n   >>> new_team.url\n   'http://api.launchpad.dev/~newteam'\n   >>> new_team.type_url\n   'http://api.launchpad.dev/beta/#team'\n\nexamining links\n---------------\n\nthe 'linked_resource' property of a parameter lets you follow a link\nto another object. the 'link' property of a parameter lets you examine\nlinks before following them.\n\n    >>> import json\n    >>> links_wadl = application_for('links-wadl.xml')\n    >>> service_root = links_wadl.get_resource_by_path('')\n    >>> representation = json.dumps(\n    ...     {'scalar_value': 'foo',\n    ...      'known_link': 'http://known/',\n    ...      'unknown_link': 'http://unknown/'})\n    >>> bound_root = service_root.bind(representation)\n\n    >>> print(bound_root.get_parameter(\"scalar_value\").link)\n    none\n\n    >>> known_resource = bound_root.get_parameter(\"known_link\")\n    >>> unknown_resource = bound_root.get_parameter(\"unknown_link\")\n\n    >>> print(known_resource.link.can_follow)\n    true\n    >>> print(unknown_resource.link.can_follow)\n    false\n\na link whose type is unknown is a link to a resource not described by\nwadl. following this link using .linked_resource or .link.follow will\ncause a wadllib error. you'll need to follow the link using a general\nhttp library or some other tool.\n\n    >>> known_resource.link.follow\n    <wadllib.application.resource object ...>\n    >>> known_resource.linked_resource\n    <wadllib.application.resource object ...>\n\n    >>> from wadllib.application import wadlerror\n    >>> test_raises(wadlerror, getattr, unknown_resource.link, 'follow')\n    cannot follow a link when the target has no wadl\n    description. try using a general http client instead.\n\n    >>> test_raises(wadlerror, getattr, unknown_resource, 'linked_resource')\n    cannot follow a link when the target has no wadl\n    description. try using a general http client instead.\n\ncreating a resource from a representation definition\n====================================================\n\nalthough every representation is a representation of some http\nresource, an http resource doesn't necessarily correspond directly to\na wadl <resource> or <resource_type> tag. sometimes a representation\nis defined within a wadl <method> tag.\n\n   >>> find_method = personset_resource.get_method(\n   ...     query_params={'ws.op' : 'find'})\n   >>> find_method.id\n   'people-find'\n\n   >>> representation_definition = (\n   ...     find_method.response.get_representation_definition(\n   ...     'application/json'))\n\nthere may be no wadl <resource> or <resource_type> tag for the\nrepresentation defined here. that's why wadllib makes it possible to\ninstantiate an anonymous resource object using only the representation\ndefinition.\n\n   >>> from wadllib.application import resource\n   >>> anonymous_resource = resource(\n   ...     wadl, \"http://foo/\", representation_definition.tag)\n\nwe can bind this resource to a representation, as long as we\nexplicitly pass in the representation definition.\n\n   >>> anonymous_resource = anonymous_resource.bind(\n   ...     get_testdata('personset'), 'application/json',\n   ...     representation_definition=representation_definition)\n\nonce the resource is bound to a representation, we can get its\nparameter values.\n\n   >>> print(anonymous_resource.get_parameter(\n   ...     'total_size', 'application/json').get_value())\n   63\n\nresource instantiation\n======================\n\nif you happen to have the url to an object lying around, and you know\nits type, you can construct a resource object directly instead of\nby following links.\n\n   >>> from wadllib.application import resource\n   >>> limi_person = resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\")\n   >>> sorted([method.id for method in limi_person.method_iter])[:3]\n   ['person-acceptinvitationtobememberof', 'person-addmember', 'person-declineinvitationtobememberof']\n\n   >>> bound_limi = bind_to_testdata(limi_person, 'person-limi')\n   >>> sorted(bound_limi.parameter_names())[:3]\n   ['admins_collection_link', 'confirmed_email_addresses_collection_link',\n    'date_created']\n   >>> languages_link = bound_limi.get_parameter(\"languages_collection_link\")\n   >>> print(languages_link.get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nyou can bind a resource to a representation when you create it.\n\n   >>> limi_data = get_testdata('person-limi')\n   >>> bound_limi = resource(\n   ...     wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\", limi_data,\n   ...     \"application/json\")\n   >>> print(bound_limi.get_parameter(\n   ...     \"languages_collection_link\").get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nby default the representation is treated as a string and processed\naccording to the media type you pass into the resource constructor. if\nyou've already processed the representation, pass in false for the\n'representation_needs_processing' argument.\n\n   >>> from wadllib import _make_unicode\n   >>> processed_limi_data = json.loads(_make_unicode(limi_data))\n   >>> bound_limi = resource(wadl, \"http://api.launchpad.dev/beta/~limi\",\n   ...     \"http://api.launchpad.dev/beta/#person\", processed_limi_data,\n   ...     \"application/json\", false)\n   >>> print(bound_limi.get_parameter(\n   ...     \"languages_collection_link\").get_value())\n   http://api.launchpad.dev/beta/~limi/languages\n\nmost of the time, the representation of a resource is of the type\nyou'd get by sending a standard get to that resource. if that's not\nthe case, you can specify a representationdefinition as the\n'representation_definition' argument to bind() or the resource\nconstructor, to show what the representation really looks like. here's\nan example.\n\nthere's a method on a person resource such as bound_limi that's\nidentified by a distinctive query argument: ws.op=getmembersbystatus.\n\n   >>> method = bound_limi.get_method(\n   ...     query_params={'ws.op' : 'findpathtoteam'})\n\ninvoke this method with a get request and you'll get back a page from\na list of people.\n\n   >>> people_page_repr_definition = (\n   ...     method.response.get_representation_definition('application/json'))\n   >>> people_page_repr_definition.tag.attrib['href']\n   'http://api.launchpad.dev/beta/#person-page'\n\nas it happens, we have a page from a list of people to use as test data.\n\n   >>> people_page_repr = get_testdata('personset')\n\nif we bind the resource to the result of the method invocation as\nhappened above, we don't be able to access any of the parameters we'd\nexpect. wadllib will think the representation is of type\n'person-full', the default get type for bound_limi.\n\n   >>> bad_people_page = bound_limi.bind(people_page_repr)\n   >>> print(bad_people_page.get_parameter('total_size'))\n   none\n\nsince we don't actually have a 'person-full' representation, we won't\nbe able to get values for the parameters of that kind of\nrepresentation.\n\n   >>> bad_people_page.get_parameter('name').get_value()\n   traceback (most recent call last):\n   ...\n   keyerror: 'name'\n\nso that's a dead end. *but*, if we pass the correct representation\ntype into bind(), we can access the parameters associated with a\n'person-page' representation.\n\n   >>> people_page = bound_limi.bind(\n   ...     people_page_repr,\n   ...     representation_definition=people_page_repr_definition)\n   >>> people_page.get_parameter('total_size').get_value()\n   63\n\nif you invoke the method and ask for a media type other than json, you\nwon't get anything.\n\n   >>> print(method.response.get_representation_definition('text/html'))\n   none\n\ndata type conversion\n--------------------\n\nthe values of date and datetime parameters are automatically converted to\npython datetime objects.\n\n   >>> data_type_wadl = application_for('data-types-wadl.xml')\n   >>> service_root = data_type_wadl.get_resource_by_path('')\n\n   >>> representation = json.dumps(\n   ...     {'a_date': '2007-10-20',\n   ...      'a_datetime': '2005-06-06t08:59:51.619713+00:00'})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n\n   >>> bound_root.get_parameter('a_date').get_value()\n   datetime.datetime(2007, 10, 20, 0, 0)\n   >>> bound_root.get_parameter('a_datetime').get_value()\n   datetime.datetime(2005, 6, 6, 8, ...)\n\na 'date' field can include a timestamp, and a 'datetime' field can\nomit one. wadllib will turn both into datetime objects.\n\n   >>> representation = json.dumps(\n   ...     {'a_date': '2005-06-06t08:59:51.619713+00:00',\n   ...      'a_datetime': '2007-10-20'})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n\n   >>> bound_root.get_parameter('a_datetime').get_value()\n   datetime.datetime(2007, 10, 20, 0, 0)\n   >>> bound_root.get_parameter('a_date').get_value()\n   datetime.datetime(2005, 6, 6, 8, ...)\n\nif a date or datetime parameter has a null value, you get none. if the\nvalue is a string that can't be parsed to a datetime object, you get a\nvalueerror.\n\n   >>> representation = json.dumps(\n   ...     {'a_date': 'foo', 'a_datetime': none})\n   >>> bound_root = service_root.bind(representation, 'application/json')\n   >>> bound_root.get_parameter('a_date').get_value()\n   traceback (most recent call last):\n   ...\n   valueerror: foo\n   >>> print(bound_root.get_parameter('a_datetime').get_value())\n   none\n\nrepresentation creation\n=======================\n\nyou must provide a representation when invoking certain methods. the\nrepresentation() method helps you build one without knowing the\ndetails of how a representation is put together.\n\n   >>> create_team_method.build_representation(\n   ...     display_name='joe bloggs', name='joebloggs')\n   ('application/x-www-form-urlencoded', 'display_name=joe+bloggs&name=joebloggs&ws.op=newteam')\n\nthe return value of build_representation is a 2-tuple containing the\nmedia type of the built representation, and the string representation\nitself. along with the resource's url, this is all you need to send\nthe representation to a web server.\n\n   >>> bound_limi.get_method('patch').build_representation(name='limi2')\n   ('application/json', '{\"name\": \"limi2\"}')\n\nrepresentations may require values for certain parameters.\n\n   >>> create_team_method.build_representation()\n   traceback (most recent call last):\n   ...\n   valueerror: no value for required parameter 'display_name'\n\n   >>> bound_limi.get_method('put').build_representation(name='limi2')\n   traceback (most recent call last):\n   ...\n   valueerror: no value for required parameter 'mugshot_link'\n\nsome representations may safely include binary data.\n\n   >>> binary_stream = pkg_resources.resource_stream(\n   ...     'wadllib.tests.data', 'multipart-binary-wadl.xml')\n   >>> cleanups.append(binary_stream)\n   >>> binary_wadl = application(\n   ...     \"http://www.example.com/\", binary_stream)\n   >>> service_root = binary_wadl.get_resource_by_path('')\n\ndefine a helper that processes the representation the same way\nzope.publisher would.\n\n   >>> import cgi\n   >>> import io\n   >>> def assert_message_parts(media_type, doc, expected):\n   ...     environ = {\n   ...         'request_method': 'post',\n   ...         'content_type': media_type,\n   ...         'content_length': str(len(doc)),\n   ...         }\n   ...     kwargs = (\n   ...         {'encoding': 'utf-8'} if sys.version_info[0] >= 3 else {})\n   ...     fs = cgi.fieldstorage(\n   ...         fp=io.bytesio(doc), environ=environ, keep_blank_values=1,\n   ...         **kwargs)\n   ...     values = []\n   ...     def append_values(fields):\n   ...         for field in fields:\n   ...             if field.list:\n   ...                 append_values(field.list)\n   ...             else:\n   ...                 values.append(field.value)\n   ...     append_values(fs.list)\n   ...     assert values == expected, (\n   ...         'expected %s, got %s' % (expected, values))\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\", binary_field=b\"\\x01\\x02\\r\\x81\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(media_type, doc, ['text', b'\\x01\\x02\\r\\x81\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=u\"text\", binary_field=b\"\\x01\\x02\\r\\x81\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(media_type, doc, ['text', b'\\x01\\x02\\r\\x81\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\\n\", binary_field=b\"\\x01\\x02\\r\\x81\\n\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\n', b'\\x01\\x02\\r\\x81\\n\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=u\"text\\n\", binary_field=b\"\\x01\\x02\\r\\x81\\n\\r\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\n', b'\\x01\\x02\\r\\x81\\n\\r'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=\"text\\r\\nmore\\r\\n\",\n   ...     binary_field=b\"\\x01\\x02\\r\\n\\x81\\r\\x82\\n\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\nmore\\r\\n', b'\\x01\\x02\\r\\n\\x81\\r\\x82\\n'])\n\n   >>> method = service_root.get_method('post', 'multipart/form-data')\n   >>> media_type, doc = method.build_representation(\n   ...     text_field=u\"text\\r\\nmore\\r\\n\",\n   ...     binary_field=b\"\\x01\\x02\\r\\n\\x81\\r\\x82\\n\")\n   >>> print(media_type)\n   multipart/form-data; boundary=...\n   >>> assert_message_parts(\n   ...     media_type, doc, ['text\\r\\nmore\\r\\n', b'\\x01\\x02\\r\\n\\x81\\r\\x82\\n'])\n\n   >>> method = service_root.get_method('post', 'text/unknown')\n   >>> method.build_representation(field=\"value\")\n   traceback (most recent call last):\n   ...\n   valueerror: unsupported media type: 'text/unknown'\n\noptions\n=======\n\nsome parameters take values from a predefined list of options.\n\n   >>> option_wadl = application_for('options-wadl.xml')\n   >>> definitions = option_wadl.representation_definitions\n   >>> service_root = option_wadl.get_resource_by_path('')\n   >>> definition = definitions['service-root-json']\n   >>> param = definition.params(service_root)[0]\n   >>> print(param.name)\n   has_options\n   >>> sorted([option.value for option in param.options])\n   ['value 1', 'value 2']\n\nsuch parameters cannot take values that are not in the list.\n\n   >>> definition.validate_param_values(\n   ...     [param], {'has_options': 'value 1'})\n   {'has_options': 'value 1'}\n\n   >>> definition.validate_param_values(\n   ...     [param], {'has_options': 'invalid value'})\n   traceback (most recent call last):\n   ...\n   valueerror: invalid value 'invalid value' for parameter\n   'has_options': valid values are: \"value 1\", \"value 2\"\n\n\nerror conditions\n================\n\nyou'll get none if you try to look up a nonexistent resource.\n\n   >>> print(wadl.get_resource_by_path('nosuchresource'))\n   none\n\nyou'll get an exception if you try to look up a nonexistent resource\ntype.\n\n   >>> print(wadl.get_resource_type('#nosuchtype'))\n   traceback (most recent call last):\n   keyerror: 'no such xml id: \"#nosuchtype\"'\n\nyou'll get none if you try to look up a method whose parameters don't\nmatch any defined method.\n\n   >>> print(bound_limi.get_method(\n   ...     'post', representation_params={ 'foo' : 'bar' }))\n   none\n\n.. cleanup\n   >>> for stream in cleanups:\n   ...    stream.close()\n\n\n\n================\nnews for wadllib\n================\n\n1.3.6 (2021-09-13)\n==================\n\n- remove buildout support in favour of tox.  [bug=922605]\n- adjust versioning strategy to avoid importing pkg_resources, which is slow\n  in large environments.\n\n1.3.5 (2021-01-20)\n==================\n\n- drop support for python 3.2, 3.3, and 3.4.\n- accept unicode parameter values again when performing multipart/form-data\n  encoding on python 2 (broken in 1.3.3).\n\n1.3.4 (2020-04-29)\n==================\n\n- advertise support for python 3.8.\n- add python 3.9 compatibility by using xml.etree.elementtree if\n  xml.etree.celementtree does not exist.  [bug=1870294]\n\n1.3.3 (2018-07-20)\n==================\n\n- drop support for python < 2.6.\n- add tox testing support.\n- implement a subset of mime multipart/form-data encoding locally rather\n  than using the standard library's email module, which doesn't have good\n  handling of binary parts and corrupts bytes in them that look like line\n  endings in various ways depending on the python version.  [bug=1729754]\n\n1.3.2 (2013-02-25)\n==================\n\n- impose sort order to avoid test failures due to hash randomization.\n  lp: #1132125\n- be sure to close streams opened by pkg_resources.resource_stream() to avoid\n  test suite complaints.\n\n\n1.3.1 (2012-03-22)\n==================\n\n- correct the double pass through _from_string causing datetime issues\n\n\n1.3.0 (2012-01-27)\n==================\n\n- add python 3 compatibility\n\n- add the ability to inspect links before following them.\n\n- ensure that the sample data is packaged.\n\n1.2.0 (2011-02-03)\n==================\n\n- it's now possible to examine a link before following it, to see\n  whether it has a wadl description or whether it needs to be fetched\n  with a general http client.\n\n- it's now possible to iterate over a resource's parameter objects\n  with the .parameters() method.\n\n1.1.8 (2010-10-27)\n==================\n\n- this revision contains no code changes, but the build system was\n  changed (yet again).  this time to include the version.txt file\n  used by setup.py.\n\n1.1.7 (2010-10-26)\n==================\n\n- this revision contains no code changes, but the build system was\n  changed (again) to include the sample data used in tests.\n\n1.1.6 (2010-10-21)\n==================\n\n- this revision contains no code changes, but the build system was\n  changed to include the sample data used in tests.\n\n1.1.5 (2010-05-04)\n==================\n\n- fixed a bug (launchpad bug 274074) that prevented the lookup of\n  parameter values in resources associated directly with a\n  representation definition (rather than a resource type with a\n  representation definition). bug fix provided by james westby.\n\n1.1.4 (2009-09-15)\n==================\n\n- fixed a bug that crashed wadllib unless all parameters of a\n  multipart representation were provided.\n\n1.1.3 (2009-08-26)\n==================\n\n- remove unnecessary build dependencies.\n\n- add missing dependencies to setup file.\n\n- remove sys.path hack from setup.py.\n\n1.1.2 (2009-08-20)\n==================\n\n- consistently handle different versions of simplejson.\n\n1.1.1 (2009-07-14)\n==================\n\n- make wadllib aware of the <option> tags that go beneath <param> tags.\n\n1.1 (2009-07-09)\n================\n\n- make wadllib capable of recognizing and generating\n  multipart/form-data representations, including representations that\n  incorporate binary parameters.\n\n\n1.0 (2009-03-23)\n================\n\n- initial release on pypi",
  "docs_url": null,
  "keywords": "",
  "license": "lgpl v3",
  "name": "wadllib",
  "package_url": "https://pypi.org/project/wadllib/",
  "project_url": "https://pypi.org/project/wadllib/",
  "project_urls": {
    "Download": "https://launchpad.net/wadllib/+download",
    "Homepage": "https://launchpad.net/wadllib"
  },
  "release_url": "https://pypi.org/project/wadllib/1.3.6/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "navigate http resources using wadl files as guides.",
  "version": "1.3.6",
  "releases": [],
  "developers": [
    "lazr-developers@lists.launchpad.net",
    "lazr_developers"
  ],
  "kwds": "binary_wadl wadl_string wadllib option_wadl wadl_stream",
  "license_kwds": "lgpl v3",
  "libtype": "pypi",
  "id": "pypi_wadllib",
  "homepage": "https://launchpad.net/wadllib",
  "release_count": 18,
  "dependency_ids": []
}