{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "# messagepack for python\n\n[![build status](https://github.com/msgpack/msgpack-python/actions/workflows/wheel.yml/badge.svg)](https://github.com/msgpack/msgpack-python/actions/workflows/wheel.yml)\n[![documentation status](https://readthedocs.org/projects/msgpack-python/badge/?version=latest)](https://msgpack-python.readthedocs.io/en/latest/?badge=latest)\n\n## what's this\n\n[messagepack](https://msgpack.org/) is an efficient binary serialization format.\nit lets you exchange data among multiple languages like json.\nbut it's faster and smaller.\nthis package provides cpython bindings for reading and writing messagepack data.\n\n\n## very important notes for existing users\n\n### pypi package name\n\npackage name on pypi was changed from `msgpack-python` to `msgpack` from 0.5.\n\nwhen upgrading from msgpack-0.4 or earlier, do `pip uninstall msgpack-python` before\n`pip install -u msgpack`.\n\n\n### compatibility with the old format\n\nyou can use `use_bin_type=false` option to pack `bytes`\nobject into raw type in the old msgpack spec, instead of bin type in new msgpack spec.\n\nyou can unpack old msgpack format using `raw=true` option.\nit unpacks str (raw) type in msgpack into python bytes.\n\nsee note below for detail.\n\n\n### major breaking changes in msgpack 1.0\n\n* python 2\n\n  * the extension module does not support python 2 anymore.\n    the pure python implementation (`msgpack.fallback`) is used for python 2.\n\n* packer\n\n  * `use_bin_type=true` by default.  bytes are encoded in bin type in msgpack.\n    **if you are still using python 2, you must use unicode for all string types.**\n    you can use `use_bin_type=false` to encode into old msgpack format.\n  * `encoding` option is removed.  utf-8 is used always.\n\n* unpacker\n\n  * `raw=false` by default.  it assumes str types are valid utf-8 string\n    and decode them to python str (unicode) object.\n  * `encoding` option is removed.  you can use `raw=true` to support old format.\n  * default value of `max_buffer_size` is changed from 0 to 100 mib.\n  * default value of `strict_map_key` is changed to true to avoid hashdos.\n    you need to pass `strict_map_key=false` if you have data which contain map keys\n    which type is not bytes or str.\n\n\n## install\n\n```\n$ pip install msgpack\n```\n\n### pure python implementation\n\nthe extension module in msgpack (`msgpack._cmsgpack`) does not support\npython 2 and pypy.\n\nbut msgpack provides a pure python implementation (`msgpack.fallback`)\nfor pypy and python 2.\n\n\n\n### windows\n\nwhen you can't use a binary distribution, you need to install visual studio\nor windows sdk on windows.\nwithout extension, using pure python implementation on cpython runs slowly.\n\n\n## how to use\n\nnote: in examples below, i use `raw=false` and `use_bin_type=true` for users\nusing msgpack < 1.0. these options are default from msgpack 1.0 so you can omit them.\n\n\n### one-shot pack & unpack\n\nuse `packb` for packing and `unpackb` for unpacking.\nmsgpack provides `dumps` and `loads` as an alias for compatibility with\n`json` and `pickle`.\n\n`pack` and `dump` packs to a file-like object.\n`unpack` and `load` unpacks from a file-like object.\n\n```pycon\n>>> import msgpack\n>>> msgpack.packb([1, 2, 3], use_bin_type=true)\n'\\x93\\x01\\x02\\x03'\n>>> msgpack.unpackb(_, raw=false)\n[1, 2, 3]\n```\n\n`unpack` unpacks msgpack's array to python's list, but can also unpack to tuple:\n\n```pycon\n>>> msgpack.unpackb(b'\\x93\\x01\\x02\\x03', use_list=false, raw=false)\n(1, 2, 3)\n```\n\nyou should always specify the `use_list` keyword argument for backward compatibility.\nsee performance issues relating to `use_list option`_ below.\n\nread the docstring for other options.\n\n\n### streaming unpacking\n\n`unpacker` is a \"streaming unpacker\". it unpacks multiple objects from one\nstream (or from bytes provided through its `feed` method).\n\n```py\nimport msgpack\nfrom io import bytesio\n\nbuf = bytesio()\nfor i in range(100):\n   buf.write(msgpack.packb(i, use_bin_type=true))\n\nbuf.seek(0)\n\nunpacker = msgpack.unpacker(buf, raw=false)\nfor unpacked in unpacker:\n    print(unpacked)\n```\n\n\n### packing/unpacking of custom data type\n\nit is also possible to pack/unpack custom data types. here is an example for\n`datetime.datetime`.\n\n```py\nimport datetime\nimport msgpack\n\nuseful_dict = {\n    \"id\": 1,\n    \"created\": datetime.datetime.now(),\n}\n\ndef decode_datetime(obj):\n    if '__datetime__' in obj:\n        obj = datetime.datetime.strptime(obj[\"as_str\"], \"%y%m%dt%h:%m:%s.%f\")\n    return obj\n\ndef encode_datetime(obj):\n    if isinstance(obj, datetime.datetime):\n        return {'__datetime__': true, 'as_str': obj.strftime(\"%y%m%dt%h:%m:%s.%f\")}\n    return obj\n\n\npacked_dict = msgpack.packb(useful_dict, default=encode_datetime, use_bin_type=true)\nthis_dict_again = msgpack.unpackb(packed_dict, object_hook=decode_datetime, raw=false)\n```\n\n`unpacker`'s `object_hook` callback receives a dict; the\n`object_pairs_hook` callback may instead be used to receive a list of\nkey-value pairs.\n\n\n### extended types\n\nit is also possible to pack/unpack custom data types using the **ext** type.\n\n```pycon\n>>> import msgpack\n>>> import array\n>>> def default(obj):\n...     if isinstance(obj, array.array) and obj.typecode == 'd':\n...         return msgpack.exttype(42, obj.tostring())\n...     raise typeerror(\"unknown type: %r\" % (obj,))\n...\n>>> def ext_hook(code, data):\n...     if code == 42:\n...         a = array.array('d')\n...         a.fromstring(data)\n...         return a\n...     return exttype(code, data)\n...\n>>> data = array.array('d', [1.2, 3.4])\n>>> packed = msgpack.packb(data, default=default, use_bin_type=true)\n>>> unpacked = msgpack.unpackb(packed, ext_hook=ext_hook, raw=false)\n>>> data == unpacked\ntrue\n```\n\n\n### advanced unpacking control\n\nas an alternative to iteration, `unpacker` objects provide `unpack`,\n`skip`, `read_array_header` and `read_map_header` methods. the former two\nread an entire message from the stream, respectively de-serialising and returning\nthe result, or ignoring it. the latter two methods return the number of elements\nin the upcoming container, so that each element in an array, or key-value pair\nin a map, can be unpacked or skipped individually.\n\n\n## notes\n\n### string and binary type\n\nearly versions of msgpack didn't distinguish string and binary types.\nthe type for representing both string and binary types was named **raw**.\n\nyou can pack into and unpack from this old spec using `use_bin_type=false`\nand `raw=true` options.\n\n```pycon\n>>> import msgpack\n>>> msgpack.unpackb(msgpack.packb([b'spam', 'eggs'], use_bin_type=false), raw=true)\n[b'spam', b'eggs']\n>>> msgpack.unpackb(msgpack.packb([b'spam', 'eggs'], use_bin_type=true), raw=false)\n[b'spam', 'eggs']\n```\n\n### ext type\n\nto use the **ext** type, pass `msgpack.exttype` object to packer.\n\n```pycon\n>>> import msgpack\n>>> packed = msgpack.packb(msgpack.exttype(42, b'xyzzy'))\n>>> msgpack.unpackb(packed)\nexttype(code=42, data='xyzzy')\n```\n\nyou can use it with `default` and `ext_hook`. see below.\n\n\n### security\n\nto unpacking data received from unreliable source, msgpack provides\ntwo security options.\n\n`max_buffer_size` (default: `100*1024*1024`) limits the internal buffer size.\nit is used to limit the preallocated list size too.\n\n`strict_map_key` (default: `true`) limits the type of map keys to bytes and str.\nwhile msgpack spec doesn't limit the types of the map keys,\nthere is a risk of the hashdos.\nif you need to support other types for map keys, use `strict_map_key=false`.\n\n\n### performance tips\n\ncpython's gc starts when growing allocated object.\nthis means unpacking may cause useless gc.\nyou can use `gc.disable()` when unpacking large message.\n\nlist is the default sequence type of python.\nbut tuple is lighter than list.\nyou can use `use_list=false` while unpacking when performance is important.\n",
  "docs_url": null,
  "keywords": "msgpack,messagepack,serializer,serialization,binary",
  "license": "apache 2.0",
  "name": "msgpack",
  "package_url": "https://pypi.org/project/msgpack/",
  "project_url": "https://pypi.org/project/msgpack/",
  "project_urls": {
    "Changelog": "https://github.com/msgpack/msgpack-python/blob/main/ChangeLog.rst",
    "Documentation": "https://msgpack-python.readthedocs.io/",
    "Homepage": "https://msgpack.org/",
    "Repository": "https://github.com/msgpack/msgpack-python/",
    "Tracker": "https://github.com/msgpack/msgpack-python/issues"
  },
  "release_url": "https://pypi.org/project/msgpack/1.0.7/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "messagepack serializer",
  "version": "1.0.7",
  "releases": [],
  "developers": [
    "songofacandy@gmail.com"
  ],
  "kwds": "msgpack messagepack _cmsgpack python packed_dict",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_msgpack",
  "homepage": "",
  "release_count": 23,
  "dependency_ids": []
}