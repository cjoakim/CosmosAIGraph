{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "topic :: software development",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "===============================\nxmljson\n===============================\n\n.. image:: https://img.shields.io/travis/sanand0/xmljson.svg\n        :target: https://travis-ci.org/sanand0/xmljson\n\n.. image:: https://img.shields.io/pypi/v/xmljson.svg\n        :target: https://pypi.python.org/pypi/xmljson\n\nthis library is not actively maintained. alternatives are `xmltodict`_ and `untangle`_.\nuse only if you need to parse using specific xml to json `conventions`_.\n\n.. _conventions: http://wiki.open311.org/json_and_xml_conversion/\n.. _xmltodict: https://github.com/martinblech/xmltodict\n.. _untangle: https://untangle.readthedocs.io/en/latest/\n\nxmljson converts xml into python dictionary structures (trees, like in json) and vice-versa.\n\nabout\n-----\n\nxml can be converted to a data structure (such as json) and back. for example::\n\n    <employees>\n        <person>\n            <name value=\"alice\"/>\n        </person>\n        <person>\n            <name value=\"bob\"/>\n        </person>\n    </employees>\n\ncan be converted into this data structure (which also a valid json object)::\n\n    {\n        \"employees\": [{\n            \"person\": {\n                \"name\": {\n                    \"@value\": \"alice\"\n                }\n            }\n        }, {\n            \"person\": {\n                \"name\": {\n                    \"@value\": \"bob\"\n                }\n            }\n        }]\n    }\n\nthis uses the `badgerfish`_ convention that prefixes attributes with ``@``.\nthe conventions supported by this library are:\n\n* `abdera`_: use ``\"attributes\"`` for attributes, ``\"children\"`` for nodes\n* `badgerfish`_: use ``\"$\"`` for text content, ``@`` to prefix attributes\n* `cobra`_: use ``\"attributes\"`` for sorted attributes (even when empty), ``\"children\"`` for nodes, values are strings\n* `gdata`_: use ``\"$t\"`` for text content, attributes added as-is\n* `parker`_: use tail nodes for text content, ignore attributes\n* `yahoo`_ use ``\"content\"`` for text content, attributes added as-is\n\n.. _abdera: http://wiki.open311.org/json_and_xml_conversion/#the-abdera-convention\n.. _badgerfish: http://www.sklar.com/badgerfish/\n.. _cobra: http://wiki.open311.org/json_and_xml_conversion/#the-cobra-convention\n.. _gdata: http://wiki.open311.org/json_and_xml_conversion/#the-gdata-convention\n.. _parker: https://developer.mozilla.org/en-us/docs/jxon#the_parker_convention\n.. _yahoo: https://developer.yahoo.com/javascript/json.html#xml\n\n\nconvert data to xml\n-------------------\n\nto convert from a data structure to xml using the badgerfish convention::\n\n    >>> from xmljson import badgerfish as bf\n    >>> bf.etree({'p': {'@id': 'main', '$': 'hello', 'b': 'bold'}})\n\nthis returns an **array** of `etree.element`_ structures. in this case, the\nresult is identical to::\n\n    >>> from xml.etree.elementtree import fromstring\n    >>> [fromstring('<p id=\"main\">hello<b>bold</b></p>')]\n\n.. _etree.element: http://effbot.org/zone/element-index.htm\n\nthe result can be inserted into any existing root `etree.element`_::\n\n    >>> from xml.etree.elementtree import element, tostring\n    >>> result = bf.etree({'p': {'@id': 'main'}}, root=element('root'))\n    >>> tostring(result)\n    '<root><p id=\"main\"/></root>'\n\nthis includes `lxml.html <http://lxml.de/lxmlhtml.html>`_ as well::\n\n    >>> from lxml.html import element, tostring\n    >>> result = bf.etree({'p': {'@id': 'main'}}, root=element('html'))\n    >>> tostring(result, doctype='<!doctype html>')\n    '<!doctype html>\\n<html><p id=\"main\"></p></html>'\n\nfor ease of use, strings are treated as node text. for example, both the\nfollowing are the same::\n\n    >>> bf.etree({'p': {'$': 'paragraph text'}})\n    >>> bf.etree({'p': 'paragraph text'})\n\nby default, non-string values are converted to strings using python's ``str``,\nexcept for booleans -- which are converted into ``true`` and ``false`` (lower\ncase). override this behaviour using ``xml_fromstring``::\n\n    >>> tostring(bf.etree({'x': 1.23, 'y': true}, root=element('root')))\n    '<root><y>true</y><x>1.23</x></root>'\n    >>> from xmljson import badgerfish              # import the class\n    >>> bf_str = badgerfish(xml_tostring=str)       # convert using str()\n    >>> tostring(bf_str.etree({'x': 1.23, 'y': true}, root=element('root')))\n    '<root><y>true</y><x>1.23</x></root>'\n\nif the data contains invalid xml keys, these can be dropped via\n``invalid_tags='drop'`` in the constructor::\n\n    >>> bf_drop = badgerfish(invalid_tags='drop')\n    >>> data = bf_drop.etree({'$': '1', 'x': '1'}, root=element('root'))    # drops invalid <$> tag\n    >>> tostring(data)\n    '<root>1<x>1</x></root>'\n\n\nconvert xml to data\n-------------------\n\nto convert from xml to a data structure using the badgerfish convention::\n\n    >>> bf.data(fromstring('<p id=\"main\">hello<b>bold</b></p>'))\n    {\"p\": {\"$\": \"hello\", \"@id\": \"main\", \"b\": {\"$\": \"bold\"}}}\n\nto convert this to json, use::\n\n    >>> from json import dumps\n    >>> dumps(bf.data(fromstring('<p id=\"main\">hello<b>bold</b></p>')))\n    '{\"p\": {\"b\": {\"$\": \"bold\"}, \"@id\": \"main\", \"$\": \"hello\"}}'\n\nto preserve the order of attributes and children, specify the ``dict_type`` as\n``ordereddict`` (or any other dictionary-like type) in the constructor::\n\n    >>> from collections import ordereddict\n    >>> from xmljson import badgerfish              # import the class\n    >>> bf = badgerfish(dict_type=ordereddict)      # pick dict class\n\nby default, values are parsed into boolean, int or float where possible (except\nin the yahoo method). override this behaviour using ``xml_fromstring``::\n\n    >>> dumps(bf.data(fromstring('<x>1</x>')))\n    '{\"x\": {\"$\": 1}}'\n    >>> bf_str = badgerfish(xml_fromstring=false)   # keep xml values as strings\n    >>> dumps(bf_str.data(fromstring('<x>1</x>')))\n    '{\"x\": {\"$\": \"1\"}}'\n    >>> bf_str = badgerfish(xml_fromstring=repr)    # custom string parser\n    '{\"x\": {\"$\": \"\\'1\\'\"}}'\n\n``xml_fromstring`` can be any custom function that takes a string and returns a\nvalue. in the example below, only the integer ``1`` is converted to an integer.\neverything else is retained as a float::\n\n    >>> def convert_only_int(val):\n    ...     return int(val) if val.isdigit() else val\n    >>> bf_int = badgerfish(xml_fromstring=convert_only_int)\n    >>> dumps(bf_int.data(fromstring('<p><x>1</x><y>2.5</y><z>nan</z></p>')))\n    '{\"p\": {\"x\": {\"$\": 1}, \"y\": {\"$\": \"2.5\"}, \"z\": {\"$\": \"nan\"}}}'\n\n\nconventions\n-----------\n\nto use a different conversion method, replace ``badgerfish`` with one of the\nother classes. currently, these are supported::\n\n    >>> from xmljson import abdera          # == xmljson.abdera()\n    >>> from xmljson import badgerfish      # == xmljson.badgerfish()\n    >>> from xmljson import cobra           # == xmljson.cobra()\n    >>> from xmljson import gdata           # == xmljson.gdata()\n    >>> from xmljson import parker          # == xmljson.parker()\n    >>> from xmljson import yahoo           # == xmljson.yahoo()\n\n\noptions\n-------\n\nconventions may support additional options.\n\nthe `parker`_ convention absorbs the root element by default.\n``parker.data(preserve_root=true)`` preserves the root instance::\n\n    >>> from xmljson import parker, parker\n    >>> from xml.etree.elementtree import fromstring\n    >>> from json import dumps\n    >>> dumps(parker.data(fromstring('<x><a>1</a><b>2</b></x>')))\n    '{\"a\": 1, \"b\": 2}'\n    >>> dumps(parker.data(fromstring('<x><a>1</a><b>2</b></x>'), preserve_root=true))\n    '{\"x\": {\"a\": 1, \"b\": 2}}'\n\n\ninstallation\n------------\n\nthis is a pure-python package built for python 2.7+ and python 3.0+. to set up::\n\n    pip install xmljson\n\n\nsimple cli utility\n------------------\n\nafter installation, you can benefit from using this package as simple cli utility. by now only xml to json conversion supported. example::\n\n    $ python -m xmljson -h\n    usage: xmljson [-h] [-o out_file]\n                [-d {abdera,badgerfish,cobra,gdata,parker,xmldata,yahoo}]\n                [in_file]\n\n    positional arguments:\n    in_file               defaults to stdin\n\n    optional arguments:\n    -h, --help            show this help message and exit\n    -o out_file, --out_file out_file\n                            defaults to stdout\n    -d {abdera,badgerfish,...}, --dialect {...}\n                            defaults to parker\n\n    $ python -m xmljson -d parker tests/mydata.xml\n    {\n      \"foo\": \"spam\",\n      \"bar\": 42\n    }\n\nthis is a typical unix filter program: it reads file (or ``stdin``), processes it in some way (convert xml to json in this case), then prints it to ``stdout`` (or file). example with pipe::\n\n    $ some-xml-producer | python -m xmljson | some-json-processor\n\nthere is also ``pip``'s ``console_script`` entry-point, you can call this utility as ``xml2json``::\n\n    $ xml2json -d abdera mydata.xml\n\nroadmap\n-------\n\n* test cases for unicode\n* support for namespaces and namespace prefixes\n* support xml comments\n\n\n\n\nhistory\n-------\n0.2.1 (25 apr 2020)\n~~~~~~~~~~~~~~~~~~~~~\n\n- bugfix: don't strip whitespace in xml text values (@imoore76)\n- bugfix: yahoo convention should convert ``<x>0</x>`` into ``{x: 0}``. empty elements become ``''`` not ``{}``\n- suggest alternate libraries in documentation\n\n\n0.2.0 (21 nov 2018)\n~~~~~~~~~~~~~~~~~~~~~\n- ``xmljson`` command line script converts from xml to json (@tribals)\n- ``invalid_tags='drop'`` in the constructor drops invalid xml tags in ``.etree()`` (@zurga)\n- bugfix: parker converts ``{'x': null}`` to ``<x></x>`` instead of ``<x>none</x>`` (@jorndoe #29)\n\n0.1.9 (1 aug 2017)\n~~~~~~~~~~~~~~~~~~\n\n- bugfix and test cases for multiple nested children in abdera_ convention\n\nthanks to @mukultaneja\n\n0.1.8 (9 may 2017)\n~~~~~~~~~~~~~~~~~~\n\n- add abdera_ and cobra_ conventions\n- add ``parker.data(preserve_root=true)`` option to preserve root element in\n  parker convention.\n\nthanks to @dagwieers\n\n.. _abdera: http://wiki.open311.org/json_and_xml_conversion/#the-abdera-convention\n.. _cobra: http://wiki.open311.org/json_and_xml_conversion/#the-cobra-convention\n\n0.1.6 (18 feb 2016)\n~~~~~~~~~~~~~~~~~~~\n\n- add ``xml_fromstring=`` and ``xml_tostring=`` parameters to constructor to\n  customise string conversion from and to xml.\n\n\n0.1.5 (23 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- add the yahoo_ xml to json conversion method.\n\n.. _yahoo: https://developer.yahoo.com/javascript/json.html#xml\n\n0.1.4 (20 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- fix ``gdata.etree()`` conversion of attributes. (they were ignored. they\n  should be added as-is.)\n\n0.1.3 (20 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- simplify ``{'p': {'$': 'text'}}`` to ``{'p': 'text'}`` in badgerfish and gdata\n  conventions.\n- add test cases for ``.etree()`` -- mainly from the `mdn jxon article`_.\n- ``dict_type``/``list_type`` do not need to inherit from ``dict``/``list``\n\n.. _mdn jxon article: https://developer.mozilla.org/en-us/docs/jxon#in_summary\n\n0.1.2 (18 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- always use the ``dict_type`` class to create dictionaries (which defaults to\n  ``ordereddict`` to preserve order of keys)\n- update documentation, test cases\n- remove support for python 2.6 (since we need ``collections.counter``)\n- make the `travis ci build`_ pass\n\n.. _travis ci build: https://travis-ci.org/sanand0/xmljson\n\n0.1.1 (18 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- convert ``true``, ``false`` and numeric values from strings to python types\n- ``xmljson.parker.data()`` is compliant with parker convention (bugs resolved)\n\n0.1.0 (15 sep 2015)\n~~~~~~~~~~~~~~~~~~~\n\n- two-way conversions via badgerfish, gdata and parker conventions.\n- first release on pypi.\n\n\n",
  "docs_url": null,
  "keywords": "xmljson",
  "license": "mit",
  "name": "xmljson",
  "package_url": "https://pypi.org/project/xmljson/",
  "project_url": "https://pypi.org/project/xmljson/",
  "project_urls": {
    "Homepage": "https://github.com/sanand0/xmljson"
  },
  "release_url": "https://pypi.org/project/xmljson/0.2.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "converts xml into json/python dicts/arrays and vice-versa.",
  "version": "0.2.1",
  "releases": [],
  "developers": [
    "root.node@gmail.com",
    "s_anand"
  ],
  "kwds": "xmljson xml2json json_and_xml_conversion _xmltodict xmltodict",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_xmljson",
  "homepage": "https://github.com/sanand0/xmljson",
  "release_count": 12,
  "dependency_ids": []
}