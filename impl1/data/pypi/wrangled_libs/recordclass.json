{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: information technology",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# recordclass library\r\n\r\n**recordclass** is [mit licensed](http://opensource.org/licenses/mit) python library.\r\nit was started as a \"proof of concept\" for the problem of fast \"mutable\"\r\nalternative of `namedtuple` (see [question](https://stackoverflow.com/questions/29290359/existence-of-mutable-named-tuple-in-python) on [stackoverflow](https://stackoverflow.com)).\r\nit was evolved further in order to provide more memory saving, fast and flexible types.\r\n\r\n**recordclass** library provide record/data-like classes that do not participate in cyclic *garbage collection* (gc) mechanism by default, but support only *reference counting* for garbage collection.\r\nthe instances of such classes havn't `pygc_head` prefix in the memory, which decrease their size and have a little faster path for the instance creation and deallocation.\r\nthis may make sense in cases where it is necessary to limit the size of the objects as much as possible, provided that they will never be part of references cycles in the application.\r\nfor example, when an object represents a record with fields with values of simple types by convention (`int`, `float`, `str`, `date`/`time`/`datetime`, `timedelta`, etc.).\r\n\r\nin order to illustrate this, consider a simple class with type hints:\r\n\r\n    class point:\r\n        x: int\r\n        y: int\r\n\r\nby tacit agreement instances of the class `point` is supposed to have attributes `x` and `y` with values of `int` type. assigning other types of values, which are not subclass of `int`, should be considered as a violation of the agreement.\r\n\r\nother examples are non-recursive data structures in which all leaf elements represent a value of an atomic type.\r\nof course, in python, nothing prevent you from \u201cshooting yourself in the foot\" by creating the reference cycle in the script or application code.\r\nbut in many cases, this can still be avoided provided that the developer understands what he is doing and uses such classes in the codebase with care.\r\nanother option is to use static code analyzers along with type annotations to monitor compliance with typehints.\r\n\r\nthe library is built on top of the base class `dataobject`. the type of `dataobject` is special metaclass `datatype`.\r\n   it control creation  of subclasses, which  will not participate in cyclic gc and do not contain `pygc_head`-prefix, `__dict__`  and `__weakref__`  by default.\r\n   as the result the instance of such class need less memory.\r\n   it's memory footprint is similar to memory footprint of instances of the classes with `__slots__` but without `pygc_head`. so the difference in memory size is equal to the size of `pygc_head`.\r\n   it also tunes `basicsize` of the instances, creates descriptors for the fields and etc.\r\n   all subclasses of `dataobject` created by `class statement` support `attrs`/`dataclasses`-like api.\r\n   for example:\r\n\r\n        from recordclass import dataobject, astuple, asdict\r\n        class point(dataobject):\r\n            x:int\r\n            y:int\r\n\r\n        >>> p = point(1, 2)\r\n        >>> astuple(p)\r\n        (1, 2)\r\n        >>> asdict(p)\r\n        {'x':1, 'y':2}\r\n\r\nthe `recordclass` factory create dataobject-based subclass with specified fields and the support of `namedtuple`-like api.\r\n   by default it will not participate in cyclic gc too.\r\n\r\n        >>> from recordclass import recordclass\r\n        >>> point = recordclass('point', 'x y')\r\n        >>> p = point(1, 2)\r\n        >>> p.y = -1\r\n        >>> print(p._astuple)\r\n        (1, -1)\r\n        >>> x, y = p\r\n        >>> print(p._asdict)\r\n        {'x':1, 'y':-1}\r\n\r\nit also provide a factory function `make_dataclass` for creation of subclasses of `dataobject` with the specified field names.\r\n   these subclasses support `attrs`/`dataclasses`-like api. it's equivalent to creating subclasses of dataobject using `class statement`.\r\n   for example:\r\n\r\n        >>> point = make_dataclass('point', 'x y')\r\n        >>> p = point(1, 2)\r\n        >>> p.y = -1\r\n        >>> print(p.x, p.y)\r\n        1 -1\r\n\r\n   if one want to use some sequence for initialization then:\r\n\r\n        >>> p = point(*sequence)\r\n\r\n\r\nthere is also a factory function `make_arrayclass` for creation of the subclass of `dataobject`, which can be considered as a compact array of simple objects.\r\n   for example:\r\n\r\n        >>> pair = make_arrayclass(2)\r\n        >>> p = pair(2, 3)\r\n        >>> p[1] = -1\r\n        >>> print(p)\r\n        pair(2, -1)\r\n\r\nthe library provide in addition the classes `lightlist` (immutable) and `litetuple`, which considers as list-like and tuple-like *light* containers in order to save memory. they do not supposed to participate in cyclic gc too. mutable variant of litetuple is called by `mutabletuple`.\r\n    for example:\r\n\r\n        >>> lt = litetuple(1, 2, 3)\r\n        >>> mt = mutabletuple(1, 2, 3)\r\n        >>> lt == mt\r\n        true\r\n        >>> mt[-1] = -3\r\n        >>> lt == mt\r\n        false\r\n        >>> print(sys.getsizeof((1,2,3)), sys.getsizeof(litetuple(1,2,3)))\r\n        64 48\r\n\r\nnote if one like create `litetuple` or `mutabletuple` from some iterable then:\r\n\r\n        >>> seq = [1,2,3]\r\n        >>> lt = litetuple(*seq)\r\n        >>> mt = mutabletuple(*seq)\r\n\r\n### memory footprint\r\n\r\nthe following table explain memory footprints of the  `dataobject`-based objects and litetuples:\r\n\r\n<table border=\"1\" class=\"dataframe\">\r\n  <thead>\r\n    <tr style=\"text-align: right;\">\r\n      <th>tuple/namedtuple</th>\r\n      <th>class with __slots__</th>\r\n      <th>recordclass/dataobject</th>\r\n      <th>litetuple/mutabletuple</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td>g+b+s+n&times;p</td>\r\n      <td>g+b+n&times;p</td>\r\n      <td>b+n&times;p</td>\r\n      <td>b+s+n&times;p</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\nwhere:\r\n\r\n * b = sizeof(pyobject)\r\n * s = sizeof(py_ssize_t)\r\n * n = number of items\r\n * p = sizeof(pyobject*)\r\n * g = sizeof(pygc_head)\r\n\r\nthis is useful in that case when you absolutely sure that reference cycle isn't supposed.\r\nfor example, when all field values are instances of atomic types.\r\nas a result the size of the instance is decreased by 24-32 bytes for cpython 3.4-3.7 and by 16 bytes for cpython >=3.8.\r\n\r\n### performance counters\r\n\r\nhere is the table with performance counters, which was measured using `tools/perfcounts.py` script:\r\n\r\n* recordclass 0.21, python 3.10, debian/testing linux, x86-64:\r\n\r\n<table border=\"1\" class=\"dataframe\">\r\n  <thead>\r\n    <tr style=\"text-align: right;\">\r\n      <th>id</th>\r\n      <th>size</th>\r\n      <th>new</th>\r\n      <th>getattr</th>\r\n      <th>setattr</th>\r\n      <th>getitem</th>\r\n      <th>setitem</th>\r\n      <th>getkey</th>\r\n      <th>setkey</th>\r\n      <th>iterate</th>\r\n      <th>copy</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td>litetuple</td>\r\n      <td>48</td>\r\n      <td>0.18</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.2</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.33</td>\r\n      <td>0.19</td>\r\n    </tr>\r\n    <tr>\r\n      <td>mutabletuple</td>\r\n      <td>48</td>\r\n      <td>0.18</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.21</td>\r\n      <td>0.21</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.33</td>\r\n      <td>0.18</td>\r\n    </tr>\r\n    <tr>\r\n      <td>tuple</td>\r\n      <td>64</td>\r\n      <td>0.24</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.21</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.37</td>\r\n      <td>0.16</td>\r\n    </tr>\r\n    <tr>\r\n      <td>namedtuple</td>\r\n      <td>64</td>\r\n      <td>0.75</td>\r\n      <td>0.23</td>\r\n      <td></td>\r\n      <td>0.21</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.33</td>\r\n      <td>0.21</td>\r\n    </tr>\r\n    <tr>\r\n      <td>class+slots</td>\r\n      <td>56</td>\r\n      <td>0.68</td>\r\n      <td>0.29</td>\r\n      <td>0.33</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n    </tr>\r\n    <tr>\r\n      <td>dataobject</td>\r\n      <td>40</td>\r\n      <td>0.25</td>\r\n      <td>0.23</td>\r\n      <td>0.29</td>\r\n      <td>0.2</td>\r\n      <td>0.22</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.33</td>\r\n      <td>0.2</td>\r\n    </tr>\r\n    <tr>\r\n      <td>dataobject+gc</td>\r\n      <td>56</td>\r\n      <td>0.27</td>\r\n      <td>0.22</td>\r\n      <td>0.29</td>\r\n      <td>0.19</td>\r\n      <td>0.21</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.35</td>\r\n      <td>0.22</td>\r\n    </tr>\r\n    <tr>\r\n      <td>dict</td>\r\n      <td>232</td>\r\n      <td>0.32</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.2</td>\r\n      <td>0.24</td>\r\n      <td>0.35</td>\r\n      <td>0.25</td>\r\n    </tr>\r\n    <tr>\r\n      <td>dataobject+map</td>\r\n      <td>40</td>\r\n      <td>0.25</td>\r\n      <td>0.23</td>\r\n      <td>0.3</td>\r\n      <td></td>\r\n      <td></td>\r\n      <td>0.29</td>\r\n      <td>0.29</td>\r\n      <td>0.32</td>\r\n      <td>0.2</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n* recordclass 0.21, python 3.11, debian/testing linux, x86-64:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>id</th>\r\n            <th>size</th>\r\n            <th>new</th>\r\n            <th>getattr</th>\r\n            <th>setattr</th>\r\n            <th>getitem</th>\r\n            <th>setitem</th>\r\n            <th>getkey</th>\r\n            <th>setkey</th>\r\n            <th>iterate</th>\r\n            <th>copy</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>litetuple</td>\r\n            <td>48</td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.18</td>\r\n            <td>0.09</td>\r\n        </tr>\r\n        <tr>\r\n            <td>mutabletuple</td>\r\n            <td>48</td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.18</td>\r\n            <td>0.08</td>\r\n        </tr>\r\n        <tr>\r\n            <td>tuple</td>\r\n            <td>64</td>\r\n            <td>0.1</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.08</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.17</td>\r\n            <td>0.1</td>\r\n        </tr>\r\n        <tr>\r\n            <td>namedtuple</td>\r\n            <td>64</td>\r\n            <td>0.49</td>\r\n            <td>0.13</td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.17</td>\r\n            <td>0.13</td>\r\n        </tr>\r\n        <tr>\r\n            <td>class+slots</td>\r\n            <td>56</td>\r\n            <td>0.31</td>\r\n            <td>0.06</td>\r\n            <td>0.06</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject</td>\r\n            <td>40</td>\r\n            <td>0.13</td>\r\n            <td>0.06</td>\r\n            <td>0.06</td>\r\n            <td>0.11</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.16</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject+gc</td>\r\n            <td>56</td>\r\n            <td>0.14</td>\r\n            <td>0.06</td>\r\n            <td>0.06</td>\r\n            <td>0.1</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.16</td>\r\n            <td>0.14</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dict</td>\r\n            <td>184</td>\r\n            <td>0.2</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.12</td>\r\n            <td>0.13</td>\r\n            <td>0.19</td>\r\n            <td>0.13</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject+map</td>\r\n            <td>40</td>\r\n            <td>0.12</td>\r\n            <td>0.07</td>\r\n            <td>0.06</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.15</td>\r\n            <td>0.16</td>\r\n            <td>0.16</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>class</td>\r\n            <td>56</td>\r\n            <td>0.35</td>\r\n            <td>0.06</td>\r\n            <td>0.06</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n* recordclas 0.21, python3.12, debian/testing linux, x86-64:\r\n\r\n<table>\r\n    <thead>\r\n        <tr>\r\n            <th>id</th>\r\n            <th>size</th>\r\n            <th>new</th>\r\n            <th>getattr</th>\r\n            <th>setattr</th>\r\n            <th>getitem</th>\r\n            <th>setitem</th>\r\n            <th>getkey</th>\r\n            <th>setkey</th>\r\n            <th>iterate</th>\r\n            <th>copy</th>\r\n        </tr>\r\n    </thead>\r\n    <tbody>\r\n        <tr>\r\n            <td>litetuple</td>\r\n            <td>48</td>\r\n            <td>0.13</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.19</td>\r\n            <td>0.09</td>\r\n        </tr>\r\n        <tr>\r\n            <td>mutabletuple</td>\r\n            <td>48</td>\r\n            <td>0.13</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.18</td>\r\n            <td>0.09</td>\r\n        </tr>\r\n        <tr>\r\n            <td>tuple</td>\r\n            <td>64</td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.09</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.16</td>\r\n            <td>0.09</td>\r\n        </tr>\r\n        <tr>\r\n            <td>namedtuple</td>\r\n            <td>64</td>\r\n            <td>0.52</td>\r\n            <td>0.13</td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.16</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>class+slots</td>\r\n            <td>56</td>\r\n            <td>0.34</td>\r\n            <td>0.08</td>\r\n            <td>0.07</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject</td>\r\n            <td>40</td>\r\n            <td>0.14</td>\r\n            <td>0.08</td>\r\n            <td>0.08</td>\r\n            <td>0.11</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.17</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject+gc</td>\r\n            <td>56</td>\r\n            <td>0.15</td>\r\n            <td>0.08</td>\r\n            <td>0.07</td>\r\n            <td>0.12</td>\r\n            <td>0.12</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.17</td>\r\n            <td>0.13</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dict</td>\r\n            <td>184</td>\r\n            <td>0.19</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.11</td>\r\n            <td>0.14</td>\r\n            <td>0.2</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>dataobject+map</td>\r\n            <td>40</td>\r\n            <td>0.14</td>\r\n            <td>0.08</td>\r\n            <td>0.08</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td>0.16</td>\r\n            <td>0.17</td>\r\n            <td>0.17</td>\r\n            <td>0.12</td>\r\n        </tr>\r\n        <tr>\r\n            <td>class</td>\r\n            <td>48</td>\r\n            <td>0.41</td>\r\n            <td>0.08</td>\r\n            <td>0.08</td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n            <td> </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\n\r\nmain repository for `recordclass` is on [github](https://github.com/intellimath/recordclass).\r\n\r\nhere is also a simple [example](https://github.com/intellimath/recordclass/blob/main/examples/what_is_recordclass.ipynb).\r\n\r\nmore examples can be found in the folder [examples](https://github.com/intellimath/recordclass/tree/main/examples).\r\n\r\n## quick start\r\n\r\n### installation\r\n\r\n#### installation from directory with sources\r\n\r\ninstall:\r\n\r\n    >>> python3 setup.py install\r\n\r\nrun tests:\r\n\r\n    >>> python3 test_all.py\r\n\r\n#### installation from pypi\r\n\r\ninstall:\r\n\r\n    >>> pip3 install recordclass\r\n\r\nrun tests:\r\n\r\n    >>> python3 -c \"from recordclass.test import *; test_all()\"\r\n\r\n### quick start with dataobject\r\n\r\n`dataobject` is the base class for creation of data classes with fast instance creation and small memory footprint. they provide `dataclass`-like api.\r\n\r\nfirst load inventory:\r\n\r\n    >>> from recordclass import dataobject, asdict, astuple, as_dataclass, as_record\r\n\r\ndefine class one of the ways:\r\n\r\n    class point(dataobject):\r\n        x: int\r\n        y: int\r\n\r\nor\r\n\r\n    @as_dataclass()\r\n    class point:\r\n        x: int\r\n        y: int\r\n\r\nor\r\n\r\n    @as_record\r\n    def point(x:int, y:int): pass\r\n\r\nor\r\n\r\n    >>> point = make_dataclass(\"point\", [(\"x\",int), (\"y\",int)])\r\n\r\nor\r\n\r\n    >>> point = make_dataclass(\"point\", {\"x\":int, \"y\",int})\r\n\r\nannotations of the fields are defined as a dict in `__annotations__`:\r\n\r\n    >>> print(point.__annotations__)\r\n    {'x': <class 'int'>, 'y': <class 'int'>}\r\n\r\nthere is default text representation:\r\n\r\n    >>> p = point(1, 2)\r\n    >>> print(p)\r\n    point(x=1, y=2)\r\n\r\nthe instances has a minimum memory footprint that is possible for cpython object, which contain only python objects:\r\n\r\n    >>> sys.getsizeof(p) # the output below for python 3.8+ (64bit)\r\n    40\r\n    >>> p.__sizeof__() == sys.getsizeof(p) # no additional space for cyclic gc support\r\n    true\r\n\r\nthe instance is mutable by default:\r\n\r\n    >>> p_id = id(p)\r\n    >>> p.x, p.y = 10, 20\r\n    >>> id(p) == p_id\r\n    true\r\n    >>> print(p)\r\n    point(x=10, y=20)\r\n\r\nthere are functions `asdict` and `astuple` for converting to `dict` and to `tuple`:\r\n\r\n    >>> asdict(p)\r\n    {'x':10, 'y':20}\r\n    >>> astuple(p)\r\n    (10, 20)\r\n\r\nby default subclasses of dataobject are mutable. if one want make it immutable then there is the option `readonly=true`:\r\n\r\n    class point(dataobject, readonly=true):\r\n        x: int\r\n        y: int\r\n\r\n    >>> p = point(1,2)\r\n    >>> p.x = -1\r\n    . . . . . . . . . . . . .\r\n    typeerror: item is readonly\r\n\r\nby default subclasses of dataobject are not iterable by default.\r\nif one want make it iterable then there is the option `iterable=true`:\r\n\r\n    class point(dataobject, iterable=true):\r\n        x: int\r\n        y: int\r\n\r\n    >>> p = point(1,2)\r\n    >>> for x in p: print(x)\r\n    1\r\n    2\r\n\r\ndefault values are also supported::\r\n\r\n    class cpoint(dataobject):\r\n        x: int\r\n        y: int\r\n        color: str = 'white'\r\n\r\nor\r\n\r\n    >>> cpoint = make_dataclass(\"cpoint\", [(\"x\",int), (\"y\",int), (\"color\",str)], defaults=(\"white\",))\r\n\r\n    >>> p = cpoint(1,2)\r\n    >>> print(p)\r\n    point(x=1, y=2, color='white')\r\n\r\nbut\r\n\r\n    class pointinvaliddefaults(dataobject):\r\n        x:int = 0\r\n        y:int\r\n\r\nis not allowed. a fields without default value may not appear after a field with default value.\r\n\r\nthere is an option `copy_default` (starting from 0.21) in order to assign a copy of the default value when creating an instance:\r\n\r\n     class polygon(dataobject, copy_default=true):\r\n        points: list = []\r\n\r\n    >>> pg1 = polygon()\r\n    >>> pg2 = polygon()\r\n    >>> assert pg1.points == pg2.points\r\n    true\r\n    >>> assert id(pg1.points) != id(pg2.points)\r\n    true\r\n\r\na `factory` (starting from 0.21) allows you to setup a factory function to calculate the default value:\r\n\r\n    from recordclass import factory\r\n\r\n    class a(dataobject, copy_default=true):\r\n        x: tuple = factory( lambda: (list(), dict()) )\r\n\r\n    >>> a = a()\r\n    >>> b = a()\r\n    >>> assert a.x == b.x\r\n    true\r\n    >>> assert id(a.x[0]) != id(b.x[0])\r\n    true\r\n    >>> assert id(a.x[1]) != id(b.x[1])\r\n    true\r\n\r\nif someone wants to define a class attribute, then there is a `classvar` trick:\r\n\r\n    class point(dataobject):\r\n        x:int\r\n        y:int\r\n        color:classvar[int] = 0\r\n\r\n    >>> print(point.__fields__)\r\n    ('x', 'y')\r\n    >>> print(point.color)\r\n    0\r\n\r\nif the default value for the `classvar`-attribute is not specified, \r\nit will just be excluded from the `__fields___`.\r\n\r\nstarting with python 3.10 `__match_args__` is specified by default so that `__match_args__` == `__fields`.\r\nuser can define it's own during definition:\r\n\r\n    class user(dataobject):\r\n        first_name: str\r\n        last_name: str\r\n        age: int\r\n        __match_args__ = 'first_name', 'last_name'\r\n\r\nor        \r\n\r\n    from recordclass import match\r\n    class user(dataobject):\r\n        first_name: str\r\n        last_name: str\r\n        _: match\r\n        age: int\r\n\r\nor\r\n\r\n    user = make_dataclass(\"user\", \"first_name last_name * age\")\r\n\r\n### quick start with recordclass\r\n\r\nthe `recordclass` factory function is designed to create classes that support `namedtuple`'s api, can be mutable and immutable, provide fast creation of the instances and have a minimum memory footprint.\r\n\r\nfirst load inventory:\r\n\r\n    >>> from recordclass import recordclass\r\n\r\nexample with `recordclass`:\r\n\r\n    >>> point = recordclass('point', 'x y')\r\n    >>> p = point(1,2)\r\n    >>> print(p)\r\n    point(1, 2)\r\n    >>> print(p.x, p.y)\r\n    1 2\r\n    >>> p.x, p.y = 1, 2\r\n    >>> print(p)\r\n    point(1, 2)\r\n    >>> sys.getsizeof(p) # the output below is for 64bit cpython3.8+\r\n    32\r\n\r\nexample with class statement and typehints:\r\n\r\n    >>> from recordclass import recordclass\r\n\r\n    class point(recordclass):\r\n       x: int\r\n       y: int\r\n\r\n    >>> print(point.__annotations__)\r\n    {'x': <class 'int'>, 'y': <class 'int'>}\r\n    >>> p = point(1, 2)\r\n    >>> print(p)\r\n    point(1, 2)\r\n    >>> print(p.x, p.y)\r\n    1 2\r\n    >>> p.x, p.y = 1, 2\r\n    >>> print(p)\r\n    point(1, 2)\r\n\r\nby default `recordclass`-based class instances doesn't participate in cyclic gc and therefore they are smaller than `namedtuple`-based ones. if one want to use it in scenarios with reference cycles then one have to use option `gc=true` (`gc=false` by default):\r\n\r\n    >>> node = recordclass('node', 'root children', gc=true)\r\n\r\nor\r\n\r\n    class node(recordclass, gc=true):\r\n         root: 'node'\r\n         chilren: list\r\n\r\nthe `recordclass` factory can also specify type of the fields:\r\n\r\n    >>> point = recordclass('point', [('x',int), ('y',int)])\r\n\r\nor\r\n\r\n    >>> point = recordclass('point', {'x':int, 'y':int})\r\n\r\n### using dataobject-based classes with mapping protocol\r\n\r\n    class fastmapingpoint(dataobject, mapping=true):\r\n        x: int\r\n        y: int\r\n\r\nor\r\n\r\n    fastmapingpoint = make_dataclass(\"fastmapingpoint\", [(\"x\", int), (\"y\", int)], mapping=true)\r\n\r\n    >>> p = fastmappingpoint(1,2)\r\n    >>> print(p['x'], p['y'])\r\n    1 2\r\n    >>> sys.getsizeof(p) # the output below for python 3.10 (64bit)\r\n    32\r\n\r\n### using dataobject-based classes for recursive data without reference cycles\r\n\r\nthere is the option `deep_dealloc` (default value is `false`) for deallocation of recursive datastructures.\r\nlet consider simple example:\r\n\r\n    class linkeditem(dataobject):\r\n        val: object\r\n        next: 'linkeditem'\r\n\r\n    class linkedlist(dataobject, deep_dealloc=true):\r\n        start: linkeditem = none\r\n        end: linkeditem = none\r\n\r\n        def append(self, val):\r\n            link = linkeditem(val, none)\r\n            if self.start is none:\r\n                self.start = link\r\n            else:\r\n                self.end.next = link\r\n            self.end = link\r\n\r\nwithout `deep_dealloc=true` deallocation of the instance of `linkedlist` will be failed if the length of the linked list is too large.\r\nbut it can be resolved with `__del__` method for clearing the linked list:\r\n\r\n    def __del__(self):\r\n        curr = self.start\r\n        while curr is not none:\r\n            next = curr.next\r\n            curr.next = none\r\n            curr = next\r\n\r\nthere is builtin more fast deallocation method using finalization mechanizm when `deep_dealloc=true`. in such case one don't need `__del__`  method for clearing the linked list.\r\n\r\n> note that for classes with `gc=true` this method is disabled: the python's cyclic gc is used in these cases.\r\n\r\nfor more details see notebook [example_datatypes](https://github.com/intellimath/recordclass/tree/main/examples/example_datatypes.ipynb).\r\n\r\n### changes:\r\n\r\n#### 0.21.1\r\n\r\n* allow to specify `__match_args__`. for example,\r\n\r\n         class user(dataobject):\r\n             first_name: str\r\n             last_name: str\r\n             age: int\r\n             __match_args__ = 'first_name', 'last_name'\r\n\r\n  or\r\n\r\n          user = make_dataclass(\"user\", \"first_name last_name * age\")\r\n  \r\n* add `@as_record` adapter for `def`-style decalarations of dataclasses\r\n  that are considered as just a struct. for example:\r\n\r\n        @as_record()\r\n        def point(x:float, y:float, meta=none): pass\r\n\r\n        >>> p = point(1,2)\r\n        >>> print(p)\r\n        point(x=1, y=2, meta=none)\r\n\r\n  it's almost equivalent to:\r\n  \r\n        point = make_dataclass('point', [('x':float), ('y',float),'meta'], (none,))\r\n\r\n* the option `fast_new` will be removed in 0.22. it will be always as `fast_new=true` by creation.\r\n\r\n        class point(dataobject):\r\n            x:int\r\n            y:int\r\n\r\n            def __new__(cls, x=0, y=0):\r\n                 return dataobject.__new__(cls, x, y)\r\n* fix issues with `_pyunicodewriter` for python3.13.\r\n\r\n#### 0.21\r\n\r\n* add a new option `copy_default` (default `false`) to allow assigning a copy of the default\r\n  value for the field. for example:\r\n  \r\n       class a(dataobject, copy_default=true):\r\n            l: list = []\r\n\r\n       a = a()\r\n       b = a()\r\n       assert(a.l == b.l)\r\n       assert(id(a.l) != id(b.l))\r\n\r\n* allow to inherit the options: `copy_default`, `gc`, `iterable`. for example:\r\n  \r\n       class base(dataobject, copy_default=true):\r\n          pass\r\n\r\n      class a(base):\r\n            l: list = []\r\n\r\n       a = a()\r\n       b = a()\r\n       assert a.l == b.l\r\n       assert id(a.l) != id(b.l)\r\n\r\n* add `factory` to specify factory function for default values. for example:\r\n\r\n        from recordclass import factory\r\n        class a(dataobject):\r\n            x: tuple = factory(lambda: (list(), dict()))\r\n\r\n        a = a()\r\n        b = a()\r\n        assert a.x == ([],{})\r\n        assert id(a.x) != id(b.x)\r\n        assert id(a.x[0]) != id(b.x[0])\r\n        assert id(a.x[1]) != id(b.x[1])\r\n\r\n        from recordclass import factory\r\n        class a(dataobject, copy_default=true):\r\n            l: list = []\r\n            x: tuple = factory(lambda: (list(), dict()))\r\n\r\n        a = a()\r\n        b = a()\r\n        assert a.x == ([],{})\r\n        assert id(a.x) != id(b.x)\r\n        assert a.l == []\r\n        assert id(a.l) != id(b.l)\r\n\r\n  * recordclass supports python 3.12 (tested on linux/debian 11/12 and windows via appveyor).\r\n  \r\n#### 0.20.1\r\n\r\n* improve row_factory for `sqlite` on the ground of `dataobject`-based classes.\r\n* move recordclass repository to [github](https://github.com/intellimath/recordclass) from [bitbucket](hhtps://bitbucket.org).\r\n\r\n#### 0.20\r\n\r\n* library codebase is compatible with python 3.12\r\n  (tested for linux only, windows until python3.12 support on appveyor).\r\n* fix error with update of readonly attribute via `update` function.\r\n\r\n#### 0.19.2\r\n\r\n* exception message for cls(**kwargs) with invalid kweyword argument is more precise (#37).\r\n* add parameter `immutable_type` for python >= 3.11. if `immutable_type=true` then a generated class\r\n  (not an instance) will be immutable. if class do not contain user defuned `__init__` and `__new__`\r\n  then instance creation will be faster (via vectorcall protocol).\r\n\r\n#### 0.19.1\r\n\r\n* fix regression with `c.attr=value` (with immutable class by default).\r\n\r\n#### 0.19\r\n\r\n* add vectorcall protocal to `litetuple` and `mutabletuple`.\r\n* add vectorcall protocal to `dataobject`.\r\n* now dataobject's `op.__hash__` return `id(op)` by default.\r\n  the option `hashable=true` make dataobject hashably by value.\r\n* now `dataobject`-based classes, `litetuple` and `mutabletuple` are support\r\n  bytecode specializations since python 3.11 for instance creation and for getattr/setattr.\r\n* fix `make` function for cases, when subclass have nontrivial `__init__`.\r\n* note for `dataobject`-based subclasses with non-trivial `__init__` one may want define also `__reduce__`.\r\n  for example:\r\n\r\n      def __reduce__(self):\r\n        from recordclass import dataobject, make\r\n        tp, args = dataobject.__reduce__(self)\r\n        return make, (tp, args)\r\n\r\n\r\n#### 0.18.4\r\n\r\n* fix a bug #35 with duplicating the field name during inheritance and mixing it with class level attributes.\r\n* allow use of classvar to define class level field.\r\n\r\n#### 0.18.3\r\n\r\n* fix bug with a tuple as default value of the field.\r\n* fix defaults propagtion to subclasses.\r\n* fix some issues with pickling in the context of dill.\r\n\r\n#### 0.18.2\r\n\r\n* slightly improve performance in the default `__init__`  when fields have default values or kwargs.\r\n* remove experimental pypy support: slow and difficult to predict memory footprint.\r\n* exclude experimental cython modules.\r\n\r\n#### 0.18.1.1\r\n\r\n* repackage 0.18.1 with `use_cython=0`\r\n\r\n#### 0.18.1\r\n\r\n* allow to initialize fields in the user defined `__init__`  method instead of `__new__`  (issue 29).\r\n  if `__init__`  is defined by user then it's responsible for initialization of all fields.\r\n  note that this feature only work for mutable fields.\r\n  instances of the class with `readonly=true` must be initialized only in the default `__new__`.\r\n  for example:\r\n\r\n        class a(dataobject):\r\n              x:int\r\n              y:int\r\n\r\n              def __init__(self, x, y):\r\n                  self.x = x\r\n                  self.y = y\r\n\r\n* `fast_new=true` by default.\r\n* add `make_row_factory` for `sqlite3` :\r\n\r\n        class planet(dataobject):\r\n            name:str\r\n            radius:int\r\n\r\n        >>> con = sql.connect(\":memory:\")\r\n        >>> cur = con.execute(\"select 'earth' as name, 6378 as radius\")\r\n        >>> cur.row_factory = make_row_factory(planet)\r\n        >>> row = cur.fetchone()\r\n        >>> print(row)\r\n        planet(name='earth', radius=6378)\r\n\r\n#### 0.18.0.1\r\n\r\n* exclude test_dataobject_match.py (for testing `match` statement) for python < 3.10.\r\n\r\n#### 0.18\r\n\r\n* python 3.11 support.\r\n* adapt data object to take benefit from bytecode specialization in 3.11.\r\n* fix issue for argument with default value in `__new__`, which havn't `__repr__`\r\n  that can be interpreted as valid python expression\r\n  for creation of the default value.\r\n* add support for typing.classvar.\r\n* add `py_tpflags_sequence`  and `py_tpflags_mapping`.\r\n* add `__match_args__`  to support match protocol for dataobject-based subclasses.\r\n\r\n#### 0.17.5\r\n\r\n* make to compile, to build and to test successfully for python 3.11.\r\n\r\n#### 0.17.4\r\n\r\n* fixed error with missing `_pyobject_gc_malloc` in 3.11.\r\n\r\n#### 0.17.3\r\n\r\n* fix compatibility issue: restore gnu98 c-syntax.\r\n* fix remained issues with use of \"py_size(op)\" and \"py_type(op)\" as l-value.\r\n\r\n#### 0.17.2\r\n\r\n* add support for python 3.10.\r\n* there are no use of \"py_size(op)\" and \"py_type(op)\" as l-value.\r\n\r\n#### 0.17.1\r\n\r\n* fix packaging issue with cython=1 in setup.py\r\n\r\n#### 0.17\r\n\r\n* now recordclass library may be compiled for pypy3, but there is still no complete runtime compatibility with pypy3.\r\n* slighly imporove performance of `litetuple` / `mutabletuple`.\r\n* slighly imporove performance of `dataobject`-based subclasses.\r\n* add adapter `as_dataclass`. for example:\r\n\r\n        @as_dataclass()\r\n        class point:\r\n            x:int\r\n            y:int\r\n\r\n* module _litelist is implemented in pure c.\r\n* make dataobject.__copy__ faster.\r\n\r\n#### 0.16.3\r\n\r\n* add possibility for recordclasses to assighn values by key:\r\n\r\n        a = recordclass(\"a\", \"x y\", mapping=true)\r\n        a = a(1,2)\r\n        a['x'] = 100\r\n        a['y'] = 200\r\n\r\n#### 0.16.2\r\n\r\n* fix the packaging bug in 0.16.1.\r\n\r\n#### 0.16.1\r\n\r\n* add `dictclass` factory function to generate class with `dict-like` api and without attribute access to the fields.\r\n  features: fast instance creation, small memory footprint.\r\n\r\n#### 0.16\r\n\r\n* `recordclass` started to be a direct subclass of dataobject with `sequence=true` and support\r\n  of `namedtuple`-like api.\r\n  insted of `recordclass(name, fields, **kw)` for class creation\r\n  use factory function `recordclass(name, fields, **kw)`\r\n  (it allows to specify types).\r\n* add option api='dict'  to `make_dataclass` for creating class that support dict-like api.\r\n* now one can't remove dataobject's property from it's class using del or builting delattr.\r\n  for example:\r\n\r\n        >>> point = make_dataclass(\"point\", \"x y\")\r\n        >>> del point.x\r\n        ...........\r\n        attributeerror: attribute x of the class point can't be deleted\r\n\r\n* now one can't delete field's value using del or builting delattr.\r\n  for example:\r\n\r\n        >>> p = point(1, 2)\r\n        >>> del p.x\r\n        ...........\r\n        attributeerror: the value can't be deleted\"\r\n  insted one can use assighnment to none:\r\n\r\n        >>> p = point(1, 2)\r\n        >>> p.x = none\r\n\r\n* slightly improve performance of the access by index of dataobject-based classes with option `sequence=true`.\r\n\r\n\r\n#### 0.15.1\r\n\r\n* options `readonly` and `iterable` now can be sspecified via keyword arguments in class statement.\r\n  for example:\r\n\r\n        class point(dataobject, readonly=true, iterable=true):\r\n             x:int\r\n             y:int\r\n\r\n* add `update(cls, **kwargs)` function to update attribute values.`\r\n\r\n\r\n#### 0.15\r\n\r\n* now library supports only python >= 3.6\r\n* 'gc' and 'fast_new' options now can be specified as kwargs in class statement.\r\n* add a function `astuple(ob)` for transformation dataobject instance `ob` to a tuple.\r\n* drop datatuple based classes.\r\n* add function `make(cls, args, **kwargs)` to create instance of the class `cls`.\r\n* add function `clone(ob, **kwargs)` to clone dataobject instance `ob`.\r\n* make structclass as alias of make_dataclass.\r\n* add option 'deep_dealloc' (@clsconfig(deep_dealloc=true)) for deallocation\r\n  instances of dataobject-based recursive subclasses.\r\n\r\n#### 0.14.3:\r\n\r\n* subclasses of `dataobject` now support iterable and hashable protocols by default.\r\n\r\n#### 0.14.2:\r\n\r\n* fix compilation issue for python 3.9.\r\n\r\n#### 0.14.1:\r\n\r\n* fix issue with __hash__ when subclassing recordclass-based classes.\r\n\r\n#### 0.14:\r\n\r\n* add __doc__ to generated  `dataobject`-based class in order to support `inspect.signature`.\r\n* add `fast_new` argument/option for fast instance creation.\r\n* fix refleak in `litelist`.\r\n* fix sequence protocol ability for `dataobject`/`datatuple`.\r\n* fix typed interface for `structclass`.\r\n\r\n#### 0.13.2\r\n\r\n* fix issue #14 with deepcopy of dataobjects.\r\n\r\n#### 0.13.1\r\n\r\n* restore ``join_classes` and add new function `join_dataclasses`.\r\n\r\n#### 0.13.0.1\r\n\r\n* remove redundant debug code.\r\n\r\n\r\n#### 0.13\r\n\r\n* make `recordclass` compiled and work with cpython 3.8.\r\n* move repository to **git** instead of mercurial since bitbucket will drop support of mercurial repositories.\r\n* fix some potential reference leaks.\r\n\r\n\r\n#### 0.12.0.1\r\n\r\n* fix missing .h files.\r\n\r\n#### 0.12\r\n\r\n* `clsconfig` now become the main decorator for tuning dataobject-based classes.\r\n* fix concatenation of mutabletuples (issue `#10`).\r\n\r\n#### 0.11.1:\r\n\r\n* `dataobject` instances may be deallocated faster now.\r\n\r\n#### 0.11:\r\n\r\n* rename `memoryslots` to `mutabletuple`.\r\n* `mutabletuple` and `immutabletuple` dosn't participate in cyclic garbage collection.\r\n* add `litelist` type for list-like objects, which doesn't participate in cyglic garbage collection.\r\n\r\n#### 0.10.3:\r\n\r\n* introduce dataclassstorage and recordclassstorage.\r\n  they allow cache classes and used them without creation of new one.\r\n* add `iterable` decorator and argument. now dataobject with fields isn't iterable by default.\r\n* move `astuple` to `dataobject.c`.\r\n\r\n#### 0.10.2\r\n\r\n* fix error with dataobject's `__copy__`.\r\n* fix error with pickling of recordclasses and structclasses, which was appeared since 0.8.5\r\n  (thanks to connor wolf).\r\n\r\n#### 0.10.1\r\n\r\n* now by default sequence protocol is not supported by default if dataobject has fields,\r\n  but iteration is supported.\r\n* by default argsonly=false for usability reasons.\r\n\r\n#### 0.10\r\n\r\n* invent new factory function `make_class` for creation of different kind of dataobject classes\r\n  without gc support by default.\r\n* invent new metaclass `datatype` and new base class `dataobject` for creation dataobject class using\r\n  `class` statement.\r\n  it have disabled gc support, but could be enabled by decorator `dataobject.enable_gc`.\r\n  it support type hints (for python >= 3.6) and default values.\r\n  it may not specify sequence of field names in `__fields__` when type hints are applied to all\r\n  data attributes (for python >= 3.6).\r\n* now `recordclass`-based classes may not support cyclic garbage collection too.\r\n  this reduces the memory footprint by the size of `pygc_head`.\r\n  now by default recordclass-based classes doesn't support cyclic garbage collection.\r\n\r\n#### 0.9\r\n\r\n* change version to 0.9 to indicate a step forward.\r\n* cleanup `dataobject.__cinit__`.\r\n\r\n#### 0.8.5\r\n\r\n* make `arrayclass`-based objects support setitem/getitem and `structclass`-based objects able\r\n  to not support them. by default, as before `structclass`-based objects support setitem/getitem protocol.\r\n* now only instances of `dataobject` are comparable to 'arrayclass'-based and `structclass`-based instances.\r\n* now generated classes can be hashable.\r\n\r\n\r\n#### 0.8.4\r\n\r\n* improve support for readonly mode for structclass and arrayclass.\r\n* add tests for arrayclass.\r\n\r\n#### 0.8.3\r\n\r\n* add typehints support to structclass-based classes.\r\n\r\n\r\n#### 0.8.2\r\n\r\n* remove `usedict`, `gc`, `weaklist` from the class `__dict__`.\r\n\r\n#### 0.8.1\r\n\r\n* remove cython dependence by default for building `recordclass` from the sources [issue #7].\r\n\r\n#### 0.8\r\n\r\n* add `structclass` factory function. it's analog of `recordclass` but with less memory\r\n  footprint for it's instances (same as for instances of classes with `__slots__`) in the camparison\r\n  with `recordclass` and `namedtuple`\r\n  (it currently implemented with `cython`).\r\n* add `arrayclass` factory function which produce a class for creation fixed size array.\r\n  the benefit of such approach is also less memory footprint\r\n  (it currently currently implemented with `cython`).\r\n* `structclass` factory has argument `gc` now. if `gc=false` (by default) support of cyclic garbage collection\r\n  will switched off for instances of the created class.\r\n* add function `join(c1, c2)` in order to join two `structclass`-based classes c1 and c2.\r\n* add `sequenceproxy` function for creation of immutable and hashable proxy object from class instances,\r\n  which implement access by index\r\n  (it currently currently implemented with `cython`).\r\n* add support for access to recordclass object attributes by idiom: `ob['attrname']` (issue #5).\r\n* add argument `readonly` to recordclass factory to produce immutable namedtuple.\r\n  in contrast to `collection.namedtuple` it use same descriptors as for\r\n  regular recordclasses for performance increasing.\r\n\r\n#### 0.7\r\n\r\n* make mutabletuple objects creation faster. as a side effect: when number of fields >= 8\r\n  recordclass instance creation time is not biger than creation time of instaces of\r\n  dataclasses with `__slots__`.\r\n* recordclass factory function now create new recordclass classes in the same way as namedtuple in 3.7\r\n  (there is no compilation of generated python source of class).\r\n\r\n#### 0.6\r\n\r\n* add support for default values in recordclass factory function in correspondence\r\n  to same addition to namedtuple in python 3.7.\r\n\r\n#### 0.5\r\n\r\n* change version to 0.5\r\n\r\n#### 0.4.4\r\n\r\n* add support for default values in recordclass (patches from pedro von hertwig)\r\n* add tests for recorclass (adopted from python tests for namedtuple)\r\n\r\n#### 0.4.3\r\n\r\n* add support for typing for python 3.6 (patches from vladimir bolshakov).\r\n* resolve memory leak issue.\r\n\r\n#### 0.4.2\r\n\r\n* fix memory leak in property getter/setter\r\n\r\n\r\n",
  "docs_url": null,
  "keywords": "namedtuple,recordclass,dataclass,dataobject",
  "license": "mit license",
  "name": "recordclass",
  "package_url": "https://pypi.org/project/recordclass/",
  "project_url": "https://pypi.org/project/recordclass/",
  "project_urls": {
    "Download": "https://pypi.org/project/recordclass/#files",
    "Homepage": "https://github.com/intellimath/recordclass"
  },
  "release_url": "https://pypi.org/project/recordclass/0.21.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "mutable variant of namedtuple -- recordclass, which support assignments, compact dataclasses and other memory saving variants.",
  "version": "0.21.1",
  "releases": [],
  "developers": [
    "szport@gmail.com",
    "zaur_shibzukhov"
  ],
  "kwds": "recordclasses what_is_recordclass recordclass dataclasses namedtuple",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_recordclass",
  "homepage": "https://github.com/intellimath/recordclass",
  "release_count": 58,
  "dependency_ids": []
}