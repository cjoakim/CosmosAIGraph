{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "framework :: django",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "=========\ndjango-rq\n=========\n\n|build status|\n\ndjango integration with `rq <https://github.com/nvie/rq>`__, a `redis <http://redis.io/>`__\nbased python queuing library. `django-rq <https://github.com/rq/django-rq>`__ is a\nsimple app that allows you to configure your queues in django's ``settings.py``\nand easily use them in your project.\n\n=================\nsupport django-rq\n=================\n\nif you find ``django-rq`` useful, please consider supporting its development via `tidelift <https://tidelift.com/subscription/pkg/pypi-django_rq?utm_source=pypi-django-rq&utm_medium=referral&utm_campaign=readme>`_.\n\n============\nrequirements\n============\n\n* `django <https://www.djangoproject.com/>`__ (2.0+)\n* `rq <https://github.com/nvie/rq>`__\n\n============\ninstallation\n============\n\n* install ``django-rq`` (or `download from pypi <http://pypi.python.org/pypi/django-rq>`__):\n\n.. code-block:: python\n\n    pip install django-rq\n\n* add ``django_rq`` to ``installed_apps`` in ``settings.py``:\n\n.. code-block:: python\n\n    installed_apps = (\n        # other apps\n        \"django_rq\",\n    )\n\n* configure your queues in django's ``settings.py``:\n\n.. code-block:: python\n\n    rq_queues = {\n        'default': {\n            'host': 'localhost',\n            'port': 6379,\n            'db': 0,\n            'username': 'some-user',\n            'password': 'some-password',\n            'default_timeout': 360,\n            'redis_client_kwargs': {    # eventual additional redis connection arguments\n                'ssl_cert_reqs': none,\n            },\n        },\n        'with-sentinel': {\n            'sentinels': [('localhost', 26736), ('localhost', 26737)],\n            'master_name': 'redismaster',\n            'db': 0,\n            # redis username/password\n            'username': 'redis-user',\n            'password': 'secret',\n            'socket_timeout': 0.3,\n            'connection_kwargs': {  # eventual additional redis connection arguments\n                'ssl': true\n            },\n            'sentinel_kwargs': {    # eventual sentinel connection arguments\n                # if sentinel also has auth, username/password can be passed here\n                'username': 'sentinel-user',\n                'password': 'secret',\n            },\n        },\n        'high': {\n            'url': os.getenv('redistogo_url', 'redis://localhost:6379/0'), # if you're on heroku\n            'default_timeout': 500,\n        },\n        'low': {\n            'host': 'localhost',\n            'port': 6379,\n            'db': 0,\n        }\n    }\n\n    rq_exception_handlers = ['path.to.my.handler'] # if you need custom exception handlers\n\n* include ``django_rq.urls`` in your ``urls.py``:\n\n.. code-block:: python\n\n    urlpatterns += [\n        path('django-rq/', include('django_rq.urls'))\n    ]\n\n=====\nusage\n=====\n\nputting jobs in the queue\n-------------------------\n\n`django-rq` allows you to easily put jobs into any of the queues defined in\n``settings.py``. it comes with a few utility functions:\n\n* ``enqueue`` - push a job to the ``default`` queue:\n\n.. code-block:: python\n\n    import django_rq\n    django_rq.enqueue(func, foo, bar=baz)\n\n* ``get_queue`` - returns an ``queue`` instance.\n\n.. code-block:: python\n\n    import django_rq\n    queue = django_rq.get_queue('high')\n    queue.enqueue(func, foo, bar=baz)\n\nin addition to ``name`` argument, ``get_queue`` also accepts ``default_timeout``,\n``is_async``, ``autocommit``, ``connection`` and ``queue_class`` arguments. for example:\n\n.. code-block:: python\n\n    queue = django_rq.get_queue('default', autocommit=true, is_async=true, default_timeout=360)\n    queue.enqueue(func, foo, bar=baz)\n\nyou can provide your own singleton redis connection object to this function so that it will not\ncreate a new connection object for each queue definition. this will help you limit\nnumber of connections to redis server. for example:\n\n.. code-block:: python\n\n    import django_rq\n    import redis\n    redis_cursor = redis.strictredis(host='', port='', db='', password='')\n    high_queue = django_rq.get_queue('high', connection=redis_cursor)\n    low_queue = django_rq.get_queue('low', connection=redis_cursor)\n\n\n* ``get_connection`` - accepts a single queue name argument (defaults to \"default\")\n  and returns a connection to the queue's redis server:\n\n.. code-block:: python\n\n    import django_rq\n    redis_conn = django_rq.get_connection('high')\n\n* ``get_worker`` - accepts optional queue names and returns a new `rq`\n  ``worker`` instance for specified queues (or ``default`` queue):\n\n.. code-block:: python\n\n    import django_rq\n    worker = django_rq.get_worker() # returns a worker for \"default\" queue\n    worker.work()\n    worker = django_rq.get_worker('low', 'high') # returns a worker for \"low\" and \"high\"\n\n\n@job decorator\n--------------\n\nto easily turn a callable into an rq task, you can also use the ``@job``\ndecorator that comes with ``django_rq``:\n\n.. code-block:: python\n\n    from django_rq import job\n\n    @job\n    def long_running_func():\n        pass\n    long_running_func.delay() # enqueue function in \"default\" queue\n\n    @job('high')\n    def long_running_func():\n        pass\n    long_running_func.delay() # enqueue function in \"high\" queue\n\nyou can pass in any arguments that rq's job decorator accepts:\n\n.. code-block:: python\n\n    @job('default', timeout=3600)\n    def long_running_func():\n        pass\n    long_running_func.delay() # enqueue function with a timeout of 3600 seconds.\n\nit's possible to specify default for ``result_ttl`` decorator keyword argument\nvia ``default_result_ttl`` setting:\n\n.. code-block:: python\n\n    rq = {\n        'default_result_ttl': 5000,\n    }\n\nwith this setting, job decorator will set ``result_ttl`` to 5000 unless it's\nspecified explicitly.\n\n\nrunning workers\n---------------\ndjango_rq provides a management command that starts a worker for every queue\nspecified as arguments::\n\n    python manage.py rqworker high default low\n\nif you want to run ``rqworker`` in burst mode, you can pass in the ``--burst`` flag::\n\n    python manage.py rqworker high default low --burst\n\nif you need to use custom worker, job or queue classes, it is best to use global settings\n(see `custom queue classes`_ and `custom job and worker classes`_). however, it is also possible\nto override such settings with command line options as follows.\n\nto use a custom worker class, you can pass in the ``--worker-class`` flag\nwith the path to your worker::\n\n    python manage.py rqworker high default low --worker-class 'path.to.geventworker'\n\nto use a custom queue class, you can pass in the ``--queue-class`` flag\nwith the path to your queue class::\n\n    python manage.py rqworker high default low --queue-class 'path.to.customqueue'\n\nto use a custom job class, provide ``--job-class`` flag.\n\nstarting from version 2.10, running rq's worker-pool is also supported::\n\n    python manage.py rqworker-pool default low medium --num-workers 4\n\nsupport for scheduled jobs\n--------------------------\n\nwith rq 1.2.0. you can use `built-in scheduler <https://python-rq.org/docs/scheduling/>`__\nfor your jobs. for example:\n\n.. code-block:: python\n\n    from django_rq.queues import get_queue\n    queue = get_queue('default')\n    job = queue.enqueue_at(datetime(2020, 10, 10), func)\n    \nif you are using built-in scheduler you have to start workers with scheduler support::\n\n    python manage.py rqworker --with-scheduler\n\n\nalternatively you can use `rq scheduler <https://github.com/ui/rq-scheduler>`__.\nafter install you can also use the ``get_scheduler`` function to return a\n``scheduler`` instance for queues defined in settings.py's ``rq_queues``.\nfor example:\n\n.. code-block:: python\n\n    import django_rq\n    scheduler = django_rq.get_scheduler('default')\n    job = scheduler.enqueue_at(datetime(2020, 10, 10), func)\n\nyou can also use the management command ``rqscheduler`` to start the scheduler::\n\n    python manage.py rqscheduler\n\n\nsupport for django-redis and django-redis-cache\n-----------------------------------------------\n\nif you have `django-redis <https://django-redis.readthedocs.org/>`__ or\n`django-redis-cache <https://github.com/sebleier/django-redis-cache/>`__\ninstalled, you can instruct django_rq to use the same connection information\nfrom your redis cache. this has two advantages: it's dry and it takes advantage\nof any optimization that may be going on in your cache setup (like using\nconnection pooling or `hiredis <https://github.com/redis/hiredis>`__.)\n\nto use configure it, use a dict with the key ``use_redis_cache`` pointing to the\nname of the desired cache in your ``rq_queues`` dict. it goes without saying\nthat the chosen cache must exist and use the redis backend. see your respective\nredis cache package docs for configuration instructions. it's also important to\npoint out that since the django-redis-cache ``shardedclient`` splits the cache\nover multiple redis connections, it does not work.\n\nhere is an example settings fragment for `django-redis`:\n\n.. code-block:: python\n\n    caches = {\n        'redis-cache': {\n            'backend': 'redis_cache.cache.rediscache',\n            'location': 'localhost:6379:1',\n            'options': {\n                'client_class': 'django_redis.client.defaultclient',\n                'max_entries': 5000,\n            },\n        },\n    }\n\n    rq_queues = {\n        'high': {\n            'use_redis_cache': 'redis-cache',\n        },\n        'low': {\n            'use_redis_cache': 'redis-cache',\n        },\n    }\n\nqueue statistics\n----------------\n\n``django_rq`` also provides a dashboard to monitor the status of your queues at\n``/django-rq/`` (or whatever url you set in your ``urls.py`` during installation.\n\nyou can also add a link to this dashboard link in ``/admin`` by adding\n``rq_show_admin_link = true`` in ``settings.py``. be careful though, this will\noverride the default admin template so it may interfere with other apps that\nmodifies the default admin template.\n\nthese statistics are also available in json format via\n``/django-rq/stats.json``, which is accessible to staff members.\nif you need to access this view via other\nhttp clients (for monitoring purposes), you can define ``rq_api_token`` and access it via\n``/django-rq/stats.json/<api_token>``.\n\n.. image::  demo-django-rq-json-dashboard.png\n\nnote: statistics of scheduled jobs display jobs from `rq built-in scheduler <https://python-rq.org/docs/scheduling/>`__,\nnot optional `rq scheduler <https://github.com/rq/rq-scheduler>`__.\n\nadditionally, these statistics are also accessible from  the command line.\n\n.. code-block:: bash\n\n    python manage.py rqstats\n    python manage.py rqstats --interval=1  # refreshes every second\n    python manage.py rqstats --json  # output as json\n    python manage.py rqstats --yaml  # output as yaml\n\n.. image:: demo-django-rq-cli-dashboard.gif\n\nconfiguring sentry\n-------------------\nsentry\nshould be configured within the django ``settings.py`` as described in the `sentry docs <https://docs.sentry.io/platforms/python/django/>`__.\n\nyou can override the default django sentry configuration when running the ``rqworker`` command\nby passing the ``sentry-dsn`` option:\n\n``./manage.py rqworker --sentry-dsn=https://*****@sentry.io/222222``\n\nthis will override any existing django configuration and reinitialise sentry,\nsetting the following sentry options:\n\n.. code-block:: python\n\n    {\n        'debug': options.get('sentry_debug'),\n        'ca_certs': options.get('sentry_ca_certs'),\n        'integrations': [redisintegration(), rqintegration(), djangointegration()]\n    }\n\n\nconfiguring logging\n-------------------\n\nrq uses python's ``logging``, this means you can easily configure ``rqworker``'s logging mechanism in django's\n``settings.py``. for example:\n\n.. code-block:: python\n\n    logging = {\n        \"version\": 1,\n        \"disable_existing_loggers\": false,\n        \"formatters\": {\n            \"rq_console\": {\n                \"format\": \"%(asctime)s %(message)s\",\n                \"datefmt\": \"%h:%m:%s\",\n            },\n        },\n        \"handlers\": {\n            \"rq_console\": {\n                \"level\": \"debug\",\n                \"class\": \"rq.logutils.colorizingstreamhandler\",\n                \"formatter\": \"rq_console\",\n                \"exclude\": [\"%(asctime)s\"],\n            },\n        },\n        'loggers': {\n            \"rq.worker\": {\n                \"handlers\": [\"rq_console\", \"sentry\"],\n                \"level\": \"debug\"\n            },\n        }\n    }\n\n\ncustom queue classes\n--------------------\n\nby default, every queue will use ``djangorq`` class. if you want to use a custom queue class, you can do so\nby adding a ``queue_class`` option on a per queue basis in ``rq_queues``:\n\n.. code-block:: python\n\n    rq_queues = {\n        'default': {\n            'host': 'localhost',\n            'port': 6379,\n            'db': 0,\n            'queue_class': 'module.path.customclass',\n        }\n    }\n\nor you can specify ``djangorq`` to use a custom class for all your queues in ``rq`` settings:\n\n.. code-block:: python\n\n    rq = {\n        'queue_class': 'module.path.customclass',\n    }\n\ncustom queue classes should inherit from ``django_rq.queues.djangorq``.\n\nif you are using more than one queue class (not recommended), be sure to only run workers\non queues with same queue class. for example if you have two queues defined in ``rq_queues`` and\none has custom class specified, you would have to run at least two separate workers for each\nqueue.\n\ncustom job and worker classes\n-----------------------------\n\nsimilarly to custom queue classes, global custom job and worker classes can be configured using\n``job_class`` and ``worker_class`` settings:\n\n.. code-block:: python\n\n    rq = {\n        'job_class': 'module.path.customjobclass',\n        'worker_class': 'module.path.customworkerclass',\n    }\n\ncustom job class should inherit from ``rq.job.job``. it will be used for all jobs\nif configured.\n\ncustom worker class should inherit from ``rq.worker.worker``. it will be used for running\nall workers unless overridden by ``rqworker`` management command ``worker-class`` option.\n\ntesting tip\n-----------\n\nfor an easier testing process, you can run a worker synchronously this way:\n\n.. code-block:: python\n\n    from django.test import testcase\n    from django_rq import get_worker\n\n    class mytest(testcase):\n        def test_something_that_creates_jobs(self):\n            ...                      # stuff that init jobs.\n            get_worker().work(burst=true)  # processes all jobs then stop.\n            ...                      # asserts that the job stuff is done.\n\nsynchronous mode\n----------------\n\nyou can set the option ``async`` to ``false`` to make synchronous operation the\ndefault for a given queue. this will cause jobs to execute immediately and on\nthe same thread as they are dispatched, which is useful for testing and\ndebugging. for example, you might add the following after you queue\nconfiguration in your settings file:\n\n.. code-block:: python\n\n    # ... logic to set debug and testing settings to true or false ...\n\n    # ... regular rq_queues setup code ...\n\n    if debug or testing:\n        for queueconfig in rq_queues.values():\n            queueconfig['async'] = false\n\nnote that setting the ``is_async`` parameter explicitly when calling ``get_queue``\nwill override this setting.\n\n=============\nrunning tests\n=============\n\nto run ``django_rq``'s test suite::\n\n    `which django-admin` test django_rq --settings=django_rq.tests.settings --pythonpath=.\n\n===================\ndeploying on ubuntu\n===================\n\ncreate an rqworker service that runs the high, default, and low queues.\n\nsudo vi /etc/systemd/system/rqworker.service\n\n.. code-block:: bash\n\n    [unit]\n    description=django-rq worker\n    after=network.target\n\n    [service]\n    workingdirectory=<<path_to_your_project_folder>>\n    execstart=/home/ubuntu/.virtualenv/<<your_virtualenv>>/bin/python \\\n        <<path_to_your_project_folder>>/manage.py \\\n        rqworker high default low\n\n    [install]\n    wantedby=multi-user.target\n\nenable and start the service\n\n.. code-block:: bash\n\n    sudo systemctl enable rqworker\n    sudo systemctl start rqworker\n\n===================\ndeploying on heroku\n===================\n\nadd `django-rq` to your `requirements.txt` file with:\n\n.. code-block:: bash\n\n    pip freeze > requirements.txt\n\nupdate your `procfile` to:\n\n.. code-block:: bash\n\n    web: gunicorn --pythonpath=\"$pwd/your_app_name\" config.wsgi:application\n\n    worker: python your_app_name/manage.py rqworker high default low\n\ncommit and re-deploy. then add your new worker with:\n\n.. code-block:: bash\n\n    heroku scale worker=1\n\n=========\nchangelog\n=========\n\nsee `changelog.md <https://github.com/rq/django-rq/blob/master/changelog.md>`__.\n\n\n.. |build status| image:: https://secure.travis-ci.org/rq/django-rq.svg?branch=master\n   :target: https://travis-ci.org/rq/django-rq\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "django-rq",
  "package_url": "https://pypi.org/project/django-rq/",
  "project_url": "https://pypi.org/project/django-rq/",
  "project_urls": {
    "Homepage": "https://github.com/rq/django-rq"
  },
  "release_url": "https://pypi.org/project/django-rq/2.10.1/",
  "requires_dist": [
    "django (>=3.2)",
    "rq (>=1.14)",
    "redis (>=3)",
    "raven (>=6.1.0) ; extra == 'sentry'",
    "mock (>=2.0.0) ; extra == 'testing'"
  ],
  "requires_python": "",
  "summary": "an app that provides django integration for rq (redis queue)",
  "version": "2.10.1",
  "releases": [],
  "developers": [
    "selwin.ong@gmail.com",
    "selwin_ong"
  ],
  "kwds": "django_rq djangorq rq_queues django django_redis",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_django_rq",
  "homepage": "https://github.com/rq/django-rq",
  "release_count": 52,
  "dependency_ids": [
    "pypi_django",
    "pypi_mock",
    "pypi_raven",
    "pypi_redis",
    "pypi_rq"
  ]
}