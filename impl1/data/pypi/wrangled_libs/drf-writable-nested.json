{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 2.2",
    "framework :: django :: 3.0",
    "framework :: django :: 3.1",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http"
  ],
  "description": "drf writable nested\n====================\n![build](https://github.com/beda-software/drf-writable-nested/actions/workflows/build.yaml/badge.svg)\n[![codecov](https://codecov.io/gh/beda-software/drf-writable-nested/branch/master/graph/badge.svg)](https://codecov.io/gh/beda-software/drf-writable-nested)\n[![pypi](https://img.shields.io/pypi/v/drf-writable-nested.svg)](https://pypi.python.org/pypi/drf-writable-nested)\n[![pyversions](https://img.shields.io/pypi/pyversions/drf-writable-nested.svg)](https://pypi.python.org/pypi/drf-writable-nested)\n\nthis is a writable nested model serializer for django rest framework which\nallows you to create/update your models with related nested data.\n\nthe following relations are supported:\n- onetoone (direct/reverse)\n- foreignkey (direct/reverse)\n- manytomany (direct/reverse excluding m2m relations with through model)\n- genericrelation (this is always only reverse)\n\nrequirements\n============\n\n- python (3.5, 3.6, 3.7, 3.8, 3.9, 3.10)\n- django (2.2, 3.0, 3.1, 3.2, 4.0)\n- djangorestframework (3.8+)\n\ninstallation\n============\n\n```\npip install drf-writable-nested\n```\n\nusage\n=====\n\nfor example, for the following model structure:\n```python\nfrom django.db import models\n\n\nclass site(models.model):\n    url = models.charfield(max_length=100)\n\n\nclass user(models.model):\n    username = models.charfield(max_length=100)\n\n\nclass accesskey(models.model):\n    key = models.charfield(max_length=100)\n\n\nclass profile(models.model):\n    sites = models.manytomanyfield(site)\n    user = models.onetoonefield(user, on_delete=models.cascade)\n    access_key = models.foreignkey(accesskey, null=true, on_delete=models.cascade)\n\n\nclass avatar(models.model):\n    image = models.charfield(max_length=100)\n    profile = models.foreignkey(profile, related_name='avatars', on_delete=models.cascade)\n```\n\nwe should create the following list of serializers:\n\n```python\nfrom rest_framework import serializers\nfrom drf_writable_nested.serializers import writablenestedmodelserializer\n\n\nclass avatarserializer(serializers.modelserializer):\n    image = serializers.charfield()\n\n    class meta:\n        model = avatar\n        fields = ('pk', 'image',)\n\n\nclass siteserializer(serializers.modelserializer):\n    url = serializers.charfield()\n\n    class meta:\n        model = site\n        fields = ('pk', 'url',)\n\n\nclass accesskeyserializer(serializers.modelserializer):\n\n    class meta:\n        model = accesskey\n        fields = ('pk', 'key',)\n\n\nclass profileserializer(writablenestedmodelserializer):\n    # direct manytomany relation\n    sites = siteserializer(many=true)\n\n    # reverse fk relation\n    avatars = avatarserializer(many=true)\n\n    # direct fk relation\n    access_key = accesskeyserializer(allow_null=true)\n\n    class meta:\n        model = profile\n        fields = ('pk', 'sites', 'avatars', 'access_key',)\n\n\nclass userserializer(writablenestedmodelserializer):\n    # reverse onetoone relation\n    profile = profileserializer()\n\n    class meta:\n        model = user\n        fields = ('pk', 'profile', 'username',)\n```\n\nalso, you can use `nestedcreatemixin` or `nestedupdatemixin` from this package\nif you want to support only create or update logic.\n\nfor example, we can pass the following data with related nested fields to our\nmain serializer:\n\n```python\ndata = {\n    'username': 'test',\n    'profile': {\n        'access_key': {\n            'key': 'key',\n        },\n        'sites': [\n            {\n                'url': 'http://google.com',\n            },\n            {\n                'url': 'http://yahoo.com',\n            },\n        ],\n        'avatars': [\n            {\n                'image': 'image-1.png',\n            },\n            {\n                'image': 'image-2.png',\n            },\n        ],\n    },\n}\n\nuser_serializer = userserializer(data=data)\nuser_serializer.is_valid(raise_exception=true)\nuser = user_serializer.save()\n```\n\nthis serializer will automatically create all nested relations and we receive a\ncomplete instance with filled data.\n```python\nuser_serializer = userserializer(instance=user)\nprint(user_serializer.data)\n```\n\n```python\n{\n    'pk': 1,\n    'username': 'test',\n    'profile': {\n        'pk': 1,\n        'access_key': {\n            'pk': 1,\n            'key': 'key'\n        },\n        'sites': [\n            {\n                'pk': 1,\n                'url': 'http://google.com',\n            },\n            {\n                'pk': 2,\n                'url': 'http://yahoo.com',\n            },\n        ],\n        'avatars': [\n            {\n                'pk': 1,\n                'image': 'image-1.png',\n            },\n            {\n                'pk': 2,\n                'image': 'image-2.png',\n            },\n        ],\n    },\n}\n```\n\nit is also possible to pass through values to nested serializers from the call\nto the base serializer's `save` method. these `kwargs` must be of type `dict`. e g:\n\n```python\n# user_serializer created with 'data' as above\nuser = user_serializer.save(\n    profile={\n        'access_key': {'key': 'key2'},\n    },\n)\nprint(user.profile.access_key.key)\n```\n\n```python\n'key2'\n```\n\nnote: the same value will be used for all nested instances like default value but with higher priority.\n\n\ntesting\n=======\nto run unit tests, run:\n```bash\n# setup the virtual environment\npython3 -m venv envname\nsource envname/bin/activate\n\npip install django\npip install django-rest-framework\npip install -r requirements.txt\n\n# run tests\npy.test\n```\n\n\nknown problems with solutions\n=============================\n\n\n##### validation problem for nested serializers with unique fields on update\nwe have a special mixin `uniquefieldsmixin` which solves this problem.\nthe mixin moves` uniquevalidator`'s from the validation stage to the save stage.\n\nif you want more details, you can read related issues and articles:\nhttps://github.com/beda-software/drf-writable-nested/issues/1\nhttp://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers\n\n###### example of usage:\n```python\nclass child(models.model):\n    field = models.charfield(unique=true)\n\n\nclass parent(models.model):\n    child = models.foreignkey('child')\n\n\nclass childserializer(uniquefieldsmixin, serializers.modelserializer):\n    class meta:\n        model = child\n\n\nclass parentserializer(nestedupdatemixin, serializers.modelserializer):\n    child = childserializer()\n\n    class meta:\n        model = parent\n```\n\nnote: `uniquefieldsmixin` must be applied only on serializer\nwhich has unique fields.\n\n###### mixin ordering\nwhen you are using both mixins\n(`uniquefieldsmixin` and `nestedcreatemixin` or `nestedupdatemixin`)\nyou should put `uniquefieldsmixin` ahead.\n\nfor example:\n```python\nclass childserializer(uniquefieldsmixin, nestedupdatemixin,\n        serializers.modelserializer):\n```\n\n##### update problem for nested fields with form-data in `patch` and `put` methods\nthere is a special problem while we try to update any model object with nested fields\nwithin it via `put` or `patch` using form-data we can not update it. and it complains\nabout fields not provided. so far, we came to know that this is also a problem in drf.\nbut we can follow a tricky way to solve it at least for now.\nsee the below solution about the problem\n\nif you want more details, you can read related issues and articles:\nhttps://github.com/beda-software/drf-writable-nested/issues/106\nhttps://github.com/encode/django-rest-framework/issues/7262#issuecomment-737364846\n\n###### example:\n```python\n\n# models\nclass voucher(models.model):\n    voucher_number = models.charfield(verbose_name=\"voucher number\", max_length=10, default='')\n    image = models.imagefield(upload_to=\"vouchers/images/\", null=true, blank=true)\n\nclass voucherrow(models.model):\n    voucher = models.foreignkey(to='voucher.voucher', on_delete=models.protect, verbose_name='voucher',\n                                related_name='voucherrows', null=true)\n    account = models.charfield(verbose_name=\"fortnox account number\", max_length=255)\n    debit = models.decimalfield(verbose_name=\"amount\", decimal_places=2, default=0.00, max_digits=12)\n    credit = models.decimalfield(verbose_name=\"amount\", decimal_places=2, default=0.00, max_digits=12)\n    description = models.charfield(verbose_name=\"description\", max_length=100, null=true, blank=true)\n\n# serializers for these models\nclass voucherrowserializer(writablenestedmodelserializer):\n    class meta:\n        model = voucherrow\n        fields = ('id', 'account', 'debit', 'credit', 'description',)\n\n\nclass voucherserializer(serializers.modelserializer):\n    voucherrows = voucherrowserializer(many=true, required=false, read_only=true)\n    class meta:\n        model = voucher\n        fields = ('id', 'participants', 'voucher_number', 'voucherrows', 'image')\n\n```\n\nnow if you want to update `voucher` with `voucherrow` and voucher image then you need to do it\nusing form-data via `put` or `patch` request where your `voucherrows` fields are nested field.\nwith the current implementation of the `drf-writable-nested` doesn't update it. because it does\nnot support something like-\n\n```text\nvoucherrows[1].account=1120\nvoucherrows[1].debit=1000.00\nvoucherrows[1].credit=0.00\nvoucherrows[1].description='debited from bank account' \nvoucherrows[2].account=1130\nvoucherrows[2].debit=0.00\nvoucherrows[2].credit=1000.00\nvoucherrows[2].description='credited to cash account'\n\n```\nthis is not supported at least for now. so, we can achieve the result in a different way.\ninstead of sending the array fields separately in this way we can convert the whole fields\nalong with values in a `json` string like below and set it as value to the field `voucherrows`.\n\n```json\n\"[{\\\"account\\\": 1120, \\\"debit\\\": 1000.00, \\\"credit\\\": 0.00, \\\"description\\\": \\\"debited from bank account\\\"}, {\\\"account\\\": 1130, \\\"debit\\\": 0.00, \\\"credit\\\": 1000.00, \\\"description\\\": \\\"credited to cash account\\\"}]\"\n```\n\nnow it'll be actually sent as a single field value to the application for the field `voucherrows`.\nfrom your `views` you need to parse it like below before sending it to the serializer-\n\n```python\nclass voucherviewset(viewsets.modelviewset):\n    serializer_class = voucherserializer\n    queryset = serializer_class.meta.model.objects.all().order_by('-created_at')\n    \n    def update(self, request, *args, **kwargs):\n        request.data.update({'voucherrows': json.loads(request.data.pop('voucherrows', none))})\n        return super().update(request, *args, **kwargs)\n```\nnow, you'll get the `voucherrows` field with data in the right format in your serializers.\nsimilar approach will be also applicable for generic views for django rest framework\n\nauthors\n=======\n2014-2022, beda.software\n",
  "docs_url": null,
  "keywords": "drf restframework rest_framework django_rest_framework serializers drf_writable_nested",
  "license": "bsd",
  "name": "drf-writable-nested",
  "package_url": "https://pypi.org/project/drf-writable-nested/",
  "project_url": "https://pypi.org/project/drf-writable-nested/",
  "project_urls": {
    "Homepage": "http://github.com/beda-software/drf-writable-nested"
  },
  "release_url": "https://pypi.org/project/drf-writable-nested/0.7.0/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "writable nested helpers for django-rest-framework's serializers",
  "version": "0.7.0",
  "releases": [],
  "developers": [
    "beda",
    "drfwritablenested@beda.software"
  ],
  "kwds": "drf_writable_nested restframework django_rest_framework rest_framework djangorestframework",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_drf_writable_nested",
  "homepage": "http://github.com/beda-software/drf-writable-nested",
  "release_count": 27,
  "dependency_ids": []
}