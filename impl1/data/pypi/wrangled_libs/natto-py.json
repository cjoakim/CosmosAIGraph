{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "natural language :: japanese",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: bsd",
    "operating system :: posix :: linux",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: linguistic"
  ],
  "description": "natto-py\r\n========\r\n\r\nwhat is natto-py?\r\n-----------------\r\na package leveraging ffi (foreign function interface), ``natto-py`` combines\r\nthe python_ programming language with mecab_, the part-of-speech and\r\nmorphological analyzer for the japanese language. no compiler is necessary, as\r\nit is **not** a c extension. ``natto-py`` will run on mac os, windows and\r\n\\*nix.\r\n\r\nyou can learn more about `natto-py at github`_.\r\n\r\nif you are still using `python 2 after sunset`_, please stick with version\r\n``natto-py==0.9.2``.\r\n\r\n|version| |pyversions| |license| |github-actions| |readthedocs|\r\n\r\nrequirements\r\n------------\r\n``natto-py`` requires the following:\r\n\r\n- an existing installation of `mecab 0.996`_\r\n- a system dictionary, like `ipa`_, `juman`_ or `unidic`_\r\n- `cffi 0.8.6`_ or greater\r\n\r\nthe following python 3 versions are supported:\r\n\r\n- `python 3.7`_\r\n- `python 3.8`_\r\n- `python 3.9`_\r\n- `python 3.10`_\r\n\r\nfor python 2, please use version ``0.9.2``.\r\n\r\ninstallation\r\n------------\r\ninstall ``natto-py`` as you would any other python package:\r\n\r\n.. code-block:: bash\r\n\r\n    $ pip install natto-py\r\n\r\nthis will automatically install the ``cffi`` package, which ``natto-py`` uses\r\nto bind to the ``mecab`` library.\r\n\r\nautomatic configuration\r\n-----------------------\r\nas long as the ``mecab`` (and ``mecab-config`` for \\*nix and mac os)\r\nexecutables are on your ``path``, ``natto-py`` does not require any explicit\r\nconfiguration.\r\n\r\n- on \\*nix and mac os, it queries ``mecab-config`` to discover the path to the ``libmecab.so`` or ``libmecab.dylib``, respectively.\r\n- on windows, it queries the windows registry to locate the mecab installation folder.\r\n- in order to convert character encodings to/from unicode, ``natto-py`` will examine the charset of the ``mecab`` system dictionary.\r\n\r\nexplicit configuration via mecab_path and mecab_charset\r\n-------------------------------------------------------\r\nif ``natto-py`` for some reason cannot locate the ``mecab`` library,\r\nor if it cannot determine the correct charset used internally by\r\n``mecab``, then you will need to set the ``mecab_path`` and ``mecab_charset``\r\nenvironment variables.\r\n\r\n- set the ``mecab_path`` environment variable to the exact name/path to your ``mecab`` library.\r\n- set the ``mecab_charset`` environment variable to the ``charset`` character encoding used by your system dictionary.\r\n\r\ne.g., for mac os:\r\n\r\n.. code-block:: bash\r\n\r\n    export mecab_path=/usr/local/cellar/mecab/0.996/lib/libmecab.dylib\r\n    export mecab_charset=utf8\r\n\r\ne.g., for bash on unix/linux:\r\n\r\n.. code-block:: bash\r\n\r\n    export mecab_path=/usr/local/lib/libmecab.so\r\n    export mecab_charset=euc-jp\r\n\r\ne.g., on windows:\r\n\r\n.. code-block:: bat\r\n\r\n    set mecab_path=c:\\program files\\mecab\\bin\\libmecab.dll\r\n    set mecab_charset=shift-jis\r\n\r\ne.g., from within a python program:\r\n\r\n.. code-block:: python\r\n\r\n    import os\r\n\r\n    os.environ['mecab_path']='/usr/local/lib/libmecab.so'\r\n    os.environ['mecab_charset']='utf-16'\r\n\r\nusage\r\n-----\r\nhere's a very quick guide to using ``natto-py``.\r\n\r\ninstantiate a reference to the ``mecab`` library, and display some details:\r\n\r\n.. code-block:: python\r\n\r\n    from natto import mecab\r\n\r\n    nm = mecab()\r\n    print(nm)\r\n\r\n    # displays details about the mecab instance\r\n    <natto.mecab.mecab\r\n     model=<cdata 'mecab_model_t *' 0x801c16300>,\r\n     tagger=<cdata 'mecab_t *' 0x801c17470>,\r\n     lattice=<cdata 'mecab_lattice_t *' 0x801c196c0>,\r\n     libpath=\"/usr/local/lib/libmecab.so\",\r\n     options={},\r\n     dicts=[<natto.dictionary.dictionaryinfo\r\n             dictionary='mecab_dictionary_info_t *' 0x801c19540>,\r\n             filepath=\"/usr/local/lib/mecab/dic/ipadic/sys.dic\",\r\n             charset=utf8,\r\n             type=0],\r\n     version=0.996>\r\n\r\n----\r\n\r\ndisplay details about the ``mecab`` system dictionary used:\r\n\r\n.. code-block:: python\r\n\r\n    sysdic = nm.dicts[0]\r\n    print(sysdic)\r\n\r\n    # displays the mecab system dictionary info\r\n    <natto.dictionary.dictionaryinfo\r\n     dictionary='mecab_dictionary_info_t *' 0x801c19540>,\r\n     filepath=\"/usr/local/lib/mecab/dic/ipadic/sys.dic\",\r\n     charset=utf8,\r\n     type=0>\r\n\r\n----\r\n\r\nparse japanese text and send the mecab result as a single string to\r\n``stdout``:\r\n\r\n.. code-block:: python\r\n\r\n    print(nm.parse('\u30d4\u30f3\u30c1\u306e\u6642\u306b\u306f\u5fc5\u305a\u30d2\u30fc\u30ed\u30fc\u304c\u73fe\u308c\u308b\u3002'))\r\n\r\n    # mecab result as a single string\r\n    \u30d4\u30f3\u30c1    \u540d\u8a5e,\u4e00\u822c,*,*,*,*,\u30d4\u30f3\u30c1,\u30d4\u30f3\u30c1,\u30d4\u30f3\u30c1\r\n    \u306e      \u52a9\u8a5e,\u9023\u4f53\u5316,*,*,*,*,\u306e,\u30ce,\u30ce\r\n    \u6642      \u540d\u8a5e,\u975e\u81ea\u7acb,\u526f\u8a5e\u53ef\u80fd,*,*,*,\u6642,\u30c8\u30ad,\u30c8\u30ad\r\n    \u306b      \u52a9\u8a5e,\u683c\u52a9\u8a5e,\u4e00\u822c,*,*,*,\u306b,\u30cb,\u30cb\r\n    \u306f      \u52a9\u8a5e,\u4fc2\u52a9\u8a5e,*,*,*,*,\u306f,\u30cf,\u30ef\r\n    \u5fc5\u305a    \u526f\u8a5e,\u52a9\u8a5e\u985e\u63a5\u7d9a,*,*,*,*,\u5fc5\u305a,\u30ab\u30ca\u30e9\u30ba,\u30ab\u30ca\u30e9\u30ba\r\n    \u30d2\u30fc\u30ed\u30fc  \u540d\u8a5e,\u4e00\u822c,*,*,*,*,\u30d2\u30fc\u30ed\u30fc,\u30d2\u30fc\u30ed\u30fc,\u30d2\u30fc\u30ed\u30fc\r\n    \u304c      \u52a9\u8a5e,\u683c\u52a9\u8a5e,\u4e00\u822c,*,*,*,\u304c,\u30ac,\u30ac\r\n    \u73fe\u308c\u308b  \u52d5\u8a5e,\u81ea\u7acb,*,*,\u4e00\u6bb5,\u57fa\u672c\u5f62,\u73fe\u308c\u308b,\u30a2\u30e9\u30ef\u30ec\u30eb,\u30a2\u30e9\u30ef\u30ec\u30eb\r\n    \u3002      \u8a18\u53f7,\u53e5\u70b9,*,*,*,*,\u3002,\u3002,\u3002\r\n    eos\r\n\r\n----\r\n\r\nnext, try parsing the text with mecab node parsing. a generator yielding the\r\nmecabnode instances lets you efficiently iterate over the output without first\r\nmaterializing each and every resulting mecabnode instance. the mecabnode\r\ninstances yielded allow access to more detailed information about each\r\nmorpheme.\r\n\r\nhere we use a `python with-statement`_ to automatically clean up after we\r\nfinish node parsing with the mecab tagger. this is the recommended approach\r\nfor using ``natto-py`` in a production environment:\r\n\r\n.. code-block:: python\r\n\r\n    # use a python with-statement to ensure mecab_destroy is invoked\r\n    #\r\n    with mecab() as nm:\r\n        for n in nm.parse('\u30d4\u30f3\u30c1\u306e\u6642\u306b\u306f\u5fc5\u305a\u30d2\u30fc\u30ed\u30fc\u304c\u73fe\u308c\u308b\u3002', as_nodes=true):\r\n    ...     # ignore any end-of-sentence nodes\r\n    ...     if not n.is_eos():\r\n    ...         print('{}\\t{}'.format(n.surface, n.cost))\r\n    ...\r\n    \u30d4\u30f3\u30c1    3348\r\n    \u306e        3722\r\n    \u6642        5176\r\n    \u306b        5083\r\n    \u306f        5305\r\n    \u5fc5\u305a    7525\r\n    \u30d2\u30fc\u30ed\u30fc   11363\r\n    \u304c       10508\r\n    \u73fe\u308c\u308b   10841\r\n    \u3002        7127\r\n\r\n----\r\n\r\nmecab output formatting is extremely flexible and is highly recommended for\r\nany serious natural language processing task. rather than parsing the mecab\r\noutput as a single, large string, use mecab's ``--node-format`` option\r\n(short form ``-f``) to customize the node's ``feature`` attribute.\r\n\r\n- morpheme surface\r\n- part-of-speech\r\n- part-of-speech id\r\n- pronunciation\r\n\r\nit is good practice when using ``--node-format`` to also specify node \r\nformatting in the case where the morpheme cannot be found in the dictionary,\r\nby using ``--unk-format`` (short form ``-u``).\r\n\r\nthis example formats the node ``feature`` to capture the items above as a\r\ncomma-separated value:\r\n\r\n.. code-block:: python\r\n\r\n    # mecab options used:\r\n    #\r\n    # -f    ... short-form of --node-format\r\n    # %m    ... morpheme surface\r\n    # %f[0] ... part-of-speech\r\n    # %h    ... part-of-speech id (ipadic)\r\n    # %f[8] ... pronunciation\r\n    # \r\n    # -u    ... short-form of --unk-format\r\n    #           output ?,?,?,? for morphemes not in dictionary\r\n    #\r\n    with mecab(r'-f%m,%f[0],%h,%f[8]\\n -u?,?,?,?\\n') as nm:\r\n        for n in nm.parse('\u30d4\u30f3\u30c1\u306e\u6642\u306b\u306f\u5fc5\u305a\u30d2\u30fc\u30ed\u30fc\u304c\u73fe\u308c\u308b\u3002', as_nodes=true):\r\n    ...     # only normal nodes, ignore any end-of-sentence and unknown nodes\r\n    ...     if n.is_nor():\r\n    ...         print(n.feature)\r\n    ...\r\n    \u30d4\u30f3\u30c1,\u540d\u8a5e,38,\u30d4\u30f3\u30c1\r\n    \u306e,\u52a9\u8a5e,24,\u30ce\r\n    \u6642,\u540d\u8a5e,66,\u30c8\u30ad\r\n    \u306b,\u52a9\u8a5e,13,\u30cb\r\n    \u306f,\u52a9\u8a5e,16,\u30ef\r\n    \u5fc5\u305a,\u526f\u8a5e,35,\u30ab\u30ca\u30e9\u30ba\r\n    \u30d2\u30fc\u30ed\u30fc,\u540d\u8a5e,38,\u30d2\u30fc\u30ed\u30fc\r\n    \u304c,\u52a9\u8a5e,13,\u30ac\r\n    \u73fe\u308c\u308b,\u52d5\u8a5e,31,\u30a2\u30e9\u30ef\u30ec\u30eb\r\n    \u3002,\u8a18\u53f7,7,\u3002\r\n\r\n\r\n----\r\n\r\n`partial parsing`_ (\u5236\u7d04\u4ed8\u304d\u89e3\u6790), allows you to pass hints to mecab on\r\nhow to tokenize morphemes when parsing. most useful are boundary constraint\r\nparsing and feature constraint parsing.\r\n\r\nwith boundary constraint parsing, you can specify either a compiled ``re``\r\nregular expression object or a string to tell mecab where the boundaries of\r\na morpheme should be. use the ``boundary_constraints`` keyword. for hints on\r\ntokenization, please see `regular expression operations`_ and `re.finditer`_\r\nin particular.\r\n\r\nthis example uses the ``-f`` node-format option to customize the resulting\r\n``mecabnode`` feature attribute to extract:\r\n\r\n- ``%m`` - morpheme surface\r\n- ``%f[0]`` - node part-of-speech\r\n- ``%s`` - node ``stat`` status value, 1 is ``unknown``\r\n\r\nnote that any such morphemes captured will have node ``stat`` status of 1 (unknown):\r\n\r\n.. code-block:: python\r\n\r\n    import re\r\n\r\n    with mecab(r'-f%m,\\s%f[0],\\s%s\\n') as nm:\r\n\r\n        text = '\u4ffa\u306f\u52aa\u529b\u3057\u305f\u3088\u3063\uff1f \u304a\u524d\u306e10\u500d\u3001\u3044\u3084100\u500d1000\u500d\u3057\u305f\u3088\u3063\uff01'\r\n        \r\n        # capture 10\u500d, 100\u500d and 1000\u500d as single parts-of-speech\r\n        pattern = re.compile('10+\u500d') \r\n\r\n        for n in nm.parse(text, boundary_constraints=pattern, as_nodes=true):\r\n    ...     print(n.feature)\r\n    ...\r\n    \u4ffa, \u540d\u8a5e, 0\r\n    \u306f, \u52a9\u8a5e, 0\r\n    \u52aa\u529b, \u540d\u8a5e, 0\r\n    \u3057, \u52d5\u8a5e, 0\r\n    \u305f\u3088\u3063, \u52d5\u8a5e, 0\r\n    \uff1f, \u8a18\u53f7, 0\r\n    \u304a\u524d, \u540d\u8a5e, 0\r\n    \u306e, \u52a9\u8a5e, 0\r\n    10\u500d, \u540d\u8a5e, 1\r\n    \u3001, \u8a18\u53f7, 0\r\n    \u3044\u3084, \u63a5\u7d9a\u8a5e, 0\r\n    100\u500d, \u540d\u8a5e, 1\r\n    1000\u500d, \u540d\u8a5e, 1\r\n    \u3057, \u52d5\u8a5e, 0\r\n    \u305f\u3088\u3063, \u52d5\u8a5e, 0\r\n    \uff01, \u8a18\u53f7, 0\r\n    eos\r\n\r\nwith feature constraint parsing, you can provide instructions to mecab\r\non what feature to use for a matching morpheme. use the \r\n``feature_constraints`` keyword to pass in a ``tuple`` containing elements\r\nthat themselves are ``tuple`` instances with a specific morpheme (str) \r\nand a corresponding feature (str), in order of constraint precedence:\r\n\r\n.. code-block:: python\r\n\r\n    with mecab(r'-f%m,\\s%f[0],\\s%s\\n') as nm:\r\n\r\n        text = '\u5fc3\u306e\u4e2d\u30673\u56de\u5531\u3048\u3001 \u30d2\u30fc\u30ed\u30fc\u898b\u53c2\uff01\u30d2\u30fc\u30ed\u30fc\u898b\u53c2\uff01\u30d2\u30fc\u30ed\u30fc\u898b\u53c2\uff01'\r\n        features = (('\u30d2\u30fc\u30ed\u30fc\u898b\u53c2', '\u611f\u52d5\u8a5e'),)\r\n\r\n        for n in nm.parse(text, feature_constraints=features, as_nodes=true):\r\n    ...     print(n.feature)\r\n    ...\r\n    \u5fc3, \u540d\u8a5e, 0\r\n    \u306e, \u52a9\u8a5e, 0\r\n    \u4e2d, \u540d\u8a5e, 0\r\n    \u3067, \u52a9\u8a5e, 0\r\n    3, \u540d\u8a5e, 1\r\n    \u56de, \u540d\u8a5e, 0\r\n    \u5531\u3048, \u52d5\u8a5e, 0\r\n    \u3001, \u8a18\u53f7, 0\r\n    \u30d2\u30fc\u30ed\u30fc\u898b\u53c2, \u611f\u52d5\u8a5e, 1\r\n    \uff01, \u8a18\u53f7, 0\r\n    \u30d2\u30fc\u30ed\u30fc\u898b\u53c2, \u611f\u52d5\u8a5e, 1\r\n    \uff01, \u8a18\u53f7, 0\r\n    \u30d2\u30fc\u30ed\u30fc\u898b\u53c2, \u611f\u52d5\u8a5e, 1\r\n    \uff01, \u8a18\u53f7, 0\r\n    eos\r\n\r\n\r\n----\r\n\r\nlearn more\r\n----------\r\n- examples and more detailed information about ``natto-py`` can be found on the `project wiki`_.\r\n- working code in jupyter notebook form can be found under this `project's notebooks directory`_.\r\n- `api documentation on read the docs`_.\r\n\r\ncontributing to natto-py\r\n------------------------\r\n- use git_ and `check out the latest code at github`_ to make sure the\r\n  feature hasn't been implemented or the bug hasn't been fixed yet.\r\n- `browse the issue tracker`_ to make sure someone already hasn't requested it\r\n  and/or contributed it.\r\n- fork the project.\r\n- start a feature/bugfix branch.\r\n- commit and push until you are happy with your contribution.\r\n- make sure to add tests for it. this is important so i don't break it in a\r\n  future version unintentionally.\r\n- please try not to mess with the ``setup.py``, ``changelog``, or version\r\n  files. if you must have your own version, that is fine, but please isolate\r\n  to its own commit so i can cherry-pick around it.\r\n- this project uses the following packages for development:\r\n\r\n  - sphinx_ for document generation\r\n  - twine_ for secure uploads during release\r\n  - unittest_ for unit tests, as it is very natural and easy-to-use\r\n  - pyyaml_ for data loading during tests\r\n\r\nchangelog\r\n---------\r\nplease see the ``changelog`` for the release history.\r\n\r\ncopyright\r\n---------\r\ncopyright |copy| 2022, brooke m. fujita. all rights reserved. please see\r\nthe ``license`` file for further details.\r\n\r\n.. |version| image:: https://badge.fury.io/py/natto-py.svg\r\n    :target: https://pypi.org/project/natto-py/ \r\n.. |pyversions| image:: https://img.shields.io/pypi/pyversions/natto-py.svg?style=flat\r\n.. |github-actions| image:: https://github.com/buruzaemon/natto-py/actions/workflows/automated-test-actions.yml/badge.svg\r\n.. |license| image:: https://img.shields.io/badge/license-bsd-blue.svg\r\n    :target: https://raw.githubusercontent.com/buruzaemon/natto-py/master/license \r\n.. |readthedocs| image:: https://readthedocs.org/projects/natto-py/badge/?version=master\r\n    :target: http://natto-py.readthedocs.org/en/master/?badge=master\r\n    :alt: documentation status\r\n.. _python: http://www.python.org/\r\n.. _mecab: http://taku910.github.io/mecab/\r\n.. _python 2 after sunset: https://www.python.org/doc/sunset-python-2/\r\n.. _ipa: http://taku910.github.io/mecab/#download\r\n.. _juman: http://taku910.github.io/mecab/#download\r\n.. _unidic: http://taku910.github.io/mecab/#download\r\n.. _natto-py at github: https://github.com/buruzaemon/natto-py\r\n.. _mecab 0.996: http://taku910.github.io/mecab/#download\r\n.. _cffi 0.8.6: https://bitbucket.org/cffi/cffi\r\n.. _python 3.7: https://docs.python.org/3.7/whatsnew/3.7.html \r\n.. _python 3.8: https://docs.python.org/3.8/whatsnew/3.8.html \r\n.. _python 3.9: https://docs.python.org/3.9/whatsnew/3.9.html \r\n.. _python 3.10: https://docs.python.org/3/whatsnew/3.10.html \r\n.. _nltk3's lead: https://github.com/nltk/nltk/wiki/porting-your-code-to-nltk-3.0\r\n.. _python with-statement: https://www.python.org/dev/peps/pep-0343/\r\n.. _partial parsing: http://taku910.github.io/mecab/partial.html\r\n.. _regular expression operations: https://docs.python.org/3/library/re.html\r\n.. _re.finditer: https://docs.python.org/3/library/re.html#re.finditer\r\n.. _project wiki: https://github.com/buruzaemon/natto-py/wiki \r\n.. _project's notebooks directory: https://github.com/buruzaemon/natto-py/tree/master/notebooks\r\n.. _api documentation on read the docs: http://natto-py.readthedocs.org/en/master/\r\n.. _git: http://git-scm.com/downloads\r\n.. _check out the latest code at github: https://github.com/buruzaemon/natto-py\r\n.. _browse the issue tracker: https://github.com/buruzaemon/natto-py/issues\r\n.. _sphinx: http://sphinx-doc.org/\r\n.. _twine: https://github.com/pypa/twine\r\n.. _unittest: http://pythontesting.net/framework/unittest/unittest-introduction/\r\n.. _pyyaml: https://github.com/yaml/pyyaml \r\n.. |copy| unicode:: 0xa9 .. copyright sign\r\n\n\n",
  "docs_url": null,
  "keywords": "mecab \u548c\u5e03\u856a \u7d0d\u8c46 japanese morphological analyzer nlp \u5f62\u614b\u7d20\u89e3\u6790 \u81ea\u7136\u8a00\u8a9e\u51e6\u7406 ffi binding \u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0",
  "license": "bsd",
  "name": "natto-py",
  "package_url": "https://pypi.org/project/natto-py/",
  "project_url": "https://pypi.org/project/natto-py/",
  "project_urls": {
    "Homepage": "https://github.com/buruzaemon/natto-py"
  },
  "release_url": "https://pypi.org/project/natto-py/1.0.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a tasty python binding with mecab(ffi-based, no swig or compiler necessary)",
  "version": "1.0.1",
  "releases": [],
  "developers": [
    "brooke_m",
    "buruzaemon@gmail.com"
  ],
  "kwds": "_natto \u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0 natto japanese mecab_dictionary_info_t",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_natto_py",
  "homepage": "https://github.com/buruzaemon/natto-py",
  "release_count": 23,
  "dependency_ids": []
}