{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: markup :: xml"
  ],
  "description": "dict2xml\n========\n\nsuper simple utility to convert a python dictionary into an xml string\n\ninstallation\n------------\n\ninstall using pip::\n\n  > python -m pip install dict2xml\n\nexample\n-------\n\n.. code-block:: python\n\n  from dict2xml import dict2xml\n\n  data = {\n    'a': 1,\n    'b': [2, 3],\n    'c': {\n      'd': [\n        {'p': 9},\n        {'o': 10}\n      ],\n      'e': 7\n    }\n  }\n\n  print dict2xml(data, wrap=\"all\", indent=\"  \")\n\noutput\n------\n\n.. code-block:: xml\n\n  <all>\n    <a>1</a>\n    <b>2</b>\n    <b>3</b>\n    <c>\n      <d>\n        <p>9</p>\n      </d>\n      <d>\n        <o>10</o>\n      </d>\n      <e>7</e>\n    </c>\n  </all>\n\nmethods\n-------\n\n``dict2xml.dict2xml(data, *args, **kwargs)``\n    equivalent to:\n\n    .. code-block:: python\n\n        dict2xml.converter(*args, **kwargs).build(data)\n\n``dict2xml.converter(wrap=\"\", indent=\"  \", newlines=true)``\n    knows how to convert a dictionary into an xml string\n\n    * wrap: wraps the entire tree in this tag\n    * indent: amount to prefix each line for each level of nesting\n    * newlines: whether or not to use newlines\n\n``dict2xml.converter.build(data, iterables_repeat_wrap=true, closed_tags_for=none)``\n    instance method on converter that takes in the data and creates the xml string\n\n    * iterables_repeat_wrap - when false the key the array is in will be repeated\n    * closed_tags_for - an array of values that will produce self closing tags\n\nself closing tags\n-----------------\n\nto produce self closing tags (like ``<item/>``) then the ``build`` method must\nbe given a list of values under ``closed_tags_for``. for example, if you want\n``none`` to produce a closing tag then:\n\n.. code-block:: python\n\n    example = {\n        \"item1\": none,\n        \"item2\": {\"string1\": \"\", \"string2\": none},\n        \"item3\": \"special\",\n    }\n\n    result = converter(\"\").build(example, closed_tags_for=[none])\n    assert result == dedent(\"\"\"\n        <item1/>\n        <item2>\n            <string1></string1>\n            <string2/>\n        </item2>\n        <item3>special</item3>\n    \"\"\").strip())\n\nhere only ``string2`` gets a self closing tag because it has data of ``none``,\nwhich has been designated as special.\n\nif you want to dynamically work out which tags should be self closing then you\nmay provide an object that implements ``__eq__`` and do your logic there.\n\nlimitations\n-----------\n\n* no attributes on elements\n* currently no explicit way to hook into how to cope with your custom data\n* currently no way to insert an xml declaration line\n\nchangelog\n---------\n\n1.7.3 - 25 feb 2023\n    * this version has no changes to the installed code.\n    * this release converts to hatch for packaging and adds a wheel to the\n      package on pypi.\n    * ci will now run against python 3.11 as well\n\n1.7.2 - 18 oct 2022\n    * this version has no changes to the installed code.\n    * this release adds the tests to the source distribution put onto pypi.\n\n1.7.1 - 16 feb 2022\n    * adding an option to have self closing tags when the value for that\n      tag equals certain values\n\n1.7.0 - 16 april, 2020\n    * use collections.abc to avoid deprecation warning. thanks @mangin.\n    * this library no longer supports python2 and is only supported for\n      python3.6+. note that the library should still work in python3.5 as i\n      have not used f-strings, but the framework i use for the tests is only 3.6+.\n\n1.6.1 - august 27, 2019\n    * include readme and license in the package\n\n1.6 - april 27, 2018\n    * no code changes\n    * changed the licence to mit\n    * added more metadata to pypi\n    * enabled travis ci\n    * updated the tests slightly\n\n1.5\n    * no changelog was kept before this point.\n\ndevelopment\n-----------\n\nto enter a virtualenv with dict2xml and dev requirements installed run::\n\n    > source run.sh activate\n\ntests may be run with::\n\n    > ./test.sh \n\nor::\n\n    > ./run.sh tox\n\nlinting and formatting is via::\n\n    > ./format\n    > ./lint\n\npython black will work on the tests as long as ``nose_of_yeti_black_compat=true``\nand the correct version of black is available. this is true if your editor\nis opened in the same terminal session after sourcing run.sh or if\nyou make sure that environment variable is set and the editor is using the\nvirtualenv made by running or sourcing ``run.sh`` (``tools/venv/.python``)\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "dict2xml",
  "package_url": "https://pypi.org/project/dict2xml/",
  "project_url": "https://pypi.org/project/dict2xml/",
  "project_urls": {
    "Homepage": "http://github.com/delfick/python-dict2xml"
  },
  "release_url": "https://pypi.org/project/dict2xml/1.7.3/",
  "requires_dist": [
    "noseofyeti[black]==2.4.1; extra == 'tests'",
    "pytest==7.2.1; extra == 'tests'"
  ],
  "requires_python": ">=3.5",
  "summary": "small utility to convert a python dictionary into an xml string",
  "version": "1.7.3",
  "releases": [],
  "developers": [
    "stephen@delfick.com"
  ],
  "kwds": "dict2xml xml python2 python dictionary",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_dict2xml",
  "homepage": "",
  "release_count": 12,
  "dependency_ids": [
    "pypi_noseofyeti",
    "pypi_pytest"
  ]
}