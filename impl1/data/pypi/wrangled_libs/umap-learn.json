{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: c",
    "programming language :: python",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering",
    "topic :: software development"
  ],
  "description": ".. -*- mode: rst -*-\n\n.. image:: doc/logo_large.png\n  :width: 600\n  :alt: umap logo\n  :align: center\n\n|pypi_version|_ |pypi_downloads|_\n\n|conda_version|_ |conda_downloads|_\n\n|license|_ |build_status|_ |coverage|_\n\n|docs|_ |joss_paper|_\n\n.. |pypi_version| image:: https://img.shields.io/pypi/v/umap-learn.svg\n.. _pypi_version: https://pypi.python.org/pypi/umap-learn/\n\n.. |pypi_downloads| image:: https://pepy.tech/badge/umap-learn/month\n.. _pypi_downloads: https://pepy.tech/project/umap-learn\n\n.. |conda_version| image:: https://anaconda.org/conda-forge/umap-learn/badges/version.svg\n.. _conda_version: https://anaconda.org/conda-forge/umap-learn\n\n.. |conda_downloads| image:: https://anaconda.org/conda-forge/umap-learn/badges/downloads.svg\n.. _conda_downloads: https://anaconda.org/conda-forge/umap-learn\n\n.. |license| image:: https://img.shields.io/pypi/l/umap-learn.svg\n.. _license: https://github.com/lmcinnes/umap/blob/master/license.txt\n\n.. |build_status| image:: https://dev.azure.com/tutteinstitute/build-pipelines/_apis/build/status/lmcinnes.umap?branchname=master\n.. _build_status: https://dev.azure.com/tutteinstitute/build-pipelines/_build/latest?definitionid=2&branchname=master\n\n.. |coverage| image:: https://coveralls.io/repos/github/lmcinnes/umap/badge.svg\n.. _coverage: https://coveralls.io/github/lmcinnes/umap\n\n.. |docs| image:: https://readthedocs.org/projects/umap-learn/badge/?version=latest\n.. _docs: https://umap-learn.readthedocs.io/en/latest/?badge=latest\n\n.. |joss_paper| image:: http://joss.theoj.org/papers/10.21105/joss.00861/status.svg\n.. _joss_paper: https://doi.org/10.21105/joss.00861\n\n====\numap\n====\n\nuniform manifold approximation and projection (umap) is a dimension reduction\ntechnique that can be used for visualisation similarly to t-sne, but also for\ngeneral non-linear dimension reduction. the algorithm is founded on three\nassumptions about the data:\n\n1. the data is uniformly distributed on a riemannian manifold;\n2. the riemannian metric is locally constant (or can be approximated as such);\n3. the manifold is locally connected.\n\nfrom these assumptions it is possible to model the manifold with a fuzzy\ntopological structure. the embedding is found by searching for a low dimensional\nprojection of the data that has the closest possible equivalent fuzzy\ntopological structure.\n\nthe details for the underlying mathematics can be found in\n`our paper on arxiv <https://arxiv.org/abs/1802.03426>`_:\n\nmcinnes, l, healy, j, *umap: uniform manifold approximation and projection\nfor dimension reduction*, arxiv e-prints 1802.03426, 2018\n\nthe important thing is that you don't need to worry about that\u2014you can use\numap right now for dimension reduction and visualisation as easily as a drop\nin replacement for scikit-learn's t-sne.\n\ndocumentation is `available via read the docs <https://umap-learn.readthedocs.io/>`_.\n\n**new: this package now also provides support for densmap.** the densmap algorithm augments umap\nto preserve local density information in addition to the topological structure of the data.\ndetails of this method are described in the following `paper <https://doi.org/10.1038/s41587-020-00801-7>`_:\n\nnarayan, a, berger, b, cho, h, *assessing single-cell transcriptomic variability\nthrough density-preserving data visualization*, nature biotechnology, 2021\n\n----------\ninstalling\n----------\n\numap depends upon ``scikit-learn``, and thus ``scikit-learn``'s dependencies\nsuch as ``numpy`` and ``scipy``. umap adds a requirement for ``numba`` for\nperformance reasons. the original version used cython, but the improved code\nclarity, simplicity and performance of numba made the transition necessary.\n\nrequirements:\n\n* python 3.6 or greater\n* numpy\n* scipy\n* scikit-learn\n* numba\n* tqdm\n* `pynndescent <https://github.com/lmcinnes/pynndescent>`_\n\nrecommended packages:\n\n* for plotting\n   * matplotlib\n   * datashader\n   * holoviews\n* for parametric umap\n   * tensorflow > 2.0.0\n\n**install options**\n\nconda install, via the excellent work of the conda-forge team:\n\n.. code:: bash\n\n    conda install -c conda-forge umap-learn\n\nthe conda-forge packages are available for linux, os x, and windows 64 bit.\n\npypi install, presuming you have numba and sklearn and all its requirements\n(numpy and scipy) installed:\n\n.. code:: bash\n\n    pip install umap-learn\n\nif you wish to use the plotting functionality you can use\n\n.. code:: bash\n\n    pip install umap-learn[plot]\n\nto install all the plotting dependencies.\n\nif you wish to use parametric umap, you need to install tensorflow, which can be\ninstalled either using the instructions at https://www.tensorflow.org/install\n(reccomended) or using\n\n.. code:: bash\n\n    pip install umap-learn[parametric_umap]\n\nfor a cpu-only version of tensorflow.\n\nif you're on an x86 processor, you can also optionally install `tbb`, which will\nprovide additional cpu optimizations:\n\n.. code:: bash\n\n    pip install umap-learn[tbb]\n\nif pip is having difficulties pulling the dependencies then we'd suggest installing\nthe dependencies manually using anaconda followed by pulling umap from pip:\n\n.. code:: bash\n\n    conda install numpy scipy\n    conda install scikit-learn\n    conda install numba\n    pip install umap-learn\n\nfor a manual install get this package:\n\n.. code:: bash\n\n    wget https://github.com/lmcinnes/umap/archive/master.zip\n    unzip master.zip\n    rm master.zip\n    cd umap-master\n\noptionally, install the requirements through conda:\n\n.. code:: bash\n\n    conda install scikit-learn numba\n\nthen install the package\n\n.. code:: bash\n\n    python -m pip install -e .\n\n---------------\nhow to use umap\n---------------\n\nthe umap package inherits from sklearn classes, and thus drops in neatly\nnext to other sklearn transformers with an identical calling api.\n\n.. code:: python\n\n    import umap\n    from sklearn.datasets import load_digits\n\n    digits = load_digits()\n\n    embedding = umap.umap().fit_transform(digits.data)\n\nthere are a number of parameters that can be set for the umap class; the\nmajor ones are as follows:\n\n -  ``n_neighbors``: this determines the number of neighboring points used in\n    local approximations of manifold structure. larger values will result in\n    more global structure being preserved at the loss of detailed local\n    structure. in general this parameter should often be in the range 5 to\n    50, with a choice of 10 to 15 being a sensible default.\n\n -  ``min_dist``: this controls how tightly the embedding is allowed compress\n    points together. larger values ensure embedded points are more evenly\n    distributed, while smaller values allow the algorithm to optimise more\n    accurately with regard to local structure. sensible values are in the\n    range 0.001 to 0.5, with 0.1 being a reasonable default.\n\n -  ``metric``: this determines the choice of metric used to measure distance\n    in the input space. a wide variety of metrics are already coded, and a user\n    defined function can be passed as long as it has been jitd by numba.\n\nan example of making use of these options:\n\n.. code:: python\n\n    import umap\n    from sklearn.datasets import load_digits\n\n    digits = load_digits()\n\n    embedding = umap.umap(n_neighbors=5,\n                          min_dist=0.3,\n                          metric='correlation').fit_transform(digits.data)\n\numap also supports fitting to sparse matrix data. for more details\nplease see `the umap documentation <https://umap-learn.readthedocs.io/>`_\n\n----------------\nbenefits of umap\n----------------\n\numap has a few signficant wins in its current incarnation.\n\nfirst of all umap is *fast*. it can handle large datasets and high\ndimensional data without too much difficulty, scaling beyond what most t-sne\npackages can manage. this includes very high dimensional sparse datasets. umap\nhas successfully been used directly on data with over a million dimensions.\n\nsecond, umap scales well in embedding dimension\u2014it isn't just for\nvisualisation! you can use umap as a general purpose dimension reduction\ntechnique as a preliminary step to other machine learning tasks. with a\nlittle care it partners well with the `hdbscan\n<https://github.com/scikit-learn-contrib/hdbscan>`_ clustering library (for\nmore details please see `using umap for clustering\n<https://umap-learn.readthedocs.io/en/latest/clustering.html>`_).\n\nthird, umap often performs better at preserving some aspects of global structure\nof the data than most implementations of t-sne. this means that it can often\nprovide a better \"big picture\" view of your data as well as preserving local neighbor\nrelations.\n\nfourth, umap supports a wide variety of distance functions, including\nnon-metric distance functions such as *cosine distance* and *correlation\ndistance*. you can finally embed word vectors properly using cosine distance!\n\nfifth, umap supports adding new points to an existing embedding via\nthe standard sklearn ``transform`` method. this means that umap can be\nused as a preprocessing transformer in sklearn pipelines.\n\nsixth, umap supports supervised and semi-supervised dimension reduction.\nthis means that if you have label information that you wish to use as\nextra information for dimension reduction (even if it is just partial\nlabelling) you can do that\u2014as simply as providing it as the ``y``\nparameter in the fit method.\n\nseventh, umap supports a variety of additional experimental features including: an\n\"inverse transform\" that can approximate a high dimensional sample that would map to\na given position in the embedding space; the ability to embed into non-euclidean\nspaces including hyperbolic embeddings, and embeddings with uncertainty; very\npreliminary support for embedding dataframes also exists.\n\nfinally, umap has solid theoretical foundations in manifold learning\n(see `our paper on arxiv <https://arxiv.org/abs/1802.03426>`_).\nthis both justifies the approach and allows for further\nextensions that will soon be added to the library.\n\n------------------------\nperformance and examples\n------------------------\n\numap is very efficient at embedding large high dimensional datasets. in\nparticular it scales well with both input dimension and embedding dimension.\nfor the best possible performance we recommend installing the nearest neighbor\ncomputation library `pynndescent <https://github.com/lmcinnes/pynndescent>`_ .\numap will work without it, but if installed it will run faster, particularly on\nmulticore machines.\n\nfor a problem such as the 784-dimensional mnist digits dataset with\n70000 data samples, umap can complete the embedding in under a minute (as\ncompared with around 45 minutes for scikit-learn's t-sne implementation).\ndespite this runtime efficiency, umap still produces high quality embeddings.\n\nthe obligatory mnist digits dataset, embedded in 42\nseconds (with pynndescent installed and after numba jit warmup)\nusing a 3.1 ghz intel core i7 processor (n_neighbors=10, min_dist=0.001):\n\n.. image:: images/umap_example_mnist1.png\n    :alt: umap embedding of mnist digits\n\nthe mnist digits dataset is fairly straightforward, however. a better test is\nthe more recent \"fashion mnist\" dataset of images of fashion items (again\n70000 data sample in 784 dimensions). umap\nproduced this embedding in 49 seconds (n_neighbors=5, min_dist=0.1):\n\n.. image:: images/umap_example_fashion_mnist1.png\n    :alt: umap embedding of \"fashion mnist\"\n\nthe uci shuttle dataset (43500 sample in 8 dimensions) embeds well under\n*correlation* distance in 44 seconds (note the longer time\nrequired for correlation distance computations):\n\n.. image:: images/umap_example_shuttle.png\n    :alt: umap embedding the uci shuttle dataset\n\nthe following is a densmap visualization of the mnist digits dataset with 784 features\nbased on the same parameters as above (n_neighbors=10, min_dist=0.001). densmap reveals\nthat the cluster corresponding to digit 1 is noticeably denser, suggesting that\nthere are fewer degrees of freedom in the images of 1 compared to other digits.\n\n.. image:: images/densmap_example_mnist.png\n    :alt: densmap embedding of the mnist dataset\n\n--------\nplotting\n--------\n\numap includes a subpackage ``umap.plot`` for plotting the results of umap embeddings.\nthis package needs to be imported separately since it has extra requirements\n(matplotlib, datashader and holoviews). it allows for fast and simple plotting and\nattempts to make sensible decisions to avoid overplotting and other pitfalls. an\nexample of use:\n\n.. code:: python\n\n    import umap\n    import umap.plot\n    from sklearn.datasets import load_digits\n\n    digits = load_digits()\n\n    mapper = umap.umap().fit(digits.data)\n    umap.plot.points(mapper, labels=digits.target)\n\nthe plotting package offers basic plots, as well as interactive plots with hover\ntools and various diagnostic plotting options. see the documentation for more details.\n\n---------------\nparametric umap\n---------------\n\nparametric umap provides support for training a neural network to learn a umap based\ntransformation of data. this can be used to support faster inference of new unseen\ndata, more robust inverse transforms, autoencoder versions of umap and\nsemi-supervised classification (particularly for data well separated by umap and very\nlimited amounts of labelled data). see the\n`documentation of parametric umap <https://umap-learn.readthedocs.io/en/0.5dev/parametric_umap.html>`_\nor the\n`example notebooks <https://github.com/lmcinnes/umap/tree/master/notebooks/parametric_umap>`_\nfor more.\n\n\n-------\ndensmap\n-------\n\nthe densmap algorithm augments umap to additionally preserve local density information\nin addition to the topological structure captured by umap. one can easily run densmap\nusing the umap package by setting the ``densmap`` input flag:\n\n.. code:: python\n\n    embedding = umap.umap(densmap=true).fit_transform(data)\n\nthis functionality is built upon the densmap `implementation <https://github.com/hhcho/densvis>`_ provided by the developers\nof densmap, who also contributed to integrating densmap into the umap package.\n\ndensmap inherits all of the parameters of umap. the following is a list of additional\nparameters that can be set for densmap:\n\n - ``dens_frac``: this determines the fraction of epochs (a value between 0 and 1) that will include the density-preservation term in the optimization objective. this parameter is set to 0.3 by default. note that densmap switches density optimization on after an initial phase of optimizing the embedding using umap.\n\n - ``dens_lambda``: this determines the weight of the density-preservation objective. higher values prioritize density preservation, and lower values (closer to zero) prioritize the umap objective. setting this parameter to zero reduces the algorithm to umap. default value is 2.0.\n\n - ``dens_var_shift``: regularization term added to the variance of local densities in the embedding for numerical stability. we recommend setting this parameter to 0.1, which consistently works well in many settings.\n\n - ``output_dens``: when this flag is true, the call to ``fit_transform`` returns, in addition to the embedding, the local radii (inverse measure of local density defined in the `densmap paper <https://doi.org/10.1101/2020.05.12.077776>`_) for the original dataset and for the embedding. the output is a tuple ``(embedding, radii_original, radii_embedding)``. note that the radii are log-transformed. if false, only the embedding is returned. this flag can also be used with umap to explore the local densities of umap embeddings. by default this flag is false.\n\nfor densmap we recommend larger values of ``n_neighbors`` (e.g. 30) for reliable estimation of local density.\n\nan example of making use of these options (based on a subsample of the mnist_784 dataset):\n\n.. code:: python\n\n    import umap\n    from sklearn.datasets import fetch_openml\n    from sklearn.utils import resample\n\n    digits = fetch_openml(name='mnist_784')\n    subsample, subsample_labels = resample(digits.data, digits.target, n_samples=7000,\n                                           stratify=digits.target, random_state=1)\n\n    embedding, r_orig, r_emb = umap.umap(densmap=true, dens_lambda=2.0, n_neighbors=30,\n                                         output_dens=true).fit_transform(subsample)\n\nsee `the documentation <https://umap-learn.readthedocs.io/en/0.5dev/densmap_demo.html>`_ for more details.\n\n----------------\nhelp and support\n----------------\n\ndocumentation is at `read the docs <https://umap-learn.readthedocs.io/>`_.\nthe documentation `includes a faq <https://umap-learn.readthedocs.io/en/latest/faq.html>`_ that\nmay answer your questions. if you still have questions then please\n`open an issue <https://github.com/lmcinnes/umap/issues/new>`_\nand i will try to provide any help and guidance that i can.\n\n--------\ncitation\n--------\n\nif you make use of this software for your work we would appreciate it if you\nwould cite the paper from the journal of open source software:\n\n.. code:: bibtex\n\n    @article{mcinnes2018umap-software,\n      title={umap: uniform manifold approximation and projection},\n      author={mcinnes, leland and healy, john and saul, nathaniel and grossberger, lukas},\n      journal={the journal of open source software},\n      volume={3},\n      number={29},\n      pages={861},\n      year={2018}\n    }\n\nif you would like to cite this algorithm in your work the arxiv paper is the\ncurrent reference:\n\n.. code:: bibtex\n\n   @article{2018arxivumap,\n        author = {{mcinnes}, l. and {healy}, j. and {melville}, j.},\n        title = \"{umap: uniform manifold approximation\n        and projection for dimension reduction}\",\n        journal = {arxiv e-prints},\n        archiveprefix = \"arxiv\",\n        eprint = {1802.03426},\n        primaryclass = \"stat.ml\",\n        keywords = {statistics - machine learning,\n                    computer science - computational geometry,\n                    computer science - learning},\n        year = 2018,\n        month = feb,\n   }\n\nadditionally, if you use the densmap algorithm in your work please cite the following reference:\n\n.. code:: bibtex\n\n    @article {nbc2020,\n        author = {narayan, ashwin and berger, bonnie and cho, hyunghoon},\n        title = {assessing single-cell transcriptomic variability through density-preserving data visualization},\n        journal = {nature biotechnology},\n        year = {2021},\n        doi = {10.1038/s41587-020-00801-7},\n        publisher = {springer nature},\n        url = {https://doi.org/10.1038/s41587-020-00801-7},\n        eprint = {https://www.biorxiv.org/content/early/2020/05/14/2020.05.12.077776.full.pdf},\n    }\n\nif you use the parametric umap algorithm in your work please cite the following reference:\n\n.. code:: bibtex\n\n    @article {smg2020,\n        author = {sainburg, tim and mcinnes, leland and gentner, timothy q.},\n        title = {parametric umap: learning embeddings with deep neural networks for representation and semi-supervised learning},\n        journal = {arxiv e-prints},\n        archiveprefix = \"arxiv\",\n        eprint = {2009.12981},\n        primaryclass = \"stat.ml\",\n        keywords = {statistics - machine learning,\n                    computer science - computational geometry,\n                    computer science - learning},\n        year = 2020,\n        }\n\n\n-------\nlicense\n-------\n\nthe umap package is 3-clause bsd licensed.\n\nwe would like to note that the umap package makes heavy use of\nnumfocus sponsored projects, and would not be possible without\ntheir support of those projects, so please `consider contributing to numfocus <https://www.numfocus.org/membership>`_.\n\n------------\ncontributing\n------------\n\ncontributions are more than welcome! there are lots of opportunities\nfor potential projects, so please get in touch if you would like to\nhelp out. everything from code to notebooks to\nexamples and documentation are all *equally valuable* so please don't feel\nyou can't contribute. to contribute please\n`fork the project <https://github.com/lmcinnes/umap/issues#fork-destination-box>`_\nmake your changes and\nsubmit a pull request. we will do our best to work through any issues with\nyou and get your code merged into the main branch.\n\n\n",
  "docs_url": null,
  "keywords": "dimension reduction t-sne manifold",
  "license": "bsd",
  "name": "umap-learn",
  "package_url": "https://pypi.org/project/umap-learn/",
  "project_url": "https://pypi.org/project/umap-learn/",
  "project_urls": {
    "Homepage": "http://github.com/lmcinnes/umap"
  },
  "release_url": "https://pypi.org/project/umap-learn/0.5.5/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "uniform manifold approximation and projection",
  "version": "0.5.5",
  "releases": [],
  "developers": [
    "leland.mcinnes@gmail.com",
    "leland_mcinnes"
  ],
  "kwds": "umap parametric_umap umap_example_mnist1 umap_example_fashion_mnist1 pypi_version",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_umap_learn",
  "homepage": "http://github.com/lmcinnes/umap",
  "release_count": 39,
  "dependency_ids": []
}