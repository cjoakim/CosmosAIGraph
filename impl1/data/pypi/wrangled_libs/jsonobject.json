{
  "classifiers": [
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# jsonobject\n\n[![build status](https://github.com/dimagi/jsonobject/actions/workflows/tests.yml/badge.svg)](https://github.com/dimagi/jsonobject/actions/workflows/tests.yml)\n[![downloads](https://pepy.tech/badge/jsonobject/month)](https://pepy.tech/project/jsonobject)\n[![supported versions](https://img.shields.io/pypi/pyversions/jsonobject.svg)](https://pypi.org/project/jsonobject)\n[![contributors](https://img.shields.io/github/contributors/dimagi/jsonobject.svg)](https://github.com/dimagi/jsonobject/graphs/contributors)\n\njsonobject is a python library for handling deeply nested json objects\nas well-schema'd python objects.\n\njsonobject is made by [dimagi](https://www.dimagi.com/), where we build, use, and contribute to oss in our mission to reduce inequity in the world.\n\njsonobject is inspired by and largely api compatible with\nthe `document`/`documentschema` portion of `couchdbkit`.\nbecause jsonobject is not only simpler and standalone, but also faster,\nwe also maintain a fork of `couchdbkit`, [jsonobject-couchdbkit](https://pypi.python.org/pypi/jsonobject-couchdbkit),\nthat is backed by `jsonobject` and works seamlessly as a swap-in replacement\nfor the main library.\n\nit is used heavily in [commcare hq](https://www.commcarehq.org/) ([source](https://github.com/dimagi/commcare-hq)),\nand the api is largely stable,\nbut more advanced features may change in the future.\n\n## getting started\n\nto install using pip, simply run\n\n```\npip install jsonobject\n```\n\n\n### example\n\nthe code below defines a simple user model, and its natural mapping to json.\n\n```python\nfrom jsonobject import *\n\nclass user(jsonobject):\n    username = stringproperty()\n    name = stringproperty()\n    active = booleanproperty(default=false)\n    date_joined = datetimeproperty()\n    tags = listproperty(unicode)\n\n```\n\nonce it is defined, it can be used to wrap or produce deserialized json.\n\n```python\n>>> user1 = user(\n    name='john doe',\n    username='jdoe',\n    date_joined=datetime.datetime.utcnow(),\n    tags=['generic', 'anonymous']\n)\n>>> user1.to_json()\n{\n    'name': u'john doe',\n    'username': u'jdoe',\n    'active': false,\n    'date_joined': '2013-08-05t02:46:58z',\n    'tags': [u'generic', u'anonymous']\n}\n```\n\nnotice that the datetime is converted to an iso format string in json, but is a real datetime on the object:\n\n```python\n>>> user1.date_joined\ndatetime.datetime(2013, 8, 5, 2, 46, 58)\n```\n\n### the jsonobject constructor\n\na jsonobject subclass that has been defined as `user` above\ncomes with a lot of built-in functionality.\nthe basic operations are\n\n1. make a new object from deserialized json (e.g. the output of `json.loads`)\n2. construct a new object with given values\n3. modify an object\n4. dump to deserialized json (e.g. the input of `json.dumps`)\n\n1 & 2 are accomplished with the constructor. there are two main ways to call\nthe constructor:\n\n```python\nuser(\n    name='john doe',\n    username='jdoe',\n    date_joined=datetime.datetime.utcnow(),\n    tags=['generic', 'anonymous']\n)\n```\n\nas above (satisfies #2) and\n\n```python\nuser({\n    'name': u'john doe',\n    'username': u'jdoe',\n    'active': false,\n    'date_joined': '2013-08-05t02:46:58z',\n    'tags': [u'generic', u'anonymous']\n})\n```\n\n(satisfies #1). these two styles can also be mixed and matched:\n\n```python\nuser({\n    'name': u'john doe',\n    'username': u'jdoe',\n    'active': false,\n    'tags': [u'generic', u'anonymous']\n}, date_joined=datetime.datetime.utcnow())\n```\n\nnotice how datetimes are stored as strings in the deserialized json, but as\n`datetime.datetime`s in the nice python object\u2014we will refer to these as the\n\"json\" representation and the \"python\" representation, or alternatively the\n\"unwrapped\" representation and the \"wrapped\" representation.\n\n**gotcha**.\nwhen calling the constructor, remember that the keyword argument style\nrequires you to pass in the \"python\" representation (e.g. a `datetime`)\nwhile the json-wrapping style of passing in a `dict` requires you to give it\nin the \"json\" representation (e.g. a datetime-formatted string).\n\n## property types\n\nthere are two main kinds of property types:\nscalar types (like string, bool, int, datetime, etc.)\nand container types (list, dict, set).\nthey are dealt with separately below.\n\n### scalar types\n\nall scalar properties can take the value `none` in addition to\nthe values particular to their type (strings, bools, etc).\nif set to the wrong type,\nproperties raise a `jsonobject.exceptions.badvalueerror`:\n\n```python\nclass foo(jsonobject.jsonobject):\n    b = jsonobject.booleanproperty()\n```\n\n```python\n>>> foo(b=0)\ntraceback (most recent call last):\n  [...]\njsonobject.exceptions.badvalueerror: 0 not of type <type 'bool'>\n```\n\n#### `jsonobject.stringproperty`\n\nmaps to a `unicode`. usage:\n\n```python\nclass foo(jsonobject.jsonobject):\n    s = jsonobject.stringproperty()\n```\n\nif you set it to an ascii `str` it will implicitly convert to `unicode`:\n\n```python\n>>> foo(s='hi')  # converts to unicode\nfoo(s=u'hi')\n```\n\nif you set it to a non-ascii `str`, it will fail with a `unicodedecodeerror`:\n\n```python\n>>> foo(s='\\xff')\ntraceback (most recent call last):\n  [...]\nunicodedecodeerror: 'ascii' codec can't decode byte 0xff in position 0: ordinal not in range(128)\n```\n\n#### `jsonobject.booleanproperty`\n\nmaps to a `bool`.\n\n\n#### `jsonobject.integerproperty`\n\nmaps to an `int` or `long`.\n\n#### `jsonobject.floatproperty`\n\nmaps to a `float`.\n\n#### `jsonobject.decimalproperty`\n\nmaps to a `decimal.decimal` and stored as a json string.\nthis type, unlike `floatproperty`,\nstores the \"human\" representation of the digits. usage:\n\n```python\nclass foo(jsonobject.jsonobject):\n    number = jsonobject.decimalproperty()\n```\n\nif you set it to an `int` or `float`, it will implicitly convert to `decimal`:\n\n```python\n>>> foo(number=1)\nfoo(number=decimal('1'))\n>>> foo(number=1.2)\nfoo(number=decimal('1.2'))\n```\n\nif you set it to a `str` or `unicode`, however, it raises an `assertionerror`:\n\n```python\n>>> foo(number='1.0')\ntraceback (most recent call last):\n  [...]\nassertionerror\n```\n\ntodo: this should really raise a `badvalueerror`.\n\nif you pass in json in which the decimal value is a `str` or `unicode`,\nbut it is malformed, it throws the same errors as `decimal.decimal`.\n\n```python\n>>> foo({'number': '1.0'})\nfoo(number=decimal('1.0'))\n>>> foo({'number': '1.0.0'})\ntraceback (most recent call last):\n  [...]\ndecimal.invalidoperation: invalid literal for decimal: '1.0.0'\n```\n\n#### `jsonobject.dateproperty`\n\nmaps to a `datetime.date` and stored as a json string of the format\n`'%y-%m-%d'`. usage:\n\n```python\nclass foo(jsonobject.jsonobject):\n    date = jsonobject.dateproperty()\n```\n\nwrapping a badly formatted string raises a `badvalueerror`:\n\n```python\n>>> foo({'date': 'foo'})\ntraceback (most recent call last):\n  [...]\njsonobject.exceptions.badvalueerror: 'foo' is not a date-formatted string\n```\n\n#### `jsonobject.datetimeproperty`\n\nmaps to a timezone-unaware `datetime.datetime`\nand stored as a json string of the format\n`'%y-%m-%dt%h:%m:%sz'`.\n\nwhile it works perfectly with good inputs, it is extremely sloppy when it comes\nto dealing with inputs that don't match the exact specified format.\nrather than matching stricty, it simply truncates the string\nto the first 19 characters and tries to parse that as `'%y-%m-%dt%h:%m:%s'`.\nthis ignores both microseconds and, even worse, *the timezone*.\nthis is a holdover from `couchdbkit`.\n\nin newer versions of jsonboject, you may optionally specify\na `datetimeproperty` as `exact`:\n\n```python\nclass foo(jsonobject.jsonobject):\n    date = jsonobject.datetimeproperty(exact=true)\n```\n\nthis provides a much cleaner conversion model\nthat has the following properties:\n\n1. it preserves microseconds\n2. the incoming json representation **must** match `'%y-%m-%dt%h:%m:%s.%fz'`\n   exactly. (this is similar to the default output,\n   except for the mandatory 6 decimal places, i.e. milliseconds.)\n3. representations that don't match exactly will be rejected with a\n   `badvalueerror`.\n\n**recommendation**:\nif you are not locked into `couchdbkit`'s earlier bad behavior,\nyou should **always** use the `exact=true` flag on `datetimeproperty`s\nand `timeproperty`s (below).\n\n#### `jsonobject.timeproperty`\n\nmaps to a `datetime.time`, stored as a json string of the format\n`'%h:%m:%s'`.\n\nto get access to milliseconds and strict behavior, use the `exact=true` setting\nwhich strictly accepts the format `'%h:%m:%s.%f'`. this is always recommended.\nfor more information please read the previous section on `datetimeproperty`.\n\n### container types\n\ncontainer types generally take a first argument, `item_type`,\nspecifying the type of the contained objects.\n\n\n#### `jsonobject.objectproperty(item_type)`\n\nmaps to a `dict` that has a schema specified by `item_type`,\nwhich must be itself a subclass of `jsonobject`. usage:\n\n```python\nclass bar(jsonobject.jsonobject):\n    name = jsonobject.stringproperty()\n\n\nclass foo(jsonobject.jsonobject):\n    bar = jsonobject.objectproperty(bar)\n```\n\nif not specified, it will be set to a new object with default values:\n\n```python\n>>> foo()\nfoo(bar=bar(name=none))\n```\n\nif you want it set to `none` you must do so explicitly.\n\n#### `jsonobject.listproperty(item_type)`\n\nmaps to a `list` with items of type `item_type`,\nwhich can be any of the following:\n\n- an _instance_ of a property class. this is the most flexible option,\n  and all validation (`required`, etc.) will be done as as specified by the property instance.\n- a property class, which will be instantiated with `required=true`\n- one of their corresponding python types (i.e. `int` for `integerproperty`, etc.)\n- a `jsonobject` subclass\n\nnote that a property _class_ (as well as the related python type syntax)\nwill be instantiated with `required=true`,\nso `listproperty(integerproperty)` and `listproperty(int)` do not allow `none`, and\n`listproperty(integerproperty())` _does_ allow `none`.\n\nthe serialization behavior of whatever item type is given is recursively\napplied to each member of the list.\n\nif not specified, it will be set to an empty list.\n\n#### `jsonobject.setproperty(item_type)`\n\nmaps to a `set` and stored as a list (with only unique elements).\notherwise its behavior is very much like `listproperty`'s.\n\n#### `jsonobject.dictproperty(item_type)`\n\nmaps to a `dict` with string keys and values specified by `item_type`.\notherwise its behavior is very much like `listproperty`'s.\n\nif not specified, it will be set to an empty dict.\n\n### other\n\n#### `jsonobject.defaultproperty()`\n\nthis flexibly wraps any valid json, including all scalar and container types,\ndynamically detecting the value's type and treating it\nwith the corresponding property.\n\n## property options\n\ncertain parameters may be passed in to any property.\n\nfor example, `required` is one such parameter in the example below:\n\n```python\n\nclass user(jsonobject):\n    username = stringproperty(required=true)\n\n```\n\nhere is a complete list of properties:\n\n- `default`\n\n  specifies a default value for the property\n\n- `name`\n\n  the name of the property within the json representation\\*.\n  this defaults to the name of the python property, but you can override it\n  if you wish. this can be useful, for example, to get around conflicting\n  with python keywords:\n  ```python\n  >>> class route(jsonobject):\n  ...     from_ = stringproperty(name='from')\n  ...     to = stringproperty()  # name='to' by default\n  >>> route(from_='me', to='you').to_json()\n  {'from': u'me', 'to': u'you'}\n  ```\n  notice how an underscore is present in the python property name ('from_'),\n  but absent in the json property name ('from').\n\n\n  <small>\n  \\*if you're wondering how `stringproperty`'s `name` parameter\n  could possibly default to `to` in the example above,\n  when it doesn't have access to the `route` class's properties at init time,\n  you're completely right.\n  the behavior described is implemented in `jsonobject`'s `__metaclass__`,\n  which *does* have access to the `route` class's properties.\n  </small>\n\n- `choices`\n\n  a list of allowed values for the property.\n  (unless otherwise specified, `none` is also an allowed value.)\n\n- `required`\n\n  defaults to `false`.\n  for scalar properties `requires` means that the value `none` may not be used.\n  for container properties it means they may not be empty\n  or take the value `none`.\n\n- `exclude_if_none`\n\n  defaults to `false`. when set to true, this property will be excluded\n  from the json output when its value is falsey.\n  (note that currently this is at odds with the parameter's name,\n  since the condition is that it is falsey, not that it is `none`).\n\n- `validators`\n\n  a single validator function or list of validator functions.\n  each validator function should raise an exception on invalid input\n  and do nothing otherwise.\n\n- `verbose_name`\n\n  this property does nothing and was added to match couchdbkit's api.\n\n\n## performance comparison with couchdbkit\n\nin order to do a direct comparison with couchdbkit, the test suite includes a large sample schema originally written with couchdbkit. it is easy to swap in jsonobject for couchdbkit and run the tests with each. here are the results:\n\n```\n$ python -m unittest test.test_couchdbkit\n....\n----------------------------------------------------------------------\nran 4 tests in 1.403s\n\nok\n$ python -m unittest test.test_couchdbkit\n....\n----------------------------------------------------------------------\nran 4 tests in 0.153s\n\nok\n```\n\n## running tests\n\nyou must rebuild c files for the tests to pick up your changes.  try this for iterating:\n\n```\n$ python setup.py build_ext --inplace && python setup.py test\n```\n\n\n## recreating c source files\n\nfor any changes in the pyx files, the corresponding c files should be recompiled with\n\n```\n$ find jsonobject -iname '*.c' -delete\n$ find jsonobject -iname '*.so' -delete\n$ python setup.py build_ext --inplace\n```\n\nthese changes should be committed independently of the non-automated changes you made.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "jsonobject",
  "package_url": "https://pypi.org/project/jsonobject/",
  "project_url": "https://pypi.org/project/jsonobject/",
  "project_urls": {
    "Homepage": "https://github.com/dimagi/jsonobject"
  },
  "release_url": "https://pypi.org/project/jsonobject/2.1.0/",
  "requires_dist": [
    "six"
  ],
  "requires_python": "",
  "summary": "a library for dealing with json as python objects",
  "version": "2.1.0",
  "releases": [],
  "developers": [
    "danny_roberts",
    "droberts@dimagi.com"
  ],
  "kwds": "jsonobject json to_json jsonboject api",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_jsonobject",
  "homepage": "https://github.com/dimagi/jsonobject",
  "release_count": 53,
  "dependency_ids": [
    "pypi_six"
  ]
}