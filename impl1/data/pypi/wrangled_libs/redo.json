{
  "classifiers": [],
  "description": "redo - utilities to retry python callables\n==========================================\n\nintroduction\n************\n\nredo provides various means to add seamless ability to retry to any python callable. redo includes a plain function ``(redo.retry)``, a decorator ``(redo.retriable)``, and a context manager ``(redo.retrying)`` to enable you to integrate it in the best possible way for your project. as a bonus, a standalone interface is also included ``(\"retry\")``.\n\ninstallation\n************\n\nfor installing with pip, run following commands\n\n::\n\n    pip install redo\n\nhow to use\n**********\n\nbelow is the list of functions available\n\n* retrier\n* retry\n* retriable\n* retrying (contextmanager)\n\nretrier(attempts=5, sleeptime=10, max_sleeptime=300, sleepscale=1.5, jitter=1)\n------------------------------------------------------------------------------\n\na generator function that sleeps between retries, handles exponential back off and jitter. the action you are retrying is meant to run after retrier yields. at each iteration, we sleep for ``sleeptime + random.randint(-jitter, jitter)``. afterwards sleeptime is multiplied by sleepscale for the next iteration.\n\n**arguments detail:**    \n\n1. **attempts (int):** maximum number of times to try; defaults to 5\n2. **sleeptime (float):** how many seconds to sleep between tries; defaults to 60s (one minute)\n3. **max_sleeptime (float):** the longest we'll sleep, in seconds; defaults to 300s (five minutes)\n4. **sleepscale (float):** how much to multiply the sleep time by each iteration; defaults to 1.5\n5. **jitter (int):** random jitter to introduce to sleep time each iteration. the amount is chosen at random between ``[-jitter, +jitter]`` defaults to 1\n\n**output:** none, a maximum of ``attempts`` number of times\n\n**example:**\n\n::\n\n    >>> n = 0\n    >>> for _ in retrier(sleeptime=0, jitter=0):\n    ...     if n == 3:\n    ...         # we did the thing!\n    ...         break\n    ...     n += 1\n    >>> n\n    3\n    >>> n = 0\n    >>> for _ in retrier(sleeptime=0, jitter=0):\n    ...     if n == 6:\n    ...         # we did the thing!\n    ...         break\n    ...     n += 1\n    ... else:\n    ...     print(\"max tries hit\")\n    max tries hit\n\nretry(action, attempts=5, sleeptime=60, max_sleeptime=5 * 60, sleepscale=1.5, jitter=1, retry_exceptions=(exception,), cleanup=none, args=(), kwargs={})  \n--------------------------------------------------------------------------------------------------------------------------------------------------------\n\ncalls an action function until it succeeds, or we give up.\n\n**arguments detail:**  \n\n1. **action (callable):** the function to retry\n2. **attempts (int):** maximum number of times to try; defaults to 5\n3. **sleeptime (float):** how many seconds to sleep between tries; defaults to 60s (one minute)\n4. **max_sleeptime (float):** the longest we'll sleep, in seconds; defaults to 300s (five minutes)\n5. **sleepscale (float):** how much to multiply the sleep time by each iteration; defaults to 1.5\n6. **jitter (int):** random jitter to introduce to sleep time each iteration. the amount is chosen at random between ``[-jitter, +jitter]`` defaults to 1\n7. **retry_exceptions (tuple):** tuple of exceptions to be caught. if other exceptions are raised by ``action()``, then these are immediately re-raised to the caller.\n8. **cleanup (callable):** optional; called if one of ``retry_exceptions`` is caught. no arguments are passed to the cleanup function; if your cleanup requires arguments, consider using ``functools.partial`` or a ``lambda`` function.\n9. **args (tuple):** positional arguments to call ``action`` with\n10. **kwargs (dict):** keyword arguments to call ``action`` with\n\n**output:** whatever action(\\*args, \\*\\*kwargs) returns\n \n**output:** whatever action(\\*args, \\*\\*kwargs) raises. ``retry_exceptions`` are caught up until the last attempt, in which case they are re-raised.\n\n**example:**\n\n::\n\n    >>> count = 0\n    >>> def foo():\n    ...     global count\n    ...     count += 1\n    ...     print(count)\n    ...     if count < 3:\n    ...         raise valueerror(\"count is too small!\")\n    ...     return \"success!\"\n    >>> retry(foo, sleeptime=0, jitter=0)\n    1\n    2\n    3\n    'success!'\n\nretriable(\\*retry_args, \\*\\*retry_kwargs)\n-----------------------------------------\n\na decorator factory for ``retry()``. wrap your function in ``@retriable(...)`` to give it retry powers!\n\n**arguments detail:** same as for ``retry``, with the exception of ``action``, ``args``, and ``kwargs``, which are left to the normal function definition.\n\n**output:** a function decorator\n\n**example:**\n\n::\n\n    >>> count = 0\n    >>> @retriable(sleeptime=0, jitter=0)\n    ... def foo():\n    ...     global count\n    ...     count += 1\n    ...     print(count)\n    ...     if count < 3:\n    ...         raise valueerror(\"count too small\")\n    ...     return \"success!\"\n    >>> foo()\n    1\n    2\n    3\n    'success!'\n\nretrying(func, \\*retry_args, \\*\\*retry_kwargs)\n----------------------------------------------\n\na context manager for wrapping functions with retry functionality.\n\n**arguments detail:**   \n\n1. **func (callable):** the function to wrap other arguments as per ``retry``\n\n**output:** a context manager that returns ``retriable(func)`` on ``__enter__``\n\n**example:**\n\n::\n\n    >>> count = 0\n    >>> def foo():\n    ...     global count\n    ...     count += 1\n    ...     print(count)\n    ...     if count < 3:\n    ...         raise valueerror(\"count too small\")\n    ...     return \"success!\"\n    >>> with retrying(foo, sleeptime=0, jitter=0) as f:\n    ...     f()\n    1\n    2\n    3\n    'success!'\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "redo",
  "package_url": "https://pypi.org/project/redo/",
  "project_url": "https://pypi.org/project/redo/",
  "project_urls": {
    "Homepage": "https://github.com/mozilla-releng/redo"
  },
  "release_url": "https://pypi.org/project/redo/2.0.4/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "utilities to retry python callables.",
  "version": "2.0.4",
  "releases": [],
  "developers": [
    "ben@hearsum.ca",
    "ben_hearsum"
  ],
  "kwds": "retry_exceptions retry_args retry_kwargs retrying retry",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_redo",
  "homepage": "https://github.com/mozilla-releng/redo",
  "release_count": 15,
  "dependency_ids": []
}