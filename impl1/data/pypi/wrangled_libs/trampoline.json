{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7"
  ],
  "description": "================================\ntrampoline - unlimited recursion\n================================\nsimple and tiny yield-based trampoline implementation for python.\n-----------------------------------------------------------------\n\nthis trampoline allows recursive functions to recurse virtually (or literally)\ninfinitely. most existing recursive functions can be converted with simple\nmodifications.\n\nthe implementation is tiny: the gist of the module consists of a single\nfunction with around 30 lines of simple python code.\n\nconversion from simple recursion\n''''''''''''''''''''''''''''''''\n\ntrampolined functions are generators: instead of recursing into other functions\ndirectly, they yield the generator of the call they want to recurse into. the\ngenerator of the first call is invoked using the ``trampoline()`` function.\n\nthis is easiest to understand with an example.\nconsider this simple recursive function:\n\n>>> def print_numbers(n):\n...     \"print numbers 0..n (recursive).\"\n...     if n >= 0:\n...         print_numbers(n - 1)\n...         print(n)\n>>>\n>>> print_numbers(2000) # doctest: +ignore_exception_detail\ntraceback (most recent call last):\nrecursionerror: maximum recursion depth exceeded in comparison\n\nthis exhausts the stack when calling it with too large ``n``.\ncompare this with our trampoline version:\n\n>>> from trampoline import trampoline\n>>>\n>>> def print_numbers(n):\n...     \"print numbers 0..n (trampolined).\"\n...     if n >= 0:\n...         yield print_numbers(n - 1)\n...         print(n)\n>>>\n>>> trampoline(print_numbers(2000)) # doctest: +ellipsis\n0\n1\n2\n...\n1999\n2000\n\nwe added a ``yield`` statement to the recursive call, and wrapped the function\ncall with ``trampoline()``.\n\n``trampoline`` takes the generator created by the ``print_numbers(2000)`` call and runs it.\nthe generator then yields another generator of ``print_numbers``, which then\ntakes over, effectively recursing into it.\n\nwhen a generator returns, the yielding generator takes over again.\n\nof course, the trampolined function doesn't have to call itself. any other\ntrampolined function generator will do.\n\nreturn values\n'''''''''''''\n\nconsider this recursive factorial:\n\n>>> def factorial(n):\n...     \"get factorial of n (recursive).\"\n...     if n <= 1:\n...         return 1\n...     return factorial(n - 1) * n\n>>>\n>>> print(factorial(2000)) # doctest: +ignore_exception_detail\ntraceback (most recent call last):\nrecursionerror: maximum recursion depth exceeded in comparison\n\nagain, this exhausts the stack at our ``factorial(2000)`` call.\n\nwe now want to convert it for our trampoline. but how do we get the result of\nthe factorial call? this uses a rarely seen feature of yield: its return value\nas an expression. with this, ``trampoline`` can send the result of the callee\nback to the caller. here is the trampolined solution:\n\n>>> def factorial(n):\n...     \"get factorial of n (trampolined).\"\n...     if n <= 1:\n...         return 1\n...     return (yield factorial(n - 1)) * n\n>>>\n>>> print(trampoline(factorial(2000))) # doctest: +ellipsis\n3316275092450633241175393380576324038281117208105780394571935437...\n\nthe function is suspended at the ``yield`` expression, ``trampoline`` continues\nexecution with the yielded generator, and afterwards provides us with the\nreturned value. in the end, ``trampoline`` returns the value that was returned\nby our first generator.\n\npython requires that we add braces around a ``yield`` expression after a\n``return``, making it look a little more ugly. we can circumvent this by adding\na variable:\n\n>>> def factorial(n):\n...     \"get factorial of n (trampolined).\"\n...     if n <= 1:\n...         return 1\n...     value = yield factorial(n - 1)\n...     return value * n\n>>>\n>>> print(trampoline(factorial(10)))\n3628800\n\nin this case, no extra braces are required.\n\nexceptions\n''''''''''\n\nexceptions are handled just as one might expect:\n\n>>> def factorial(n):\n...     \"get factorial of n (trampolined). unless we don't like the number.\"\n...     if n <= 1:\n...         return 1\n...     if n == 500:\n...         raise exception(\"i don't like this number\")\n...     return (yield factorial(n - 1)) * n\n>>>\n>>> print(trampoline(factorial(1000)))\ntraceback (most recent call last):\n  file \"/usr/lib/python3.7/doctest.py\", line 1329, in __run\n    compileflags, 1), test.globs)\n  file \"<doctest readme.rst[10]>\", line 1, in <module>\n    print(trampoline(factorial(1000)))\n  file \"trampoline.py\", line 39, in trampoline\n    raise exception\n  file \"trampoline.py\", line 21, in trampoline\n    res = stack[-1].throw(ex)\n...\n  file \"<doctest readme.rst[9]>\", line 7, in factorial\n    return (yield factorial(n - 1)) * n\n  file \"trampoline.py\", line 21, in trampoline\n    res = stack[-1].throw(ex)\n  file \"<doctest readme.rst[9]>\", line 7, in factorial\n    return (yield factorial(n - 1)) * n\n  file \"trampoline.py\", line 21, in trampoline\n    res = stack[-1].throw(ex)\n  file \"<doctest readme.rst[9]>\", line 7, in factorial\n    return (yield factorial(n - 1)) * n\n  file \"trampoline.py\", line 25, in trampoline\n    res = next(stack[-1])\n  file \"<doctest readme.rst[9]>\", line 6, in factorial\n    raise exception(\"i don't like this number\")\nexception: i don't like this number\n\nas seen in this example, event tracebacks are preserved, hiding no information\nin error cases. there is just one additional stack frame of the ``trampoline``\nfunction for each generator-yield.\n\nthis also means that yields work just fine inside ``with`` blocks.\n\ntail calls\n''''''''''\n\na trampolined function can raise ``tailcall`` (which is an exception) passing\nit the generator of the next function call:\n\n>>> from trampoline import tailcall\n>>>\n>>> def factorial(n, x=1):\n...     \"get factorial of n (trampolined).\"\n...     if n <= 1:\n...         return x\n...     raise tailcall(factorial(n - 1, x * n))\n...     yield # just to make this a generator\n>>>\n>>> # this could take some seconds (the numbers are extremely large)\n>>> print(trampoline(factorial(100000))) # doctest: +ellipsis\n282422940796034787429342157802453551847749492609122485057891808654...\n\nthis implementation uses constant memory, and theoretically works with any\n``n`` (until the result gets too large).\n\nbeware that we still need to have a generator function, so there has to be a\n``yield`` in the function, reachable or not. the\n\n::\n\n    raise tailcall(...)\n    yield\n\nidiom is recommended if the function doesn't yield any other calls.\n\nsuggestions\n'''''''''''\n\nexpose a wrapper\n````````````````\n\nif you want to hide the trampolined-ness of a function and simplify its usage,\nexpose a wrapper function that calls the trampolined function with\n``trampoline``:\n\n>>> def exposed_factorial(n):\n...     \"get factorial of n.\"\n...     return trampoline(factorial(n))\n>>>\n>>> print(exposed_factorial(42))\n1405006117752879898543142606244511569936384000000000\n\njust make sure to always use the trampolined version from other trampolined\nfunctions. otherwise it will recurse as usual, taking no advantage of the\ntrampoline.\n\nuse it in classes\n`````````````````\n\n``trampoline`` works just fine with methods.\n\n>>> class node(object):\n...\n...     def __init__(self, name, children=()):\n...         self.name = name\n...         self.children = children\n...\n...     def do_print(self, prefix=\"\"):\n...         print(prefix + self.name)\n...         for child in self.children:\n...             yield child.do_print(prefix=\"  \" + prefix)\n>>>\n>>> root = node(\"root\", [node(\"first\", [node(\"one\")]), node(\"second\", [node(\"two\"), node(\"last\")])])\n>>> trampoline(root.do_print())\nroot\n  first\n    one\n  second\n    two\n    last\n\nsubclasses can extend or override these trampolined methods to provide their\nown implementation. just make sure to always ``yield`` super calls when\nextending a trampolined method.\n\ncaveats\n'''''''\n\nlastly, there are some downsides to consider.\n\nyield\n`````\n\nas we use ``yield`` for recursion, we cannot use it to yield actual values.\n\nsimple cases could be rewritten with a callback function or by appending or\nreturning a list.\n\nmemory consumption\n``````````````````\n\nrecursing hundreds of thousands of times allocates a lot of objects for local\nvariables and for the generators themselves, which all need to exist at the\nsame time. when overdoing it, this can easily lead to multiple gigabytes on the\nstack.\n\nof course, if we mess up our exit condition and recurse infinitely, we will\nexhaust our memory.\n\nuse tail calls if they are an option. otherwise an iterative approach may be\npreferable.\n\nperformance\n```````````\n\nas said above, when recursing extremely deeply, the stack may get rather large.\nthese objects not only have to be allocated, but need to be freed as well when\ndone, which slows down the return path.\n\nfunction call and exception handling overhead may come into play for functions\nthat don't recurse deeply or use a lot of tail calls. this should only matter\nfor functions that don't do a lot of work. a simple tail-calling count-down\nfrom one million takes about one second on a mediocre laptop.\n\ntracebacks\n``````````\n\nwhen an exception occurs at ridiculous recursion depth, displaying the\ntraceback may take a while, depending on the exception handler and formatter.\nreducing ``sys.tracebacklimit`` may help. of course, the traceback will then be\ncut off. python's default traceback limit applies here too, printing the last\n1000 frames.\n\ntail calls don't have this problem, as they don't appear in tracebacks.\n\n.. vim:set sw=4 et:\n\n\n",
  "docs_url": null,
  "keywords": "trampoline recursion tail call",
  "license": "mit",
  "name": "trampoline",
  "package_url": "https://pypi.org/project/trampoline/",
  "project_url": "https://pypi.org/project/trampoline/",
  "project_urls": {
    "Homepage": "https://gitlab.com/ferreum/trampoline"
  },
  "release_url": "https://pypi.org/project/trampoline/0.1.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "simple and tiny yield-based trampoline implementation.",
  "version": "0.1.2",
  "releases": [],
  "developers": [
    "code.danielk@gmail.com"
  ],
  "kwds": "recursing recursion recursive recursionerror trampoline",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_trampoline",
  "homepage": "https://gitlab.com/ferreum/trampoline",
  "release_count": 3,
  "dependency_ids": []
}