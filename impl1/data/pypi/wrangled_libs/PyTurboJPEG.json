{
  "classifiers": [],
  "description": "# pyturbojpeg\na python wrapper of libjpeg-turbo for decoding and encoding jpeg image.\n\n## prerequisites\n- [libjpeg-turbo](https://github.com/libjpeg-turbo/libjpeg-turbo/releases)\n- [numpy](https://github.com/numpy/numpy)\n\n## example\n\n```python\nimport cv2\nfrom turbojpeg import turbojpeg, tjpf_gray, tjsamp_gray, tjflag_progressive, tjflag_fastupsample, tjflag_fastdct\n\n# specifying library path explicitly\n# jpeg = turbojpeg(r'd:\\turbojpeg.dll')\n# jpeg = turbojpeg('/usr/lib64/libturbojpeg.so')\n# jpeg = turbojpeg('/usr/local/lib/libturbojpeg.dylib')\n\n# using default library installation\njpeg = turbojpeg()\n\n# decoding input.jpg to bgr array\nin_file = open('input.jpg', 'rb')\nbgr_array = jpeg.decode(in_file.read())\nin_file.close()\ncv2.imshow('bgr_array', bgr_array)\ncv2.waitkey(0)\n\n# decoding input.jpg to bgr array with fast upsample and fast dct. (i.e. fastest speed but lower accuracy)\nin_file = open('input.jpg', 'rb')\nbgr_array = jpeg.decode(in_file.read(), flags=tjflag_fastupsample|tjflag_fastdct)\nin_file.close()\ncv2.imshow('bgr_array', bgr_array)\ncv2.waitkey(0)\n\n# direct rescaling 1/2 while decoding input.jpg to bgr array\nin_file = open('input.jpg', 'rb')\nbgr_array_half = jpeg.decode(in_file.read(), scaling_factor=(1, 2))\nin_file.close()\ncv2.imshow('bgr_array_half', bgr_array_half)\ncv2.waitkey(0)\n\n# getting possible scaling factors for direct rescaling\nscaling_factors = jpeg.scaling_factors\n\n# decoding jpeg image properties\nin_file = open('input.jpg', 'rb')\nwidth, height, jpeg_subsample, jpeg_colorspace = jpeg.decode_header(in_file.read())\nin_file.close()\n\n# decoding input.jpg to yuv array\nin_file = open('input.jpg', 'rb')\nbuffer_array, plane_sizes = jpeg.decode_to_yuv(in_file.read())\nin_file.close()\n\n# decoding input.jpg to yuv planes\nin_file = open('input.jpg', 'rb')\nplanes = jpeg.decode_to_yuv_planes(in_file.read())\nin_file.close()\n\n# encoding bgr array to output.jpg with default settings.\nout_file = open('output.jpg', 'wb')\nout_file.write(jpeg.encode(bgr_array))\nout_file.close()\n\n# encoding bgr array to output.jpg with tjsamp_gray subsample.\nout_file = open('output_gray.jpg', 'wb')\nout_file.write(jpeg.encode(bgr_array, jpeg_subsample=tjsamp_gray))\nout_file.close()\n\n# encoding bgr array to output.jpg with quality level 50. \nout_file = open('output_quality_50.jpg', 'wb')\nout_file.write(jpeg.encode(bgr_array, quality=50))\nout_file.close()\n\n# encoding bgr array to output.jpg with quality level 100 and progressive entropy coding.\nout_file = open('output_quality_100_progressive.jpg', 'wb')\nout_file.write(jpeg.encode(bgr_array, quality=100, flags=tjflag_progressive))\nout_file.close()\n\n# decoding input.jpg to grayscale array\nin_file = open('input.jpg', 'rb')\ngray_array = jpeg.decode(in_file.read(), pixel_format=tjpf_gray)\nin_file.close()\ncv2.imshow('gray_array', gray_array)\ncv2.waitkey(0)\n\n# scale with quality but leaves out the color conversion step\nin_file = open('input.jpg', 'rb')\nout_file = open('scaled_output.jpg', 'wb')\nout_file.write(jpeg.scale_with_quality(in_file.read(), scaling_factor=(1, 4), quality=70))\nout_file.close()\nin_file.close()\n\n# lossless crop image\nout_file = open('lossless_cropped_output.jpg', 'wb')\nout_file.write(jpeg.crop(open('input.jpg', 'rb').read(), 8, 8, 320, 240))\nout_file.close()\n```\n\n```python\n# using pyturbojpeg with exifread to transpose an image if the image has an exif orientation tag.\n#\n# pip install pyturbojpeg -u\n# pip install exifread -u\n\nimport cv2\nimport numpy as np\nimport exifread\nfrom turbojpeg import turbojpeg\n\ndef transposeimage(image, orientation):\n    \"\"\"see orientation in https://www.exif.org/exif2-2.pdf for details.\"\"\"\n    if orientation == none: return image\n    val = orientation.values[0]\n    if val == 1: return image\n    elif val == 2: return np.fliplr(image)\n    elif val == 3: return np.rot90(image, 2)\n    elif val == 4: return np.flipud(image)\n    elif val == 5: return np.rot90(np.flipud(image), -1)\n    elif val == 6: return np.rot90(image, -1)\n    elif val == 7: return np.rot90(np.flipud(image))\n    elif val == 8: return np.rot90(image)\n\n# using default library installation\nturbo_jpeg = turbojpeg()\n# open jpeg file\nin_file = open('foobar.jpg', 'rb')\n# parse orientation\norientation = exifread.process_file(in_file).get('image orientation', none)\n# seek file position back to 0 before decoding jpeg image\nin_file.seek(0)\n# start to decode the jpeg file\nimage = turbo_jpeg.decode(in_file.read())\n# transpose image based on exif orientation tag\ntransposed_image = transposeimage(image, orientation)\n# close the file since it's no longer needed.\nin_file.close()\n\ncv2.imshow('transposed_image', transposed_image)\ncv2.waitkey(0)\n```\n\n## installation\n\n### macos\n- brew install jpeg-turbo\n- pip install -u git+https://github.com/lilohuang/pyturbojpeg.git\n\n### windows \n- download [libjpeg-turbo official installer](https://sourceforge.net/projects/libjpeg-turbo/files) \n- pip install -u git+https://github.com/lilohuang/pyturbojpeg.git\n\n### linux\n- rhel/centos/fedora\n  - download [libjpeg-turbo.repo](https://libjpeg-turbo.org/pmwiki/uploads/downloads/libjpeg-turbo.repo) to /etc/yum.repos.d/\n  - sudo yum install libjpeg-turbo-official\n  - pip install -u git+https://github.com/lilohuang/pyturbojpeg.git\n\n- ubuntu\n  - sudo apt-get update\n  - sudo apt-get install libturbojpeg\n  - pip install -u git+https://github.com/lilohuang/pyturbojpeg.git\n\n## benchmark \n\n### macos\n- macos sierra 10.12.6\n- intel(r) core(tm) i5-3210m cpu @ 2.50ghz\n- opencv-python 3.4.0.12 (pre-built)\n- turbo-jpeg 1.5.3 (pre-built)\n\n| function              | wall-clock time |\n| ----------------------|-----------------|\n| cv2.imdecode() \u00a0 \u00a0 \u00a0  |   0.528 sec \u00a0   |\n| turbojpeg.decode()    |   0.191 sec     |\n| cv2.imencode() \u00a0 \u00a0 \u00a0  |   0.875 sec \u00a0   |\n| turbojpeg.encode()    |   0.176 sec     |\n\n### windows \n- windows 7 ultimate 64-bit\n- intel(r) xeon(r) e3-1276 v3 cpu @ 3.60 ghz\n- opencv-python 3.4.0.12 (pre-built)\n- turbo-jpeg 1.5.3 (pre-built)\n\n| function              | wall-clock time |\n| ----------------------|-----------------|\n| cv2.imdecode() \u00a0 \u00a0 \u00a0  |   0.358 sec \u00a0   |\n| turbojpeg.decode()    |   0.135 sec     |\n| cv2.imencode() \u00a0 \u00a0 \u00a0  |   0.581 sec \u00a0   |\n| turbojpeg.encode()    |   0.140 sec     |\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "pyturbojpeg",
  "package_url": "https://pypi.org/project/PyTurboJPEG/",
  "project_url": "https://pypi.org/project/PyTurboJPEG/",
  "project_urls": {
    "Homepage": "https://github.com/lilohuang/PyTurboJPEG"
  },
  "release_url": "https://pypi.org/project/PyTurboJPEG/1.7.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a python wrapper of libjpeg-turbo for decoding and encoding jpeg image.",
  "version": "1.7.3",
  "releases": [],
  "developers": [
    "kuso.cc@gmail.com",
    "lilo_huang"
  ],
  "kwds": "turbo_jpeg turbojpeg pyturbojpeg turbo jpeg_subsample",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pyturbojpeg",
  "homepage": "https://github.com/lilohuang/pyturbojpeg",
  "release_count": 25,
  "dependency_ids": []
}