{
  "classifiers": [],
  "description": "\n# rank-bm25: a two line search engine\n\n![build status](https://github.com/dorianbrown/rank_bm25/workflows/pytest/badge.svg)\n[![pypi version](https://badge.fury.io/py/rank-bm25.svg)](https://badge.fury.io/py/rank-bm25)\n[![doi](https://zenodo.org/badge/166720547.svg)](https://zenodo.org/badge/latestdoi/166720547)\n\na collection of algorithms for querying a set of documents and returning the ones most relevant to the query. the most common use case for these algorithms is, as you might have guessed, to create search engines.\n\nso far the algorithms that have been implemented are:\n- [x] okapi bm25\n- [x] bm25l\n- [x] bm25+\n- [ ] bm25-adpt\n- [ ] bm25t \n\nthese algorithms were taken from [this paper](http://www.cs.otago.ac.nz/homepages/andrew/papers/2014-2.pdf), which gives a nice overview of each method, and also benchmarks them against each other. a nice inclusion is that they compare different kinds of preprocessing like stemming vs no-stemming, stopword removal or not, etc. great read if you're new to the topic. \n\n## installation\nthe easiest way to install this package is through `pip`, using\n```bash\npip install rank_bm25\n```\nif you want to be sure you're getting the newest version, you can install it directly from github with\n```bash\npip install git+ssh://git@github.com/dorianbrown/rank_bm25.git\n```\n\n## usage\nfor this example we'll be using the `bm25okapi` algorithm, but the others are used in pretty much the same way.\n\n### initalizing\n\nfirst thing to do is create an instance of the bm25 class, which reads in a corpus of text and does some indexing on it:\n```python\nfrom rank_bm25 import bm25okapi\n\ncorpus = [\n    \"hello there good man!\",\n    \"it is quite windy in london\",\n    \"how is the weather today?\"\n]\n\ntokenized_corpus = [doc.split(\" \") for doc in corpus]\n\nbm25 = bm25okapi(tokenized_corpus)\n# <rank_bm25.bm25okapi at 0x1047881d0>\n```\nnote that this package doesn't do any text preprocessing. if you want to do things like lowercasing, stopword removal, stemming, etc, you need to do it yourself. \n\nthe only requirements is that the class receives a list of lists of strings, which are the document tokens.\n\n### ranking of documents\n\nnow that we've created our document indexes, we can give it queries and see which documents are the most relevant:\n```python\nquery = \"windy london\"\ntokenized_query = query.split(\" \")\n\ndoc_scores = bm25.get_scores(tokenized_query)\n# array([0.        , 0.93729472, 0.        ])\n```\ngood to note that we also need to tokenize our query, and apply the same preprocessing steps we did to the documents in order to have an apples-to-apples comparison\n\ninstead of getting the document scores, you can also just retrieve the best documents with\n```python\nbm25.get_top_n(tokenized_query, corpus, n=1)\n# ['it is quite windy in london']\n```\nand that's pretty much it!\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache2.0",
  "name": "rank-bm25",
  "package_url": "https://pypi.org/project/rank-bm25/",
  "project_url": "https://pypi.org/project/rank-bm25/",
  "project_urls": {
    "Homepage": "https://github.com/dorianbrown/rank_bm25"
  },
  "release_url": "https://pypi.org/project/rank-bm25/0.2.2/",
  "requires_dist": [
    "numpy",
    "pytest ; extra == 'dev'"
  ],
  "requires_python": "",
  "summary": "various bm25 algorithms for document ranking",
  "version": "0.2.2",
  "releases": [],
  "developers": [
    "dorianstuartbrown@gmail.com"
  ],
  "kwds": "rank_bm25 search ranking algorithms indexing",
  "license_kwds": "apache2.0",
  "libtype": "pypi",
  "id": "pypi_rank_bm25",
  "homepage": "https://github.com/dorianbrown/rank_bm25",
  "release_count": 4,
  "dependency_ids": [
    "pypi_numpy",
    "pypi_pytest"
  ]
}