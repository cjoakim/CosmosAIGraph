{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: information technology",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: implementation :: cpython",
    "topic :: multimedia :: graphics",
    "topic :: software development :: libraries"
  ],
  "description": "<!-- spdx-filecopyrighttext: 2023 geisserml <geisserml@gmail.com> -->\n<!-- spdx-license-identifier: cc-by-4.0 -->\n\n# pypdfium2\n\n[![downloads](https://pepy.tech/badge/pypdfium2/month)](https://pepy.tech/project/pypdfium2)\n\n[pypdfium2](https://github.com/pypdfium2-team/pypdfium2) is an [abi-level](#drawbacks-of-abi-level-bindings) python 3 binding to [pdfium](https://pdfium.googlesource.com/pdfium/+/refs/heads/main), a powerful and liberal-licensed library for pdf rendering, inspection, manipulation and creation.\n\nit is built with [ctypesgen](https://github.com/pypdfium2-team/ctypesgen) and external [pdfium binaries](https://github.com/bblanchon/pdfium-binaries/).\nthe custom setup infrastructure provides a seamless packaging and installation process. a wide range of platforms is supported with pre-built packages.\n\npypdfium2 includes helpers to simplify common use cases, while the raw pdfium/ctypes api remains accessible as well.\n\n\n## installation\n\n<!-- fixme is there a better/universal way to create linkable sub-sections without them being a heading? note, the current solution is specific to gh and doesn't work on rtd. -->\n\n* <a id=\"user-content-install-pypi\" class=\"anchor\" href=\"#install-pypi\">from pypi \ud83d\udd17</a> (recommended)\n  ```bash\n  python -m pip install -u pypdfium2\n  ```\n  this will use a pre-built wheel package, the easiest way of installing pypdfium2.\n\n\n* <a id=\"user-content-install-conda\" class=\"anchor\" href=\"#install-conda\">from conda \ud83d\udd17</a>\n  \n  _**beware:** any conda packages/recipes of pypdfium2 or pdfium-binaries that might be provided by other distributors, including `anaconda/main` or `conda-forge` default channels, are [unofficial](#install-unofficial)._\n  \n  + to install\n    \n    with permanent channel config (encouraged):\n    ```bash\n    conda config --add channels bblanchon\n    conda config --add channels pypdfium2-team\n    conda config --set channel_priority strict\n    conda install pypdfium2-team::pypdfium2_helpers\n    ```\n    \n    alternatively, with temporary channel config:\n    ```bash\n    conda install pypdfium2-team::pypdfium2_helpers --override-channels -c pypdfium2-team -c bblanchon\n    ```\n    \n    adding the channels permanently and tightening priority is encouraged to include pypdfium2 in `conda update` by default, and to avoid accidentally replacing the install with a different channel. (if desired, you may limit the channel config to the current environment by adding `--env`.)\n    otherwise, you should be cautious when making changes to the environment.\n  \n  + to depend on pypdfium2 in a `conda-build` recipe\n    ```yaml\n    requirements:\n      run:\n        - pypdfium2-team::pypdfium2_helpers\n    ```\n    you'll want to have downstream callers handle the custom channels as shown above, otherwise conda will not be able to satisfy requirements.\n  \n  + to set up channels in a gh workflow\n    ```yaml\n    - name: ...\n      uses: conda-incubator/setup-miniconda@v2\n      with:\n        # ... your options\n        channels: pypdfium2-team,bblanchon\n        channel-priority: strict\n    ```\n    this is just a suggestion, you can also call `conda config` manually, or pass channels on command basis using `-c`, as discussed above.\n  \n  + to verify the sources\n    ```bash\n    conda list --show-channel-urls \"pypdfium2|pdfium-binaries\"\n    conda config --show-sources\n    ```\n    the table should show `pypdfium2-team` and `bblanchon` in the channels column.\n    if added permanently, the config should also include these channels, ideally with top priority.\n    please check this before reporting any issue with a conda install of pypdfium2.\n  \n  _**note:** conda packages are normally managed using recipe feedstocks driven by third parties, in a linux repository like fashion. however, with some quirks it is also possible to do conda packaging within the original project and publish to a custom channel, which is what pypdfium2-team does, and the above instructions are referring to._\n\n\n* <a id=\"user-content-install-unofficial\" class=\"anchor\" href=\"#install-unofficial\">unofficial packages \ud83d\udd17</a>\n  \n  the authors of this project have no control over and are not responsible for possible third-party builds of pypdfium2, and we do not support them. please use the official packages where possible.\n  if you have an issue with a third-party build, either contact your distributor, or try to reproduce with an official build.\n  \n  do not expect us to help with the creation of unofficial builds or add/change code for downstream setup tasks. related issues or prs may be closed without further notice if we don't see fit for upstream.\n  \n  if you are a third-party distributor, please point out clearly and visibly in the description that your package is unofficial, i.e. not affiliated with or endorsed by pypdfium2 team.\n\n\n* <a id=\"user-content-install-source\" class=\"anchor\" href=\"#install-source\">from source \ud83d\udd17</a>\n  \n  * dependencies:\n    - system: git, c pre-processor (e.g. gcc, has to be in `$path`)\n    - python: ctypesgen (pypdfium2-team fork), wheel, setuptools. usually installed automatically.\n  \n  * get the code\n    ```\n    git clone \"https://github.com/pypdfium2-team/pypdfium2.git\"\n    cd pypdfium2/\n    ```\n  \n  * <a id=\"user-content-install-source-default\" class=\"anchor\" href=\"#install-source-default\">with pre-built binary \ud83d\udd17</a>\n    ```bash\n    # in the pypdfium2/ directory\n    python -m pip install -v .\n    ```\n    a binary is downloaded implicitly from `pdfium-binaries` and bundled into pypdfium2.\n  \n  * <a id=\"user-content-install-source-selfbuilt\" class=\"anchor\" href=\"#install-source-selfbuilt\">with self-built binary \ud83d\udd17</a>\n    ```bash\n    # call build script with --help to list options\n    python setupsrc/pypdfium2_setup/build_pdfium.py\n    pdfium_platform=\"sourcebuild\" python -m pip install -v .\n    ```\n    building pdfium may take a long time, as it comes with its bundled toolchain and deps, rather than taking them from the system.[^pdfium_buildsystem]\n    however, we can at least provide the `--use-syslibs` option to build against system-provided runtime libraries.\n  \n  * <a id=\"user-content-install-source-system\" class=\"anchor\" href=\"#install-source-system\">with system-provided binary \ud83d\udd17</a>\n    ```bash\n    # substitute $pdfium_ver with the system pdfium's build version.\n    # for abi safety reasons, you'll want to make sure `$pdfium_ver` is correct and the bindings are rebuilt whenever system pdfium is updated.\n    pdfium_platform=\"system:$pdfium_ver\" python -m pip install -v .\n    ```\n    link against external pdfium instead of bundling it.\n    note, this is basically a high-level convenience entry point to internal bindings generation, and intended for end users. therefore it is less flexible, supporting only the \"simple case\" for now.\n    for more sohpisticated use cases that need passing custom parameters to ctypesgen (e.g. runtime libdirs / headers / feature flags), consider [caller-provided data files](#install-source-caller).\n  \n  <!-- todo version.json: reconsider origin - should we add a new field for the packager? -->\n  * <a id=\"user-content-install-source-caller\" class=\"anchor\" href=\"#install-source-caller\">with caller-provided data files \ud83d\udd17</a> (this is expected to work offline)\n    ```bash\n    # call ctypesgen (see --help or packaging_base.py::run_ctypesgen() for further options)\n    # reminder: you'll want to use the pypdfium2-team fork of ctypesgen\n    ctypesgen --library pdfium --runtime-libdirs $my_libdirs --headers $my_include_dir/fpdf*.h -o src/pypdfium2_raw/bindings.py --strip-build-path=. --no-srcinfo [-d $my_flags]\n    \n    # write the version file (fill the placeholders).\n    # note, this is not a mature interface yet and might change!\n    # major/minor/build/patch: integers forming the pdfium version being packaged\n    # n_commits/hash: git describe like post-tag info (0/null for release commit)\n    # origin: a string to identify the build, consisting of binary source and package provider (e.g. \"system/debian\", \"pdfium-binaries/debian\")\n    # flags: a comma-delimited list of pdfium feature flag strings (e.g. \"v8\", \"xfa\") - may be empty for default build\n    cat >\"src/pypdfium2_raw/version.json\" <<end\n    {\n      \"major\": $pdfium_major,\n      \"minor\": $pdfium_minor,\n      \"build\": $pdfium_build,\n      \"patch\": $pdfium_patch,\n      \"n_commits\": $post_tag_commit_count,\n      \"hash\": $post_tag_hash,\n      \"origin\": \"$origin\",\n      \"flags\": [$my_flags]\n    }\n    end\n    \n    # optional: copy in a binary if bundling\n    cp \"$binary_path\" src/pypdfium2_raw/libpdfium.so\n    \n    # finally, install\n    # set $my_platform to \"system\" if building against system pdfium, \"auto\" or the platform name otherwise\n    pdfium_platform='prepared!$my_platform:$pdfium_build' python -m pip install --no-build-isolation -v .\n    ```\n  \n  see [setup magic](#setup-magic) for details.\n  \n  support for source installs (esp. with self-built/system pdfium) is limited, as their integrity depends somewhat on a correctly acting caller.\n  \n  installing an `sdist` does not implicitly trigger a sourcebuild if no pre-built binary is available. it is preferred to let callers decide consciously what to do, and run the build script without pip encapsulation.\n  \n  relevant pip options:\n  * `-v`: verbose logging output. useful for debugging.\n  * `-e`: install in editable mode, so the installation points to the source tree. this way, changes directly take effect without needing to re-install. recommended for development.\n  * `--no-build-isolation`: do not isolate setup in a virtual env; use the main env instead. this renders `pyproject.toml [build-system]` inactive, setup deps must be prepared by caller. useful to install custom versions of setup deps, or as speedup when installing repeatedly.\n  \n  [^pdfium_buildsystem]: this means pdfium may not compile on arbitrary hosts. the script is limited to build hosts supported by google's toolchain. ideally, we'd need an alternative build system that runs with system packages instead.\n\n\n### runtime dependencies\n\nas of this writing, pypdfium2 does not need any mandatory runtime dependencies apart from python itself.\n\nhowever, some optional support model features require additional packages:\n* [`pillow`](https://pillow.readthedocs.io/en/stable/) (module name `pil`) is a pouplar imaging library for python. pypdfium2 provides convenience methods to translate between raw bitmap buffers and pil images.\n* [`numpy`](https://numpy.org/doc/stable/index.html) is a library for scientific computing. similar to `pillow`, pypdfium2 provides helpers to get a numpy array view of a raw bitmap.\n\n\n### setup magic\n\nas pypdfium2 requires a c extension and has custom setup code, there are some special features to consider. note, the apis below may change any time and are mostly of internal interest.\n\n* binaries are stored in platform-specific sub-directories of `data/`, along with bindings and version information.\n\n* `$pdfium_platform` defines which binary to include on setup.\n  - format spec: `[$platform][-v8][:$version]` (`[]` = segments, `$caps` = variables).\n  - examples: `auto`, `auto:5975` `auto-v8:5975` (`auto` may be substituted by an explicit platform name, e.g. `linux_x64`).\n  - platform:\n    + if unset or `auto`, the host platform is detected and a corresponding binary will be selected.\n    + if an explicit platform identifier (e.g. `linux_x64`, `darwin_arm64`, ...), binaries for the requested platform will be used.[^platform_ids]\n    + if `system`, bind against system-provided pdfium instead of embedding a binary. version must be given explicitly so matching bindings can be generated.\n    + if `sourcebuild`, binaries will be taken from `data/sourcebuild/`, assuming a prior run of `build_pdfium.py`.\n    + if `none`, no platform-dependent files will be included, so as to create a source distribution.\n    `sourcebuild` and `none` are standalone, they cannot be followed by additional specifiers.\n  - v8: if given, use the v8 (javascript) and xfa enabled pdfium binaries. otherwise, use the regular (non-v8) binaries.\n  - version: if given, use the specified pdfium-binaries release. otherwise, use the latest one.\n  - it is possible to prepend `prepared!` to install with existing platform files instead of generating on the fly; the value will be used for metadata / file inclusion. this can be helpful when installing in an isolated env where ctypesgen is not available, but it is not desirable to use the reference bindings (e.g. conda).\n\n* `$pypdfium_modules=[raw,helpers]` defines the modules to include. metadata adapts dynamically.\n  - may be used by packagers to decouple raw bindings and helpers, which may be relevant if packaging against system pdfium.\n  - would also allow to install only the raw module without helpers, or only helpers with a custom raw module.\n\n* `$pdfium_bindings=reference` allows to override ctypesgen and use the reference bindings file `autorelease/bindings.py` instead.\n  - this is a convenience option to get pypdfium2 installed from source even if a working ctypesgen is not available in the install env.\n  - warning: this may not be abi-safe. please make sure binary/bindings build headers match to avoid abi issues.\n\n[^platform_ids]: intended for packaging, so that wheels can be crafted for any platform without access to a native host.\n\n\n## usage\n\n### [support model](https://pypdfium2.readthedocs.io/en/stable/python_api.html)\n\n<!-- todo demonstrate more apis (e. g. xobject placement, transform matrices, image extraction, ...) -->\n\nhere are some examples of using the support model api.\n\n* import the library\n  ```python\n  import pypdfium2 as pdfium\n  ```\n\n* open a pdf using the helper class `pdfdocument` (supports file path strings, bytes, and byte buffers)\n  ```python\n  pdf = pdfium.pdfdocument(\"./path/to/document.pdf\")\n  version = pdf.get_version()  # get the pdf standard version\n  n_pages = len(pdf)  # get the number of pages in the document\n  page = pdf[0]  # load a page\n  ```\n\n* render the page\n  ```python\n  bitmap = page.render(\n      scale = 1,    # 72dpi resolution\n      rotation = 0, # no additional rotation\n      # ... further rendering options\n  )\n  pil_image = bitmap.to_pil()\n  pil_image.show()\n  ```\n\n* try some page methods\n  ```python\n  # get page dimensions in pdf canvas units (1pt->1/72in by default)\n  width, height = page.get_size()\n  # set the absolute page rotation to 90\u00b0 clockwise\n  page.set_rotation(90)\n  \n  # locate objects on the page\n  for obj in page.get_objects():\n      print(obj.level, obj.type, obj.get_pos())\n  ```\n\n* extract and search text\n  ```python\n  # load a text page helper\n  textpage = page.get_textpage()\n  \n  # extract text from the whole page\n  text_all = textpage.get_text_range()\n  # extract text from a specific rectangular area\n  text_part = textpage.get_text_bounded(left=50, bottom=100, right=width-50, top=height-100)\n  \n  # locate text on the page\n  searcher = textpage.search(\"something\", match_case=false, match_whole_word=false)\n  # this returns the next occurrence as (char_index, char_count), or none if not found\n  first_occurrence = searcher.get_next()\n  ```\n\n<!-- toc api will change with the next major release -->\n* read the table of contents\n  ```python\n  for item in pdf.get_toc():\n      state = \"*\" if item.n_kids == 0 else \"-\" if item.is_closed else \"+\"\n      target = \"?\" if item.page_index is none else item.page_index+1\n      print(\n          \"    \" * item.level +\n          \"[%s] %s -> %s  # %s %s\" % (\n              state, item.title, target, item.view_mode, item.view_pos,\n          )\n      )\n  ```\n\n* create a new pdf with an empty a4 sized page\n  ```python\n  pdf = pdfium.pdfdocument.new()\n  width, height = (595, 842)\n  page_a = pdf.new_page(width, height)\n  ```\n\n* include a jpeg image in a pdf\n  ```python\n  pdf = pdfium.pdfdocument.new()\n  \n  image = pdfium.pdfimage.new(pdf)\n  image.load_jpeg(\"./tests/resources/mona_lisa.jpg\")\n  width, height = image.get_size()\n  \n  matrix = pdfium.pdfmatrix().scale(width, height)\n  image.set_matrix(matrix)\n  \n  page = pdf.new_page(width, height)\n  page.insert_obj(image)\n  page.gen_content()\n  ```\n\n* save the document\n  ```python\n  # pdf 1.7 standard\n  pdf.save(\"output.pdf\", version=17)\n  ```\n\n### raw pdfium api\n\nwhile helper classes conveniently wrap the raw pdfium api, it may still be accessed directly and is available in the namespace `pypdfium2.raw`. lower-level helpers that may aid with using the raw api are provided in `pypdfium2.internal`.\n\n```python\nimport pypdfium2.raw as pdfium_c\nimport pypdfium2.internal as pdfium_i\n```\n\nsince pdfium is a large library, many components are not covered by helpers yet. you may seamlessly interact with the raw api while still using helpers where available. when used as ctypes function parameter, helper objects automatically resolve to the underlying raw object (but you may still access it explicitly if desired):\n```python\npermission_flags = pdfium_c.fpdf_getdocpermission(pdf.raw)  # explicit\npermission_flags = pdfium_c.fpdf_getdocpermission(pdf)      # implicit\n```\n\nfor pdfium docs, please look at the comments in its [public header files](https://pdfium.googlesource.com/pdfium/+/refs/heads/main/public/).[^pdfium_docs]\na large variety of examples on how to interface with the raw api using [`ctypes`](https://docs.python.org/3/library/ctypes.html) is already provided with [support model source code](src/pypdfium2/_helpers).\nnonetheless, the following guide may be helpful to get started with the raw api, especially for developers who are not familiar with `ctypes` yet.\n\n[^pdfium_docs]: unfortunately, no recent html-rendered docs are available for pdfium at the moment.\n\n<!-- todo write something about weakref.finalize(); add example on creating a c page array -->\n\n* in general, pdfium functions can be called just like normal python functions.\n  however, parameters may only be passed positionally, i. e. it is not possible to use keyword arguments.\n  there are no defaults, so you always need to provide a value for each argument.\n  ```python\n  # arguments: filepath (bytes), password (bytes|none)\n  # null-terminate filepath and encode as utf-8\n  pdf = pdfium_c.fpdf_loaddocument((filepath+\"\\x00\").encode(\"utf-8\"), none)\n  ```\n  this is the underlying bindings declaration,[^bindings_decl] which loads the function from the binary and\n  contains the information required to convert python types to their c equivalents.\n  ```python\n  if _libs[\"pdfium\"].has(\"fpdf_loaddocument\", \"cdecl\"):\n      fpdf_loaddocument = _libs[\"pdfium\"].get(\"fpdf_loaddocument\", \"cdecl\")\n      fpdf_loaddocument.argtypes = [fpdf_string, fpdf_bytestring]\n      fpdf_loaddocument.restype = fpdf_document\n  ```\n  python `bytes` are converted to `fpdf_string` by ctypes autoconversion.\n  when passing a string to a c function, it must always be null-terminated, as the function merely receives a pointer to the first item and then continues to read memory until it finds a null terminator.\n  \n[^bindings_decl]: from the auto-generated bindings file. we maintain a reference copy at `autorelease/bindings.py`. or if you have an editable install, there will also be `src/pypdfium2_raw/bindings.py`.\n\n* while some functions are quite easy to use, things soon get more complex.\n  first of all, function parameters are not only used for input, but also for output:\n  ```python\n  # initialise an integer object (defaults to 0)\n  c_version = ctypes.c_int()\n  # let the function assign a value to the c_int object, and capture its return code (true for success, false for failure)\n  ok = pdfium_c.fpdf_getfileversion(pdf, c_version)\n  # if successful, get the python int by accessing the `value` attribute of the c_int object\n  # otherwise, set the variable to none (in other cases, it may be desired to raise an exception instead)\n  version = c_version.value if ok else none\n  ```\n\n* if an array is required as output parameter, you can initialise one like this (in general terms):\n  ```python\n  # long form\n  array_type = (c_type * array_length)\n  array_object = array_type()\n  # short form\n  array_object = (c_type * array_length)()\n  ```\n  example: getting view mode and target position from a destination object returned by some other function.\n  ```python\n  # (assuming `dest` is an fpdf_dest)\n  n_params = ctypes.c_ulong()\n  # create a c array to store up to four coordinates\n  view_pos = (pdfium_c.fs_float * 4)()\n  view_mode = pdfium_c.fpdfdest_getview(dest, n_params, view_pos)\n  # convert the c array to a python list and cut it down to the actual number of coordinates\n  view_pos = list(view_pos)[:n_params.value]\n  ```\n\n* for string output parameters, callers needs to provide a sufficiently long, pre-allocated buffer.\n  this may work differently depending on what type the function requires, which encoding is used, whether the number of bytes or characters is returned, and whether space for a null terminator is included or not. carefully review the documentation for the function in question to fulfill its requirements.\n  \n  example a: getting the title string of a bookmark.\n  ```python\n  # (assuming `bookmark` is an fpdf_bookmark)\n  # first call to get the required number of bytes (not characters!), including space for a null terminator\n  n_bytes = pdfium_c.fpdfbookmark_gettitle(bookmark, none, 0)\n  # initialise the output buffer\n  buffer = ctypes.create_string_buffer(n_bytes)\n  # second call with the actual buffer\n  pdfium_c.fpdfbookmark_gettitle(bookmark, buffer, n_bytes)\n  # decode to string, cutting off the null terminator\n  # encoding: utf-16le (2 bytes per character)\n  title = buffer.raw[:n_bytes-2].decode(\"utf-16-le\")\n  ```\n  \n  example b: extracting text in given boundaries.\n  ```python\n  # (assuming `textpage` is an fpdf_textpage and the boundary variables are set)\n  # store common arguments for the two calls\n  args = (textpage, left, top, right, bottom)\n  # first call to get the required number of characters (not bytes!) - a possible null terminator is not included\n  n_chars = pdfium_c.fpdftext_getboundedtext(*args, none, 0)\n  # if no characters were found, return an empty string\n  if n_chars <= 0:\n      return \"\"\n  # calculate the required number of bytes (utf-16le encoding again)\n  n_bytes = 2 * n_chars\n  # initialise the output buffer - this function can work without null terminator, so skip it\n  buffer = ctypes.create_string_buffer(n_bytes)\n  # re-interpret the type from char to unsigned short as required by the function\n  buffer_ptr = ctypes.cast(buffer, ctypes.pointer(ctypes.c_ushort))\n  # second call with the actual buffer\n  pdfium_c.fpdftext_getboundedtext(*args, buffer_ptr, n_chars)\n  # decode to string (you may want to pass `errors=\"ignore\"` to skip possible errors in the pdf's encoding)\n  text = buffer.raw.decode(\"utf-16-le\")\n  ```\n\n* not only are there different ways of string output that need to be handled according to the requirements of the function in question.\n  string input, too, can work differently depending on encoding and type.\n  we have already discussed `fpdf_loaddocument()`, which takes a utf-8 encoded string as `char *`.\n  a different examples is `fpdftext_findstart()`, which needs a utf-16le encoded string, given as `unsigned short *`:\n  ```python\n  # (assuming `text` is a str and `textpage` an fpdf_textpage)\n  # add the null terminator and encode as utf-16le\n  enc_text = (text + \"\\x00\").encode(\"utf-16-le\")\n  # cast `enc_text` to a c_ushort pointer\n  text_ptr = ctypes.cast(enc_text, ctypes.pointer(ctypes.c_ushort))\n  search = pdfium_c.fpdftext_findstart(textpage, text_ptr, 0, 0)\n  ```\n\n* leaving strings, let's suppose you have a c memory buffer allocated by pdfium and wish to read its data.\n  pdfium will provide you with a pointer to the first item of the byte array.\n  to access the data, you'll want to re-interpret the pointer using `ctypes.cast()` to encompass the whole array:\n  ```python\n  # (assuming `bitmap` is an fpdf_bitmap and `size` is the expected number of bytes in the buffer)\n  buffer_ptr = pdfium_c.fpdfbitmap_getbuffer(bitmap)\n  buffer_ptr = ctypes.cast(buffer_ptr, ctypes.pointer(ctypes.c_ubyte * size))\n  # buffer as ctypes array (referencing the original buffer, will be unavailable as soon as the bitmap is destroyed)\n  c_array = buffer_ptr.contents\n  # buffer as python bytes (independent copy)\n  data = bytes(c_array)\n  ```\n\n* writing data from python into a c buffer works in a similar fashion:\n  ```python\n  # (assuming `buffer_ptr` is a pointer to the first item of a c buffer to write into,\n  #  `size` the number of bytes it can store, and `py_buffer` a python byte buffer)\n  buffer_ptr = ctypes.cast(buffer_ptr, ctypes.pointer(ctypes.c_char * size))\n  # read from the python buffer, starting at its current position, directly into the c buffer\n  # (until the target is full or the end of the source is reached)\n  n_bytes = py_buffer.readinto(buffer_ptr.contents)  # returns the number of bytes read\n  ```\n\n* if you wish to check whether two objects returned by pdfium are the same, the `is` operator won't help because `ctypes` does not have original object return (oor), i. e. new, equivalent python objects are created each time, although they might represent one and the same c object.[^ctypes_no_oor]\n  that's why you'll want to use `ctypes.addressof()` to get the memory addresses of the underlying c object.\n  for instance, this is used to avoid infinite loops on circular bookmark references when iterating through the document outline:\n  ```python\n  # (assuming `pdf` is an fpdf_document)\n  seen = set()\n  bookmark = pdfium_c.fpdfbookmark_getfirstchild(pdf, none)\n  while bookmark:\n      # bookmark is a pointer, so we need to use its `contents` attribute to get the object the pointer refers to\n      # (otherwise we'd only get the memory address of the pointer itself, which would result in random behaviour)\n      address = ctypes.addressof(bookmark.contents)\n      if address in seen:\n          break  # circular reference detected\n      else:\n          seen.add(address)\n      bookmark = pdfium_c.fpdfbookmark_getnextsibling(pdf, bookmark)\n  ```\n  \n  [^ctypes_no_oor]: confer the [ctypes documentation on pointers](https://docs.python.org/3/library/ctypes.html#pointers).\n\n* in many situations, callback functions come in handy.[^callback_usecases] thanks to `ctypes`, it is seamlessly possible to use callbacks across python/c language boundaries.\n  \n  [^callback_usecases]: e. g. incremental read/write, management of progressive tasks, ...\n  \n  example: loading a document from a python buffer. this way, file access can be controlled in python while the whole data does not need to be in memory at once.\n  ```python\n  import os\n  \n  # factory class to create callable objects holding a reference to a python buffer\n  class _reader_class:\n    \n    def __init__(self, py_buffer):\n        self.py_buffer = py_buffer\n    \n    def __call__(self, _, position, p_buf, size):\n        # write data from python buffer into c buffer, as explained before\n        buffer_ptr = ctypes.cast(p_buf, ctypes.pointer(ctypes.c_char * size))\n        self.py_buffer.seek(position)\n        self.py_buffer.readinto(buffer_ptr.contents)\n        return 1  # non-zero return code for success\n  \n  # (assuming py_buffer is a python file buffer, e. g. io.bufferedreader)\n  # get the length of the buffer\n  py_buffer.seek(0, os.seek_end)\n  file_len = py_buffer.tell()\n  py_buffer.seek(0)\n  \n  # set up an interface structure for custom file access\n  fileaccess = pdfium_c.fpdf_fileaccess()\n  fileaccess.m_filelen = file_len\n  \n  # assign the callback, wrapped in its cfunctype\n  fileaccess.m_getblock = type(fileaccess.m_getblock)( _reader_class(py_buffer) )\n  \n  # finally, load the document\n  pdf = pdfium_c.fpdf_loadcustomdocument(fileaccess, none)\n  ```\n\n<!-- todo mention pdfium_i.get_bufreader() as a shortcut to set up an fpdf_fileaccess interface -->\n\n* when using the raw api, special care needs to be taken regarding object lifetime, considering that python may garbage collect objects as soon as their reference count reaches zero. however, the interpreter has no way of magically knowing how long the underlying resources of a python object might still be needed on the c side, so measures need to be taken to keep such objects referenced until pdfium does not depend on them anymore.\n  \n  if resources need to remain valid after the time of a function call, pdfium docs usually indicate this clearly. ignoring requirements on object lifetime will lead to memory corruption (commonly resulting in a segfault).\n  \n  for instance, the docs on `fpdf_loadcustomdocument()` state that\n  > the application must keep the file resources |pfileaccess| points to valid until the returned fpdf_document is closed. |pfileaccess| itself does not need to outlive the fpdf_document.\n  \n  this means that the callback function and the python buffer need to be kept alive as long as the `fpdf_document` is used.\n  this can be achieved by referencing these objects in an accompanying class, e. g.\n  \n  ```python\n  class pdfdataholder:\n      \n      def __init__(self, buffer, function):\n          self.buffer = buffer\n          self.function = function\n      \n      def close(self):\n          # make sure both objects remain available until this function is called\n          # no-op id() call to denote that the object needs to stay in memory up to this point\n          id(self.function)\n          self.buffer.close()\n  \n  # ... set up an fpdf_fileaccess structure\n  \n  # (assuming `py_buffer` is the buffer and `fileaccess` the fpdf_fileaccess interface)\n  data_holder = pdfdataholder(py_buffer, fileaccess.m_getblock)\n  pdf = pdfium_c.fpdf_loadcustomdocument(fileaccess, none)\n  \n  # ... work with the pdf\n  \n  # close the pdf to free resources\n  pdfium_c.fpdf_closedocument(pdf)\n  # close the data holder, to keep the object itself and thereby the objects it\n  # references alive up to this point, as well as to release the buffer\n  data_holder.close()\n  ```\n\n* finally, let's finish with an example how to render the first page of a document to a `pil` image in `rgba` color format.\n  ```python\n  import math\n  import ctypes\n  import os.path\n  import pil.image\n  import pypdfium2.raw as pdfium_c\n  \n  # load the document\n  filepath = os.path.abspath(\"tests/resources/render.pdf\")\n  pdf = pdfium_c.fpdf_loaddocument((filepath+\"\\x00\").encode(\"utf-8\"), none)\n  \n  # check page count to make sure it was loaded correctly\n  page_count = pdfium_c.fpdf_getpagecount(pdf)\n  assert page_count >= 1\n  \n  # load the first page and get its dimensions\n  page = pdfium_c.fpdf_loadpage(pdf, 0)\n  width  = math.ceil(pdfium_c.fpdf_getpagewidthf(page))\n  height = math.ceil(pdfium_c.fpdf_getpageheightf(page))\n  \n  # create a bitmap\n  use_alpha = false  # we don't render with transparent background\n  bitmap = pdfium_c.fpdfbitmap_create(width, height, int(use_alpha))\n  # fill the whole bitmap with a white background\n  # the color is given as a 32-bit integer in argb format (8 bits per channel)\n  pdfium_c.fpdfbitmap_fillrect(bitmap, 0, 0, width, height, 0xffffffff)\n  \n  # store common rendering arguments\n  render_args = (\n      bitmap,  # the bitmap\n      page,    # the page\n      # positions and sizes are to be given in pixels and may exceed the bitmap\n      0,       # left start position\n      0,       # top start position\n      width,   # horizontal size\n      height,  # vertical size\n      0,       # rotation (as constant, not in degrees!)\n      pdfium_c.fpdf_lcd_text | pdfium_c.fpdf_annot,  # rendering flags, combined with binary or\n  )\n  \n  # render the page\n  pdfium_c.fpdf_renderpagebitmap(*render_args)\n  \n  # get a pointer to the first item of the buffer\n  buffer_ptr = pdfium_c.fpdfbitmap_getbuffer(bitmap)\n  # re-interpret the pointer to encompass the whole buffer\n  buffer_ptr = ctypes.cast(buffer_ptr, ctypes.pointer(ctypes.c_ubyte * (width * height * 4)))\n  \n  # create a pil image from the buffer contents\n  img = pil.image.frombuffer(\"rgba\", (width, height), buffer_ptr.contents, \"raw\", \"bgra\", 0, 1)\n  # save it as file\n  img.save(\"out.png\")\n  \n  # free resources\n  pdfium_c.fpdfbitmap_destroy(bitmap)\n  pdfium_c.fpdf_closepage(page)\n  pdfium_c.fpdf_closedocument(pdf)\n  ```\n\n### [command-line interface](https://pypdfium2.readthedocs.io/en/stable/shell_api.html)\n\npypdfium2 also ships with a simple command-line interface, providing access to key features of the support model in a shell environment (e. g. rendering, content extraction, document inspection, page rearranging, ...).\n\nthe primary motivation behind this is to have a nice testing interface, but it may be helpful in a variety of other situations as well.\nusage should be largely self-explanatory, assuming a minimum of familiarity with the command-line.\n\n\n## licensing\n\npdfium and pypdfium2 are available by the terms and conditions of either [`apache-2.0`](licenses/apache-2.0.txt) or [`bsd-3-clause`](licenses/bsd-3-clause.txt), at your choice.\nvarious other open-source licenses apply to dependencies bundled with pdfium. verbatim copies of their respective licenses are contained in the file [`licenseref-pdfiumthirdparty.txt`](licenses/licenseref-pdfiumthirdparty.txt), which also has to be shipped with binary redistributions.\ndocumentation and examples of pypdfium2 are licensed under [`cc-by-4.0`](licenses/cc-by-4.0.txt).\n\npypdfium2 complies with the [reuse standard](https://reuse.software/spec/) by including [spdx](https://spdx.org/licenses/) headers in source files, and license information for data files in [`.reuse/dep5`](.reuse/dep5).\n\nto the author's knowledge, pypdfium2 is one of the rare python libraries that are capable of pdf rendering while not being covered by copyleft licenses (such as the `gpl`).[^liberal_pdf_renderlibs]\n\nas of early 2023, a single developer is author and rightsholder of the code base (apart from a few minor [code contributions](https://github.com/pypdfium2-team/pypdfium2/graphs/contributors)).\n\n[^liberal_pdf_renderlibs]: the only other liberal-licensed pdf rendering libraries known to the author are [`pdf.js`](https://github.com/mozilla/pdf.js/) (javascript) and [`apache pdfbox`](https://github.com/apache/pdfbox) (java), but python bindings packages don't exist yet or are unsatisfactory. however, we wrote some gists that show it'd be possible in principle: [pdfbox](https://gist.github.com/mara004/51c3216a9eabd3dcbc78a86d877a61dc) (+ [setup](https://gist.github.com/mara004/881d0c5a99b8444fd5d1d21a333b70f8)), [pdfjs](https://gist.github.com/mara004/87276da4f8be31c80c38036c6ab667d7).\n\n\n## issues\n\nwhile using pypdfium2, you might encounter bugs or missing features.\nin this case, feel free to file an issue. if applicable, include details such as tracebacks, os and cpu type, as well as the versions of pypdfium2 and used dependencies.\n\nroadmap:\n* pypdfium2\n  - [issues panel](https://github.com/pypdfium2-team/pypdfium2/issues): initial bug reports and feature requests. may need to be transferred to dependencies.\n  - [discussions page](https://github.com/pypdfium2-team/pypdfium2/discussions): general questions and suggestions.\n* pdfium\n  - [bug tracker](https://bugs.chromium.org/p/pdfium/issues/list): issues in pdfium.\n    beware: the bridge between python and c increases the probability of integration issues or api misuse. the symptoms can often make it look like a pdfium bug while it is not.\n  - [mailing list](https://groups.google.com/g/pdfium/): questions regarding pdfium usage.\n* [pdfium-binaries](https://github.com/bblanchon/pdfium-binaries/issues): binary builder.\n* [ctypesgen](https://github.com/ctypesgen/ctypesgen/issues): bindings generator.\n\n### known limitations\n\n#### incompatibility with cpython 3.7.6 and 3.8.1\n\npypdfium2 built with mainstream ctypesgen cannot be used with releases 3.7.6 and 3.8.1 of the cpython interpreter due to a [regression](https://github.com/python/cpython/pull/16799#issuecomment-612353119) that [broke](https://github.com/ctypesgen/ctypesgen/issues/77) ctypesgen-created string handling code.\n\nsince version 4, pypdfium2 is built with a patched fork of ctypesgen that removes ctypesgen's problematic string code.\n\n#### risk of unknown object lifetime violations\n\nas outlined in the raw api section, it is essential that python-managed resources remain available as long as they are needed by pdfium.\n\nthe problem is that the python interpreter may garbage collect objects with reference count zero at any time, so an unreferenced but still required object may either by chance stay around long enough or disappear too soon, resulting in non-deterministic memory issues that are hard to debug.\nif the timeframe between reaching reference count zero and removal is sufficiently large and roughly consistent across different runs, it is even possible that mistakes regarding object lifetime remain unnoticed for a long time.\n\nalthough we intend to develop helpers carefully, it cannot be fully excluded that unknown object lifetime violations are still lurking around somewhere, especially if unexpected requirements were not documented by the time the code was written.\n\n#### missing raw pdf access\n\nas of this writing, pdfium's public interface does not provide access to the raw pdf data structure (see [issue 1694](https://crbug.com/pdfium/1694)). it does not expose apis to read/write pdf dictionaries, streams, name/number trees, etc. instead, it merely offers a predefined set of abstracted functions. this considerably limits the library's potential, compared to other products such as `pikepdf`.\n\n#### limitations of abi bindings\n\npdfium's non-public backend would provide extended capabilities, including [raw access](#missing-raw-pdf-access), but it is not exported into the abi and written in c++ (not pure c), so we cannot use it with `ctypes`. this means it's out of scope for this project.\n\nalso, while abi bindings tend to be more convenient, they have some technical drawbacks compared to api bindings (see e.g. [1](https://cffi.readthedocs.io/en/latest/overview.html#abi-versus-api), [2](https://github.com/ocrmypdf/ocrmypdf/issues/541#issuecomment-1834684532))\n\n\n## development\n<!-- todo wheel tags, maintainer access, github peculiarities -->\n\nthis section contains some key information relevant for project maintainers.\n\n### long lines\n\nthe pypdfium2 codebase does not hard wrap long lines.\nit is recommended to set up automatic word wrap in your text editor, e.g. vs code:\n```\neditor.wordwrap = bounded\neditor.wordwrapcolumn = 100\n```\n\n### docs\n\npypdfium2 provides api documentation using [sphinx](https://github.com/sphinx-doc/sphinx/), which can be rendered to various formats, including html:\n```bash\nsphinx-build -b html ./docs/source ./docs/build/html/\n./run build  # short alias\n```\n\nbuilt docs are primarily hosted on [`readthedocs.org`](https://readthedocs.org/projects/pypdfium2/).\nit may be configured using a [`.readthedocs.yaml`](.readthedocs.yaml) file (see [instructions](https://docs.readthedocs.io/en/stable/config-file/v2.html)), and the administration page on the web interface.\nrtd supports hosting multiple versions, so we currently have one linked to the `main` branch and another to `stable`.\nnew builds are automatically triggered by a webhook whenever you push to a linked branch.\n\nadditionally, one doc build can also be hosted on [github pages](https://pypdfium2-team.github.io/pypdfium2/index.html).\nit is implemented with a ci workflow, which is supposed to be triggered automatically on release.\nthis provides us with full control over the build env and the used commands, whereas rtd may be less liberal in this regard.\n\n\n### testing\n\npypdfium2 contains a small test suite to verify the library's functionality. it is written with [pytest](https://github.com/pytest-dev/pytest/):\n```bash\n./run test\n```\n\nnote that ...\n* you can pass `-sv` to get more detailed output.\n* `$debug_autoclose=1` may be set to get debugging information on automatic object finalization.\n\nto get code coverage statistics, you may call\n```bash\n./run coverage\n```\n\nsometimes, it can also be helpful to test code on many pdfs.[^testing_corpora]\nin this case, the command-line interface and `find` come in handy:\n```bash\n# example a: analyse pdf images (in the current working directory)\nfind . -name '*.pdf' -exec bash -c \"echo \\\"{}\\\" && pypdfium2 pageobjects \\\"{}\\\" --filter image\" \\;\n# example b: parse pdf table of contents\nfind . -name '*.pdf' -exec bash -c \"echo \\\"{}\\\" && pypdfium2 toc \\\"{}\\\"\" \\;\n```\n\n[^testing_corpora]: for instance, one could use the testing corpora of open-source pdf libraries (pdfium, pikepdf/ocrmypdf, mupdf/ghostscript, tika/pdfbox, pdfjs, ...)\n\n### release workflow\n\nthe release process is fully automated using python scripts and scheduled release workflows.\nyou may also trigger the workflow manually using the github actions panel or the [`gh`](https://cli.github.com/) command-line tool.\n\npython release scripts are located in the folder `setupsrc/pypdfium2_setup`, along with custom setup code:\n* `update_pdfium.py` downloads binaries.\n* `craft_packages.py pypi` builds platform-specific wheel packages and a source distribution suitable for pypi upload.\n* `autorelease.py` takes care of versioning, changelog, release note generation and vcs checkin.\n\nthe autorelease script has some peculiarities maintainers should know about:\n* the changelog for the next release shall be written into `docs/devel/changelog_staging.md`.\n  on release, it will be moved into the main changelog under `docs/source/changelog.md`, annotated with the pdfium version update.\n  it will also be shown on the github release page.\n* pypdfium2 versioning uses the pattern `major.minor.patch`, optionally with an appended beta mark (e. g. `2.7.1`, `2.11.0`, `3.0.0b1`, ...).\n  version changes are based on the following logic:\n  * if pdfium was updated, the minor version is incremented.\n  * if only pypdfium2 code was updated, the patch version is incremented instead.\n  * major updates and beta marks are controlled via `autorelease/config.json`.\n    if `major` is true, the major version is incremented.\n    if `beta` is true, a new beta tag is set, or an existing one is incremented.\n    the control file is automatically reset when the versioning is finished.\n  * if switching from a beta release to a non-beta release, only the beta mark is removed while minor and patch versions remain unchanged.\n\nin case of necessity, you may also forego autorelease/ci and do the release manually, which will roughly work like this (though ideally it should never be needed):\n* commit changes to the version file\n  ```bash\n  git add src/pypdfium2/version.py\n  git commit -m \"increment version\"\n  git push\n  ```\n* create a new tag that matches the version file\n  ```bash\n  # substitute $version accordingly\n  git tag -a $version\n  git push --tags\n  ```\n* build the packages\n  ```bash\n  python setupsrc/pypdfium2_setup/update_pdfium.py\n  python setupsrc/pypdfium2_setup/craft_packages.py pypi\n  ```\n* upload to pypi\n  ```bash\n  # make sure the packages are valid\n  twine check dist/*\n  # upload to pypi (this will interactively ask for your username/password)\n  twine upload dist/*\n  ```\n* update the `stable` branch to trigger a documentation rebuild\n  ```bash\n  git checkout stable\n  git rebase origin/main  # alternatively: git reset --hard main\n  git checkout main\n  ```\n\nif something went wrong with commit or tag, you can still revert the changes:\n```bash\n# perform an interactive rebase to change history (substitute $n_commits with the number of commits to drop or modify)\ngit rebase -i head~$n_commits\ngit push --force\n# delete local tag (substitute $tagname accordingly)\ngit tag -d $tagname\n# delete remote tag\ngit push --delete origin $tagname\n```\nfaulty pypi releases may be yanked using the web interface.\n\n\n## thanks to[^thanks_to]\n\n<!-- order: alphabetical by surname -->\n\n* [beno\u00eet blanchon](https://github.com/bblanchon): author of [pdfium binaries](https://github.com/bblanchon/pdfium-binaries/) and [patches](sourcebuild/patches/).\n* [anderson bravalheri](https://github.com/abravalheri): help with pep 517/518 compliance. hint to use an environment variable rather than separate setup files.\n* [bastian germann](https://github.com/bgermann): help with inclusion of licenses for third-party components of pdfium.\n* [tim head](https://github.com/betatim): original idea for python bindings to pdfium with ctypesgen in `wowpng`.\n* [yinlin hu](https://github.com/yinlinhu): `pypdfium` prototype and `kuafu` pdf viewer.\n* [adam huganir](https://github.com/adam-huganir): help with maintenance and development decisions since the beginning of the project.\n* [kobaltcore](https://github.com/kobaltcore): bug fix for `pdfdocument.save()`.\n* [mike kroutikov](https://github.com/mkroutikov): examples on how to use pdfium with ctypes in `redstork` and `pdfbrain`.\n* [peter saalbrink](https://github.com/petersaalbrink): code style improvements to the multipage renderer.\n\n... and further [code contributors](https://github.com/pypdfium2-team/pypdfium2/graphs/contributors) (github stats).\n\n*if you have somehow contributed to this project but we forgot to mention you here, please let us know.*\n\n[^thanks_to]: people listed in this section may not necessarily have contributed any copyrightable code to the repository. some have rather helped with ideas, or contributions to dependencies of pypdfium2.\n\n\n## history\n\n### pdfium\n\nthe pdfium code base was originally developed as part of the commercial foxit sdk, before being acquired and open-sourced by google, who maintain pdfium independently ever since, while foxit continue to develop their sdk closed-source.\n\n### pypdfium2\n\npypdfium2 is the successor of *pypdfium* and *pypdfium-reboot*.\n\ninspired by *wowpng*, the first known proof of concept python binding to pdfium using ctypesgen, the initial *pypdfium* package was created. it had to be updated manually, which did not happen frequently. there were no platform-specific wheels, but only a single wheel that contained binaries for 64-bit linux, windows and macos.\n\n*pypdfium-reboot* then added a script to automate binary deployment and bindings generation to simplify regular updates. however, it was still not platform specific.\n\npypdfium2 is a full rewrite of *pypdfium-reboot* to build platform-specific wheels and consolidate the setup scripts. further additions include ...\n* a ci workflow to automatically release new wheels every tuesday\n* support models that conveniently wrap the raw pdfium/ctypes api\n* test code\n* a script to build pdfium from source\n",
  "docs_url": null,
  "keywords": "pdf,pdfium",
  "license": "(apache-2.0 or bsd-3-clause) and licenseref-pdfiumthirdparty",
  "name": "pypdfium2",
  "package_url": "https://pypi.org/project/pypdfium2/",
  "project_url": "https://pypi.org/project/pypdfium2/",
  "project_urls": {
    "Changelog": "https://pypdfium2.readthedocs.io/en/stable/changelog.html",
    "Documentation": "https://pypdfium2.readthedocs.io",
    "Homepage": "https://github.com/pypdfium2-team/pypdfium2",
    "Source": "https://github.com/pypdfium2-team/pypdfium2",
    "Tracker": "https://github.com/pypdfium2-team/pypdfium2/issues"
  },
  "release_url": "https://pypi.org/project/pypdfium2/4.25.0/",
  "requires_dist": [],
  "requires_python": ">= 3.6",
  "summary": "python bindings to pdfium",
  "version": "4.25.0",
  "releases": [],
  "developers": [
    "geisserml@gmail.com",
    "pypdfium2"
  ],
  "kwds": "pdfium pypdfium2 pypdfium2_helpers pypdfium pdfium_docs",
  "license_kwds": "(apache-2.0 or bsd-3-clause) and licenseref-pdfiumthirdparty",
  "libtype": "pypi",
  "id": "pypi_pypdfium2",
  "homepage": "https://github.com/pypdfium2-team/pypdfium2",
  "release_count": 104,
  "dependency_ids": []
}