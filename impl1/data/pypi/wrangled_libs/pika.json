{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: jython",
    "programming language :: python :: implementation :: pypy",
    "topic :: communications",
    "topic :: internet",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules",
    "topic :: system :: networking"
  ],
  "description": "pika\n====\npika is a rabbitmq (amqp 0-9-1) client library for python.\n\n|version| |python versions| |actions status| |coverage| |license| |docs|\n\nintroduction\n------------\npika is a pure-python implementation of the amqp 0-9-1 protocol including\nrabbitmq's extensions.\n\n- supports python 3.7+ (`1.1.0` was the last version to support 2.7)\n- since threads aren't appropriate to every situation, it doesn't require\n  threads. pika core takes care not to forbid them, either. the same goes for\n  greenlets, callbacks, continuations, and generators. an instance of pika's\n  built-in connection adapters isn't thread-safe, however.\n- people may be using direct sockets, plain old ``select()``, or any of the\n  wide variety of ways of getting network events to and from a python\n  application. pika tries to stay compatible with all of these, and to make\n  adapting it to a new environment as simple as possible.\n\ndocumentation\n-------------\npika's documentation can be found at https://pika.readthedocs.io.\n\nexample\n-------\nhere is the most simple example of use, sending a message with the\n``pika.blockingconnection`` adapter:\n\n.. code :: python\n\n    import pika\n\n    connection = pika.blockingconnection()\n    channel = connection.channel()\n    channel.basic_publish(exchange='test', routing_key='test',\n                          body=b'test message.')\n    connection.close()\n\nand an example of writing a blocking consumer:\n\n.. code :: python\n\n    import pika\n\n    connection = pika.blockingconnection()\n    channel = connection.channel()\n\n    for method_frame, properties, body in channel.consume('test'):\n        # display the message parts and acknowledge the message\n        print(method_frame, properties, body)\n        channel.basic_ack(method_frame.delivery_tag)\n\n        # escape out of the loop after 10 messages\n        if method_frame.delivery_tag == 10:\n            break\n\n    # cancel the consumer and return any pending messages\n    requeued_messages = channel.cancel()\n    print('requeued %i messages' % requeued_messages)\n    connection.close()\n\npika provides the following adapters\n------------------------------------\n\n- ``pika.adapters.asyncio_connection.asyncioconnection`` - asynchronous adapter\n  for python 3 `asyncio <https://docs.python.org/3/library/asyncio.html>`_'s\n  i/o loop.\n- ``pika.blockingconnection`` - synchronous adapter on top of library for\n  simple usage.\n- ``pika.selectconnection`` - asynchronous adapter without third-party\n  dependencies.\n- ``pika.adapters.gevent_connection.geventconnection`` - asynchronous adapter\n  for use with `gevent <http://www.gevent.org>`_'s i/o loop.\n- ``pika.adapters.tornado_connection.tornadoconnection`` - asynchronous adapter\n  for use with `tornado <http://tornadoweb.org>`_'s i/o loop.\n- ``pika.adapters.twisted_connection.twistedprotocolconnection`` - asynchronous\n  adapter for use with `twisted <http://twistedmatrix.com>`_'s i/o loop.\n\nmultiple connection parameters\n------------------------------\nyou can also pass multiple ``pika.connectionparameters`` instances for\nfault-tolerance as in the code snippet below (host names are just examples, of\ncourse). to enable retries, set ``connection_attempts`` and ``retry_delay`` as\nneeded in the last ``pika.connectionparameters`` element of the sequence.\nretries occur after connection attempts using all of the given connection\nparameters fail.\n\n.. code :: python\n\n    import pika\n\n    parameters = (\n        pika.connectionparameters(host='rabbitmq.zone1.yourdomain.com'),\n        pika.connectionparameters(host='rabbitmq.zone2.yourdomain.com',\n                                  connection_attempts=5, retry_delay=1))\n    connection = pika.blockingconnection(parameters)\n\nwith non-blocking adapters, such as ``pika.selectconnection`` and\n``pika.adapters.asyncio_connection.asyncioconnection``, you can request a\nconnection using multiple connection parameter instances via the connection\nadapter's ``create_connection()`` class method.\n\nrequesting message acknowledgements from another thread\n-------------------------------------------------------\nthe single-threaded usage constraint of an individual pika connection adapter\ninstance may result in a dropped amqp/stream connection due to amqp heartbeat\ntimeout in consumers that take a long time to process an incoming message. a\ncommon solution is to delegate processing of the incoming messages to another\nthread, while the connection adapter's thread continues to service its i/o\nloop's message pump, permitting amqp heartbeats and other i/o to be serviced in\na timely fashion.\n\nmessages processed in another thread may not be acknowledged directly from that\nthread, since all accesses to the connection adapter instance must be from a\nsingle thread, which is the thread running the adapter's i/o loop. this is\naccomplished by requesting a callback to be executed in the adapter's\ni/o loop thread. for example, the callback function's implementation might look\nlike this:\n\n.. code :: python\n\n    def ack_message(channel, delivery_tag):\n        \"\"\"note that `channel` must be the same pika channel instance via which\n        the message being acknowledged was retrieved (amqp protocol constraint).\n        \"\"\"\n        if channel.is_open:\n            channel.basic_ack(delivery_tag)\n        else:\n            # channel is already closed, so we can't acknowledge this message;\n            # log and/or do something that makes sense for your app in this case.\n            pass\n\nthe code running in the other thread may request the ``ack_message()`` function\nto be executed in the connection adapter's i/o loop thread using an\nadapter-specific mechanism:\n\n- ``pika.blockingconnection`` abstracts its i/o loop from the application and\n  thus exposes ``pika.blockingconnection.add_callback_threadsafe()``. refer to\n  this method's docstring for additional information. for example:\n\n  .. code :: python\n\n      connection.add_callback_threadsafe(functools.partial(ack_message, channel, delivery_tag))\n\n- when using a non-blocking connection adapter, such as\n  ``pika.adapters.asyncio_connection.asyncioconnection`` or\n  ``pika.selectconnection``, you use the underlying asynchronous framework's\n  native api for requesting an i/o loop-bound callback from another thread. for\n  example, ``pika.selectconnection``'s i/o loop provides\n  ``add_callback_threadsafe()``,\n  ``pika.adapters.tornado_connection.tornadoconnection``'s i/o loop has\n  ``add_callback()``, while\n  ``pika.adapters.asyncio_connection.asyncioconnection``'s i/o loop exposes\n  ``call_soon_threadsafe()``.\n\nthis threadsafe callback request mechanism may also be used to delegate\npublishing of messages, etc., from a background thread to the connection\nadapter's thread.\n\nconnection recovery\n-------------------\n\nsome rabbitmq clients (bunny, java, .net, objective-c, swift) provide a way to\nautomatically recover a connection, its channels and topology (e.g. queues,\nbindings and consumers) after a network failure. others require connection\nrecovery to be performed by the application code and strive to make it a\nstraightforward process. pika falls into the second category.\n\npika supports multiple connection adapters. they take different approaches to\nconnection recovery.\n\nfor ``pika.blockingconnection`` adapter exception handling can be used to check\nfor connection errors. here is a very basic example:\n\n.. code :: python\n\n    import pika\n\n    while true:\n        try:\n            connection = pika.blockingconnection()\n            channel = connection.channel()\n            channel.basic_consume('test', on_message_callback)\n            channel.start_consuming()\n        # don't recover if connection was closed by broker\n        except pika.exceptions.connectionclosedbybroker:\n            break\n        # don't recover on channel errors\n        except pika.exceptions.amqpchannelerror:\n            break\n        # recover on all other connection errors\n        except pika.exceptions.amqpconnectionerror:\n            continue\n\nthis example can be found in `examples/consume_recover.py`.\n\ngeneric operation retry libraries such as\n`retry <https://github.com/invl/retry>`_ can be used. decorators make it\npossible to configure some additional recovery behaviours, like delays between\nretries and limiting the number of retries:\n\n.. code :: python\n\n    from retry import retry\n\n\n    @retry(pika.exceptions.amqpconnectionerror, delay=5, jitter=(1, 3))\n    def consume():\n        connection = pika.blockingconnection()\n        channel = connection.channel()\n        channel.basic_consume('test', on_message_callback)\n\n        try:\n            channel.start_consuming()\n        # don't recover connections closed by server\n        except pika.exceptions.connectionclosedbybroker:\n            pass\n\n\n    consume()\n\nthis example can be found in `examples/consume_recover_retry.py`.\n\nfor asynchronous adapters, use ``on_close_callback`` to react to connection\nfailure events. this callback can be used to clean up and recover the\nconnection.\n\nan example of recovery using ``on_close_callback`` can be found in\n`examples/asynchronous_consumer_example.py`.\n\ncontributing\n------------\nto contribute to pika, please make sure that any new features or changes to\nexisting functionality **include test coverage**.\n\n*pull requests that add or change code without adequate test coverage will be\nrejected.*\n\nadditionally, please format your code using\n`yapf <http://pypi.python.org/pypi/yapf>`_ with ``google`` style prior to\nissuing your pull request. *note: only format those lines that you have changed\nin your pull request. if you format an entire file and change code outside of\nthe scope of your pr, it will likely be rejected.*\n\nextending to support additional i/o frameworks\n----------------------------------------------\nnew non-blocking adapters may be implemented in either of the following ways:\n\n- by subclassing ``pika.baseconnection``, implementing its abstract method and\n  passing its constructor an implementation of\n  ``pika.adapters.utils.nbio_interface.abstractioservices``.\n  ``pika.baseconnection`` implements ``pika.connection.connection``'s abstract\n  methods, including internally-initiated connection logic. for examples, refer\n  to the implementations of\n  ``pika.adapters.asyncio_connection.asyncioconnection``,\n  ``pika.adapters.gevent_connection.geventconnection`` and\n  ``pika.adapters.tornado_connection.tornadoconnection``.\n- by subclassing ``pika.connection.connection`` and implementing its abstract\n  methods. this approach facilitates implementation of custom\n  connection-establishment and transport mechanisms. for an example, refer to\n  the implementation of\n  ``pika.adapters.twisted_connection.twistedprotocolconnection``.\n\n.. |version| image:: https://img.shields.io/pypi/v/pika.svg?\n   :target: http://badge.fury.io/py/pika\n\n.. |python versions| image:: https://img.shields.io/pypi/pyversions/pika.svg\n    :target: https://pypi.python.org/pypi/pika\n\n.. |actions status| image:: https://github.com/pika/pika/actions/workflows/main.yaml/badge.svg\n   :target: https://github.com/pika/pika/actions/workflows/main.yaml\n\n.. |coverage| image:: https://img.shields.io/codecov/c/github/pika/pika.svg?\n   :target: https://codecov.io/github/pika/pika?branch=main\n\n.. |license| image:: https://img.shields.io/pypi/l/pika.svg?\n   :target: https://pika.readthedocs.io\n\n.. |docs| image:: https://readthedocs.org/projects/pika/badge/?version=stable\n   :target: https://pika.readthedocs.io\n   :alt: documentation status\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-3-clause",
  "name": "pika",
  "package_url": "https://pypi.org/project/pika/",
  "project_url": "https://pypi.org/project/pika/",
  "project_urls": {
    "Homepage": "https://pika.readthedocs.io",
    "Source": "https://github.com/pika/pika"
  },
  "release_url": "https://pypi.org/project/pika/1.3.2/",
  "requires_dist": [
    "gevent ; extra == 'gevent'",
    "tornado ; extra == 'tornado'",
    "twisted ; extra == 'twisted'"
  ],
  "requires_python": ">=3.7",
  "summary": "pika python amqp client library",
  "version": "1.3.2",
  "releases": [],
  "developers": [
    "gavinmroy@gmail.com",
    "lukerbakken@gmail.com"
  ],
  "kwds": "pika rabbitmq amqpconnectionerror call_soon_threadsafe asyncio_connection",
  "license_kwds": "bsd-3-clause",
  "libtype": "pypi",
  "id": "pypi_pika",
  "homepage": "",
  "release_count": 47,
  "dependency_ids": [
    "pypi_gevent",
    "pypi_tornado",
    "pypi_twisted"
  ]
}