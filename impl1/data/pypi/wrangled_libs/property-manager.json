{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: information technology",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: documentation :: sphinx",
    "topic :: software development",
    "topic :: software development :: documentation",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "property-manager: useful property variants for python programming\n=================================================================\n\n.. image:: https://travis-ci.org/xolox/python-property-manager.svg?branch=master\n   :target: https://travis-ci.org/xolox/python-property-manager\n\n.. image:: https://coveralls.io/repos/github/xolox/python-property-manager/badge.svg?branch=master\n   :target: https://coveralls.io/github/xolox/python-property-manager?branch=master\n\nthe `property-manager` package defines several custom property_ variants for\npython programming including required properties, writable properties, cached\nproperties, etc. it's currently tested on python 2.7, 3.5, 3.6, 3.7, 3.8 and\npypy. for usage instructions please refer to the documentation_.\n\n.. contents::\n   :local:\n\nstatus\n------\n\nthe `property-manager` package came into existence as a submodule of my\nexecutor_ package where i wanted to define classes with a lot of properties\nthat had a default value which was computed on demand but also needed to\nsupport assignment to easily override the default value.\n\nsince i created that module i'd wanted to re-use it in a couple of other\nprojects i was working on, but adding an `executor` dependency just for the\n`property_manager` submodule felt kind of ugly.\n\nthis is when i decided that it was time for the `property-manager` package to\nbe created. when i extracted the submodule from `executor` i significantly\nchanged its implementation (making the code more robust and flexible) and\nimproved the tests, documentation and coverage in the process.\n\ninstallation\n------------\n\nthe `property-manager` package is available on pypi_ which means installation\nshould be as simple as:\n\n.. code-block:: sh\n\n   $ pip install property-manager\n\nthere's actually a multitude of ways to install python packages (e.g. the `per\nuser site-packages directory`_, `virtual environments`_ or just installing\nsystem wide) and i have no intention of getting into that discussion here, so\nif this intimidates you then read up on your options before returning to these\ninstructions ;-).\n\nusage\n-----\n\nthis section shows how to use the most useful property subclasses. please refer\nto the documentation_ for more detailed information.\n\n.. contents::\n   :local:\n\nwritable properties\n~~~~~~~~~~~~~~~~~~~\n\nwritable properties with a computed default value are easy to create using the\nwritable_property_ decorator:\n\n.. code-block:: python\n\n   from random import random\n   from property_manager import writable_property\n\n   class writablepropertydemo(object):\n\n       @writable_property\n       def change_me(self):\n           return random()\n\nfirst let's see how the computed default value behaves:\n\n>>> instance = writablepropertydemo()\n>>> print(instance.change_me)\n0.13692489329941815\n>>> print(instance.change_me)\n0.8664002331885933\n\nas you can see the value is recomputed each time. now we'll assign it a value:\n\n>>> instance.change_me = 42\n>>> print(instance.change_me)\n42\n\nfrom this point onwards `change_me` will be the number 42_ and it's impossible\nto revert back to the computed value:\n\n>>> delattr(instance, 'change_me')\ntraceback (most recent call last):\n  file \"property_manager/__init__.py\", line 584, in __delete__\n    raise attributeerror(msg % (obj.__class__.__name__, self.__name__))\nattributeerror: 'writablepropertydemo' object attribute 'change_me' is read-only\n\nif you're looking for a property that supports both assignment and deletion\n(clearing the assigned value) you can use mutable_property_.\n\nrequired properties\n~~~~~~~~~~~~~~~~~~~\n\nthe required_property_ decorator can be used to create required properties:\n\n.. code-block:: python\n\n   from property_manager import propertymanager, required_property\n\n   class requiredpropertydemo(propertymanager):\n\n       @required_property\n       def important(self):\n           \"\"\"a very important attribute.\"\"\"\n\nwhat does it mean for a property to be required? let's create an instance of\nthe class and find out:\n\n>>> instance = requiredpropertydemo()\ntraceback (most recent call last):\n  file \"property_manager/__init__.py\", line 131, in __init__\n    raise typeerror(\"%s (%s)\" % (msg, concatenate(missing_properties)))\ntypeerror: missing 1 required argument (important)\n\nso the constructor of the class raises an exception when the property hasn't\nbeen given a value. we can give the property a value by providing keyword\narguments to the constructor:\n\n>>> instance = requiredpropertydemo(important=42)\n>>> print(instance)\nrequiredpropertydemo(important=42)\n\nwe can also assign a new value to the property:\n\n>>> instance.important = 13\n>>> print(instance)\nrequiredpropertydemo(important=13)\n\ncached properties\n~~~~~~~~~~~~~~~~~\n\ntwo kinds of cached properties are supported, we'll show both here:\n\n.. code-block:: python\n\n   from random import random\n   from property_manager import cached_property, lazy_property\n\n   class cachedpropertydemo(object):\n\n       @cached_property\n       def expensive(self):\n           print(\"calculating expensive property ..\")\n           return random()\n\n       @lazy_property\n       def non_idempotent(self):\n           print(\"calculating non-idempotent property ..\")\n           return random()\n\nthe properties created by the cached_property_ decorator compute the\nproperty's value on demand and cache the result:\n\n>>> instance = cachedpropertydemo()\n>>> print(instance.expensive)\ncalculating expensive property ..\n0.763863180683\n>>> print(instance.expensive)\n0.763863180683\n\nthe property's cached value can be invalidated in order to recompute its value:\n\n>>> del instance.expensive\n>>> print(instance.expensive)\ncalculating expensive property ..\n0.396322737214\n>>> print(instance.expensive)\n0.396322737214\n\nnow that you understand cached_property_, explaining lazy_property_ is very\nsimple: it simply doesn't support invalidation of cached values! here's how\nthat works in practice:\n\n>>> instance.non_idempotent\ncalculating non-idempotent property ..\n0.27632566561900895\n>>> instance.non_idempotent\n0.27632566561900895\n>>> del instance.non_idempotent\ntraceback (most recent call last):\n  file \"property_manager/__init__.py\", line 499, in __delete__\n    raise attributeerror(msg % (obj.__class__.__name__, self.__name__))\nattributeerror: 'cachedpropertydemo' object attribute 'non_idempotent' is read-only\n>>> instance.non_idempotent\n0.27632566561900895\n\nproperties based on environment variables\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe constructor of the custom_property_ class (and its subclasses) accepts the\nkeyword argument `environment_variable` which can be provided to get the\nproperty's value from the environment:\n\n.. code-block:: python\n\n   from random import random\n   from property_manager import mutable_property\n\n   class environmentpropertydemo(object):\n\n       @mutable_property(environment_variable='whatever_you_want')\n       def environment_based(self):\n           return 'some-default-value'\n\nby default the property's value is computed as expected:\n\n>>> instance = environmentpropertydemo()\n>>> print(instance.environment_based)\nsome-default-value\n\nwhen the environment variable is set it overrides the computed value:\n\n>>> os.environ['whatever_you_want'] = '42'\n>>> print(instance.environment_based)\n42\n\nassigning a value to the property overrides the value from the environment:\n\n>>> instance.environment_based = '13'\n>>> print(instance.environment_based)\n13\n\ndeleting the property clears the assigned value so that the property falls back\nto the environment:\n\n>>> delattr(instance, 'environment_based')\n>>> print(instance.environment_based)\n42\n\nif we now clear the environment variable as well then the property falls back\nto the computed value:\n\n>>> os.environ.pop('whatever_you_want')\n'42'\n>>> print(instance.environment_based)\nsome-default-value\n\nsupport for setters and deleters\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nall of the custom property classes support setters and deleters just like\npython's ``property`` decorator does.\n\nthe `propertymanager` class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwhen you define a class that inherits from the propertymanager_ class the\nfollowing behavior is made available to your class:\n\n- required properties raise an exception if they're not set.\n\n- the values of writable properties can be set by passing\n  keyword arguments to the constructor of your class.\n\n- the `repr()` of your objects will render the name of the class and the names\n  and values of all properties. individual properties can easily be excluded\n  from the `repr()` output.\n\n- the `clear_cached_properties()`_ method can be used to invalidate the cached\n  values of all cached properties at once.\n\nadditionally you can use the property_manager.sphinx_ module as a sphinx\nextension to automatically generate boilerplate documentation that provides an\noverview of base classes, properties, public methods and special methods.\n\nsimilar projects\n----------------\n\nthe python package index contains quite a few packages that provide custom\nproperties with similar semantics:\n\n`cached-property <https://pypi.python.org/pypi/cached-property>`_\n my personal favorite until i wrote my own :-). this package provides several\n cached property variants. it supports threading and time based cache\n invalidation which `property-manager` doesn't support.\n\n`lazy-property <https://pypi.python.org/pypi/lazy-property>`_\n this package provides two cached property variants: a read only property and\n a writable property. both variants cache computed values indefinitely.\n\n`memoized-property <https://pypi.python.org/pypi/memoized-property>`_\n this package provides a single property variant which simply caches computed\n values indefinitely.\n\n`property-caching <https://pypi.python.org/pypi/property-caching>`_\n this package provides several cached property variants supporting class\n properties, object properties and cache invalidation.\n\n`propertylib <https://pypi.python.org/pypi/propertylib>`_\n this package uses metaclasses to implement an alternative syntax for defining\n computed properties. it defines several property variants with semantics that\n are similar to those defined by the `property-manager` package.\n\n`rwproperty <https://pypi.python.org/pypi/rwproperty>`_\n this package implements computed, writable properties using an alternative\n syntax to define the properties.\n\ndistinguishing features\n~~~~~~~~~~~~~~~~~~~~~~~\n\ndespite all of the existing python packages discussed above i decided to create\nand publish the `property-manager` package because it was fun to get to know\npython's `descriptor protocol`_ and i had several features in mind i couldn't\nfind anywhere else:\n\n- a superclass that sets writable properties based on constructor arguments.\n\n- a superclass that understands required properties and raises a clear\n  exception if a required property is not properly initialized.\n\n- clear disambiguation between lazy properties (whose computed value is cached\n  but cannot be invalidated because it would compromise internal state) and\n  cached properties (whose computed value is cached but can be invalidated to\n  compute a fresh value).\n\n- an easy way to quickly invalidate all cached properties of an object.\n\n- an easy way to change the semantics of custom properties, e.g. what if the\n  user wants a writable cached property? with `property-manager` it is trivial\n  to define new property variants by combining existing semantics:\n\n  .. code-block:: python\n\n     from property_manager import cached_property\n\n     class writablecachedpropertydemo(object):\n\n         @cached_property(writable=true)\n         def expensive_overridable_attribute(self):\n             \"\"\"expensive calculations go here.\"\"\"\n\n  the example above creates a new anonymous class and then immediately uses\n  that to decorate the method. we could have given the class a name though:\n\n  .. code-block:: python\n\n     from property_manager import cached_property\n\n     writable_cached_property = cached_property(writable=true)\n\n     class writablecachedpropertydemo(object):\n\n         @writable_cached_property\n         def expensive_overridable_attribute(self):\n             \"\"\"expensive calculations go here.\"\"\"\n\n  by giving the new property variant a name it can be reused. we can go one\n  step further and properly document the new property variant:\n\n  .. code-block:: python\n\n     from property_manager import cached_property\n\n     class writable_cached_property(cached_property):\n\n         \"\"\"a cached property that supports assignment.\"\"\"\n\n         writable = true\n\n     class writablecachedpropertydemo(object):\n\n         @writable_cached_property\n         def expensive_overridable_attribute(self):\n             \"\"\"expensive calculations go here.\"\"\"\n\n  i've used computed properties for years in python and over those years i've\n  learned that different python projects have different requirements from\n  custom property variants. defining every possible permutation up front is\n  madness, but i think that the flexibility with which the `property-manager`\n  package enables adaptation gets a long way. this was the one thing that\n  bothered me the most about all of the other python packages that implement\n  property variants: they are not easily adapted to unanticipated use cases.\n\ncontact\n-------\n\nthe latest version of `property-manager` is available on pypi_ and github_. the\ndocumentation is hosted on `read the docs`_ and includes a changelog_. for bug\nreports please create an issue on github_. if you have questions, suggestions,\netc. feel free to send me an e-mail at `peter@peterodding.com`_.\n\nlicense\n-------\n\nthis software is licensed under the `mit license`_.\n\n\u00a9 2020 peter odding.\n\n\n.. external references:\n.. _42: https://en.wikipedia.org/wiki/42_(number)#the_hitchhiker.27s_guide_to_the_galaxy\n.. _cached_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.cached_property\n.. _changelog: https://property-manager.readthedocs.io/en/latest/changelog.html\n.. _clear_cached_properties(): https://property-manager.readthedocs.io/en/latest/api.html#property_manager.propertymanager.clear_cached_properties\n.. _custom_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.custom_property\n.. _descriptor protocol: https://docs.python.org/2/howto/descriptor.html\n.. _documentation: https://property-manager.readthedocs.io\n.. _executor: https://executor.readthedocs.org/en/latest/\n.. _github: https://github.com/xolox/python-property-manager\n.. _lazy_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.lazy_property\n.. _mit license: http://en.wikipedia.org/wiki/mit_license\n.. _mutable_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.mutable_property\n.. _per user site-packages directory: https://www.python.org/dev/peps/pep-0370/\n.. _peter@peterodding.com: peter@peterodding.com\n.. _property: https://docs.python.org/2/library/functions.html#property\n.. _property_manager.sphinx: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.sphinx\n.. _propertymanager: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.propertymanager\n.. _pypi: https://pypi.python.org/pypi/property-manager\n.. _read the docs: https://property-manager.readthedocs.io\n.. _required_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.required_property\n.. _virtual environments: http://docs.python-guide.org/en/latest/dev/virtualenvs/\n.. _writable_property: https://property-manager.readthedocs.io/en/latest/api.html#property_manager.writable_property\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "property-manager",
  "package_url": "https://pypi.org/project/property-manager/",
  "project_url": "https://pypi.org/project/property-manager/",
  "project_urls": {
    "Homepage": "https://property-manager.readthedocs.io"
  },
  "release_url": "https://pypi.org/project/property-manager/3.0/",
  "requires_dist": [
    "humanfriendly (>=8.0)",
    "verboselogs (>=1.1)"
  ],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
  "summary": "useful property variants for python programming (required properties, writable properties, cached properties, etc)",
  "version": "3.0",
  "releases": [],
  "developers": [
    "peter@peterodding.com",
    "peter_odding"
  ],
  "kwds": "_property_manager _custom_property custom_property_ custom_property property_manager",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_property_manager",
  "homepage": "https://property-manager.readthedocs.io",
  "release_count": 15,
  "dependency_ids": [
    "pypi_humanfriendly",
    "pypi_verboselogs"
  ]
}