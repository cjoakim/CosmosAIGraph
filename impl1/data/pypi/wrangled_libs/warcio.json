{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "warcio: warc (and arc) streaming library\n========================================\n.. image:: https://travis-ci.org/webrecorder/warcio.svg?branch=master\n      :target: https://travis-ci.org/webrecorder/warcio\n.. image:: https://codecov.io/gh/webrecorder/warcio/branch/master/graph/badge.svg\n      :target: https://codecov.io/gh/webrecorder/warcio\n\n\nbackground\n----------\n\nthis library provides a fast, standalone way to read and write `warc\nformat <https://en.wikipedia.org/wiki/web_archive>`__ commonly used in\nweb archives. supports python 2.7+ and python 3.4+ (using\n`six <https://pythonhosted.org/six/>`__, the only external dependency)\n\nwarcio supports reading and writing of warc files compliant with both the `warc 1.0 <http://bibnum.bnf.fr/warc/warc_iso_28500_version1_latestdraft.pdf>`__\nand `warc 1.1 <http://bibnum.bnf.fr/warc/warc_iso_28500_version1-1_latestdraft.pdf>`__ iso standards.\n\ninstall with: ``pip install warcio``\n\nthis library is a spin-off of the warc reading and writing component of\nthe `pywb <https://github.com/webrecorder/pywb>`__ high-fidelity replay\nlibrary, a key component of\n`webrecorder <https://github.com/webrecorder/webrecorder>`__\n\nthe library is designed for fast, low-level access to web archival\ncontent, oriented around a stream of warc records rather than files.\n\nreading warc records\n--------------------\n\na key feature of the library is to be able to iterate over a stream of\nwarc records using the ``archiveiterator``.\n\nit includes the following features:\n\n- reading a warc 1.0, warc 1.1 or arc stream\n- on the fly arc to warc record conversion\n- decompressing and de-chunking http payload content stored in warc/arc files.\n\nfor example, the following prints the the url for each warc ``response``\nrecord:\n\n.. code:: python\n\n    from warcio.archiveiterator import archiveiterator\n\n    with open('path/to/file', 'rb') as stream:\n        for record in archiveiterator(stream):\n            if record.rec_type == 'response':\n                print(record.rec_headers.get_header('warc-target-uri'))\n\nthe stream object could be a file on disk or a remote network stream.\nthe ``archiveiterator`` reads the warc content in a single pass. the\n``record`` is represented by an ``arcwarcrecord`` object which contains\nthe format (arc or warc), record type, the record headers, http headers\n(if any), and raw stream for reading the payload.\n\n.. code:: python\n\n    class arcwarcrecord(object):\n        def __init__(self, *args):\n            (self.format, self.rec_type, self.rec_headers, self.raw_stream,\n             self.http_headers, self.content_type, self.length) = args\n\nreading warc content\n~~~~~~~~~~~~~~~~~~~~\n\nthe ``raw_stream`` can be used to read the rest of the payload directly.\na special ``arcwarcrecord.content_stream()`` function provides a stream that\nautomatically decompresses and de-chunks the http payload, if it is\ncompressed and/or transfer-encoding chunked.\n\narc files\n~~~~~~~~~\n\nthe library provides support for reading (but not writing arc) files.\nthe arc format is legacy but is important to support in a consistent\nmatter. the ``archiveiterator`` can equally iterate over arc and warc\nfiles to emit ``arcwarcrecord`` objects. the special ``arc2warc`` option\nconverts arc records to warcs on the fly, allowing for them to be\naccessed using the same api.\n\n(special ``warciterator`` and ``arciterator`` subclasses of ``archiveiterator``\nare also available to read only warc or only arc files).\n\nwarc and arc streaming\n~~~~~~~~~~~~~~~~~~~~~~\nfor example, here is a snippet for reading an arc and a warc using the\nsame api.\n\nthe example streams a warc and arc file over http using\n`requests <http://docs.python-requests.org/en/master/>`__, printing the\n``warcinfo`` record (or arc header) and any response records (or all arc\nrecords) that contain html:\n\n.. code:: python\n\n    import requests\n    from warcio.archiveiterator import archiveiterator\n\n    def print_records(url):\n        resp = requests.get(url, stream=true)\n\n        for record in archiveiterator(resp.raw, arc2warc=true):\n            if record.rec_type == 'warcinfo':\n                print(record.raw_stream.read())\n\n            elif record.rec_type == 'response':\n                if record.http_headers.get_header('content-type') == 'text/html':\n                    print(record.rec_headers.get_header('warc-target-uri'))\n                    print(record.content_stream().read())\n                    print('')\n\n    # warc\n    print_records('https://archive.org/download/examplearcandwarcfiles/iah-20080430204825-00000-blackbook.warc.gz')\n\n\n    # arc with arc2warc\n    print_records('https://archive.org/download/examplearcandwarcfiles/iah-20080430204825-00000-blackbook.arc.gz')\n\n\nwriting warc records\n--------------------\n\nstarting with 1.6, warcio introduces a way to capture http/s traffic directly\nto a warc file, by monkey-patching python's ``http.client`` library.\n\nthis approach works well with the popular ``requests`` library often used to fetch\nhttp/s content. note that ``requests`` must be imported after the ``capture_http`` module.\n\nquick start to writing a warc\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfetching the url ``https://example.com/`` while capturing the response and request\ninto a gzip compressed warc file named ``example.warc.gz`` can be done with the following four lines:\n\n.. code:: python\n\n    from warcio.capture_http import capture_http\n    import requests  # requests must be imported after capture_http\n\n    with capture_http('example.warc.gz'):\n        requests.get('https://example.com/')\n\n\nthe warc ``example.warc.gz`` will contain two records (the response is written first, then the request).\n\nto write to a default in-memory buffer (``bufferwarcwriter``), don't specify a filename, using ``with capture_http() as writer:``.\n\nadditional requests in the ``capture_http`` context and will be appended to the warc as expected.\n\nthe ``warc-ip-address`` header will also be added for each record if the ip address is available.\n\nthe following example (similar to a `unit test from the test suite <test/test_capture_http.py>`__) demonstrates the resulting records created with ``capture_http``:\n\n.. code:: python\n\n    with capture_http() as writer:\n        requests.get('http://example.com/')\n        requests.get('https://google.com/')\n\n    expected = [('http://example.com/', 'response', true),\n                ('http://example.com/', 'request', true),\n                ('https://google.com/', 'response', true),\n                ('https://google.com/', 'request', true),\n                ('https://www.google.com/', 'response', true),\n                ('https://www.google.com/', 'request', true)\n               ]\n\n     actual = [\n                (record.rec_headers['warc-target-uri'],\n                 record.rec_type,\n                 'warc-ip-address' in record.rec_headers)\n\n                for record in archiveiterator(writer.get_stream())\n              ]\n\n     assert actual == expected\n\n\ncustomizing warc writing\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe library provides a simple and extensible interface for writing\nstandards-compliant warc files.\n\nthe library comes with a basic ``warcwriter`` class for writing to a\nsingle warc file and ``bufferwarcwriter`` for writing to an in-memory\nbuffer. the ``basewarcwriter`` can be extended to support more complex\noperations.\n\n(there is no support for writing legacy arc files)\n\nfor more flexibility, such as to use a custom ``warcwriter`` class,\nthe above example can be written as:\n\n.. code:: python\n\n    from warcio.capture_http import capture_http\n    from warcio import warcwriter\n    import requests  # requests *must* be imported after capture_http\n\n    with open('example.warc.gz', 'wb') as fh:\n        warc_writer = warcwriter(fh)\n        with capture_http(warc_writer):\n            requests.get('https://example.com/')\n\nwarc/1.1 support\n~~~~~~~~~~~~~~~~\n\nby default, warcio creates warc 1.0 records for maximum compatibility with existing tools.\nto create warc/1.1 records, simply specify the warc version as follows:\n\n.. code:: python\n\n    with capture_http('example.warc.gz', warc_version='1.1'):\n        ...\n\n\n.. code:: python\n\n    warcwriter(fh, warc_version='1.1)\n    ...\n\nwhen using warc 1.1, the main difference is that the ``warc-date`` timestamp header\nwill be written with microsecond precision, while warc 1.0 only supports second precision.\n\nwarc 1.0:\n\n.. code::\n\n    warc/1.0\n    ...\n    warc-date: 2018-12-26t10:11:12z\n\nwarc 1.1:\n\n.. code::\n\n    warc/1.1\n    ...\n    warc-date: 2018-12-26t10:11:12.456789z\n\n\n\nfiltering http capture\n~~~~~~~~~~~~~~~~~~~~~~\n\nwhen capturing via http, it is possible to provide a custom filter function, \nwhich can be used to determine if a particular request and response records\nshould be written to the warc file or skipped.\n\nthe filter function is called with the request and response record\nbefore they are written, and can be used to substitute a different record (for example, a revisit\ninstead of a response), or to skip writing altogether by returning nothing, as shown below:\n\n.. code:: python\n\n    def filter_records(request, response, request_recorder):\n        # return none, none to indicate records should be skipped\n        if response.http_headers.get_statuscode() != '200':\n            return none, none\n\n        # the response record can be replaced with a revisit record\n        elif check_for_dedup():\n            response = create_revisit_record(...)\n\n        return request, response\n\n    with capture_http('example.warc.gz', filter_records):\n         requests.get('https://example.com/')\n\nplease refer to\n`test/test\\_capture_http.py <test/test_capture_http.py>`__ for additional examples\nof capturing ``requests`` traffic to warc.\n\nmanual/advanced warc writing\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nbefore 1.6, this was the primary method for fetching a url and then\nwriting to a warc. this process is a bit more verbose,\nbut provides for full control of warc creation and avoid monkey-patching.\n\nthe following example loads ``http://example.com/``, creates a warc\nresponse record, and writes it, gzip compressed, to ``example.warc.gz``\nthe block and payload digests are computed automatically.\n\n.. code:: python\n\n    from warcio.warcwriter import warcwriter\n    from warcio.statusandheaders import statusandheaders\n\n    import requests\n\n    with open('example.warc.gz', 'wb') as output:\n        writer = warcwriter(output, gzip=true)\n\n        resp = requests.get('http://example.com/',\n                            headers={'accept-encoding': 'identity'},\n                            stream=true)\n\n        # get raw headers from urllib3\n        headers_list = resp.raw.headers.items()\n\n        http_headers = statusandheaders('200 ok', headers_list, protocol='http/1.0')\n\n        record = writer.create_warc_record('http://example.com/', 'response',\n                                            payload=resp.raw,\n                                            http_headers=http_headers)\n\n        writer.write_record(record)\n\n\nthe library also includes additional semantics for:\n - creating ``warcinfo`` and ``revisit`` records\n - writing ``response`` and ``request`` records together\n - writing custom warc records\n - reading a full warc record from a stream\n\nplease refer to `warcwriter.py <warcio/warcwriter.py>`__ and\n`test/test\\_writer.py <test/test_writer.py>`__ for additional examples.\n\nwarcio cli: indexing and recompression\n--------------------------------------\n\nthe library currently ships with a few simple command line tools.\n\nindex\n~~~~~\n\nthe ``warcio index`` cmd will print a simple index of the records in the\nwarc file as newline delimited json lines (ndjson).\n\nwarc header fields to include in the index can be specified via the\n``-f`` flag, and are included in the json block (in order, for\nconvenience).\n\n::\n\n    warcio index ./test/data/example-iana.org-chunked.warc -f warc-type,warc-target-uri,content-length\n    {\"warc-type\": \"warcinfo\", \"content-length\": \"137\"}\n    {\"warc-type\": \"response\", \"warc-target-uri\": \"http://www.iana.org/\", \"content-length\": \"7566\"}\n    {\"warc-type\": \"request\", \"warc-target-uri\": \"http://www.iana.org/\", \"content-length\": \"76\"}\n\n\nhttp header fields can be included by prefixing them with the prefix\n``http:``. the special field ``offset`` refers to the record offset within\nthe warc file.\n\n::\n\n    warcio index ./test/data/example-iana.org-chunked.warc -f offset,content-type,http:content-type,warc-target-uri\n    {\"offset\": \"0\", \"content-type\": \"application/warc-fields\"}\n    {\"offset\": \"405\", \"content-type\": \"application/http;msgtype=response\", \"http:content-type\": \"text/html; charset=utf-8\", \"warc-target-uri\": \"http://www.iana.org/\"}\n    {\"offset\": \"8379\", \"content-type\": \"application/http;msgtype=request\", \"warc-target-uri\": \"http://www.iana.org/\"}\n\n(note: this library does not produce cdx or cdxj format indexes often\nassociated with web archives. to create these indexes, please see the\n`cdxj-indexer <https://github.com/webrecorder/cdxj-indexer>`__ tool which extends warcio indexing to provide this functionality)\n\ncheck\n~~~~~\n\nthe ``warcio check`` command will check the payload and block digests\nof warc records, if possible. an exit value of 1 indicates a failure.\n``warcio check -v`` will print verbose output for each record in the\nwarc file.\n\nrecompress\n~~~~~~~~~~\n\nthe ``recompress`` command allows for re-compressing or normalizing warc\n(or arc) files to a record-compressed, gzipped warc file.\n\neach warc record is compressed individually and concatenated. this is\nthe 'canonical' warc storage format used by\n`webrecorder <https://github.com/webrecorder/webrecorder>`__ and other\nweb archiving institutions, and usually stored with a ``.warc.gz``\nextension.\n\nit can be used to: - compress an uncompressed warc - convert any arc\nfile to a compressed warc - fix an improperly compressed warc file (eg.\na warc compressed entirely instead of by record)\n\n::\n\n    warcio recompress ./input.arc.gz ./output.warc.gz\n\n\nextract\n~~~~~~~\n\nthe  ``extract`` command provides a way to extract either the warc and http headers and/or payload of a warc record\nto stdout. given a warc filename and an offset, ``extract`` will print the (decompressed) record at that offset\nin the file to stdout\n\nspecifying --payload or --headers will output only the payload or only the warc + http headers (if any), respectively.\n\n::\n\n    warcio extract [--payload | --headers] filename offset\n\n\nlicense\n~~~~~~~\n\n``warcio`` is licensed under the apache 2.0 license and is part of the\nwebrecorder project.\n\nsee `notice <notice>`__ and `license <license>`__ for details.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "warcio",
  "package_url": "https://pypi.org/project/warcio/",
  "project_url": "https://pypi.org/project/warcio/",
  "project_urls": {
    "Homepage": "https://github.com/webrecorder/warcio"
  },
  "release_url": "https://pypi.org/project/warcio/1.7.4/",
  "requires_dist": [
    "six"
  ],
  "requires_python": "",
  "summary": "streaming warc (and arc) io library",
  "version": "1.7.4",
  "releases": [],
  "developers": [
    "ikreymer@gmail.com",
    "ilya_kreymer"
  ],
  "kwds": "webrecorder examplearcandwarcfiles warc_version warcio warc_writer",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_warcio",
  "homepage": "https://github.com/webrecorder/warcio",
  "release_count": 22,
  "dependency_ids": [
    "pypi_six"
  ]
}