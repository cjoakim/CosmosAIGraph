{
  "classifiers": [
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "pynisher is a library to limit resources of a function call in a synchronous manner.\nyou can use this to ensure that your function doesn't use up more resources than it\nshould.\n\n## usage\n\nlimit the time a process can take\n```python\nimport pynisher\n\n\ndef sleepy(x: int) -> int:\n    time.sleep(x)\n    return x\n\n# you can also use `cpu_time` instead\nwith pynisher.limit(sleepy, wall_time=7) as limited_sleep:\n    x = limited_sleep(10)  # will raise a timeoutexception\n```\n\nlimit the memory usage in a sequential manner\n```python\nfrom pynisher import limit, memorylimitexception, walltimeoutexception\n\n\ndef train_memory_hungry_model(x, y) -> model:\n    # ... do some thing\n    return model\n\nmodel_trainer = limit(\n    train_memory_hungry_model,\n    memory=(500, \"mb\"),\n    wall_time=(1.5, \"h\")  # 1h30m\n)\n\ntry:\n    model = model_trainer(x, y)\nexcept (walltimeoutexception, memorylimitexception):\n    model = none\n```\n\npassing `raises=false` means it will hide all errors and will return `empty` if\nthere is no result to give back.\n\n```python\nfrom pynisher import limit, empty\n\ndef f():\n    raise valueerror()\n\nlimited_f = limit(f, wall_time=(2, \"m\"), raises=false)\nresult = limited_f()\n\nif result is not empty:\n    # ...\n```\n\n\nyou can even use the decorator, in which case it will always be limited.\nplease note in [details](#details) that support for this is limited and mostly\nfor linux.\n```python\nfrom pynisher import restricted\n\n@restricted(wall_time=1, raises=false)\ndef notify_remote_server() -> response:\n    \"\"\"we don't care that this fails, just give it a second to try\"\"\"\n    server = block_until_access(...)\n    response = server.notify()\n\nnotify_remote_server()\n# ... continue on even if it failed\n```\n\nyou can safely raise errors from inside your function and the same kind of error will be reraised\nwith a traceback.\n```python\nfrom pynisher import limit\n\n\ndef f():\n    raise valueerror()\n\nlimited_f = limit(f)\n\ntry:\n    limited_f()\nexcept valueerror as e:\n    ... # do what you need\n```\n\nif returning very large items, prefer to save them to file first and then read the result as\nsending large objects through pipes can be very slow.\n\n```python\nfrom pathlib import path\nimport pickle\n\nfrom pynisher import limit\n\ndef train_gpt3(save_path: path) -> bool:\n    gpt3 = ...\n    gpt3.train()\n    with save_path.open('wb') as f:\n        pickle.dump(gpt3, f)\n\n    return true\n\npath = path('gpt3.model')\ntrainer = limit(train_gpt3, memory=(1_000_000, \"gb\")):\n\ntry:\n    trainer(save_path=path)\n\n    with path.open(\"rb\") as f:\n        gpt3 = pickle.load(f)\n\nexcept memorylimitexception as e:\n    ...\n```\n\n\n## details\npynisher works by running your function inside of a subprocess.\nonce in the subprocess, the resources will be limited for that process before running your\nfunction. the methods for limiting specific resources can be found within the respective\n`pynisher/limiters/<platform>.py`.\n\n#### features\nto check if a feature is supported on your system:\n```python\nfrom pynisher import limit\n\n\nfor limit in [\"cpu_time\", \"wall_time\", \"memory\", \"decorator\"]:\n    print(f\"supports {limit} - {supports(limit)}\")\n\n\nlimited_f = limit(f, ...)\nif not limited_f.supports(\"memory\"):\n    ...\n```\n\ncurrently we mainly support linux with partial support for mac and windows:\n\n| os      | `wall_time`        | `cpu_time`              | `memory`                | `@restricted`      |\n| --      | -----------        | ----------              | --------                | -------------      |\n| linux   | :heavy_check_mark: | :heavy_check_mark:      | :heavy_check_mark:      | :heavy_check_mark: |\n| windows | :heavy_check_mark: | :heavy_check_mark: (1.) | :heavy_check_mark: (1.) | :x:  (3.)          |\n| mac     | :heavy_check_mark: | :heavy_check_mark: (4.) | :x: (2.)                | :x:  (3.)          |\n\n1. limiting memory and cputime on windows is done with the library `pywin32`. there seem\nto be installation issues when instead of using `conda install <x>`, you use `pip install <x>`\ninside a conda environment, specifically only with `python 3.8` and `python 3.9`.\nthe workaround is to instead install `pywin32` with conda, which can be done with\n`pip uninstall pywin32; conda install pywin32`.\nplease see this [issue](https://github.com/mhammond/pywin32/issues/1865) for updates.\n\n2. mac doesn't seem to allow for limiting a processes memory. no workaround has been found\nincluding trying `launchctl` which seems global and ignores memory limiting. possibly `ulimit`\ncould work but needs to be tested. using `setrlimit(rlimit_as, (soft, hard))` does nothing\nand will either fail explicitly or silently, hence we advertise it is not supported.\nhowever, passing a memory limit on mac is still possible but may not do anything useful or\neven raise an error. if you are aware of a solution, please let us know.\n\n3. this is something due to how multiprocessing pickling protocols work, hence `@restricted(...)` does\nnot work for your mac/windows. please use the `limit` method of limiting resources in this case.\n(technically this is supported for mac python 3.7 though). this is likely due to the default\n`spawn` context for windows and mac but using other available methods on mac also seems to not work.\nfor linux, the `fork` and `forkserver` context seems to work.\n\n4. for unknown reasons, using `time.process_time()` to query the cpu time usage within a pynished function\nwill cause the `cpu_time` limits to be ignored on mac, leading to a function that will hang indefinitly\nunless using some other limit. please let us know if this is some known issue or any workarounds are\navailable.\n\n\n#### parameters\nthe full list of options available with both `limit` and `@restricted` are:\n```python\n# the name given to the multiprocessing.process\nname: str | none = none\n\n\n# the memory limit to place. specify the amount of bytes or (int, unit) where unit\n# can be \"b\", \"kb\", \"mb\" or \"gb\"\nmemory: int | tuple[int, str] | none = none\n\n\n# the cpu time in seconds to limit the process to. this time is only counted while the\n# process is active.\n# can provide in (time, units) such as (1.5, \"h\") to indicate one and a half hours.\n# units available are \"s\", \"m\", \"h\"\ncpu_time: int | tuple[float, str] | none = none\n\n\n# the wall time in seconds to limit the process to\n# can provide in (time, units) such as (1.5, \"h\") to indicate one and a half hours.\n# units available are \"s\", \"m\", \"h\"\nwall_time: int | tuple[float, str] | none = none\n\n\n# whether to throw any errors that occured in the subprocess or to silently\n# throw them away. if `true` and an error was raised, `none` will be returned.\n# the errors raised in the subprocess will be the same type that are raised in\n# the controlling process. the exception to this are memoryerrors which occur\n# in the subprocess, we convert these to memorylimitexception.\nraises: bool = true\n\n\n# this is the multiprocess context used, please refer to their documentation\n# https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\ncontext: \"fork\" | \"spawn\" | \"forkserver\" | basecontext | none = none\n\n\n# whether to emit warnings from  limit or not. the current warnings:\n# * when the memory limit is lower than the starting memory of a process\n# * when trying to remove the memory limit for sending back information\n#   from the subprocess to the main process\nwarnings: bool = true\n\n\n# how to handle errors. if `bool` then this decides whether or not to wrap them in\n# a pynisher exception. if `list`, you can specify which errors get wrapped in a\n# pynisher exception and if `dict`, you can specify what kind of errors get wrapped\n# and how. see `pynisher::pynisher::__init__` for more details on `dict`\n#\n# * wrap_errors={ \"memory\": [importerror, (oserror, 22)], \"pynisher\": [valueerror] }\n#\n# we check that the exception is explicitly of the same type and not just a subclass.\n# this is to prevent accidentally wrapping to eagerly.\nwrap_errors: bool | list[exception] | dict = false\n\n\n# whether to terminate child processes of your limited function.\n# by default, pynisher will kill any subprocesses your function may spawn. if this\n# is not desired behaviour, please use `daemon=true` with your spawned subprocesses\n# and set `terminate_child_processes` to `false`\nterminate_child_processes: bool = true\n\n# whether keyboard interrupts should forceably kill any subprocess or the\n# pynished function. if true, it will temrinate the process tree of\n# the pynished function and then reraise the keyboardinterrupt.\nforceful_keyboard_interrupt: bool = true\n```\n\n#### exceptions\npynisher will let all subprocess `exceptions` buble up to the controlling process.\nif a subprocess exceeds a limit, one of `cputimeoutexception`, `walltimeoutexception` or `memorylimitexception` are raised, but you can use their base classes to cover them more generally.\n\n```python\nclass pynisherexception(exception): ...\n    \"\"\"when a subprocess exceeds a limit\"\"\"\n\nclass timeoutexception(pynisherexception): ...\n    \"\"\"when a subprocess exceeds a time limit (walltime or cputime)\"\"\"\n\nclass cputimeoutexception(timeoutexception): ...\n    \"\"\"when a subprocess exceeds its cpu time limit\"\"\"\n\nclass walltimeoutexception(timeoutexception):\n    \"\"\"when a subprocess exceeds its wall time limit\"\"\"\n\nclass memorylimitexception(pynisherexception, memoryerror):\n    \"\"\"when a subprocess tries to allocate memory that would take it over the limit\n\n    this also inherits from memoryerror as it is technically a memoryerror that we\n    catch and convert.\n    \"\"\"\n```\n\n## changes from v0.6.0\nfor simplicity, pynisher will no longer try to control `stdout`, `stderr`, instead\nusers can use the builtins `redirect_stdout` and `redirect_stderr` of python to\nsend things as needed.\n\npynisher issues warnings through `stderr`. depending on how you set up the `context`\nto spawn a new process, using objects may now work as intended. the safest option\nis to write to a file if needed.\n\n```python\nfrom contextlib import redirect_stderr\n\n# you can always disable warnings\nlimited_f = limit(func, warnings=false)\n\n# capture warnings in a file\n# only seems to work properly on linux\nwith open(\"stderr.txt\", \"w\") as stderr, redirect_stderr(stderr):\n    limited_f()\n\nwith open(\"stderr.txt\", \"r\") as stderr:\n    print(stderr.readlines())\n```\n\nthe support for passing a `logger` to `pynisher` has also been removed. the only diagnostics\ninformation that would have been sent to the logger is not communicated with prints to `stderr`.\nthese diagnostic messages only occur when an attempt to limit resources failed\nthis can be captured or disabled as above.\n\nany other kind of issue will raise an exception with relevant information.\n\nthe support for checking `exit_status` was removed and the success of a pynisher process can\nbe handled in the usual python manner of checking for errors, with a `try: except:`. if you\ndon't care for the `exit_status` then use `f = limit(func, raises=false)` and you can\ncheck for output `output = f(...)`. this will be `none` if an error was raised and was `raises=false`.\n\npynisher no longer times your function for you with `self.wall_clock_time`. if you need to measure\nthe duration it ran, please do so outside of `pynisher`.\n\nthe exceptions were also changed, please see [exceptions](#exceptions)\n\n## controlling namespace pollution\nas an advanced use case, sometimes you might want to keep the modules imported for your\nlimited function to be local only, preventing this from leaking to the main process that\nruns created the limited function. you have three ways to control that the locally imported\nerror does not pollute the main namespace.\n\n```python\nimport sys\nfrom pynisher import pynisherexception, limit\n\ndef import_sklearn() -> none:\n    \"\"\"imports sklearn into a local namespace and has an sklearn object in its args\"\"\"\n    from sklearn.exceptions import notfittederror\n    from sklearn.svm import svr\n\n    assert \"sklearn\" in sys.modules.keys()\n    raise notfittederror(svr())\n\n\nif __name__ == \"__main__\":\n    # wrapping all errors\n    lf = limit(import_sklearn, wrap_errors=true)\n    try:\n        lf()\n    except pynisherexception:\n        assert \"sklearn\" not in sys.modules.keys()\n\n    # wrapping only specific errors\n    lf = limit(import_sklearn, wrap_errors=[\"notfittederror\"])\n    try:\n        lf()\n    except pynisherexception:\n        assert \"sklearn\" not in sys.modules.keys()\n\n    # wrapping that error specifically as a pynisherexception\n    lf = limit(import_sklearn, wrap_errors={\"pynisher\": [\"notfittederror\"]})\n    try:\n        lf()\n    except pynisherexception:\n        assert \"sklearn\" not in sys.modules.keys()\n```\n\n\n## pynisher and multithreading\nwhen pynisher is used together with the python threading library, it is possible to run into\na deadlock when using the standard ``fork`` method to start new processes as described in\n\n* https://github.com/delgan/loguru/issues/231\n* https://gist.github.com/mfm24/e62ec5d50c672524107ca00a391e6104\n* https://github.com/dask/dask/issues/3759\n\none way of solving this would be to change the forking behavior as described\n`here <https://github.com/google/python-atfork/blob/main/atfork/stdlib_fixer.py>`_, but this is\nalso makes very strong assumptions on how the code is executed. an alternative is passing a\n`context <https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods>`_\nwhich uses either ``spawn`` or ``forkserver`` as the process startup method.\n\n\n## nested pynisher and multiprocessing contexts\nbe careful when using multiple contexts for multiprocessing while using `pynisher`. if your\npynished function spawns subprocess using `\"forkserver\"` while you set `pynisher` to use\nthe context `\"fork\"`, then issues can begin to occur when terminate processes.\n\n## project origin\nthis repository is based on stefan falkner's https://github.com/sfalkner/pynisher.\n",
  "docs_url": null,
  "keywords": "resources",
  "license": "mit",
  "name": "pynisher",
  "package_url": "https://pypi.org/project/pynisher/",
  "project_url": "https://pypi.org/project/pynisher/",
  "project_urls": {
    "Homepage": "https://github.com/automl/pynisher"
  },
  "release_url": "https://pypi.org/project/pynisher/1.0.10/",
  "requires_dist": [
    "psutil",
    "typing_extensions",
    "pywin32; platform_system == \"Windows\"",
    "pytest; extra == \"test\"",
    "pre-commit; extra == \"test\"",
    "pytest-cov; extra == \"test\"",
    "pytest-forked; extra == \"test\"",
    "pydocstyle[toml]; extra == \"test\"",
    "isort; extra == \"test\"",
    "black; extra == \"test\"",
    "flake8; extra == \"test\"",
    "mypy; extra == \"test\"",
    "scikit-learn; extra == \"test\""
  ],
  "requires_python": ">=3.7",
  "summary": "a library to limit the resources used by functions using subprocesses",
  "version": "1.0.10",
  "releases": [],
  "developers": [
    "feurerm@informatik.uni-freiburg.de"
  ],
  "kwds": "train_memory_hungry_model limited_sleep memoryerror memoryerrors wall_clock_time",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pynisher",
  "homepage": "https://github.com/automl/pynisher",
  "release_count": 22,
  "dependency_ids": [
    "pypi_black",
    "pypi_flake8",
    "pypi_isort",
    "pypi_mypy",
    "pypi_pre_commit",
    "pypi_psutil",
    "pypi_pydocstyle",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_forked",
    "pypi_pywin32",
    "pypi_scikit_learn",
    "pypi_typing_extensions"
  ]
}