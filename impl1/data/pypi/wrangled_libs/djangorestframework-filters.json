{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: internet :: www/http"
  ],
  "description": "django rest framework filters\n=============================\n\n.. image:: https://travis-ci.org/philipn/django-rest-framework-filters.png?branch=master\n  :target: https://travis-ci.org/philipn/django-rest-framework-filters\n\n.. image:: https://codecov.io/gh/philipn/django-rest-framework-filters/branch/master/graph/badge.svg\n  :target: https://codecov.io/gh/philipn/django-rest-framework-filters\n\n.. image:: https://img.shields.io/pypi/v/djangorestframework-filters.svg\n  :target: https://pypi.python.org/pypi/djangorestframework-filters\n\n\n``django-rest-framework-filters`` is an extension to `django rest framework`_ and `django filter`_\nthat makes it easy to filter across relationships. historically, this extension also provided a\nnumber of additional features and fixes, however the number of features has shrunk as they are\nmerged back into ``django-filter``.\n\n.. _`django rest framework`: https://github.com/tomchristie/django-rest-framework\n.. _`django filter`: https://github.com/carltongibson/django-filter\n\nusing ``django-rest-framework-filters``, we can easily do stuff like::\n\n    /api/article?author__first_name__icontains=john\n    /api/article?is_published!=true\n\n.. contents::\n    **table of contents**\n    :local:\n    :depth: 2\n    :backlinks: none\n\nfeatures\n--------\n\n* easy filtering across relationships\n* support for method filtering across relationships\n* automatic filter negation with a simple ``param!=value`` syntax\n* backend caching to increase performance\n\n\nrequirements\n------------\n\n* **python**: 2.7 or 3.3+\n* **django**: 1.8, 1.9, 1.10, 1.11\n* **drf**: 3.5, 3.6\n\n\ninstallation\n------------\n\n.. code-block:: bash\n\n    $ pip install djangorestframework-filters\n\n\nusage\n-----\n\nupgrading from ``django-filter`` to ``django-rest-framework-filters`` is straightforward:\n\n* import from ``rest_framework_filters`` instead of from ``django_filters``\n* use the ``rest_framework_filters`` backend instead of the one provided by ``django_filter``.\n\n.. code-block:: python\n\n    # django-filter\n    from django_filters.rest_framework import filterset, filters\n\n    class productfilter(filterset):\n        manufacturer = filters.modelchoicefilter(queryset=manufacturer.objects.all())\n        ...\n\n\n    # django-rest-framework-filters\n    import rest_framework_filters as filters\n\n    class productfilter(filters.filterset):\n        manufacturer = filters.modelchoicefilter(queryset=manufacturer.objects.all())\n        ...\n\n\nto use the django-rest-framework-filters backend, add the following to your settings:\n\n.. code-block:: python\n\n    rest_framework = {\n        'default_filter_backends': (\n            'rest_framework_filters.backends.djangofilterbackend', ...\n        ),\n        ...\n\n\nonce configured, you can continue to use all of the filters found in ``django-filter``.\n\n\nfiltering across relationships\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nyou can easily traverse multiple relationships when filtering by using ``relatedfilter``:\n\n.. code-block:: python\n\n    from rest_framework import viewsets\n    import rest_framework_filters as filters\n\n\n    class managerfilter(filters.filterset):\n        class meta:\n            model = manager\n            fields = {'name': ['exact', 'in', 'startswith']}\n\n\n    class departmentfilter(filters.filterset):\n        manager = filters.relatedfilter(managerfilter, name='manager', queryset=manager.objects.all())\n\n        class meta:\n            model = department\n            fields = {'name': ['exact', 'in', 'startswith']}\n\n\n    class companyfilter(filters.filterset):\n        department = filters.relatedfilter(departmentfilter, name='department', queryset=department.objects.all())\n\n        class meta:\n            model = company\n            fields = {'name': ['exact', 'in', 'startswith']}\n\n\n    # company viewset\n    class companyview(viewsets.modelviewset):\n        filter_class = companyfilter\n        ...\n\nexample filter calls:\n\n.. code-block::\n\n    /api/companies?department__name=accounting\n    /api/companies?department__manager__name__startswith=bob\n\n``queryset`` callables\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nsince ``relatedfilter`` is a subclass of ``modelchoicefilter``, the ``queryset`` argument supports callable behavior.\nin the following example, the set of departments is restricted to those in the user's company.\n\n.. code-block:: python\n\n    def departments(request):\n        company = request.user.company\n        return company.department_set.all()\n\n    class employeefilter(filters.filterset):\n        department = filters.relatedfilter(filterset=departmentfilter, queryset=departments)\n        ...\n\nrecursive relationships\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nrecursive relations are also supported. it may be necessary to specify the full module path.\n\n.. code-block:: python\n\n    class personfilter(filters.filterset):\n        name = filters.alllookupsfilter(name='name')\n        best_friend = filters.relatedfilter('people.views.personfilter', name='best_friend', queryset=person.objects.all())\n\n        class meta:\n            model = person\n\nsupporting ``filter.method``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``django_filters.methodfilter`` has been deprecated and reimplemented as the ``method`` argument\nto all filter classes. it incorporates some of the implementation details of the old\n``rest_framework_filters.methodfilter``, but requires less boilerplate and is simpler to write.\n\n* it is no longer necessary to perform empty/null value checking.\n* you may use any filter class (``charfilter``, ``booleanfilter``, etc...) which will\n  validate input values for you.\n* the argument signature has changed from ``(name, qs, value)`` to ``(qs, name, value)``.\n\n.. code-block:: python\n\n    class postfilter(filters.filterset):\n        # note the use of booleanfilter, the original model field's name, and the method argument.\n        is_published = filters.booleanfilter(name='date_published', method='filter_is_published')\n\n        class meta:\n            model = post\n            fields = ['title', 'content']\n\n        def filter_is_published(self, qs, name, value):\n            \"\"\"\n            `is_published` is based on the `date_published` model field.\n            if the publishing date is null, then the post is not published.\n            \"\"\"\n            # incoming value is normalized as a boolean by booleanfilter\n            isnull = not value\n            lookup_expr = lookup_sep.join([name, 'isnull'])\n\n            return qs.filter(**{lookup_expr: isnull})\n\n    class authorfilter(filters.filterset):\n        posts = filters.relatedfilter('postfilter', queryset=post.objects.all())\n\n        class meta:\n            model = author\n            fields = ['name']\n\nthe above would enable the following filter calls:\n\n.. code-block::\n\n    /api/posts?is_published=true\n    /api/authors?posts__is_published=true\n\n\nin the first api call, the filter method receives a queryset of posts. in the second,\nit receives a queryset of users. the filter method in the example modifies the lookup\nname to work across the relationship, allowing you to find published posts, or authors\nwho have published posts.\n\nautomatic filter negation/exclusion\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nfiltersets support automatic exclusion using a simple ``param!=value`` syntax. this syntax\ninternally sets the ``exclude`` property on the filter.\n\n.. code-block::\n\n    /api/page?title!=the%20park\n\nthis syntax supports regular filtering combined with exclusion filtering. for example, the\nfollowing would search for all articles containing \"hello\" in the title, while excluding\nthose containing \"world\".\n\n.. code-block::\n\n    /api/articles?title__contains=hello&title__contains!=world\n\nnote that most filters only accept a single query parameter. in the above, ``title__contains``\nand ``title__contains!`` are interpreted as two separate query parameters. the following would\nprobably be invalid, although it depends on the specifics of the individual filter class:\n\n.. code-block::\n\n    /api/articles?title__contains=hello&title__contains!=world&title_contains!=friend\n\n\nallowing any lookup type on a field\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif you need to enable several lookups for a field, django-filter provides the dict-syntax for\n``meta.fields``.\n\n.. code-block:: python\n\n    class productfilter(filters.filterset):\n        class meta:\n            model = product\n            fields = {\n                'price': ['exact', 'lt', 'gt', ...],\n            }\n\n``django-rest-framework-filters`` also allows you to enable all possible lookups for any field.\nthis can be achieved through the use of ``alllookupsfilter`` or using the ``'__all__'`` value in\nthe ``meta.fields`` dict-style syntax. generated filters (``meta.fields``, ``alllookupsfilter``)\nwill never override your declared filters.\n\nnote that using all lookups comes with the same admonitions as enabling ``'__all__'`` fields in\ndjango forms (`docs`_). exposing all lookups may allow users to construct queries that\ninadvertently leak data. use this feature responsibly.\n\n.. _`docs`: https://docs.djangoproject.com/en/1.10/topics/forms/modelforms/#selecting-the-fields-to-use\n\n.. code-block:: python\n\n    class productfilter(filters.filterset):\n        # not overridden by `__all__`\n        price__gt = filters.numberfilter(name='price', lookup_expr='gt', label='minimum price')\n\n        class meta:\n            model = product\n            fields = {\n                'price': '__all__',\n            }\n\n    # or\n\n    class productfilter(filters.filterset):\n        price = filters.alllookupsfilter()\n\n        # not overridden by `alllookupsfilter`\n        price__gt = filters.numberfilter(name='price', lookup_expr='gt', label='minimum price')\n\n        class meta:\n            model = product\n\nyou cannot combine ``alllookupsfilter`` with ``relatedfilter`` as the filter names would clash.\n\n.. code-block:: python\n\n    class productfilter(filters.filterset):\n        manufacturer = filters.relatedfilter('manufacturerfilter', queryset=manufacturer.objects.all())\n        manufacturer = filters.alllookupsfilter()\n\nto work around this, you have the following options:\n\n.. code-block:: python\n\n    class productfilter(filters.filterset):\n        manufacturer = filters.relatedfilter('manufacturerfilter', queryset=manufacturer.objects.all())\n\n        class meta:\n            model = product\n            fields = {\n                'manufacturer': '__all__',\n            }\n\n    # or\n\n    class productfilter(filters.filterset):\n        manufacturer = filters.relatedfilter('manufacturerfilter', queryset=manufacturer.objects.all(), lookups='__all__')  # `lookups` also accepts a list\n\n        class meta:\n            model = product\n\n\ncan i mix and match ``django-filter`` and ``django-rest-framework-filters``?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nyes you can. ``django-rest-framework-filters`` is simply an extension of ``django-filter``. note\nthat ``relatedfilter`` and other ``django-rest-framework-filters`` features are designed to work\nwith ``rest_framework_filters.filterset`` and will not function on a ``django_filters.filterset``.\nhowever, the target ``relatedfilter.filterset`` may point to a ``filterset`` from either package,\nand both ``filterset`` implementations are compatible with the other's drf backend.\n\n.. code-block:: python\n\n    # valid\n    class vanillafilter(django_filters.filterset):\n        ...\n\n    class drffilter(rest_framework_filters.filterset):\n        vanilla = rest_framework_filters.relatedfilter(filterset=vanillafilter, queryset=...)\n\n\n    # invalid\n    class drffilter(rest_framework_filters.filterset):\n        ...\n\n    class vanillafilter(django_filters.filterset):\n        drf = rest_framework_filters.relatedfilter(filterset=drffilter, queryset=...)\n\n\ncaveats & limitations\n~~~~~~~~~~~~~~~~~~~~~\n\n``multiwidget`` is incompatible\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ndjangorestframework-filters is not compatible with form widgets that parse query names that differ from the filter's\nattribute name. although this only practically applies to ``multiwidget``, it is a general limitation that affects\ncustom widgets that also have this behavior. affected filters include ``rangefilter``, ``datetimefromtorangefilter``,\n``datefromtorangefilter``, ``timerangefilter``, and ``numericrangefilter``.\n\nto demonstrate the incompatiblity, take the following filterset:\n\n.. code-block:: python\n\n    class postfilter(filterset):\n        publish_date = filters.datefromtorangefilter()\n\nthe above filter allows users to perform a ``range`` query on the publication date. the filter class internally uses\n``multiwidget`` to separately parse the upper and lower bound values. the incompatibility lies in that ``multiwidget``\nappends an index to its inner widget names. instead of parsing ``publish_date``, it expects ``publish_date_0`` and\n``publish_date_1``. it is possible to fix this by including the attribute name in the querystring, although this is\nnot recommended.\n\n.. code-block::\n\n    ?publish_date_0=2016-01-01&publish_date_1=2016-02-01&publish_date=\n\n``multiwidget`` is also discouraged since:\n\n* ``core-api`` field introspection fails for similar reasons\n* ``_0`` and ``_1`` are less api-friendly than ``_min`` and ``_max``\n\nthe recommended solutions are to either:\n\n* create separate filters for each of the sub-widgets (such as ``publish_date_min`` and ``publish_date_max``).\n* use a csv-based filter such as those derived from ``basecsvfilter``/``baseinfilter``/``baserangefilter``. eg,\n\n.. code-block::\n\n    ?publish_date__range=2016-01-01,2016-02-01\n\n\nmigrating to 1.0\n----------------\n\n``relatedfilter.queryset`` now required\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe related filterset's model is no longer used to provide the default value for ``relatedfilter.queryset``. this\nchange reduces the chance of unintentionally exposing data in the rendered filter forms. you must now explicitly\nprovide the ``queryset`` argument, or override the ``get_queryset()`` method (see `queryset callables`_).\n\n\n``get_filters()`` renamed to ``expand_filters()``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndjango-filter has add a ``get_filters()`` classmethod to it's api, so this method has been renamed.\n\n\npublishing\n----------\n\n.. code-block:: bash\n\n    $ pip install -u twine setuptools wheel\n    $ rm -rf dist/ build/\n    $ python setup.py sdist bdist_wheel\n    $ twine upload dist/*\n\n\nlicense\n-------\ncopyright (c) 2013-2015 philip neustrom <philipn@gmail.com>,\n2016-2017 ryan p kilby <rpkilby@ncsu.edu>\n\npermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"software\"), to deal\nin the software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the software, and to permit persons to whom the software is\nfurnished to do so, subject to the following conditions:\n\nthe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the software.\n\nthe software is provided \"as is\", without warranty of any kind, express or\nimplied, including but not limited to the warranties of merchantability,\nfitness for a particular purpose and noninfringement. in no event shall the\nauthors or copyright holders be liable for any claim, damages or other\nliability, whether in an action of contract, tort or otherwise, arising from,\nout of or in connection with the software or the use or other dealings in\nthe software.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "djangorestframework-filters",
  "package_url": "https://pypi.org/project/djangorestframework-filters/",
  "project_url": "https://pypi.org/project/djangorestframework-filters/",
  "project_urls": {
    "Homepage": "http://github.com/philipn/django-rest-framework-filters"
  },
  "release_url": "https://pypi.org/project/djangorestframework-filters/0.11.1/",
  "requires_dist": [
    "djangorestframework",
    "django-filter (~=1.1)"
  ],
  "requires_python": "",
  "summary": "better filtering for django rest framework",
  "version": "0.11.1",
  "releases": [],
  "developers": [
    "philip_neustrom",
    "philipn@gmail.com"
  ],
  "kwds": "rest_framework_filters django_filters django_filter djangofilterbackend relatedfilter",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_djangorestframework_filters",
  "homepage": "http://github.com/philipn/django-rest-framework-filters",
  "release_count": 20,
  "dependency_ids": [
    "pypi_django_filter",
    "pypi_djangorestframework"
  ]
}