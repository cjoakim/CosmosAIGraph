{
  "classifiers": [
    "intended audience :: developers",
    "natural language :: chinese (simplified)",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "topic :: utilities"
  ],
  "description": "# paddleocr package\n\n## 1 get started quickly\n### 1.1 install package\ninstall by pypi\n```bash\npip install \"paddleocr>=2.0.1\" # recommend to use version 2.0.1+\n```\n\nbuild own whl package and install\n```bash\npython3 setup.py bdist_wheel\npip3 install dist/paddleocr-x.x.x-py3-none-any.whl # x.x.x is the version of paddleocr\n```\n## 2 use\n### 2.1 use by code\nthe paddleocr whl package will automatically download the ppocr lightweight model as the default model, which can be customized and replaced according to the section 3 **custom model**.\n\n* detection angle classification and recognition\n```python\nfrom paddleocr import paddleocr,draw_ocr\n# paddleocr supports chinese, english, french, german, korean and japanese.\n# you can set the parameter `lang` as `ch`, `en`, `french`, `german`, `korean`, `japan`\n# to switch the language model in order.\nocr = paddleocr(use_angle_cls=true, lang='en') # need to run only once to download and load model into memory\nimg_path = 'paddleocr/doc/imgs_en/img_12.jpg'\nresult = ocr.ocr(img_path, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# draw result\nfrom pil import image\nresult = result[0]\nimage = image.open(img_path).convert('rgb')\nboxes = [line[0] for line in result]\ntxts = [line[1][0] for line in result]\nscores = [line[1][1] for line in result]\nim_show = draw_ocr(image, boxes, txts, scores, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n\noutput will be a list, each item contains bounding box, text and recognition confidence\n```bash\n[[[442.0, 173.0], [1169.0, 173.0], [1169.0, 225.0], [442.0, 225.0]], ['acknowledgements', 0.99283075]]\n[[[393.0, 340.0], [1207.0, 342.0], [1207.0, 389.0], [393.0, 387.0]], ['we would like to thank all the designers and', 0.9357758]]\n[[[399.0, 398.0], [1204.0, 398.0], [1204.0, 433.0], [399.0, 433.0]], ['contributors whohave been involved in the', 0.9592447]]\n......\n```\n\nvisualization of results\n\n<div align=\"center\">\n    <img src=\"../imgs_results/whl/12_det_rec.jpg\" width=\"800\">\n</div>\n\n* detection and recognition\n```python\nfrom paddleocr import paddleocr,draw_ocr\nocr = paddleocr(lang='en') # need to run only once to download and load model into memory\nimg_path = 'paddleocr/doc/imgs_en/img_12.jpg'\nresult = ocr.ocr(img_path, cls=false)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# draw result\nfrom pil import image\nresult = result[0]\nimage = image.open(img_path).convert('rgb')\nboxes = [line[0] for line in result]\ntxts = [line[1][0] for line in result]\nscores = [line[1][1] for line in result]\nim_show = draw_ocr(image, boxes, txts, scores, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n\noutput will be a list, each item contains bounding box, text and recognition confidence\n```bash\n[[[442.0, 173.0], [1169.0, 173.0], [1169.0, 225.0], [442.0, 225.0]], ['acknowledgements', 0.99283075]]\n[[[393.0, 340.0], [1207.0, 342.0], [1207.0, 389.0], [393.0, 387.0]], ['we would like to thank all the designers and', 0.9357758]]\n[[[399.0, 398.0], [1204.0, 398.0], [1204.0, 433.0], [399.0, 433.0]], ['contributors whohave been involved in the', 0.9592447]]\n......\n```\n\nvisualization of results\n\n<div align=\"center\">\n    <img src=\"../imgs_results/whl/12_det_rec.jpg\" width=\"800\">\n</div>\n\n* classification and recognition\n```python\nfrom paddleocr import paddleocr\nocr = paddleocr(use_angle_cls=true, lang='en') # need to run only once to load model into memory\nimg_path = 'paddleocr/doc/imgs_words_en/word_10.png'\nresult = ocr.ocr(img_path, det=false, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n```\n\noutput will be a list, each item contains recognition text and confidence\n```bash\n['pain', 0.990372]\n```\n\n* only detection\n```python\nfrom paddleocr import paddleocr,draw_ocr\nocr = paddleocr() # need to run only once to download and load model into memory\nimg_path = 'paddleocr/doc/imgs_en/img_12.jpg'\nresult = ocr.ocr(img_path,rec=false)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# draw result\nfrom pil import image\nresult = result[0]\nimage = image.open(img_path).convert('rgb')\nim_show = draw_ocr(image, result, txts=none, scores=none, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n\noutput will be a list, each item only contains bounding box\n```bash\n[[756.0, 812.0], [805.0, 812.0], [805.0, 830.0], [756.0, 830.0]]\n[[820.0, 803.0], [1085.0, 801.0], [1085.0, 836.0], [820.0, 838.0]]\n[[393.0, 801.0], [715.0, 805.0], [715.0, 839.0], [393.0, 836.0]]\n......\n```\n\nvisualization of results\n\n<div align=\"center\">\n    <img src=\"../imgs_results/whl/12_det.jpg\" width=\"800\">\n</div>\n\n* only recognition\n```python\nfrom paddleocr import paddleocr\nocr = paddleocr(lang='en') # need to run only once to load model into memory\nimg_path = 'paddleocr/doc/imgs_words_en/word_10.png'\nresult = ocr.ocr(img_path, det=false, cls=false)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n```\n\noutput will be a list, each item contains recognition text and confidence\n```bash\n['pain', 0.990372]\n```\n\n* only classification\n```python\nfrom paddleocr import paddleocr\nocr = paddleocr(use_angle_cls=true) # need to run only once to load model into memory\nimg_path = 'paddleocr/doc/imgs_words_en/word_10.png'\nresult = ocr.ocr(img_path, det=false, rec=false, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n```\n\noutput will be a list, each item contains classification result and confidence\n```bash\n['0', 0.99999964]\n```\n\n### 2.2 use by command line\n\nshow help information\n```bash\npaddleocr -h\n```\n\n* detection classification and recognition\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_en/img_12.jpg --use_angle_cls true --lang en\n```\n\noutput will be a list, each item contains bounding box, text and recognition confidence\n```bash\n[[[441.0, 174.0], [1166.0, 176.0], [1165.0, 222.0], [441.0, 221.0]], ('acknowledgements', 0.9971134662628174)]\n[[[403.0, 346.0], [1204.0, 348.0], [1204.0, 384.0], [402.0, 383.0]], ('we would like to thank all the designers and', 0.9761400818824768)]\n[[[403.0, 396.0], [1204.0, 398.0], [1204.0, 434.0], [402.0, 433.0]], ('contributors who have been involved in the', 0.9791957139968872)]\n......\n```\n\npdf file is also supported, you can infer the first few pages by using the `page_num` parameter, the default is 0, which means infer all pages\n```bash\npaddleocr --image_dir ./xxx.pdf --use_angle_cls true --use_gpu false --page_num 2\n```\n\n* detection and recognition\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_en/img_12.jpg --lang en\n```\n\noutput will be a list, each item contains bounding box, text and recognition confidence\n```bash\n[[[441.0, 174.0], [1166.0, 176.0], [1165.0, 222.0], [441.0, 221.0]], ('acknowledgements', 0.9971134662628174)]\n[[[403.0, 346.0], [1204.0, 348.0], [1204.0, 384.0], [402.0, 383.0]], ('we would like to thank all the designers and', 0.9761400818824768)]\n[[[403.0, 396.0], [1204.0, 398.0], [1204.0, 434.0], [402.0, 433.0]], ('contributors who have been involved in the', 0.9791957139968872)]\n......\n```\n\n* classification and recognition\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_words_en/word_10.png --use_angle_cls true --det false --lang en\n```\n\noutput will be a list, each item contains text and recognition confidence\n```bash\n['pain', 0.9934559464454651]\n```\n\n* only detection\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_en/img_12.jpg --rec false\n```\n\noutput will be a list, each item only contains bounding box\n```bash\n[[397.0, 802.0], [1092.0, 802.0], [1092.0, 841.0], [397.0, 841.0]]\n[[397.0, 750.0], [1211.0, 750.0], [1211.0, 789.0], [397.0, 789.0]]\n[[397.0, 702.0], [1209.0, 698.0], [1209.0, 734.0], [397.0, 738.0]]\n......\n```\n\n* only recognition\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_words_en/word_10.png --det false --lang en\n```\n\noutput will be a list, each item contains text and recognition confidence\n```bash\n['pain', 0.9934559464454651]\n```\n\n* only classification\n```bash\npaddleocr --image_dir paddleocr/doc/imgs_words_en/word_10.png --use_angle_cls true --det false --rec false\n```\n\noutput will be a list, each item contains classification result and confidence\n```bash\n['0', 0.99999964]\n```\n\n## 3 use custom model\nwhen the built-in model cannot meet the needs, you need to use your own trained model.\nfirst, refer to [export](./detection_en.md#4-inference) doc to convert your det and rec model to inference model, and then use it as follows\n\n### 3.1 use by code\n\n```python\nfrom paddleocr import paddleocr,draw_ocr\n# the path of detection and recognition model must contain model and params files\nocr = paddleocr(det_model_dir='{your_det_model_dir}', rec_model_dir='{your_rec_model_dir}', rec_char_dict_path='{your_rec_char_dict_path}', cls_model_dir='{your_cls_model_dir}', use_angle_cls=true)\nimg_path = 'paddleocr/doc/imgs_en/img_12.jpg'\nresult = ocr.ocr(img_path, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# draw result\nfrom pil import image\nresult = result[0]\nimage = image.open(img_path).convert('rgb')\nboxes = [line[0] for line in result]\ntxts = [line[1][0] for line in result]\nscores = [line[1][1] for line in result]\nim_show = draw_ocr(image, boxes, txts, scores, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n\n### 3.2 use by command line\n\n```bash\npaddleocr --image_dir paddleocr/doc/imgs/11.jpg --det_model_dir {your_det_model_dir} --rec_model_dir {your_rec_model_dir} --rec_char_dict_path {your_rec_char_dict_path} --cls_model_dir {your_cls_model_dir} --use_angle_cls true\n```\n\n## 4 use web images or numpy array as input\n\n### 4.1 web image\n\n- use by code\n```python\nfrom paddleocr import paddleocr, draw_ocr\nocr = paddleocr(use_angle_cls=true, lang=\"ch\") # need to run only once to download and load model into memory\nimg_path = 'http://n.sinaimg.cn/ent/transform/w630h933/20171222/o111-fypvuqf1838418.jpg'\nresult = ocr.ocr(img_path, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# show result\nfrom pil import image\nresult = result[0]\nimage = image.open(img_path).convert('rgb')\nboxes = [line[0] for line in result]\ntxts = [line[1][0] for line in result]\nscores = [line[1][1] for line in result]\nim_show = draw_ocr(image, boxes, txts, scores, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n- use by command line\n```bash\npaddleocr --image_dir http://n.sinaimg.cn/ent/transform/w630h933/20171222/o111-fypvuqf1838418.jpg --use_angle_cls=true\n```\n\n### 4.2 numpy array\nsupport numpy array as input only when used by code\n\n```python\nimport cv2\nfrom paddleocr import paddleocr, draw_ocr, download_with_progressbar\nocr = paddleocr(use_angle_cls=true, lang=\"ch\") # need to run only once to download and load model into memory\nimg_path = 'paddleocr/doc/imgs/11.jpg'\nimg = cv2.imread(img_path)\n# img = cv2.cvtcolor(img,cv2.color_bgr2gray), if your own training model supports grayscale images, you can uncomment this line\nresult = ocr.ocr(img, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# show result\nfrom pil import image\nresult = result[0]\ndownload_with_progressbar(img_path, 'tmp.jpg')\nimage = image.open('tmp.jpg').convert('rgb')\nboxes = [line[0] for line in result]\ntxts = [line[1][0] for line in result]\nscores = [line[1][1] for line in result]\nim_show = draw_ocr(image, boxes, txts, scores, font_path='/path/to/paddleocr/doc/fonts/simfang.ttf')\nim_show = image.fromarray(im_show)\nim_show.save('result.jpg')\n```\n## 5 pdf file\n- use by command line\n\nyou can infer the first few pages by using the `page_num` parameter, the default is 0, which means infer all pages\n```bash\npaddleocr --image_dir ./xxx.pdf --use_angle_cls true --use_gpu false --page_num 2\n```\n- use by code\n\n```python\nfrom paddleocr import paddleocr, draw_ocr\n\n# paddleocr supports chinese, english, french, german, korean and japanese.\n# you can set the parameter `lang` as `ch`, `en`, `fr`, `german`, `korean`, `japan`\n# to switch the language model in order.\nocr = paddleocr(use_angle_cls=true, lang=\"ch\"\uff0c page_num=2)  # need to run only once to download and load model into memory\nimg_path = './xxx.pdf'\nresult = ocr.ocr(img_path, cls=true)\nfor idx in range(len(result)):\n    res = result[idx]\n    for line in res:\n        print(line)\n\n# draw result\nimport fitz\nfrom pil import image\nimport cv2\nimport numpy as np\nimgs = []\nwith fitz.open(img_path) as pdf:\n    for pg in range(0, pdf.pagecount):\n        page = pdf[pg]\n        mat = fitz.matrix(2, 2)\n        pm = page.getpixmap(matrix=mat, alpha=false)\n        # if width or height > 2000 pixels, don't enlarge the image\n        if pm.width > 2000 or pm.height > 2000:\n            pm = page.getpixmap(matrix=fitz.matrix(1, 1), alpha=false)\n\n        img = image.frombytes(\"rgb\", [pm.width, pm.height], pm.samples)\n        img = cv2.cvtcolor(np.array(img), cv2.color_rgb2bgr)\n        imgs.append(img)\nfor idx in range(len(result)):\n    res = result[idx]\n    image = imgs[idx]\n    boxes = [line[0] for line in res]\n    txts = [line[1][0] for line in res]\n    scores = [line[1][1] for line in res]\n    im_show = draw_ocr(image, boxes, txts, scores, font_path='doc/fonts/simfang.ttf')\n    im_show = image.fromarray(im_show)\n    im_show.save('result_page_{}.jpg'.format(idx))\n```\n\n## 6 parameter description\n\n| parameter                    | description                                                                                                                                                                                                                 | default value                  |\n|-------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------|\n| use_gpu                 | use gpu or not                                                                                                                                                                                                          | true                    |\n| gpu_mem                 | gpu memory size used for initialization                                                                                                                                                                                              | 8000m                   |\n| image_dir               | the images path or folder path for predicting when used by the command line                                                                                                                                                                           |                         |\n| page_num               | valid when the input type is pdf file, specify to predict the previous page_num pages, all pages are predicted by default                                                                                                                                                                           |          0               |\n| det_algorithm           | type of detection algorithm selected                                                                                                                                                                                                   | db                      |\n| det_model_dir           | the text detection inference model folder. there are two ways to transfer parameters, 1. none: automatically download the built-in model to `~/.paddleocr/det`; 2. the path of the inference model converted by yourself, the model and params files must be included in the model path | none           |\n| det_max_side_len        | the maximum size of the long side of the image. when the long side exceeds this value, the long side will be resized to this size, and the short side will be scaled proportionally                                                                                                                         | 960                     |\n| det_db_thresh           | binarization threshold value of db output map                                                                                                                                                                                        | 0.3                     |\n| det_db_box_thresh       | the threshold value of the db output box. boxes score lower than this value will be discarded                                                                                                                                                                         | 0.5                     |\n| det_db_unclip_ratio     | the expanded ratio of db output box                                                                                                                                                                                             | 2                       |\n| det_db_score_mode |  the parameter that control how the score of the detection frame is calculated. there are 'fast' and 'slow' options. if the text to be detected is curved, it is recommended to use 'slow'  | 'fast' |\n| det_east_score_thresh   | binarization threshold value of east output map                                                                                                                                                                                       | 0.8                     |\n| det_east_cover_thresh   | the threshold value of the east output box. boxes score lower than this value will be discarded                                                                                                                                                                         | 0.1                     |\n| det_east_nms_thresh     | the nms threshold value of east model output box                                                                                                                                                                                              | 0.2                     |\n| rec_algorithm           | type of recognition algorithm selected                                                                                                                                                                                                | crnn                    |\n| rec_model_dir           | the text recognition inference model folder. there are two ways to transfer parameters, 1. none: automatically download the built-in model to `~/.paddleocr/rec`; 2. the path of the inference model converted by yourself, the model and params files must be included in the model path | none |\n| rec_image_shape         | image shape of recognition algorithm                                                                                                                                                                                            | \"3,32,320\"              |\n| rec_batch_num           | when performing recognition, the batchsize of forward images                                                                                                                                                                                         | 30                      |\n| max_text_length         | the maximum text length that the recognition algorithm can recognize                                                                                                                                                                                         | 25                      |\n| rec_char_dict_path      | the alphabet path which needs to be modified to your own path when `rec_model_name` use mode 2                                                                                                                                              | ./ppocr/utils/ppocr_keys_v1.txt                        |\n| use_space_char          | whether to recognize spaces                                                                                                                                                                                                         | true                    |\n| drop_score          | filter the output by score (from the recognition model), and those below this score will not be returned                                                                                                                                                                                                        | 0.5                    |\n| use_angle_cls          | whether to load classification model                                                                                                                                                                                                       | false                    |\n| cls_model_dir           | the classification inference model folder. there are two ways to transfer parameters, 1. none: automatically download the built-in model to `~/.paddleocr/cls`; 2. the path of the inference model converted by yourself, the model and params files must be included in the model path | none |\n| cls_image_shape         | image shape of classification algorithm                                                                                                                                                                                            | \"3,48,192\"              |\n| label_list         | label list of classification algorithm                                                                                                                                                                                            | ['0','180']           |\n| cls_batch_num           | when performing classification, the batchsize of forward images                                                                                                                                                                                         | 30                      |\n| enable_mkldnn           | whether to enable mkldnn                                                                                                                                                                                                       | false                   |\n| use_zero_copy_run           | whether to forward by zero_copy_run                                                                                                                                                                               | false                   |\n| lang                     | the support language, now only chinese(ch)\u3001english(en)\u3001french(french)\u3001german(german)\u3001korean(korean)\u3001japanese(japan) are supported                                                                                                                                                                                                  | ch                    |\n| det                     | enable detction when `ppocr.ocr` func exec                                                                                                                                                                                                   | true                    |\n| rec                     | enable recognition when `ppocr.ocr` func exec                                                                                                                                                                                                   | true                    |\n| cls                     | enable classification when `ppocr.ocr` func exec((use use_angle_cls in command line mode to control whether to start classification in the forward direction)                                                                                                                                                                                                   | false                    |\n| show_log                     | whether to print log| false                    |\n| type                     | perform ocr or table structuring, the value is selected in ['ocr','structure']                                                                                                                                                                                             | ocr                    |\n| ocr_version                     | ocr model version number, the current model support list is as follows: pp-ocrv3 supports chinese and english detection, recognition, multilingual recognition, direction classifier models, pp-ocrv2 support chinese detection and recognition model, pp-ocr support chinese detection, recognition and direction classifier, multilingual recognition model | pp-ocrv3                 |\n\n\n",
  "docs_url": null,
  "keywords": "ocr textdetection textrecognition paddleocr crnn east star-net rosetta ocrlite db chineseocr chinesetextdetection chinesetextrecognition",
  "license": "apache license 2.0",
  "name": "paddleocr",
  "package_url": "https://pypi.org/project/paddleocr/",
  "project_url": "https://pypi.org/project/paddleocr/",
  "project_urls": {
    "Download": "https://github.com/PaddlePaddle/PaddleOCR.git",
    "Homepage": "https://github.com/PaddlePaddle/PaddleOCR"
  },
  "release_url": "https://pypi.org/project/paddleocr/2.7.0.3/",
  "requires_dist": [
    "shapely",
    "scikit-image",
    "imgaug",
    "pyclipper",
    "lmdb",
    "tqdm",
    "numpy",
    "visualdl",
    "rapidfuzz",
    "opencv-python (<=4.6.0.66)",
    "opencv-contrib-python (<=4.6.0.66)",
    "cython",
    "lxml",
    "premailer",
    "openpyxl",
    "attrdict",
    "PyMuPDF (<1.21.0)",
    "Pillow (>=10.0.0)",
    "pyyaml",
    "python-docx",
    "beautifulsoup4",
    "fonttools (>=4.24.0)",
    "fire (>=0.3.0)",
    "pdf2docx"
  ],
  "requires_python": "",
  "summary": "awesome ocr toolkits based on paddlepaddle (8.6m ultra-lightweight pre-trained model, support training and deployment among server, mobile, embeded and iot devices)",
  "version": "2.7.0.3",
  "releases": [],
  "developers": [],
  "kwds": "chinesetextrecognition paddleocr chineseocr chinesetextdetection draw_ocr",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_paddleocr",
  "homepage": "https://github.com/paddlepaddle/paddleocr",
  "release_count": 39,
  "dependency_ids": [
    "pypi_attrdict",
    "pypi_beautifulsoup4",
    "pypi_cython",
    "pypi_fire",
    "pypi_fonttools",
    "pypi_imgaug",
    "pypi_lmdb",
    "pypi_lxml",
    "pypi_numpy",
    "pypi_opencv_contrib_python",
    "pypi_opencv_python",
    "pypi_openpyxl",
    "pypi_pdf2docx",
    "pypi_pillow",
    "pypi_premailer",
    "pypi_pyclipper",
    "pypi_pymupdf",
    "pypi_python_docx",
    "pypi_pyyaml",
    "pypi_rapidfuzz",
    "pypi_scikit_image",
    "pypi_shapely",
    "pypi_tqdm",
    "pypi_visualdl"
  ]
}