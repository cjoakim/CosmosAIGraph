{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# boto3_type_annotations\n\na programmatically created package that defines `boto3` services as stand in classes with type annotations. `boto3` is \nan incredibly useful, well designed interface to the aws api. however, we live in an age where even free ides like \npycharm ce have full code completion (intellisense). because `boto3`'s services are created at runtime, ides aren't \nable to index its code in order to provide code completion or infer the type of these services or of the objects created \nby them. even if it was able to do so, clients and service resources are created using a service agnostic factory method\nand are only identified by a string argument of that method. ides don't parse arguments to infer the return type of a\nmethod, and they probably shouldn't. meaning that the only way for an ide to know the type of a client created by \n`boto3.client('<service>')` is for it to be explicitly declared in type annotations, type comments, or docstrings, which\nbrings us back to the original problem of services being defined at runtime. all of that to say that working with \n`boto3` can be very frustrating at times.\n\nto reduce this frustration, `boto3_type_annotations` defines stand in classes for the clients, service resources, \npaginators, and waiters provided by `boto3`'s services. even though these services are created by `boto3` are created at\nruntime, they are still full fledged python objects, and aws has been nice enough to include documentation in the \ndocstrings of these objects' methods. by parsing those docstrings, we can retrieve the types of method \narguments--also, which arguments are required and which may be omitted--and the types of their return \nvalues. with that, we have everything we need to create objects which mimic the class structure of `boto3`'s objects. \nand with python's `typing` module, we can annotate the methods of the stand in objects with the types which we've \nparsed. what this means is that we can use these stand in objects to declare the type of `boto3` service objects in our \nown code.\n\n![types!](https://github.com/alliefitter/boto3_type_annotations/blob/master/img/boto3_type_annotations.gif)\n\n## with or without docstrings\n\nthis package is available both with docstrings, named `boto3_type_annotations_with_docs` on pypi (which contains the \nsame documentation you'll find online), and without, named `boto3_type_annotations` on pypi. the reason for this is \nthat, for a python package, `boto3_type_annotations_with_docs` is huge. `boto3_type_annotations` is pretty large itself \nat 2.2 mb, but `boto3_type_annotations_with_docs` dwarfs it at 41 mb. being that `boto3` and `botocore` add up to be 34 \nmb, this is likely not ideal for many use cases. however, there are use cases in which you may want documentation in \nyour ide, during development for example. a possible workflow for this use case is detailed below.\n\n## installation\n\nwithout docs:\n```\npip install boto3_type_annotations\n```\n\nwith docs:\n```\npip install boto3_type_annotations_with_docs\n```\n\n## usage\n\nregardless of which deployment package you install, you'll still import the same package, `boto3_type_annotations`.\nits constituent packages and modules can be used to declare the type of `boto3` objects. for instance, everybody's \nfavorite, s3:\n\n```python\nimport boto3\nfrom boto3_type_annotations.s3 import client, serviceresource\nfrom boto3_type_annotations.s3.waiter import bucketexists\nfrom boto3_type_annotations.s3.paginator import listobjectsv2\n\n# with type annotations\n\nclient: client = boto3.client('s3')\nclient.create_bucket(bucket='foo')  # not only does your ide knows the name of this method, \n                                    # it knows the type of the `bucket` argument too!\n                                    # it also, knows that `bucket` is required, but `acl` isn't!\n\n# waiters and paginators and defined also...\n\nwaiter: bucketexists = client.get_waiter('bucket_exists')\nwaiter.wait('foo')\n\npaginator: listobjectsv2 = client.get_paginator('list_objects_v2')\nresponse = paginator.paginate(bucket='foo')\n\n# along with service resources.\n\nresource: serviceresource = boto3.resource('s3')\nbucket = resource.bucket('bar')\nbucket.create()\n\n# with type comments\n\nclient = boto3.client('s3')  # type: client\nresponse = client.get_object(bucket='foo', key='bar')\n\n# in docstrings\n\nclass foo:\n    def __init__(self, client):\n        \"\"\"\n        :param client: it's an s3 client and the ide is gonna know what it is!\n        :type client: client\n        \"\"\"\n        self.client = client\n\n    def bar(self):\n        \"\"\"\n        :rtype: client\n        \"\"\"\n        self.client.delete_object(bucket='foo', key='bar')\n        return self.client\n```\n\n## how is this package different from `pyboto3`?\n\n`pyboto3` has been a useful package which was created for the same purpose and using the same methodology as this \npackage. it does have its shortcomings, though. for one, it only defines clients, no service resources, waiters, or \npaginators. two, it defines2 clients as modules when the objects created by `boto3` are classes. this seems \nnitpicky until you realize that modules can't be used to declare type with type annotations. even a variable in the \noutermost scope of a module would require rst docstring to declare its type. also, and this is actually is nitpicky, \nthe package structure doesn't mimic that of `boto3`--which you can see in the documentation i.e. `sqs.serviceresource`, \n`s3.bucket`, `ec2.waiter.instanceexists`. though i don't want to purport that this is perfectly one to one with what is\nin the docs. for instance, there's not much consistency in the docs as far as casing. you'll sometimes see \n`s3.waiter.bucketexists` and in other places `sqs.bucket`. i chose to go with the pep8 guidelines where module names are\nin snake case and classes are in pascal case.\n\n## development workflow with docstring\n\nas mentioned above, there may be scenarios in which you would want to have docstrings in development, but not want\nto package a 41mb dependency with your production code. to accommodate this and similar scenarios, i decided to provide \ntwo deployment packages, each containing a `boto3_type_annotations` package. so, one workflow may be to have two \nrequirements files: requirements.txt and requirements-dev.txt (`boto3` does something similar in that they have \nrequirements.txt for the api resource and requirements-docs.txt for building documentation.). these two files would \nlook like this:\n\n**requirements.txt**\n```\nboto3_type_annotations\n# other dependencies\n```\n\n**requirements-dev.txt**\n```\nboto3_type_annotations_with_docs\n# other dependencies\n```\n\nyou would then install `requirements.txt` in production and `requirements-dev.txt` in development. because both \ndeployment packages define the `boto3_type_annotations` package, you won't have to change your code. you just need to \ninstall the appropriate deployment package.\n\n## custom builds\n\nin cases when you're only using a small number of `boto3` services, you may not want to depend on a package containing \nevery service available. to provide a bit more flexibility, this package provides a way to create a custom build of\nthe `boto3_type_annotations` package. the `configs/` directory contains configurations for `boto3_type_annotations` and\n`boto3_type_annnotations_with_docs`, along with a couple example configurations.\n\n```yaml\nservices: # a list of services. use `boto3.session.session.get_available_services()` to view services. \n  - ec2\n  - rds\n  - sqs\n  - sns\n  - lambda\n  - s3\nwith_docs: true # include docstrings.\nwith_clients: true # include client classes\nwith_service_resources: true # include service resources.\nwith_paginators: true # include paginators\nwith_waiters: true # include waiters\npackage_name: boto3_type_annotations_essentials # the name of the package.\nmodule_name: boto3_type_annotations # the name of the module.\nversion: 0.2.4 # version of the package.\nreadme: readme.md # path to readme file.\nlicense: license # path to file containing license.\n```\n\nthe preceding configuration is the contents of `config/example.essentials.yaml`. when `build.py` is run with this\nconfig, it will parse and write the ec2, rds, sqs, sns, lambda, and s3 services with docstrings and including all\nclients, service resources, paginators, and waiters. \n\n```bash\n$ python build_scripts/build.py ../configs/example.essentials.yaml\n```\n\nit will create a directory named `boto3_type_annotations_essentials`\nin the root directory of the repository. that directory will contain a python module named `boto3_type_annotations`,\na license file, and a `setup.py` file. now all you need to do is package everything up and install it.\n\n```bash\n$ python setup.py sdist bdist_wheel\n\n$ pip3 install dist/boto3_type_annotations_essentials-0.2.4-py3-none-any.whl --user\n\n```\n\n## todo\n\n- create an \"essentials\" deployment package only containing often used services like lambda, s3, sqs, and cloudformation\n\n- package related services into separate deployment packages, to create smaller packages containing only services\n  which are essential to a certain use case, group ec2 and rds for instance.\n\n- ~~create custom builds. if a project only uses s3's service resource, provide a way to build a deployment package \n  containing just that package. this would require some sort of configuration and more mature build script.~~\n\n- reduce the size of `boto3_type_annotations_with_docs`. i'm already cutting out extraneous new lines and some\n  whitespaces which reduced the size by 10 mb(!), but i'd like to see it closer to the 34 mb of `boto3` + `botocore`.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "boto3-type-annotations",
  "package_url": "https://pypi.org/project/boto3-type-annotations/",
  "project_url": "https://pypi.org/project/boto3-type-annotations/",
  "project_urls": {
    "Homepage": "https://github.com/alliefitter/boto3_type_annotations"
  },
  "release_url": "https://pypi.org/project/boto3-type-annotations/0.3.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "type annotations for boto3. adds code completion in ides such as pycharm.",
  "version": "0.3.1",
  "releases": [],
  "developers": [
    "allie_fitter",
    "fitterj@gmail.com"
  ],
  "kwds": "boto3_type_annotations boto3_type_annotations_with_docs boto3_type_annotations_essentials boto3_type_annnotations_with_docs boto3",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_boto3_type_annotations",
  "homepage": "https://github.com/alliefitter/boto3_type_annotations",
  "release_count": 7,
  "dependency_ids": []
}