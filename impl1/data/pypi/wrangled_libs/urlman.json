{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: django",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "urlman\n------\n\n.. image:: https://travis-ci.org/andrewgodwin/urlman.svg?branch=master\n   :target: https://travis-ci.org/andrewgodwin/urlman\n   :alt: test status\n\n.. image:: https://codecov.io/gh/andrewgodwin/urlman/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/andrewgodwin/urlman\n   :alt: test coverage status\n\na nicer way to do urls for django models.\n\nreplaces things like ``get_absolute_url`` with a ``.urls`` attribute that\ncan reference other urls and build sensible trees of things, and can\nthen be accessed using ``instance.urls.name``.\n\nthis is so you can have urls on your model instances directly (rather than reversing\nthrough the url lookup functions, which is not only slow but often hard to supply\narguments to). you can just throw ``{{ instance.urls.view }}`` into a template to get\na link.\n\nit also lets you use python string formatting syntax to place arguments into urls from\nthe model instance itself or from other urls in the same set.\n\nexample:\n\n.. code-block:: python\n\n    import urlman\n\n    class group(models.model):\n\n    ...\n\n        class urls(urlman.urls):\n            view = \"/{self.slug}/\"\n            users = \"{view}users/\"\n            admin = \"{view}admin/\"\n\n\n    def my_view(request):\n        group = ...\n        return redirect(group.urls.view)\n\nit's suggested that you use \"view\" as the equivalent name for\n``get_absolute_url``, and have a function like this on your model:\n\n.. code-block:: python\n\n    def get_absolute_url(self):\n        return self.urls.view\n\nto build a full url use the ``full`` method like this:\n\n.. code-block:: python\n\n    def my_view(request):\n        group = ...\n        return redirect(group.urls.admin.full(scheme='https'))\n\nyou can implement the `get_scheme(url)` and `get_hostname(url)` methods on your\n`url` class to change your default theme and hostname from the urlman defaults\nof `'http'` and `'localhost'`, respectively.\n\nif you use django rest framework, you can use ``urlman.urlmanfield`` to provide\nan object with a set of urls. it is used like this (only the ``urls`` parameter\nis required):\n\n.. code-block:: python\n\n   from urlman.serializers import urlmanfield\n\n   class myserializer(modelserializer):\n       urls = urlmanfield(urls=['view', 'edit'], attribute='urls', full=true)\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "urlman",
  "package_url": "https://pypi.org/project/urlman/",
  "project_url": "https://pypi.org/project/urlman/",
  "project_urls": {
    "Homepage": "https://github.com/andrewgodwin/urlman"
  },
  "release_url": "https://pypi.org/project/urlman/2.0.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "django url pattern helpers",
  "version": "2.0.1",
  "releases": [],
  "developers": [
    "andrew@aeracode.org",
    "andrew_godwin"
  ],
  "kwds": "urlmanfield django get_absolute_url urlman urls",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_urlman",
  "homepage": "https://github.com/andrewgodwin/urlman",
  "release_count": 8,
  "dependency_ids": []
}