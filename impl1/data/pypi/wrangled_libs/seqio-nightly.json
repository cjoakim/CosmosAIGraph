{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "topic :: scientific/engineering :: artificial intelligence"
  ],
  "description": "# seqio\n\n*task-based datasets, preprocessing, and evaluation for sequence models*\n\n*go to [seqio readthedocs documentation page](https://seqio.readthedocs.io/).*\n\n\n## overview\n\n**seqio** is a library for processing sequential data to be fed into downstream\nsequence models. it uses [`tf.data.dataset`](https://www.tensorflow.org/api_docs/python/tf/data/dataset)\nto create scalable data pipelines but requires minimal use of tensorflow. in\nparticular, with one line of code, the returned dataset can be transformed to a\nnumpy iterator and hence it is fully compatible with other frameworks such as\n[jax](https://github.com/google/jax) or\n[pytorch](https://pytorch.org/).\n\nseqio assumes that the dataset is a sequence. modalities such as text or audio\nare naturally supported. images are supported as long as they are represented as\nsequences (e.g., [image gpt](http://proceedings.mlr.press/v119/chen20s.html)).\n\nseqio is a refactor of the\n[`t5.data`](https://github.com/google-research/text-to-text-transfer-transformer/)\nlibrary used (in conjunction with the\n[mesh tensorflow](https://github.com/tensorflow/mesh) transformer\nimplementation) to train the t5 models introduced in [*exploring the limits of\ntransfer learning with a unified text-to-text\ntransformer*](https://arxiv.org/abs/1910.10683).\n\nif you have used `t5.data` in the past and want to know how seqio differs,\nplease read [this section](#differences-from-t5data).\n\n## installation\n\n### from pypi\n\n```sh\npip install seqio\n```\n\n### from source\n\n```sh\ngit clone https://github.com/google/seqio.git\ncd seqio\npip install -e .\n```\n\n## usage tutorial\n\nat a high level, we use seqio with the following steps.\n\n1.  define a `task` (and optionally a `mixture`).\n\n1.  define (or use an existing) a `featureconverter` based on the model\n    architecture.\n\n1.  use the top-level function `seqio.get_dataset` to obtain the\n    `tf.data.dataset` instance.\n\nwe will look at each of these steps in detail.\n\n\n### defining a `task`\n\nthe most important class in seqio is the `task`. it is an abstraction that combines:\n\n  * a raw *data source*\n  * one or more *preprocessing* steps\n  * a *vocabulary* to tokenize/detokenize each preprocessed feature for the model\n  * a *postprocessor* to convert detokenized model outputs into a format for evaluation\n  * one or more *metrics* to evaluate with\n\noftentimes a `task` lines up with a common benchmark. in this tutorial, we use\n[wmt 19 english-german](http://www.statmt.org/wmt19/translation-task.html) machine\ntranslation task. in the end, our `task` will look like this:\n\n\n```py\nseqio.taskregistry.add(\n    \"wmt19_ende\",\n    seqio.tfdsdatasource(tfds_name=\"wmt19_translate/de-en:1.0.0\"),\n    preprocessors=[\n        functools.partial(\n            translate, source_language='en', target_language='de'),\n        seqio.preprocessors.tokenize, seqio.preprocessors.append_eos\n    ],\n    output_features={\n        'inputs':\n            seqio.feature(\n                seqio.sentencepiecevocabulary('/path/to/inputs/vocab'),\n                add_eos=false,\n                dtype=tf.int32),\n        'targets':\n            seqio.feature(\n                seqio.sentencepiecevocabulary('/path/to/targets/vocab'),\n                add_eos=true,\n                dtype=tf.int32),\n    },\n    metric_fns=[bleu])\n```\n\nwe typically add the `task` to the global registry when we define it (as shown\nabove) to make it easier to use with model configs and flags. thus, it  must\nhave a unique string name (`\"wmt19_ende\"` in this case). note, however, that\nyou may also instantiate a `seqio.task` directly without adding it to the\nregistry, if desired.\n\nwe'll now break down each part of the task definition.\n\n#### data source\n\ndata sources are the first step in your pipeline, providing a way to load raw\ndata in many formats as a `tf.data.dataset`.\nall data sources are subclasses of the `datasource` base class and are defined in\n[dataset_providers](https://github.com/google/seqio/tree/main/seqio/dataset_providers.py).\n\nexisting implementations include:\n\n  * `tfdsdatasource` for loading examples from [tensorflow datasets](https://www.tensorflow.org/datasets).\n  * `textlinedatasource` for loading examples from text files (e.g., tsv).\n  * `tfexampledatasource` for loading [`tf.train.example`](https://www.tensorflow.org/tutorials/load_data/tfrecord) protos from a file (e.g. a `tfrecord` file.)\n  * `functiondatasource` for providing an custom function that returns a `tf.data.dataset`.\n\nin our example, we are using the `tfdsdatasource`. we specify the name of the wmt dataset in tfds ([`\"wmt19_translate\"`](https://www.tensorflow.org/datasets/catalog/wmt19_translate)), the specific config for the language pair that excludes the context for the open domain setting (`\"de-en\"`), and the version number (`\"1.0.0\"`).\n\n#### output features\n\nthe `output_features` field expects a dictionary that maps string feature names\nto `seqio.feature` objects. this defines what the `task` is expected to produce\nin its output examples. the output examples *may* contain additional fields, but\nthey *must* contain these fields in the specified format or exceptions will be\nraised.\n\neach `feature` includes:\n\n*   a `vocabulary`, which must subclass\n    [`seqio.vocabulary`](https://github.com/google/seqio/tree/main/seqio/vocabularies.py),\n    to specify how the feature can be tokenized and detokenized. you may use\n    `seqio.passthroughvocabulary` if tokenization is not necessary.\n*   `add_eos`, which specifies whether the feature should end with the\n    vocabulary's eos token.\n*   the output `dtype` which must be a `tf.dtypes.dtype`.\n\n**note:** specifying these options on `feature` does not by itself ensure the\nproper transformations are applied -- you must also include the necessary\npreprocessors.\n\nthe [tasks used in t5](todo) all produce \"inputs\" and \"targets\" features to be\nconsumed by the text-to-text model. for a decoder-only language model, only a\nsingle feature (e.g., \"targets\") would be necessary. nevertheless, seqio is\nflexible enough to generate arbitrary output features what will be converted\ninto model features by the [`featureconverter`](#featureconverter) later in the\npipeline.\n\n#### preprocessors\n\npreprocessors are functions that transform one `tf.data.dataset` into a new\n`tf.data.dataset`. typically this involves executing a `map` over the given\ndataset. the preprocessors provided to the `task` will be executed sequentially.\n\nas an example, let's look at the previously undefined `translate` from the\n\"wmt19_ende\" example above.\n\n```py\ndef translate(dataset: tf.data.dataset,\n              source_language: str,\n              target_language: str) -> tf.data.dataset:\n  def _translate(ex: mapping[str, tf.tensor]) -> mapping[str, tf.tensor]:\n    \"\"\"convert a translation example to a text2text pair.\n\n    for example, say the dataset returns examples of this format:\n      {'de': 'das ist gut.', 'en': 'that is good.'}\n    if source_language = 'de', target_language = 'en', then the outputs will have\n    the format:\n      {'inputs': 'translate de to en: das ist gut.',\n      'targets': 'that is good.'}\n\n    args:\n      ex: an example to process.\n      source_language: source language code (e.g. 'en') to translate from.\n      target_language: target language code (e.g. 'de') to translate to.\n\n    returns:\n      a preprocessed example with the format listed above.\n    \"\"\"\n    src_str = f'translate {source_language}'\n    tgt_str = f' to {target_language}: '\n    return {\n        'inputs': tf.strings.join([src_str, tgt_str, ex[source_language]]),\n        'targets': ex[target_language],\n    }\n\n  return dataset.map(_translate,\n                     num_parallel_calls=tf.data.experimental.autotune)\n```\n\nthe tfds dataset provides the dataset where each example has the form: `{'de':\n'das ist gut.', 'en': 'that is good.'}`. we convert this to \"inputs\" and\n\"targets\" with the appropriate prompt to inform the model of the task.\n\n\na few **important** notes:\n\n1.  when instantiating a `task`, the preprocessor functions can have the\n    following arguments: `dataset`, `output_features`, and `sequence_length`.\n    the first (positional) dataset argument is always required. if an argument\n    named `output_features` is provided, the\n    [output feature mapping](#output-features) will be passed to the\n    preprocessor. if `sequence_length` is provided, a mapping from feature name\n    to its *maximum* final sequence length\n    ([provided by the caller](#getting-a-preprocessed-dataset)) will be\n    passed -- any sequences that are too long after preprocessing will be\n    automatically truncated. if a preprocessor function does have other\n    arguments, they must have default values or be bound (e.g., with\n    `functools.partial` as used in `translate`) before instantiating the `task`.\n\n1.  mapping functions operate on and return `tf.tensor`s using tensorflow\n    operations. this is more flexible than it may sound:\n\n    *   automatic\n        [autograph](https://www.tensorflow.org/guide/function#autograph_transformations)\n        conversion allow you to write python control flow in your\n        transformations.\n    *   [tf.experimental.numpy](https://www.tensorflow.org/guide/tf_numpy)\n        provides a numpy interface.\n    *   [`tf.py_function`](https://www.tensorflow.org/api_docs/python/tf/py_function)\n        allows you to wrap arbitrary python code. note: `tf.data` pipelines\n        using this function can only be run in the python process where they\n        were defined, and performance is limited by the python gil.\n\n    see `tf.data.dataset`\n    [documentation](https://www.tensorflow.org/api_docs/python/tf/data/dataset)\n    for more details.\n\n1.  when calling `map`, it is important to **always** set\n    `num_parallel_calls=tf.data.experimental.autotune` to avoid creating a\n    bottleneck. the `seqio.map_over_dataset` decorator helps enforce this as\n    follows.\n\n    ```py\n    @seqio.map_over_dataset\n    def translate(ex: mapping[str, tf.tensor],\n                  source_language: str,\n                  target_language: str) -> mapping[str, tf.tensor]:\n      \"\"\"convert a translation dataset to a text2text pair.\n\n      for example, say the dataset returns examples of this format:\n        {'de': 'das ist gut.', 'en': 'that is good.'}\n      if source_language = 'de', target_language = 'en', then the outputs will have\n      the format:\n        {'inputs': 'translate german to english: das ist gut.',\n        'targets': 'that is good.'}\n\n      args:\n        ex: an example to process.\n        source_language: source language code (e.g. 'en') to translate from.\n        target_language: target language code (e.g. 'de') to translate to.\n\n      returns:\n        a preprocessed example with the format listed above.\n      \"\"\"\n      src_str = f'translate {source_language}'\n      tgt_str = f' to {target_language}: '\n      return {\n          'inputs': tf.strings.join([src_str, tgt_str, ex[source_language]]),\n          'targets': ex[target_language],\n      }\n    ```\n\n    note that `translate` takes as input an individual example. then\n    `seqio.map_over_dataset` decorates it to a function that takes in a\n    `tf.data.dataset` instance.\n\n1.  stochastic operations must be\n    [stateless](https://www.tensorflow.org/guide/random_numbers#stateless_rngs)\n    if deterministic pipelines are needed. to get (optionally deterministic)\n    seeds for these operations, use the `seqio.map_over_dataset(num_seeds=n)`\n    decorator. for example:\n\n    ```py\n    def random_chunk(\n      dataset: tf.data.dataset,\n      sequence_length: mapping[str, int]\n    ) -> tf.data.dataset:\n    \"\"\"takes a random chunk out of each feature the size of `sequence_length`.\"\"\"\n\n      @seqio.map_over_dataset(num_seeds=1)\n      def take_chunk(\n          ex: mapping[str, tf.tensor],\n          seed\n      ) -> mapping[str, tf.tensor]:\n        new_ex = {}\n        for k, v in ex.items():\n          if k in sequence_length:\n            length = sequence_length[k]\n            start_idx = tf.random.stateless_uniform(\n               (), seed, 0, tf.size(v) - (length + 1))\n            new_ex[k] = v[start_idx:start_idx+length]\n          else:\n            new_ex[k] = v\n        return new_ex\n\n    return take_chunk(dataset)\n    ```\n\n    if `num_seeds > 1`, the arg will instead be called `seeds` and will contain\n    a sequence of seeds.\n\nin our \"wmt_19_ende\" task, we also use the predefined preprocessors\n`seqio.preprocessors.tokenize` and `seqio.preprocessors.append_eos`. the former\nuses each `feature.vocabulary` to tokenize it, and the the latter appends\n`feature.vocabulary.eos_id` to the feature if the `feature.add_eos` is true. see\n[preprocessors.py](https://github.com/google/seqio/tree/main/seqio/preprocessors.py) for\ntheir implementations and other useful preprocessors.\n\n#### postprocessor\n\nduring evaluation, the model outputs are first detokenized using the output\nfeature vocabulary. before passing these predictions to the metric functions,\nthey can be run through a python postprocessing function, alongside the full\ninput example. similarly, the raw targets are run through this function before\nbeing passed to the metrics. since the postprocess function is used on both the\nmodel output and the targets, it is passed an `is_target` boolean in case the\nbehavior should be different. it is also passed the fully preprocessed example,\nincluding fields that were excluded from `output_features`.\n\nfor the \"wmt19_ende\", we don't need any postprocessors. see \"trivia_qa_open\"\ntask in the [advanced postprocessing `task`](#advanced-postprocessing-task) for\nan example postprocessor.\n\n#### metrics\n\nmetrics are functions that are passed (by the [evaluator](#evaluator)) the\nfully-materialized list of postprocessed model outputs (or scores) and targets\nand return a mapping from string names to `metricvalue` objects containing their\nvalues. these are most commonly floating-point scalars, but may also be text,\nimages, audio, histograms, etc (see\n[metrics.py](https://github.com/google/seqio/tree/main/seqio/metrics.py) for the full list).\n\nthe first argument of a metric function must always be called `targets`. if the\nsecond argument of a metric function is called `predictions`, it will be passed\nthe decoded and detokenized model prediction. if it is called `scores`, it will\nbe passed a list of log-likelihood scores for each example.\n\nif multiple metric functions are provided, they will all be used and their\nreturned mappings merged.\n\n##### prediction metrics\n\nprediction metrics are computed using the postprocessed targets and model\noutputs (predictions). the args must be named `targets` and `predictions`.\n\nlet's look at the metric function used for \"wmt19_ende\" task. a standard metric\nfor the translation task is bleu and we use `sacrebleu` implementation.\n\n```py\ndef bleu(targets: sequence[str], predictions: sequence[str]):\n  \"\"\"computes bleu score.\n\n  args:\n    targets: list of strings or list of list of strings if multiple references\n      are present.\n    predictions: list of strings\n\n  returns:\n    bleu_score across all targets and predictions\n  \"\"\"\n  if isinstance(targets[0], list):\n    targets = [[x for x in target] for target in targets]\n  else:\n    # need to wrap targets in another list for corpus_bleu.\n    targets = [targets]\n\n  bleu_score = sacrebleu.corpus_bleu(predictions, targets,\n                                     smooth_method=\"exp\",\n                                     smooth_value=0.0,\n                                     force=false,\n                                     lowercase=false,\n                                     tokenize=\"intl\",\n                                     use_effective_order=false)\n  return {\"bleu\": bleu_score.score}\n```\n\n\n##### score metrics\n\nscore metrics are computed using the postprocessed targets and their\nlog-likelihood scores according to the model. the args must be named `targets`\nand `scores`.\n\n```py\ndef perplexity(targets: sequence[str], scores: sequence[int]):\n  return {\n    \"perplexity\": seqio.metrics.scalar(np.exp(np.mean(scores)))\n  }\n```\n\n### defining a `mixture`\n\nonce you have multiple `task`s added to the `taskregistry`, you can define\n`mixture`s that will combine the examples from them according to some specified\nrate. examples will then be sampled from each task in proportion to its rate.\n\nas an example, [multilingual t5](http://goo.gle/mt5) uses a `mixture` of\nper-language `task`s with tail languages up-weighted in the mixture.\n\nthere are 3 ways to specify the tasks and their rates:\n\n1.  provide a rate along with each task's name (rates are normalized before\n    sampling). in this example, the rates provided are units of the final\n    mixture that come from the component tasks. here, 1/(1+7) of the final\n    mixture will come from \"task1\".\n\n    ```py\n    seqio.mixtureregistry.add(\n      \"mix1\",\n      [(\"task1\", 1), (\"task2\", 7)]\n    )\n    ```\n\n1.  provide a constant default rate for some or all tasks, which will be used\n    when only the name is provided. the example below will produce identical\n    mixing rates as the previous one.\n\n    ```py\n    seqio.mixtureregistry.add(\n      \"mix1\",\n      [(\"task1\", 0.5), \"task2\"],\n      default_rate=3.5\n    )\n    ```\n\n1.  provide a function that generates the rate for each task at runtime. the\n    example below uses the provided\n    [`seqio.mixing_rate_num_examples`](https://github.com/google/seqio/tree/main/seqio/utils.py),\n    which uses the number of examples (computed during\n    [offline caching](#optional-offline-caching)) as the rate for each task.\n\n    ```py\n    seqio.mixtureregistry.add(\n      \"mix2\",\n      [\"task1\", \"task2\"],\n      default_rate=seqio.mixing_rate_num_examples\n    )\n    ```\n\nyou can also include `mixture`s in your `mixture`! for example, the following\ntask would contain 1/24 (from \"mix1\") + 1/3 \"task1\", 7/24 (from \"mix1\") of\n\"task2\", and 1/3 \"task3\".\n\n```py\nseqio.mixtureregistry.add(\n  \"mix3\",\n  [\"mix1\", \"task1\", \"task3\"],\n  default_rate=1\n)\n```\n\nif sampling without replacement is important for your task, you can achieve that\nby using either deterministic tasks or using dataset checkpointing (and not\nrunning more than an epoch) for a non-deterministic task. otherwise, the mixture\nmay sample with replacement.\n\n### getting a preprocessed dataset\n\nnow that your `task` (and/or `mixture`) is defined, its primary functionality is\nto use it to generate a dataset.\n\nyou may first need to use `seqio.get_mixture_or_task(mixture_or_task_name)` to\naccess your dataset provider from the registry.\n\nafter that, you can call `get_dataset` to build the `tf.data.dataset`. for\nexample:\n\n```py\ndataset = seqio.get_mixture_or_task(\"mix1\").get_dataset(\n    sequence_length={\"inputs\": 256, \"targets\": 128},\n    split=\"train\",\n    shuffle=true,\n    num_epochs=1,\n    shard_info=seqio.shardinfo(index=0, num_shards=10),\n    use_cached=false,\n    seed=42\n)\n\n# print the first 5 examples.\nfor _, ex in zip(range(5), dataset.as_numpy_iterator()):\n  print(ex)\n```\n\nsome notes on a few of the arguments:\n\n*   `sequence_length`: an *optional* mapping from feature name to *maximum*\n    length. will be passed to the preprocessors with a `sequence_length`\n    argument. if not `none`, the final example features will be truncated if\n    they exceed the specified length. note that this value may be required to be\n    set if any of the preprocessors use the `sequence_length` argument and do\n    not handle the `none` case.\n*   `num_epochs`: the number of times to repeat the source dataset.\n    preprocessing will be re-applied with new seeds to enable new samples from\n    stochastic steps. note that if the `cachedatasetplaceholder` is included\n    (see below) preprocessing is only re-applied after that step.\n*   `shard_info`: an optional sharding specification for loading a deterministic\n    subset of the dataset. loading will be most efficient if the number of\n    shards evenly divides the number of shards in the raw data source.\n*   `use_cached`: specifies whether to load from a pre-cached task for increased\n    performance or to do the preprocessing on-the-fly. see the\n    [following section](#optional-offline-caching) for details on how to cache\n    your task, which must be done before this can be set to `true`.\n*   `seed`: an optional seed to use for deterministic shuffling and (stateless)\n    stochastic ops. these operations will still be pseudorandom but will be\n    reproducible with the same seed. set to `none` if determinism is not\n    desired.\n\n### (optional) offline caching\n\nfor improved performance at load time and to avoid redundant computations for\ncommonly used tasks, you can pre-cache your `task` with all or part of the\npreprocessing done in advance of training; this partial preprocessing is\nespecially useful if the task is stochastic and one wishes to cache the\ndeterministic operations while running the stochastic ones on the fly. caching\nstochastic seqio mixtures in this way is not supported.\n\nthe first step to doing so is to add a\n`seqio.cachedatasetplaceholder(required=false)` as one of the steps in your\npreprocessing pipeline. all steps before the placeholder will be cached offline\nand all steps after will be executed on the fly at load time. you may set\n`required=true` if you want `get_dataset` to fail unless `use_cached=true`.\n\ncaveats:\n\n*   any stochastic operations that you wish to be re-run when `num_epochs > 1`\n    or with a different `seed` *should* go after the placeholder since only a\n    single sample will be cached.\n*   any preprocessing steps that use the `sequence_length` argument *must* come\n    after the `seqio.cachedatasetplaceholder` preprocessor since this is only\n    known at runtime, or an exception will be raised. if you wish to cache for a\n    specific sequence length, you can use\n    [`seqio.experimental.add_fully_cached_task`](https://github.com/google/seqio/tree/main/seqio/experimental.py).\n\nonce your `task` is registered, you can run\n[`cache_tasks_main`](https://github.com/google/seqio/tree/main/seqio/scripts/cache_tasks_main.py)\nto execute the offline preprocessing, providing it with the module containing\nyour task definitions via the `--module_import` flag. for very large datasets,\nit's recommended you run this [apache beam](https://beam.apache.org/) script on\na distributed framework like\n[google cloud dataflow](https://beam.apache.org/documentation/runners/dataflow/).\n\nfinally, you are ready to load the cached version of your `task` (or `mixture`)\ncontaining it. you will need to add the path to the directory you passed to\n`--output_cache_dir` via `seqio.add_global_cache_dirs([\"/my/cache/dir\"])`. now\nwhen you call `task_or_mixture.get_dataset(..., use_cached=true)`, the data will\nbe loaded from the cache directory instead of the raw data source.\n\n### feature converters\n\nthe role of `task` is to provide the dataset object with as little\nmodel-specific features (e.g., generic \"inputs\" and \"targets\") while the feature\nconverters transform the model-agnostic features to model-specific features\n(e.g., \"encoder_input_tokens\"). we refer to the former as \"task features\" and\nthe latter as \"model features\".\n\nlet's use machine translation (english to german) as a running example.\n\nthe raw data consists of sentence pairs such as\n\n```\n\"that is good\\tdas ist gut.\"\n```\n\na task registered to `task` (e.g.,\n[wmt_t2t_ende_v003](t5/data/tasks.py?l=156&rcl=337594707))\nreads these sentence pairs from the data source and applies a series of\n[preprocessors](t5/data/preprocessors.py?rcl=343354647).\none of the internal representations looks like\n\n```python\n{\"inputs\": \"translate english to german: that is good.\",\n \"targets\": \"das ist gut.\"}\n```\n\nthe final output from the `task` is a tokenized version of the parallel\nsentences. in the following toy example (the token ids do not correspond to the\nabove string example), the dataset consists of 2 examples.\n\n```python\ndataset = [{\"inputs\": [7, 8, 5], \"targets\": [3, 9]},\n           {\"inputs\": [8, 4, 9, 3], \"targets\": [4]}]\n```\n\nthe format is in the `tf.data.dataset` (i.e., each example is a dictionary with\n\"inputs\" and \"targets\" fields.\n\nthe `featureconverter` then takes this as an input and converts to the\nmodel-specific features. in addition, the feature converter performs padding and\noptionally packing (for model implementations that support it) for efficiency.\nfor example, let's assume that we are using the standard transformer\narchitecture with an encoder and a decoder. the output of the feature converter\nis\n\n```python\nconverted_dataset = [{\n    \"encoder_input_tokens\": [7, 8, 5, 1, 8, 4, 9, 3, 1, 0],\n     \"encoder_segment_ids\": [1, 1, 1, 1, 2, 2, 2, 2, 2, 0],\n       \"encoder_positions\": [0, 1, 2, 3, 0, 1, 2, 3, 4, 0],\n   \"decoder_target_tokens\": [3, 9, 1, 4, 1, 0, 0],\n    \"decoder_input_tokens\": [0, 3, 9, 0, 4, 0, 0],\n    \"decoder_loss_weights\": [1, 1, 1, 1, 1, 0, 0],\n       \"decoder_positions\": [0, 1, 2, 0, 1, 0, 0],\n     \"decoder_segment_ids\": [1, 1, 1, 2, 2, 0, 0],\n}]\n```\n\nin this case, two task examples are packed into one. `*_segment_id` and\n`*_position` are the fields used to denote the membership and position of packed\ntoken in the original sequence. the eos ids (i.e., 1) are appended. in addition,\neach fields is padded to the specified length.\n\nwe will look at the details of this example in encoder-decoder architecture:\n`seqio.encdecfeatureconverter` section.\n\n\n#### feature converters provided out of the box\n\nwe provide feature converters for three common architectures: encoder-decoder,\ndecoder-only and encoder-only. here we describe how users can use the feature\nconverters for each of these architectures out of the box as a part of the seqio\nlibrary.\n\nin the seqio library, each architecture has a class defining how the task\nfeatures are converted to model features. since these feature converters are\nalready implemented, it is straightforward to use them by providing the class as\na `feature_converter` argument of the `seqio.get_dataset` function. the\nfollowing sections show example usage of `seqio.get_dataset`.\n\n##### encoder-decoder architecture: `seqio.encdecfeatureconverter`\nthis is the architecture of the original transformer paper. for the\nenglish-to-german translation task, the following function call retrieves the\n`tf.data.dataset` object with the model features.\n\n```python\ndataset: tf.data.dataset = seqio.get_dataset(\n    mixture_or_task_name=\"wmt_t2t_ende_v003\",\n    task_feature_lengths={\"inputs\": 32, \"targets\": 32},\n    dataset_split=\"train\",\n    shuffle=true,\n    feature_converter=seqio.encdecfeatureconverter(pack=true)\n)\n```\n\nthe resulting dataset object has the following 7 fields\n\n|feature name          | explanation                |\n|----------------------|---------------------------|\n|`encoder_input_tokens` | input tokens to the encoder. |\n|`encoder_positions`    | position index in the sequence before packing.|\n|`encoder_segment_ids`  | sequence membership before packing. two positions with the same positive integer mean that they belong to the same sequence before packing. |\n|`decoder_input_tokens` | input tokens to the decoder. |\n|`decoder_target_tokens`| output tokens from the decoder. |\n|`decoder_loss_weights` | a weight on each position that can be used as a mask. |\n|`decoder_positions`    | position index in the sequence before packing. |\n|`decoder_segment_ids`  | same as `encoder_segment_ids` but for decoder.|\n\n##### decoder-only architecture\n\nthis architecture consists of a single autoregressive stack, which we denote as\na \"decoder\".\n\na decoder autoregressively produces an output sequence.\ntherefore, it can be used as a standard language model if the task dataset has\nonly \"targets\" features, i.e., self-supervised. if the task dataset also has an\n\"inputs\" field, e.g., supervised machine translation, the decoder can still be\nused by concatenating the inputs and targets fields. see [raffel et al.\n(2020)](https://arxiv.org/abs/1910.10683), section 3.2.1 for more detailed take\non this topic.\n\nwe support both uses cases and refer to the former as *standard language model*\nand the latter as *prefix language model*. each of these models is described\nseparately below.\n\nnote that we do not provide special features to denote how the dataset should be\nconsumed. for example, a transformer-based fully autoregressive decoder has a\nfully-causal self-attention layer. since there are many ways of implementing the\nmasking pattern for such attention layer and, more importantly, seqio is not\nlimited to attention-based models, we leave it up to the model implementations\nto apply the masking pattern. there is one exception, and we cover this in\nthe prefix lm section below.\n\na common use pattern is to pretrain a decoder model with the left-to-right\nlanguage modeling objective (unsupervised) using `seqio.lmfeatureconverter` and\nthen fine-tune (supervised) using `seqio.prefixlmfeatureconverter`.\n\n\n###### standard lm\n\nfor the standard language model, the task dataset only has \"targets\" field.\ntherefore, the sequence length specification only needs to specify targets.\n\n```python\ndataset: tf.data.dataset = seqio.get_dataset(\n    mixture_or_task_name=\"standard_lm\",\n    task_feature_lengths={\"targets\": 32},\n    dataset_split=\"train\",\n    shuffle=true,\n    feature_converter=seqio.lmfeatureconverter(pack=true)\n)\n```\n\nnote that \"standard_lm\" is not a registered task in the codebase. it is the\nleft-to-right language modeling task, i.e., predict the next token given the\nprevious tokens on some language corpus (e.g.,\n[c4](https://www.tensorflow.org/datasets/catalog/c4)).\n\nthe output dataset has the following model features.\n\n|feature name          | explanation                |\n|----------------------|---------------------------|\n|`decoder_target_tokens`| output tokens from the decoder |\n|`decoder_input_tokens` | input tokens to the decoder |\n|`decoder_loss_weights` | binary mask to indicate where the loss should be taken |\n|`decoder_positions`    | position index in the sequence before packing|\n|`decoder_segment_ids`  | sequence membership before packing. two positions with the same positive integer mean that they belong to the same sequence before packing. |\n\nthe `decoder_target_tokens` is a shifted version of `decoder_input_tokens` for the\nstandard teacher-forced autoregressive training.\n\n\n\n###### prefix lm: `seqio.prefixlmfeatureconverter`\n\nif the input dataset has a notion of \"inputs\" and \"targets\", we can concatenate\nthem so that we can still use a single stack decoder. therefore, the output only\ncontains \"targets\" just like standard lm case.\n\nwe use the same toy example for english-to-german translation task as a running\nexample:\n\n```\n{\"inputs\": \"translate english to german: that is good.\",\n \"targets\": \"das ist gut.\"}\n```\n\nto be consumed by the decoder-only stack, `seqio.prefixlmfeatureconverter`\nconcatenates them form the new \"targets\". consider 2-layer decoder architecture\nwhose activations are shown below\n\n```\n\nthat  is  good <eos> das ist gut <eos>\n |    |    |    |    |   |    |   |\n u1   u2   u3   u4   u5  u6   u7  u8\n |    |    |    |    |   |    |   |\n v1   v2   v3   v4   v5  v6   v7  v8\n |    |    |    |    |   |    |   |\n<bos> that is  good <eos> das ist gut\n\n```\n\nlet us denote the first layer's activation in the `i`th position as `vi`.\nsimilarly, let `ui` denote the activation of the second layer in the `i`th\nposition.\n\n\nfor attention-based sequence models such as transformer decoders, the\nself-attention layer is used to encode contextualized representation of the\nsequence. at a given layer, each position's representation is computed as a\nfunction of the representations of the tokens *before* its position in the\nprevious layer.\n\nreferring to the toy example, when computing `u2` with fully-causal masking, we\ndo not use `v3`. this results in a representation `u2` of the word \"is\" that\ndoes not take into account the word \"good\", which is unnecessarily limiting.\n\nfor prefix lm, this issue is resolved by having the fully visible masking\npattern for the inputs portion only. for example, when computing `u2`, `v1`,\n`v2`, `v3`, `v4` and `v5` are all visible and taken into account. for the tokens\nin the \"targets\" of the `task` dataset, we use the causal masking. for example,\nwhen computing `u6`, all `vi` for `i <= 6` are taken into account but not `v7`.\n\n<details>\n  <summary>why is `v5` included in the inputs attention pattern?</summary>\n  in the same translation example, we note that when computing `u2`, the\n  activation corresponding to the position where \\<eos\\> token was input (i.e.,\n  `v5`) was visible. this doesn't count as \"cheating\" because the model doesn't\n  see the next word \"das\". this can provide additional context in building the\n  representation for \"good\". in this case, `u4` has the context that \"good\" is\n  the last word in the sentence.\n</details>\n\n`seqio.prefixlmfeatureconverter` provides a feature `decoder_causal_attention`\nto encode this information. for the above example, we have\n\n\n```\ndecoder_causal_attention = [1, 1, 1, 1, 1, 0, 0, 0]\n```\n\nindicating that the non-causal attention can be applied to the first five\npositions. note that this feature seems trivial, but for a packed dataset\nthe inputs and targets boundary are more nuanced.\n\n\na final consideration for the prefix lm is that because we concatenate \"inputs\"\nand \"targets\", which tokens are used for the loss computation is a modeling\ndecision. for example, we can penalize the models only for the \"targets\" tokens\nor we may choose to penalize building the representation for \"inputs\" tokens.\nthis is controlled by `loss_on_targets_only` argument (defaults to `true`) to\n`seqio.prefixlmfeatureconverter` constructor. in the above example, we would get\n\n```\ndecoder_loss_weights = [0, 0, 0, 0, 1, 1, 1, 1]\n```\n\nthis indicates that the last 4 positions are used for the loss computation.\n\nto get the dataset with prefix lm features, we can use\n\n```python\ndataset: tf.data.dataset = seqio.get_dataset(\n    mixture_or_task_name=\"wmt_t2t_ende_v003\",\n    task_feature_lengths={\"inputs\": 32, \"targets\": 32},\n    dataset_split=\"train\",\n    shuffle=true,\n    feature_converter=seqio.prefixlmfeatureconverter(\n        pack=true,\n        loss_on_targets_only=true)\n)\n```\n\nthe resulting features have length 64 because it concatenates inputs and targets\neach with length 32.\n\nthe output dataset has the following model features. note that the only\nadditional feature is `decoder_causal_attention`.\n\n|feature name          | explanation                |\n|----------------------|---------------------------|\n|`decoder_target_tokens`| output tokens from the decoder |\n|`decoder_input_tokens` | input tokens to the decoder |\n|`decoder_loss_weights` | binary mask to indicate where the loss should be taken |\n|`decoder_positions`    | position index in the sequence before packing|\n|`decoder_segment_ids`  | sequence membership before packing. two positions with the ` same positive integer mean that they belong to the same sequence before packing. |\n|`decoder_causal_attention`| binary mask denoting which tokens are in the non-causal masking region.|\n\n###### encoder-only architecture\nlike decoder-only architecture, this one is a single stack, but not\nautoregressive.\n\none notable assumption is that the inputs and targets are *aligned*, i.e., they\nhave the same sequence length and `i`th position in the targets correspond to\nthe output representation of the `i`th token in the inputs.\n\na common model using encoder-only architecture is\n[bert](https://arxiv.org/abs/1810.04805). we provide `encoder` feature converter\nclass to support the masked language modeling (mlm) objective from bert.\n\nwe assume that a unique sentinel such as `[mask]` token is used to mask some\nfraction of the input text and the task is to recover the original text.\ntherefore, the \"targets\" is naturally defined as the original text whereas\n\"inputs\" are the masked text.\n\nencoder-only models are often used for classification tasks. in bert, a special\ntoken `[cls]` is prepended to the input sequence. the last layer's activation\ncorresponding to this sentinel token is the contextualized representation of the\nsequence. we assume that such \"classification\" sentinel is prepended.\n\nconsider the following example for the mlm task. the input dataset has two\nexamples, which is packed to one example. we assume that `mask_id = 9` and the\n`[cls]` token has id of 8.\n\n```py\ndataset = [{\"inputs\": [8, 9, 9, 3, 4], \"targets\": [8, 7, 4, 3, 4]},\n           {\"inputs\": [8, 3, 9], \"targets\": [8, 3, 6]}]\n\nconverted_dataset = {\n     \"encoder_input_tokens\": [8, 9, 9, 3, 4, 1, 8, 3, 9, 1, 0],\n    \"encoder_target_tokens\": [8, 7, 4, 3, 4, 1, 8, 3, 6, 1, 0],\n      \"encoder_segment_ids\": [1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 0],\n        \"encoder_positions\": [0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 0],\n     \"encoder_loss_weights\": [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0],\n}\n```\n\nnote that the packed sequence has `[cls]` token at the beginning of each\nsequences. also note that the loss is taken only on the masked position.\n\nto use the pre-defined `encoderfeatureconverter`, provide `mask_id` as an\nargument.\n\n```py\ndataset: tf.data.dataset = seqio.get_dataset(\n    mixture_or_task_name=\"some mlm task\",\n    task_feature_lengths={\"inputs\": 32, \"targets\": 32},\n    dataset_split=\"train\",\n    shuffle=true,\n    feature_converter=seqio.encoderfeatureconverter(\n        pack=true,\n        mask_id=9)\n)\n```\n\nthe resulting dataset object has the following 5 fields\n\n|feature name          | explanation                |\n|----------------------|---------------------------|\n|`encoder_input_tokens` | input tokens to the encoder |\n|`encoder_positions`    | position index in the sequence before packing|\n|`encoder_segment_ids`  | sequence membership before packing. two positions with the ` same positive integer mean that they belong to the same sequence before packing. |\n|`encoder_target_tokens`| output tokens from the encoder |\n|`encoder_loss_weights` | binary mask to indicate where the loss should be taken |                                          :\n\n###### custom architectures\nfor a custom model architecture, you need to create a subclass of\n`featureconverter` and override two methods `_convert_features` and\n`get_model_feature_lengths` to define how task features are mapped to the model\nfeatures, including the length relationships. the existing feature converters\n(e.g., `seqio.encdecfeatureconverter`) follow the same pattern, which can be a\nuseful starting point.\n\n### evaluation\n\nthe seqio `evaluator` class provides a way to evaluate models on seqio tasks\nand mixtures. for an interactive walkthrough of seqio evaluation, see the\n[evaluation notebook](https://github.com/google/seqio/blob/main/seqio/docs/tutorials.md).\nthe following is a deep-dive into the `evaluator` class.\n\nan evaluator instance can be created by passing a seqio task or\nmixture, and additional eval params like feature converter, split, sequence\nlengths, seed, etc. the evaluator init calls `get_dataset` for each task to be\nevaluated with the appropriate params, creating the `task_dataset`, and invokes\nthe model-specific feature converter on the `task_dataset` to create features\nthat can be passed to a model, called `model_dataset`. both `task_dataset` and\n`model_dataset` are stored in-memory so that the dataset can be reused across\nmultiple evaluations (e.g. on checkpoints from a training run). both datasets\nare enumerated so that even if the order of examples is changed during model\ninference, the enumeration can be used to match model outputs to examples from\nthe `task_dataset`.\n\nfor mixtures, each sub-task is evaluated separately, regardless of mixing\nrates, because in the context of eval benchmarks, mixtures commonly refer to a\ncollection of tasks belonging to that benchmark, each of which is evaluated\nseparately, e.g. superglue mixture.\n\nonce an `evaluator` instance is created with a seqio task or mixture, a model\ncan be evaluated by calling `evaluator.evaluate(...)` and passing a `predict_fn`\nand/or a `predict_with_aux_fn` and/or a `score_fn` to interact with the model.\n`predict_fn` takes the `model_dataset` as input and outputs a `sequence[(index,\ntoken_ids)]` where `token_ids` is the sequence of token ids generated by the\nmodel for the input example whose index matches `index`. therefore, even if\n`predict_fn` mixes the order of the examples during prediction, the order can be\ncorrected as long as the correct index for each example is maintained. a common\nexample is the multi-host setup where the evaluation dataset is split amongst\nmultiple hosts that independently make predictions and combine the results\nduring which the ordering can be mixed. `predict_with_aux_fn` is similar to\n`predict_fn`, except that it can also return a dictionary of auxiliary values\nalong with each sequence of `token_ids`, e.g. scores from the generated tokens.\nthe `score_fn` takes the `model_dataset` as input and returns a\n`sequence[(index, score)]` where `score` is the sequence of log likelihood\nscores for the targets in the dataset. this simple interface allows users to\neasily integrate the seqio evaluation flow with popular training frameworks in\ntf and jax.\n\ncorresponding to the model fns, users can configure three kinds of metric fns in\ntheir tasks, which are differentiated by their function signature. metrics\ncomputed on the outputs of `predict_fn` (and `predict_with_aux_fn`) have the\nsignature `targets` and `predictions` (and optionally `aux_values`), while\nmetrics computed on the outputs of `score_fn` have the signature `targets` and\n`predictions`. the `evaluator` takes care of calling the correct model fns and\nmetric fns during evaluation. here is an example of a metric of each type.\n\n```\ndef sequence_accuracy(targets, predictions):\n seq_acc = 100 * np.mean([p == t for p, t in zip(predictions, targets)])\n return {\"sequence_accuracy\": seq_acc}\n\ndef log_likelihood(targets, scores):\n log_likelihood = np.mean([scipy.special.logsumexp(el) for el in scores])\n return {\"log_likelihood\": log_likelihood}\n```\n\nthere are 4 steps involved in the evaluation using predicted tokens:\n\n+   the `predict_fn` or `predict_with_aux_fn` returns indices and output_tokens:\n    `sequence[tuple[int, sequence[int]]]`, potentially with some auxiliary\n    values.\n+   output tokens are decoded by `vocab.decode`\n+   postprocessors configured in tasks are applied to the decoded output. these\n    are denoted as predictions.\n+   metric fns configured in tasks are applied to the predictions and the cached\n    targets.\n\nthere are 2 steps involved in the evaluation using scores:\n\n+   the `score_fn` returns indices and scores: `sequence[tuple[int,\n    sequence[float]]]`\n+   metric fns configured in tasks is applied to the scores and the cached\n    targets.\n\ntraining codebases like t5x provide integration with seqio evaluation to allow \nevaluating checkpoints on seqio tasks and mixtures. see [t5x eval](https://github.com/google-research/t5x/blob/main/docs/usage/eval.md)\nfor instructions.\n\n## differences from `t5.data`\n\nthe original `t5` library introduced and implemented the `t5.data.task`\nabstraction for specifying preprocessing and evaluation metrics for text-to-text\ntasks. when creating a task, users specify a source dataset of raw text, some\npreprocessing steps, a vocabulary for tokenization, and evaluation metrics. the\nfully-specified task can then be used to pre-train or fine-tune a\nencoder-decoder transformer model. however, the design included many baked-in\nassumptions about the types of tasks users could specify.\n\nseqio removes some of the constraints of this abstraction:\n\n*   inputs and outputs are no longer required to be strings (e.g., it may be\n    images or audio).\n*   architectures other than the original encoder-decoder are supported (e.g.,\n    decoder-only language models like gpt or encoder-only models like bert).\n*   users can control at which stage of the pipeline offline caching occurs.\n*   users can control when and where eos tokens are added.\n\nfurthermore, seqio has been made more modular with respect to the mesh\ntensorflow transformer. this allows it to be used with other model\nimplementations with more consistency and much less code duplication.\n\n## advanced postprocessing `task`\n\n### triviaqa (closed-book, open-domain version)\nthis version of triviaqa was introduced in [roberts et al.\n2020](https://arxiv.org/abs/2002.08910).\n\n\n```py\nseqio.taskregistry.add(\n    \"trivia_qa_open\",\n    source=seqio.tfdsdatasource(\n      tfds_name=\"trivia_qa/unfiltered.nocontext:1.1.0\",\n      splits={\n          \"train\": \"train[:90%]\",\n          \"validation\": \"train[90%:]\",\n          \"test\": \"validation\"\n      }),\n    preprocessors=[\n        tqa_open_preprocessor,\n        seqio.preprocessors.tokenize,\n        seqio.preprocessors.append_eos,\n    ],\n    output_features={\n        \"inputs\": seqio.feature(\n           seqio.sentencepiecevocabulary(\"/path/to/inputs/vocab\"),\n           add_eos=false, dtype=tf.int32\n        ),\n        \"targets\": seqio.feature(\n           seqio.sentencepiecevocabulary(\"/path/to/targets/vocab\"),\n           add_eos=true, dtype=tf.int32\n        ),\n    },\n    postprocess_fn=tqa_open_postprocessor,\n    metric_fns=[tqa_metric])\n```\n\nin this example, we are using the `tfdsdatasource`. we specify the name of the\ntriviaqa dataset in tfds\n([`\"trivia_qa\"`](https://www.tensorflow.org/datasets/catalog/trivia_qa)), the\nspecific config that excludes the context for the open domain setting\n(`\"unfiltered.nocontext\"`), and the version number (`\"1.1.0\"`). we also override\nthe default splits to match what is commonly used for the open domain setting.\nspecifically, we set our \"test\" split to be the tfds \"validation\" split, and\ncreate a small pseudo-\"validation\" set by taking examples out of the tfds\n\"train\" split.\n\nthe preprocessor `tqa_open_preprocessor` is defined as follows.\n\n```py\ndef tqa_open_preprocessor(\n    dataset: tf.data.dataset,\n    prefix:str = \"trivia_qa question: \"\n  ) -> tf.data.dataset:\n  \"\"\"convert triviaqa dataset to open domain qa examples.\n\n  the function takes the trivia_qa tfds dataset and emits examples of the\n  form:\n  {\n    \"inputs\": \"trivia_qa question: what are the names of the olsen twins?\"\n    \"targets\": \"mary-kate and ashley\",\n    \"answers\": [\"mary-kate and ashley\", \"ashley and mary-kate\"]\n  }\n\n  args:\n    dataset: a tf.data.dataset to process.\n    prefix: str, prefix to prepend to the inputs.\n\n  returns:\n    a tf.data.dataset\n  \"\"\"\n  def tqa_map(ex):\n    \"\"\"map triviaqa example to text-to-text example.\"\"\"\n    return {\n        \"inputs\": prefix + ex[\"question\"],\n        \"targets\": ex[\"answer\"][\"value\"],\n        \"answers\": ex[\"answer\"][\"aliases\"],\n    }\n\n  return dataset.map(tqa_map, num_parallel_calls=tf.data.experimental.autotune)\n```\n\nor with the `seqio.map_overdataset` decorator, we have\n\n```py\ndef tqa_open_preprocessor(\n  dataset: tf.data.dataset,\n  prefix: str = \"trivia_qa question: \"\n) -> tf.data.dataset:\n\n  @seqio.map_over_dataset\n  def tqa_map(ex: mapping[str, tf.tensor]) -> mapping[str, tf.tensor]:\n    \"\"\"map triviaqa example to text-to-text example.\"\"\"\n    return {\n        \"inputs\": prefix + ex[\"question\"],\n        \"targets\": ex[\"answer\"][\"value\"],\n        \"answers\": ex[\"answer\"][\"aliases\"],\n    }\n\nreturn tqa_map(dataset)\n```\n\nhere we made a thin wrapper to emphasize that the function decorated by\n`seqio.map_over_dataset` takes in an instance of `tf.data.dataset`. in practice,\nthis wrapper is not necessary.\n\n\nthe postprocessor for this example is `tqa_open_postprocessor`, which is defined\nas follows:\n\n```py\ndef tqa_open_postprocessor(output_or_target, example=none, is_target=false):\n  \"\"\"returns output as answer, or all answers if the full example is provided.\"\"\"\n  if is_target:\n    return [a.decode(\"utf-8\") for a in example[\"answers\"]]\n  else:\n    return output_or_target.decode(\"utf-8\")\n```\n\nwhen processing the target, we ignore `output_or_target` (equivalent to\n`example[\"targets\"]`) since it is just selecting a single answer in\n`trivia_qa_open`. instead, we extract the full list of answers from the example\nand convert them from bytes to text. when handling the model output, we simply\nconvert it to text from detokenized bytes.\n\nthe metric function `tqa_metric` is defined as:\n\n```py\ndef tqa_metric(\n  targets: sequence[sequence[str]],\n  predictions: sequence[str]\n) -> mapping[str, seqio.metrics.metricvaluevalue]:\n  \"\"\"computes official triviaqa metrics.\n\n  args:\n    targets: list of lists of strings\n    predictions: list of strings\n\n  returns:\n    dict with score_key: squad score across all targets and predictions\n  \"\"\"\n\n  if len(targets) != len(predictions):\n    raise valueerror(\"number of targets and predictions must match.\")\n\n  def _normalize_answer(text):\n    \"\"\"lower text and remove punctuation, articles and extra whitespace.\"\"\"\n    # remove articles.\n    text = re.sub(r\"\\b(a|an|the)\\b\", \" \", s)\n    # remove punctuation.\n    for punc in string.punctuation:\n      text = text.replace(punc, '')\n    # normalize white space\n    text = \" \".join(s.split())\n    return text\n\n  # normalize answers before comparing.\n  targets = [[_normalize_answer(t) for t in u] for u in targets]\n  predictions = [_normalize_answer(p) for p in predictions]\n\n  em = np.mean([\n      max(pred == gt for gt in ground_truths)\n      for pred, ground_truths in zip(predictions, targets)\n  ])\n  return {\n      \"exact_match\": seqio.metrics.scalar(em),\n  }\n```\n\n## citing seqio\nplease use the following bibtex entry to cite seqio.\n\n```\n@article{roberts2022t5x,\n  url = {https://arxiv.org/abs/2203.17189},\n  author = {roberts, adam and chung, hyung won and levskaya, anselm and mishra, gaurav and bradbury, james and andor, daniel and narang, sharan and lester, brian and gaffney, colin and mohiuddin, afroz and hawthorne, curtis and lewkowycz, aitor and salcianu, alex and van zee, marc and austin, jacob and goodman, sebastian and soares, livio baldini and hu, haitang and tsvyashchenko, sasha and chowdhery, aakanksha and bastings, jasmijn and bulian, jannis and garcia, xavier and ni, jianmo and chen, andrew and kenealy, kathleen and clark, jonathan h. and lee, stephan and garrette, dan and lee-thorp, james and raffel, colin and shazeer, noam and ritter, marvin and bosma, maarten and passos, alexandre and maitin-shepard, jeremy and fiedel, noah and omernick, mark and saeta, brennan and sepassi, ryan and spiridonov, alexander and newlan, joshua and gesmundo, andrea},\n  title = {scaling up models and data with $\\texttt{t5x}$ and $\\texttt{seqio}$},\n  journal={arxiv preprint arxiv:2203.17189},\n  year = {2022},\n}\n```\n\n",
  "docs_url": null,
  "keywords": "sequence preprocessing nlp machinelearning",
  "license": "apache 2.0",
  "name": "seqio-nightly",
  "package_url": "https://pypi.org/project/seqio-nightly/",
  "project_url": "https://pypi.org/project/seqio-nightly/",
  "project_urls": {
    "Homepage": "https://github.com/google/seqio/tree/nightly"
  },
  "release_url": "https://pypi.org/project/seqio-nightly/0.0.17.dev20231224/",
  "requires_dist": [
    "absl-py",
    "clu",
    "editdistance",
    "jax",
    "jaxlib",
    "numpy",
    "packaging",
    "pyglove",
    "sentencepiece",
    "tensorflow-text",
    "tfds-nightly ==4.9.2.dev202308090034",
    "protobuf <=3.20.3",
    "apache-beam ; extra == 'cache-tasks'",
    "gevent ; extra == 'gcp'",
    "google-api-python-client ; extra == 'gcp'",
    "google-compute-engine ; extra == 'gcp'",
    "google-cloud-storage ; extra == 'gcp'",
    "oauth2client ; extra == 'gcp'",
    "pytest ; extra == 'test'"
  ],
  "requires_python": "",
  "summary": "seqio: task-based datasets, preprocessing, and evaluation for sequence models.",
  "version": "0.0.17.dev20231224",
  "releases": [],
  "developers": [
    "google_inc",
    "no-reply@google.com"
  ],
  "kwds": "tensorflow dataflow corpus sequence_accuracy sequentially",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_seqio_nightly",
  "homepage": "https://github.com/google/seqio/tree/nightly",
  "release_count": 765,
  "dependency_ids": [
    "pypi_absl_py",
    "pypi_apache_beam",
    "pypi_clu",
    "pypi_editdistance",
    "pypi_gevent",
    "pypi_google_api_python_client",
    "pypi_google_cloud_storage",
    "pypi_google_compute_engine",
    "pypi_jax",
    "pypi_jaxlib",
    "pypi_numpy",
    "pypi_oauth2client",
    "pypi_packaging",
    "pypi_protobuf",
    "pypi_pyglove",
    "pypi_pytest",
    "pypi_sentencepiece",
    "pypi_tensorflow_text",
    "pypi_tfds_nightly"
  ]
}