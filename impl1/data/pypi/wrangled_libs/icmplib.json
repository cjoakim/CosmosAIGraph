{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v3 (lgplv3)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "<br>\n<img src=\"https://raw.githubusercontent.com/valentinbelyn/icmplib/main/media/icmplib-logo.png\" height=\"125\" width=\"100\" alt=\"icmplib\">\n<br>\n\nicmplib is a brand new and modern implementation of the icmp protocol in python.<br>\nuse the built-in functions or build your own, you have the choice!\n\n<br>\n\n## features\n\n- \ud83c\udf33 **ready-to-use:** icmplib offers ready-to-use functions such as the most popular ones: `ping`, `multiping` and `traceroute`. an extensive documentation also helps you get started.\n- \ud83d\udc8e **modern:** this library uses the latest mechanisms offered by python 3.7+ and is fully object-oriented.\n- \ud83d\ude80 **fast:** each class and function has been designed and optimized to deliver the best performance. some functions are also asynchronous like the `async_ping` and `async_multiping` functions. you can ping the world in seconds!\n- \u26a1\ufe0f **powerful:** use the library without root privileges, set the traffic class of icmp packets, customize their payload, send broadcast requests and more!\n- \ud83d\udd29 **evolutive:** easily build your own classes and functions with `icmpv4` and `icmpv6` sockets.\n- \ud83d\udd25 **seamless integration of ipv6:** use ipv6 the same way you use ipv4.\n- \ud83c\udf7a **cross-platform:** optimized for linux, macos and windows. the library automatically manages the specificities of each system.\n- \ud83e\udd18 **no dependency:** icmplib is a pure python implementation of the icmp protocol. it does not rely on any external dependency.\n\n<br>\n\n## installation\n\n- **install icmplib**\n\n  the recommended way to install icmplib is to use `pip3`:\n\n  ```shell\n  $ pip3 install icmplib\n  ```\n\n- **import basic functions**\n\n  ```python\n  from icmplib import ping, multiping, traceroute, resolve\n  ```\n\n- **import asynchronous functions**\n\n  ```python\n  from icmplib import async_ping, async_multiping, async_resolve\n  ```\n\n- **import sockets (advanced)**\n\n  ```python\n  from icmplib import icmpv4socket, icmpv6socket, asyncsocket, icmprequest, icmpreply\n  ```\n\n- **import exceptions**\n\n  ```python\n  from icmplib import icmpliberror, namelookuperror, icmpsocketerror\n  from icmplib import socketaddresserror, socketpermissionerror\n  from icmplib import socketunavailableerror, socketbroadcasterror, timeoutexceeded\n  from icmplib import icmperror, destinationunreachable, timeexceeded\n  ```\n\n  *import only what you need.*\n\n<br>\n\n## getting started\n\n### ping\n\nsend icmp echo request packets to a network host.\n\n```python\nping(address, count=4, interval=1, timeout=2, id=none, source=none, family=none, privileged=true, **kwargs)\n```\n\n#### parameters\n\n- `address`\n\n  the ip address, hostname or fqdn of the host to which messages should be sent. for deterministic behavior, prefer to use an ip address.\n\n  - type: `str`\n\n- `count`\n\n  the number of ping to perform.\n\n  - type: `int`\n  - default: `4`\n\n- `interval`\n\n  the interval in seconds between sending each packet.\n\n  - type: `int` or `float`\n  - default: `1`\n\n- `timeout`\n\n  the maximum waiting time for receiving a reply in seconds.\n\n  - type: `int` or `float`\n  - default: `2`\n\n- `id`\n\n  the identifier of icmp requests. used to match the responses with requests. in practice, a unique identifier should be used for every ping process. on linux, this identifier is ignored when the `privileged` parameter is disabled. the library handles this identifier itself by default.\n\n  - type: `int`\n  - default: `none`\n\n- `source`\n\n  the ip address from which you want to send packets. by default, the interface is automatically chosen according to the specified destination.\n\n  - type: `str`\n  - default: `none`\n\n- `family`\n\n  the address family if a hostname or fqdn is specified. can be set to `4` for ipv4 or `6` for ipv6 addresses. by default, this function searches for ipv4 addresses first before searching for ipv6 addresses.\n\n  - type: `int`\n  - default: `none`\n\n- `privileged`\n\n  when this option is enabled, this library fully manages the exchanges and the structure of icmp packets. disable this option if you want to use this function without root privileges and let the kernel handle icmp headers.\n\n  [learn more about the `privileged` parameter.](https://github.com/valentinbelyn/icmplib/blob/main/docs/6-use-icmplib-without-privileges.md)\n\n  *only available on unix systems. ignored on windows.*\n\n  - type: `bool`\n  - default: `true`\n\n- `payload`\n\n  the payload content in bytes. a random payload is used by default.\n\n  - type: `bytes`\n  - default: `none`\n\n- `payload_size`\n\n  the payload size. ignored when the `payload` parameter is set.\n\n  - type: `int`\n  - default: `56`\n\n- `traffic_class`\n\n  the traffic class of icmp packets. provides a defined level of service to packets by setting the ds field (formerly tos) or the traffic class field of ip headers. packets are delivered with the minimum priority by default (best-effort delivery). intermediate routers must be able to support this feature.\n\n  *only available on unix systems. ignored on windows.*\n\n  - type: `int`\n  - default: `0`\n\n#### return value\n\n- a `host` object containing statistics about the desired destination:<br>\n  `address`, `min_rtt`, `avg_rtt`, `max_rtt`, `rtts`, `packets_sent`, `packets_received`, `packet_loss`, `jitter`, `is_alive`\n\n#### exceptions\n\n- `namelookuperror`\n\n  if you pass a hostname or fqdn in parameters and it does not exist or cannot be resolved.\n\n- `socketpermissionerror`\n\n  if the privileges are insufficient to create the socket.\n\n- `socketaddresserror`\n\n  if the source address cannot be assigned to the socket.\n\n- `icmpsocketerror`\n\n  if another error occurs. see the `icmpv4socket` or `icmpv6socket` class for details.\n\n#### example\n\n```python\n>>> from icmplib import ping\n\n>>> host = ping('1.1.1.1', count=10, interval=0.2)\n\n>>> host.address              # the ip address of the host that responded\n'1.1.1.1'                     # to the request\n\n>>> host.min_rtt              # the minimum round-trip time in milliseconds\n5.761\n\n>>> host.avg_rtt              # the average round-trip time in milliseconds\n12.036\n\n>>> host.max_rtt              # the maximum round-trip time in milliseconds\n16.207\n\n>>> host.rtts                 # the list of round-trip times expressed in\n[ 11.595, 13.135, 9.614,      # milliseconds\n  16.018, 11.960, 5.761,      # the results are not rounded unlike other\n  16.207, 11.937, 12.098 ]    # properties\n\n>>> host.packets_sent         # the number of requests transmitted to the\n10                            # remote host\n\n>>> host.packets_received     # the number of icmp responses received from\n9                             # the remote host\n\n>>> host.packet_loss          # packet loss occurs when packets fail to\n0.1                           # reach their destination. returns a float\n                              # between 0 and 1 (all packets are lost)\n\n>>> host.jitter               # the jitter in milliseconds, defined as the\n4.575                         # variance of the latency of packets flowing\n                              # through the network\n\n>>> host.is_alive             # indicates whether the host is reachable\ntrue\n```\n\n<br>\n\n### multiping\n\nsend icmp echo request packets to several network hosts.\n\n```python\nmultiping(addresses, count=2, interval=0.5, timeout=2, concurrent_tasks=50, source=none, family=none, privileged=true, **kwargs)\n```\n\n#### parameters\n\n- `addresses`\n\n  the ip addresses of the hosts to which messages should be sent. hostnames and fqdns are allowed but not recommended. you can easily retrieve their ip address by calling the built-in `resolve` function.\n\n  - type: `list[str]`\n\n- `count`\n\n  the number of ping to perform per address.\n\n  - type: `int`\n  - default: `2`\n\n- `interval`\n\n  the interval in seconds between sending each packet.\n\n  - type: `int` or `float`\n  - default: `0.5`\n\n- `timeout`\n\n  the maximum waiting time for receiving a reply in seconds.\n\n  - type: `int` or `float`\n  - default: `2`\n\n- `concurrent_tasks`\n\n  the maximum number of concurrent tasks to speed up processing. this value cannot exceed the maximum number of file descriptors configured on the operating system.\n\n  - type: `int`\n  - default: `50`\n\n- `source`\n\n  the ip address from which you want to send packets. by default, the interface is automatically chosen according to the specified destinations. this parameter should not be used if you are passing both ipv4 and ipv6 addresses to this function.\n\n  - type: `str`\n  - default: `none`\n\n- `family`\n\n  the address family if a hostname or fqdn is specified. can be set to `4` for ipv4 or `6` for ipv6 addresses. by default, this function searches for ipv4 addresses first before searching for ipv6 addresses.\n\n  - type: `int`\n  - default: `none`\n\n- `privileged`\n\n  when this option is enabled, this library fully manages the exchanges and the structure of icmp packets. disable this option if you want to use this function without root privileges and let the kernel handle icmp headers.\n\n  [learn more about the `privileged` parameter.](https://github.com/valentinbelyn/icmplib/blob/main/docs/6-use-icmplib-without-privileges.md)\n\n  *only available on unix systems. ignored on windows.*\n\n  - type: `bool`\n  - default: `true`\n\n- `payload`\n\n  the payload content in bytes. a random payload is used by default.\n\n  - type: `bytes`\n  - default: `none`\n\n- `payload_size`\n\n  the payload size. ignored when the `payload` parameter is set.\n\n  - type: `int`\n  - default: `56`\n\n- `traffic_class`\n\n  the traffic class of icmp packets. provides a defined level of service to packets by setting the ds field (formerly tos) or the traffic class field of ip headers. packets are delivered with the minimum priority by default (best-effort delivery). intermediate routers must be able to support this feature.\n\n  *only available on unix systems. ignored on windows.*\n\n  - type: `int`\n  - default: `0`\n\n#### return value\n\n- a list of `host` objects containing statistics about the desired destinations:<br>\n  `address`, `min_rtt`, `avg_rtt`, `max_rtt`, `rtts`, `packets_sent`, `packets_received`, `packet_loss`, `jitter`, `is_alive`\n\n  the list is sorted in the same order as the addresses passed in parameters.\n\n#### exceptions\n\n- `namelookuperror`\n\n  if you pass a hostname or fqdn in parameters and it does not exist or cannot be resolved.\n\n- `socketpermissionerror`\n\n  if the privileges are insufficient to create the socket.\n\n- `socketaddresserror`\n\n  if the source address cannot be assigned to the socket.\n\n- `icmpsocketerror`\n\n  if another error occurs. see the `icmpv4socket` or `icmpv6socket` class for details.\n\n#### example\n\n```python\n>>> from icmplib import multiping\n\n>>> hosts = multiping(['10.0.0.5', '127.0.0.1', '::1'])\n\n>>> for host in hosts:\n...     if host.is_alive:\n...         # see the host class for details\n...         print(f'{host.address} is up!')\n...     else:\n...         print(f'{host.address} is down!')\n\n# 10.0.0.5 is down!\n# 127.0.0.1 is up!\n# ::1 is up!\n```\n\n<br>\n\n### traceroute\n\ndetermine the route to a destination host.\n\nthe internet is a large and complex aggregation of network hardware, connected together by gateways. tracking the route one's packets follow can be difficult. this function uses the ip protocol time to live field and attempts to elicit an icmp time exceeded response from each gateway along the path to some host.\n\n*this function requires root privileges to run.*\n\n```python\ntraceroute(address, count=2, interval=0.05, timeout=2, first_hop=1, max_hops=30, fast=false, id=none, source=none, family=none, **kwargs)\n```\n\n#### parameters\n\n- `address`\n\n  the ip address, hostname or fqdn of the host to reach. for deterministic behavior, prefer to use an ip address.\n\n  - type: `str`\n\n- `count`\n\n  the number of ping to perform per hop.\n\n  - type: `int`\n  - default: `2`\n\n- `interval`\n\n  the interval in seconds between sending each packet.\n\n  - type: `int` or `float`\n  - default: `0.05`\n\n- `timeout`\n\n  the maximum waiting time for receiving a reply in seconds.\n\n  - type: `int` or `float`\n  - default: `2`\n\n- `first_hop`\n\n  the initial time to live value used in outgoing probe packets.\n\n  - type: `int`\n  - default: `1`\n\n- `max_hops`\n\n  the maximum time to live (max number of hops) used in outgoing probe packets.\n\n  - type: `int`\n  - default: `30`\n\n- `fast`\n\n  when this option is enabled and an intermediate router has been reached, skip to the next hop rather than perform additional requests. the `count` parameter then becomes the maximum number of requests in the event of no response.\n\n  - type: `bool`\n  - default: `false`\n\n- `id`\n\n  the identifier of icmp requests. used to match the responses with requests. in practice, a unique identifier should be used for every traceroute process. the library handles this identifier itself by default.\n\n  - type: `int`\n  - default: `none`\n\n- `source`\n\n  the ip address from which you want to send packets. by default, the interface is automatically chosen according to the specified destination.\n\n  - type: `str`\n  - default: `none`\n\n- `family`\n\n  the address family if a hostname or fqdn is specified. can be set to `4` for ipv4 or `6` for ipv6 addresses. by default, this function searches for ipv4 addresses first before searching for ipv6 addresses.\n\n  - type: `int`\n  - default: `none`\n\n- `payload`\n\n  the payload content in bytes. a random payload is used by default.\n\n  - type: `bytes`\n  - default: `none`\n\n- `payload_size`\n\n  the payload size. ignored when the `payload` parameter is set.\n\n  - type: `int`\n  - default: `56`\n\n- `traffic_class`\n\n  the traffic class of icmp packets. provides a defined level of service to packets by setting the ds field (formerly tos) or the traffic class field of ip headers. packets are delivered with the minimum priority by default (best-effort delivery). intermediate routers must be able to support this feature.\n\n  *only available on unix systems. ignored on windows.*\n\n  - type: `int`\n  - default: `0`\n\n#### return value\n\n- a list of `hop` objects representing the route to the desired destination. a `hop` has the same properties as a `host` object but it also has a `distance`:<br>\n  `address`, `min_rtt`, `avg_rtt`, `max_rtt`, `rtts`, `packets_sent`, `packets_received`, `packet_loss`, `jitter`, `is_alive`, `distance`\n\n  the list is sorted in ascending order according to the distance, in terms of hops, that separates the remote host from the current machine. gateways that do not respond to requests are not added to this list.\n\n#### exceptions\n\n- `namelookuperror`\n\n  if you pass a hostname or fqdn in parameters and it does not exist or cannot be resolved.\n\n- `socketpermissionerror`\n\n  if the privileges are insufficient to create the socket.\n\n- `socketaddresserror`\n\n  if the source address cannot be assigned to the socket.\n\n- `icmpsocketerror`\n\n  if another error occurs. see the `icmpv4socket` or `icmpv6socket` class for details.\n\n#### example\n\n```python\n>>> from icmplib import traceroute\n\n>>> hops = traceroute('1.1.1.1')\n\n>>> print('distance/ttl    address    average round-trip time')\n>>> last_distance = 0\n\n>>> for hop in hops:\n...     if last_distance + 1 != hop.distance:\n...         print('some gateways are not responding')\n...\n...     # see the hop class for details\n...     print(f'{hop.distance}    {hop.address}    {hop.avg_rtt} ms')\n...\n...     last_distance = hop.distance\n\n# distance/ttl    address                 average round-trip time\n# 1               10.0.0.1                5.196 ms\n# 2               194.149.169.49          7.552 ms\n# 3               194.149.166.54          12.21 ms\n# *               some gateways are not responding\n# 5               212.73.205.22           22.15 ms\n# 6               1.1.1.1                 13.59 ms\n```\n\n<br>\n\n### async_ping\n\nsend icmp echo request packets to a network host.\n\n*this function is non-blocking.*\n\n```python\nasync_ping(address, count=4, interval=1, timeout=2, id=none, source=none, family=none, privileged=true, **kwargs)\n```\n\n#### parameters, return value and exceptions\n\nthe same parameters, return value and exceptions as for the `ping` function.\n\n#### example\n\n```python\n>>> import asyncio\n>>> from icmplib import async_ping\n\n>>> async def is_alive(address):\n...     host = await async_ping(address, count=10, interval=0.2)\n...     return host.is_alive\n\n>>> asyncio.run(is_alive('1.1.1.1'))\ntrue\n```\n\n<br>\n\n### async_multiping\n\nsend icmp echo request packets to several network hosts.\n\n*this function is non-blocking.*\n\n```python\nasync_multiping(addresses, count=2, interval=0.5, timeout=2, concurrent_tasks=50, source=none, family=none, privileged=true, **kwargs)\n```\n\n#### parameters, return value and exceptions\n\nthe same parameters, return values and exceptions as for the `multiping` function.\n\n#### example\n\n```python\n>>> import asyncio\n>>> from icmplib import async_multiping\n\n>>> async def are_alive(*addresses):\n...     hosts = await async_multiping(addresses)\n...     \n...     for host in hosts:\n...         if not host.is_alive:\n...             return false\n...\n...     return true\n\n>>> asyncio.run(are_alive('10.0.0.5', '127.0.0.1', '::1'))\nfalse\n```\n\n<br>\n\n## documentation\n\nthis page only gives an overview of the features of icmplib.\n\nto learn more about the built-in functions, on how to create your own and handle exceptions, you can click on the following link:\n\n- \ud83d\ude80 [documentation](https://github.com/valentinbelyn/icmplib/tree/main/docs)\n\n## contributing\n\ncomments and enhancements are welcome.\n\nall development is done on [github](https://github.com/valentinbelyn/icmplib). use [issues](https://github.com/valentinbelyn/icmplib/issues) to report problems and submit feature requests. please include a minimal example that reproduces the bug.\n\n## donate\n\nicmplib is completely free and open source. it has been fully developed on my free time. if you enjoy it, please consider donating to support the development.\n\n- \ud83c\udf89 [donate via paypal](https://paypal.me/valentinbelyn)\n\n## license\n\ncopyright 2017-2023 valentin belyn.\n\ncode released under the gnu lgplv3 license. see the [license](https://github.com/valentinbelyn/icmplib/blob/main/license) for details.\n\n\n",
  "docs_url": null,
  "keywords": "icmp,sockets,ping,multiping,traceroute,async,asyncio,ipv4,ipv6,python,python3",
  "license": "gnu lesser general public license v3.0",
  "name": "icmplib",
  "package_url": "https://pypi.org/project/icmplib/",
  "project_url": "https://pypi.org/project/icmplib/",
  "project_urls": {
    "Homepage": "https://github.com/ValentinBELYN/icmplib"
  },
  "release_url": "https://pypi.org/project/icmplib/3.0.4/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "easily forge icmp packets and make your own ping and traceroute.",
  "version": "3.0.4",
  "releases": [],
  "developers": [
    "valentin-hello@gmx.com",
    "valentin_belyn"
  ],
  "kwds": "icmplib icmp icmpliberror icmpv4socket icmpv6socket",
  "license_kwds": "gnu lesser general public license v3.0",
  "libtype": "pypi",
  "id": "pypi_icmplib",
  "homepage": "https://github.com/valentinbelyn/icmplib",
  "release_count": 22,
  "dependency_ids": []
}