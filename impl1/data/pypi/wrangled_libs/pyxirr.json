{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: the unlicense (unlicense)",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: rust",
    "topic :: office/business :: financial"
  ],
  "description": "[![rust-lang.org](https://img.shields.io/badge/made%20with-rust-red)](https://www.rust-lang.org/)\n[![license](https://img.shields.io/github/license/anexen/pyxirr.svg)](https://github.com/anexen/pyxirr/blob/master/license)\n[![pypi](https://img.shields.io/pypi/v/pyxirr.svg)](https://pypi.org/project/pyxirr/)\n[![versions](https://img.shields.io/pypi/pyversions/pyxirr.svg)](https://pypi.org/project/pyxirr/)\n\n# pyxirr\n\nrust-powered collection of financial functions.\n\npyxirr stands for \"python xirr\" (for historical reasons), but contains many other financial functions such as irr, fv, npv, etc.\n\nfeatures:\n\n- correct\n- supports different day count conventions (e.g. act/360, 30e/360, etc.)\n- works with different input data types (iterators, numpy arrays, pandas dataframes)\n- no external dependencies\n- type annotations\n- blazingly fast\n\n# installation\n\n```\npip install pyxirr\n```\n\n# benchmarks\n\nrust implementation has been tested against existing [xirr](https://pypi.org/project/xirr/) package\n(uses [scipy.optimize](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html) under the hood)\nand the [implementation from the stack overflow](https://stackoverflow.com/a/11503492) (pure python).\n\n![bench](https://raw.githubusercontent.com/anexen/pyxirr/main/docs/static/bench.png)\n\npyxirr is ~10-20x faster in xirr calculation than the other implementations.\n\npowered by [github-action-benchmark](https://github.com/rhysd/github-action-benchmark) and [plotly.js](https://github.com/plotly/plotly.js).\n\nlive benchmarks are hosted on [github pages](https://anexen.github.io/pyxirr/bench).\n\n# example\n\n```python\nfrom datetime import date\nfrom pyxirr import xirr\n\ndates = [date(2020, 1, 1), date(2021, 1, 1), date(2022, 1, 1)]\namounts = [-1000, 750, 500]\n\n# feed columnar data\nxirr(dates, amounts)\n# feed iterators\nxirr(iter(dates), (x / 2 for x in amounts))\n# feed an iterable of tuples\nxirr(zip(dates, amounts))\n# feed a dictionary\nxirr(dict(zip(dates, amounts)))\n# dates as strings\nxirr(['2020-01-01', '2021-01-01'], [-1000, 1200])\n```\n\n# multiple irr problem\n\nthe multiple irr problem occur when the signs of cash flows change more than\nonce. in this case, we say that the project has non-conventional cash flows.\nthis leads to situation, where it can have more the one irr or have no irr at all.\n\npyxirr's approach to the multiple irr problem:\n\n1. it looks for positive result around 0.1 (the same as excel with the default guess=0.1).\n2. if it can't find a result, it uses several other attempts and selects the lowest irr to be conservative.\n\nhere is an example of how to find multiple irrs:\n\n```python\nimport numpy as np\nimport pyxirr\n\n# load cash flow:\ncf = pd.read_csv(\"tests/samples/30-22.csv\", names=[\"date\", \"amount\"])\n# check whether the cash flow is conventional:\nprint(pyxirr.is_conventional_cash_flow(cf[\"amount\"]))  # false\n\n# build npv profile:\n# calculate 50 npv values for different rates\nrates = np.linspace(-0.5, 0.5, 50)\n# any iterable, any rates, e.g.\n# rates = [-0.5, -0.3, -0.1, 0.1, -0.6]\nvalues = pyxirr.xnpv(rates, cf)\n\n# print npv profile:\n# npv changes sign two times:\n#   1) between -0.316 and -0.295\n#   2) between -0.03 and -0.01\nprint(\"npv profile:\")\nfor rate, value in zip(rates, values):\n    print(rate, value)\n\n# plot npv profile\nimport pandas as pd\nseries = pd.series(values, index=rates)\npd.dataframe(series[series > -1e6]).assign(zero=0).plot()\n\n# find points where npv function crosses zero\nindexes = pyxirr.zero_crossing_points(values)\n\nprint(\"zero crossing points:\")\nfor idx in indexes:\n    print(\"between\", rates[idx], \"and\", rates[idx+1])\n\n# xirr has two results:\n#   -0.31540826742734207\n#   -0.028668460065441048\nfor i, idx in enumerate(indexes, start=1):\n    rate = pyxirr.xirr(cf, guess=rates[idx])\n    npv = pyxirr.xnpv(rate, cf)\n    print(f\"{i}) {rate}; xnpv = {npv}\")\n```\n\n# more examples\n\n### numpy and pandas\n\n```python\nimport numpy as np\nimport pandas as pd\n\n# feed numpy array\nxirr(np.array([dates, amounts]))\nxirr(np.array(dates), np.array(amounts))\n\n# feed dataframe (columns names doesn't matter; ordering matters)\nxirr(pd.dataframe({\"a\": dates, \"b\": amounts}))\n\n# feed series with datetimeindex\nxirr(pd.series(amounts, index=pd.to_datetime(dates)))\n\n# bonus: apply xirr to a dataframe with datetimeindex:\ndf = pd.dataframe(\n    index=pd.date_range(\"2021\", \"2022\", freq=\"ms\", inclusive=\"left\"),\n    data={\n        \"one\": [-100] + [20] * 11,\n        \"two\": [-80] + [19] * 11,\n    },\n)\ndf.apply(xirr)  # series(index=[\"one\", \"two\"], data=[5.09623547168478, 8.780801977141174])\n```\n\n### day count conventions\n\ncheck out the available options on the [docs/day-count-conventions](https://anexen.github.io/pyxirr/functions.html#day-count-conventions).\n\n```python\nfrom pyxirr import daycount\n\nxirr(dates, amounts, day_count=daycount.act_360)\n\n# parse day count from string\nxirr(dates, amounts, day_count=\"30e/360\")\n```\n\n### private equity performance metrics\n\n```python\nfrom pyxirr import pe\n\npe.pme_plus([-20, 15, 0], index=[100, 115, 130], nav=20)\n\npe.direct_alpha([-20, 15, 0], index=[100, 115, 130], nav=20)\n```\n\n[docs](https://anexen.github.io/pyxirr/private_equity.html)\n\n### other financial functions\n\n```python\nimport pyxirr\n\n# future value\npyxirr.fv(0.05/12, 10*12, -100, -100)\n\n# net present value\npyxirr.npv(0, [-40_000, 5_000, 8_000, 12_000, 30_000])\n\n# irr\npyxirr.irr([-100, 39, 59, 55, 20])\n\n# ... and more! check out the docs.\n```\n\n[docs](https://anexen.github.io/pyxirr/functions.html)\n\n### vectorization\n\npyxirr supports numpy-like vectorization.\n\nif all input is scalar, returns a scalar float. if any input is array_like,\nreturns values for each input element. if multiple inputs are\narray_like, performs broadcasting and returns values for each element.\n\n```python\nimport pyxirr\n\n# feed list\npyxirr.fv([0.05/12, 0.06/12], 10*12, -100, -100)\npyxirr.fv([0.05/12, 0.06/12], [10*12, 9*12], [-100, -200], -100)\n\n# feed numpy array\nimport numpy as np\nrates = np.array([0.05, 0.06, 0.07])/12\npyxirr.fv(rates, 10*12, -100, -100)\n\n# feed any iterable!\npyxirr.fv(\n    np.linspace(0.01, 0.2, 10),\n    (x + 1 for x in range(10)),\n    range(-100, -1100, -100),\n    tuple(range(-100, -200, -10))\n)\n\n# 2d, 3d, 4d, and more!\nrates = [[[[[[0.01], [0.02]]]]]]\npyxirr.fv(rates, 10*12, -100, -100)\n```\n\n# api reference\n\nsee the [docs](https://anexen.github.io/pyxirr)\n\n# roadmap\n\n- [x] implement all functions from [numpy-financial](https://numpy.org/numpy-financial/latest/index.html)\n- [x] improve docs, add more tests\n- [x] type hints\n- [x] vectorized versions of numpy-financial functions.\n- [ ] compile library for rust/javascript/python\n\n# development\n\nrunning tests with pyo3 is a bit tricky. in short, you need to compile your tests without `extension-module` feature to avoid linking errors.\nsee the following issues for the details: [#341](https://github.com/pyo3/pyo3/issues/341), [#771](https://github.com/pyo3/pyo3/issues/771).\n\nif you are using `pyenv`, make sure you have the shared library installed (check for `${pyenv_root}/versions/<version>/lib/libpython3.so` file).\n\n```bash\n$ python_configure_opts=\"--enable-shared\" pyenv install <version>\n```\n\ninstall dev-requirements\n\n```bash\n$ pip install -r dev-requirements.txt\n```\n\n### building\n\n```bash\n$ maturin develop\n```\n\n### testing\n\n```bash\n$ ld_library_path=${pyenv_root}/versions/3.10.8/lib cargo test\n```\n\n### benchmarks\n\n```bash\n$ pip install -r bench-requirements.txt\n$ ld_library_path=${pyenv_root}/versions/3.10.8/lib cargo +nightly bench\n```\n\n# building and distribution\n\nthis library uses [maturin](https://github.com/pyo3/maturin) to build and distribute python wheels.\n\n```bash\n$ docker run --rm -v $(pwd):/io ghcr.io/pyo3/maturin build --release --manylinux 2010 --strip\n$ maturin upload target/wheels/pyxirr-${version}*\n```\n\n",
  "docs_url": null,
  "keywords": "python,fast,financial,xirr,cashflow,day count convention,pme",
  "license": "unlicense",
  "name": "pyxirr",
  "package_url": "https://pypi.org/project/pyxirr/",
  "project_url": "https://pypi.org/project/pyxirr/",
  "project_urls": {
    "Homepage": "https://github.com/Anexen/pyxirr"
  },
  "release_url": "https://pypi.org/project/pyxirr/0.10.1/",
  "requires_dist": [],
  "requires_python": ">=3.7, <3.13",
  "summary": "rust-powered collection of financial functions for python.",
  "version": "0.10.1",
  "releases": [],
  "developers": [
    "anexen"
  ],
  "kwds": "pyxirr pypi pyo3 pyenv rust",
  "license_kwds": "unlicense",
  "libtype": "pypi",
  "id": "pypi_pyxirr",
  "homepage": "https://github.com/anexen/pyxirr",
  "release_count": 27,
  "dependency_ids": []
}