{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu general public license v3 or later (gplv3+)",
    "license :: osi approved :: gnu lesser general public license v3 or later (lgplv3+)",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "# extra dictionary classes and utilities for python\n\nsome mapping containers and tools for daily use with python.\nthis attempts to be a small package with no dependencies,\njust delivering its data-types as described bellow\nenough tested for production-usage.\n\n\n## versiondict\n\na python mutable mapping container (dictionary :-) ) that\ncan \"remember\" previous values.\nuse it wherever you would use a dict - at each\nkey change or update, it's `version` attribute\nis increased by one.\n\n### special and modified methods:\n\n`.get` method is modified to receive an optional\nnamed  `version` parameter that allows one to retrieve\nfor a key the value it contained at that respective version.\nnb. when using the `version` parameter, `get` will raise\na keyerror if the key does not exist for that version and\nno default value is specified.\n\n`.copy(version=none)`:  yields a copy of the current dictionary at that version, with history preserved\n(if version is not given, the current version is used)\n\n`.freeze(version=none)` yields a snapshot of the versiondict in the form of a plain dictionary for\nthe specified version\n\n\n### implementation:\nit works by internally keeping a list of (named)tuples with\n(version, value) for each key.\n\n\n### example:\n\n```python\n\n>>> from extradict import versiondict\n>>> a = versiondict(b=0)\n>>> a[\"b\"] = 1\n>>> a[\"b\"]\n1\n>>> a.get(\"b\", version=0)\n0\n```\n\nfor extra examples, check the \"tests\" directory\n\n## orderedversiondict\n\ninherits from versiondict, but preserves and retrieves key\ninsertion order. unlike a plain \"collections.ordereddict\",\nhowever, whenever a key's value is updated, it is moved\nlast on the dictionary order.\n\n### example:\n```python\n>>> from collections import ordereddict\n>>> a = ordereddict(((\"a\", 1), (\"b\", 2), (\"c\", 3)))\n>>> list(a.keys())\n>>> ['a', 'b', 'c']\n>>> a[\"a\"] = 3\n>>> list(a.keys())\n>>> ['a', 'b', 'c']\n\n>>> from extradict import orderedversiondict\n>>> a = orderedversiondict(((\"a\", 1), (\"b\", 2), (\"c\", 3)))\n>>> list(a.keys())\n['a', 'b', 'c']\n>>> a[\"a\"] = 3\n>>> list(a.keys())\n['b', 'c', 'a']\n```\n\n## mapgetter\na context manager that allows one to pick variables from inside a dictionary,\nmapping, or any python object by using the  `from <myobject> import key1, key2` statement.\n\n\n\n```python\n>>> from extradict import mapgetter\n>>> a = dict(b=\"test\", c=\"another test\")\n>>> with mapgetter(a) as a:\n...     from a import b, c\n...\n>>> print (b, c)\ntest another test\n```\n\nor:\n```python\n>>> from collections import namedtuple\n>>> a = namedtuple(\"a\", \"c d\")\n>>> b = a(2,3)\n>>> with mapgetter(b):\n...     from b import c, d\n>>> print(c, d)\n2, 3\n```\n\nit works with python 3.4+ \"enum\"s - which is great as it allow one\nto use the enums by their own name, without having to prepend the enum class\nevery time:\n```python\n>>> from enum import enum\n\n>>> class colors(tuple, enum):\n...     red = 255, 0, 0\n...     green = 0, 255, 0\n...     blue = 0, 0, 255\n...\n\n>>> with mapgetter(colors):\n...    from colors import red, green, blue\n...\n\n>>> red\n<colors.red: (255, 0, 0)>\n>>> red[0]\n255\n```\n\nmapgetter can also have a `default` value or callable which\nwill generate values for each name that one tries to \"import\" from it:\n\n```python\n>>> with mapgetter(default=lambda x: x) as x:\n...    from x import foo, bar, baz\n...\n\n>>> foo\n'foo'\n>>> bar\n'bar'\n>>> baz\n'baz'\n```\n\nif the parameter default is not a callable, it is assigned directly to\nthe imported names. if it is a callable, mapgetter will try to call it passing\neach name as the first and only positional parameter. if that fails\nwith a type error, it calls it without parameters the way collections.defaultdict\nworks.\n\n\nthe syntax `from <mydict> import key1 as var1` works as well.\n\n## bijectivedict\nthis is a bijective dictionary for which each pair key, value added\nis also added as value, key.\n\nthe explicitly inserted keys can be retrieved as the \"assigned_keys\"\nattribute - and a dictionary copy with all such keys is available\nat the \"bijectivedict.assigned\".\nconversely, the generated keys are exposed as \"bijectivedict.generated_keys\"\nand can be seen as a dict at \"bijective.generated\"\n\n```python\n>>> from extradict import bijectivedict\n>>>\n>>> a = bijectivedict(b = 1, c = 2)\n>>> a\nbijectivedict({'b': 1, 2: 'c', 'c': 2, 1: 'b'})\n>>> a[2]\n'c'\n>>> a[2] = \"d\"\n>>> a[\"d\"]\n2\n>>> a[\"c\"]\ntraceback (most recent call last):\n  file \"<stdin>\", line 1, in <module>\n  file \"/home/gwidion/projetos/extradict/extradict/reciprocal_dict.py\", line 31, in __getitem__\n    return self._data[item]\nkeyerror: 'c'\n>>>\n```\n\n## namedtuple\nalternate, clean room, implementation of 'namedtuple' as in stdlib's collection.namedtuple\n. this does not make use of \"eval\" at runtime - and can be up to 10 times faster to create\na namedtuple class than the stdlib version.\n\ninstead, it relies on closures to do its magic.\n\nhowever, these will be slower to instantiate than stdlib version. the \"fastnamedtuple\"\nis faster in all respects, although it holds the same api for instantiating as tuples, and\nperforms no length checking.\n\n\n## fastnamedtuple\nlike namedtuple but the class returned take an iterable for its values\nrather than positioned or named parameters. no checks are made towards the iterable\nlength, which should match the number of attributes\nit is faster for instantiating as compared with stdlib's namedtuple\n\n\n## defaultnamedtuple\nimplementation of named-tuple using default parameters -\neither pass a sequence of 2-tuples (or an ordereddict) as the second parameter, or\nsend in kwargs with the default parameters, after the first.\n(this takes advantage of python3.6 + guaranteed ordering of **kwargs for a function\nsee https://docs.python.org/3.6/whatsnew/3.6.html)\n\nthe resulting object can accept positional or named parameters to be instantiated, as a\nnormal namedtuple, however, any omitted parameters are used from the original\nmapping passed to it.\n\n\n## fallbacknormalizeddict\ndictionary meant for text only keys:\nwill normalize keys in a way that capitalization, whitespace and\npunctuation will be ignored when retrieving items.\n\na parallel dictionary is maintained with the original keys,\nso that strings that would clash on normalization can still\nbe used as separated key/value pairs if original punctuation\nis passed in the key.\n\nprimary use case if for keeping translation strings when the source\nfor the original strings is loose in terms of whitespace/punctuation\n(for example, in an http snippet)\n\n\n## normalizeddict\ndictionary meant for text only keys:\nwill normalize keys in a way that capitalization, whitespace and\npunctuation will be ignored when retrieving items.\n\nunlike fallbacknormalizeddict this does not keep the original\nversion of the keys.\n\n\n## treedict\na python mapping with an underlying auto-balancing binary tree data structure.\nas such, it allows seeking ranges of keys - so, that\n`mytreedict[\"aa\":\"bz\"] will return a list with all values in\nthe dictionary whose keys are strings starting from \"aa\"\nup to those starting with \"by\".\n\nit also features a `.get_closest_keys` method that will\nretrieve the closest existing keys for the required element.\n```python\n>>> from extradict import treedict\n>>> a = treedict()\n>>> a[1] = \"one word\"\n>>> a[3] = \"another word\"\n>>> a[:]\n['one word', 'another word']\n>>> a.get_closest_keys(2)\n(1, 3)\n```\n\nanother feature of these dicts is that as they\ndo not rely on an object hash, any python\nobject can be used as a key. of course\nkey objects should be comparable with <=, ==, >=. if\nthey are not, errors will be raised. however, there is\nan extra feature - when creating the treedict a named\nargument `key` parameter can be passed that works the\nsame as python's `sorted` \"key\" parameter: a callable\nthat will receive the key/value pair as its sole argument\nand should return a comparable object. the returned object\nis the one used to keep the binary tree organized.\n\n\nif the output of the given `key_func` ties, that is it:\nthe new pair simply overwrites whatever other key/value\nhad the same key_func output. to avoid that,\ncraft the key_funcs so that they return a tuple\nwith the original key as the second item:\n```python\n>>> from extradict import treedict\n>>> b = treedict(key=len)\n>>> b[\"red\"] = 1\n>>> b[\"blue\"] = 2\n>>> b\ntreedict('red'=1, 'blue'=2, key_func= <built-in function len>)\n\n>>> b[\"1234\"] = 5\n>>> b\ntreedict('red'=1, '1234'=5, key_func= <built-in function len>)\n\n>>> treedict(key=lambda k: (len(k), k))\n>>> b[\"red\"] = 1\n>>> b[\"blue\"] = 2\n>>> b[\"1234\"] = 5\n>>> b\n>>> treedict('red'=1, '1234'=5, 'blue'=2, key_func= <function <lambda> at 0x7fbc7f462320>)\n```\n\n### plainnode and avlnode\n\nto support the treedict mapping interface, the standalone\n`plainnode` and `avlnode` classes are available at\nthe `extradict.binary_tree_dict` module - and can be used\nto create a lower level tree data structure, which can\nhave more capabilities. for one, the \"raw\" use allows\nrepeated values in the nodes, all nodes are root to\ntheir own subtrees and know nothing of their parents,\nand if one wishes, no need to work with \"key: value\" pairs:\nif a \"pair\" argument is not supplied to a node, it\nreflects the given key as its own value.\n\n`plainnode` will build non-autobalancing trees,\nwhile those built with `avlnode` will be self-balancing.\ntrying to manually mix node types in the same tree, or\nchanging the key_func in different notes,\nwill obviously wreck everything.\n\n## grouper\n\n\nthink of it as an itertools.groupby which returns a mapping\nor as an itertools.tee that splits the stream into filtered\nsubstreams according to the passed key-callable.\n\ngiven an iterable and a key callable,\neach element in the iterable is run through the key callable and\nmade available in an iterator under a bucket using the resulting key-value.\n\nthe source iterable need not be ordered (unlike itertools.groupby).\nif no key function  is given, the identity function is used.\n\nthe items will be made available under the iterable-values as requested,\nin a lazy way when possible. note that several different method calls may\nprecipatate an eager processing of all items in the source iterator:\n.keys() or len(), for example.\n\nwhenever a new key is found during input consumption, a \"queue\" iterator,\nwhich is a thin wrapper over collections.deque is created under that key\nand can be further iterated to retrieve more elements that map to\nthe same key.\n\nin short, this is very similar to `itertools.tee`, but with a filter\nso that each element goes to a mapped bucket.\n\nonce created, the resulting object may obtionally be called. doing this\nwill consume all data in the source iterator at once, and return a\na plain dictionary with all data fetched into lists.\n\nfor example, to divide a sequence of numbers from 0 to 10 in\n5 buckets, all one need to do is: `grouper(myseq, lambda x: x // 2)`\n\nor:\n```python\n>>> from extradict import grouper\n>>> even_odd = grouper(range(10), lambda x: \"even\" if not x % 2 else \"odd\")\n>>> print(list(even_odd[\"even\"]))\n[0, 2, 4, 6, 8]\n>>> print(list(even_odd[\"odd\"]))\n[1, 3, 5, 7, 9]\n\n```\n\n\n## nesteddata\n\nnestable mappings and sequences data structure to facilitate field access\n\nthe idea is a single data structure that can hold \"json\" data, adding some\nhelper methods and functionalities.\n\nprimarily, one can use a dotted string path to access a deply nested key, value pair,\ninstead of concatenating several dictionary \".get\" calls.\n\nexamples:\n      `person[\"address.city\"] instead of person[\"address\"][\"city\"]`\n\n      or\n\n      `persons[\"10.contacts.emails.0\"]`\n\n\nthe first tool available is the ability to merge mappings with extra keys\ninto existing nested mappings, without deleting non colidng keys:\na \"person.address\" key that would contain \"city\" but no \"street\" or \"zip-code\"\ncan be updated with:  `record[\"person\"].merge({\"address\": {\"street\": \"5th ave\", \"zip-code\": \"000000\"}})`\npreserving the \"person.address.city\" value in the process.\n\nthe \".data\" attribute stores the object contents as a tree of dicionary and lists as needed -\nthese are lazily wrapped as nesteddata instances if retrieved through the class, but\ncan be freely manipulated directly.\n\n```python\n>>> import json\n>>> from extradict import nesteddata\n>>> a = nesteddata(json.load(open(\"myfile.json\")))\n>>> assert a[\"persons.0.address\"] == a[\"persons\"][0][\"address\"]\ntrue\n>>> a.merge({\"city\": none}, \"persons.*.address\")  # creates a new \"city\" key in all addresses\n```",
  "docs_url": null,
  "keywords": "versioned bijective assigner getter unpack transactional container collection dict dictionary normalized binarytree",
  "license": "lgplv3+",
  "name": "extradict",
  "package_url": "https://pypi.org/project/extradict/",
  "project_url": "https://pypi.org/project/extradict/",
  "project_urls": {
    "Homepage": "https://github.com/jsbueno/extradict"
  },
  "release_url": "https://pypi.org/project/extradict/0.6.0/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "enhanced, maybe useful, data containers and utilities: a versioned dictionary, a bidirectional dictionary, a binary tree backed dictionary, a grouper iterator mapper similar to itertools.tee, and an easy extractor from dictionary key/values to variables",
  "version": "0.6.0",
  "releases": [],
  "developers": [
    "gwidion@gmail.com"
  ],
  "kwds": "versiondict bijectivedict orderedversiondict binary_tree_dict normalizeddict",
  "license_kwds": "lgplv3+",
  "libtype": "pypi",
  "id": "pypi_extradict",
  "homepage": "https://github.com/jsbueno/extradict",
  "release_count": 13,
  "dependency_ids": []
}