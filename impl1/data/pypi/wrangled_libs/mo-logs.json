{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mozilla public license 2.0 (mpl 2.0)",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "\r\n# more logs - structured logging and exception handling\r\n\r\n[![pypi latest release](https://img.shields.io/pypi/v/mo-logs.svg)](https://pypi.org/project/mo-logs/)\r\n[![build status](https://app.travis-ci.com/klahnakoski/mo-logs.svg?branch=master)](https://travis-ci.com/github/klahnakoski/mo-logs)\r\n [![coverage status](https://coveralls.io/repos/github/klahnakoski/mo-logs/badge.svg?branch=dev)](https://coveralls.io/github/klahnakoski/mo-logs?branch=dev)\r\n[![downloads](https://pepy.tech/badge/mo-logs)](https://pepy.tech/project/mo-logs)\r\n\r\n\r\nthis library provides two main features\r\n\r\n* **structured logging** - output is all json (with options to serialize to text for humans)\r\n* **exception handling weaved in** - good logs must represent what happened,\r\nand that can only be done if the logging library is intimately familiar with\r\nthe (exceptional) code paths taken.\r\n\r\n## motivation\r\n\r\nexception handling and logging are undeniably linked. there are many instances\r\nwhere exceptions are raised and must be logged, and others where the subsuming \r\nsystem can fully handle the exception, and no log should be emitted. exception \r\nhandling semantics are great because they decouple the cause from the solution, \r\nbut this can be at odds with clean logging - which couples raising and catching \r\nto make appropriate decisions about what to emit to the log.  \r\n\r\nthis logging module is additionally responsible for raising exceptions,\r\ncollecting the trace and severity, and then deducing if it must be logged, or\r\nif it can be ignored because something can handle it.\r\n\r\n\r\n## basic usage\r\n\r\n### use `logger.info()` for all logging\r\n\r\n```python\r\nfrom mo_logs import logger\r\nlogger.info(\"hello, world!\")\r\n```\r\n\r\nthere is no need to create logger objects. the `mo_logs` module will keep track of\r\nwhat, where and when of every call.\r\n\r\n\r\n### importing\r\n\r\nif you have existing logger code, you may change your import statement, replace `import logging` with `import mo_logs as logging`\r\n\r\nsince `mo-logs` tracks calling context, you may simply import the same logger everywhere \r\n\r\n\r\n```python\r\nfrom mo_logs import logger\r\n```\r\n\r\n\r\n### using named parameters\r\n\r\nall logging calls accept a string template with named parameters. keyword arguments\r\ncan be added to the call to provide values. the template and arguments are not \r\ncombined at call time, rather they are held in a json-izable data structure for \r\nstructured logging. the template is only expanded *if* the log is serialized for humans.  \r\n\r\n```python\r\nlogger.info(\"hello, {{name}}!\", name=\"world!\")\r\n```\r\n\r\n**do not use python's string formatting features:**\r\n \r\n* [string formatting operator (`%`)](http://python-reference.readthedocs.io/en/latest/docs/str/formatting.html), \r\n* [the `format()` function](https://docs.python.org/3/library/stdtypes.html#str.format) \r\n* [literal string intrpolation](https://www.python.org/dev/peps/pep-0498/).\r\n\r\nusing any of these will expand the string template at call time, which is a parsing\r\nnightmare for log analysis tools.\r\n\r\n\r\n### parametric parameters\r\n\r\nall the `logger` functions accept a `default_params` as a second parameter, like so:\r\n\r\n```python\r\nlogger.info(\"hello, {{name}}!\", {\"name\": \"world!\"})\r\n```\r\n\r\nthis is meant for the situation your code already has a bundled structure you\r\nwish to use as a source of parameters. if keyword parameters are used, they\r\nwill override the default values. be careful when sending whole data\r\nstructures, they will be logged!\r\n\r\n### please, never use locals()\r\n\r\n```python\r\ndef worker(value):\r\n    name = \"tout le monde!\"\r\n    password = \"123\"\r\n    logger.info(\"hello, {{name}}\", locals())      # do not do this!\r\n```\r\n\r\ndespite the fact using `locals()` is a wonderful shortcut for logging it is\r\ndangerous because it also picks up sensitive local variables. even if\r\n`{{name}}` is the only value in the template, the whole `locals()` dict will\r\nbe sent to the structured loggers for recording. \r\n\r\n### formatting parameters\r\n\r\nthere are a variety of formatters, and they can be applied by using the \r\npipe (`|`) symbol.  \r\n\r\nin this example we cast the `name` to uppercase\r\n\r\n```python\r\nlogger.info(\"hello, {{name|upper}}!\", name=\"world!\")\r\n```\r\n\r\nsome formatters accept arguments:\r\n\r\n```python\r\nlogger.info(\"pi is {{pi|round(places=3)}}!\", pi=3.14159265)\r\n```\r\n\r\nyou can look at the [`strings` module](https://github.com/klahnakoski/mo-logs/blob/dev/mo_logs/strings.py#l56) to see the formatters available.\r\n\r\n### destination: database!\r\n\r\nall logs are structured logs; the parameters will be included, unchanged, in\r\nthe log structure. this library also expects all parameter values to be json-\r\nserializable so they can be stored/processed by downstream json tools.\r\n\r\n**example structured log** \r\n```json\r\n{\r\n    \"template\": \"hello, {{name}}!\",\r\n    \"params\": {\"name\": \"world!\"},\r\n    \"severity\": \"note\",\r\n    \"format\": \"{{machine.name}} (pid {{machine.pid}}) - {{timestamp|datetime}} - {{thread.name}} - \\\"{{location.file}}:{{location.line}}\\\" - ({{location.method}}) - hello, {{params.name}}!\",\r\n    \"location\": {\r\n        \"file\": \"/home/kyle/code/example.py\",\r\n        \"line\": 10,\r\n        \"method\": \"worker\"\r\n    },\r\n    \"machine\": {\r\n        \"name\": \"klahnakoski-39477\",\r\n        \"os\": \"windows10\",\r\n        \"pid\": 18060,\r\n        \"python\": \"cpython\"\r\n    },\r\n    \"thread\": {\r\n        \"id\": 14352,\r\n        \"name\": \"mainthread\"\r\n    },\r\n    \"timestamp\": 1578673471\r\n}\r\n```\r\n\r\n## exception handling\r\n\r\n### instead of `raise` use `logger.error()`\r\n\r\n```python\r\nlogger.error(\"this will throw an error\")\r\n```\r\n\r\nthe actual call will always raise an exception, and it manipulates the stack\r\ntrace to ensure the caller is appropriately blamed. feel free to use the\r\n`raise` keyword (as in `raise logger.error(\"\")`), if that looks nicer to you. \r\n\r\n### always chain your exceptions\r\n\r\nthe `cause` parameter accepts an `exception`, or a list of exceptions.\r\nchaining is generally good practice that helps you find the root cause of\r\na failure. \r\n\r\n```python\r\ntry:\r\n    # do something that might raise exception\r\nexcept exception as cause:\r\n    logger.error(\"describe what you were trying to do\", cause=cause)\r\n```\r\n\r\n### use `raise from`?\r\n\r\npython3 attaches the full stacktrace to exceptions and allows chaining with `raise from`.  we can replace \r\n\r\n```python\r\nfrom mo_logs import logger\r\nlogger.error(\"description\", cause=cause)\r\n```\r\n\r\nwith \r\n\r\n```python\r\nfrom mo_logs.exceptions import error, except \r\nraise except(error, \"description\") from cause\r\n```\r\n\r\nwhich is a bit more clunky, especially when passing dynamic parameters. plus it breaks the `logger.<type>()` calling pattern; switching between an `error` and a `warning` is more than a name change.\r\n\r\n\r\n### use named parameters in your error descriptions too\r\n\r\nerror logging accepts keyword parameters just like `logger.info()` does\r\n\r\n```python\r\ndef worker(value):\r\n    try:\r\n        logger.info(\"start working with {{key1}}\", key1=value1)\r\n        # do something that might raise exception\r\n    except exception as cause:\r\n        logger.error(\"failure to work with {{key2}}\", key2=value2, cause=cause)\r\n```\r\n\r\n### no need to formally type your exceptions\r\n\r\nan exception can be uniquely identified by the message template\r\nit is given; exceptions raised with the same template are the same type. you\r\nshould have no need to create new exception types.\r\n\r\n### testing for exception \"types\"\r\n\r\nthis library advocates chaining exceptions early and often, and this hides\r\nimportant exception types in a long causal chain. `mo-logs` allows you to easily\r\ntest if a type (or string, or template) can be found in the causal chain by using\r\nthe `in` keyword:   \r\n\r\n```python\r\ndef worker(value):\r\n    try:\r\n        # do something that might raise exception\r\n    except exception as cause:\r\n        if \"failure to work with {{key2}}\" in cause:\r\n            # deal with exception thrown in above code, no matter\r\n            # how many other exception handlers were in the chain\r\n```\r\n\r\nfor those who may abhor the use of magic strings, feel free to use constants instead:\r\n\r\n```python\r\nkey_error = \"failure to work with {{key}}\"\r\n\r\ntry:\r\n    logger.error(key_error, key=42)        \r\nexcept exception as cause:\r\n    if key_error in cause:\r\n        logger.info(\"dealt with key error\")\r\n```\r\n\r\n\r\n\r\n\r\n### if you can deal with an exception, then it will never be logged\r\n\r\nwhen a caller catches an exception from a callee, it is the caller's\r\nresponsibility to handle that exception, or re-raise it. there are many\r\nsituations a caller can be expected to handle exceptions; and in those cases\r\nlogging an error would be deceptive. \r\n\r\n```python\r\ndef worker(value):\r\n    try:\r\n        logger.error(\"failure to work with {{key3}}\", key3=value3)\r\n    except exception as cause:\r\n        # try something else\r\n```\r\n\r\n### use `logger.warning()` if your code can deal with an exception, but you still want to log it as an issue\r\n\r\n```python\r\ndef worker(value):\r\n    try:\r\n        logger.info(\"start working with {{key4}}\", key4=value4)\r\n        # do something that might raise exception\r\n    except exception as cause:\r\n        logger.warning(\"failure to work with {{key4}}\", key4=value4, cause=cause)\r\n```\r\n### don't loose your stack trace!\r\n\r\nbe aware your `except` clause can also throw exceptions: in the event you\r\ncatch a vanilla python exception, you run the risk of loosing its stack trace.\r\nto prevent this, wrap your exception in an `except` object, which will capture\r\nyour trace for later use. exceptions thrown from `mo-logs` library need not\r\nbe wrapped because they already captured their trace. if you wrap an `except`\r\nobject, you simply get back the object you passed.\r\n\r\n\r\n```python\r\ntry:\r\n    # do some work        \r\nexcept exception as cause:\r\n    cause = except.wrap(cause)\r\n    # do some fancy error recovery\r\n ```\r\n\r\n### always catch all `exceptions`\r\n\r\ncatching all exceptions is preferred over the *only-catch-what-you-can-handle*\r\nstrategy. first, exceptions are not lost because we are chaining. second,\r\nwe catch unexpected `exceptions` early and we annotate them with a\r\ndescription of what the local code was intending to do. this annotation\r\neffectively groups the possible errors (known, or not) into a class, which\r\ncan be used by callers to decide on appropriate mitigation.  \r\n\r\nto repeat: when using dependency injection, callers can not reasonably be\r\nexpected to know about the types of failures that can happen deep down the\r\ncall chain. this makes it vitally important that methods summarize all\r\nexceptions, both known and unknown, so their callers have the information to\r\nmake better decisions on appropriate action.  \r\n\r\nfor example: an abstract document container, implemented on top of a sql \r\ndatabase, should not emit sqlexceptions of any kind: a caller that uses a \r\ndocument container should not need to know how to handle sqlexceptions (or any \r\nother implementation-specific exceptions). rather, in this example, the \r\ncaller should be told it \"can not add a document\", or \"can not remove a \r\ndocument\". this allows the caller to make reasonable decisions when they do \r\noccur. the original cause (the sqlexception) is in the causal chain.\r\n\r\nanother example, involves *nested exceptions*: if you catch a particular type \r\nof exception, you may inadvertently catch the same type of exception \r\nfrom deeper in the call chain. narrow exception handling is an illusion. \r\nbroad exception handling will force you to consider a variety of failures \r\nearly; force you to consider what it means when a block of code fails; and \r\nforce you to describe it for others.\r\n\r\n### don't make methods you do not need\r\n\r\nthere is an argument that suggests you should break your code into logical methods, rather than catching exceptions: the method name will describe action that failed, and the stack trace can be inspected to make mitigation decisions. additional methods is a poor solution:\r\n\r\n* more methods means more complexity; the programmer must find the method, remember the method, and wonder if the method is used elsewhere.\r\n* methods can be removed while refactoring; exceptions make it clear the error is important\r\n* compiler optimizations can interfere with the call stack\r\n* the method name is not an appropriate description of the problem: many words may be required for clarity.\r\n* code that inspects its own stack trace is messy code.\r\n* a stack trace does not include runtime values that are vital for describing the problem.\r\n\r\n\r\n## log 'levels'\r\n\r\nthe `mo-logs` module has no concept of logging \"levels\". it's expected you use debug\r\nvariables: variables prefixed with `debug_` are used to control the logging\r\noutput.\r\n\r\n\r\n```python\r\n# simple.py\r\ndebug_show_detail = true\r\n\r\ndef worker():\r\n    if debug_show_detail:\r\n        logger.info(\"starting\")\r\n\r\n    # do work here\r\n\r\n    if debug_show_detail:\r\n        logger.info(\"done\")\r\n\r\ndef main():\r\n    try:\r\n        settings = startup.read_settings()\r\n        logger.start(settings.debug)\r\n\r\n        # do work here\r\n\r\n    except exception as cause:\r\n        logger.error(\"complain, or not\", cause)\r\n    finally:\r\n        logger.stop()\r\n```\r\n\r\nthis pattern of using explict debug variables allows the programmer to switch logging on and off on individual subsystems that share that variable: either multiple debug variables in a single module, or multiple modules sharing a single debug variable.\r\n\r\nthese debug variables can be switched on/off by configuration file:\r\n\r\n```javascript\r\n// settings.json\r\n{\r\n    \"debug\":{\r\n        \"constants\":{\"simple.debug_show_details\":false}\r\n    }\r\n}\r\n```\r\n\r\nto keep logging to a single line, you may consider this pattern:\r\n\r\n    debug and logger.info(\"error: {{value}}\", value=expensive_function()) \r\n\r\nnotice the `expensive_function()` is not run when `debug` is false.\r\n\r\n## log configuration and setup\r\n\r\nthe `mo-logs` library will log to the console by default. ```logger.start(settings)```\r\nwill redirect the logging to other streams, as defined by the settings:\r\n\r\n *  **logs** - list of all log-streams and their parameters\r\n *  **trace** - show more details in every log line (default false)\r\n *  **cprofile** - used to enable the builtin python c-profiler, ensuring the cprofiler is turned on for all spawned threads. (default false)\r\n *  **constants** - map absolute path of module constants to the values that will be assigned. used mostly to set debugging constants in modules.\r\n\r\nof course, logging should be the first thing to be setup (aside from digesting\r\nsettings of course). for this reason, applications should have the following\r\nstructure:\r\n\r\n```python\r\nfrom mo_logs import logger\r\n\r\ndef main():\r\n    try:\r\n        settings = startup.read_settings()\r\n        logger.start(settings.debug)\r\n\r\n        # do work here\r\n\r\n    except exception as cause:\r\n        logger.error(\"complain, or not\", cause)\r\n    finally:\r\n        logger.stop()\r\n```\r\n\r\nor more simply \r\n\r\n```python\r\nfrom mo_logs import loggingcontext\r\n\r\ndef main():\r\n    with loggingcontext():\r\n        # do work here\r\n```\r\n\r\n\r\nexample configuration file\r\n\r\n```json\r\n{\"debug\":{\r\n    \"trace\":true,\r\n    \"log\":[\r\n        {\r\n            \"class\": \"logging.handlers.rotatingfilehandler\",\r\n            \"filename\": \"examples/logs/examples_etl.log\",\r\n            \"maxbytes\": 10000000,\r\n            \"backupcount\": 100,\r\n            \"encoding\": \"utf8\"\r\n        },\r\n        {\r\n            \"class\": \"graypy.gelfudphandler\",\r\n            \"host\": \"localhost\",\r\n            \"port\": 12201\r\n        },\r\n        {\r\n            \"log_type\": \"email\",\r\n            \"from_address\": \"klahnakoski@mozilla.com\",\r\n            \"to_address\": \"klahnakoski@mozilla.com\",\r\n            \"subject\": \"[alert][dev] problem in etl spot\",\r\n            \"$ref\": \"file://~/private.json#email\"\r\n        },\r\n        {\r\n            \"log_type\": \"console\"\r\n        }\r\n    ]\r\n}}\r\n```\r\n\r\n## capturing logs\r\n\r\nyou can receive a copy of all logs and send them to your own logging with \r\n\r\n    logger.set_logger(mylogger)\r\n    \r\nwhere `mylogger` is an instance that can accept a calls to `write(template, parameters)`. if your logging library can only handle strings, then use `message = expand_template(template, params)`.\r\n\r\n\r\n## more reading\r\n\r\n* **structured logging is good** - https://sites.google.com/site/steveyegge2/the-emacs-problem\r\n\r\n",
  "docs_url": null,
  "keywords": "",
  "license": "mpl 2.0",
  "name": "mo-logs",
  "package_url": "https://pypi.org/project/mo-logs/",
  "project_url": "https://pypi.org/project/mo-logs/",
  "project_urls": {
    "Homepage": "https://github.com/klahnakoski/mo-logs"
  },
  "release_url": "https://pypi.org/project/mo-logs/8.456.23316/",
  "requires_dist": [
    "mo-dots ==9.455.23316",
    "mo-future ==7.449.23304",
    "mo-imports ==7.449.23304",
    "mo-kwargs ==7.455.23316",
    "mo-json ; extra == 'tests'",
    "mo-threads ==5.368.23092 ; extra == 'tests'",
    "mo-testing ; extra == 'tests'",
    "mo-kwargs ; extra == 'tests'",
    "jx-python ; extra == 'tests'",
    "boto ; extra == 'tests'",
    "beautifulsoup4 ; extra == 'tests'",
    "graypy ; extra == 'tests'"
  ],
  "requires_python": "",
  "summary": "more logs! structured logging and exception handling",
  "version": "8.456.23316",
  "releases": [],
  "developers": [
    "kyle@lahnakoski.com",
    "kyle_lahnakoski"
  ],
  "kwds": "mo_logs logging logs log logger",
  "license_kwds": "mpl 2.0",
  "libtype": "pypi",
  "id": "pypi_mo_logs",
  "homepage": "https://github.com/klahnakoski/mo-logs",
  "release_count": 128,
  "dependency_ids": [
    "pypi_beautifulsoup4",
    "pypi_boto",
    "pypi_graypy",
    "pypi_jx_python",
    "pypi_mo_dots",
    "pypi_mo_future",
    "pypi_mo_imports",
    "pypi_mo_json",
    "pypi_mo_kwargs",
    "pypi_mo_testing",
    "pypi_mo_threads"
  ]
}