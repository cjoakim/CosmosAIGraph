{
  "classifiers": [
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# dataclass array\n\n[![unittests](https://github.com/google-research/dataclass_array/actions/workflows/pytest_and_autopublish.yml/badge.svg)](https://github.com/google-research/dataclass_array/actions/workflows/pytest_and_autopublish.yml)\n[![pypi version](https://badge.fury.io/py/dataclass_array.svg)](https://badge.fury.io/py/dataclass_array)\n[![documentation status](https://readthedocs.org/projects/dataclass-array/badge/?version=latest)](https://dataclass-array.readthedocs.io/en/latest/?badge=latest)\n\n\n`dataclassarray` are dataclasses which behave like numpy-like arrays (can be\nbatched, reshaped, sliced,...), compatible with jax, tensorflow, and numpy (with\ntorch support planned).\n\nthis reduce boilerplate and improve readability. see the\n[motivating examples](#motivating-examples) section bellow.\n\nto view an example of dataclass arrays used in practice, see\n[visu3d](https://github.com/google-research/visu3d).\n\n## documentation\n\n### definition\n\nto create a `dca.dataclassarray`, take a frozen dataclass and:\n\n*   inherit from `dca.dataclassarray`\n*   annotate the fields with `dataclass_array.typing` to specify the inner shape\n    and dtype of the array (see below for static or nested dataclass fields).\n    the array types are an alias from\n    [`etils.array_types`](https://github.com/google/etils/blob/main/etils/array_types/readme.md).\n\n```python\nimport dataclass_array as dca\nfrom dataclass_array.typing import floatarray\n\n\nclass ray(dca.dataclassarray):\n  pos: floatarray['*batch_shape 3']\n  dir: floatarray['*batch_shape 3']\n```\n\n### usage\n\nafterwards, the dataclass can be used as a numpy array:\n\n```python\nray = ray(pos=jnp.zeros((3, 3)), dir=jnp.eye(3))\n\n\nray.shape == (3,)  # 3 rays batched together\nray.pos.shape == (3, 3)  # individual fields still available\n\n# numpy slicing/indexing/masking\nray = ray[..., 1:2]\nray = ray[norm(ray.dir) > 1e-7]\n\n# shape transformation\nray = ray.reshape((1, 3))\nray = ray.reshape('h w -> w h')  # native einops support\nray = ray.flatten()\n\n# stack multiple dataclass arrays together\nray = dca.stack([ray0, ray1, ...])\n\n# supports tf, jax, numpy (torch planned) and can be easily converted\nray = ray.as_jax()  # as_np(), as_tf()\nray.xnp == jax.numpy  # `numpy`, `jax.numpy`, `tf.experimental.numpy`\n\n# compatibility `with jax.tree_util`, `jax.vmap`,..\nray = jax.tree_util.tree_map(lambda x: x+1, ray)\n```\n\na `dataclassarray` has 2 types of fields:\n\n*   array fields: fields batched like numpy arrays, with reshape, slicing,...\n    can be `xnp.ndarray` or nested `dca.dataclassarray`.\n*   static fields: other non-numpy field. are not modified by reshaping,...\n    static fields are also ignored in `jax.tree_map`.\n\n```python\nclass myarray(dca.dataclassarray):\n  # array fields\n  a: floatarray['*batch_shape 3']  # defined by `etils.array_types`\n  b: floatarray['*batch_shape _ _']  # dynamic shape\n  c: ray  # nested dataclassarray (equivalent to `ray['*batch_shape']`)\n  d: ray['*batch_shape 6']\n\n  # array fields explicitly defined\n  e: any = dca.field(shape=(3,), dtype=np.float32)\n  f: any = dca.field(shape=(none,  none), dtype=np.float32)  # dynamic shape\n  g: ray = dca.field(shape=(3,), dtype=ray)  # nested dataclassarray\n\n  # static field (everything not defined as above)\n  static0: float\n  static1: np.array\n```\n\n### vectorization\n\n`@dca.vectorize_method` allow your dataclass method to automatically support\nbatching:\n\n1.  implement method as if `self.shape == ()`\n2.  decorate the method with `dca.vectorize_method`\n\n```python\nclass camera(dca.dataclassarray):\n  k: floatarray['*batch_shape 4 4']\n  resolution = tuple[int, int]\n\n  @dca.vectorize_method\n  def rays(self) -> ray:\n    # inside `@dca.vectorize_method` shape is always guarantee to be `()`\n    assert self.shape == ()\n    assert self.k.shape == (4, 4)\n\n    # compute the ray as if there was only a single camera\n    return ray(pos=..., dir=...)\n```\n\nafterward, we can generate rays for multiple camera batched together:\n\n```python\ncams = camera(k=k)  # k.shape == (num_cams, 4, 4)\nrays = cams.rays()  # generate the rays for all the cameras\n\ncams.shape == (num_cams,)\nrays.shape == (num_cams, h, w)\n```\n\n`@dca.vectorize_method` is similar to `jax.vmap` but:\n\n*   only work on `dca.dataclassarray` methods\n*   instead of vectorizing a single axis, `@dca.vectorize_method` will vectorize\n    over `*self.shape` (not just `self.shape[0]`). this is like if `vmap` was\n    applied to `self.flatten()`\n*   when multiple arguments, axis with dimension `1` are broadcasted.\n\nfor example, with `__matmul__(self, x: t) -> t`:\n\n```python\n() @ (*x,) -> (*x,)\n(b,) @ (b, *x) -> (b, *x)\n(b,) @ (1, *x) -> (b, *x)\n(1,) @ (b, *x) -> (b, *x)\n(b, h, w) @ (b, h, w, *x) -> (b, h, w, *x)\n(1, h, w) @ (b, 1, 1, *x) -> (b, h, w, *x)\n(a, *x) @ (b, *x) -> error: incompatible a != b\n```\n\nto test on colab, see the `visu3d` dataclass\n[colab tutorial](https://colab.research.google.com/github/google-research/visu3d/blob/main/docs/dataclass.ipynb).\n\n## motivating examples\n\n`dca.dataclassarray` improve readability by simplifying common patterns:\n\n*   reshaping all fields of a dataclass:\n\n    before (`rays` is simple `dataclass`):\n\n    ```python\n    num_rays = math.prod(rays.origins.shape[:-1])\n    rays = jax.tree_map(lambda r: r.reshape((num_rays, -1)), rays)\n    ```\n\n    after (`rays` is `dataclassarray`):\n\n    ```python\n    rays = rays.flatten()  # (b, h, w) -> (b*h*w,)\n    ```\n\n*   rendering a video:\n\n    before (`cams: list[camera]`):\n\n    ```python\n    img = cams[0].render(scene)\n    imgs = np.stack([cam.render(scene) for cam in cams[::2]])\n    imgs = np.stack([cam.render(scene) for cam in cams])\n    ```\n\n    after (`cams: camera` with `cams.shape == (num_cams,)`):\n\n    ```python\n    img = cams[0].render(scene)  # render only the first camera (to debug)\n    imgs = cams[::2].render(scene)  # render 1/2 frames (for quicker iteration)\n    imgs = cams.render(scene)  # render all cameras at once\n    ```\n\n## installation\n\n```sh\npip install dataclass_array\n```\n\n*this is not an official google product*\n\n",
  "docs_url": null,
  "keywords": "dataclass,dataclasses,numpy,jax,tensorflow,array",
  "license": "",
  "name": "dataclass-array",
  "package_url": "https://pypi.org/project/dataclass-array/",
  "project_url": "https://pypi.org/project/dataclass-array/",
  "project_urls": {
    "changelog": "https://github.com/google-research/dataclass_array/blob/main/CHANGELOG.md",
    "documentation": "https://dataclass-array.readthedocs.io",
    "homepage": "https://github.com/google-research/dataclass_array",
    "repository": "https://github.com/google-research/dataclass_array"
  },
  "release_url": "https://pypi.org/project/dataclass-array/1.5.1/",
  "requires_dist": [
    "einops",
    "etils[edc,enp,epath,epy,etree]",
    "lark",
    "numpy",
    "typing_extensions",
    "pytest ; extra == \"dev\"",
    "pytest-xdist ; extra == \"dev\"",
    "pylint>=2.6.0 ; extra == \"dev\"",
    "pyink ; extra == \"dev\"",
    "chex ; extra == \"dev\"",
    "jax[cpu] ; extra == \"dev\"",
    "tf-nightly ; extra == \"dev\"",
    "torch ; extra == \"dev\"",
    "sphinx-apitree[ext] ; extra == \"docs\"",
    "dataclass_array[dev] ; extra == \"docs\""
  ],
  "requires_python": ">=3.9",
  "summary": "dataclasses that behave like numpy arrays (with indexing, slicing, vectorization).",
  "version": "1.5.1",
  "releases": [],
  "developers": [
    "dataclass_array@google.com"
  ],
  "kwds": "dataclasses dataclass_array dataclass dataclassarray tensorflow",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_dataclass_array",
  "homepage": "",
  "release_count": 11,
  "dependency_ids": [
    "pypi_chex",
    "pypi_dataclass_array",
    "pypi_einops",
    "pypi_etils",
    "pypi_jax",
    "pypi_lark",
    "pypi_numpy",
    "pypi_pyink",
    "pypi_pylint",
    "pypi_pytest",
    "pypi_pytest_xdist",
    "pypi_sphinx_apitree",
    "pypi_tf_nightly",
    "pypi_torch",
    "pypi_typing_extensions"
  ]
}