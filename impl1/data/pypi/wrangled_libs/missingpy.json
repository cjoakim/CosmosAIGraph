{
  "classifiers": [
    "license :: osi approved :: gnu general public license v3 (gplv3)",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "## missingpy\n\n`missingpy` is a library for missing data imputation in python. it has an \napi consistent with [scikit-learn](http://scikit-learn.org/stable/), so users \nalready comfortable with that interface will find themselves in familiar \nterrain. currently, the library supports k-nearest neighbors based \nimputation and random forest based imputation (missforest) but we plan to add \nother imputation tools in the future so please stay tuned!\n\n## installation\n\n`pip install missingpy`\n\n## k-nearest neighbors (knn) imputation\n\n### example\n```\n# let x be an array containing missing values\nfrom missingpy import knnimputer\nimputer = knnimputer()\nx_imputed = imputer.fit_transform(x)\n```\n\n### description\nthe `knnimputer` class provides imputation for completing missing\nvalues using the k-nearest neighbors approach. each sample's missing values\nare imputed using values from `n_neighbors` nearest neighbors found in the\ntraining set. note that if a sample has more than one feature missing, then\nthe sample can potentially have multiple sets of `n_neighbors`\ndonors depending on the particular feature being imputed.\n\neach missing feature is then imputed as the average, either weighted or\nunweighted, of these neighbors. where the number of donor neighbors is less\nthan `n_neighbors`, the training set average for that feature is used\nfor imputation. the total number of samples in the training set is, of course,\nalways greater than or equal to the number of nearest neighbors available for\nimputation, depending on both the overall sample size as well as the number of\nsamples excluded from nearest neighbor calculation because of too many missing\nfeatures (as controlled by `row_max_missing`).\nfor more information on the methodology, see [1].\n\nthe following snippet demonstrates how to replace missing values,\nencoded as `np.nan`, using the mean feature value of the two nearest\nneighbors of the rows that contain the missing values::\n\n    >>> import numpy as np\n    >>> from missingpy import knnimputer\n    >>> nan = np.nan\n    >>> x = [[1, 2, nan], [3, 4, 3], [nan, 6, 5], [8, 8, 7]]\n    >>> imputer = knnimputer(n_neighbors=2, weights=\"uniform\")\n    >>> imputer.fit_transform(x)\n    array([[1. , 2. , 4. ],\n           [3. , 4. , 3. ],\n           [5.5, 6. , 5. ],\n           [8. , 8. , 7. ]])\n\n### api\n    knnimputer(missing_values=\"nan\", n_neighbors=5, weights=\"uniform\", \n                     metric=\"masked_euclidean\", row_max_missing=0.5, \n                     col_max_missing=0.8, copy=true)\n\n    parameters\n    ----------\n    missing_values : integer or \"nan\", optional (default = \"nan\")\n        the placeholder for the missing values. all occurrences of\n        `missing_values` will be imputed. for missing values encoded as\n        ``np.nan``, use the string value \"nan\".\n\n    n_neighbors : int, optional (default = 5)\n        number of neighboring samples to use for imputation.\n\n    weights : str or callable, optional (default = \"uniform\")\n        weight function used in prediction.  possible values:\n\n        - 'uniform' : uniform weights.  all points in each neighborhood\n          are weighted equally.\n        - 'distance' : weight points by the inverse of their distance.\n          in this case, closer neighbors of a query point will have a\n          greater influence than neighbors which are further away.\n        - [callable] : a user-defined function which accepts an\n          array of distances, and returns an array of the same shape\n          containing the weights.\n\n    metric : str or callable, optional (default = \"masked_euclidean\")\n        distance metric for searching neighbors. possible values:\n        - 'masked_euclidean'\n        - [callable] : a user-defined function which conforms to the\n        definition of _pairwise_callable(x, y, metric, **kwds). in other\n        words, the function accepts two arrays, x and y, and a\n        ``missing_values`` keyword in **kwds and returns a scalar distance\n        value.\n\n    row_max_missing : float, optional (default = 0.5)\n        the maximum fraction of columns (i.e. features) that can be missing\n        before the sample is excluded from nearest neighbor imputation. it\n        means that such rows will not be considered a potential donor in\n        ``fit()``, and in ``transform()`` their missing feature values will be\n        imputed to be the column mean for the entire dataset.\n\n    col_max_missing : float, optional (default = 0.8)\n        the maximum fraction of rows (or samples) that can be missing\n        for any feature beyond which an error is raised.\n\n    copy : boolean, optional (default = true)\n        if true, a copy of x will be created. if false, imputation will\n        be done in-place whenever possible. note that, if metric is\n        \"masked_euclidean\" and copy=false then missing_values in the\n        input matrix x will be overwritten with zeros.\n\n    attributes\n    ----------\n    statistics_ : 1-d array of length {n_features}\n        the 1-d array contains the mean of each feature calculated using\n        observed (i.e. non-missing) values. this is used for imputing\n        missing values in samples that are either excluded from nearest\n        neighbors search because they have too many ( > row_max_missing)\n        missing features or because all of the sample's k-nearest neighbors\n        (i.e., the potential donors) also have the relevant feature value\n        missing.\n\n    methods\n    -------\n    fit(x, y=none):\n        fit the imputer on x.\n\n        parameters\n        ----------\n        x : {array-like}, shape (n_samples, n_features)\n            input data, where ``n_samples`` is the number of samples and\n            ``n_features`` is the number of features.\n\n        returns\n        -------\n        self : object\n            returns self.\n\n\n    transform(x):\n        impute all missing values in x.\n\n        parameters\n        ----------\n        x : {array-like}, shape = [n_samples, n_features]\n            the input data to complete.\n\n        returns\n        -------\n        x : {array-like}, shape = [n_samples, n_features]\n            the imputed dataset.\n\n\n    fit_transform(x, y=none, **fit_params):\n        fit knnimputer and impute all missing values in x.\n\n        parameters\n        ----------\n        x : {array-like}, shape (n_samples, n_features)\n            input data, where ``n_samples`` is the number of samples and\n            ``n_features`` is the number of features.\n\n        returns\n        -------\n        x : {array-like}, shape (n_samples, n_features)\n            returns imputed dataset.       \n\n### references\n1. olga troyanskaya, michael cantor, gavin sherlock, pat brown, trevor\n    hastie, robert tibshirani, david botstein and russ b. altman, missing value\n    estimation methods for dna microarrays, bioinformatics vol. 17 no. 6, 2001\n    pages 520-525.\n\n## random forest imputation (missforest)\n\n### example\n```\n# let x be an array containing missing values\nfrom missingpy import missforest\nimputer = missforest()\nx_imputed = imputer.fit_transform(x)\n```\n\n### description\nmissforest imputes missing values using random forests in an iterative\nfashion [1]. by default, the imputer begins imputing missing values of the\ncolumn (which is expected to be a variable) with the smallest number of\nmissing values -- let's call this the candidate column.\nthe first step involves filling any missing values of the remaining,\nnon-candidate, columns with an initial guess, which is the column mean for\ncolumns representing numerical variables and the column mode for columns\nrepresenting categorical variables. note that the categorical variables \nneed to be explicitly identified during the imputer's `fit()` method call \n(see api for more information). after that, the imputer fits a random\nforest model with the candidate column as the outcome variable and the\nremaining columns as the predictors over all rows where the candidate\ncolumn values are not missing.\nafter the fit, the missing rows of the candidate column are\nimputed using the prediction from the fitted random forest. the\nrows of the non-candidate columns act as the input data for the fitted\nmodel.\nfollowing this, the imputer moves on to the next candidate column with the\nsecond smallest number of missing values from among the non-candidate\ncolumns in the first round. the process repeats itself for each column\nwith a missing value, possibly over multiple iterations or epochs for\neach column, until the stopping criterion is met.\nthe stopping criterion is governed by the \"difference\" between the imputed\narrays over successive iterations. for numerical variables (`num_vars_`),\nthe difference is defined as follows:\n\n     sum((x_new[:, num_vars_] - x_old[:, num_vars_]) ** 2) /\n     sum((x_new[:, num_vars_]) ** 2)\n\nfor categorical variables(`cat_vars_`), the difference is defined as follows:\n\n    sum(x_new[:, cat_vars_] != x_old[:, cat_vars_])) / n_cat_missing\n\nwhere `x_new` is the newly imputed array, `x_old` is the array imputed in the\nprevious round, `n_cat_missing` is the total number of categorical\nvalues that are missing, and the `sum()` is performed both across rows\nand columns. following [1], the stopping criterion is considered to have\nbeen met when difference between `x_new` and `x_old` increases for the first\ntime for both types of variables (if available).\n\n\n    >>> from missingpy import missforest\n    >>> nan = float(\"nan\")\n    >>> x = [[1, 2, nan], [3, 4, 3], [nan, 6, 5], [8, 8, 7]]\n    >>> imputer = missforest()\n    >>> imputer.fit_transform(x)\n    iteration: 0\n    iteration: 1\n    iteration: 2\n    iteration: 3\n    array([[1.  , 2. , 4. ],\n           [3.  , 4. , 3. ],\n           [3.16, 6. , 5. ],\n           [8.  , 8. , 7. ]])\n\n### api\n    missforest(max_iter=10, decreasing=false, missing_values=np.nan,\n                 copy=true, n_estimators=100, criterion=('mse', 'gini'),\n                 max_depth=none, min_samples_split=2, min_samples_leaf=1,\n                 min_weight_fraction_leaf=0.0, max_features='auto',\n                 max_leaf_nodes=none, min_impurity_decrease=0.0,\n                 bootstrap=true, oob_score=false, n_jobs=-1, random_state=none,\n                 verbose=0, warm_start=false, class_weight=none)\n\n    parameters\n    ----------\n    note: most parameter definitions below are taken verbatim from the\n    scikit-learn documentation at [2] and [3].\n\n    max_iter : int, optional (default = 10)\n        the maximum iterations of the imputation process. each column with a\n        missing value is imputed exactly once in a given iteration.\n\n    decreasing : boolean, optional (default = false)\n        if set to true, columns are sorted according to decreasing number of\n        missing values. in other words, imputation will move from imputing\n        columns with the largest number of missing values to columns with\n        fewest number of missing values.\n\n    missing_values : np.nan, integer, optional (default = np.nan)\n        the placeholder for the missing values. all occurrences of\n        `missing_values` will be imputed.\n\n    copy : boolean, optional (default = true)\n        if true, a copy of x will be created. if false, imputation will\n        be done in-place whenever possible.\n\n    criterion : tuple, optional (default = ('mse', 'gini'))\n        the function to measure the quality of a split.the first element of\n        the tuple is for the random forest regressor (for imputing numerical\n        variables) while the second element is for the random forest\n        classifier (for imputing categorical variables).\n\n    n_estimators : integer, optional (default=100)\n        the number of trees in the forest.\n\n    max_depth : integer or none, optional (default=none)\n        the maximum depth of the tree. if none, then nodes are expanded until\n        all leaves are pure or until all leaves contain less than\n        min_samples_split samples.\n\n    min_samples_split : int, float, optional (default=2)\n        the minimum number of samples required to split an internal node:\n        - if int, then consider `min_samples_split` as the minimum number.\n        - if float, then `min_samples_split` is a fraction and\n          `ceil(min_samples_split * n_samples)` are the minimum\n          number of samples for each split.\n\n    min_samples_leaf : int, float, optional (default=1)\n        the minimum number of samples required to be at a leaf node.\n        a split point at any depth will only be considered if it leaves at\n        least ``min_samples_leaf`` training samples in each of the left and\n        right branches.  this may have the effect of smoothing the model,\n        especially in regression.\n        - if int, then consider `min_samples_leaf` as the minimum number.\n        - if float, then `min_samples_leaf` is a fraction and\n          `ceil(min_samples_leaf * n_samples)` are the minimum\n          number of samples for each node.\n\n    min_weight_fraction_leaf : float, optional (default=0.)\n        the minimum weighted fraction of the sum total of weights (of all\n        the input samples) required to be at a leaf node. samples have\n        equal weight when sample_weight is not provided.\n\n    max_features : int, float, string or none, optional (default=\"auto\")\n        the number of features to consider when looking for the best split:\n        - if int, then consider `max_features` features at each split.\n        - if float, then `max_features` is a fraction and\n          `int(max_features * n_features)` features are considered at each\n          split.\n        - if \"auto\", then `max_features=sqrt(n_features)`.\n        - if \"sqrt\", then `max_features=sqrt(n_features)` (same as \"auto\").\n        - if \"log2\", then `max_features=log2(n_features)`.\n        - if none, then `max_features=n_features`.\n        note: the search for a split does not stop until at least one\n        valid partition of the node samples is found, even if it requires to\n        effectively inspect more than ``max_features`` features.\n\n    max_leaf_nodes : int or none, optional (default=none)\n        grow trees with ``max_leaf_nodes`` in best-first fashion.\n        best nodes are defined as relative reduction in impurity.\n        if none then unlimited number of leaf nodes.\n\n    min_impurity_decrease : float, optional (default=0.)\n        a node will be split if this split induces a decrease of the impurity\n        greater than or equal to this value.\n        the weighted impurity decrease equation is the following::\n            n_t / n * (impurity - n_t_r / n_t * right_impurity\n                                - n_t_l / n_t * left_impurity)\n        where ``n`` is the total number of samples, ``n_t`` is the number of\n        samples at the current node, ``n_t_l`` is the number of samples in the\n        left child, and ``n_t_r`` is the number of samples in the right child.\n        ``n``, ``n_t``, ``n_t_r`` and ``n_t_l`` all refer to the weighted sum,\n        if ``sample_weight`` is passed.\n\n    bootstrap : boolean, optional (default=true)\n        whether bootstrap samples are used when building trees.\n\n    oob_score : bool (default=false)\n        whether to use out-of-bag samples to estimate\n        the generalization accuracy.\n\n    n_jobs : int or none, optional (default=none)\n        the number of jobs to run in parallel for both `fit` and `predict`.\n        ``none`` means 1 unless in a :obj:`joblib.parallel_backend` context.\n        ``-1`` means using all processors. see :term:`glossary <n_jobs>`\n        for more details.\n\n    random_state : int, randomstate instance or none, optional (default=none)\n        if int, random_state is the seed used by the random number generator;\n        if randomstate instance, random_state is the random number generator;\n        if none, the random number generator is the randomstate instance used\n        by `np.random`.\n\n    verbose : int, optional (default=0)\n        controls the verbosity when fitting and predicting.\n\n    warm_start : bool, optional (default=false)\n        when set to ``true``, reuse the solution of the previous call to fit\n        and add more estimators to the ensemble, otherwise, just fit a whole\n        new forest. see :term:`the glossary <warm_start>`.\n\n    class_weight : dict, list of dicts, \"balanced\", \"balanced_subsample\" or \\\n    none, optional (default=none)\n        weights associated with classes in the form ``{class_label: weight}``.\n        if not given, all classes are supposed to have weight one. for\n        multi-output problems, a list of dicts can be provided in the same\n        order as the columns of y.\n        note that for multioutput (including multilabel) weights should be\n        defined for each class of every column in its own dict. for example,\n        for four-class multilabel classification weights should be\n        [{0: 1, 1: 1}, {0: 1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of\n        [{1:1}, {2:5}, {3:1}, {4:1}].\n        the \"balanced\" mode uses the values of y to automatically adjust\n        weights inversely proportional to class frequencies in the input data\n        as ``n_samples / (n_classes * np.bincount(y))``\n        the \"balanced_subsample\" mode is the same as \"balanced\" except that\n        weights are computed based on the bootstrap sample for every tree\n        grown.\n        for multi-output, the weights of each column of y will be multiplied.\n        note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n        note: this parameter is only applicable for random forest classifier\n        objects (i.e., for categorical variables).\n\n    attributes\n    ----------\n    statistics_ : dictionary of length two\n        the first element is an array with the mean of each numerical feature\n        being imputed while the second element is an array of modes of\n        categorical features being imputed (if available, otherwise it\n        will be none).\n\n    methods\n    -------\n    fit(self, x, y=none, cat_vars=none):\n        fit the imputer on x.\n\n        parameters\n        ----------\n        x : {array-like}, shape (n_samples, n_features)\n            input data, where ``n_samples`` is the number of samples and\n            ``n_features`` is the number of features.\n\n        cat_vars : int or array of ints, optional (default = none)\n            an int or an array containing column indices of categorical\n            variable(s)/feature(s) present in the dataset x.\n            ``none`` if there are no categorical variables in the dataset.\n\n        returns\n        -------\n        self : object\n            returns self.\n\n\n    transform(x):\n        impute all missing values in x.\n\n        parameters\n        ----------\n        x : {array-like}, shape = [n_samples, n_features]\n            the input data to complete.\n\n        returns\n        -------\n        x : {array-like}, shape = [n_samples, n_features]\n            the imputed dataset.\n\n\n    fit_transform(x, y=none, **fit_params):\n        fit missforest and impute all missing values in x.\n\n        parameters\n        ----------\n        x : {array-like}, shape (n_samples, n_features)\n            input data, where ``n_samples`` is the number of samples and\n            ``n_features`` is the number of features.\n\n        returns\n        -------\n        x : {array-like}, shape (n_samples, n_features)\n            returns imputed dataset.\n\n### references\n\n* [1] stekhoven, daniel j., and peter b\u00fchlmann. \"missforest\u2014non-parametric\n  missing value imputation for mixed-type data.\" bioinformatics 28.1\n  (2011): 112-118.\n* [2] https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.randomforestregressor.html#sklearn.ensemble.randomforestregressor\n* [3] https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.randomforestclassifier.html#sklearn.ensemble.randomforestclassifier\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "missingpy",
  "package_url": "https://pypi.org/project/missingpy/",
  "project_url": "https://pypi.org/project/missingpy/",
  "project_urls": {
    "Homepage": "https://github.com/epsilon-machine/missingpy"
  },
  "release_url": "https://pypi.org/project/missingpy/0.2.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "missing data imputation for python",
  "version": "0.2.0",
  "releases": [],
  "developers": [
    "ashim_bhattarai"
  ],
  "kwds": "missingpy imputation missing_values n_cat_missing knn",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_missingpy",
  "homepage": "https://github.com/epsilon-machine/missingpy",
  "release_count": 4,
  "dependency_ids": []
}