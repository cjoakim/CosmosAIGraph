{
  "classifiers": [
    "license :: other/proprietary license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# tempo - time series utilities for data teams using databricks\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/databrickslabs/tempo/master/tempo%20-%20light%20background.svg\" width=\"300px\"/>\n</p>\n\n## project description\nthe purpose of this project is to make time series manipulation with spark simpler. operations covered under this package include as of joins, rolling statistics with user-specified window lengths, featurization of time series using lagged values, and delta lake optimization on time and partition fields.\n\n[![image](https://github.com/databrickslabs/tempo/workflows/build/badge.svg)](https://github.com/databrickslabs/tempo/actions?query=workflow%3abuild)\n[![codecov](https://codecov.io/gh/databrickslabs/tempo/branch/master/graph/badge.svg)](https://codecov.io/gh/databrickslabs/tempo)\n[![downloads](https://pepy.tech/badge/dbl-tempo/month)](https://pepy.tech/project/dbl-tempo)\n[![docs](https://github.com/databrickslabs/tempo/actions/workflows/docs.yml/badge.svg)](https://databrickslabs.github.io/tempo/)\n\n## [tempo project documentation](https://databrickslabs.github.io/tempo/)\n\n## using the project\n\npython - pip install in databricks notebooks using:\n\n```shell\n%pip install dbl-tempo\n```\n\ninstall locally using: \n\n```shell\npip install dbl-tempo\n```\n\n\n### starting point: tsdf object, a wrapper over a spark data frame\nthe entry point into all features for time series analysis in tempo is a tsdf object which wraps the spark data frame. at a high level, a tsdf contains a data frame which contains many smaller time series, one per partition key. in order to create a tsdf object, a distinguished timestamp column much be provided in order for sorting purposes for public methods. optionally, a sequence number and partition columns can be provided as the assumptive columns on which to create new features from. below are the public methods available for tsdf transformation and enrichment.\n\n#### sample reference architecture for capital markets\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/databrickslabs/tempo/master/ts_in_fs.png\" width=\"700px\"/>\n</p>\n\n## quickstart - python \n\ndata source is uci public accelerometer data available at this url https://archive.ics.uci.edu/ml/datasets/heterogeneity+activity+recognition\n\n#### 0. read in data and display it \n\n```python\nfrom pyspark.sql.functions import * \n\nphone_accel_df = spark.read.format(\"csv\").option(\"header\", \"true\").load(\"dbfs:/home/tempo/phones_accelerometer\").withcolumn(\"event_ts\", (col(\"arrival_time\").cast(\"double\")/1000).cast(\"timestamp\")).withcolumn(\"x\", col(\"x\").cast(\"double\")).withcolumn(\"y\", col(\"y\").cast(\"double\")).withcolumn(\"z\", col(\"z\").cast(\"double\")).withcolumn(\"event_ts_dbl\", col(\"event_ts\").cast(\"double\"))\n\nfrom tempo import * \n\nphone_accel_tsdf = tsdf(phone_accel_df, ts_col=\"event_ts\", partition_cols = [\"user\"])\n\ndisplay(phone_accel_tsdf)\n```\n\n#### 1. resample and visualize\n\n###### sample usage: \npossible values for frequency include patterns such as 1 minute, 4 hours, 2 days or simply sec, min, day. for the accepted functions to aggregate data, options are 'floor', 'ceil', 'min', 'max', 'mean'. custom functions will be available in a future release.\n\nnote: you can upsample any missing values by using an option in the resample interface (fill = true)\n\n```python\n# ts_col = timestamp column on which to sort fact and source table\n# partition_cols - columns to use for partitioning the tsdf into more granular time series for windowing and sorting\n\nresampled_sdf = phone_accel_tsdf.resample(freq='min', func='floor')\nresampled_pdf = resampled_sdf.df.filter(col('event_ts').cast(\"date\") == \"2015-02-23\").topandas()\n\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport pandas as pd\n\n# plotly figure 1\nfig = px.line(resampled_pdf, x='event_ts', y='z',\n              color=\"user\",\n              line_group=\"user\", hover_name=\"user\")\nfig.update_layout(title='phone accelerometer usage' , showlegend=false)\n\nfig.show()\n```\n\n#### 2. as of join \n##### this join uses windowing in order to select the latest record from a source table and merges this onto the base fact table\n\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/databrickslabs/tempo/master/as_of_join.png\" width=\"700px\"/>\n</p>\n\n\n```python\nfrom pyspark.sql.functions import * \n\nwatch_accel_df = spark.read.format(\"csv\").option(\"header\", \"true\").load(\"dbfs:/home/tempo/watch_accelerometer\").withcolumn(\"event_ts\", (col(\"arrival_time\").cast(\"double\")/1000).cast(\"timestamp\")).withcolumn(\"x\", col(\"x\").cast(\"double\")).withcolumn(\"y\", col(\"y\").cast(\"double\")).withcolumn(\"z\", col(\"z\").cast(\"double\")).withcolumn(\"event_ts_dbl\", col(\"event_ts\").cast(\"double\"))\n\nwatch_accel_tsdf = tsdf(watch_accel_df, ts_col=\"event_ts\", partition_cols = [\"user\"])\n\n# applying as of join to tsdf datasets\njoined_df = watch_accel_tsdf.asofjoin(phone_accel_tsdf, right_prefix=\"phone_accel\")\n\ndisplay(joined_df)\n```\n\n#### 3. skew join optimized as of join\n\nthe purpose of the skew optimized as of join is to bucket each set of `partition_cols` to get the latest source record merged onto the fact table\n\nparameters: \n\nts_col = timestamp column for sorting \npartition_cols = partition columns for defining granular time series for windowing and sorting\ntspartitionval = value to break up each partition into time brackets\nfraction = overlap fraction\nright_prefix = prefix used for source columns when merged into fact table\n\n```python\njoined_df = watch_accel_tsdf.asofjoin(phone_accel_tsdf, right_prefix=\"watch_accel\", tspartitionval = 10, fraction = 0.1)\ndisplay(joined_df)\n```\n\n#### 4 - approximate exponential moving average\n\nthe approximate exponential moving average uses an approximation of the form `ema = e * lag(col,0) + e * (1 - e) * lag(col, 1) + e * (1 - e)^2 * lag(col, 2) ` to define a rolling moving average based on exponential decay.\n\nparameters: \n\nwindow = number of lagged values to compute for moving average\n\n```python\nema_trades = watch_accel_tsdf.ema(\"x\", window = 50)\ndisplay(ema_trades)\n```\n\n#### 5 - simple moving average\n\nmethod for computing rolling statistics based on the distinguished timestamp column \n\nparameters: \n\nrangebackwindowsecs = number of seconds to look back\n\n```python\nmoving_avg = watch_accel_tsdf.withrangestats(\"y\", rangebackwindowsecs=600)\nmoving_avg.select('event_ts', 'x', 'y', 'z', 'mean_y').show(10, false)\n```\n\n#### 6 - fourier transform\n\nmethod for transforming the time series to frequency domain based on the distinguished data column \n\nparameters: \n\ntimestep = timestep value to be used for getting the frequency scale\n\nvaluecol = name of the time domain data column which will be transformed\n\n```python\nft_df = tsdf.fourier_transform(timestep=1, valuecol=\"data_col\")\ndisplay(ft_df)\n```\n\n#### 7- interpolation\ninterpolate a series to fill in missing values using a specified function. the following interpolation methods are supported: \n\n- zero fill : `zero`\n- null fill: `null`\n- backwards fill: `bfill`\n- forwards fill: `ffill`\n- linear fill: `linear`\n\nthe `interpolate` method can either be use in conjunction with `resample` or independently.\n\nif `interpolate` is not chained after a `resample` operation, the method automatically first re-samples the input dataset into a given frequency, then performs interpolation on the sampled time-series dataset.\n\npossible values for frequency include patterns such as 1 minute, 4 hours, 2 days or simply sec, min, day. for the accepted functions to aggregate data, options are 'floor', 'ceil', 'min', 'max', 'mean'. \n\n`null` values after re-sampling are treated the same as missing values. ability to specify `null` as a valid value is currently not supported.\n\nvalid columns data types for interpolation are: `[\"int\", \"bigint\", \"float\", \"double\"]`.\n\n```python\n# create instance of the tsdf class\ninput_tsdf = tsdf(\n            input_df,\n            partition_cols=[\"partition_a\", \"partition_b\"],\n            ts_col=\"event_ts\",\n        )\n\n\n# what the following chain of operation does is:\n# 1. aggregate all valid numeric columns using mean into 30 second intervals\n# 2. interpolate any missing intervals or null values using linear fill\n# note: when chaining interpolate after a resample, there is no need to provide a freq or func parameter. only method is required.\ninterpolated_tsdf = input_tsdf.resample(freq=\"30 seconds\", func=\"mean\").interpolate(\n    method=\"linear\"\n)\n\n# what the following interpolation method does is:\n# 1. aggregate columna and columnbn  using mean into 30 second intervals\n# 2. interpolate any missing intervals or null values using linear fill\ninterpolated_tsdf = input_tsdf.interpolate(\n    freq=\"30 seconds\",\n    func=\"mean\",\n    target_cols= [\"columna\",\"columnb\"],\n    method=\"linear\"\n\n)\n\n# alternatively it's also possible to override default tsdf parameters.\n# e.g. partition_cols, ts_col a\ninterpolated_tsdf = input_tsdf.interpolate(\n    partition_cols=[\"partition_c\"],\n    ts_col=\"other_event_ts\"\n    freq=\"30 seconds\",\n    func=\"mean\",\n    target_cols= [\"columna\",\"columnb\"],\n    method=\"linear\"\n)\n\n# the show_interpolated flag can be set to `true` to show additional boolean columns \n# for a given row that shows if a column has been interpolated.\ninterpolated_tsdf = input_tsdf.interpolate(\n    partition_cols=[\"partition_c\"],\n    ts_col=\"other_event_ts\"\n    freq=\"30 seconds\",\n    func=\"mean\",\n    method=\"linear\",\n    target_cols= [\"columna\",\"columnb\"],\n    show_interpolated=true,\n)\n\n```\n\n#### 8 - grouped stats by frequency\n\ngroup by partition columns and a frequency to get the minimum, maximum, count, mean, standard deviation, and sum for all or some subset of numeric columns.\n\n###### parameters: \n\n`freq` = (required) frequency at which the grouping should take place - acceptable parameters are strings of the form \"1 minute\", \"40 seconds\", etc.\n\n`metriccols` = (optional) list of columns to compute metrics for. these should be numeric columns. if this is not supplied, this method will compute stats on all numeric columns in the tsdf\n\n```python\ngrouped_stats = watch_accel_tsdf.withgroupedstats(metriccols = [\"y\"], freq=\"1 minute\")\ndisplay(grouped_stats)\n```\n\n\n## project support\nplease note that all projects in the /databrickslabs github account are provided for your exploration only, and are not formally supported by databricks with service level agreements (slas).  they are provided as-is and we do not make any guarantees of any kind.  please do not submit a support ticket relating to any issues arising from the use of these projects.\n\nany issues discovered through the use of this project should be filed as github issues on the repo.  they will be reviewed as time permits, but there are no formal slas for support.\n\n## project setup\nafter cloning the repo, it is highly advised that you create a [virtual environment](https://docs.python.org/3/library/venv.html) to isolate and manage\npackages for this project, like so:\n\n`python -m venv <path to project root>/venv`\n\nthen, install the required modules via pip:\n\n`pip install -r requirements.txt`\n\n## building the project\nonce in the main project folder, build into a wheel using the following command: \n\n`python setup.py bdist_wheel`\n\n## releasing the project\ninstructions for how to release a version of the project\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "dbl-tempo",
  "package_url": "https://pypi.org/project/dbl-tempo/",
  "project_url": "https://pypi.org/project/dbl-tempo/",
  "project_urls": {
    "Homepage": "https://databrickslabs.github.io/tempo/"
  },
  "release_url": "https://pypi.org/project/dbl-tempo/0.1.26/",
  "requires_dist": [
    "ipython",
    "pandas",
    "scipy",
    "pytest ; extra == 'tests'"
  ],
  "requires_python": "",
  "summary": "spark time series utility package",
  "version": "0.1.26",
  "releases": [],
  "developers": [
    "labs@databricks.com",
    "ricardo_portilla"
  ],
  "kwds": "databrickslabs databricks pyspark spark tempo",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_dbl_tempo",
  "homepage": "https://databrickslabs.github.io/tempo/",
  "release_count": 27,
  "dependency_ids": [
    "pypi_ipython",
    "pypi_pandas",
    "pypi_pytest",
    "pypi_scipy"
  ]
}