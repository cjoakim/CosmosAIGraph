{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "topic :: internet :: www/http :: dynamic content",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# tabulator-py\n\n[![travis](https://img.shields.io/travis/frictionlessdata/tabulator-py/master.svg)](https://travis-ci.org/frictionlessdata/tabulator-py)\n[![coveralls](http://img.shields.io/coveralls/frictionlessdata/tabulator-py.svg?branch=master)](https://coveralls.io/r/frictionlessdata/tabulator-py?branch=master)\n[![pypi](https://img.shields.io/pypi/v/tabulator.svg)](https://pypi.python.org/pypi/tabulator)\n[![github](https://img.shields.io/badge/github-master-brightgreen)](https://github.com/frictionlessdata/tabulator-py)\n[![gitter](https://img.shields.io/gitter/room/frictionlessdata/chat.svg)](https://gitter.im/frictionlessdata/chat)\n\na library for reading and writing tabular data (csv/xls/json/etc).\n\n> **[important notice]** we have released [frictionless framework](https://github.com/frictionlessdata/frictionless-py). this framework is logical continuation of `tabulator` that was extended to be a complete data solution. the change in not breaking for the existing software so no actions are required. please read the [migration guide](https://framework.frictionlessdata.io/docs/development/migration) from `tabulator` to frictionless framework.\n> - we continue to bug-fix `tabulator@1.x` in this [repository](https://github.com/frictionlessdata/tabulator-py) as well as it's available on [pypi](https://pypi.org/project/tabulator/) as it was before\n> - please note that `frictionless@3.x` version's api, we're working on at the moment, is not stable\n> - we will release `frictionless@4.x` by the end of 2020 to be the first semver/stable version\n\n## features\n\n- **supports most common tabular formats**: csv, xls, ods, json, google sheets, sql, and others. see complete list [below](#supported-file-formats).\n- **loads local and remote data**: supports http, ftp and s3.\n- **low memory usage**: only the current row is kept in memory, so you can\n  large datasets.\n- **supports compressed files**: using zip or gzip algorithms.\n- **extensible**: you can add support for custom file formats and loaders (e.g.\n  ftp).\n\n## contents\n\n<!--toc-->\n\n  - [getting started](#getting-started)\n    - [installation](#installation)\n    - [running on cli](#running-on-cli)\n    - [running on python](#running-on-python)\n  - [documentation](#documentation)\n    - [working with stream](#working-with-stream)\n    - [supported schemes](#supported-schemes)\n    - [supported file formats](#supported-file-formats)\n    - [custom file sources and formats](#custom-file-sources-and-formats)\n  - [api reference](#api-reference)\n    - [`cli`](#cli)\n    - [`stream`](#stream)\n    - [`loader`](#loader)\n    - [`parser`](#parser)\n    - [`writer`](#writer)\n    - [`validate`](#validate)\n    - [`tabulatorexception`](#tabulatorexception)\n    - [`sourceerror`](#sourceerror)\n    - [`schemeerror`](#schemeerror)\n    - [`formaterror`](#formaterror)\n    - [`encodingerror`](#encodingerror)\n    - [`compressionerror`](#compressionerror)\n    - [`ioerror`](#ioerror)\n    - [`loadingerror`](#loadingerror)\n    - [`httperror`](#httperror)\n  - [contributing](#contributing)\n  - [changelog](#changelog)\n\n<!--toc-->\n\n## getting started\n\n### installation\n\n```bash\n$ pip install tabulator\n```\n\n### running on cli\n\ntabulator ships with a simple cli called `tabulator` to read tabular data. for\nexample:\n\n```bash\n$ tabulator https://github.com/frictionlessdata/tabulator-py/raw/4c1b3943ac98be87b551d87a777d0f7ca4904701/data/table.csv.gz\nid,name\n1,english\n2,\u4e2d\u56fd\u4eba\n```\n\nyou can see all supported options by running `tabulator --help`.\n\n### running on python\n\n```python\nfrom tabulator import stream\n\nwith stream('data.csv', headers=1) as stream:\n    stream.headers # [header1, header2, ..]\n    for row in stream:\n        print(row)  # [value1, value2, ..]\n```\n\nyou can find other examples in the [examples][examples-dir] directory.\n\n## documentation\n\nin the following sections, we'll walk through some usage examples of\nthis library. all examples were tested with python 3.6, but should\nrun fine with python 3.3+.\n\n### working with stream\n\nthe `stream` class represents a tabular stream. it takes the file path as the\n`source` argument. for example:\n\n```\n<scheme>://path/to/file.<format>\n```\n\nit uses this path to determine the file format (e.g. csv or xls) and scheme\n(e.g. http or postgresql). it also supports format extraction from urls like `http://example.com?format=csv`. if necessary, you also can define these explicitly.\n\nlet's try it out. first, we create a `stream` object passing the path to a csv file.\n\n```python\nimport tabulator\n\nstream = tabulator.stream('data.csv')\n```\n\nat this point, the file haven't been read yet. let's open the stream so we can\nread the contents.\n\n```python\ntry:\n    stream.open()\nexcept tabulator.tabulatorexception as e:\n    pass  # handle exception\n```\n\nthis will open the underlying data stream, read a small sample to detect the\nfile encoding, and prepare the data to be read. we catch\n`tabulator.tabulatorexception` here, in case something goes wrong.\n\nwe can now read the file contents. to iterate over each row, we do:\n\n```python\nfor row in stream.iter():\n    print(row)  # [value1, value2, ...]\n```\n\nthe `stream.iter()` method will return each row data as a list of values. if\nyou prefer, you could call `stream.iter(keyed=true)` instead, which returns a\ndictionary with the column names as keys. either way, this method keeps only a\nsingle row in memory at a time. this means it can handle handle large files\nwithout consuming too much memory.\n\nif you want to read the entire file, use `stream.read()`. it accepts the same\narguments as `stream.iter()`, but returns all rows at once.\n\n```python\nstream.reset()\nrows = stream.read()\n```\n\nnotice that we called `stream.reset()` before reading the rows. this is because\ninternally, tabulator only keeps a pointer to its current location in the file.\nif we didn't reset this pointer, we would read starting from where we stopped.\nfor example, if we ran `stream.read()` again, we would get an empty list, as\nthe internal file pointer is at the end of the file (because we've already read\nit all). depending on the file location, it might be necessary to download the\nfile again to rewind (e.g. when the file was loaded from the web).\n\nafter we're done, close the stream with:\n\n```python\nstream.close()\n```\n\nthe entire example looks like:\n\n```python\nimport tabulator\n\nstream = tabulator.stream('data.csv')\ntry:\n    stream.open()\nexcept tabulator.tabulatorexception as e:\n    pass  # handle exception\n\nfor row in stream.iter():\n    print(row)  # [value1, value2, ...]\n\nstream.reset()  # rewind internal file pointer\nrows = stream.read()\n\nstream.close()\n```\n\nit could be rewritten to use python's context manager interface as:\n\n```python\nimport tabulator\n\ntry:\n    with tabulator.stream('data.csv') as stream:\n        for row in stream.iter():\n            print(row)\n\n        stream.reset()\n        rows = stream.read()\nexcept tabulator.tabulatorexception as e:\n    pass\n```\n\nthis is the preferred way, as python closes the stream automatically, even if some exception was thrown along the way.\n\nthe full api documentation is available as docstrings in the [stream source code][stream.py].\n\n#### headers\n\nby default, tabulator considers that all file rows are values (i.e. there is no\nheader).\n\n```python\nwith stream([['name', 'age'], ['alex', 21]]) as stream:\n  stream.headers # none\n  stream.read() # [['name', 'age'], ['alex', 21]]\n```\n\nif you have a header row, you can use the `headers` argument with the its row\nnumber (starting from 1).\n\n```python\n# integer\nwith stream([['name', 'age'], ['alex', 21]], headers=1) as stream:\n  stream.headers # ['name', 'age']\n  stream.read() # [['alex', 21]]\n```\n\nyou can also pass a lists of strings to define the headers explicitly:\n\n```python\nwith stream([['alex', 21]], headers=['name', 'age']) as stream:\n  stream.headers # ['name', 'age']\n  stream.read() # [['alex', 21]]\n```\n\ntabulator also supports multiline headers for the `xls` and `xlsx` formats.\n\n```python\nwith stream('data.xlsx', headers=[1, 3], fill_merged_cells=true) as stream:\n  stream.headers # ['header from row 1-3']\n  stream.read() # [['value1', 'value2', 'value3']]\n```\n\n#### encoding\n\nyou can specify the file encoding (e.g. `utf-8` and `latin1`) via the `encoding`\nargument.\n\n```python\nwith stream(source, encoding='latin1') as stream:\n  stream.read()\n```\n\nif this argument isn't set, tabulator will try to infer it from the data. if you\nget a `unicodedecodeerror` while loading a file, try setting the encoding to\n`utf-8`.\n\n#### compression (python3-only)\n\ntabulator supports both zip and gzip compression methods. by default it'll infer from the file name:\n\n```python\nwith stream('http://example.com/data.csv.zip') as stream:\n  stream.read()\n```\n\nyou can also set it explicitly:\n\n```python\nwith stream('data.csv.ext', compression='gz') as stream:\n  stream.read()\n```\n**options**\n\n- **filename**: filename in zip file to process (default is first file)\n\n#### allow html\n\nthe `stream` class raises `tabulator.exceptions.formaterror` if it detects html\ncontents. this helps avoiding the relatively common mistake of trying to load a\ncsv file inside an html page, for example on github.\n\nyou can disable this behaviour using the `allow_html` option:\n\n```python\nwith stream(source_with_html, allow_html=true) as stream:\n  stream.read() # no exception on open\n```\n\n#### sample size\n\nto detect the file's headers, and run other checks like validating that the file\ndoesn't contain html, tabulator reads a sample of rows on the `stream.open()`\nmethod. this data is available via the `stream.sample` property. the number of\nrows used can be defined via the `sample_size` parameters (defaults to 100).\n\n```python\nwith stream(two_rows_source, sample_size=1) as stream:\n  stream.sample # only first row\n  stream.read() # first and second rows\n```\n\nyou can disable this by setting `sample_size` to zero. this way, no data will be\nread on `stream.open()`.\n\n#### bytes sample size\n\ntabulator needs to read a part of the file to infer its encoding. the\n`bytes_sample_size` arguments controls how many bytes will be read for this\ndetection (defaults to 10000).\n\n```python\nsource = 'data/special/latin1.csv'\nwith stream(source) as stream:\n    stream.encoding # 'iso8859-2'\n```\n\nyou can disable this by setting `bytes_sample_size` to zero, in which case it'll\nuse the machine locale's default encoding.\n\n#### ignore blank headers\n\nwhen `true`, tabulator will ignore columns that have blank headers (defaults to\n`false`).\n\n```python\n# default behaviour\nsource = 'text://header1,,header3\\nvalue1,value2,value3'\nwith stream(source, format='csv', headers=1) as stream:\n    stream.headers # ['header1', '', 'header3']\n    stream.read(keyed=true) # {'header1': 'value1', '': 'value2', 'header3': 'value3'}\n\n# ignoring columns with blank headers\nsource = 'text://header1,,header3\\nvalue1,value2,value3'\nwith stream(source, format='csv', headers=1, ignore_blank_headers=true) as stream:\n    stream.headers # ['header1', 'header3']\n    stream.read(keyed=true) # {'header1': 'value1', 'header3': 'value3'}\n```\n\n#### ignore listed/not-listed headers\n\nthe option is similar to the `ignore_blank_headers`. it removes arbitrary columns from the data based on the corresponding column names:\n\n```python\n# ignore listed headers (omit columns)\nsource = 'text://header1,header2,header3\\nvalue1,value2,value3'\nwith stream(source, format='csv', headers=1, ignore_listed_headers=['header2']) as stream:\n    assert stream.headers == ['header1', 'header3']\n    assert stream.read(keyed=true) == [\n        {'header1': 'value1', 'header3': 'value3'},\n    ]\n\n# ignore not listed headers (pick colums)\nsource = 'text://header1,header2,header3\\nvalue1,value2,value3'\nwith stream(source, format='csv', headers=1, ignore_not_listed_headers=['header2']) as stream:\n    assert stream.headers == ['header2']\n    assert stream.read(keyed=true) == [\n        {'header2': 'value2'},\n    ]\n```\n\n#### force strings\n\nwhen `true`, all rows' values will be converted to strings (defaults to\n`false`). `none` values will be converted to empty strings.\n\n```python\n# default behaviour\nwith stream([['string', 1, datetime.datetime(2017, 12, 1, 17, 00)]]) as stream:\n  stream.read() # [['string', 1, datetime.dateime(2017, 12, 1, 17, 00)]]\n\n# forcing rows' values as strings\nwith stream([['string', 1]], force_strings=true) as stream:\n  stream.read() # [['string', '1', '2017-12-01 17:00:00']]\n```\n\n#### force parse\n\nwhen `true`, don't raise an exception when parsing a malformed row, but simply\nreturn an empty row. otherwise, tabulator raises\n`tabulator.exceptions.sourceerror` when a row can't be parsed. defaults to `false`.\n\n```python\n# default behaviour\nwith stream([[1], 'bad', [3]]) as stream:\n  stream.read() # raises tabulator.exceptions.sourceerror\n\n# with force_parse\nwith stream([[1], 'bad', [3]], force_parse=true) as stream:\n  stream.read() # [[1], [], [3]]\n```\n\n#### skip rows\n\nlist of row numbers and/or strings to skip.\nif it's a string, all rows that begin with it will be skipped (e.g. '#' and '//').\nif it's the empty string, all rows that begin with an empty column will be skipped.\n\n```python\nsource = [['john', 1], ['alex', 2], ['#sam', 3], ['mike', 4], ['john', 5]]\nwith stream(source, skip_rows=[1, 2, -1, '#']) as stream:\n  stream.read() # [['mike', 4]]\n```\n\nif the `headers` parameter is also set to be an integer, it will use the first not skipped row as a headers.\n\n```python\nsource = [['#comment'], ['name', 'order'], ['john', 1], ['alex', 2]]\nwith stream(source, headers=1, skip_rows=['#']) as stream:\n  stream.headers # [['name', 'order']]\n  stream.read() # [['jogn', 1], ['alex', 2]]\n```\n\n#### post parse\n\nlist of functions that can filter or transform rows after they are parsed. these\nfunctions receive the `extended_rows` containing the row's number, headers\nlist, and the row values list. they then process the rows, and yield or discard\nthem, modified or not.\n\n```python\ndef skip_odd_rows(extended_rows):\n    for row_number, headers, row in extended_rows:\n        if not row_number % 2:\n            yield (row_number, headers, row)\n\ndef multiply_by_two(extended_rows):\n    for row_number, headers, row in extended_rows:\n        doubled_row = list(map(lambda value: value * 2, row))\n        yield (row_number, headers, doubled_row)\n\nrows = [\n  [1],\n  [2],\n  [3],\n  [4],\n]\nwith stream(rows, post_parse=[skip_odd_rows, multiply_by_two]) as stream:\n  stream.read() # [[4], [8]]\n```\n\nthese functions are applied in order, as a simple data pipeline. in the example\nabove, `multiply_by_two` just sees the rows yielded by `skip_odd_rows`.\n\n#### keyed and extended rows\n\nthe methods `stream.iter()` and `stream.read()` accept the `keyed` and\n`extended` flag arguments to modify how the rows are returned.\n\nby default, every row is returned as a list of its cells values:\n\n```python\nwith stream([['name', 'age'], ['alex', 21]]) as stream:\n  stream.read() # [['alex', 21]]\n```\n\nwith `keyed=true`, the rows are returned as dictionaries, mapping the column names to their values in the row:\n\n```python\nwith stream([['name', 'age'], ['alex', 21]]) as stream:\n  stream.read(keyed=true) # [{'name': 'alex', 'age': 21}]\n```\n\nand with `extended=true`, the rows are returned as a tuple of `(row_number,\nheaders, row)`, there `row_number` is the current row number (starting from 1),\n`headers` is a list with the headers names, and `row` is a list with the rows\nvalues:\n\n```python\nwith stream([['name', 'age'], ['alex', 21]]) as stream:\n  stream.read(extended=true) # (1, ['name', 'age'], ['alex', 21])\n```\n\n### supported schemes\n\n#### s3\n\nit loads data from aws s3. for private files you should provide credentials supported by the `boto3` library, for example, corresponding environment variables. read more about [configuring `boto3`](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html).\n\n```python\nstream = stream('s3://bucket/data.csv')\n```\n\n**options**\n\n- **s3\\_endpoint\\_url** - the endpoint url to use. by default it's `https://s3.amazonaws.com`. for complex use cases, for example, `goodtables`'s runs on a data package this option can be provided as an environment variable `s3_endpoint_url`.\n\n#### file\n\nthe default scheme, a file in the local filesystem.\n\n```python\nstream = stream('data.csv')\n```\n\n#### http/https/ftp/ftps\n\n> in python 2, `tabulator` can't stream remote data sources because of a limitation in the underlying libraries. the whole data source will be loaded to the memory. in python 3 there is no such problem and remote files are streamed.\n\n```python\nstream = stream('https://example.com/data.csv')\n```\n\n**options**\n\n- **http\\_session** - a `requests.session` object. read more in the [requests docs][requests-session].\n- **http\\_stream** - enables or disables http streaming, when possible (enabled by default). disable it if you'd like to preload the whole file into memory.\n- **http\\_timeout** - this timeout will be used for a `requests` session construction.\n\n#### stream\n\nthe source is a file-like python object.\n\n\n```python\nwith open('data.csv') as fp:\n    stream = stream(fp)\n```\n\n#### text\n\nthe source is a string containing the tabular data. both `scheme` and `format`\nmust be set explicitly, as it's not possible to infer them.\n\n```python\nstream = stream(\n    'name,age\\njohn, 21\\n',\n    scheme='text',\n    format='csv'\n)\n```\n\n### supported file formats\n\nin this section, we'll describe the supported file formats, and their respective\nconfiguration options and operations. some formats only support read operations,\nwhile others support both reading and writing.\n\n#### csv (read & write)\n\n```python\nstream = stream('data.csv', delimiter=',')\n```\n\n**options**\n\nit supports all options from the python csv library. check [their\ndocumentation][pydoc-csv] for more information.\n\n#### xls/xlsx (read & write)\n\n> tabulator is unable to stream `xls` files, so the entire file is loaded in\n> memory. streaming is supported for `xlsx` files.\n\n```python\nstream = stream('data.xls', sheet=1)\n```\n\n**options**\n\n- **sheet**: sheet name or number (starting from 1).\n- **workbook_cache**: an empty dictionary to handle workbook caching. if provided, `tabulator` will fill the dictionary with `source: tmpfile_path` pairs for remote workbooks. each workbook will be downloaded only once and all the temporary files will be deleted on the process exit. defauts: none\n- **fill_merged_cells**: if `true` it will unmerge and fill all merged cells by\n  a visible value. with this option enabled the parser can't stream data and\n  load the whole document into memory.\n- **preserve_formatting**: if `true` it will try to preserve text formatting of numeric and temporal cells returning it as strings according to how it looks in a spreadsheet (experimetal)\n- **adjust_floating_point_error**: if `true` it will correct the excel behaviour regarding floating point numbers\n\n#### ods (read only)\n\n> this format is not included to package by default. to use it please install `tabulator` with an `ods` extras: `$ pip install tabulator[ods]`\n\nsource should be a valid open office document.\n\n```python\nstream = stream('data.ods', sheet=1)\n```\n\n**options**\n\n- **sheet**: sheet name or number (starting from 1)\n\n#### gsheet (read only)\n\na publicly-accessible google spreadsheet.\n\n```python\nstream = stream('https://docs.google.com/spreadsheets/d/<id>?usp=sharing')\nstream = stream('https://docs.google.com/spreadsheets/d/<id>edit#gid=<gid>')\n```\n\n#### sql (read & write)\n\nany database url supported by [sqlalchemy][sqlalchemy].\n\n```python\nstream = stream('postgresql://name:pass@host:5432/database', table='data')\n```\n\n**options**\n\n- **table (required)**: database table name\n- **order_by**: sql expression for row ordering (e.g. `name desc`)\n\n#### data package (read only)\n\n> this format is not included to package by default. you can enable it by\n> installing tabulator using `pip install tabulator[datapackage]`.\n\na [tabular data package][tdp].\n\n```python\nstream = stream('datapackage.json', resource=1)\n```\n\n**options**\n\n- **resource**: resource name or index (starting from 0)\n\n#### inline (read only)\n\neither a list of lists, or a list of dicts mapping the column names to their\nrespective values.\n\n```python\nstream = stream([['name', 'age'], ['john', 21], ['alex', 33]])\nstream = stream([{'name': 'john', 'age': 21}, {'name': 'alex', 'age': 33}])\n```\n\n#### json (read & write)\n\njson document containing a list of lists, or a list of dicts mapping the column\nnames to their respective values (see the `inline` format for an example).\n\n```python\nstream = stream('data.json', property='key1.key2')\n```\n\n**options**\n\n- **property**: json path to the property containing the tabular data. for example, considering the json `{\"response\": {\"data\": [...]}}`, the `property` should be set to `response.data`.\n- **keyed** (write): save as array of arrays (default) or as array of dicts (keyed).\n\n#### ndjson (read only)\n\n```python\nstream = stream('data.ndjson')\n```\n\n#### tsv (read only)\n\n```python\nstream = stream('data.tsv')\n```\n\n#### html (read only)\n\n\n> this format is not included to package by default. to use it please install `tabulator` with the `html` extra: `$ pip install tabulator[html]`\n\nan html table element residing inside an html document.\n\nsupports simple tables (no merged cells) with any legal combination of the td, th, tbody & thead elements.\n\nusually `foramt='html'` would need to be specified explicitly as web urls don't always use the `.html` extension.\n\n```python\nstream = stream('http://example.com/some/page.aspx', format='html' selector='.content .data table#id1', raw_html=true)\n```\n\n**options**\n\n- **selector**: css selector for specifying which `table` element to extract. by default it's `table`, which takes the first `table` element in the document. if empty, will assume the entire page is the table to be extracted (useful with some excel formats).\n\n- **raw_html**: false (default) to extract the textual contents of each cell. true to return the inner html without modification.\n\n### custom file sources and formats\n\ntabulator is written with extensibility in mind, allowing you to add support for\nnew tabular file formats, schemes (e.g. ssh), and writers (e.g. mongodb). there\nare three components that allow this:\n\n* loaders\n  * loads a stream from some location (e.g. ssh)\n* parsers\n  * parses a stream of tabular data in some format (e.g. xls)\n* writers\n  * writes tabular data to some destination (e.g. mongodb)\n\nin this section, we'll see how to write custom classes to extend any of these components.\n\n#### custom loaders\n\nyou can add support for a new scheme (e.g. ssh) by creating a custom loader.\ncustom loaders are implemented by inheriting from the `loader` class, and\nimplementing its methods. this loader can then be used by `stream` to load data\nby passing it via the `custom_loaders={'scheme': customloader}` argument.\n\nthe skeleton of a custom loader looks like:\n\n```python\nfrom tabulator import loader\n\nclass customloader(loader):\n  options = []\n\n  def __init__(self, bytes_sample_size, **options):\n      pass\n\n  def load(self, source, mode='t', encoding=none):\n      # load logic\n\nwith stream(source, custom_loaders={'custom': customloader}) as stream:\n  stream.read()\n```\n\nyou can see examples of how the loaders are implemented by looking in the\n`tabulator.loaders` module.\n\n#### custom parsers\n\nyou can add support for a new file format by creating a custom parser. similarly\nto custom loaders, custom parsers are implemented by inheriting from the\n`parser` class, and implementing its methods. this parser can then be used by\n`stream` to parse data by passing it via the `custom_parsers={'format':\ncustomparser}` argument.\n\nthe skeleton of a custom parser looks like:\n\n```python\nfrom tabulator import parser\n\nclass customparser(parser):\n    options = []\n\n    def __init__(self, loader, force_parse, **options):\n        self.__loader = loader\n\n    def open(self, source, encoding=none):\n        # open logic\n\n    def close(self):\n        # close logic\n\n    def reset(self):\n        # reset logic\n\n    @property\n    def closed(self):\n        return false\n\n    @property\n    def extended_rows(self):\n        # extended rows logic\n\nwith stream(source, custom_parsers={'custom': customparser}) as stream:\n  stream.read()\n```\n\nyou can see examples of how parsers are implemented by looking in the\n`tabulator.parsers` module.\n\n#### custom writers\n\nyou can add support to write files in a specific format by creating a custom\nwriter. the custom writers are implemented by inheriting from the base `writer`\nclass, and implementing its methods. this writer can then be used by `stream` to\nwrite data via the `custom_writers={'format': customwriter}` argument.\n\nthe skeleton of a custom writer looks like:\n\n```python\nfrom tabulator import writer\n\nclass customwriter(writer):\n  options = []\n\n  def __init__(self, **options):\n      pass\n\n  def write(self, source, target, headers=none, encoding=none):\n      # write logic\n\nwith stream(source, custom_writers={'custom': customwriter}) as stream:\n  stream.save(target)\n```\n\nyou can see examples of how parsers are implemented by looking in the\n`tabulator.writers` module.\n\n## api reference\n\n### `cli`\n```python\ncli(source, limit, **options)\n```\ncommand-line interface\n\n```\nusage: tabulator [options] source\n\noptions:\n  --headers integer\n  --scheme text\n  --format text\n  --encoding text\n  --limit integer\n  --sheet text/integer (excel)\n  --fill-merged-cells boolean (excel)\n  --preserve-formatting boolean (excel)\n  --adjust-floating-point-error boolean (excel)\n  --table text (sql)\n  --order_by text (sql)\n  --resource text/integer (datapackage)\n  --property text (json)\n  --keyed boolean (json)\n  --version          show the version and exit.\n  --help             show this message and exit.\n```\n\n\n### `stream`\n```python\nstream(self,\n       source,\n       headers=none,\n       scheme=none,\n       format=none,\n       encoding=none,\n       compression=none,\n       allow_html=false,\n       sample_size=100,\n       bytes_sample_size=10000,\n       ignore_blank_headers=false,\n       ignore_listed_headers=none,\n       ignore_not_listed_headers=none,\n       multiline_headers_joiner=' ',\n       multiline_headers_duplicates=false,\n       force_strings=false,\n       force_parse=false,\n       pick_rows=none,\n       skip_rows=none,\n       pick_fields=none,\n       skip_fields=none,\n       pick_columns=none,\n       skip_columns=none,\n       post_parse=[],\n       custom_loaders={},\n       custom_parsers={},\n       custom_writers={},\n       **options)\n```\nstream of tabular data.\n\nthis is the main `tabulator` class. it loads a data source, and allows you\nto stream its parsed contents.\n\n__arguments__\n\n\n    source (str):\n        path to file as ``<scheme>://path/to/file.<format>``.\n        if not explicitly set, the scheme (file, http, ...) and\n        format (csv, xls, ...) are inferred from the source string.\n\n    headers (union[int, list[int], list[str]], optional):\n        either a row\n        number or list of row numbers (in case of multi-line headers) to be\n        considered as headers (rows start counting at 1), or the actual\n        headers defined a list of strings. if not set, all rows will be\n        treated as containing values.\n\n    scheme (str, optional):\n        scheme for loading the file (file, http, ...).\n        if not set, it'll be inferred from `source`.\n\n    format (str, optional):\n        file source's format (csv, xls, ...). if not\n        set, it'll be inferred from `source`. inferred\n\n    encoding (str, optional):\n        source encoding. if not set, it'll be inferred.\n\n    compression (str, optional):\n        source file compression (zip, ...). if not set, it'll be inferred.\n\n    pick_rows (list[union[int, str, dict]], optional):\n        the same as `skip_rows` but it's for picking rows instead of skipping.\n\n    skip_rows (list[union[int, str, dict]], optional):\n        list of row numbers, strings and regex patterns as dicts to skip.\n        if a string, it'll skip rows that their first cells begin with it e.g. '#' and '//'.\n        to skip only completely blank rows use `{'type': 'preset', 'value': 'blank'}`\n        to provide a regex pattern use  `{'type': 'regex', 'value': '^#'}`\n        for example: `skip_rows=[1, '# comment', {'type': 'regex', 'value': '^# (regex|comment)'}]`\n\n    pick_fields (str[]):\n        when passed, ignores all columns with headers\n        that the given list does not include\n\n    skip_fields (str[]):\n        when passed, ignores all columns with headers\n        that the given list includes. if it contains an empty string it will skip\n        empty headers\n\n    sample_size (int, optional):\n        controls the number of sample rows used to\n        infer properties from the data (headers, encoding, etc.). set to\n        ``0`` to disable sampling, in which case nothing will be inferred\n        from the data. defaults to ``config.default_sample_size``.\n\n    bytes_sample_size (int, optional):\n        same as `sample_size`, but instead\n        of number of rows, controls number of bytes. defaults to\n        ``config.default_bytes_sample_size``.\n\n    allow_html (bool, optional):\n        allow the file source to be an html page.\n        if false, raises ``exceptions.formaterror`` if the loaded file is\n        an html page. defaults to false.\n\n    multiline_headers_joiner (str, optional):\n        when passed, it's used to join multiline headers\n        as `<passed-value>.join(header1_1, header1_2)`\n        defaults to ' ' (space).\n\n    multiline_headers_duplicates (bool, optional):\n        by default tabulator will exclude a cell of a miltilne header from joining\n        if it's exactly the same as the previous seen value in this field.\n        enabling this option will force duplicates inclusion\n        defaults to false.\n\n    force_strings (bool, optional):\n        when true, casts all data to strings.\n        defaults to false.\n\n    force_parse (bool, optional):\n        when true, don't raise exceptions when\n        parsing malformed rows, simply returning an empty value. defaults\n        to false.\n\n    post_parse (list[function], optional):\n        list of generator functions that\n        receives a list of rows and headers, processes them, and yields\n        them (or not). useful to pre-process the data. defaults to none.\n\n    custom_loaders (dict, optional):\n        dictionary with keys as scheme names,\n        and values as their respective ``loader`` class implementations.\n        defaults to none.\n\n    custom_parsers (dict, optional):\n        dictionary with keys as format names,\n        and values as their respective ``parser`` class implementations.\n        defaults to none.\n\n    custom_loaders (dict, optional):\n        dictionary with keys as writer format\n        names, and values as their respective ``writer`` class\n        implementations. defaults to none.\n\n    **options (any, optional): extra options passed to the loaders and parsers.\n\n\n\n#### `stream.closed`\nreturns true if the underlying stream is closed, false otherwise.\n\n__returns__\n\n`bool`: whether closed\n\n\n\n#### `stream.compression`\nstream's compression (\"no\" if no compression)\n\n__returns__\n\n`str`: compression\n\n\n\n#### `stream.encoding`\nstream's encoding\n\n__returns__\n\n`str`: encoding\n\n\n\n#### `stream.format`\npath's format\n\n__returns__\n\n`str`: format\n\n\n\n#### `stream.fragment`\npath's fragment\n\n__returns__\n\n`str`: fragment\n\n\n\n#### `stream.hash`\nreturns the sha256 hash of the read chunks if available\n\n__returns__\n\n`str/none`: sha256 hash\n\n\n\n#### `stream.headers`\nheaders\n\n__returns__\n\n`str[]/none`: headers if available\n\n\n\n#### `stream.sample`\nreturns the stream's rows used as sample.\n\nthese sample rows are used internally to infer characteristics of the\nsource file (e.g. encoding, headers, ...).\n\n__returns__\n\n`list[]`: sample\n\n\n\n#### `stream.scheme`\npath's scheme\n\n__returns__\n\n`str`: scheme\n\n\n\n#### `stream.size`\nreturns the byte count of the read chunks if available\n\n__returns__\n\n`int/none`: byte count\n\n\n\n#### `stream.source`\nsource\n\n__returns__\n\n`any`: stream source\n\n\n\n#### `stream.open`\n```python\nstream.open()\n```\nopens the stream for reading.\n\n__raises:__\n\n    tabulatorexception: if an error\n\n\n\n#### `stream.close`\n```python\nstream.close()\n```\ncloses the stream.\n\n\n#### `stream.reset`\n```python\nstream.reset()\n```\nresets the stream pointer to the beginning of the file.\n\n\n#### `stream.iter`\n```python\nstream.iter(keyed=false, extended=false)\n```\niterate over the rows.\n\neach row is returned in a format that depends on the arguments `keyed`\nand `extended`. by default, each row is returned as list of their\nvalues.\n\n__arguments__\n- __keyed (bool, optional)__:\n        when true, each returned row will be a\n        `dict` mapping the header name to its value in the current row.\n        for example, `[{'name': 'j smith', 'value': '10'}]`. ignored if\n        ``extended`` is true. defaults to false.\n- __extended (bool, optional)__:\n        when true, returns each row as a tuple\n        with row number (starts at 1), list of headers, and list of row\n        values. for example, `(1, ['name', 'value'], ['j smith', '10'])`.\n        defaults to false.\n\n__raises__\n- `exceptions.tabulatorexception`: if the stream is closed.\n\n__returns__\n\n`iterator[union[list[any], dict[str, any], tuple[int, list[str], list[any]]]]`:\n        the row itself. the format depends on the values of `keyed` and\n        `extended` arguments.\n\n\n\n#### `stream.read`\n```python\nstream.read(keyed=false, extended=false, limit=none)\n```\nreturns a list of rows.\n\n__arguments__\n- __keyed (bool, optional)__: see :func:`stream.iter`.\n- __extended (bool, optional)__: see :func:`stream.iter`.\n- __limit (int, optional)__:\n        number of rows to return. if none, returns all rows. defaults to none.\n\n__returns__\n\n`list[union[list[any], dict[str, any], tuple[int, list[str], list[any]]]]`:\n        the list of rows. the format depends on the values of `keyed`\n        and `extended` arguments.\n\n\n#### `stream.save`\n```python\nstream.save(target, format=none, encoding=none, **options)\n```\nsave stream to the local filesystem.\n\n__arguments__\n- __target (str)__: path where to save the stream.\n- __format (str, optional)__:\n        the format the stream will be saved as. if\n        none, detects from the ``target`` path. defaults to none.\n- __encoding (str, optional)__:\n        saved file encoding. defaults to ``config.default_encoding``.\n- __**options__: extra options passed to the writer.\n\n__returns__\n\n`count (int?)`: written rows count if available\nbuilding index...\nstarted generating documentation...\n\n### `loader`\n```python\nloader(self, bytes_sample_size, **options)\n```\nabstract class implemented by the data loaders\n\nthe loaders inherit and implement this class' methods to add support for a\nnew scheme (e.g. ssh).\n\n__arguments__\n- __bytes_sample_size (int)__: sample size in bytes\n- __**options (dict)__: loader options\n\n\n\n#### `loader.options`\n\n\n#### `loader.load`\n```python\nloader.load(source, mode='t', encoding=none)\n```\nload source file.\n\n__arguments__\n- __source (str)__: path to tabular source file.\n- __mode (str, optional)__:\n        text stream mode, `t` (text) or `b` (binary).  defaults to `t`.\n- __encoding (str, optional)__:\n        source encoding. auto-detect by default.\n\n__returns__\n\n`union[textio, binaryio]`: i/o stream opened either as text or binary.\n\n\n### `parser`\n```python\nparser(self, loader, force_parse, **options)\n```\nabstract class implemented by the data parsers.\n\nthe parsers inherit and implement this class' methods to add support for a\nnew file type.\n\n__arguments__\n- __loader (tabulator.loader)__: loader instance to read the file.\n- __force_parse (bool)__:\n        when `true`, the parser yields an empty extended\n        row tuple `(row_number, none, [])` when there is an error parsing a\n        row. otherwise, it stops the iteration by raising the exception\n        `tabulator.exceptions.sourceerror`.\n- __**options (dict)__: loader options\n\n\n\n#### `parser.closed`\nflag telling if the parser is closed.\n\n__returns__\n\n`bool`: whether closed\n\n\n\n#### `parser.encoding`\nencoding\n\n__returns__\n\n`str`: encoding\n\n\n\n#### `parser.extended_rows`\nreturns extended rows iterator.\n\nthe extended rows are tuples containing `(row_number, headers, row)`,\n\n__raises__\n- `sourceerror`:\n        if `force_parse` is `false` and\n        a row can't be parsed, this exception will be raised.\n        otherwise, an empty extended row is returned (i.e.\n        `(row_number, none, [])`).\n\nreturns:\n    iterator[tuple[int, list[str], list[any]]]:\n        extended rows containing\n        `(row_number, headers, row)`, where `headers` is a list of the\n        header names (can be `none`), and `row` is a list of row\n        values.\n\n\n\n#### `parser.options`\n\n\n#### `parser.open`\n```python\nparser.open(source, encoding=none)\n```\nopen underlying file stream in the beginning of the file.\n\nthe parser gets a byte or text stream from the `tabulator.loader`\ninstance and start emitting items.\n\n__arguments__\n- __source (str)__: path to source table.\n- __encoding (str, optional)__: source encoding. auto-detect by default.\n\n__returns__\n\n    none\n\n\n\n#### `parser.close`\n```python\nparser.close()\n```\ncloses underlying file stream.\n\n\n#### `parser.reset`\n```python\nparser.reset()\n```\nresets underlying stream and current items list.\n\nafter `reset()` is called, iterating over the items will start from the beginning.\n\n### `writer`\n```python\nwriter(self, **options)\n```\nabstract class implemented by the data writers.\n\nthe writers inherit and implement this class' methods to add support for a\nnew file destination.\n\n__arguments__\n- __**options (dict)__: writer options.\n\n\n\n#### `writer.options`\n\n\n#### `writer.write`\n```python\nwriter.write(source, target, headers, encoding=none)\n```\nwrites source data to target.\n\n__arguments__\n- __source (str)__: source data.\n- __target (str)__: write target.\n- __headers (list[str])__: list of header names.\n- __encoding (str, optional)__: source file encoding.\n\n__returns__\n\n`count (int?)`: written rows count if available\n\n\n### `validate`\n```python\nvalidate(source, scheme=none, format=none)\n```\ncheck if tabulator is able to load the source.\n\n__arguments__\n- __source (union[str, io])__: the source path or io object.\n- __scheme (str, optional)__: the source scheme. auto-detect by default.\n- __format (str, optional)__: the source file format. auto-detect by default.\n\n__raises__\n- `schemeerror`: the file scheme is not supported.\n- `formaterror`: the file format is not supported.\n\n__returns__\n\n`bool`: whether tabulator is able to load the source file.\n\n\n### `tabulatorexception`\n```python\ntabulatorexception()\n```\nbase class for all tabulator exceptions.\n\n\n### `sourceerror`\n```python\nsourceerror()\n```\nthe source file could not be parsed correctly.\n\n\n### `schemeerror`\n```python\nschemeerror()\n```\nthe file scheme is not supported.\n\n\n### `formaterror`\n```python\nformaterror()\n```\nthe file format is unsupported or invalid.\n\n\n### `encodingerror`\n```python\nencodingerror()\n```\nencoding error\n\n\n### `compressionerror`\n```python\ncompressionerror()\n```\ncompression error\n\n\n### `ioerror`\n```python\nioerror()\n```\nlocal loading error\n\n\n### `loadingerror`\n```python\nloadingerror()\n```\nlocal loading error\n\n\n### `httperror`\n```python\nhttperror()\n```\nremote loading error\n\n## contributing\n\n> the project follows the [open knowledge international coding standards](https://github.com/okfn/coding-standards).\n\nrecommended way to get started is to create and activate a project virtual environment.\nto install package and development dependencies into active environment:\n\n```bash\n$ make install\n```\n\nto run tests with linting and coverage:\n\n```bash\n$ make test\n```\n\nto run tests without internet:\n\n```\n$ pytest -m 'not remote\n```\n\n## changelog\n\nhere described only breaking and the most important changes. the full changelog and documentation for all released versions could be found in nicely formatted [commit history](https://github.com/frictionlessdata/tabulator-py/commits/master).\n\n#### v1.53\n\n- add support for raw_html extraction in html parser (#341)\n\n#### v1.52\n\n- published stream.dialect (works only for csv, for now)\n\n#### v1.51\n\n- added experimental table discovery options\n\n#### v1.50\n\n- ensure that headers is always a list of strings\n\n#### v1.49\n\n- added `workbook_cache` argument for xlsx formats\n\n#### v1.48\n\n- published `stream.hashing_algorithm` property\n\n#### v1.47\n\n- added `hashing_algorithm` parameter\n\n#### v1.46\n\n- fixed multiline headers merging\n- introduced a `multiline_headers_duplicates` flag\n\n#### v1.45\n\n- html format: adds support for empty selector (#321)\n\n#### v1.44\n\n- exposed `stream.compression`\n\n#### v1.43\n\n- exposed `stream.source`\n\n#### v1.42\n\n- exposed format option to the cli\n\n#### v1.41\n\n- implemented a `pick_rows` parameter (opposite to `skip_rows`)\n\n#### v1.40\n\n- implemented `stream.save()` returning count of written rows\n\n#### v1.39\n\n- implemented json writer (#311)\n\n#### v1.38\n\n- use `chardet` for encoding detection by default. for `cchardet`: `pip install tabulator[cchardet]`. due to a great deal of problems caused by `ccharted` for non-linux/conda installations we're returning back to using `chardet` by default.\n\n#### v1.37\n\n- raise ioerror/httperror even a not-existent file has a bad format (#304)\n\n#### v1.36\n\n- implemented `blank` preset for `skip_rows` (#302)\n\n#### v1.35\n\n- added `skip/pick_columns` aliases for (#293)\n\n#### v1.34\n\n- added `multiline_headers_joiner` argument (#291)\n\n#### v1.33\n\n- added support for regex patterns in `skip_rows` (#290)\n\n#### v1.32\n\n- added ability to skip columns (#293)\n\n#### v1.31\n\n- added `xlsx` writer\n- added `html` reader\n\n#### v1.30\n\n- added `adjust_floating_point_error` parameter to the `xlsx` parser\n\n#### v1.29\n\n- implemented the `stream.size` and `stream.hash` properties\n\n#### v1.28\n\n- added sql writer\n\n#### v1.27\n\n- added `http_timeout` argument for the `http/https` format\n\n#### v1.26\n\n- added `stream.fragment` field showing e.g. excel sheet's or dp resource's name\n\n#### v1.25\n\n- added support for the `s3` file scheme (data loading from aws s3)\n\n#### v1.24\n\n- added support for compressed file-like objects\n\n#### v1.23\n\n- added a setter for the `stream.headers` property\n\n#### v1.22\n\n- the `headers` parameter will now use the first not skipped row if the `skip_rows` parameter is provided and there are comments on the top of a data source (see #264)\n\n#### v1.21\n\n- implemented experimental `preserve_formatting` for xlsx\n\n#### v1.20\n\n- added support for specifying filename in zip source\n\n#### v1.19\n\nupdated behaviour:\n- for `ods` format the boolean, integer and datetime native types are detected now\n\n#### v1.18\n\nupdated behaviour:\n- for `xls` format the boolean, integer and datetime native types are detected now\n\n#### v1.17\n\nupdated behaviour:\n- added support for python 3.7\n\n#### v1.16\n\nnew api added:\n- `skip_rows` support for an empty string to skip rows with an empty first column\n\n#### v1.15\n\nnew api added:\n- format will be extracted from urls like `http://example.com?format=csv`\n\n#### v1.14\n\nupdated behaviour:\n- now `xls` booleans will be parsed as booleans not integers\n\n#### v1.13\n\nnew api added:\n- the `skip_rows` argument now supports negative numbers to skip rows starting from the end\n\n#### v1.12\n\nupdated behaviour:\n- instead of raising an exception, a `userwarning` warning will be emitted if an option isn't recognized.\n\n#### v1.11\n\nnew api added:\n- added `http_session` argument for the `http/https` format (it uses `requests` now)\n- added support for multiline headers: `headers` argument accept ranges like `[1,3]`\n\n#### v1.10\n\nnew api added:\n- added support for compressed files i.e. `zip` and `gz` on python3\n- the `stream` constructor now accepts a `compression` argument\n- the `http/https` scheme now accepts a `http_stream` flag\n\n#### v1.9\n\nimproved behaviour:\n- the `headers` argument allows to set the order for keyed sources and cherry-pick values\n\n#### v1.8\n\nnew api added:\n- formats `xls/xlsx/ods` supports sheet names passed via the `sheet` argument\n- the `stream` constructor accepts an `ignore_blank_headers` option\n\n#### v1.7\n\nimproved behaviour:\n- rebased `datapackage` format on `datapackage@1` library\n\n#### v1.6\n\nnew api added:\n- argument `source` for the `stream` constructor can be a `pathlib.path`\n\n#### v1.5\n\nnew api added:\n- argument `bytes_sample_size` for the `stream` constructor\n\n#### v1.4\n\nimproved behaviour:\n- updated encoding name to a canonical form\n\n#### v1.3\n\nnew api added:\n- `stream.scheme`\n- `stream.format`\n- `stream.encoding`\n\npromoted provisional api to stable api:\n- `loader` (custom loaders)\n- `parser` (custom parsers)\n- `writer` (custom writers)\n- `validate`\n\n#### v1.2\n\nimproved behaviour:\n- autodetect common csv delimiters\n\n#### v1.1\n\nnew api added:\n- added `fill_merged_cells` option to `xls/xlsx` formats\n\n#### v1.0\n\nnew api added:\n- published `loader/parser/writer` api\n- added `stream` argument `force_strings`\n- added `stream` argument `force_parse`\n- added `stream` argument `custom_writers`\n\ndeprecated api removal:\n- removed `topen` and `table` - use `stream` instead\n- removed `stream` arguments `loader/parser_options` - use `**options` instead\n\nprovisional api changed:\n- updated the `loader/parser/writer` api - please use an updated version\n\n#### v0.15\n\nprovisional api added:\n- unofficial support for `stream` arguments `custom_loaders/parsers`\n\n\n[stream.py]: tabulator/stream.py\n[examples-dir]: examples \"examples\"\n[requests-session]: https://docs.puthon-requests.org/en/master/user/advanced/#session-objects\n[pydoc-csv]: https://docs.python.org/3/library/csv.html#dialects-and-formatting-parameters \"python csv options\"\n[sqlalchemy]: https://www.sqlalchemy.org/\n[tdp]: https://frictionlessdata.io/specs/tabular-data-package/ \"tabular data package\"\n[tabulator.exceptions]: tabulator/exceptions.py \"tabulator exceptions\"\n\n",
  "docs_url": null,
  "keywords": "frictionless data",
  "license": "mit",
  "name": "tabulator",
  "package_url": "https://pypi.org/project/tabulator/",
  "project_url": "https://pypi.org/project/tabulator/",
  "project_urls": {
    "Homepage": "https://github.com/frictionlessdata/tabulator-py"
  },
  "release_url": "https://pypi.org/project/tabulator/1.53.5/",
  "requires_dist": [
    "six (>=1.9)",
    "click (>=6.0)",
    "requests (>=2.8)",
    "chardet (>=3.0)",
    "boto3 (>=1.9)",
    "unicodecsv (>=0.14)",
    "ijson (>=3.0.3)",
    "jsonlines (>=1.1)",
    "sqlalchemy (>=0.9.6)",
    "linear-tsv (>=1.0)",
    "xlrd (>=1.0)",
    "openpyxl (>=2.6)",
    "cchardet (>=2.0) ; extra == 'cchardet'",
    "datapackage (>=1.12) ; extra == 'datapackage'",
    "mock ; extra == 'develop'",
    "pylama ; extra == 'develop'",
    "pytest ; extra == 'develop'",
    "pytest-cov ; extra == 'develop'",
    "moto[server] ; extra == 'develop'",
    "pyquery (<1.4.2) ; extra == 'html'",
    "ezodf (>=0.3) ; extra == 'ods'",
    "lxml (>=3.0) ; extra == 'ods'"
  ],
  "requires_python": "",
  "summary": "consistent interface for stream reading and writing tabular data (csv/xls/json/etc)",
  "version": "1.53.5",
  "releases": [],
  "developers": [
    "info@okfn.org",
    "open_knowledge_foundation"
  ],
  "kwds": "tabulator frictionlessdata tabulatorexception pip pytest",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_tabulator",
  "homepage": "https://github.com/frictionlessdata/tabulator-py",
  "release_count": 142,
  "dependency_ids": [
    "pypi_boto3",
    "pypi_cchardet",
    "pypi_chardet",
    "pypi_click",
    "pypi_datapackage",
    "pypi_ezodf",
    "pypi_ijson",
    "pypi_jsonlines",
    "pypi_linear_tsv",
    "pypi_lxml",
    "pypi_mock",
    "pypi_moto",
    "pypi_openpyxl",
    "pypi_pylama",
    "pypi_pyquery",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_requests",
    "pypi_six",
    "pypi_sqlalchemy",
    "pypi_unicodecsv",
    "pypi_xlrd"
  ]
}