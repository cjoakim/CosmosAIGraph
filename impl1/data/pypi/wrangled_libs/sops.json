{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mozilla public license 2.0 (mpl 2.0)",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "sops: secrets operations\n========================\n\n.. image:: http://unmaintained.tech/badge.svg\n   :target: http://unmaintained.tech/\n   :alt: no maintenance intended\n\nthis is the python version of sops that is no longer maintained. we fix the occasional bug, but all improvements happen in the go version of sops, over in the master branch. you have been warned!\n\n**sop** is an editor of encrypted files that supports yaml, json and binary formats and encrypts with aws kms and pgp (via gnupg). watch `the demo <https://www.youtube.com/watch?v=ytevylxfiq0>`_.\n\n.. image:: http://i.imgur.com/il6dlhm.gif\n\n.. image:: https://travis-ci.org/mozilla/sops.svg?branch=master\n\t:target: https://travis-ci.org/mozilla/sops\n\n**questions?** ping \"ulfr\" in `#security` on `irc.mozilla.org <https://wiki.mozilla.org/irc>`_\n(use a web client like `mibbit <https://chat.mibbit.com>`_ ).\n\n.. sectnum::\n.. contents:: table of contents\n\ninstallation\n------------\n\n* rhel family::\n\n\tsudo yum install gcc git libffi-devel libyaml-devel make openssl openssl-devel python-devel python-pip\n\tsudo pip install --upgrade sops\n\n* debian family::\n\n\tsudo apt-get install gcc git libffi-dev libssl-dev libyaml-dev make openssl python-dev python-pip\n\tsudo pip install --upgrade sops\n\n* macos brew install::\n\n\tbrew install sops\n\n* macos manual install::\n\n\tbrew install libffi libyaml python [1]\n\tpip install sops\n\n1. http://docs.python-guide.org/en/latest/starting/install/osx/#doing-it-right\n\nin a virtualenv\n~~~~~~~~~~~~~~~\n\nassuming you already have libffi and libyaml installed, the following commands will install sops in a virtualenv:\n\n.. code:: bash\n\n    $ sudo pip install virtualenv --upgrade\n    $ virtualenv ~/sopsvenv\n    $ source ~/sopsvenv/bin/activate\n    $ pip install -u sops\n    $ sops -v\n    sops 1.9\n\ntest with the dev pgp key\n~~~~~~~~~~~~~~~~~~~~~~~~~\nclone the repository, load the test pgp key and open the test files::\n\n\t$ git clone https://github.com/mozilla/sops.git\n\t$ cd sops\n\t$ gpg --import tests/sops_functional_tests_key.asc\n\t$ sops example.yaml\n\nthis last step will decrypt `example.yaml` using the test private key. to create\nyour own secrets files using keys under your control, keep reading.\n\nusage\n-----\n\nif you're using aws kms, create one or multiple master keys in the iam console\nand export them, comma separated, in the **sops_kms_arn** env variable. it is\nrecommended to use at least two master keys in different regions.\n\n.. code:: bash\n\n\texport sops_kms_arn=\"arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e,arn:aws:kms:ap-southeast-1:656532927350:key/9006a8aa-0fa6-4c14-930e-a2dfb916de1d\"\n\nyour aws credentials must be present in `~/.aws/credentials`. sops uses boto3.\n\n.. code::\n\n\t$ cat ~/.aws/credentials\n\t[default]\n\taws_access_key_id = aki.....\n\taws_secret_access_key = mw......\n\nif you want to use pgp, export the fingerprints of the public keys, comma\nseparated, in the **sops_pgp_fp** env variable.\n\n.. code:: bash\n\n\texport sops_pgp_fp=\"85d77543b3d624b63cea9e6dbc17301b491b3f21,e60892bb9bd89a69f759a1a0a3d652173b763e8f\"\n\nnote: you can use both pgp and kms simultaneously.\n\nthen simply call `sops` with a file path as argument. it will handle the\nencryption/decryption transparently and open the cleartext file in an editor\n\n.. code:: bash\n\n\t$ sops mynewtestfile.yaml\n\tmynewtestfile.yaml doesn't exist, creating it.\n\tplease wait while an encryption key is being generated and stored in a secure fashion\n\tfile written to mynewtestfile.yaml\n\n.\nediting will happen in whatever $editor is set to, or, if it's not set, in vim.\nkeep in mind that sops will wait for the editor to exit, and then try to reencrypt\nthe file. some gui editors (atom, sublime) spawn a child process and then exit\nimmediately. they usually have an option to wait for the main editor window to be\nclosed before exiting. see [#127](https://github.com/mozilla/sops/issues/127) for\nmore information.\n\nthe resulting encrypted file looks like this:\n\n.. code:: yaml\n\n    myapp1: enc[aes256_gcm,data:tr7o=,iv:1=,aad:no=,tag:k=]\n    app2:\n        db:\n            user: enc[aes256_gcm,data:cwe4o1s=,iv:2k=,aad:o=,tag:w==]\n            password: enc[aes256_gcm,data:p673w==,iv:yy=,aad:uq=,tag:a=]\n        # private key for secret operations in app2\n        key: |-\n            enc[aes256_gcm,data:ea3kl5o5u8=,iv:dm=,aad:fka=,tag:ea==]\n    an_array:\n    - enc[aes256_gcm,data:v8jq=,iv:hbe=,aad:21c=,tag:ga==]\n    - enc[aes256_gcm,data:x10=,iv:o8=,aad:cq=,tag:hw==]\n    - enc[aes256_gcm,data:kn=,iv:160=,aad:fi4=,tag:tnw==]\n    sops:\n        kms:\n        -   created_at: 1441570389.775376\n            enc: cic....pm1hm\n            arn: arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e\n        -   created_at: 1441570391.925734\n            enc: ci...awnx\n            arn: arn:aws:kms:ap-southeast-1:656532927350:key/9006a8aa-0fa6-4c14-930e-a2dfb916de1d\n        pgp:\n        -   fp: 85d77543b3d624b63cea9e6dbc17301b491b3f21\n            created_at: 1441570391.930042\n            enc: |\n                -----begin pgp message-----\n                hqima0t4uzhfl9qgaq//uvgawgepyhuf2/zaywclogads0mzi+zw6cmxvmrnpusa\n\t\t\t\t...=ojgs\n                -----end pgp message-----\n\na copy of the encryption/decryption key is stored securely in each kms and pgp\nblock. as long as one of the kms or pgp method is still usable, you will be able\nto access your data.\n\nto decrypt a file in a `cat` fashion, use the `-d` flag:\n\n.. code:: bash\n\n\t$ sops -d mynewtestfile.yaml\n\n`sops` encrypted files contain the necessary information to decrypt their content.\nall a user of `sops` needs is valid aws credentials and the necessary\npermissions on kms keys.\n\ngiven that, the only command a `sops` user needs is:\n\n.. code:: bash\n\n\t$ sops <file>\n\n`<file>` will be opened, decrypted, passed to a text editor (vim by default),\nencrypted if modified, and saved back to its original location. all of these\nsteps, apart from the actual editing, are transparent to the user.\n\nadding and removing keys\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nwhen creating new files, `sops` uses the pgp and kms defined in the command\nline arguments `--kms` and `--pgp`, or from the environment variables\n`sops_kms_arn` and `sops_pgp_fp`. that information is stored in the file under\nthe `sops` section, such that decrypting files does not require providing those\nparameters again.\n\nmaster pgp and kms keys can be added and removed from a `sops` file in one of\ntwo ways: by using command line flag, or by editing the file directly.\n\ncommand line flag `--add-kms`, `--add-pgp`, `--rm-kms` and `--rm-pgp` can be\nused to add and remove keys from a file. these flags use the comma separated\nsyntax as the `--kms` and `--pgp` arguments when creating new files.\n\n.. code:: bash\n\n\t# add a new pgp key to the file and rotate the data key\n\t$ sops -r --add-pgp 85d77543b3d624b63cea9e6dbc17301b491b3f21 example.yaml\n\n\t# remove a pgp key from the file and rotate the data key\n\t$ sops -r --rm-pgp 85d77543b3d624b63cea9e6dbc17301b491b3f21 example.yaml\n\nalternatively, invoking `sops` with the flag **-s** will display the master keys\nwhile editing. this method can be used to add or remove kms or pgp keys under the\nsops section.\n\nfor example, to add a kms master key to a file, add the following entry while\nediting:\n\n.. code:: yaml\n\n\tsops:\n\t    kms:\n\t    - arn: arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e\n\nand, similarly, to add a pgp master key, we add its fingerprint:\n\n.. code:: yaml\n\n\tsops:\n\t    pgp:\n\t    - fp: 85d77543b3d624b63cea9e6dbc17301b491b3f21\n\nwhen the file is saved, `sops` will update its metadata and encrypt the data key\nwith the freshly added master keys. the removed entries are simply deleted from\nthe file.\n\nwhen removing keys, it is recommended to rotate the data key using `-r`,\notherwise owners of the removed key may have add access to the data key in the\npast.\n\nassuming roles and using kms in various aws accounts\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nsops has the ability to use kms in multiple aws accounts by assuming roles in\neach account. being able to assume roles is a nice feature of aws that allows\nadministrators to establish trust relationships between accounts, typically from\nthe most secure account to the least secure one. in our use-case, we use roles\nto indicate that a user of the master aws account is allowed to make use of kms\nmaster keys in development and staging aws accounts. using roles, a single file\ncan be encrypted with kms keys in multiple accounts, thus increasing reliability\nand ease of use.\n\nyou can use keys in various accounts by tying each kms master key to a role that\nthe user is allowed to assume in each account. the `iam roles\n<http://docs.aws.amazon.com/iam/latest/userguide/id_roles_use.html>`_\ndocumentation has full details on how this needs to be configured on aws's side.\n\nfrom the point of view of `sops`, you only need to specify the role a kms key\nmust assume alongside its arn, as follows:\n\n.. code:: yaml\n\n\tsops:\n\t    kms:\n\t    -\tarn: arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e\n\t        role: arn:aws:iam::927034868273:role/sops-dev-xyz\n\nthe role must have permission to call encrypt and decrypt using kms. an example\npolicy is shown below.\n\n.. code:: json\n\n\t{\n\t  \"sid\": \"allow use of the key\",\n\t  \"effect\": \"allow\",\n\t  \"action\": [\n\t\t\"kms:encrypt\",\n\t\t\"kms:decrypt\",\n\t\t\"kms:reencrypt*\",\n\t\t\"kms:generatedatakey*\",\n\t\t\"kms:describekey\"\n\t  ],\n\t  \"resource\": \"*\",\n\t  \"principal\": {\n\t\t\"aws\": [\n\t\t  \"arn:aws:iam::927034868273:role/sops-dev-xyz\"\n\t\t]\n\t  }\n\t}\n\nyou can specify a role in the `--kms` flag and `sops_kms_arn` variable by\nappending it to the arn of the master key, separated by a **+** sign::\n\n\t<kms arn>+<role arn>\n\tarn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500+arn:aws:iam::927034868273:role/sops-dev-xyz\n\naws kms encryption context\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nsops has the ability to use aws kms key policy and encryption context\n<http://docs.aws.amazon.com/kms/latest/developerguide/encryption-context.html>\nto refine the access control of a given kms master key.\n\nwhen creating a new file, you can specify encryption context in the\n`--encryption-context` flag by comma separated list of key-value pairs:\n\nwhen creating a new file, you can specify encryption context in the\n`--encryption-context` flag by comma separated list of key-value pairs:\n\n.. code:: bash\n\n\t$ sops --encryption-context environment:production,role:web-server test.dev.yaml\n\nthe format of the encrypt context string is `<encryptioncontext key>:<encryptioncontext value>,<encryptioncontext key>:<encryptioncontext value>,...`\n\nthe encryption context will be stored in the file metadata and does\nnot need to be provided at decryption.\n\nencryption contexts can be used in conjunction with kms key policies to define\nroles that can only access a given context. an example policy is shown below:\n\n.. code:: json\n\n    {\n      \"effect\": \"allow\",\n      \"principal\": {\n        \"aws\": \"arn:aws:iam::111122223333:role/roleforexampleapp\"\n      },\n      \"action\": \"kms:decrypt\",\n      \"resource\": \"*\",\n      \"condition\": {\n        \"stringequals\": {\n          \"kms:encryptioncontext:appname\": \"exampleapp\",\n          \"kms:encryptioncontext:filepath\": \"/var/opt/secrets/\"\n        }\n      }\n    }\n\nkey rotation\n~~~~~~~~~~~~\n\nit is recommended to renew the data key on a regular basis. `sops` supports key\nrotation via the `-r` flag. invoking it on an existing file causes sops to\nreencrypt the file with a new data key, which is then encrypted with the various\nkms and pgp master keys defined in the file.\n\n.. code:: bash\n\n\tsops -r example.yaml\n\nusing .sops.yaml conf to select kms/pgp for new files\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nit is often tedious to specify the `--kms` and `--pgp` parameters for creation\nof all new files. if your secrets are stored under a specific directory, like a\n`git` repository, you can create a `.sops.yaml` configuration file at the root\ndirectory to define which keys are used for which filename.\n\nlet's take an example:\n\n* file named **something.dev.yaml** should use one set of kms a\n* file named **something.prod.yaml** should use another set of kms b\n* other files use a third set of kms c\n* all live under **mysecretrepo/something.{dev,prod}.yaml**\n\nunder those circumstances, a file placed at **mysecretrepo/.sops.yaml**\ncan manage the three sets of configurations for the three types of files:\n\n.. code:: yaml\n\n\t# creation rules are evaluated sequentially, the first match wins\n\tcreation_rules:\n\t\t# upon creation of a file that matches the pattern *.dev.yaml,\n\t\t# kms set a is used\n\t\t- filename_regex: \\.dev\\.yaml$\n\t\t  kms: 'arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500,arn:aws:kms:us-west-2:361527076523:key/5052f06a-5d3f-489e-b86c-57201e06f31e+arn:aws:iam::361527076523:role/hiera-sops-prod'\n\t\t  pgp: '1022470de3f0bc54bc6ab62de05550bc07fb1a0a'\n\n\t\t# prod files use kms set b in the prod iam\n\t\t- filename_regex: \\.prod\\.yaml$\n\t\t  kms: 'arn:aws:kms:us-west-2:361527076523:key/5052f06a-5d3f-489e-b86c-57201e06f31e+arn:aws:iam::361527076523:role/hiera-sops-prod,arn:aws:kms:eu-central-1:361527076523:key/cb1fab90-8d17-42a1-a9d8-334968904f94+arn:aws:iam::361527076523:role/hiera-sops-prod'\n\t\t  pgp: '1022470de3f0bc54bc6ab62de05550bc07fb1a0a'\n\n\t\t# finally, if the rules above have not matched, this one is a\n\t\t# catchall that will encrypt the file using kms set c\n\t\t# the absence of a filename_regex means it will match everything\n\t\t- kms: 'arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500,arn:aws:kms:us-west-2:142069644989:key/846cfb17-373d-49b9-8baf-f36b04512e47,arn:aws:kms:us-west-2:361527076523:key/5052f06a-5d3f-489e-b86c-57201e06f31e'\n\t\t  pgp: '1022470de3f0bc54bc6ab62de05550bc07fb1a0a'\n\nwhen creating any file under **mysecretrepo**, whether at the root or under\na subdirectory, sops will recursively look for a `.sops.yaml` file. if one is\nfound, the filename of the file being created is compared with the filename\nregexes of the configuration file. the first regex that matches is selected,\nand its kms and pgp keys are used to encrypt the file.\n\ncreating a new file with the right keys is now as simple as\n\n.. code:: bash\n\n\t$ sops <newfile>.prod.yaml\n\nnote that the configuration file is ignored when kms or pgp parameters are\npassed on the sops command line or in environment variables.\n\nspecify a different gpg executable\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`sops` checks for the `sops_gpg_exec` environment variable. if specified, \nit will attempt to use the executable set there instead of the default \nof `gpg`.\n\nexample: place the following in your `~/.bashrc`\n\n.. code:: bash\n\n\tsops_gpg_exec = 'your_gpg_client_wrapper'\n\t\nimportant information on types\n------------------------------\n\nyaml and json type extensions\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`sops` uses the file extension to decide which encryption method to use on the file\ncontent. `yaml` and `json` files are treated as trees of data, and key/values are\nextracted from the files to only encrypt the leaf values. the tree structure is also\nused to check the integrity of the file.\n\ntherefore, if a file is encrypted using a specific format, it need to be decrypted\nin the same format. the easiest way to achieve this is to conserve the original file\nextension after encrypting a file. for example::\n\n\t$ sops -e -i myfile.json\n\n\t$ sops -d myfile.json\n\nif you want to change the extension of the file once encrypted, you need to provide\nsops with the `--input-type` flag upon decryption. for example::\n\n\t$ sops -e myfile.json > myfile.json.enc\n\n\t$ sops -d --input-type json myfile.json.enc\n\nyaml anchors\n~~~~~~~~~~~~\n`sops` only supports a subset of `yaml`'s many types. encrypting yaml files that\ncontain strings, numbers and booleans will work fine, but files that contain anchors\nwill not work, because the anchors redefine the structure of the file at load time.\n\nthis file will not work in `sops`:\n\n.. code:: yaml\n\n\tbill-to:  &id001\n\t    street: |\n\t        123 tornado alley\n\t        suite 16\n\t    city:   east centerville\n\t    state:  ks\n\n\tship-to:  *id001\n\n`sops` uses the path to a value as additional data in the aead encryption, and thus\ndynamic paths generated by anchors break the authentication step.\n\njson and text file types do not support anchors and thus have no such limitation.\n\ntop-level arrays\n~~~~~~~~~~~~~~~~\n`yaml` and `json` top-level arrays are not supported, because `sops` needs a top-level\n`sops` key to store its metadata.\nthis file will not work in sops:\n\n.. code:: yaml\n\n\t---\n\t  - some\n\t  - array\n\t  - elements\n\nbut this one will because because the `sops` key can be added at the same level as the\n`data` key.\n\n.. code:: yaml\n\n\tdata:\n\t  - some\n\t  - array\n\t  - elements\n\nsimilarly, with `json` arrays, this document will not work:\n\n.. code:: json\n\n\t[\n\t  \"some\",\n\t  \"array\",\n\t  \"elements\"\n\t]\n\n\nbut this one will work just fine:\n\n.. code:: json\n\n\t{\n\t  \"data\": [\n\t    \"some\",\n\t    \"array\",\n\t    \"elements\"\n\t  ]\n\t}\n\n\nexamples\n--------\n\ntake a look into the `examples <https://github.com/mozilla/sops/tree/master/examples>`_ folder for detailed use cases of sops in a ci environment. the section below describes specific tips for common use cases.\n\ncreating a new file\n~~~~~~~~~~~~~~~~~~~\n\nthe command below creates a new file with a data key encrypted by kms and pgp.\n\n.. code:: bash\n\n\t$ sops --kms \"arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500\" --pgp c9cab0af1165060db58d6d6b2653b624d620786d /path/to/new/file.yaml\n\nencrypting an existing file\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nsimilar to the previous command, we tell sops to use one kms and one pgp key.\nthe path points to an existing cleartext file, so we give sops flag `-e` to\nencrypt the file, and redirect the output to a destination file.\n\n.. code:: bash\n\n\t$ export sops_kms_arn=\"arn:aws:kms:us-west-2:927034868273:key/fe86dd69-4132-404c-ab86-4269956b4500\"\n\t$ export sops_pgp_fp=\"c9cab0af1165060db58d6d6b2653b624d620786d\"\n\t$ sops -e /path/to/existing/file.yaml > /path/to/new/encrypted/file.yaml\n\ndecrypt the file with `-d`.\n\n.. code:: bash\n\n\t$ sops -d /path/to/new/encrypted/file.yaml\n\nencrypt or decrypt a file in place\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nrather than redirecting the output of `-e` or `-d`, sops can replace the\noriginal file after encrypting or decrypting it.\n\n.. code:: bash\n\n\t# file.yaml is in cleartext\n\t$ sops -e -i /path/to/existing/file.yaml\n\t# file.yaml is now encrypted\n\t$ sops -d -i /path/to/existing/file.yaml\n\t# file.yaml is back in cleartext\n\nencrypting binary files\n~~~~~~~~~~~~~~~~~~~~~~~\n\n`sops` primary use case is encrypting yaml and json configuration files, but it\nalso has the ability to manage binary files. when encrypting a binary, sops will\nread the data as bytes, encrypt it, store the encrypted base64 under\n`tree['data']` and write the result as json.\n\nnote that the base64 encoding of encrypted data can actually make the encrypted\nfile larger than the cleartext one.\n\nin-place encryption/decryption also works on binary files.\n\n.. code::\n\n\t$ dd if=/dev/urandom of=/tmp/somerandom bs=1024\n\tcount=512\n\t512+0 records in\n\t512+0 records out\n\t524288 bytes (524 kb) copied, 0.0466158 s, 11.2 mb/s\n\n\t$ sha512sum /tmp/somerandom\n\t9589bb20280e9d381f7a192000498c994e921b3cdb11d2ef5a986578dc2239a340b25ef30691bac72bdb14028270828dad7e8bd31e274af9828c40d216e60cbe /tmp/somerandom\n\n\t$ sops -e -i /tmp/somerandom\n\tplease wait while a data encryption key is being generated and stored securely\n\n\t$ sops -d -i /tmp/somerandom\n\n\t$ sha512sum /tmp/somerandom\n\t9589bb20280e9d381f7a192000498c994e921b3cdb11d2ef5a986578dc2239a340b25ef30691bac72bdb14028270828dad7e8bd31e274af9828c40d216e60cbe /tmp/somerandom\n\nextract a sub-part of a document tree\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`sops` can extract a specific part of a yaml or json document, by provided the\npath in the `--extract` command line flag. this is useful to extract specific\nvalues, like keys, without needing an extra parser.\n\n.. code:: bash\n\n\t$ sops -d ~/git/svc/sops/example.yaml --extract '[\"app2\"][\"key\"]'\n\t-----begin rsa private key-----\n\tmiibpaibaajbaptmniyhuztplyc7vshqtwokwyobkublmhwrmbxzlax6k8tmf3wf\n\timcbnkqaknelzfapsbeemhrbn0pyoc9lylmcaweaaqjbalxd4sjubn1e7y9agimz\n\tbjebuzj4wbhyxomvoqkfacu+kh80ulfzkosz85/ysauwe8lgzcmliboixnhdkfql\n\tvheciqd6tcg9nmfwor69kgbx8vk5y+ql+krq+9hk6yz9a+hslqihapn4ie6hgtjw\n\tfhstxwzpgsan7nwtkiu4u5q2slljczh/aiea78nyrrbwgwaynuqzutgbqyxkul4u\n\terb0xaeyvv7e8j0ciqc8vby8f8yg+y7kxbw4zdygyb3kkxl10yorpeuzr4luqqig\n\tbkgpkmm4w5blye1tqgn0t7sjwex+euogacrnqm2ljva=\n\t-----end rsa private key-----\n\nthe tree path syntax uses regular python dictionary syntax, without the\nvariable name. extract keys by naming them, and array elements by numbering\nthem.\n\n.. code:: bash\n\n\t$ sops -d ~/git/svc/sops/example.yaml --extract '[\"an_array\"][1]'\n\tsecretuser2\n\nset a sub-part in a document tree\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n`sops` can set a specific part of a yaml or json document, by providing\nthe path and value in the `--set` command line flag. this is useful to\nset specific values, like keys, without needing an editor.\n\n.. code:: bash\n\n\t$ sops ~/git/svc/sops/example.yaml --set '[\"app2\"][\"key\"]' '\"app2keystringvalue\"'\n\nthe tree path syntax uses regular python dictionary syntax, without the\nvariable name. set to keys by naming them, and array elements by\nnumbering them.\n\n.. code:: bash\n\n\t$ sops ~/git/svc/sops/example.yaml --set '[\"an_array\"][1]' '\"secretuser2\"'\n\nthe value must be formatted as json.\n\n.. code:: bash\n\n\t$ sops ~/git/svc/sops/example.yaml --set '[\"an_array\"][1]' '{\"uid1\":null,\"uid2\":1000,\"uid3\":[\"bob\"]}'\n\nusing sops as a library in a python script\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nyou can import sops as a module and use it in your python program.\n\n.. code:: python\n\n\timport sops\n\n\tpathtype = sops.detect_filetype(path)\n\ttree = sops.load_file_into_tree(path, pathtype)\n\tsops_key, tree = sops.get_key(tree)\n\ttree = sops.walk_and_decrypt(tree, sops_key)\n\tsops.write_file(tree, path=path, filetype=pathtype)\n\nshowing diffs in cleartext in git\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nyou most likely want to store encrypted files in a version controlled repository.\nsops can be used with git to decrypt files when showing diffs between versions.\nthis is very handy for reviewing changes or visualizing history.\n\nto configure sops to decrypt files during diff, create a `.gitattributes` file\nat the root of your repository that contains a filter and a command.\n\n... code::\n\n\t*.yaml diff=sopsdiffer\n\nhere we only care about yaml files. `sopsdiffer` is an arbitrary name that we map\nto a sops command in the git configuration file of the repository.\n\n.. code:: bash\n\n\t$ git config diff.sopsdiffer.textconv \"sops -d\"\n\n\t$ grep -a 1 sopsdiffer .git/config\n\t[diff \"sopsdiffer\"]\n\t\ttextconv = \"sops -d\"\n\nwith this in place, calls to `git diff` will decrypt both previous and current\nversions of the target file prior to displaying the diff. and it even works with\ngit client interfaces, because they call git diff under the hood!\n\nencrypting only parts of a file\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nnote: this only works on yaml and json files, not on binary files.\n\nby default, `sops` encrypts all the values of a yaml or json file and leaves the\nkeys in cleartext. in some instances, you may want to exclude some values from\nbeing encrypted. this can be accomplished by adding the suffix **_unencrypted**\nto any key of a file. when set, all values underneath the key that set the\n**_unencrypted** prefix will be left in cleartext.\n\nnote that, while in cleartext, unencrypted content is still added to the\nchecksum of the file, and thus cannot be modified outside of sops without\nbreaking the file integrity check.\n\nthe unencrypted suffix can be set to a different value using the\n`--unencrypted-suffix` option.\n\nencryption protocol\n-------------------\n\nwhen sops creates a file, it generates a random 256 bit data key and asks each\nkms and pgp master key to encrypt the data key. the encrypted version of the data\nkey is stored in the `sops` metadata under `sops.kms` and `sops.pgp`.\n\nfor kms:\n\n.. code:: yaml\n\n    sops:\n        kms:\n        -   enc: cic6ycotzsnfhkfdislyz0baf//gylycmiu87b3sy/5yyxknaqebaqb4usgjrc7jxyzh3sljwgdgwh//4gc2apilvowd7mv+cmmaaab+mhwgcsqgsib3dqehbqbvmg0caqawaayjkozihvcnaqcbmb4gcwcgsaflawqbljarbaygdroduymhba8ozj8carcao7opmolpjumbxd39zlp0l2h9fzmkidhm1vvaf6nnfq0clry7flizmtm4jfnoebpseffixfn9tg8cq7oi\n            enc_ts: 1439568549.245995\n            arn: arn:aws:kms:us-east-1:656532927350:key/920aff2e-c5f1-4040-943a-047fa387b27e\n\nfor pgp:\n\n.. code:: yaml\n\n    sops:\n        pgp:\n        -   fp: 85d77543b3d624b63cea9e6dbc17301b491b3f21\n            created_at: 1441570391.930042\n            enc: |\n                -----begin pgp message-----\n                version: gnupg v1\n\n                hqima0t4uzhfl9qgaq//uvgawgepyhuf2/zaywclogads0mzi+zw6cmxvmrnpusa\n                pagrkczjmdu4+xzn+cxx5iq9xewibny9b5rojwtxt3qcuyz4gkzbq4mwkjupp/iv\n                qo4mjayzoh5yxc4yorq2lvzha2ygsczynljmatgeung01yj6r5mwfwdxl4nc80cn\n                rwnhugexk8j1jyjzu/juk1qrbuboauruippwvdfb845pa7waacg1iduw3ztbkoy3\n                o0bifg2ekrg0nik6stohdua+l2bewcceci8fycejwhm9sg5cxmp2v5m1mby+ukam\n                kewaooyjbmv1mh3ii1b/aqmr+/6ze9mt2knsowosyamfyjxv5r1zzm7cwknot+tu\n                kovghtv1teofvpajntnwtv/oyh3mmlq0f0hgctqomqvqw5+sj7owaasud3cu/dyo\n                pcmy5qe0tnl1jsmneh8ljdqsh+e0hsuxdy1ouvsg3ysf6mdm8ciwb3wrgxih1vmf\n                unfly8ly3v7zic8ehv8aljqh32jizv4i2zxioo4zbkrudkcecy1c2+zb/tzival8\n                qype47q8gi1riyev5uirlzjgpp+jkdugomnzlx334fz9pwtqmyw4y67urai4xuq6\n                /q1zbaehoeeeqk+ykdb7ak/y22ysiqqbnp2n4ckskae4erzlwvtdvsp+49swms/s\n                xggi+13maxip0ecpkyntbjf+now/i3muykr8ebdhrd2xgit06qxqjylscb1tz0zm\n                xgxsoty3b+onq2zjhcovandp7/k77b+gfitlykg4blzsl7gjb12t8mqnpfsmrt4=\n                =ojgs\n                -----end pgp message-----\n\nsops then opens a text editor on the newly created file. the user adds data to the\nfile and saves it when done.\n\nupon save, sops browses the entire file as a key/value tree. every time sops\nencounters a leaf value (a value that does not have children), it encrypts the\nvalue with aes256_gcm using the data key and a 256 bit random initialization\nvector.\n\neach file uses a single data key to encrypt all values of a document, but each\nvalue receives a unique initialization vector and has unique authentication data.\n\nadditional data is used to guarantee the integrity of the encrypted data\nand of the tree structure: when encrypting the tree, key names are concatenated\ninto a byte string that is used as aead additional data (aad) when encrypting\nvalues. we expect that keys do not carry sensitive information, and\nkeeping them in cleartext allows for better diff and overall readability.\n\nany valid kms or pgp master key can later decrypt the data key and access the\ndata.\n\nmultiple master keys allow for sharing encrypted files without sharing master\nkeys, and provide a disaster recovery solution. the recommended way to use sops\nis to have two kms master keys in different regions and one pgp public key with\nthe private key stored offline. if, by any chance, both kms master keys are\nlost, you can always recover the encrypted data using the pgp private key.\n\nmessage authentication code\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin addition to authenticating branches of the tree using keys as additional\ndata, sops computes a mac on all the values to ensure that no value has been\nadded or removed fraudulently. the mac is stored encrypted with aes_gcm and\nthe data key under tree->`sops`->`mac`.\n\nmotivation\n----------\n\nautomating the distribution of secrets and credentials to components of an\ninfrastructure is a hard problem. we know how to encrypt secrets and share them\nbetween humans, but extending that trust to systems is difficult. particularly\nwhen these systems follow devops principles and are created and destroyed\nwithout human intervention. the issue boils down to establishing the initial\ntrust of a system that just joined the infrastructure, and providing it access\nto the secrets it needs to configure itself.\n\nthe initial trust\n~~~~~~~~~~~~~~~~~\n\nin many infrastructures, even highly dynamic ones, the initial trust is\nestablished by a human. an example is seen in puppet by the way certificates are\nissued: when a new system attempts to join a puppetmaster, an administrator\nmust, by default, manually approve the issuance of the certificate the system\nneeds. this is cumbersome, and many puppetmasters are configured to auto-sign\nnew certificates to work around that issue. this is obviously not recommended\nand far from ideal.\n\naws provides a more flexible approach to trusting new systems. it uses a\npowerful mechanism of roles and identities. in aws, it is possible to verify\nthat a new system has been granted a specific role at creation, and it is\npossible to map that role to specific resources. instead of trusting new systems\ndirectly, the administrator trusts the aws permission model and its automation\ninfrastructure. as long as aws keys are safe, and the aws api is secure, we can\nassume that trust is maintained and systems are who they say they are.\n\nkms, trust and secrets distribution\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nusing the aws trust model, we can create fine grained access controls to\namazon's key management service (kms). kms is a service that encrypts and\ndecrypts data with aes_gcm, using keys that are never visible to users of the\nservice. each kms master key has a set of role-based access controls, and\nindividual roles are permitted to encrypt or decrypt using the master key. kms\nhelps solve the problem of distributing keys, by shifting it into an access\ncontrol problem that can be solved using aws's trust model.\n\noperational requirements\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nwhen mozilla's services operations team started revisiting the issue of\ndistributing secrets to ec2 instances, we set a goal to store these secrets\nencrypted until the very last moment, when they need to be decrypted on target\nsystems. not unlike many other organizations that operate sufficiently complex\nautomation, we found this to be a hard problem with a number of prerequisites:\n\n1. secrets must be stored in yaml files for easy integration into hiera\n\n2. secrets must be stored in git, and when a new cloudformation stack is\n   built, the current head is pinned to the stack. (this allows secrets to\n   be changed in git without impacting the current stack that may\n   autoscale).\n\n3. entries must be encrypted separately. encrypting entire files as blobs makes\n   git conflict resolution almost impossible. encrypting each entry\n   separately is much easier to manage.\n\n4. secrets must always be encrypted on disk (admin laptop, upstream\n   git repo, jenkins and s3) and only be decrypted on the target\n   systems\n\nsops can be used to encrypt yaml, json and binary files. in binary mode, the\ncontent of the file is treated as a blob, the same way pgp would encrypt an\nentire file. in yaml and json modes, however, the content of the file is\nmanipulated as a tree where keys are stored in cleartext, and values are\nencrypted. hiera-eyaml does something similar, and over the years we learned\nto appreciate its benefits, namely:\n\n* diffs are meaningful. if a single value of a file is modified, only that\n  value will show up in the diff. the diff is still limited to only showing\n  encrypted data, but that information is already more granular that\n  indicating that an entire file has changed.\n\n* conflicts are easier to resolve. if multiple users are working on the\n  same encrypted files, as long as they don't modify the same values,\n  changes are easy to merge. this is an improvement over the pgp\n  encryption approach where unsolvable conflicts often happen when\n  multiple users work on the same file.\n\nopenpgp integration\n~~~~~~~~~~~~~~~~~~~\n\nopenpgp gets a lot of bad press for being an outdated crypto protocol, and while\ntrue, what really made us look for alternatives is the difficulty of managing and\ndistributing keys to systems. with kms, we manage permissions to an api, not keys,\nand that's a lot easier to do.\n\nbut pgp is not dead yet, and we still rely on it heavily as a backup solution:\nall our files are encrypted with kms and with one pgp public key, with its\nprivate key stored securely for emergency decryption in the event that we lose\nall our kms master keys.\n\nsops can be used without kms entirely, the same way you would use an encrypted\npgp file: by referencing the pubkeys of each individual who has access to the file.\nit can easily be done by providing sops with a comma-separated list of public keys\nwhen creating a new file:\n\n.. code:: bash\n\n\t$ sops --pgp \"e60892bb9bd89a69f759a1a0a3d652173b763e8f,84050f1d61af7c230a12217687df65059ef093d3,85d77543b3d624b63cea9e6dbc17301b491b3f21\" mynewfile.yaml\n\nthreat model\n------------\n\nthe security of the data stored using sops is as strong as the weakest\ncryptographic mechanism. values are encrypted using aes256_gcm which is the\nstrongest symetric encryption algorithm known today. data keys are encrypted\nin either kms, which also uses aes256_gcm, or pgp which uses either rsa or\necdsa keys.\n\ngoing from the most likely to the least likely, the threats are as follows:\n\ncompromised aws credentials grant access to kms master key\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nan attacker with access to an aws console can grant itself access to one of\nthe kms master keys used to encrypt a sops data key. this threat should be\nmitigated by protecting aws accesses with strong controls, such as multi-factor\nauthentication, and also by performing regular audits of permissions granted\nto aws users.\n\ncompromised pgp key\n~~~~~~~~~~~~~~~~~~~\n\npgp keys are routinely mishandled, either because owners copy them from\nmachine to machine, or because the key is left forgotten on an unused machine\nan attacker gains access to. when using pgp encryption, sops users should take\nspecial care of pgp private keys, and store them on smart cards or offline\nas often as possible.\n\nfactorized rsa key\n~~~~~~~~~~~~~~~~~~\n\nsops doesn't apply any restriction on the size or type of pgp keys. a weak pgp\nkeys, for example 512 bits rsa, could be factorized by an attacker to gain\naccess to the private key and decrypt the data key. users of sops should rely\non strong keys, such as 2048+ bits rsa keys, or 256+ bits ecdsa keys.\n\nweak aes cryptography\n~~~~~~~~~~~~~~~~~~~~~\n\na vulnerability in aes256_gcm could potentially leak the data key or the kms\nmaster key used by a sops encrypted file. while no such vulnerability exists\ntoday, we recommend that users keep their encrypted files reasonably private.\n\nbackward compatibility\n----------------------\n\n`sops` will remain backward compatible on the major version, meaning that all\nimprovements brought to the 1.x branch (current) will maintain the file format\nintroduced in **1.0**.\n\nlicense\n-------\nmozilla public license version 2.0\n\nauthors\n-------\n* julien vehent <jvehent@mozilla.com> (lead & maintainer)\n\n* daniel thornton <dthornton@mozilla.com>\n* alexis metaireau <alexis@mozilla.com>\n* r\u00e9my hubscher <natim@mozilla.com>\n* todd wolfson <todd@twolfson.com>\n* brian hourigan <bhourigan@mozilla.com>\n\ncredits\n-------\n\n`sops` is inspired by `hiera-eyaml <https://github.com/tompoulton/hiera-eyaml>`_,\n`credstash <https://github.com/luminaloss/credstash>`_ ,\n`sneaker <https://github.com/codahale/sneaker>`_,\n`password store <http://www.passwordstore.org/>`_ and too many years managing\npgp encrypted files by hand...\n",
  "docs_url": null,
  "keywords": "mozilla secret credential encryption aws kms",
  "license": "mpl",
  "name": "sops",
  "package_url": "https://pypi.org/project/sops/",
  "project_url": "https://pypi.org/project/sops/",
  "project_urls": {
    "Homepage": "https://github.com/mozilla/sops"
  },
  "release_url": "https://pypi.org/project/sops/1.18/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "secrets operations (sops) is an editor of encrypted files",
  "version": "1.18",
  "releases": [],
  "developers": [
    "julien_vehent",
    "jvehent@mozilla.com"
  ],
  "kwds": "sops_key aws_secret_access_key sops_gpg_exec sops_functional_tests_key sops",
  "license_kwds": "mpl",
  "libtype": "pypi",
  "id": "pypi_sops",
  "homepage": "https://github.com/mozilla/sops",
  "release_count": 35,
  "dependency_ids": []
}