{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mozilla public license 2.0 (mpl 2.0)",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "typing :: typed"
  ],
  "description": "# dataclassy\n**dataclassy** is a reimplementation of data classes in python - an alternative to the built-in [dataclasses module](https://docs.python.org/3/library/dataclasses.html) that avoids many of [its](https://stackoverflow.com/questions/54678337) [common](https://stackoverflow.com/q/51575931) [pitfalls](https://stackoverflow.com/q/50180735). dataclassy is designed to be more flexible, less verbose, and more powerful than dataclasses, while retaining a familiar interface.\n\nin short, dataclassy is a library for moving data around your python programs that's optimised for speed, simplicity and developer happiness.\n\n```python\nfrom dataclassy import dataclass\nfrom typing import dict\n\n@dataclass\nclass pet:\n    name: str\n    species: str\n    fluffy: bool\n    foods: dict[str, int] = {}\n```\n\n\n## why use dataclassy?\nthis section describes various motivations for using **dataclassy** over **dataclasses**.\n\n#### backwards compatibility\ndataclassy implements the decorator options of the latest version of dataclasses, plus its own, such that they are compatible back to python 3.6. it is [tested against](.github/workflows/ci.yml) **cpython 3.6 through 3.11** and **pypy 3.6 through 3.9**.\n\n#### upgrade your data classes\n- new decorator options\n    - [`slots`](#slots) generates `__slots__` to reduce memory footprint and improve attribute lookup performance\n    - [`kwargs`](#kwargs) appends `**kwargs` to `__init__`'s parameter list to consume unexpected arguments\n    - [`iter`](#iter) allows class instances to be destructured, like named tuples\n    - [`hide_internals`](#hide_internals) automatically hides private fields from `__repr__` and excludes them from comparison and iteration\n- `@dataclass` usage and options are inherited (subclasses do not have to reuse the decorator)\n- fields can be in any order - fields with defaults are [reordered](#parameter-reordering) - making inheritance feasible\n- mutable default values (`list`, `set`, `dict` and more) are [automatically copied](#default-values) upon initialisation\n- new functions: [`is_dataclass_instance`](#is_dataclass_instanceobj) and [`values`](#valuesdataclass-internalsfalse)\n\n#### additionally, dataclassy\n- implements all the decorator options and functions of dataclasses\n- is tiny (~160 loc; less than 25% the size of dataclasses)\n- has no external dependencies, and no stdlib imports other than `types`, `typing` and `reprlib`\n- is [fast](benchmarks.py), matching dataclasses' performance when `slots=false` and significantly exceeding it when `slots=true`\n- supports multiple inheritance and custom metaclasses\n- comes with [support for mypy](#mypy-support)\n\n#### other differences\ndataclassy's api is strongly influenced by dataclasses', but with a focus on minimalism and elegance.\n\n- there's no `field` or `field`. use [`hashed`](#hashed), [`internal`](#internal) or [`factory`](#factorycreator) to replicate its functions\n- there's no `initvar`. simply add arguments to `__post_init__`\n- there's no need for `classvar`. simply omit the field's type hint to ignore it\n\n#### also consider\n\n- [`attrs`](https://github.com/python-attrs/attrs) if you need complex validation and type conversions\n- [`pydantic`](https://github.com/samuelcolvin/pydantic) if you need strict type checking\n\n\n## usage\n### installation\ninstall the latest release from [pypi](https://pypi.org/project/dataclassy/) with pip:\n\n```console\npip install dataclassy\n```\n\nor install the latest development version straight from this repository:\n\n```console\npip install https://github.com/biqqles/dataclassy/archive/master.zip -u\n```\n\n\n### migration\ndataclassy's api is broadly similar to dataclasses. if you simply use the decorator and other functions, it is possible to instantly migrate from dataclasses to dataclassy by simply changing\n\n```python\nfrom dataclasses import *\n```\n\nto\n\n```python\nfrom dataclassy import *\n```\n\notherwise, you will have to make a couple of easy refactorings (that should leave you with cleaner code!). consult the table under [differences](#differences) or skip ahead to [examples](#examples) to see dataclassy in action.\n\n#### similarities\ndataclassy's `dataclass` decorator takes all of the same arguments as dataclasses', plus its own, and should therefore be a drop-in replacement.\n\ndataclassy also implements all dataclasses' [functions](#functions): `is_dataclass`, `fields`, `replace`, `make_dataclass`, `asdict` and `astuple` (the last two are aliased from `as_dict` and `as_tuple` respectively), and they should work as you expect.\n\n#### differences\nalthough dataclassy's api is similar to dataclasses', [compatibility with it is not a goal](https://straight-shoota.github.io/crystal-book/feature/tutorials-initial/) (this is similar to the relationship between crystal and ruby).\n\ndataclassy has several important differences from dataclasses, mainly reflective of its minimalistic style and implementation. these differences are enumerated below and fully expanded on in the next section.\n\n|                                 |dataclasses                                 |dataclassy                              |\n|---------------------------------|:-------------------------------------------|:---------------------------------------|\n|*init-only variables*            |fields with type `initvar`                  |arguments to `__post_init__`            |\n|*class variables*                |fields with type `classvar`                 |fields without type annotation          |\n|*mutable defaults*               |`a: dict = field(default_factory=dict)`     |`a: dict = {}`                          |\n|*dynamic defaults*               |`b: myclass = field(default_factory=myclass)`|`b: myclass = factory(myclass)`        |\n|*field excluded from `repr`*     |`c: int = field(repr=false)`                |`internal` type wrapper or `_name`      |\n|*\"late init\" field*              |`d: int = field(init=false)`                |`d: int = none`                         |\n|*abstract data class*            |`class foo(abc):`                           |`class foo(metaclass=abcmeta):`         |\n\nthere are a couple of minor differences, too:\n\n- `fields` returns `dict[str, type]` instead of `dict[field, type]` and has an additional parameter which filters internal fields\n- attempting to modify a frozen instance raises `attributeerror` with an explanation rather than `frozeninstanceerror`\n\nfinally, there are some quality of life improvements that, while not being directly implicated in migration, will allow you to make your code cleaner:\n\n- `@dataclass` does not need to be applied to every subclass - its behaviour and options are inherited\n- unlike dataclasses, fields with defaults do not need to follow those without them. this is particularly useful when working with subclasses, which is almost impossible with dataclasses\n- dataclassy adds a `dataclass` type annotation to represent variables that should be generic data class instances\n- dataclassy has the `is_dataclass_instance` suggested as a [recipe](https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass) for dataclasses built-in\n- the generated comparison methods (when `order=true`) are compatible with supertypes and subtypes of the class. this means that heterogeneous collections of instances with the same superclass can be sorted\n\nit is also worth noting that internally, dataclasses and dataclassy work in different ways. you can think of dataclassy as _turning your class into a different type of thing_ (indeed, it uses a metaclass) and dataclasses as merely _adding things to your class_ (it does not).\n\n\n### examples\n#### the basics\nto define a data class, simply apply the `@dataclass` decorator to a class definition ([see above](#dataclassy)).\n\nwithout arguments to the decorator, the resulting class will behave very similarly to its equivalent from the built-in module. however, dataclassy's decorator has some additional options over dataclasses', and it is also inherited so that subclasses of data classes are automatically data classes too.\n\nthe decorator generates various methods for the class. which ones exactly depend on the options to the decorator. for example, `@dataclass(repr=false)` will prevent a `__repr__` method from being generated. `@dataclass` is equivalent to using the decorator with default parameters (i.e. `@dataclass` and `@dataclass()` are equivalent). options to the decorator are detailed fully in the [next section](#decorator-options).\n\n#### class variables\nyou can exclude a class attribute from dataclassy's mechanisms entirely by simply defining it without a type annotation. this can be used for class variables and constants.\n\n#### parameter reordering\ndataclassy modifies the order of fields when converting them into parameters for the generated `__init__`. specifically, fields with default values always follow those without them. this stems from python's requirement that _parameters_ with default arguments follow those without them. conceptually, you can think of the process to generate the parameter list like this:\n\n1. dataclassy takes the fields in definition order\n2. it splits them into two lists, the first being fields without default values and the second being fields with them\n3. it appends the second list to the first\n\nthis simple design decision prevents the dreaded `typeerror: non-default argument '...' follows default argument` error that anyone who has tried to do serious inheritance using dataclasses will know well.\n\nyou can verify the signature of the generated initialiser for any class using `signature` from the `inspect` module. for example, using the definition linked to above, `inspect.signature(pet)` will return `(name: str, species: str, fluffy: bool, foods: dict[str, int] = {}))`.\n\nif we then decided to subclass `pet` to add a new field, `hungry`:\n\n```python\n@dataclass\nclass hungrypet(pet):\n    hungry: bool\n```\n\nyou will see that `inspect.signature(hungrypet)` returns `(name: str, species: str, fluffy: bool, hungry: bool, foods: dict[str, int] = {})`.\n\n#### inheritance\nunlike dataclasses, dataclassy's decorator only needs to be applied once, and all subclasses will become data classes with the same options as the parent class. the decorator can still be reapplied to subclasses in order to apply new parameters.\n\nto change the type, or to add or change the default value of a field in a subclass, simply redeclare it in the subclass.\n\n#### post-initialisation processing\nif an initialiser is requested (`init=true`), dataclassy automatically sets the attributes of the class upon initialisation. you can define code that should run after this happens - this is called _post-init processing_.  \n\nthe method that contains this logic should be called `__post_init__`. like with dataclasses, if `init=false` or the class has no fields, `__post_init__` will not be called.\n\n```python\n@dataclass\nclass custominit:\n    a: int\n    b: int\n    \n    def __post_init__(self):\n        self.c = self.a / self.b\n```\n\nin this example, when the class is instantiated with `custominit(1, 2)`, the field `c` is calculated as `0.5`.\n\nlike with any function, your `__post_init__` can also take parameters which exist only in the context of `__post_init__`. these can be used for arguments to the class that you do not want to store as fields. a parameter cannot have the name of a class field; this is to prevent ambiguity.\n\n#### default values\ndefault values for fields work exactly as default arguments to functions (and in fact this is how they are implemented), with one difference: for copyable defaults, a copy is automatically created for each class instance. this means that a new copy of the `list` field `foods` in `pet` above will be created each time it is instantiated, so that appending to that attribute in one instance will not affect other instances. a \"copyable default\" is defined as any object implementing a `copy` method, which includes all the built-in mutable collections (including `defaultdict`).\n\nif you want to create new instances of objects which do not have a `copy` method, use the [`factory`](#factorycreator) function. this function takes any zero-argument callable. when the class is instantiated, this callable is executed to produce a default value for the field:\n\n```python\nclass myclass:\n    pass\n\n@dataclass\nclass customdefault:\n    m: myclass = factory(myclass)\n\ncustomdefault()  # customdefault(m=<__main__.myclass object at 0x7f8b156feb50>)\ncustomdefault()  # customdefault(m=<__main__.myclass object at 0x7f8b156fc7d0>)\n```\n\n## api\n### decorator\n#### `@dataclass(init=true, repr=true, eq=true, order=false, unsafe_hash=false, frozen=false, hide_internals=true, iter=false, kwargs=false, slots=false, meta=dataclassmeta)`\nthe decorator used to signify that a class definition should become a data class. the decorator returns a new data class with generated methods as detailed below. if the class already defines a particular method, it will not be replaced with a generated one.\n\nwithout arguments, its behaviour is, superficially, almost identical to its equivalent in the built-in module. however, dataclassy's decorator only needs to be applied once, and all subclasses will become data classes with the same parameters. the decorator can still be reapplied to subclasses in order to change parameters.\n\na data class' fields are defined using python's type annotations syntax. to change the type or default value of a field in a subclass, simply redeclare it.\n\nthis decorator takes advantage of two equally important features added in python 3.6: [variable annotations](https://docs.python.org/3/glossary.html#term-variable-annotation) and [dictionaries being ordered](https://docs.python.org/3.7/tutorial/datastructures.html#dictionaries). (the latter is technically an [implementation detail](https://docs.python.org/3.6/whatsnew/3.6.html#whatsnew36-compactdict) of python 3.6, only becoming standardised in python 3.7, but is the case for all current implementations of python 3.6, i.e. cpython and pypy.)\n\n\n#### decorator options\n> the term \"field\", as used in this section, refers to a class-level variable with a type annotation. for more information, see the documentation for [`fields()`](#fieldsdataclass-internalsfalse) below.\n\n##### `init`\nif true (the default), generate an [`__init__`](https://docs.python.org/3/reference/datamodel.html#object.__init__) method that has as parameters all fields up its inheritance chain. these are ordered in definition order, with all fields with default values placed towards the end, following all fields without them. the method initialises the class by applying these parameters to the class as attributes. if defined, it will also call `__post_init__` with any remaining arguments.\n\nthis ordering is an important distinction from dataclasses, where all fields are simply ordered in definition order, and is what allows dataclassy's data classes to be far more flexible in terms of inheritance. \n\na shallow copy will be created for mutable arguments (defined as those defining a `copy` method). this means that default field values that are mutable (e.g. a list) will not be mutated between instances.\n\n##### `repr`\nif true (the default), generate a [`__repr__`](https://docs.python.org/3/reference/datamodel.html#object.__repr__) method that displays all fields (or if [`hide_internals`](#hide_internals) is true, all fields excluding [internal](#internal) ones) of the data class instance and their values.\n\n##### `eq`\nif true (the default), generate an [`__eq__`](https://docs.python.org/3/reference/datamodel.html#object.__eq__) method that compares this data class to another of the same type as if they were tuples created by [`as_tuple`](#as_tupledataclass), excluding [internal fields](#internal) if [`hide_internals`](#hide_internals) is true.\n\n##### `order`\nif true, a [`__lt__`](https://docs.python.org/3/reference/datamodel.html#object.__lt__) method is generated, making the class *orderable*. if `eq` is also true, all other comparison methods are also generated. these methods compare this data class to another of the same type (or a subclass) as if they were tuples created by [`as_tuple`](#as_tupledataclass), excluding [internal fields](#internal) if [`hide_internals`](#hide_internals) is true. the normal rules of [lexicographical comparison](https://docs.python.org/3/reference/expressions.html#value-comparisons) apply.\n\n##### `unsafe_hash`\nif true, force the generation of a [`__hash__`](https://docs.python.org/3/reference/datamodel.html#object.__hash__) method that attempts to hash the class as if it were a tuple of its hashable fields. if `unsafe_hash` is false, `__hash__` will only be generated if `eq` and `frozen` are both true.\n\n##### `match_args`\nif true (the default), generate a `__match_args__` attribute that enables structural pattern matching on python 3.10+.\n\n##### `kw_only`\nif true, all parameters to the generated `__init__` are marked as [keyword-only](https://peps.python.org/pep-3102). this includes arguments passed through to `__post_init__`.\n\n##### `frozen`\nif true, instances are nominally immutable: fields cannot be overwritten or deleted after initialisation in `__init__`. attempting to do so will raise an `attributeerror`. **warning: incurs a significant initialisation performance penalty.**\n\n##### `hide_internals`\nif true (the default), [internal fields](#internal) are not included in the generated [`__repr__`](#repr), comparison functions ([`__eq__`](#eq), [ `__lt__`](#order), etc.), or [`__iter__`](#iter).\n\n##### `iter`\nif true, generate an [`__iter__`](https://docs.python.org/3/reference/datamodel.html#object.__iter__) method that returns the values of the class's fields, in order of definition, noting that [internal fields](#internal) are excluded when [`hide_internals`](#hide_internals) is true. this can be used to destructure a data class instance, as with a scala `case class` or a python `namedtuple`.\n\n##### `kwargs`\nif true, add [`**kwargs`](https://docs.python.org/3.3/glossary.html#term-parameter) to the end of the parameter list for `__init__`. this simplifies data class instantiation from dictionaries that may have keys in addition to the fields of the data class (i.e. `somedataclass(**some_dict)`).\n\n##### `slots`\nif true, generate a [`__slots__`](https://docs.python.org/3/reference/datamodel.html#slots) attribute for the class. this reduces the memory footprint of instances and attribute lookup overhead. however, `__slots__` come with a few [restrictions](https://docs.python.org/3/reference/datamodel.html#notes-on-using-slots) (for example, multiple inheritance becomes tricky) that you should be aware of.\n\n##### `meta`\nset this parameter to use a metaclass other than dataclassy's own. this metaclass must subclass [`dataclassy.dataclass.dataclassmeta`](dataclassy/dataclass.py).\n\n`dataclassmeta` is best considered less stable than the parts of the library available in the root namespace. only use a custom metaclass if absolutely necessary.\n\n\n### functions\n#### `factory(producer)`\ntakes a zero-argument callable and creates a _factory_ that executes this callable to generate a default value for the field at class initialisation time.\n\n#### `is_dataclass(obj)`\nreturns true if `obj` is a data class as implemented in this module.\n\n#### `is_dataclass_instance(obj)`\nreturns true if `obj` is an instance of a data class as implemented in this module.\n\n#### `fields(dataclass, internals=false)`\nreturn a dict of `dataclass`'s fields and their types. `internals` selects whether to include internal fields. `dataclass` can be either a data class or an instance of a data class.\n\na field is defined as a class-level variable with a [type annotation](https://docs.python.org/3/glossary.html#term-variable-annotation). variables defined in the class without type annotations are completely excluded from dataclassy's consideration. class variables and constants can therefore be indicated by the absence of type annotations.\n\n#### `values(dataclass, internals=false)`\nreturn a dict of `dataclass`'s fields and their values. `internals` selects whether to include internal fields. `dataclass` must be an instance of a data class.\n\n#### `as_dict(dataclass dict_factory=dict)`\nrecursively create a dict of a data class instance's fields and their values.\n\nthis function is recursively called on data classes, named tuples and iterables.\n\n#### `as_tuple(dataclass)`\nrecursively create a tuple of the values of a data class instance's fields, in definition order.\n\nthis function is recursively called on data classes, named tuples and iterables.\n\n#### `make_dataclass(name, fields, defaults, bases=(), **options)`\ndynamically create a data class with name `name`, fields `fields`, default field values `defaults` and inheriting from `bases`.\n\n#### `replace(dataclass, **changes)`\nreturn a new copy of `dataclass` with field values replaced as specified in `changes`.\n\n### type hints\n#### `internal`\nthe `internal` type wrapper marks a field as being \"internal\" to the data class. fields which begin with the [\"internal use\"](https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles) idiomatic indicator `_` or the [private field](https://docs.python.org/3/tutorial/classes.html#private-variables) interpreter indicator `__` are automatically treated as internal fields.  the `internal` type wrapper therefore serves as an alternative method of indicating that a field is internal for situations where you are unable to name your fields in this way.\n\n#### `hashed`\nuse `hashed` to wrap the type annotations of fields that you want to be included in a data class' `__hash__`. the value hashed by `__hash__` consists of a tuple of the instance's type followed by any fields marked as `hashed`.\n\n#### `dataclass`\nuse this type hint to indicate that a variable, parameter or field should be a generic data class instance. for example, dataclassy uses these in the signatures of `as_dict`, `as_tuple` and `values` to show that these functions should be called on data class instances.\n\n### mypy support\nin order to use dataclassy in projects with mypy, you will need to use the mypy plugin. you can create a `mypy.ini` or `.mypy.ini` for such projects with the following content:\n\n```ini\n[mypy]\nplugins = dataclassy.mypy\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "dataclassy",
  "package_url": "https://pypi.org/project/dataclassy/",
  "project_url": "https://pypi.org/project/dataclassy/",
  "project_urls": {
    "Homepage": "https://github.com/biqqles/dataclassy"
  },
  "release_url": "https://pypi.org/project/dataclassy/1.0.1/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "a fast and flexible reimplementation of data classes",
  "version": "1.0.1",
  "releases": [],
  "developers": [
    "biqqles",
    "biqqles@proton.me"
  ],
  "kwds": "dataclassy dataclasses dataclass make_dataclass is_dataclass_instance",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_dataclassy",
  "homepage": "https://github.com/biqqles/dataclassy",
  "release_count": 25,
  "dependency_ids": []
}