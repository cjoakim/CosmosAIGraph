{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: text processing",
    "topic :: text processing :: markup :: html",
    "topic :: utilities"
  ],
  "description": "==================================================================================\ninscriptis -- html to text conversion library, command line client and web service\n==================================================================================\n\n.. image:: https://img.shields.io/pypi/pyversions/inscriptis   \n   :target: https://badge.fury.io/py/inscriptis\n   :alt: supported python versions\n\n.. image:: https://api.codeclimate.com/v1/badges/f8ed73f8a764f2bc4eba/maintainability\n   :target: https://codeclimate.com/github/weblyzard/inscriptis/maintainability\n   :alt: maintainability\n\n.. image:: https://codecov.io/gh/weblyzard/inscriptis/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/weblyzard/inscriptis/\n   :alt: coverage\n\n.. image:: https://github.com/weblyzard/inscriptis/actions/workflows/python-package.yml/badge.svg\n   :target: https://github.com/weblyzard/inscriptis/actions/workflows/python-package.yml\n   :alt: build status\n\n.. image:: https://readthedocs.org/projects/inscriptis/badge/?version=latest\n   :target: https://inscriptis.readthedocs.io/en/latest/?badge=latest\n   :alt: documentation status\n\n.. image:: https://badge.fury.io/py/inscriptis.svg\n   :target: https://badge.fury.io/py/inscriptis\n   :alt: pypi version\n\n.. image:: https://pepy.tech/badge/inscriptis\n   :target: https://pepy.tech/project/inscriptis\n   :alt: pypi downloads\n\n.. image:: https://joss.theoj.org/papers/10.21105/joss.03557/status.svg\n   :target: https://doi.org/10.21105/joss.03557\n\n\na python based html to text conversion library, command line client and web\nservice with support for **nested tables**, a **subset of css** and optional\nsupport for providing an **annotated output**. \n\ninscriptis is particularly well suited for applications that require high-performance, high-quality (i.e., layout-aware) text representations of html content, and will aid knowledge extraction and data science tasks conducted upon web data.\n\nplease take a look at the\n`rendering <https://github.com/weblyzard/inscriptis/blob/master/rendering.md>`_\ndocument for a demonstration of inscriptis' conversion quality.\n\na java port of inscriptis 1.x has been published by\n`x28 <https://github.com/x28/inscriptis-java>`_.\n\nthis document provides a short introduction to inscriptis. \n\n- the full documentation is built automatically and published on `read the docs <https://inscriptis.readthedocs.org/en/latest/>`_. \n- if you are interested in a more general overview on the topic of *text extraction from html*, this `blog post on different html to text conversion approaches, and criteria for selecting them <https://www.semanticlab.net/linux/big%20data/knowledge%20extraction/extracting-text-from-html-with-python/>`_ might be interesting to you.\n\n.. contents:: table of contents\n\nstatement of need - why inscriptis?\n===================================\n\n1. inscriptis provides a **layout-aware** conversion of html that more closely resembles the rendering obtained from standard web browsers and, therefore, better preserves the spatial arrangement of text elements. \n\n   conversion quality becomes a factor once you need to move beyond simple html snippets. non-specialized approaches and less sophisticated libraries do not correctly interpret html semantics and, therefore, fail to properly convert constructs such as itemizations, enumerations, and tables.\n\n   beautiful soup's ``get_text()`` function, for example, converts the following html enumeration to the string ``firstsecond``.\n\n   .. code-block:: html\n   \n      <ul>\n        <li>first</li>\n        <li>second</li>\n      <ul>\n\n\n   inscriptis, in contrast, not only returns the correct output\n   \n   .. code-block::\n   \n      * first\n      * second\n\n   but also supports much more complex constructs such as nested tables and also interprets a subset of html (e.g., ``align``, ``valign``) and css (e.g., ``display``, ``white-space``, ``margin-top``, ``vertical-align``, etc.) attributes that determine the text alignment. any time the spatial alignment of text is relevant (e.g., for many knowledge extraction tasks, the computation of word embeddings and language models, and sentiment analysis) an accurate html to text conversion is essential.\n\n2. inscriptis supports `annotation rules <#annotation-rules>`_, i.e., user-provided mappings that allow for annotating the extracted text based on structural and semantic information encoded in html tags and attributes used for controlling structure and layout in the original html document. these rules might be used to\n\n   - provide downstream knowledge extraction components with additional information that may be leveraged to improve their respective performance.\n   - assist manual document annotation processes (e.g., for qualitative analysis or gold standard creation). ``inscriptis`` supports multiple export formats such as xml, annotated html and the jsonl format that is used by the open source annotation tool `doccano <https://github.com/doccano/doccano>`_.\n   - enabling the use of ``inscriptis``  for tasks such as content extraction (i.e., extract task-specific relevant content from a web page) which rely on information on the html document's structure.\n\n\ninstallation\n============\n\nat the command line::\n\n    $ pip install inscriptis\n\nor, if you don't have pip installed::\n\n    $ easy_install inscriptis\n\nif you want to install from the latest sources, you can do::\n\n    $ git clone https://github.com/weblyzard/inscriptis.git\n    $ cd inscriptis\n    $ python setup.py install\n\n\npython library\n==============\n\nembedding inscriptis into your code is easy, as outlined below:\n\n.. code-block:: python\n   \n   import urllib.request\n   from inscriptis import get_text\n   \n   url = \"https://www.fhgr.ch\"\n   html = urllib.request.urlopen(url).read().decode('utf-8')\n   \n   text = get_text(html)\n   print(text)\n\n\nstandalone command line client\n==============================\nthe command line client converts html files or text retrieved from web pages to\nthe corresponding text representation.\n\n\ncommand line parameters\n-----------------------\n\nthe inscript.py command line client supports the following parameters::\n\n    usage: inscript.py [-h] [-o output] [-e encoding] [-i] [-d] [-l] [-a] [-r annotation_rules] [-p postprocessor] [--indentation indentation]\n                       [--table-cell-separator table_cell_separator] [-v]\n                       [input]\n\n    convert the given html document to text.\n\n    positional arguments:\n      input                 html input either from a file or a url (default:stdin).\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      -o output, --output output\n                            output file (default:stdout).\n      -e encoding, --encoding encoding\n                            input encoding to use (default:utf-8 for files; detected server encoding for web urls).\n      -i, --display-image-captions\n                            display image captions (default:false).\n      -d, --deduplicate-image-captions\n                            deduplicate image captions (default:false).\n      -l, --display-link-targets\n                            display link targets (default:false).\n      -a, --display-anchor-urls\n                            display anchor urls (default:false).\n      -r annotation_rules, --annotation-rules annotation_rules\n                            path to an optional json file containing rules for annotating the retrieved text.\n      -p postprocessor, --postprocessor postprocessor\n                            optional component for postprocessing the result (html, surface, xml).\n      --indentation indentation\n                            how to handle indentation (extended or strict; default: extended).\n      --table-cell-separator table_cell_separator\n                            separator to use between table cells (default: three spaces).\n      -v, --version         display version information\n\n   \n\nhtml to text conversion\n-----------------------\nconvert the given page to text and output the result to the screen::\n\n  $ inscript.py https://www.fhgr.ch\n   \nconvert the file to text and save the output to fhgr.txt::\n\n  $ inscript.py fhgr.html -o fhgr.txt\n\nconvert the file using strict indentation (i.e., minimize indentation and extra spaces) and save the output to fhgr-layout-optimized.txt::\n\n  $ inscript.py --indentation strict fhgr.html -o fhgr-layout-optimized.txt\n   \nconvert html provided via stdin and save the output to output.txt::\n\n  $ echo \"<body><p>make it so!</p></body>\" | inscript.py -o output.txt \n\n\nhtml to annotated text conversion\n---------------------------------\nconvert and annotate html from a web page using the provided annotation rules. \n\ndownload the example `annotation-profile.json <https://github.com/weblyzard/inscriptis/blob/master/examples/annotation-profile.json>`_ and save it to your working directory::\n\n  $ inscript.py https://www.fhgr.ch -r annotation-profile.json\n\nthe annotation rules are specified in `annotation-profile.json`:\n\n.. code-block:: json\n\n   {\n    \"h1\": [\"heading\", \"h1\"],\n    \"h2\": [\"heading\", \"h2\"],\n    \"b\": [\"emphasis\"],\n    \"div#class=toc\": [\"table-of-contents\"],\n    \"#class=factbox\": [\"fact-box\"],\n    \"#cite\": [\"citation\"]\n   }\n\nthe dictionary maps an html tag and/or attribute to the annotations\ninscriptis should provide for them. in the example above, for instance, the tag\n``h1`` yields the annotations ``heading`` and ``h1``, a ``div`` tag with a\n``class`` that contains the value ``toc`` results in the annotation\n``table-of-contents``, and all tags with a ``cite`` attribute are annotated with\n``citation``.\n\ngiven these annotation rules the html file\n\n.. code-block:: html\n\n   <h1>chur</h1>\n   <b>chur</b> is the capital and largest town of the swiss canton of the\n   grisons and lies in the grisonian rhine valley.\n\nyields the following jsonl output\n\n.. code-block:: json\n\n   {\"text\": \"chur\\n\\nchur is the capital and largest town of the swiss canton\n             of the grisons and lies in the grisonian rhine valley.\",\n    \"label\": [[0, 4, \"heading\"], [0, 4, \"h1\"], [6, 10, \"emphasis\"]]}\n\nthe provided list of labels contains all annotated text elements with their\nstart index, end index and the assigned label.\n\n\nannotation postprocessors\n-------------------------\nannotation postprocessors enable the post processing of annotations to formats\nthat are suitable for your particular application. post processors can be\nspecified with the ``-p`` or ``--postprocessor`` command line argument::\n\n  $ inscript.py https://www.fhgr.ch \\\n          -r ./examples/annotation-profile.json \\\n          -p surface\n\n\noutput:\n\n.. code-block:: json\n\n   {\"text\": \"  chur\\n\\n  chur is the capital and largest town of the swiss\n             canton of the grisons and lies in the grisonian rhine valley.\",\n    \"label\": [[0, 6, \"heading\"], [8, 14, \"emphasis\"]],\n    \"tag\": \"<heading>chur</heading>\\n\\n<emphasis>chur</emphasis> is the\n           capital and largest town of the swiss canton of the grisons and\n           lies in the grisonian rhine valley.\"}\n\n\n\ncurrently, inscriptis supports the following postprocessors:\n\n- surface: returns a list of mapping between the annotation's surface form and its label::\n\n    [\n       ['heading', 'chur'], \n       ['emphasis': 'chur']\n    ]\n\n- xml: returns an additional annotated text version::\n\n    <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n    <heading>chur</heading>\n\n    <emphasis>chur</emphasis> is the capital and largest town of the swiss\n    canton of the grisons and lies in the grisonian rhine valley.\n\n- html: creates an html file which contains the converted text and highlights all annotations as outlined below:\n\n.. figure:: https://github.com/weblyzard/inscriptis/raw/master/docs/paper/images/annotations.png\n   :align: left\n   :alt: annotations extracted from the wikipedia entry for chur with the ``--postprocess html`` postprocessor.\n\n   snippet of the rendered html file created with the following command line options and annotation rules:\n\n   .. code-block:: bash\n\n      inscript.py --annotation-rules ./wikipedia.json \\\n                  --postprocessor html \\\n                  https://en.wikipedia.org/wiki/chur.html\n\n   annotation rules encoded in the ``wikipedia.json`` file:\n\n   .. code-block:: json\n\n      {\n        \"h1\": [\"heading\"],\n        \"h2\": [\"heading\"],\n        \"h3\": [\"subheading\"],\n        \"h4\": [\"subheading\"],\n        \"h5\": [\"subheading\"],\n        \"i\": [\"emphasis\"],\n        \"b\": [\"bold\"],\n        \"table\": [\"table\"],\n        \"th\": [\"tableheading\"],\n        \"a\": [\"link\"]\n      } \n\n\nweb service\n===========\n\nthe flask web service translates html pages to the corresponding plain text.\n\nrun the web service on your host system\n---------------------------------------\nprovide additional requirement `python3-flask <https://flask.palletsprojects.com/en/2.2.x/>`_, then start the inscriptis web service with the following command::\n\n  $ export flask_app=\"inscriptis.service.web\"\n  $ python3 -m flask run\n\nrun the web service with docker\n-------------------------------\n\nthe docker definition can be found `here <https://github.com/weblyzard/inscriptis/pkgs/container/inscriptis>`_::\n  \n  $ docker pull ghcr.io/weblyzard/inscriptis:latest\n  $ docker run -n inscriptis ghcr.io/weblyzard/inscriptis:latest\n\nrun as kubernetes deployment\n--------------------------------------\n\nthe helm chart for deployment on a kubernetes cluster is located in the `inscriptis-helm repository <https://github.com/weblyzard/inscriptis-helm>`_.\n\nuse the web service\n-------------------\n\nthe web services receives the html file in the request body and returns the\ncorresponding text. the file's encoding needs to be specified\nin the ``content-type`` header (``utf-8`` in the example below)::\n\n  $ curl -x post  -h \"content-type: text/html; encoding=utf8\"  \\\n          --data-binary @test.html  http://localhost:5000/get_text\n\nthe service also supports a version call::\n\n  $ curl http://localhost:5000/version\n\n\nexample annotation profiles\n===========================\n\nthe following section provides a number of example annotation profiles illustrating the use of inscriptis' annotation support.\nthe examples present the used annotation rules and an image that highlights a snippet with the annotated text on the converted web page, which has been \ncreated using the html postprocessor as outlined in section `annotation postprocessors <#annotation-postprocessors>`_.\n\nwikipedia tables and table metadata\n-----------------------------------\n\n\nthe following annotation rules extract tables from wikipedia pages, and annotate table headings that are typically used to indicate column or row headings.\n\n.. code-block:: json\n\n   {\n      \"table\": [\"table\"],\n      \"th\": [\"tableheading\"],\n      \"caption\": [\"caption\"]\n   }\n\nthe figure below outlines an example table from wikipedia that has been annotated using these rules.\n\n.. figure:: https://github.com/weblyzard/inscriptis/raw/master/docs/images/wikipedia-chur-table-annotation.png\n   :alt: table and table metadata annotations extracted from the wikipedia entry for chur.\n\n\nreferences to entities, missing entities and citations from wikipedia\n---------------------------------------------------------------------\n\nthis profile extracts references to wikipedia entities, missing entities and citations. please note that the profile isn't perfect, since it also annotates ``[ edit ]`` links.\n\n.. code-block:: json\n\n   {\n      \"a#title\": [\"entity\"],\n      \"a#class=new\": [\"missing\"],\n      \"class=reference\": [\"citation\"]\n   }\n\nthe figure shows entities and citations that have been identified on a wikipedia page using these rules.\n\n.. figure:: https://github.com/weblyzard/inscriptis/raw/master/docs/images/wikipedia-chur-entry-annotation.png\n   :alt: metadata on entries, missing entries and citations extracted from the wikipedia entry for chur.\n\n\n\n\n\nposts and post metadata from the xda developer forum\n----------------------------------------------------\n\nthe annotation rules below, extract posts with metadata on the post's time, user and the user's job title from the xda developer forum.\n\n.. code-block:: json\n\n   {\n       \"article#class=message-body\": [\"article\"],\n       \"li#class=u-concealed\": [\"time\"],\n       \"#itemprop=name\": [\"user-name\"],\n       \"#itemprop=jobtitle\": [\"user-title\"]\n   }\n\nthe figure illustrates the annotated metadata on posts from the xda developer forum.\n\n.. figure:: https://github.com/weblyzard/inscriptis/raw/master/docs/images/xda-posts-annotation.png\n   :alt: posts and post metadata extracted from the xda developer forum.\n\n\n\ncode and metadata from stackoverflow pages\n------------------------------------------\nthe rules below extracts code and metadata on users and comments from stackoverflow pages.\n\n.. code-block:: json\n\n   {\n      \"code\": [\"code\"],\n      \"#itemprop=datecreated\": [\"creation-date\"],\n      \"#class=user-details\": [\"user\"],\n      \"#class=reputation-score\": [\"reputation\"],\n      \"#class=comment-date\": [\"comment-date\"],\n      \"#class=comment-copy\": [\"comment-comment\"]\n   }\n\napplying these rules to a stackoverflow page on text extraction from html yields the following snippet:\n\n.. figure:: https://github.com/weblyzard/inscriptis/raw/master/docs/images/stackoverflow-code-annotation.png\n   :alt: code and metadata from stackoverflow pages.\n\n\nadvanced topics\n===============\n\nannotated text\n--------------\ninscriptis can provide annotations alongside the extracted text which allows\ndownstream components to draw upon semantics that have only been available in\nthe original html file.\n\nthe extracted text and annotations can be exported in different formats,\nincluding the popular jsonl format which is used by\n`doccano <https://github.com/doccano/doccano>`_.\n\nexample output:\n\n.. code-block:: json\n\n   {\"text\": \"chur\\n\\nchur is the capital and largest town of the swiss canton\n             of the grisons and lies in the grisonian rhine valley.\",\n    \"label\": [[0, 4, \"heading\"], [0, 4, \"h1\"], [6, 10, \"emphasis\"]]}\n\nthe output above is produced, if inscriptis is run with the following\nannotation rules:\n\n.. code-block:: json\n\n   {\n    \"h1\": [\"heading\", \"h1\"],\n    \"b\": [\"emphasis\"],\n   }\n\nthe code below demonstrates how inscriptis' annotation capabilities can\nbe used within a program:\n\n.. code-block:: python\n\n  import urllib.request\n  from inscriptis import get_annotated_text, parserconfig\n\n  url = \"https://www.fhgr.ch\"\n  html = urllib.request.urlopen(url).read().decode('utf-8')\n\n  rules = {'h1': ['heading', 'h1'],\n           'h2': ['heading', 'h2'],\n           'b': ['emphasis'],\n           'table': ['table']\n          }\n\n  output = get_annotated_text(html, parserconfig(annotation_rules=rules)\n  print(\"text:\", output['text'])\n  print(\"annotations:\", output['label'])\n\nfine tuning\n-----------\n\nthe following options are available for fine tuning inscriptis' html rendering:\n\n1. **more rigorous indentation:** call ``inscriptis.get_text()`` with the\n   parameter ``indentation='extended'`` to also use indentation for tags such as\n   ``<div>`` and ``<span>`` that do not provide indentation in their standard\n   definition. this strategy is the default in ``inscript.py`` and many other\n   tools such as lynx. if you do not want extended indentation you can use the\n   parameter ``indentation='standard'`` instead.\n\n2. **overwriting the default css definition:** inscriptis uses css definitions\n   that are maintained in ``inscriptis.css.css`` for rendering html tags. you can\n   override these definitions (and therefore change the rendering) as outlined\n   below:\n\n.. code-block:: python\n\n      from lxml.html import fromstring\n      from inscriptis.css_profiles import css_profiles, htmlelement\n      from inscriptis.html_properties import display\n      from inscriptis.model.config import parserconfig\n      \n      # create a custom css based on the default style sheet and change the\n      # rendering of `div` and `span` elements\n      css = css_profiles['strict'].copy()\n      css['div'] = htmlelement(display=display.block, padding=2)\n      css['span'] = htmlelement(prefix=' ', suffix=' ')\n      \n      html_tree = fromstring(html)\n      # create a parser using a custom css\n      config = parserconfig(css=css)\n      parser = inscriptis(html_tree, config)  usage: inscript.py [-h] [-o output] [-e encoding] [-i] [-d] [-l] [-a] [-r annotation_rules] [-p postprocessor]\n                     [--indentation indentation] [-v]\n                     [input]\n\n  convert the given html document to text.\n\n  positional arguments:\n    input                 html input either from a file or a url (default:stdin).\n\n  optional arguments:\n    -h, --help            show this help message and exit\n    -o output, --output output\n                          output file (default:stdout).\n    -e encoding, --encoding encoding\n                          input encoding to use (default:utf-8 for files; detected server encoding for web urls).\n    -i, --display-image-captions\n                          display image captions (default:false).\n    -d, --deduplicate-image-captions\n                          deduplicate image captions (default:false).\n    -l, --display-link-targets\n                          display link targets (default:false).\n    -a, --display-anchor-urls\n                          display anchor urls (default:false).\n    -r annotation_rules, --annotation-rules annotation_rules\n                          path to an optional json file containing rules for annotating the retrieved text.\n    -p postprocessor, --postprocessor postprocessor\n                          optional component for postprocessing the result (html, surface, xml).\n    --indentation indentation\n                          how to handle indentation (extended or strict; default: extended).\n    -v, --version         display version information\n      text = parser.get_text()\n\n\ncustom html tag handling\n------------------------\n\nif the fine-tuning options discussed above are not sufficient, you may even override inscriptis' handling of start and end tags as outlined below:\n\n.. code-block:: python\n\n    inscriptis = inscriptis(html, config)\n\n    inscriptis.start_tag_handler_dict['a'] = my_handle_start_a\n    inscriptis.end_tag_handler_dict['a'] = my_handle_end_a\n    text = inscriptis.get_text()\n\t\t\n\nin the example the standard html handlers for the ``a`` tag are overwritten with custom versions (i.e., ``my_handle_start_a`` and ``my_handle_end_a``).\nyou may define custom handlers for any tag, regardless of whether it already exists in ``start_tag_handler_dict`` or ``end_tag_handler_dict``. \n\noptimizing memory consumption\n-----------------------------\n\ninscriptis uses the python lxml library which prefers to reuse memory rather than release it to the operating system. this behavior might lead to an increased memory consumption, if you use inscriptis within a web service that parses very complex html pages.\n\nthe following code mitigates this problem on unix systems by manually forcing lxml to release the allocated memory:\n\n.. code-block:: python\n\n   import ctypes\n   def trim_memory() -> int:\n      libc = ctypes.cdll(\"libc.so.6\")\n      return libc.malloc_trim(0)\n\n\ncitation\n========\n\nthere is a `journal of open source software <https://joss.theoj.org>`_ `paper <https://joss.theoj.org/papers/10.21105/joss.03557>`_ you can cite for inscriptis:\n\n.. code-block:: bibtex\n\n      @article{weichselbraun2021,\n        doi = {10.21105/joss.03557},\n        url = {https://doi.org/10.21105/joss.03557},\n        year = {2021},\n        publisher = {the open journal},\n        volume = {6},\n        number = {66},\n        pages = {3557},\n        author = {albert weichselbraun},\n        title = {inscriptis - a python-based html to text conversion library optimized for knowledge extraction from the web},\n        journal = {journal of open source software}\n      }\n\n\nchangelog\n=========\n\na full list of changes can be found in the\n`release notes <https://github.com/weblyzard/inscriptis/releases>`_.\n\n\n\n",
  "docs_url": null,
  "keywords": "html,converter,text",
  "license": "apache 2.0",
  "name": "inscriptis",
  "package_url": "https://pypi.org/project/inscriptis/",
  "project_url": "https://pypi.org/project/inscriptis/",
  "project_urls": {
    "Homepage": "https://github.com/weblyzard/inscriptis"
  },
  "release_url": "https://pypi.org/project/inscriptis/2.3.2/",
  "requires_dist": [
    "lxml",
    "requests"
  ],
  "requires_python": ">=3.6",
  "summary": "inscriptis - html to text converter.",
  "version": "2.3.2",
  "releases": [],
  "developers": [
    "albert.weichselbraun@fhgr.ch",
    "albert_weichselbraun",
    "fabian.odoni@fhgr.ch"
  ],
  "kwds": "get_text html html_properties get_annotated_text inscript",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_inscriptis",
  "homepage": "https://github.com/weblyzard/inscriptis",
  "release_count": 24,
  "dependency_ids": [
    "pypi_lxml",
    "pypi_requests"
  ]
}