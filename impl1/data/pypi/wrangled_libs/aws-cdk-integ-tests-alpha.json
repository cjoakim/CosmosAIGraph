{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: aws cdk",
    "framework :: aws cdk :: 2",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# integ-tests\n\n<!--begin stability banner-->---\n\n\n![cdk-constructs: experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)\n\n> the apis of higher level constructs in this module are experimental and under active development.\n> they are subject to non-backward compatible changes or removal in any future version. these are\n> not subject to the [semantic versioning](https://semver.org/) model and breaking changes will be\n> announced in the release notes. this means that while you may use them, you may need to update\n> your source code when upgrading to a newer version of this package.\n\n---\n<!--end stability banner-->\n\n## overview\n\nthis library is meant to be used in combination with the [integ-runner](https://github.com/aws/aws-cdk/tree/main/packages/%40aws-cdk/integ-runner) cli\nto enable users to write and execute integration tests for aws cdk constructs.\n\nan integration test should be defined as a cdk application, and\nthere should be a 1:1 relationship between an integration test and a cdk application.\n\nso for example, in order to create an integration test called `my-function`\nwe would need to create a file to contain our integration test application.\n\n*test/integ.my-function.ts*\n\n```python\napp = app()\nstack = stack()\nlambda_.function(stack, \"myfunction\",\n    runtime=lambda_.runtime.nodejs_latest,\n    handler=\"index.handler\",\n    code=lambda_.code.from_asset(path.join(__dirname, \"lambda-handler\"))\n)\n```\n\nthis is a self contained cdk application which we could deploy by running\n\n```bash\ncdk deploy --app 'node test/integ.my-function.js'\n```\n\nin order to turn this into an integration test, all that is needed is to\nuse the `integtest` construct.\n\n```python\n# app: app\n# stack: stack\n\nintegtest(app, \"integ\", test_cases=[stack])\n```\n\nyou will notice that the `stack` is registered to the `integtest` as a test case.\neach integration test can contain multiple test cases, which are just instances\nof a stack. see the [usage](#usage) section for more details.\n\n## usage\n\n### integtest\n\nsuppose you have a simple stack, that only encapsulates a lambda function with a\ncertain handler:\n\n```python\nclass stackundertest(stack):\n    def __init__(self, scope, id, *, architecture=none, description=none, env=none, stackname=none, tags=none, synthesizer=none, terminationprotection=none, analyticsreporting=none, crossregionreferences=none, permissionsboundary=none, suppresstemplateindentation=none):\n        super().__init__(scope, id, architecture=architecture, description=description, env=env, stackname=stackname, tags=tags, synthesizer=synthesizer, terminationprotection=terminationprotection, analyticsreporting=analyticsreporting, crossregionreferences=crossregionreferences, permissionsboundary=permissionsboundary, suppresstemplateindentation=suppresstemplateindentation)\n\n        lambda_.function(self, \"handler\",\n            runtime=lambda_.runtime.nodejs_latest,\n            handler=\"index.handler\",\n            code=lambda_.code.from_asset(path.join(__dirname, \"lambda-handler\")),\n            architecture=architecture\n        )\n```\n\nyou may want to test this stack under different conditions. for example, we want\nthis stack to be deployed correctly, regardless of the architecture we choose\nfor the lambda function. in particular, it should work for both `arm_64` and\n`x86_64`. so you can create an `integtestcase` that exercises both scenarios:\n\n```python\nclass stackundertest(stack):\n    def __init__(self, scope, id, *, architecture=none, description=none, env=none, stackname=none, tags=none, synthesizer=none, terminationprotection=none, analyticsreporting=none, crossregionreferences=none, permissionsboundary=none, suppresstemplateindentation=none):\n        super().__init__(scope, id, architecture=architecture, description=description, env=env, stackname=stackname, tags=tags, synthesizer=synthesizer, terminationprotection=terminationprotection, analyticsreporting=analyticsreporting, crossregionreferences=crossregionreferences, permissionsboundary=permissionsboundary, suppresstemplateindentation=suppresstemplateindentation)\n\n        lambda_.function(self, \"handler\",\n            runtime=lambda_.runtime.nodejs_latest,\n            handler=\"index.handler\",\n            code=lambda_.code.from_asset(path.join(__dirname, \"lambda-handler\")),\n            architecture=architecture\n        )\n\n# beginning of the test suite\napp = app()\n\nintegtest(app, \"differentarchitectures\",\n    test_cases=[\n        stackundertest(app, \"stack1\",\n            architecture=lambda_.architecture.arm_64\n        ),\n        stackundertest(app, \"stack2\",\n            architecture=lambda_.architecture.x86_64\n        )\n    ]\n)\n```\n\nthis is all the instruction you need for the integration test runner to know\nwhich stacks to synthesize, deploy and destroy. but you may also need to\ncustomize the behavior of the runner by changing its parameters. for example:\n\n```python\napp = app()\n\nstack_under_test = stack(app, \"stackundertest\")\n\nstack = stack(app, \"stack\")\n\ntest_case = integtest(app, \"customizeddeploymentworkflow\",\n    test_cases=[stack_under_test],\n    diff_assets=true,\n    stack_update_workflow=true,\n    cdk_command_options=cdkcommands(\n        deploy=deploycommand(\n            args=deployoptions(\n                require_approval=requireapproval.never,\n                json=true\n            )\n        ),\n        destroy=destroycommand(\n            args=destroyoptions(\n                force=true\n            )\n        )\n    )\n)\n```\n\n### integtestcasestack\n\nin the majority of cases an integration test will contain a single `integtestcase`.\nby default when you create an `integtest` an `integtestcase` is created for you\nand all of your test cases are registered to this `integtestcase`. the `integtestcase`\nand `integtestcasestack` constructs are only needed when it is necessary to\ndefined different options for individual test cases.\n\nfor example, you might want to have one test case where `diffassets` is enabled.\n\n```python\n# app: app\n# stack_under_test: stack\n\ntest_case_with_assets = integtestcasestack(app, \"testcaseassets\",\n    diff_assets=true\n)\n\nintegtest(app, \"integ\", test_cases=[stack_under_test, test_case_with_assets])\n```\n\n## assertions\n\nthis library also provides a utility to make assertions against the infrastructure that the integration test deploys.\n\nthere are two main scenarios in which assertions are created.\n\n* part of an integration test using `integ-runner`\n\nin this case you would create an integration test using the `integtest` construct and then make assertions using the `assert` property.\nyou should **not** utilize the assertion constructs directly, but should instead use the `methods` on `integtest.assertions`.\n\n```python\n# app: app\n# stack: stack\n\n\ninteg = integtest(app, \"integ\", test_cases=[stack])\ninteg.assertions.aws_api_call(\"s3\", \"getobject\")\n```\n\nby default an assertions stack is automatically generated for you. you may however provide your own stack to use.\n\n```python\n# app: app\n# stack: stack\n# assertion_stack: stack\n\n\ninteg = integtest(app, \"integ\", test_cases=[stack], assertion_stack=assertion_stack)\ninteg.assertions.aws_api_call(\"s3\", \"getobject\")\n```\n\n* part of a  normal cdk deployment\n\nin this case you may be using assertions as part of a normal cdk deployment in order to make an assertion on the infrastructure\nbefore the deployment is considered successful. in this case you can utilize the assertions constructs directly.\n\n```python\n# my_app_stack: stack\n\n\nawsapicall(my_app_stack, \"getobject\",\n    service=\"s3\",\n    api=\"getobject\"\n)\n```\n\n### deployassert\n\nassertions are created by using the `deployassert` construct. this construct creates it's own `stack` separate from\nany stacks that you create as part of your integration tests. this `stack` is treated differently from other stacks\nby the `integ-runner` tool. for example, this stack will not be diffed by the `integ-runner`.\n\n`deployassert` also provides utilities to register your own assertions.\n\n```python\n# my_custom_resource: customresource\n# stack: stack\n# app: app\n\n\ninteg = integtest(app, \"integ\", test_cases=[stack])\ninteg.assertions.expect(\"customassertion\",\n    expectedresult.object_like({\"foo\": \"bar\"}),\n    actualresult.from_custom_resource(my_custom_resource, \"data\"))\n```\n\nin the above example an assertion is created that will trigger a user defined `customresource`\nand assert that the `data` attribute is equal to `{ foo: 'bar' }`.\n\n### api calls\n\na common method to retrieve the \"actual\" results to compare with what is expected is to make an\napi call to receive some data. this library does this by utilizing cloudformation custom resources\nwhich means that cloudformation will call out to a lambda function which will\nmake the api call.\n\n#### httpapicall\n\nusing the `httpapicall` will use the\n[node-fetch](https://github.com/node-fetch/node-fetch) javascript library to\nmake the http call.\n\nthis can be done by using the class directory (in the case of a normal deployment):\n\n```python\n# stack: stack\n\n\nhttpapicall(stack, \"myasssertion\",\n    url=\"https://example-api.com/abc\"\n)\n```\n\nor by using the `httpapicall` method on `deployassert` (when writing integration tests):\n\n```python\n# app: app\n# stack: stack\n\ninteg = integtest(app, \"integ\",\n    test_cases=[stack]\n)\ninteg.assertions.http_api_call(\"https://example-api.com/abc\")\n```\n\n#### awsapicall\n\nusing the `awsapicall` construct will use the aws javascript sdk to make the api call.\n\nthis can be done by using the class directory (in the case of a normal deployment):\n\n```python\n# stack: stack\n\n\nawsapicall(stack, \"myassertion\",\n    service=\"sqs\",\n    api=\"receivemessage\",\n    parameters={\n        \"queueurl\": \"url\"\n    }\n)\n```\n\nor by using the `awsapicall` method on `deployassert` (when writing integration tests):\n\n```python\n# app: app\n# stack: stack\n\ninteg = integtest(app, \"integ\",\n    test_cases=[stack]\n)\ninteg.assertions.aws_api_call(\"sqs\", \"receivemessage\", {\n    \"queueurl\": \"url\"\n})\n```\n\nby default, the `awsapicall` construct will automatically add the correct iam policies\nto allow the lambda function to make the api call. it does this based on the `service`\nand `api` that is provided. in the above example the service is `sqs` and the api is\n`receivemessage` so it will create a policy with `action: 'sqs:receivemessage`.\n\nthere are some cases where the permissions do not exactly match the service/api call, for\nexample the s3 `listobjectsv2` api. in these cases it is possible to add the correct policy\nby accessing the `provider` object.\n\n```python\n# app: app\n# stack: stack\n# integ: integtest\n\n\napi_call = integ.assertions.aws_api_call(\"s3\", \"listobjectsv2\", {\n    \"bucket\": \"mybucket\"\n})\n\napi_call.provider.add_to_role_policy({\n    \"effect\": \"allow\",\n    \"action\": [\"s3:getobject\", \"s3:listbucket\"],\n    \"resource\": [\"*\"]\n})\n```\n\nnote that addtorolepolicy() uses direct iam json policy blobs, not a iam.policystatement\nobject like you will see in the rest of the cdk.\n\n### equalsassertion\n\nthis library currently provides the ability to assert that two values are equal\nto one another by utilizing the `equalsassertion` class. this utilizes a lambda\nbacked `customresource` which in tern uses the [match](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.assertions.match.html) utility from the\n[@aws-cdk/assertions](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.assertions-readme.html) library.\n\n```python\n# app: app\n# stack: stack\n# queue: sqs.queue\n# fn: lambda.ifunction\n\n\ninteg = integtest(app, \"integ\",\n    test_cases=[stack]\n)\n\ninteg.assertions.invoke_function(\n    function_name=fn.function_name,\n    invocation_type=invocationtype.event,\n    payload=json.stringify({\"status\": \"ok\"})\n)\n\nmessage = integ.assertions.aws_api_call(\"sqs\", \"receivemessage\", {\n    \"queueurl\": queue.queue_url,\n    \"waittimeseconds\": 20\n})\n\nmessage.assert_at_path(\"messages.0.body\", expectedresult.object_like({\n    \"request_context\": {\n        \"condition\": \"success\"\n    },\n    \"request_payload\": {\n        \"status\": \"ok\"\n    },\n    \"response_context\": {\n        \"status_code\": 200\n    },\n    \"response_payload\": \"success\"\n}))\n```\n\n#### match\n\n`integ-tests` also provides a `match` utility similar to the `@aws-cdk/assertions` module. `match`\ncan be used to construct the `expectedresult`. while the utility is similar, only a subset of methods are currently available on the `match` utility of this module: `arraywith`, `objectlike`, `stringlikeregexp` and `serializedjson`.\n\n```python\n# message: awsapicall\n\n\nmessage.expect(expectedresult.object_like({\n    \"messages\": match.array_with([{\n        \"payload\": match.serialized_json({\"key\": \"value\"})\n    }, {\n        \"body\": {\n            \"values\": match.array_with([{\"asdf\": 3}]),\n            \"message\": match.string_like_regexp(\"message\")\n        }\n    }\n    ])\n}))\n```\n\n### examples\n\n#### invoke a lambda function\n\nin this example there is a lambda function that is invoked and\nwe assert that the payload that is returned is equal to '200'.\n\n```python\n# lambda_function: lambda.ifunction\n# app: app\n\n\nstack = stack(app, \"cdk-integ-lambda-bundling\")\n\ninteg = integtest(app, \"integtest\",\n    test_cases=[stack]\n)\n\ninvoke = integ.assertions.invoke_function(\n    function_name=lambda_function.function_name\n)\ninvoke.expect(expectedresult.object_like({\n    \"payload\": \"200\"\n}))\n```\n\n#### make an aws api call\n\nin this example there is a stepfunctions state machine that is executed\nand then we assert that the result of the execution is successful.\n\n```python\n# app: app\n# stack: stack\n# sm: istatemachine\n\n\ntest_case = integtest(app, \"integtest\",\n    test_cases=[stack]\n)\n\n# start an execution\nstart = test_case.assertions.aws_api_call(\"stepfunctions\", \"startexecution\", {\n    \"state_machine_arn\": sm.state_machine_arn\n})\n\n# describe the results of the execution\ndescribe = test_case.assertions.aws_api_call(\"stepfunctions\", \"describeexecution\", {\n    \"execution_arn\": start.get_att_string(\"executionarn\")\n})\n\n# assert the results\ndescribe.expect(expectedresult.object_like({\n    \"status\": \"succeeded\"\n}))\n```\n\n#### chain apicalls\n\nsometimes it may be necessary to chain api calls. since each api call is its own resource, all you\nneed to do is add a dependency between the calls. there is an helper method `next` that can be used.\n\n```python\n# integ: integtest\n\n\ninteg.assertions.aws_api_call(\"s3\", \"putobject\", {\n    \"bucket\": \"my-bucket\",\n    \"key\": \"my-key\",\n    \"body\": \"helloworld\"\n}).next(integ.assertions.aws_api_call(\"s3\", \"getobject\", {\n    \"bucket\": \"my-bucket\",\n    \"key\": \"my-key\"\n}))\n```\n\n#### wait for results\n\na common use case when performing assertions is to wait for a condition to pass. sometimes the thing\nthat you are asserting against is not done provisioning by the time the assertion runs. in these\ncases it is possible to run the assertion asynchronously by calling the `waitforassertions()` method.\n\ntaking the example above of executing a stepfunctions state machine, depending on the complexity of\nthe state machine, it might take a while for it to complete.\n\n```python\n# app: app\n# stack: stack\n# sm: istatemachine\n\n\ntest_case = integtest(app, \"integtest\",\n    test_cases=[stack]\n)\n\n# start an execution\nstart = test_case.assertions.aws_api_call(\"stepfunctions\", \"startexecution\", {\n    \"state_machine_arn\": sm.state_machine_arn\n})\n\n# describe the results of the execution\ndescribe = test_case.assertions.aws_api_call(\"stepfunctions\", \"describeexecution\", {\n    \"execution_arn\": start.get_att_string(\"executionarn\")\n}).expect(expectedresult.object_like({\n    \"status\": \"succeeded\"\n})).wait_for_assertions()\n```\n\nwhen you call `waitforassertions()` the assertion provider will continuously make the `awsapicall` until the\n`expectedresult` is met. you can also control the parameters for waiting, for example:\n\n```python\n# test_case: integtest\n# start: iapicall\n\n\ndescribe = test_case.assertions.aws_api_call(\"stepfunctions\", \"describeexecution\", {\n    \"execution_arn\": start.get_att_string(\"executionarn\")\n}).expect(expectedresult.object_like({\n    \"status\": \"succeeded\"\n})).wait_for_assertions(\n    total_timeout=duration.minutes(5),\n    interval=duration.seconds(15),\n    backoff_rate=3\n)\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.integ-tests-alpha",
  "package_url": "https://pypi.org/project/aws-cdk.integ-tests-alpha/",
  "project_url": "https://pypi.org/project/aws-cdk.integ-tests-alpha/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.integ-tests-alpha/2.116.1a0/",
  "requires_dist": [
    "aws-cdk-lib <3.0.0,>=2.116.1",
    "constructs <11.0.0,>=10.0.0",
    "jsii <2.0.0,>=1.93.0",
    "publication >=0.0.3",
    "typeguard ~=2.13.3"
  ],
  "requires_python": "~=3.8",
  "summary": "cdk integration testing constructs",
  "version": "2.116.1a0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "cdk_command_options versioning cdk banner integtest",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.integ_tests_alpha",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 139,
  "dependency_ids": [
    "pypi_aws_cdk_lib",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}