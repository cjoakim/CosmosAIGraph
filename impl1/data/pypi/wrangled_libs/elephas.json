{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# elephas: distributed deep learning with keras & spark \n\n![elephas](https://raw.githubusercontent.com/danielenricocahall/elephas/master/elephas-logo.png)\n\n## \n\n[![build status](https://github.com/danielenricocahall/elephas/actions/workflows/ci.yaml/badge.svg)](https://github.com/danielenricocahall/elephas/actions/workflows/ci.yaml/badge.svg)\n[![license](https://img.shields.io/github/license/mashape/apistatus.svg?maxage=2592000)](https://github.com/danielenricocahall/elephas/blob/master/license)\n[![supported versions](https://img.shields.io/badge/python-3.8%20%7c%203.9%20%7c%203.10-blue)](https://img.shields.io/badge/python-3.8%20%7c%203.9%20%7c%203.10-blue)\n\nelephas is an extension of [keras](http://keras.io), which allows you to run distributed deep learning models at \nscale with [spark](http://spark.apache.org). elephas currently supports a number of \napplications, including:\n\n- [data-parallel training of deep learning models](#basic-spark-integration)\n- [distributed inference and evaluation of deep learning models](#distributed-inference-and-evaluation)\n- [~~distributed training of ensemble models~~](#distributed-training-of-ensemble-models)  (removed as of 3.0.0)\n- [~~distributed hyper-parameter optimization~~](#distributed-hyper-parameter-optimization)  (removed as of 3.0.0)\n\n\n\nschematically, elephas works as follows.\n\n![elephas](https://raw.githubusercontent.com/danielenricocahall/elephas/master/elephas.gif)\n\ntable of content:\n* [elephas: distributed deep learning with keras & spark](#elephas-distributed-deep-learning-with-keras-&-spark-)\n  * [introduction](#introduction)\n  * [getting started](#getting-started)\n  * [basic spark integration](#basic-spark-integration)\n  * [distributed inference and evaluation](#distributed-inference-and-evaluation)\n  * [spark mllib integration](#spark-mllib-integration)\n  * [spark ml integration](#spark-ml-integration)\n  * [hadoop integration](#hadoop-integration)\n  * [distributed hyper-parameter optimization](#distributed-hyper-parameter-optimization)\n  * [distributed training of ensemble models](#distributed-training-of-ensemble-models)\n  * [discussion](#discussion)\n  * [literature](#literature)\n\n\n\n## introduction\nelephas brings deep learning with [keras](http://keras.io) to [spark](http://spark.apache.org). elephas intends to \nkeep the simplicity and high usability of keras, thereby allowing for fast prototyping of distributed models, which \ncan be run on massive data sets. for an introductory example, see the following \n[ipython notebook](https://github.com/danielenricocahall/elephas/blob/master/examples/spark_ml_pipeline.ipynb).\n\n\u1f10\u03bb\u03ad\u03c6\u03b1\u03c2 is greek for _ivory_ and an accompanying project to \u03ba\u03ad\u03c1\u03b1\u03c2, meaning _horn_. if this seems weird mentioning, like \na bad dream, you should confirm it actually is at the \n[keras documentation](https://github.com/fchollet/keras/blob/master/readme.md). \nelephas also means _elephant_, as in stuffed yellow elephant.\n\nelephas implements a class of data-parallel algorithms on top of keras, using spark's rdds and data frames. \nkeras models are initialized on the driver, then serialized and shipped to workers, alongside with data and broadcasted \nmodel parameters. spark workers deserialize the model, train their chunk of data and send their gradients back to the \ndriver. the \"master\" model on the driver is updated by an optimizer, which takes gradients either synchronously or\nasynchronously.\n\n## getting started\n\njust install elephas from pypi with, spark will be installed through `pyspark` for you.\n\n```\npip install elephas\n```\n\nthat's it, you should now be able to run elephas examples.\n\n## basic spark integration\n\nafter installing both elephas, you can train a model as follows. first, create a local pyspark context\n```python\nfrom pyspark import sparkcontext, sparkconf\nconf = sparkconf().setappname('elephas_app').setmaster('local[8]')\nsc = sparkcontext(conf=conf)\n```\n\nnext, you define and compile a keras model\n```python\nfrom tensorflow.keras.models import sequential\nfrom tensorflow.keras.layers import dense, dropout, activation\nfrom tensorflow.keras.optimizers import sgd\nmodel = sequential()\nmodel.add(dense(128, input_dim=784))\nmodel.add(activation('relu'))\nmodel.add(dropout(0.2))\nmodel.add(dense(128))\nmodel.add(activation('relu'))\nmodel.add(dropout(0.2))\nmodel.add(dense(10))\nmodel.add(activation('softmax'))\nmodel.compile(loss='categorical_crossentropy', optimizer=sgd())\n```\n\nand create an rdd from numpy arrays (or however you want to create an rdd)\n```python\nfrom elephas.utils.rdd_utils import to_simple_rdd\nrdd = to_simple_rdd(sc, x_train, y_train)\n```\n\nthe basic model in elephas is the `sparkmodel`. you initialize a `sparkmodel` by passing in a compiled keras model, \nan update frequency and a parallelization mode. after that you can simply `fit` the model on your rdd. elephas `fit`\nhas the same options as a keras model, so you can pass `epochs`, `batch_size` etc. as you're used to from tensorflow.keras.\n\n```python\nfrom elephas.spark_model import sparkmodel\n\nspark_model = sparkmodel(model, frequency='epoch', mode='asynchronous')\nspark_model.fit(rdd, epochs=20, batch_size=32, verbose=0, validation_split=0.1)\n```\n\nyour script can now be run using spark-submit\n```bash\nspark-submit --driver-memory 1g ./your_script.py\n```\n\nincreasing the driver memory even further may be necessary, as the set of parameters in a network may be very large \nand collecting them on the driver eats up a lot of resources. see the examples folder for a few working examples.\n\n## distributed inference and evaluation\n\nthe `sparkmodel` can also be used for distributed inference (prediction) and evaluation. similar to the `fit` method,  the `predict` and `evaluate` methods\nconform to the keras model api. \n\n```python\nfrom elephas.spark_model import sparkmodel\n\n# create/train the model, similar to the previous section (basic spark integration)\nmodel = ...\nspark_model = sparkmodel(model, ...)\nspark_model.fit(...)\n\nx_test, y_test = ... # load test data\n\npredictions = spark_model.predict(x_test) # perform inference\nevaluation = spark_model.evaluate(x_test, y_test) # perform evaluation/scoring\n```\nthe paradigm is identical to the data parallelism in training, as the model is serialized and shipped to the workers and used to evaluate a chunk of the testing data. the predict method will take either a numpy array or an rdd.\n\n## spark mllib integration\n\nfollowing up on the last example, to use spark's mllib library with elephas, you create an rdd of labeledpoints for \nsupervised training as follows\n\n```python\nfrom elephas.utils.rdd_utils import to_labeled_point\nlp_rdd = to_labeled_point(sc, x_train, y_train, categorical=true)\n```\n\ntraining a given labeledpoint-rdd is very similar to what we've seen already\n\n```python\nfrom elephas.spark_model import sparkmllibmodel\nspark_model = sparkmllibmodel(model, frequency='batch', mode='hogwild')\nspark_model.train(lp_rdd, epochs=20, batch_size=32, verbose=0, validation_split=0.1, \n                  categorical=true, nb_classes=nb_classes)\n```\n\n\n## spark ml integration\n\nto train a model with a sparkml estimator on a data frame, use the following syntax.\n```python\ndf = to_data_frame(sc, x_train, y_train, categorical=true)\ntest_df = to_data_frame(sc, x_test, y_test, categorical=true)\n\nestimator = elephasestimator(model, epochs=epochs, batch_size=batch_size, frequency='batch', mode='asynchronous',\n                             categorical=true, nb_classes=nb_classes)\nfitted_model = estimator.fit(df)\n```\n\nfitting an estimator results in a sparkml transformer, which we can use for predictions and other evaluations by \ncalling the transform method on it.\n\n```python\nprediction = fitted_model.transform(test_df)\npnl = prediction.select(\"label\", \"prediction\")\npnl.show(100)\nimport numpy as np\nprediction_and_label = pnl.rdd.map(lambda row: (row.label, float(np.argmax(row.prediction))))\n\nmetrics = multiclassmetrics(prediction_and_label)\nprint(metrics.weightedprecision)\nprint(metrics.weightedrecall)\n```\n\nif the model utilizes custom activation function, layer, or loss function, that will need to be supplied using the `set_custom_objects` method:\n\n```python\ndef custom_activation(x):\n    ...\nclass customlayer(layer):\n    ...\nmodel = sequential()\nmodel.add(customlayer(...))\n\nestimator = elephasestimator(model, epochs=epochs, batch_size=batch_size)\nestimator.set_custom_objects({'custom_activation': custom_activation, 'customlayer': customlayer})\n```\n\n## hadoop integration\n\nin addition to saving locally, models may be saved directly into a network-accessible hadoop cluster.\n\n```python\nspark_model.save('/absolute/file/path/model.h5', to_hadoop=true)\n```\n\nmodels saved on a network-accessible hadoop cluster may be loaded as follows.\n\n```python\nfrom elephas.spark_model import load_spark_model\n\nspark_model = load_spark_model('/absolute/file/path/model.h5', from_hadoop=true)\n```\n\n## distributed hyper-parameter optimization\n\n<span style=\"color:red\">**update**: as of 3.0.0, hyper-parameter optimization features have been removed, since hyperas is no longer active and was causing versioning compatibility issues. to use these features, install version 2.1 or below.</span>\n\nhyper-parameter optimization with elephas is based on [hyperas](https://github.com/maxpumperla/hyperas), a convenience \nwrapper for hyperopt and keras. each spark worker executes a number of trials, the results get collected and the best \nmodel is returned. as the distributed mode in hyperopt (using mongodb), is somewhat difficult to configure and error \nprone at the time of writing, we chose to implement parallelization ourselves. right now, the only available \noptimization algorithm is random search.\n\nthe first part of this example is more or less directly taken from the hyperas documentation. we define data and model \nas functions, hyper-parameter ranges are defined through braces. see the hyperas documentation for more on how \nthis works.\n\n```python\nfrom hyperopt import status_ok\nfrom hyperas.distributions import choice, uniform\n\ndef data():\n    from tensorflow.keras.datasets import mnist\n    from tensorflow.keras.utils import to_categorical\n    (x_train, y_train), (x_test, y_test) = mnist.load_data()\n    x_train = x_train.reshape(60000, 784)\n    x_test = x_test.reshape(10000, 784)\n    x_train = x_train.astype('float32')\n    x_test = x_test.astype('float32')\n    x_train /= 255\n    x_test /= 255\n    nb_classes = 10\n    y_train = to_categorical(y_train, nb_classes)\n    y_test = to_categorical(y_test, nb_classes)\n    return x_train, y_train, x_test, y_test\n\n\ndef model(x_train, y_train, x_test, y_test):\n    from tensorflow.keras.models import sequential\n    from tensorflow.keras.layers import dense, dropout, activation\n    from tensorflow.keras.optimizers import rmsprop\n\n    model = sequential()\n    model.add(dense(512, input_shape=(784,)))\n    model.add(activation('relu'))\n    model.add(dropout({{uniform(0, 1)}}))\n    model.add(dense({{choice([256, 512, 1024])}}))\n    model.add(activation('relu'))\n    model.add(dropout({{uniform(0, 1)}}))\n    model.add(dense(10))\n    model.add(activation('softmax'))\n\n    rms = rmsprop()\n    model.compile(loss='categorical_crossentropy', optimizer=rms)\n\n    model.fit(x_train, y_train,\n              batch_size={{choice([64, 128])}},\n              nb_epoch=1,\n              show_accuracy=true,\n              verbose=2,\n              validation_data=(x_test, y_test))\n    score, acc = model.evaluate(x_test, y_test, show_accuracy=true, verbose=0)\n    print('test accuracy:', acc)\n    return {'loss': -acc, 'status': status_ok, 'model': model.to_json()}\n```\n\nonce the basic setup is defined, running the minimization is done in just a few lines of code:\n\n```python\nfrom elephas.hyperparam import hyperparammodel\nfrom pyspark import sparkcontext, sparkconf\n\n# create spark context\nconf = sparkconf().setappname('elephas_hyperparameter_optimization').setmaster('local[8]')\nsc = sparkcontext(conf=conf)\n\n# define hyper-parameter model and run optimization\nhyperparam_model = hyperparammodel(sc)\nhyperparam_model.minimize(model=model, data=data, max_evals=5)\n```\n\n## distributed training of ensemble models\n<span style=\"color:red\">**update**: as of 3.0.0, hyper-parameter optimization features have been removed, since hyperas is no longer active and was causing versioning compatibility issues. to use these features, install version 2.1 or below.</span>\n\nbuilding on the last section, it is possible to train ensemble models with elephas by means of running hyper-parameter \noptimization on large search spaces and defining a resulting voting classifier on the top-n performing models. \nwith ```data``` and ```model``` defined as above, this is a simple as running\n\n```python\nresult = hyperparam_model.best_ensemble(nb_ensemble_models=10, model=model, data=data, max_evals=5)\n```\nin this example an ensemble of 10 models is built, based on optimization of at most 5 runs on each of the spark workers.\n\n## discussion\n\npremature parallelization may not be the root of all evil, but it may not always be the best idea to do so. keep in \nmind that more workers mean less data per worker and parallelizing a model is not an excuse for actual learning. \nso, if you can perfectly well fit your data into memory *and* you're happy with training speed of the model consider \njust using keras.\n\none exception to this rule may be that you're already working within the spark ecosystem and want to leverage what's \nthere. the above sparkml example shows how to use evaluation modules from spark and maybe you wish to further process \nthe outcome of an elephas model down the road. in this case, we recommend to use elephas as a simple wrapper by setting \nnum_workers=1.\n\nnote that right now elephas restricts itself to data-parallel algorithms for two reasons. first, spark simply makes it \nvery easy to distribute data. second, neither spark nor theano make it particularly easy to split up the actual model \nin parts, thus making model-parallelism practically impossible to realize.\n\nhaving said all that, we hope you learn to appreciate elephas as a pretty easy to setup and use playground for \ndata-parallel deep-learning algorithms.\n\n\n## literature\n[1] j. dean, g.s. corrado, r. monga, k. chen, m. devin, qv. le, mz. mao, m\u2019a. ranzato, a. senior, p. tucker, k. yang, and ay. ng. [large scale distributed deep networks](http://research.google.com/archive/large_deep_networks_nips2012.html).\n\n[2] f. niu, b. recht, c. re, s.j. wright [hogwild!: a lock-free approach to parallelizing stochastic gradient descent](http://arxiv.org/abs/1106.5730)\n\n[3] c. noel, s. osindero. [dogwild! \u2014 distributed hogwild for cpu & gpu](http://stanford.edu/~rezab/nips2014workshop/submits/dogwild.pdf)\n\n## maintainers / contributions\n\nthis great project was started by max pumperla, and is currently maintained by daniel cahall (https://github.com/danielenricocahall). if you have any questions, please feel free to open up an issue or send an email to danielenricocahall@gmail.com. if you want to contribute, feel free to submit a pr, or start a conversation about how we can go about implementing something.\n\n## star history\n\n[![star history chart](https://api.star-history.com/svg?repos=danielenricocahall/elephas&type=date)](https://star-history.com/#danielenricocahall/elephas&date)\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "elephas",
  "package_url": "https://pypi.org/project/elephas/",
  "project_url": "https://pypi.org/project/elephas/",
  "project_urls": {
    "Homepage": "https://danielenricocahall.github.io/elephas/"
  },
  "release_url": "https://pypi.org/project/elephas/5.0.0/",
  "requires_dist": [
    "tensorflow (>2.2,<=2.14)",
    "Flask (>=2.2.3,<3.0.0)",
    "h5py (==3.8.0)",
    "pyspark (<=3.5.0)",
    "Cython (>=0.29.33,<0.30.0)",
    "numpy (==1.23.5)"
  ],
  "requires_python": ">=3.8,<3.12",
  "summary": "distributed deep learning on spark with keras",
  "version": "5.0.0",
  "releases": [],
  "developers": [
    "daniel_cahall",
    "danielenricocahall@gmail.com"
  ],
  "kwds": "elephas badge elephas_app elephas_hyperparameter_optimization large_deep_networks_nips2012",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_elephas",
  "homepage": "https://danielenricocahall.github.io/elephas/",
  "release_count": 39,
  "dependency_ids": [
    "pypi_cython",
    "pypi_flask",
    "pypi_h5py",
    "pypi_numpy",
    "pypi_pyspark",
    "pypi_tensorflow"
  ]
}