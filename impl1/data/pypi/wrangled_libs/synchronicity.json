{
  "classifiers": [],
  "description": "![ci/cd badge](https://github.com/erikbern/synchronicity/actions/workflows/ci.yml/badge.svg)\n[![pypi badge](https://img.shields.io/pypi/v/synchronicity.svg?style=flat)](https://pypi.python.org/pypi/synchronicity)\n\npython 3 has some amazing support for async programming but it's arguably made it a bit harder to develop libraries. are you tired of implementing synchronous _and_ asynchronous methods doing basically the same thing? this might be a simple solution for you.\n\ninstalling\n==========\n\n```\npip install synchronicity\n```\n\n\nbackground: why is anything like this needed\n============================================\n\nlet's say you have an asynchronous function\n\n```python\nasync def f(x):\n    await asyncio.sleep(1.0)\n    return x**2\n```\n\nand let's say (for whatever reason) you want to offer a synchronous api to users. for instance maybe you want to make it easy to run your code in a basic script, or a user is building something that's mostly cpu-bound, so they don't want to bother with asyncio.\n\na \"simple\" way to create a synchronous equivalent would be to implement a set of synchronous functions where all they do is call [asyncio.run](https://docs.python.org/3/library/asyncio-task.html#asyncio.run) on an asynchronous function. but this isn't a great solution for more complex code:\n\n* it's kind of tedious grunt work to have to do this for every method/function\n* [asyncio.run](https://docs.python.org/3/library/asyncio-task.html#asyncio.run) doesn't work with generators\n* in many cases, you need to preserve an event loop running between calls.\n\nthe last case is particularly challenging. for instance, let's say you are implementing a client to a database that needs to have a persistent connection, and you want to built it in asyncio:\n\n```python\nclass dbconnection:\n    def __init__(self, url):\n        self._url = url\n\n    async def connect(self):\n        self._connection = await connect_to_database(self._url)\n\n    async def query(self, q):\n        return await self._connection.run_query(q)\n```\n\nhow do you expose a synchronous interface to this code? the problem is that wrapping `connect` and `query` in [asyncio.run](https://docs.python.org/3/library/asyncio-task.html#asyncio.run) won't work since you need to _preserve the event loop across calls_. it's clear we need something slightly more advanced.\n\nhow to use this library\n=======================\n\nthis library offers a simple `synchronizer` class that creates an event loop on a separate thread, and wraps functions/generators/classes so that synchronous execution happens on that thread. when you call anything, it will detect if you're running in a synchronous or asynchronous context, and behave correspondingly.\n\n* in the synchronous case, it will simply block until the result is available (note that you can make it return a future as well, see later)\n* in the asynchronous case, it works just like the usual business of calling asynchronous code\n\n```python\nfrom synchronicity import synchronizer\n\nsynchronizer = synchronizer()\n\n@synchronizer.create_blocking\nasync def f(x):\n    await asyncio.sleep(1.0)\n    return x**2\n\n\n# running f in a synchronous context blocks until the result is available\nret = f(42)  # blocks\nprint('f(42) =', ret)\n\n\nasync def g():\n    # running f in an asynchronous context works the normal way\n    ret = await f(42)\n    print('f(42) =', ret)\n```\n\nmore advanced examples\n======================\n\ngenerators\n----------\n\nthe decorator also works on generators:\n\n```python\n@synchronizer.create_blocking\nasync def f(n):\n    for i in range(n):\n        await asyncio.sleep(1.0)\n\tyield i\n\n\n# note that the following runs in a synchronous context\n# each number will take 1s to print\nfor ret in f(10):\n    print(ret)\n```\n\nsynchronizing whole classes\n---------------------------\n\nit also operates on classes by wrapping every method on the class:\n\n\n```python\n@synchronizer.create_blocking\nclass dbconnection:\n    def __init__(self, url):\n        self._url = url\n\n    async def connect(self):\n        self._connection = await connect_to_database(self._url)\n\n    async def query(self, q):\n        return await self._connection.run_query(q)\n\n\n# now we can call it synchronously, if we want to\ndb_conn = dbconnection('tcp://localhost:1234')\ndb_conn.connect()\ndata = db_conn.query('select * from foo')\n```\n\nreturning futures\n-----------------\n\nyou can also make functions return a `future` object by adding `_future=true` to any call. this can be useful if you want to dispatch many calls from a blocking context, but you want to resolve them roughly in parallel:\n\n```python\nfrom synchronicity import synchronizer\n\nsynchronizer = synchronizer()\n\n@synchronizer.create_blocking\nasync def f(x):\n    await asyncio.sleep(1.0)\n    return x**2\n\nfutures = [f(i, _future=true) for i in range(10)]  # this returns immediately\nrets = [fut.result() for fut in futures]  # this should take ~1s to run, resolving all futures in parallel\nprint('first ten squares:', rets)\n```\n\nusing with with other asynchronous code\n---------------------------------------\n\nthis library can also be useful in purely asynchronous settings, if you have multiple event loops, or if you have some section that is cpu-bound, or some critical code that you want to run on a separate thread for safety. all calls to synchronized functions/generators are thread-safe by design. this makes it a useful alternative to [loop.run_in_executor](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor) for simple things. note however that each synchronizer only runs one thread.\n\ncontext managers\n----------------\n\nyou can synchronize context manager classes just like any other class and the special methods will be handled properly.\n\nthere's also a function decorator `@synchronizer.asynccontextmanager` which behaves just like [https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager](contextlib.asynccontextmanager) but works in both synchronous and asynchronous contexts.\n\n\ngotchas\n=======\n\n* it works for classes that are context managers, but not for functions returning a context manager\n* it creates a new class (with the same name) when wrapping classes, which might lead to typing problems if you have any any un-synchronized usage of the same class\n* no idea how this interacts with typing annotations\n* if a class is \"synchronized\", it wraps all the methods on the class, but this typically means you can't reach into attributes and run asynchronous code on it: you might get errors such as \"attached to a different loop\"\n* note that all synchronized code will run on a different thread, and a different event loop, so calling the code might have some minor extra overhead\n\ntodos\n=====\n\n* support the opposite case, i.e. you have a blocking function/generator/class/object, and you want to call it asynchronously (this is relatively simple to do for plain functions using [loop.run_in_executor](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.run_in_executor), but python has no built-in support for generators, and it would be nice to transform a whole class\n* more documentation\n* make it possible to annotate methods selectively to return futures\n* maybe make it possible to synchronize objects on the fly, not just classes\n\nthis library is limb-amputating edge\n====================================\n\nthis is code i broke out of a personal projects, and it's not been battle-tested. there is a small test suite that you can run using pytest.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "synchronicity",
  "package_url": "https://pypi.org/project/synchronicity/",
  "project_url": "https://pypi.org/project/synchronicity/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/synchronicity/0.5.3/",
  "requires_dist": [
    "sigtools (==4.0.1)"
  ],
  "requires_python": ">=3.7.9",
  "summary": "export blocking and async library versions from a single async implementation",
  "version": "0.5.3",
  "releases": [],
  "developers": [],
  "kwds": "synchronize synchronizing synchronizer async synchronously",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_synchronicity",
  "homepage": "",
  "release_count": 47,
  "dependency_ids": [
    "pypi_sigtools"
  ]
}