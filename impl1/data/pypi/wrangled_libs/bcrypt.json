{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "bcrypt\n======\n\n.. image:: https://img.shields.io/pypi/v/bcrypt.svg\n    :target: https://pypi.org/project/bcrypt/\n    :alt: latest version\n\n.. image:: https://github.com/pyca/bcrypt/workflows/ci/badge.svg?branch=main\n    :target: https://github.com/pyca/bcrypt/actions?query=workflow%3aci+branch%3amain\n\nacceptable password hashing for your software and your servers (but you should\nreally use argon2id or scrypt)\n\n\ninstallation\n============\n\nto install bcrypt, simply:\n\n.. code:: bash\n\n    $ pip install bcrypt\n\nnote that bcrypt should build very easily on linux provided you have a c\ncompiler and a rust compiler (the minimum supported rust version is 1.56.0).\n\nfor debian and ubuntu, the following command will ensure that the required dependencies are installed:\n\n.. code:: bash\n\n    $ sudo apt-get install build-essential cargo\n\nfor fedora and rhel-derivatives, the following command will ensure that the required dependencies are installed:\n\n.. code:: bash\n\n    $ sudo yum install gcc cargo\n\nfor alpine, the following command will ensure that the required dependencies are installed:\n\n.. code:: bash\n\n    $ apk add --update musl-dev gcc cargo\n\n\nalternatives\n============\n\nwhile bcrypt remains an acceptable choice for password storage, depending on your specific use case you may also want to consider using scrypt (either via `standard library`_ or `cryptography`_) or argon2id via `argon2_cffi`_.\n\nchangelog\n=========\n\n4.1.2\n-----\n\n* publish both ``py37`` and ``py39`` wheels. this should resolve some errors\n  relating to initializing a module multiple times per process.\n\n4.1.1\n-----\n\n* fixed the type signature on the ``kdf`` method.\n* fixed packaging bug on windows.\n* fixed incompatibility with passlib package detection assumptions.\n\n4.1.0\n-----\n\n* dropped support for python 3.6.\n* bumped msrv to 1.64. (note: rust 1.63 can be used by setting the ``bcrypt_allow_rust_163`` environment variable)\n\n4.0.1\n-----\n\n* we now build pypy ``manylinux`` wheels.\n* fixed a bug where passing an invalid ``salt`` to ``checkpw`` could result in\n  a ``pyo3_runtime.panicexception``. it now correctly raises a ``valueerror``.\n\n4.0.0\n-----\n\n* ``bcrypt`` is now implemented in rust. users building from source will need\n  to have a rust compiler available. nothing will change for users downloading\n  wheels.\n* we no longer ship ``manylinux2010`` wheels. users should upgrade to the latest\n  ``pip`` to ensure this doesn\u2019t cause issues downloading wheels on their\n  platform. we now ship ``manylinux_2_28`` wheels for users on new enough platforms.\n* ``nul`` bytes are now allowed in inputs.\n\n\n3.2.2\n-----\n\n* fixed packaging of ``py.typed`` files in wheels so that ``mypy`` works.\n\n3.2.1\n-----\n\n* added support for compilation on z/os\n* the next release of ``bcrypt`` with be 4.0 and it will require rust at\n  compile time, for users building from source. there will be no additional\n  requirement for users who are installing from wheels. users on most\n  platforms will be able to obtain a wheel by making sure they have an up to\n  date ``pip``. the minimum supported rust version will be 1.56.0.\n* this will be the final release for which we ship ``manylinux2010`` wheels.\n  going forward the minimum supported manylinux abi for our wheels will be\n  ``manylinux2014``. the vast majority of users will continue to receive\n  ``manylinux`` wheels provided they have an up to date ``pip``.\n\n\n3.2.0\n-----\n\n* added typehints for library functions.\n* dropped support for python versions less than 3.6 (2.7, 3.4, 3.5).\n* shipped ``abi3`` windows wheels (requires pip >= 20).\n\n3.1.7\n-----\n\n* set a ``setuptools`` lower bound for pep517 wheel building.\n* we no longer distribute 32-bit ``manylinux1`` wheels. continuing to produce\n  them was a maintenance burden.\n\n3.1.6\n-----\n\n* added support for compilation on haiku.\n\n3.1.5\n-----\n\n* added support for compilation on aix.\n* dropped python 2.6 and 3.3 support.\n* switched to using ``abi3`` wheels for python 3. if you are not getting a\n  wheel on a compatible platform please upgrade your ``pip`` version.\n\n3.1.4\n-----\n\n* fixed compilation with mingw and on illumos.\n\n3.1.3\n-----\n* fixed a compilation issue on solaris.\n* added a warning when using too few rounds with ``kdf``.\n\n3.1.2\n-----\n* fixed a compile issue affecting big endian platforms.\n* fixed invalid escape sequence warnings on python 3.6.\n* fixed building in non-utf8 environments on python 2.\n\n3.1.1\n-----\n* resolved a ``userwarning`` when used with ``cffi`` 1.8.3.\n\n3.1.0\n-----\n* added support for ``checkpw``, a convenience method for verifying a password.\n* ensure that you get a ``$2y$`` hash when you input a ``$2y$`` salt.\n* fixed a regression where ``$2a`` hashes were vulnerable to a wraparound bug.\n* fixed compilation under alpine linux.\n\n3.0.0\n-----\n* switched the c backend to code obtained from the openbsd project rather than\n  openwall.\n* added support for ``bcrypt_pbkdf`` via the ``kdf`` function.\n\n2.0.0\n-----\n* added support for an adjustible prefix when calling ``gensalt``.\n* switched to cffi 1.0+\n\nusage\n-----\n\npassword hashing\n~~~~~~~~~~~~~~~~\n\nhashing and then later checking that a password matches the previous hashed\npassword is very simple:\n\n.. code:: pycon\n\n    >>> import bcrypt\n    >>> password = b\"super secret password\"\n    >>> # hash a password for the first time, with a randomly-generated salt\n    >>> hashed = bcrypt.hashpw(password, bcrypt.gensalt())\n    >>> # check that an unhashed password matches one that has previously been\n    >>> # hashed\n    >>> if bcrypt.checkpw(password, hashed):\n    ...     print(\"it matches!\")\n    ... else:\n    ...     print(\"it does not match :(\")\n\nkdf\n~~~\n\nas of 3.0.0 ``bcrypt`` now offers a ``kdf`` function which does ``bcrypt_pbkdf``.\nthis kdf is used in openssh's newer encrypted private key format.\n\n.. code:: pycon\n\n    >>> import bcrypt\n    >>> key = bcrypt.kdf(\n    ...     password=b'password',\n    ...     salt=b'salt',\n    ...     desired_key_bytes=32,\n    ...     rounds=100)\n\n\nadjustable work factor\n~~~~~~~~~~~~~~~~~~~~~~\none of bcrypt's features is an adjustable logarithmic work factor. to adjust\nthe work factor merely pass the desired number of rounds to\n``bcrypt.gensalt(rounds=12)`` which defaults to 12):\n\n.. code:: pycon\n\n    >>> import bcrypt\n    >>> password = b\"super secret password\"\n    >>> # hash a password for the first time, with a certain number of rounds\n    >>> hashed = bcrypt.hashpw(password, bcrypt.gensalt(14))\n    >>> # check that a unhashed password matches one that has previously been\n    >>> #   hashed\n    >>> if bcrypt.checkpw(password, hashed):\n    ...     print(\"it matches!\")\n    ... else:\n    ...     print(\"it does not match :(\")\n\n\nadjustable prefix\n~~~~~~~~~~~~~~~~~\n\nanother one of bcrypt's features is an adjustable prefix to let you define what\nlibraries you'll remain compatible with. to adjust this, pass either ``2a`` or\n``2b`` (the default) to ``bcrypt.gensalt(prefix=b\"2b\")`` as a bytes object.\n\nas of 3.0.0 the ``$2y$`` prefix is still supported in ``hashpw`` but deprecated.\n\nmaximum password length\n~~~~~~~~~~~~~~~~~~~~~~~\n\nthe bcrypt algorithm only handles passwords up to 72 characters, any characters\nbeyond that are ignored. to work around this, a common approach is to hash a\npassword with a cryptographic hash (such as ``sha256``) and then base64\nencode it to prevent null byte problems before hashing the result with\n``bcrypt``:\n\n.. code:: pycon\n\n    >>> password = b\"an incredibly long password\" * 10\n    >>> hashed = bcrypt.hashpw(\n    ...     base64.b64encode(hashlib.sha256(password).digest()),\n    ...     bcrypt.gensalt()\n    ... )\n\ncompatibility\n-------------\n\nthis library should be compatible with py-bcrypt and it will run on python\n3.6+, and pypy 3.\n\nc code\n------\n\nthis library uses code from openbsd.\n\nsecurity\n--------\n\n``bcrypt`` follows the `same security policy as cryptography`_, if you\nidentify a vulnerability, we ask you to contact us privately.\n\n.. _`same security policy as cryptography`: https://cryptography.io/en/latest/security.html\n.. _`standard library`: https://docs.python.org/3/library/hashlib.html#hashlib.scrypt\n.. _`argon2_cffi`: https://argon2-cffi.readthedocs.io\n.. _`cryptography`: https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/#cryptography.hazmat.primitives.kdf.scrypt.scrypt\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "bcrypt",
  "package_url": "https://pypi.org/project/bcrypt/",
  "project_url": "https://pypi.org/project/bcrypt/",
  "project_urls": {
    "homepage": "https://github.com/pyca/bcrypt/"
  },
  "release_url": "https://pypi.org/project/bcrypt/4.1.2/",
  "requires_dist": [
    "pytest !=3.3.0,>=3.2.1 ; extra == 'tests'",
    "mypy ; extra == 'typecheck'"
  ],
  "requires_python": ">=3.7",
  "summary": "modern password hashing for your software and your servers",
  "version": "4.1.2",
  "releases": [],
  "developers": [
    "cryptography-dev@python.org"
  ],
  "kwds": "bcrypt_allow_rust_163 bcrypt bcrypt_pbkdf scrypt passlib",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_bcrypt",
  "homepage": "",
  "release_count": 23,
  "dependency_ids": [
    "pypi_mypy",
    "pypi_pytest"
  ]
}