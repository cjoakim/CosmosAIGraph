{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: django",
    "framework :: django :: 3.2",
    "framework :: django :: 4.1",
    "framework :: django :: 4.2",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# sql views for postgres\n\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\nadds first-class support for [postgresql views][pg-views] in the django orm.\nfork of the original [django-pgviews][django-pgviews] by [mypebble][mypebble] with support for django 3.2+.\n\n[pg-views]: http://www.postgresql.org/docs/9.1/static/sql-createview.html\n[django-pgviews]: https://github.com/mypebble/django-pgviews\n[mypebble]: https://github.com/mypebble\n\n## installation\n\ninstall via pip:\n\n    pip install django-pgviews-redux\n\nadd to installed applications in settings.py:\n\n```python\ninstalled_apps = (\n  # ...\n  'django_pgviews',\n)\n```\n\n## examples\n\n```python\nfrom django.db import models\n\nfrom django_pgviews import view as pg\n\n\nclass customer(models.model):\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n    is_preferred = models.booleanfield(default=false)\n\n    class meta:\n        app_label = 'myapp'\n\nclass preferredcustomer(pg.view):\n    projection = ['myapp.customer.*',]\n    dependencies = ['myapp.otherview',]\n    sql = \"\"\"select * from myapp_customer where is_preferred = true;\"\"\"\n\n    class meta:\n      app_label = 'myapp'\n      db_table = 'myapp_preferredcustomer'\n      managed = false\n```\n\n**note** it is important that we include the `managed = false` in the `meta` so\ndjango 1.7 migrations don't attempt to create db tables for this view.\n\nthe sql produced by this might look like:\n\n```postgresql\ncreate view myapp_preferredcustomer as\nselect * from myapp_customer where is_preferred = true;\n```\n\nto create all your views, run ``python manage.py sync_pgviews``\n\nyou can also specify field names, which will map onto fields in your view:\n\n```python\nfrom django_pgviews import view as pg\n\n\nview_sql = \"\"\"\n    select name, post_code from myapp_customer where is_preferred = true\n\"\"\"\n\n\nclass preferredcustomer(pg.view):\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n\n    sql = view_sql\n```\n\n## usage\n\nto map onto a view, simply extend `pg_views.view.view`, assign sql to the\n`sql` argument and define a `db_table`. you must _always_ set `managed = false`\non the `meta` class.\n\nviews can be created in a number of ways:\n\n1. define fields to map onto the view output\n2. define a projection that describes the view fields\n\n### define fields\n\ndefine the fields as you would with any django model:\n\n```python\nfrom django_pgviews import view as pg\n\n\nview_sql = \"\"\"\n    select name, post_code from myapp_customer where is_preferred = true\n\"\"\"\n\n\nclass preferredcustomer(pg.view):\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n\n    sql = view_sql\n\n    class meta:\n      managed = false\n      db_table = 'my_sql_view'\n```\n\n### define projection\n\n`django-pgviews` can take a projection to figure out what fields it needs to\nmap onto for a view. to use this, set the `projection` attribute:\n\n```python\nfrom django_pgviews import view as pg\n\n\nclass preferredcustomer(pg.view):\n    projection = ['myapp.customer.*',]\n    sql = \"\"\"select * from myapp_customer where is_preferred = true;\"\"\"\n\n    class meta:\n      db_table = 'my_sql_view'\n      managed = false\n```\n\nthis will take all fields on `myapp.customer` and apply them to\n`preferredcustomer`\n\n## features\n\n### updating views\n\nsometimes your models change and you need your database views to reflect the new\ndata. updating the view logic is as simple as modifying the underlying sql and\nrunning:\n\n```\npython manage.py sync_pgviews --force\n```\n\nthis will forcibly update any views that conflict with your new sql.\n\n### dependencies\n\nyou can specify other views you depend on. this ensures the other views are\ninstalled beforehand. using dependencies also ensures that your views get\nrefreshed correctly when using `sync_pgviews --force`.\n\n**note:** views are synced after the django application has migrated and adding\nmodels to the dependency list will cause syncing to fail.\n\nexample:\n\n```python\nfrom django_pgviews import view as pg\n\nclass preferredcustomer(pg.view):\n    dependencies = ['myapp.otherview',]\n    sql = \"\"\"select * from myapp_customer where is_preferred = true;\"\"\"\n\n    class meta:\n      app_label = 'myapp'\n      db_table = 'myapp_preferredcustomer'\n      managed = false\n```\n\n### materialized views\n\npostgres 9.3 and up supports [materialized views](http://www.postgresql.org/docs/current/static/sql-creatematerializedview.html)\nwhich allow you to cache the results of views, potentially allowing them\nto load faster.\n\nhowever, you do need to manually refresh the view. to do this automatically,\nyou can attach [signals](https://docs.djangoproject.com/en/1.8/ref/signals/)\nand call the refresh function.\n\nexample:\n\n```python\nfrom django_pgviews import view as pg\n\n\nview_sql = \"\"\"\n    select name, post_code from myapp_customer where is_preferred = true\n\"\"\"\n\nclass customer(models.model):\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n    is_preferred = models.booleanfield(default=true)\n\n\nclass preferredcustomer(pg.materializedview):\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n\n    sql = view_sql\n\n\n@receiver(post_save, sender=customer)\ndef customer_saved(sender, action=none, instance=none, **kwargs):\n    preferredcustomer.refresh()\n```\n\n#### concurrent refresh\n\npostgres 9.4 and up allow materialized views to be refreshed concurrently, without blocking reads, as long as a\nunique index exists on the materialized view. to enable concurrent refresh, specify the name of a column that can be\nused as a unique index on the materialized view. unique index can be defined on more than one column of a materialized \nview. once enabled, passing `concurrently=true` to the model's refresh method will result in postgres performing the \nrefresh concurrently. (note that the refresh method itself blocks until the refresh is complete; concurrent refresh is \nmost useful when materialized views are updated in another process or thread.)\n\nexample:\n\n```python\nfrom django_pgviews import view as pg\n\n\nview_sql = \"\"\"\n    select id, name, post_code from myapp_customer where is_preferred = true\n\"\"\"\n\nclass preferredcustomer(pg.materializedview):\n    concurrent_index = 'id, post_code'\n    sql = view_sql\n\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n\n\n@receiver(post_save, sender=customer)\ndef customer_saved(sender, action=none, instance=none, **kwargs):\n    preferredcustomer.refresh(concurrently=true)\n```\n\n#### indexes\n\nas the materialized view isn't defined through the usual django model fields, any indexes defined there won't be \ncreated on the materialized view. luckily django provides a meta option called `indexes` which can be used to add custom\nindexes to models. `pg_views` supports defining indexes on materialized views using this option.\n\nin the following example, one index will be created, on the `name` column. the `db_index=true` on the field definition\nfor `post_code` will get ignored.\n\n```python\nfrom django_pgviews import view as pg\n\n\nview_sql = \"\"\"\n    select id, name, post_code from myapp_customer where is_preferred = true\n\"\"\"\n\nclass preferredcustomer(pg.materializedview):\n    sql = view_sql\n\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20, db_index=true)\n    \n    class meta:\n        managed = false  # don't forget this, otherwise django will think it's a regular model\n        indexes = [\n             models.index(fields=[\"name\"]),\n        ]\n```\n\n#### with no data\n\nmaterialized views can be created either with or without data. by default, they are created with data, however\n`pg_views` supports creating materialized views without data, by defining `with_data = false` for the\n`pg.materializedview` class. such views then do not support querying until the first \nrefresh (raising `django.db.utils.operationalerror`).\n\nexample:\n\n```python\nfrom django_pgviews import view as pg\n\nclass preferredcustomer(pg.materializedview):\n    concurrent_index = 'id, post_code'\n    sql = \"\"\"\n        select id, name, post_code from myapp_customer where is_preferred = true\n    \"\"\"\n    with_data = false\n\n    name = models.charfield(max_length=100)\n    post_code = models.charfield(max_length=20)\n```\n\n#### conditional materialized views recreate\n\nsince all materialized views are recreated on running `migrate`, it can lead to obsolete recreations even if there\nwere no changes to the definition of the view. to prevent this, version 0.7.0 and higher contain a feature which\nchecks existing materialized view definition in the database (if the mat. view exists at all) and compares the\ndefinition with the one currently defined in your `pg.materializedview` subclass. if the definition matches\nexactly, the re-create of materialized view is skipped.\n\nthis feature is enabled by setting the `materialized_views_check_sql_changed` in your django settings to `true`, \nwhich enables the feature when running `migrate`. the command `sync_pgviews` uses this setting as well,\nhowever it also has switches `--enable-materialized-views-check-sql-changed` and\n`--disable-materialized-views-check-sql-changed` which override this setting for that command.\n\nthis feature also takes into account indexes. when a view is deemed not needing recreating, the process will still\ncheck the indexes on the table and delete any extra indexes and create any missing indexes. this reconciliation\nis done through the index name, so if you use custom names for your indexes, it might happen that it won't get updated\non change of the content but not the name.\n\n### custom schema\n\nyou can define any table name you wish for your views. they can even live inside your own custom\n[postgresql schema](http://www.postgresql.org/docs/current/static/ddl-schemas.html).\n\n```python\nfrom django_pgviews import view as pg\n\n\nclass preferredcustomer(pg.view):\n    sql = \"\"\"select * from myapp_customer where is_preferred = true;\"\"\"\n\n    class meta:\n      db_table = 'my_custom_schema.preferredcustomer'\n      managed = false\n```\n\n### dynamic view sql\n\nif you need a dynamic view sql (for example if it needs a value from settings in it), you can override the `run_sql`\nclassmethod on the view to return the sql. the method should return a namedtuple `viewsql`, which contains the query\nand potentially the params to `cursor.execute` call. params should be either none or a list of parameters for the query.\n\n```python\nfrom django.conf import settings\nfrom django_pgviews import view as pg\n\n\nclass preferredcustomer(pg.view):\n    @classmethod\n    def get_sql(cls):\n        return pg.viewsql(\n            \"\"\"select * from myapp_customer where is_preferred = true and created_at >= %s;\"\"\",\n            [settings.min_preferred_customer_created_at]\n        )\n\n    class meta:\n      db_table = 'preferredcustomer'\n      managed = false\n```\n\n### sync listeners\n\ndjango-pgviews 0.5.0 adds the ability to listen to when a `post_sync` event has\noccurred.\n\n#### `view_synced`\n\nfired every time a view is synchronised with the database.\n\nprovides args:\n* `sender` - view class\n* `update` - whether the view to be updated\n* `force` - whether `force` was passed\n* `status` - the result of creating the view e.g. `exists`, `force_required`\n* `has_changed` - whether the view had to change\n\n#### `all_views_synced`\n\nsent after all postgres views are synchronised.\n\nprovides args:\n* `sender` - always `none`\n\n\n### multiple databases\n\ndjango-pgviews can use multiple databases.  similar to django's `migrate`\nmanagement command, our commands (`clear_pgviews`, `refresh_pgviews`,\n`sync_pgviews`) operate on one database at a time. you can specify which\ndatabase to synchronize by providing the `--database` option. for example:\n\n```shell\npython manage.py sync_pgviews  # uses default db\npython manage.py sync_pgviews --database=myotherdb\n```\n\nunless using custom routers, django-pgviews will sync all views to the specified\ndatabase. if you want to interact with multiple databases automatically, you'll\nneed to take some additional steps. please refer to django's [automatic database\nrouting](https://docs.djangoproject.com/en/3.2/topics/db/multi-db/#automatic-database-routing)\nto pin views to specific databases.\n\n\n## django compatibility\n\n<table>\n  <thead>\n    <tr>\n      <th>django version</th>\n      <th>django-pgview version</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1.4 and down</td>\n      <td>unsupported</td>\n    </tr>\n    <tr>\n      <td>1.5</td>\n      <td>0.0.1</td>\n    </tr>\n    <tr>\n      <td>1.6</td>\n      <td>0.0.3</td>\n    </tr>\n    <tr>\n      <td>1.7</td>\n      <td>0.0.4</td>\n    </tr>\n    <tr>\n      <td>1.9</td>\n      <td>0.1.0</td>\n    </tr>\n    <tr>\n      <td>1.10</td>\n      <td>0.2.0</td>\n    </tr>\n    <tr>\n      <td>2.2</td>\n      <td>0.6.0</td>\n    </tr>\n    <tr>\n      <td>3.0</td>\n      <td>0.6.0</td>\n    </tr>\n    <tr>\n      <td>3.1</td>\n      <td>0.6.1</td>\n    <tr>\n      <td>3.2</td>\n      <td>0.7.1</td>\n    </tr>\n    <tr>\n      <td>4.0</td>\n      <td>0.8.1</td>\n    </tr>\n    <tr>\n      <td>4.1</td>\n      <td>0.8.4</td>\n    </tr>\n    <tr>\n      <td>4.2</td>\n      <td>0.9.2</td>\n    </tr>\n    <tr>\n      <td>5.0</td>\n      <td>0.9.4</td>\n    </tr>\n  </tbody>\n</table>\n\n## python 3 support\n\ndjango pgviews redux only officially supports python 3.7+, it might work on 3.6, but there's no guarantees.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "public domain",
  "name": "django-pgviews-redux",
  "package_url": "https://pypi.org/project/django-pgviews-redux/",
  "project_url": "https://pypi.org/project/django-pgviews-redux/",
  "project_urls": {
    "Homepage": "https://github.com/xelixdev/django-pgviews-redux"
  },
  "release_url": "https://pypi.org/project/django-pgviews-redux/0.9.4/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "create and manage postgres sql views in django",
  "version": "0.9.4",
  "releases": [],
  "developers": [
    "mikulas.poul@xelix.com"
  ],
  "kwds": "django_pgviews pg_views pgviews pgview django",
  "license_kwds": "public domain",
  "libtype": "pypi",
  "id": "pypi_django_pgviews_redux",
  "homepage": "https://github.com/xelixdev/django-pgviews-redux",
  "release_count": 16,
  "dependency_ids": []
}