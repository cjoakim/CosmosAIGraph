{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "git filter-repo is a versatile tool for rewriting history, which includes\n[capabilities i have not found anywhere\nelse](#design-rationale-behind-filter-repo).  it roughly falls into the\nsame space of tool as [git\nfilter-branch](https://git-scm.com/docs/git-filter-branch) but without the\ncapitulation-inducing poor\n[performance](https://public-inbox.org/git/cabpp-bgoz8nks0+tdw5gygqxeyr-3ff6ft5jcgvqzdyvrq6qog@mail.gmail.com/),\nwith far more capabilities, and with a design that scales usability-wise\nbeyond trivial rewriting cases.  [git filter-repo is now recommended by the\ngit project](https://git-scm.com/docs/git-filter-branch#_warning) instead\nof git filter-branch.\n\nwhile most users will probably just use filter-repo as a simple command\nline tool (and likely only use a few of its flags), at its core filter-repo\ncontains a library for creating history rewriting tools.  as such, users\nwith specialized needs can leverage it to quickly create [entirely new\nhistory rewriting tools](contrib/filter-repo-demos).\n\n# table of contents\n\n  * [prerequisites](#prerequisites)\n  * [how do i install it?](#how-do-i-install-it)\n  * [how do i use it?](#how-do-i-use-it)\n  * [why filter-repo instead of other alternatives?](#why-filter-repo-instead-of-other-alternatives)\n    * [filter-branch](#filter-branch)\n    * [bfg repo cleaner](#bfg-repo-cleaner)\n  * [simple example, with comparisons](#simple-example-with-comparisons)\n    * [solving this with filter-repo](#solving-this-with-filter-repo)\n    * [solving this with bfg repo cleaner](#solving-this-with-bfg-repo-cleaner)\n    * [solving this with filter-branch](#solving-this-with-filter-branch)\n    * [solving this with fast-export/fast-import](#solving-this-with-fast-exportfast-import)\n  * [design rationale behind filter-repo](#design-rationale-behind-filter-repo)\n  * [how do i contribute?](#how-do-i-contribute)\n  * [is there a code of conduct?](#is-there-a-code-of-conduct)\n  * [upstream improvements](#upstream-improvements)\n\n# prerequisites\n\nfilter-repo requires:\n\n  * git >= 2.22.0 at a minimum; [some features](#upstream-improvements)\n    require git >= 2.24.0 or later\n  * python3 >= 3.5\n\n# how do i install it?\n\ngit-filter-repo is a single-file python script, which was done to make\ninstallation for basic use on many systems trivial: just place the\nscript into your $path.\n\nsee [install.md](install.md) for things beyond basic usage or special\ncases.  the more involved instructions are needed if you\n\n  * are working with a python3 executable named something other than \"python3\"\n  * want to install documentation (beyond the builtin docs shown with -h)\n  * want to run some of the [contrib](contrib/filter-repo-demos/) examples\n  * want to create your own python filtering scripts using filter-repo as a\n    module/library\n\n# how do i use it?\n\nsee the [user\nmanual](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html).\n\nif you prefer learning from examples:\n  * the [simple example](#simple-example-with-comparisons) below may\n    be of interest\n  * the user manual has an extensive [examples\nsection](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#examples)\n  * there is a [cheat sheet for converting filter-branch\n    commands](documentation/converting-from-filter-branch.md#cheat-sheet-conversion-of-examples-from-the-filter-branch-manpage),\n    which covers every example from the filter-branch manual\n  * there is a [cheat sheet for converting bfg repo cleaner\n    commands](documentation/converting-from-bfg-repo-cleaner.md#cheat-sheet-conversion-of-examples-from-bfg),\n    which covers every example from the bfg website\n\nexternal sites also have [alternative formats of the user\nmanual](https://www.mankier.com/1/git-filter-repo) available, at least\nfor the most recent release.  this also may be beneficial if\nhtmlpreview.github.io starts hitting load limits.\n\n# why filter-repo instead of other alternatives?\n\nthis was covered in more detail in a [git rev news article on\nfilter-repo](https://git.github.io/rev_news/2019/08/21/edition-54/#an-introduction-to-git-filter-repo--written-by-elijah-newren),\nbut some highlights for the main competitors:\n\n## filter-branch\n\n  * filter-branch is [extremely to unusably\n    slow](https://public-inbox.org/git/cabpp-bgoz8nks0+tdw5gygqxeyr-3ff6ft5jcgvqzdyvrq6qog@mail.gmail.com/)\n    ([multiple orders of magnitude slower than it should\n    be](https://git-scm.com/docs/git-filter-branch#performance))\n    for non-trivial repositories.\n\n  * [filter-branch is riddled with\n    gotchas](https://git-scm.com/docs/git-filter-branch#safety) that can\n    silently corrupt your rewrite or at least thwart your \"cleanup\"\n    efforts by giving you something more problematic and messy than what\n    you started with.\n\n  * filter-branch is [very onerous](#simple-example-with-comparisons)\n    [to\n    use](https://github.com/newren/git-filter-repo/blob/a6a6a1b0f62d365bbe2e76f823e1621857ec4dbd/contrib/filter-repo-demos/filter-lamely#l9-l61)\n    for any rewrite which is even slightly non-trivial.\n\n  * the git project has stated that the above issues with filter-branch\n    cannot be backward compatibly fixed; they recommend that you [stop\n    using\n    filter-branch](https://git-scm.com/docs/git-filter-branch#_warning)\n\n  * die-hard fans of filter-branch may be interested in\n    [filter-lamely](contrib/filter-repo-demos/filter-lamely)\n    (a.k.a. [filter-branch-ish](contrib/filter-repo-demos/filter-branch-ish)),\n    a reimplementation of filter-branch based on filter-repo which is\n    more performant (though not nearly as fast or safe as\n    filter-repo).\n\n  * a [cheat\n    sheet](documentation/converting-from-filter-branch.md#cheat-sheet-conversion-of-examples-from-the-filter-branch-manpage)\n    is available showing how to convert example commands from the manual of\n    filter-branch into filter-repo commands.\n\n## bfg repo cleaner\n\n  * great tool for its time, but while it makes some things simple, it\n    is limited to a few kinds of rewrites.\n\n  * its architecture is not amenable to handling more types of\n    rewrites.\n\n  * its architecture presents some shortcomings and bugs even for its\n    intended usecase.\n\n  * fans of bfg may be interested in\n    [bfg-ish](contrib/filter-repo-demos/bfg-ish), a reimplementation of bfg\n    based on filter-repo which includes several new features and bugfixes\n    relative to bfg.\n\n  * a [cheat\n    sheet](documentation/converting-from-bfg-repo-cleaner.md#cheat-sheet-conversion-of-examples-from-bfg)\n    is available showing how to convert example commands from the manual of\n    bfg repo cleaner into filter-repo commands.\n\n# simple example, with comparisons\n\nlet's say that we want to extract a piece of a repository, with the intent\non merging just that piece into some other bigger repo.  for extraction, we\nwant to:\n\n  * extract the history of a single directory, src/.  this means that only\n    paths under src/ remain in the repo, and any commits that only touched\n    paths outside this directory will be removed.\n  * rename all files to have a new leading directory, my-module/ (e.g. so that\n    src/foo.c becomes my-module/src/foo.c)\n  * rename any tags in the extracted repository to have a 'my-module-'\n    prefix (to avoid any conflicts when we later merge this repo into\n    something else)\n\n## solving this with filter-repo\n\ndoing this with filter-repo is as simple as the following command:\n```shell\n  git filter-repo --path src/ --to-subdirectory-filter my-module --tag-rename '':'my-module-'\n```\n(the single quotes are unnecessary, but make it clearer to a human that we\nare replacing the empty string as a prefix with `my-module-`)\n\n## solving this with bfg repo cleaner\n\nbfg repo cleaner is not capable of this kind of rewrite; in fact, all\nthree types of wanted changes are outside of its capabilities.\n\n## solving this with filter-branch\n\nfilter-branch comes with a pile of caveats (more on that below) even\nonce you figure out the necessary invocation(s):\n\n```shell\n  git filter-branch \\\n      --tree-filter 'mkdir -p my-module && \\\n                     git ls-files \\\n                         | grep -v ^src/ \\\n                         | xargs git rm -f -q && \\\n                     ls -d * \\\n                         | grep -v my-module \\\n                         | xargs -i files mv files my-module/' \\\n          --tag-name-filter 'echo \"my-module-$(cat)\"' \\\n\t  --prune-empty -- --all\n  git clone file://$(pwd) newcopy\n  cd newcopy\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git gc --prune=now\n```\n\nsome might notice that the above filter-branch invocation will be really\nslow due to using --tree-filter; you could alternatively use the\n--index-filter option of filter-branch, changing the above commands to:\n\n```shell\n  git filter-branch \\\n      --index-filter 'git ls-files \\\n                          | grep -v ^src/ \\\n                          | xargs git rm -q --cached;\n                      git ls-files -s \\\n                          | sed \"s%$(printf \\\\t)%&my-module/%\" \\\n                          | git update-index --index-info;\n                      git ls-files \\\n                          | grep -v ^my-module/ \\\n                          | xargs git rm -q --cached' \\\n      --tag-name-filter 'echo \"my-module-$(cat)\"' \\\n      --prune-empty -- --all\n  git clone file://$(pwd) newcopy\n  cd newcopy\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git gc --prune=now\n```\n\nhowever, for either filter-branch command there are a pile of caveats.\nfirst, some may be wondering why i list five commands here for\nfilter-branch.  despite the use of --all and --tag-name-filter, and\nfilter-branch's manpage claiming that a clone is enough to get rid of\nold objects, the extra steps to delete the other tags and do another\ngc are still required to clean out the old objects and avoid mixing\nnew and old history before pushing somewhere.  other caveats:\n  * commit messages are not rewritten; so if some of your commit\n    messages refer to prior commits by (abbreviated) sha1, after the\n    rewrite those messages will now refer to commits that are no longer\n    part of the history.  it would be better to rewrite those\n    (abbreviated) sha1 references to refer to the new commit ids.\n  * the --prune-empty flag sometimes misses commits that should be\n    pruned, and it will also prune commits that *started* empty rather\n    than just ended empty due to filtering.  for repositories that\n    intentionally use empty commits for versioning and publishing\n    related purposes, this can be detrimental.\n  * the commands above are os-specific.  gnu vs. bsd issues for sed,\n    xargs, and other commands often trip up users; i think i failed to\n    get most folks to use --index-filter since the only example in the\n    filter-branch manpage that both uses it and shows how to move\n    everything into a subdirectory is linux-specific, and it is not\n    obvious to the reader that it has a portability issue since it\n    silently misbehaves rather than failing loudly.\n  * the --index-filter version of the filter-branch command may be two to\n    three times faster than the --tree-filter version, but both\n    filter-branch commands are going to be multiple orders of magnitude\n    slower than filter-repo.\n  * both commands assume all filenames are composed entirely of ascii\n    characters (even special ascii characters such as tabs or double\n    quotes will wreak havoc and likely result in missing files or\n    misnamed files)\n\n## solving this with fast-export/fast-import\n\none can kind of hack this together with something like:\n\n```shell\n  git fast-export --no-data --reencode=yes --mark-tags --fake-missing-tagger \\\n      --signed-tags=strip --tag-of-filtered-object=rewrite --all \\\n      | grep -vp '^m [0-9]+ [0-9a-f]+ (?!src/)' \\\n      | grep -vp '^d (?!src/)' \\\n      | perl -pe 's%^(m [0-9]+ [0-9a-f]+ )(.*)$%\\1my-module/\\2%' \\\n      | perl -pe 's%^(d )(.*)$%\\1my-module/\\2%' \\\n      | perl -pe s%refs/tags/%refs/tags/my-module-% \\\n      | git -c core.ignorecase=false fast-import --date-format=raw-permissive \\\n            --force --quiet\n  git for-each-ref --format=\"delete %(refname)\" refs/tags/ \\\n      | grep -v refs/tags/my-module- \\\n      | git update-ref --stdin\n  git reset --hard\n  git reflog expire --expire=now --all\n  git gc --prune=now\n```\n\nbut this comes with some nasty caveats and limitations:\n  * the various greps and regex replacements operate on the entire\n    fast-export stream and thus might accidentally corrupt unintended\n    portions of it, such as commit messages.  if you needed to edit\n    file contents and thus dropped the --no-data flag, it could also\n    end up corrupting file contents.\n  * this command assumes all filenames in the repository are composed\n    entirely of ascii characters, and also exclude special characters\n    such as tabs or double quotes.  if such a special filename exists\n    within the old src/ directory, it will be pruned even though it\n    was intended to be kept.  (in slightly different repository\n    rewrites, this type of editing also risks corrupting filenames\n    with special characters by adding extra double quotes near the end\n    of the filename and in some leading directory name.)\n  * this command will leave behind huge numbers of useless empty\n    commits, and has no realistic way of pruning them.  (and if you\n    tried to combine this technique with another tool to prune the\n    empty commits, then you now have no way to distinguish between\n    commits which were made empty by the filtering that you want to\n    remove, and commits which were empty before the filtering process\n    and which you thus may want to keep.)\n  * commit messages which reference other commits by hash will now\n    reference old commits that no longer exist.  attempting to edit\n    the commit messages to update them is extraordinarily difficult to\n    add to this kind of direct rewrite.\n\n# design rationale behind filter-repo\n\nnone of the existing repository filtering tools did what i wanted;\nthey all came up short for my needs.  no tool provided any of the\nfirst eight traits below i wanted, and all failed to provide at least\none of the last four traits as well:\n\n  1. [starting report] provide user an analysis of their repo to help\n     them get started on what to prune or rename, instead of expecting\n     them to guess or find other tools to figure it out.  (triggered, e.g.\n     by running the first time with a special flag, such as --analyze.)\n\n  1. [keep vs. remove] instead of just providing a way for users to\n     easily remove selected paths, also provide flags for users to\n     only *keep* certain paths.  sure, users could workaround this by\n     specifying to remove all paths other than the ones they want to\n     keep, but the need to specify all paths that *ever* existed in\n     **any** version of the repository could sometimes be quite\n     painful.  for filter-branch, using pipelines like `git ls-files |\n     grep -v ... | xargs -r git rm` might be a reasonable workaround\n     but can get unwieldy and isn't as straightforward for users; plus\n     those commands are often operating-system specific (can you spot\n     the gnuism in the snippet i provided?).\n\n  1. [renaming] it should be easy to rename paths.  for example, in\n     addition to allowing one to treat some subdirectory as the root\n     of the repository, also provide options for users to make the\n     root of the repository just become a subdirectory.  and more\n     generally allow files and directories to be easily renamed.\n     provide sanity checks if renaming causes multiple files to exist\n     at the same path.  (and add special handling so that if a commit\n     merely copied oldname->newname without modification, then\n     filtering oldname->newname doesn't trigger the sanity check and\n     die on that commit.)\n\n  1. [more intelligent safety] writing copies of the original refs to\n     a special namespace within the repo does not provide a\n     user-friendly recovery mechanism.  many would struggle to recover\n     using that.  almost everyone i've ever seen do a repository\n     filtering operation has done so with a fresh clone, because\n     wiping out the clone in case of error is a vastly easier recovery\n     mechanism.  strongly encourage that workflow by [detecting and\n     bailing if we're not in a fresh\n     clone](https://htmlpreview.github.io/?https://github.com/newren/git-filter-repo/blob/docs/html/git-filter-repo.html#freshclone),\n     unless the user overrides with --force.\n\n  1. [auto shrink] automatically remove old cruft and repack the\n     repository for the user after filtering (unless overridden); this\n     simplifies things for the user, helps avoid mixing old and new\n     history together, and avoids problems where the multi-step\n     process for shrinking the repo documented in the manpage doesn't\n     actually work in some cases.  (i'm looking at you,\n     filter-branch.)\n\n  1. [clean separation] avoid confusing users (and prevent accidental\n     re-pushing of old stuff) due to mixing old repo and rewritten\n     repo together.  (this is particularly a problem with filter-branch\n     when using the --tag-name-filter option, and sometimes also an\n     issue when only filtering a subset of branches.)\n\n  1. [versatility] provide the user the ability to extend the tool or\n     even write new tools that leverage existing capabilities, and\n     provide this extensibility in a way that (a) avoids the need to\n     fork separate processes (which would destroy performance), (b)\n     avoids making the user specify os-dependent shell commands (which\n     would prevent users from sharing commands with each other), (c)\n     takes advantage of rich data structures (because hashes, dicts,\n     lists, and arrays are prohibitively difficult in shell) and (d)\n     provides reasonable string manipulation capabilities (which are\n     sorely lacking in shell).\n\n  1. [old commit references] provide a way for users to use old commit\n     ids with the new repository (in particular via mapping from old to\n     new hashes with refs/replace/ references).\n\n  1. [commit message consistency] if commit messages refer to other\n     commits by id (e.g. \"this reverts commit 01234567890abcdef\", \"in\n     commit 0013deadbeef9a...\"), those commit messages should be\n     rewritten to refer to the new commit ids.\n\n  1. [become-empty pruning] commits which become empty due to filtering\n     should be pruned.  if the parent of a commit is pruned, the first\n     non-pruned ancestor needs to become the new parent.  if no\n     non-pruned ancestor exists and the commit was not a merge, then it\n     becomes a new root commit.  if no non-pruned ancestor exists and\n     the commit was a merge, then the merge will have one less parent\n     (and thus make it likely to become a non-merge commit which would\n     itself be pruned if it had no file changes of its own).  one\n     special thing to note here is that we prune commits which become\n     empty, not commits which start empty.  some projects intentionally\n     create empty commits for versioning or publishing reasons, and\n     these should not be removed.  (as a special case, commits which\n     started empty but whose parent was pruned away will also be\n     considered to have \"become empty\".)\n\n  1. [become-degenerate pruning] pruning of commits which become empty\n     can potentially cause topology changes, and there are lots of\n     special cases.  normally, merge commits are not removed since they\n     are needed to preserve the graph topology, but the pruning of\n     parents and other ancestors can ultimately result in the loss of\n     one or more parents.  a simple case was already noted above: if a\n     merge commit loses enough parents to become a non-merge commit and\n     it has no file changes, then it too can be pruned.  merge commits\n     can also have a topology that becomes degenerate: it could end up\n     with the merge_base serving as both parents (if all intervening\n     commits from the original repo were pruned), or it could end up\n     with one parent which is an ancestor of its other parent.  in such\n     cases, if the merge has no file changes of its own, then the merge\n     commit can also be pruned.  however, much as we do with empty\n     pruning we do not prune merge commits that started degenerate\n     (which indicates it may have been intentional, such as with --no-ff\n     merges) but only merge commits that become degenerate and have no\n     file changes of their own.\n\n  1. [speed] filtering should be reasonably fast\n\n# how do i contribute?\n\nsee the [contributing guidelines](documentation/contributing.md).\n\n# is there a code of conduct?\n\nparticipants in the filter-repo community are expected to adhere to\nthe same standards as for the git project, so the [git code of\nconduct](https://git.kernel.org/pub/scm/git/git.git/tree/code_of_conduct.md)\napplies.\n\n# upstream improvements\n\nwork on filter-repo and [its\npredecessor](https://public-inbox.org/git/51419b2c0904072035u1182b507o836a67ac308d32b9@mail.gmail.com/)\nhas also driven numerous improvements to fast-export and fast-import\n(and occasionally other commands) in core git, based on things\nfilter-repo needs to do its work:\n\n  * git-2.28.0\n    * [fast-import: add new --date-format=raw-permissive format](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d42a2fb72f)\n  * git-2.24.0\n    * [fast-export: handle nested tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=941790d7de)\n    * [t9350: add tests for tags of things other than a commit](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8d7d33c1ce)\n    * [fast-export: allow user to request tags be marked with --mark-tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a1638cfe12)\n    * [fast-export: add support for --import-marks-if-exists](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=208d69246e)\n    * [fast-import: add support for new 'alias' command](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=b8f50e5b60)\n    * [fast-import: allow tags to be identified by mark labels](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f73b2aba05)\n    * [fast-import: fix handling of deleted tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=3164e6bd24)\n    * [fast-export: fix exporting a tag and nothing else](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=af2abd870b)\n    * [git-fast-import.txt: clarify that multiple merge commits are allowed](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d1387d3895)\n  * git-2.23.0\n    * [t9350: fix encoding test to actually test reencoding](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=32615ce762)\n    * [fast-import: support 'encoding' commit header](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=3edfcc65fd)\n    * [fast-export: avoid stripping encoding header if we cannot reencode](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=ccbfc96dc4)\n    * [fast-export: differentiate between explicitly utf-8 and implicitly\n      utf-8](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=57a8be2cb0)\n    * [fast-export: do automatic reencoding of commit messages only if\n      requested](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=e80001f8fd)\n  * git-2.22.0\n    * [log,diff-tree: add --combined-all-paths option](\n        https://git.kernel.org/pub/scm/git/git.git/commit/?id=d76ce4f734)\n    * [t9300: demonstrate bug with get-mark and empty orphan commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=62edbec7de)\n    * [git-fast-import.txt: fix wording about where ls command can appear](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a63c54a019)\n    * [fast-import: check most prominent commands first](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=5056bb7646)\n    * [fast-import: only allow cat-blob requests where it makes sense](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=7ffde293f2)\n    * [fast-import: fix erroneous handling of get-mark with empty orphan\n      commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=cf7b857a77)\n    * [honor core.precomposeunicode in more places](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8e712ef6fc)\n  * git-2.21.0\n    * [fast-export: convert sha1 to oid](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=843b9e6d48)\n    * [git-fast-import.txt: fix documentation for --quiet option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f55c979b14)\n    * [git-fast-export.txt: clarify misleading documentation about rev-list\n      args](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=4532be7cba)\n    * [fast-export: use value from correct enum](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=b93b81e799)\n    * [fast-export: avoid dying when filtering by paths and old tags exist](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=1f30c904b3)\n    * [fast-export: move commit rewriting logic into a function for reuse](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=f129c4275c)\n    * [fast-export: when using paths, avoid corrupt stream with non-existent\n      mark](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=cd13762d8f)\n    * [fast-export: ensure we export requested refs](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=fdf31b6369)\n    * [fast-export: add --reference-excluded-parents option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=530ca19c02)\n    * [fast-import: remove unmaintained duplicate documentation](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=25dd3e4889)\n    * [fast-export: add a --show-original-ids option to show\n      original names](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=a965bb3116)\n    * [git-show-ref.txt: fix order of flags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=bd8d6f0def)\n  * git-2.20.0\n    * [update-ref: fix type of update_flags variable to\n      match its usage](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=e4c34855a2)\n    * [update-ref: allow --no-deref with --stdin](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d345e9fbe7)\n  * git-1.7.3\n    * [fast-export: fix dropping of files with --import-marks and path\n      limiting](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=4087a02e45)\n    * [fast-export: add a --full-tree option](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=7f40ab0916)\n    * [fast-export: fix output order of d/f changes](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=060df62422)\n    * [fast-import: improve robustness when d->f changes provided in wrong\n      order](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=253fb5f889)\n  * git-1.6.4:\n    * [fast-export: set revs.topo_order before calling setup_revisions](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=668f3aa776)\n    * [fast-export: omit tags that tag trees](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=02c48cd69b)\n    * [fast-export: make sure we show actual ref names instead of \"(null)\"](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=2374502c6c)\n    * [fast-export: do parent rewriting to avoid dropping relevant commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=32164131db)\n    * [fast-export: add a --tag-of-filtered-object option for newly\n      dangling tags](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=2d8ad46919)\n    * [add new fast-export testcases](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=25e0ca5dd6)\n    * [fast-export: document the fact that git-rev-list arguments are\n      accepted](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=8af15d282e)\n  * git-1.6.3:\n    * [git-filter-branch: avoid collisions with variables in eval'ed\n      commands](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=d5b0c97d13)\n    * [correct missing sp characters in grammar comment at top of\n      fast-import.c](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=98e1a4186a)\n    * [fast-export: avoid dropping files from commits](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=ebeec7dbc5)\n  * git-1.6.1.4:\n    * [fast-export: ensure we traverse commits in topological order](\n      https://git.kernel.org/pub/scm/git/git.git/commit/?id=784f8affe4)\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "git-filter-repo",
  "package_url": "https://pypi.org/project/git-filter-repo/",
  "project_url": "https://pypi.org/project/git-filter-repo/",
  "project_urls": {
    "Homepage": "https://github.com/newren/git-filter-repo",
    "Issues": "https://github.com/newren/git-filter-repo/issues/",
    "Source": "https://github.com/newren/git-filter-repo"
  },
  "release_url": "https://pypi.org/project/git-filter-repo/2.38.0/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "quickly rewrite git repository history",
  "version": "2.38.0",
  "releases": [],
  "developers": [],
  "kwds": "git github branches filtering commits",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_git_filter_repo",
  "homepage": "https://github.com/newren/git-filter-repo",
  "release_count": 12,
  "dependency_ids": []
}