{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "intended audience :: financial and insurance industry",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: office/business :: financial :: accounting"
  ],
  "description": "pyxero\n======\n\n[![python versions](https://img.shields.io/pypi/pyversions/pyxero.svg)](https://pypi.python.org/pypi/pyxero) [![pypi version](https://img.shields.io/pypi/v/pyxero.svg)](https://pypi.python.org/pypi/pyxero) [![maturity](https://img.shields.io/pypi/status/pyxero.svg)](https://pypi.python.org/pypi/pyxero) [![bsd license](https://img.shields.io/pypi/l/pyxero.svg)](https://github.com/freakboy3742/pyxero/blob/master/license) [![build status](https://github.com/freakboy3742/pyxero/workflows/build%20status/badge.svg)](https://github.com/freakboy3742/pyxero/actions)\n\npyxero is a python api for accessing the rest api provided by the [xero](https://developer.xero.com)\naccounting tool. it allows access to both public, private and partner applications.\n\n## quickstart:\n\ninstall this library using the python package manager:\n\n```\npip install pyxero\n```\n\n### using oauth2 credentials\n\noauth2 is an open standard authorization protocol that allows users to\nprovide specific permissions to apps that want to use their account. oauth2\nauthentication is performed using *tokens* that are obtained using an api;\nthese tokens are then provided with each subsequent request.\n\noauth2 tokens have a 30 minute expiry, but can be swapped for a new token at any\ntime. xero documentation on the oauth2 process can be found\n[here](https://developer.xero.com/documentation/oauth2/overview/). the procedure\nfor creating and authenticating credentials is as follows *(with a django\nexample at the end)*:\n\n 1) [register your app](https://developer.xero.com/myapps) with xero, using a\n    redirect uri which will be served by your app in order to complete the\n    authorisation e.g. `https://mysite.com/oauth/xero/callback/`. see step 3 for\n    an example of what your app should do. generate a client secret, then store\n    it and the client id somewhere that your app can access them, such as a\n    config file.\n\n 2) construct an `oauth2credentials` instance using the details from the first\n    step.\n    ```python\n    >>> from xero.auth import oauth2credentials\n    >>>\n    >>> credentials = oauth2credentials(client_id, client_secret,\n    >>>                                 callback_uri=callback_uri)\n    ```\n    if neccessary pass in a list of scopes to define the scopes required by your\n    app. e.g. if write access is required to transactions and payroll employees:\n\n    ```python\n    >>> from xero.constants import xeroscopes\n    >>>\n    >>> my_scope = [xeroscopes.accounting_transactions,\n    >>>             xeroscopes.payroll_employees]\n    >>> credentials = oauth2credentials(client_id, client_secret, scope=my_scope\n    >>>                                 callback_uri=callback_uri)\n    ```\n    the default scopes are `['offline_access', 'accounting.transactions.read',\n    'accounting.contacts.read']`. `offline_access` is required in order for\n    tokens to be refreshable. for more details on scopes see xero's\n    [documentation]( https://developer.xero.com/documentation/oauth2/scopes).\n\n 3) generate a xero authorisation url which the user can visit to complete\n    authorisation. then store the state of the credentials object and redirect\n    the user to the url in their browser.\n    ```python\n    >>> authorisation_url = credentials.generate_url()\n    >>>\n    >>> # now store credentials.state somewhere accessible, e.g a cache\n    >>> mycache['xero_creds'] = credentials.state\n    >>>\n    >>> # then redirect the user to authorisation_url\n    ...\n    ```\n    the callback uri should be the redirect uri you used in step 1.\n\n 4) after authorization the user will be redirected from xero to the\n    callback uri provided in step 1, along with a querystring containing the\n    authentication secret. when your app processes this request, it should pass\n    the full uri including querystring to `verify()`:\n    ```python\n    >>> # recreate the credentials object\n    >>> credentials = oauth2credentials(**mycache['xero_creds'])\n    >>>\n    >>> # get the full redirect uri from the request including querystring\n    >>> # e.g. request_uri = 'https://mysite.com/oauth/xero/callback/?code=0123456789&scope=openid%20profile&state=87784234sdf5ds8ad546a8sd545ss6'\n    >>>\n    >>> credentials.verify(request_uri)\n    ```\n    a token will be fetched from xero and saved as `credentials.token`. if the\n    credentials object needs to be created again either dump the whole object\n    using:\n    ```python\n    >>> cred_state = credentials.state\n    >>> ...\n    >>> new_creds = oauth2credentials(**cred_state)\n    ```\n    or just use the client_id, client_secret and token (and optionally scopes\n    and tenant_id):\n    ```python\n    >>> token = credentials.token\n    >>> ...\n    >>> new_creds = oauth2credentials(client_id, client_secret, token=token)\n    ```\n\n 5) now the credentials may be used to authorize a xero session. as oauth2\n    allows authentication for multiple xero organisations, it is necessary to\n    set the tenant_id against which the xero client's queries will run.\n    ```python\n    >>> from xero import xero\n    >>> # use the first xero organisation (tenant) permitted\n    >>> credentials.set_default_tenant()\n    >>> xero = xero(credentials)\n    >>> xero.contacts.all()\n    >>> ...\n    ```\n    if the scopes supplied in step 2 did not require access to organisations\n    (e.g. when only requesting scopes for single sign) it will not be\n    possible to make requests with the xero api and `set_default_tenant()` will\n    raise an exception.\n\n    to pick from multiple possible xero organisations the `tenant_id` may be set\n    explicitly:\n    ```python\n    >>> tenants = credentials.get_tenants()\n    >>> credentials.tenant_id = tenants[1]['tenantid']\n    >>> xero = xero(credentials)\n    ```\n    `oauth2credentials.__init__()` accepts `tenant_id` as a keyword argument.\n\n 6) when using the api over an extended period, you will need to exchange tokens\n    when they expire. if a refresh token is available, it can be used to\n    generate a new token:\n    ```python\n    >>> if credentials.expired():\n    >>>     credentials.refresh()\n    >>>     # then store the new credentials or token somewhere for future use:\n    >>>     cred_state = credentials.state\n    >>>     # or\n    >>>     new_token = credentials.token\n\n    **important**: ``credentials.state`` changes after a token swap. be sure to\n    persist the new state.\n\n    ```\n #### django oauth2 app example\n this example shows authorisation, automatic token refreshing and api use in\n a django app which has read/write access to contacts and transactions. if the\n cache used is cleared on server restart, the token will be lost and\n verification will have to take place again.\n\n ```python\nfrom django.http import httpresponseredirect\nfrom django.core.cache import caches\n\nfrom xero import xero\nfrom xero.auth import oauth2credentials\nfrom xero.constants import xeroscopes\n\ndef start_xero_auth_view(request):\n    # get client_id, client_secret from config file or settings then\n    credentials = oauth2credentials(\n        client_id, client_secret, callback_uri=callback_uri,\n        scope=[xeroscopes.offline_access, xeroscopes.accounting_contacts,\n               xeroscopes.accounting_transactions]\n    )\n    authorization_url = credentials.generate_url()\n    caches['mycache'].set('xero_creds', credentials.state)\n    return httpresponseredirect(authorization_url)\n\ndef process_callback_view(request):\n    cred_state = caches['mycache'].get('xero_creds')\n    credentials = oauth2credentials(**cred_state)\n    auth_secret = request.build_absolute_uri()\n    credentials.verify(auth_secret)\n    credentials.set_default_tenant()\n    caches['mycache'].set('xero_creds', credentials.state)\n\ndef some_view_which_calls_xero(request):\n    cred_state = caches['mycache'].get('xero_creds')\n    credentials = oauth2credentials(**cred_state)\n    if credentials.expired():\n        credentials.refresh()\n        caches['mycache'].set('xero_creds', credentials.state)\n    xero = xero(credentials)\n\n    contacts = xero.contacts.all()\n    ...\n ```\n\n### using pkce credentials\n\npkce is an alternative flow for providing authentication via oauth2. it works\nlargely the same as the standard oauth2 mechanism, but unlike the normal flow is\ndesigned to work with applications which cannot keep private keys secure, such\nas desktop, mobile or single page apps where such secrets could be extracted. a\nclient id is still required.\n\nas elsewhere, oauth2 tokens have a 30 minute expiry, but can be only swapped for\na new token if the `offline_access` scope is requested.\n\nxero documentation on the pkce flow can be found\n[here](https://developer.xero.com/documentation/guides/oauth2/pkce-flow). the\nprocedure for creating and authenticating credentials is as follows *(with a cli\nexample at the end)*:\n\n 1) [register your app](https://developer.xero.com/myapps) with xero, using a\n    redirect uri which will be served by your app in order to complete the\n    authorisation e.g. `http://localhost:<port>/callback/`. you can chose any\n    port, anc can pass it to the credentials object on construction, allow with\n    the the client id you are provded with.\n\n 2) construct an `oauth2credentials` instance using the details from the first\n    step.\n\n    ```python\n    >>> from xero.auth import oauth2credentials\n    >>>\n    >>> credentials = oauth2pkcecredentials(client_id,   port=my_port)\n    ```\n\n    if neccessary, pass in a list of scopes to define the scopes required by\n    your app. e.g. if write access is required to transactions and payroll\n    employees:\n\n    ```python\n    >>> from xero.constants import xeroscopes\n    >>>\n    >>> my_scope = [xeroscopes.accounting_transactions,\n    >>>             xeroscopes.payroll_employees]\n    >>> credentials = oauth2credentials(client_id, scope=my_scope\n    >>>                                 port=my_port)\n    ```\n\n    the default scopes are `['offline_access', 'accounting.transactions.read',\n    'accounting.contacts.read']`. `offline_access` is required in order for\n    tokens to be refreshable. for more details on scopes see [xero's\n    documentation on oauth2\n    scopes](https://developer.xero.com/documentation/oauth2/scopes).\n\n 3) call `credentials.logon()` . this will open a browser window, an visit\n    a xero authentication page.\n\n    ```python\n    >>> credentials.logon()\n    ```\n\n    the authenticator will also start a local webserver on the provided port.\n    this webserver will be used to collect the tokens that xero returns.\n\n    the default `pckeauthreceiver` class has no reponse pages defined so the\n    browser will show an error, on empty page for all transactions. but the\n    application is now authorised and will continue. if you wish you can\n    override the `send_access_ok()` method, and the `send_error_page()` method\n    to create a more userfriendly experience.\n\n    in either case once the callback url has been visited the local server will\n    shutdown.\n\n 4) you can now continue as per the normal oauth2 flow. now the credentials may\n    be used to authorize a xero session. as oauth2 allows authentication for\n    multiple xero organisations, it is necessary to set the tenant_id against\n    which the xero client's queries will run.\n\n    ```python\n    >>> from xero import xero\n    >>> # use the first xero organisation (tenant) permitted\n    >>> credentials.set_default_tenant()\n    >>> xero = xero(credentials)\n    >>> xero.contacts.all()\n    >>> ...\n    ```\n    if the scopes supplied in step 2 did not require access to organisations\n    (e.g. when only requesting scopes for single sign) it will not be possible\n    to make requests with the xero api and `set_default_tenant()` will raise an\n    exception.\n\n    to pick from multiple possible xero organisations the `tenant_id` may be set\n    explicitly:\n\n    ```python\n    >>> tenants = credentials.get_tenants()\n    >>> credentials.tenant_id = tenants[1]['tenantid']\n    >>> xero = xero(credentials)\n    ```\n    `oauth2credentials.__init__()` accepts `tenant_id` as a keyword argument.\n\n 5) when using the api over an extended period, you will need to exchange tokens\n    when they expire. if a refresh token is available, it can be used to\n    generate a new token:\n\n    ```python\n    >>> if credentials.expired():\n    >>>     credentials.refresh()\n    >>>     # then store the new credentials or token somewhere for future use:\n    >>>     cred_state = credentials.state\n    >>>     # or\n    >>>     new_token = credentials.token\n\n    **important**: ``credentials.state`` changes after a token swap. be sure to\n    persist the new state.\n\n    ```\n\n#### cli oauth2 app example\n\nthis example shows authorisation, automatic token refreshing and api use in\na django app which has read/write access to contacts and transactions.\n\neach time this app starts it asks for authentication, but you\ncould consider using the user `keyring` to store tokens.\n\n```python\nfrom xero import xero\nfrom xero.auth import oauth2pkcecredentials\nfrom xero.constants import xeroscopes\n\n# get client_id, client_secret from config file or settings then\ncredentials = oauth2pkcecredentials(\n    client_id, port=8080,\n    scope=[xeroscopes.offline_access, xeroscopes.accounting_contacts,\n            xeroscopes.accounting_transactions]\n)\ncredentials.logon()\ncredentials.set_default_tenant()\n\nfor contacts in xero.contacts.all()\n    print contact[\"name\"]\n```\n\n### older authentication methods ###\n\nin the past, xero had the concept of \"public\", \"private\", and \"partner\"\napplications, which each had their own authentication procedures. however,\nthey removed access for public applications on 31 march 2021; private\napplications were removed on 30 september 2021. partner applications\nstill exist, but the only supported authentication method is oauth2; these\nare now referred to as \"oauth2 apps\". as xero no longer supports these older\nauthentication methods, neither does pyxero.\n\n## using the xero api\n\n*this api is a work in progress. at present, there is no wrapper layer\nto help create real objects, it just returns dictionaries in the exact\nformat provided by the xero api. this will change into a more useful api\nbefore 1.0*\n\nthe xero api object exposes a simple api for retrieving and updating objects.\nfor example, to deal with contacts::\n\n```python\n# retrieve all contact objects\n>>> xero.contacts.all()\n[{...contact info...}, {...contact info...}, {...contact info...}, ...]\n\n# retrieve a specific contact object\n>>> xero.contacts.get(u'b2b5333a-2546-4975-891f-d71a8a640d23')\n{...contact info...}\n\n# retrieve all contacts updated since 1 jan 2013\n>>> xero.contacts.filter(since=datetime(2013, 1, 1))\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# retrieve all contacts whose name is 'john smith'\n>>> xero.contacts.filter(name='john smith')\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# retrieve all contacts whose name starts with 'john'\n>>> xero.contacts.filter(name__startswith='john')\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# retrieve all contacts whose name ends with 'smith'\n>>> xero.contacts.filter(name__endswith='smith')\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# retrieve all contacts whose name starts with 'john' and ends with 'smith'\n>>> xero.contacts.filter(name__startswith='john', name__endswith='smith')\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# retrieve all contacts whose name contains 'mit'\n>>> xero.contacts.filter(name__contains='mit')\n[{...contact info...}, {...contact info...}, {...contact info...}]\n\n# create a new object\n>>> xero.contacts.put({...contact info...})\n\n# create multiple new objects\n>>> xero.contacts.put([{...contact info...}, {...contact info...}, {...contact info...}])\n\n# save an update to an existing object\n>>> c = xero.contacts.get(u'b2b5333a-2546-4975-891f-d71a8a640d23')\n>>> c['name'] = 'john smith'\n>>> xero.contacts.save(c)\n\n# save multiple objects\n>>> xero.contacts.save([c1, c2])\n```\n\ncomplex filters can be constructed in the django-way, for example retrieving invoices for a contact:\n\n```python\n>>> xero.invoices.filter(contact_contactid='83ad77d8-48a7-4f77-9146-e6933b7fb63b')\n```\n\nfilters which aren't supported by this api can also be constructed using 'raw' mode like this:\n```python\n>>> xero.invoices.filter(raw='amountdue > 0')\n```\n\nbe careful when dealing with large amounts of data, the xero api will take an\nincreasingly long time to respond, or an error will be returned. if a query might\nreturn more than 100 results, you should make use of the ``page`` parameter::\n\n```python\n# grab 100 invoices created after 01-01-2013\n>>> xero.invoices.filter(since=datetime(2013, 1, 1), page=1)\n```\n\nyou can also order the results to be returned::\n\n```python\n# grab contacts ordered by emailaddress\n>>> xero.contacts.filter(order='emailaddress desc')\n```\n\nfor invoices (and other objects that can be retrieved as pdfs), accessing the pdf is done\nvia setting the accept header:\n\n```python\n# fetch a pdf\ninvoice = xero.invoices.get('af722e93-b64f-482d-9955-1b027bfec896', \\\n    headers={'accept': 'application/pdf'})\n# stream the pdf to the user (django specific example)\nresponse = httpresponse(invoice, content_type='application/pdf')\nresponse['content-disposition'] = 'attachment; filename=\"invoice.pdf\"'\nreturn response\n```\n\ndownload and uploading attachments is supported using the xero guid of the relevant object::\n\n```python\n# list attachments on a contact\n>>> xero.contacts.get_attachments(c['contactid'])\n[{...attachment info...}, {...attachment info...}]\n\n# attach a pdf to a contact\n>>> f = open('form.pdf', 'rb')\n>>> xero.contacts.put_attachment(c['contactid'], 'form.pdf', f, 'application/pdf')\n>>> f.close()\n\n>>> xero.contacts.put_attachment_data(c['contactid'], 'form.pdf', data, 'application/pdf')\n\n# download an attachment\n>>> f = open('form.pdf', 'wb')\n>>> xero.contacts.get_attachment(c['contactid'], 'form.pdf', f)\n>>> f.close()\n\n>>> data = xero.contacts.get_attachment_data(c['contactid'], 'form.pdf')\n```\n\nthis same api pattern exists for the following api objects:\n\n* accounts\n* attachments\n* banktransactions\n* banktransfers\n* brandingthemes\n* contactgroups\n* contacts\n* creditnotes\n* currencies\n* employees\n* expenseclaims\n* invoices\n* items\n* journals\n* manualjournals\n* organisation\n* overpayments\n* payments\n* prepayments\n* purchase orders\n* receipts\n* repeatinginvoices\n* reports\n* taxrates\n* trackingcategories\n* users\n\n\n## payroll\n\nin order to access the payroll methods from xero, you can do it like this:\n\n```\nxero.payrollapi.payruns.all()\n```\n\nwithin the payrollapi you have access to:\n\n* employees\n* leaveapplications\n* payitems\n* payrollcalendars\n* payruns\n* payslip\n* superfunds\n* timesheets\n\n\n## projects\n\nin order to access the projects methods from xero, you can do it like this:\n\n```\nxero.projectsapi.projects.all()\n```\n\nwithin the projectsapi you have access to:\n\n* projects\n* projectsusers\n* tasks\n* time\n\n\n## under the hood\n\nusing a wrapper around xero api is a really nice feature, but it's also interesting to understand what is exactly\nhappening under the hood.\n\n### filter operator\n\n``filter`` operator wraps the \"where\" keyword in xero api.\n\n```python\n# retrieves all contacts whose name is \"john\"\n>>> xero.contacts.filter(name=\"john\")\n\n# triggers this get request:\nhtml encoded: <xero_api_url>/contacts?where=name%3d%3d%22john%22\nnon encoded:  <xero_api_url>/contacts?where=name==\"john\"\n```\n\nseveral parameters are separated with encoded '&&' characters:\n\n```python\n# retrieves all contacts whose first name is \"john\" and last name is \"doe\"\n>>> xero.contacts.filter(firstname=\"john\", lastname=\"doe\")\n\n# triggers this get request:\nhtml encoded: <xero_api_url>/contacts?where=lastname%3d%3d%22doe%22%26%26firstname%3d%3d%22john%22\nnon encoded:  <xero_api_url>/contacts?where=lastname==\"doe\"&&firstname==\"john\"\n\n```\n\nunderscores are automatically converted as \"dots\":\n```python\n# retrieves all contacts whose name is \"john\"\n>>> xero.contacts.filter(first_name=\"john\")\n\n# triggers this get request:\nhtml encoded: <xero_api_url>/contacts?where=first.name%3d%3d%22john%22%\nnon encoded:  <xero_api_url>/contacts?where=first.name==\"john\"\n```\n\n## contributing\n\nif you're going to run the pyxero test suite, in addition to the dependencies\nfor pyxero, you need to add the following dependency to your environment:\n\n    mock >= 1.0\n\nmock isn't included in the formal dependencies because they aren't required\nfor normal operation of pyxero. it's only required for testing purposes.\n\nonce you've installed these dependencies, you can run the test suite by\nrunning the following from the root directory of the project:\n\n    $ python setup.py test\n\nif you find any problems with pyxero, you can log them on [github issues](https://github.com/freakboy3742/pyxero/issues).\nwhen reporting problems, it's extremely helpful if you can provide\nreproduction instructions -- the sequence of calls and/or test data that\ncan be used to reproduce the issue.\n\nnew features or bug fixes can be submitted via a pull request. if you want\nyour pull request to be merged quickly, make sure you either include\nregression test(s) for the behavior you are adding/fixing, or provide a\ngood explanation of why a regression test isn't possible.\n",
  "docs_url": null,
  "keywords": "",
  "license": "new bsd",
  "name": "pyxero",
  "package_url": "https://pypi.org/project/pyxero/",
  "project_url": "https://pypi.org/project/pyxero/",
  "project_urls": {
    "Homepage": "http://github.com/freakboy3742/pyxero"
  },
  "release_url": "https://pypi.org/project/pyxero/0.9.4/",
  "requires_dist": [
    "requests <3,>=1.1.0",
    "requests-oauthlib <2,>=0.3.0",
    "python-dateutil <3,>=2.8",
    "PyJWT <3,>=1.6.4",
    "cryptography >=1.3.1",
    "pre-commit ==3.0.2 ; extra == 'dev'",
    "pytest ==7.2.1 ; extra == 'dev'",
    "pytest-tldr ==0.2.5 ; extra == 'dev'",
    "tox ==4.4.2 ; extra == 'dev'"
  ],
  "requires_python": ">=3.8",
  "summary": "python api for accessing the rest api of the xero accounting tool.",
  "version": "0.9.4",
  "releases": [],
  "developers": [
    "russell@keith-magee.com",
    "russell_keith"
  ],
  "kwds": "pyxero pyversions pypi build cli",
  "license_kwds": "new bsd",
  "libtype": "pypi",
  "id": "pypi_pyxero",
  "homepage": "http://github.com/freakboy3742/pyxero",
  "release_count": 11,
  "dependency_ids": [
    "pypi_cryptography",
    "pypi_pre_commit",
    "pypi_pyjwt",
    "pypi_pytest",
    "pypi_pytest_tldr",
    "pypi_python_dateutil",
    "pypi_requests",
    "pypi_requests_oauthlib",
    "pypi_tox"
  ]
}