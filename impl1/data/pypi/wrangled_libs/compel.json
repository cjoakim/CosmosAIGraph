{
  "classifiers": [
    "license :: osi approved :: gnu affero general public license v3",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# compel\na text prompt weighting and blending library for transformers-type text embedding systems, by [@damian0815](https://github.com/damian0815).\n\nwith a flexible and intuitive syntax, you can re-weight different parts of a prompt string and thus re-weight the different parts of the embedding tensor produced from the string.\n\ntested and developed against hugging face's `stablediffusionpipeline` but it should work with any diffusers-based system that uses an `tokenizer` and a `text encoder` of some kind.  \n\nadapted from the [invokeai](https://github.com/invoke-ai) prompting code (also by [@damian0815](https://github.com/damian0815)).\n\nnote that cross-attention control `.swap()` is currently ignored by compel, but you can use it by calling `build_conditioning_tensor_for_prompt_object()` yourself, and implementing cross-attention control in your diffusion loop.\n\n### installation\n\n`pip install compel`\n\n### documentation\n\ndocumentation is [here](doc/).\n\n### demo\n\nsee [compel-demo.ipynb](compel-demo.ipynb)\n\n<a target=\"_blank\" href=\"https://colab.research.google.com/github/damian0815/compel/blob/main/compel-demo.ipynb\">\n  <img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"open in colab\"/>\n</a>\n\n### quickstart\n\nwith hugging face diffusers >=0.12:\n\n```python\nfrom diffusers import stablediffusionpipeline\nfrom compel import compel\n\npipeline = stablediffusionpipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\")\ncompel = compel(tokenizer=pipeline.tokenizer, text_encoder=pipeline.text_encoder)\n\n# upweight \"ball\"\nprompt = \"a cat playing with a ball++ in the forest\"\nconditioning = compel.build_conditioning_tensor(prompt)\n# or: conditioning = compel([prompt])\n\n# generate image\nimages = pipeline(prompt_embeds=conditioning, num_inference_steps=20).images\nimages[0].save(\"image.jpg\")\n```\n\nfor batched input, use the __call__ interface to compel:\n\n```python\nfrom diffusers import stablediffusionpipeline\nfrom compel import compel\n\npipeline = stablediffusionpipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\")\ncompel = compel(tokenizer=pipeline.tokenizer, text_encoder=pipeline.text_encoder)\n\nprompts = [\"a cat playing with a ball++ in the forest\", \"a dog playing with a ball in the forest\"]\nprompt_embeds = compel(prompts)\nimages = pipeline(prompt_embeds=prompt_embeds).images\n\nimages[0].save(\"image0.jpg\")\nimages[1].save(\"image1.jpg\")\n```\n\n### textual inversion support\n\nif you want to have access to \ud83e\udd17diffusers textual inversions, instantiate a `diffuserstextualinversionmanager` and pass it on compel init:\n\n```\npipeline = stablediffusionpipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\")\ntextual_inversion_manager = diffuserstextualinversionmanager(pipeline)\ncompel = compel(tokenizer=pipeline.tokenizer, text_encoder=pipeline.text_encoder, \n    textual_inversion_manager=textual_inversion_manager)\n```\n\n## memory usage/vram leaks\n\nif you run into memory issues, please make sure you're running compel inside `with torch.no_grad():` blocks. \n\nif this doesn't help, you could try this advice offered by @kshieh1: \n> after image generation, you should explictly de-reference the tensor object (i.e., prompt_embeds = none) and call gc.collect()\n\nsee https://github.com/damian0815/compel/issues/24 for more details. thanks @kshieh1 !\n\n## changelog\n\n#### 2.0.2 - fix for `pipeline.enable_sequential_cpu_offloading()` with sdxl models (you need to pass `device='cuda'` on compel init)\n\n#### 2.0.1 - fix for [#45](https://github.com/damian0815/compel/issues/45) padding issue with sdxl non-truncated prompts and `.and()` \n\n### 2.0.0 - sdxl support\n\nwith big thanks to patrick von platen from hugging face for [the pull request](https://github.com/damian0815/compel/pull/41), compel now supports sdxl. use it like this: \n\n```py\nfrom compel import compel, returnedembeddingstype\nfrom diffusers import diffusionpipeline\nimport torch\n\npipeline = diffusionpipeline.from_pretrained(\"stabilityai/stable-diffusion-xl-base-1.0\", variant=\"fp16\", use_safetensors=true, torch_dtype=torch.float16).to(\"cuda\")\ncompel = compel(tokenizer=[pipeline.tokenizer, pipeline.tokenizer_2] , text_encoder=[pipeline.text_encoder, pipeline.text_encoder_2], returned_embeddings_type=returnedembeddingstype.penultimate_hidden_states_non_normalized, requires_pooled=[false, true])\n# upweight \"ball\"\nprompt = \"a cat playing with a ball++ in the forest\"\nconditioning, pooled = compel(prompt)\n# generate image\nimage = pipeline(prompt_embeds=conditioning, pooled_prompt_embeds=pooled, num_inference_steps=30).images[0]\n```\n\nplease note that this is a **breaking change** if you've been using clip skip: the old boolean arg `use_penultimate_clip_layer` has been replaced with an enum `returnedembeddingstype.penultimate_hidden_states_normalized`.\n\n\n#### 1.2.1 - actually apply `.and()` weights\n\n### 1.2.0 - concatenate embeddings using `.and()`\n\nfor stable diffusion 2.1 i've been experimenting with a new feature: concatenated embeddings. what i noticed, for example, is that for more complex prompts image generation quality becomes wildly better when the prompt is broken into multiple parts and fed to openclip separately.\n\ntl;dr: you can now experiment with breaking up your prompts into segments, which for sd2.1 appears to improve the generated image. the syntax is `(\"prompt part 1\", \"prompt part 2\").and()`. you can have more than one part, and you can also weight them, eg `(\"a man eating an apple\", \"sitting on the roof of a car\", \"high quality, trending on artstation, 8k uhd\").and(1, 0.5, 0.5)` which will assign weight `1` to `man eating an apple` and `0.5` to `sitting on the roof of a car` and `high quality, trending on artstation, 8k uhd`. \n\nhere's a nonsense example from the invokeai discord #garbage-bin channel, created by gogurt enjoyer's incredible [nightmare prompt generator](https://huggingface.co/cactusfriend/nightmare-invokeai-prompts):\n\n```\na moist sloppy pindlesackboy sloppy hamblin' bogomadong, clem fandango is pissed-off, wario's woods in background, making a noise like ga-woink-a\n```\n\nplugging this straight into sd2.1 we get this, which is really not a good image:\n![](images/000075.6dfd7adf.466129594.png)\n\nhowever, if the prompt is broken up into chunks and fed into openclip separately as four separate prompts, and then concatenated:\n\n```\na moist sloppy pindlesackboy sloppy hamblin' bogomadong\n\nclem fandango is pissed-off\n\nwario's woods in background\n\nmaking a noise like ga-woink-a\n```\n\nthen output image with the same seed is *so much* better:\n![](images/000076.68b1c320.466129594.png)\n\nin the new `.and()` syntax you would prompt this as follows:\n```\n(\"a moist sloppy pindlesackboy sloppy hamblin' bogomadong\", \"clem fandango is pissed-off\", \"wario's woods in background\", \"making a noise like ga-woink-a\").and()\n```\n\nthe effect can be more or less subtle. here for example is \n```\na dream of a distant galaxy, by caspar david friedrich, matte painting, trending on artstation, hq\n```\n![](images/000129.1b33b559.2793529321.png)\n\nand the same split into two parts:\n```\na dream of a distant galaxy, by caspar david friedrich, matte painting\n\ntrending on artstation, hq\n```\n![](images/000128.b5d5cd62.2793529321.png)\n\nthe compel prompt for this is: \n```\n(\"a dream of a distant galaxy, by caspar david friedrich, matte painting\", \"trending on artstation, hq\").and()\n```\n\n\n\n\n#### 1.1.6 - misc small fixes\n- add `diffuserstextualinversionmanager` (thanks @pdoane)\n- fix batch embedding generation with truncated/non-truncated prompt lengths (#18, thanks @abassino)\n- add note about memory leakage (ref #24, thanks @kshieh1) \n- fix incorrect parsing when commas are not followed by whitespace (#34, thanks @moono)\n\n#### 1.1.5 - fix for compel turning numbers into floats for text inside parentheses\n\n#### 1.1.4 - fixes for #23 (sequential offload) and invokeai issue #3442 (allow hyphens in lora names) \n\n#### 1.1.3 - enable fetching the penultimate clip hidden layer (aka \"clip skip\")\n\nto use, pass `use_penultimate_clip_layer=true` when initializing your `compel` instance. note that there's no need to pass this flag for sd2.0/sd2.1 because diffusers already throws away the last hidden layer when loading the sd2.0+ text encoder.\n\n#### 1.1.2 - fix for #21 (crash when parsing long prompts with truncation enabled if there is weighted fragments beyond the truncation boundary)\n\n#### 1.1.1 - fix for #22 (issues parsing `.` characters inside parentheses)\n\n#### 1.1.0 - support for parsing `withlora`/`uselora` on `parse_prompt_string()`.\n\n* `compel.parse_prompt_string()` now returns a `conjunction`\n* any appearances of `withlora(name[, weight])` or `uselora(name[, weight])` anywhere in the prompt string will be parsed to `loraweight` instances, and returned on the outermost `conjunction` returned by `parse_prompt_string()`.\n\n#### 1.0.5 - fix incorrect parsing when passing invalid (auto1111) syntax that has a float\n\nalso fix test case for default swap parameters\n\n#### 1.0.4 - fix embeddings for empty swap target (eg `cat.swap(\"\")`) when truncation is disabled \n\n#### 1.0.3 - better defaults for .swap (https://github.com/damian0815/compel/issues/8)\n\n#### 1.0.2 - fix padding for non-truncated batched embeddings (https://github.com/damian0815/compel/issues/9)\n\n#### 1.0.1 - fix for invokeai's `--free_gpu_mem` option\n\n### 1.0.0 - new downweighting algorithm \n\ndownweighting now works by applying an attention mask to remove the downweighted tokens, rather than literally removing them from the sequence. this behaviour is the default, but the old behaviour can be re-enabled by passing `downweight_mode=downweightmode.remove` on init of the `compel` instance.\n\nformerly, downweighting a token worked by both multiplying the weighting of the token's embedding, and doing an inverse-weighted blend with a copy of the token sequence that had the downweighted tokens removed. the intuition is that as weight approaches zero, the tokens being downweighted should be actually removed from the sequence. however, removing the tokens resulted in the positioning of all downstream tokens becoming messed up. the blend ended up blending a lot more than just the tokens in question. \n\nas of v1.0.0, taking advice from @keturn and @bonlime (https://github.com/damian0815/compel/issues/7) the procedure is by default different. downweighting still involves a blend but what is blended is a version of the token sequence with the downweighted tokens masked out, rather than removed. this correctly preserves positioning embeddings of the other tokens. \n\nalso a bugfix: fix black images on weight 0 (https://github.com/invoke-ai/invokeai/issues/2832)\n\n### 0.1.10 - add support for prompts longer than the model's max token length. \n\nto enable, initialize `compel` with `truncate_long_prompts=false` (default is true). prompts that are longer than the model's `max_token_length` will be chunked and padded out to an integer multiple of `max_token_length`. \n\nnote that even if you don't use a negative prompt, you'll need to build a conditioning tensor for a negative prompt of at least `\"\"`, and use `compel.pad_conditioning_tensors_to_same_length()`, otherwise the you'll get an error about mismatched conditioning tensor lengths:\n\n```python\ncompel = compel(..., truncate_long_prompts=false)\nprompt = \"a cat playing with a ball++ in the forest, amazing, exquisite, stunning, masterpiece, skilled, powerful, incredible, amazing, trending on gregstation, greg, greggy, greggs greggson, greggy mcgregface, ...\" # very long prompt\nconditioning = compel.build_conditioning_tensor(prompt)\nnegative_prompt = \"\" # it's necessary to create an empty prompt - it can also be very long, if you want\nnegative_conditioning = compel.build_conditioning_tensor(negative_prompt)\n[conditioning, negative_conditioning] = compel.pad_conditioning_tensors_to_same_length([conditioning, negative_conditioning])\n```\n\n#### 0.1.9 - broken\n\n#### 0.1.8 - downgrade python min version to 3.7\n\n#### 0.1.7 - invokeai compatibility\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "compel",
  "package_url": "https://pypi.org/project/compel/",
  "project_url": "https://pypi.org/project/compel/",
  "project_urls": {
    "Bug Tracker": "https://github.com/damian0815/compel/issues",
    "Homepage": "https://github.com/damian0815/compel"
  },
  "release_url": "https://pypi.org/project/compel/2.0.2/",
  "requires_dist": [
    "diffusers >=0.11",
    "pyparsing ~=3.0",
    "torch",
    "transformers ~=4.25"
  ],
  "requires_python": ">=3.7",
  "summary": "a prompting enhancement library for transformers-type text embedding systems.",
  "version": "2.0.2",
  "releases": [],
  "developers": [
    "null@damianstewart.com"
  ],
  "kwds": "build_conditioning_tensor_for_prompt_object prompt_embeds text_encoder tokenizer parse_prompt_string",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_compel",
  "homepage": "",
  "release_count": 33,
  "dependency_ids": [
    "pypi_diffusers",
    "pypi_pyparsing",
    "pypi_torch",
    "pypi_transformers"
  ]
}