{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: macos",
    "operating system :: posix :: linux",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": ".. image:: https://circleci.com/gh/omni-us/reconplogger.svg?style=svg\n    :target: https://circleci.com/gh/omni-us/reconplogger\n.. image:: https://codecov.io/gh/omni-us/reconplogger/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/omni-us/reconplogger\n.. image:: https://sonarcloud.io/api/project_badges/measure?project=omni-us_reconplogger&metric=alert_status\n    :target: https://sonarcloud.io/dashboard?id=omni-us_reconplogger\n.. image:: https://badge.fury.io/py/reconplogger.svg\n    :target: https://badge.fury.io/py/reconplogger\n.. image:: https://img.shields.io/badge/contributions-welcome-brightgreen.svg\n    :target: https://github.com/omni-us/reconplogger\n\nreconplogger - omni:us python logger\n====================================\n\nthis repository contains the code of reconplogger, a python package intended to\nease the standardization of logging within omni:us. the main design decision of\nreconplogger is to allow total freedom to reconfigure loggers without hard\ncoding anything.\n\nthe package contains essentially three things:\n\n- a default logging configuration.\n- a function for loading logging configuration for regular python code.\n- a function for loading logging configuration for flask-based microservices.\n- an inheritable class to add a logger property.\n- lower level functions for:\n\n  - loading logging configuration from any of: config file, environment variable, or default.\n  - replacing the handlers of an existing logger object.\n  - function to add a file handler to a logger.\n\n\nhow to use\n==========\n\nthere are two main use cases reconplogger targets. one is for logging in regular\ngeneric python code and the second one is logging in microservices. see the two\nstandardizing sections below for a detailed explanation of the two use cases.\n\n\nadd as requirement\n------------------\n\nthe first step to use reconplogger is adding it as a requirement in the\nrespective package where it will be used. this means adding it in the file\n`setup.cfg` as an item in :code:`install_requires` or in an\n:code:`extras_require` depending on whether reconplogger is intended to be a\ncore or an optional requirement.\n\nnote: it is highly discouraged to develop packages in which requirements are\nadded directly to `setup.py` or to have an ambiguous `requirements.txt` file.\nsee the `setup.cfg` file in the reconplogger source code for reference.\n\n\ndefault logging configuration\n-----------------------------\n\na feature that reconplogger provides is the possibility of externally setting\nthe logging configuration without having to change code or implement any parsing\nof configuration. however, if a logging configuration is not given externally,\nreconplogger provides a default configuration.\n\nthe default configuration defines three handlers, two of which are stream\nhandlers and are set to debug log level. the first handler called\n:code:`plain_handler` uses a simple plain text formatter, and the second handler\ncalled :code:`json_handler` as the name suggests outputs in json format, using\nthe `logmatic <https://pypi.org/project/logmatic-python/>`_ jsonformatter class.\nthe third handler called :code:`null_handler` is useful to disable all logging.\n\nfor each handler the default configuration defines a corresponding logger:\n:code:`plain_logger`, :code:`json_logger` and :code:`null_logger`.\n\n\nstandardizing logging in regular python\n---------------------------------------\n\none objective of reconplogger is to ease the use of logging and standardize the\nway it is done across all omni:us python code. the use of reconplogger comes\ndown to calling one function to get the logger object. for regular python code\n(i.e. not a microservice) the function to use is\n`reconplogger.logger_setup`.\n\nthe following code snippet illustrates the use:\n\n.. code-block:: python\n\n    import reconplogger\n\n    # default plain logger\n    logger = reconplogger.logger_setup()\n    logger.info('my log message')\n\n    # json logger and custom prefix\n    logger = reconplogger.logger_setup('json_logger', env_prefix='myapp')\n    logger.info('my log message in json format')\n\nthis function gives you the ability to set the default logger to use\n(:code:`logger_name` argument whose default value is :code:`plain_logger`) and\noptionally provide a logging :code:`config` and/or a logging :code:`level` that\noverrides the level in the config.\n\nall of these values can be overridden via environment variables whose names are\nprefixed by the value of the :code:`env_prefix` argument. the environment\nvariables supported are: :code:`{env_prefix}_cfg`, :code:`{env_prefix}_name` and\n:code:`{env_prefix}_level`. note that the environment variable names are not\nrequired to be prefixed by the default :code:`env_prefix='logger'`. the prefix\ncan be chosen by the user for each particular application.\n\nfor functions or classes that receive logger object as an argument, it might be\ndesired to set a non-logging default so that it can be called without specifying\none. for this reconplogger defines :code:`null logger` that could be used as\nfollows:\n\n.. code-block:: python\n\n    from reconplogger import null_logger\n\n    ...\n\n    def my_func(arg1, arg2, logger=null_logger):\n\n    ...\n\n\nstandardizing logging in flask-based microservices\n--------------------------------------------------\n\nthe most important objective of reconplogger is to allow standardization of a\nstructured logging format for all microservices developed. thus, the logging\nfrom all microservices should be configured like explained here. the use is\nanalogous to the previous case, but using the function\n`reconplogger.flask_app_logger_setup` instead, and giving as first argument\nthe flask app object.\n\nadditional to the previous case, this function:\n\n- replaces the flask app and werkzeug loggers to use a reconplogger configured one.\n- add to the logs the correlation_id\n- add before and after request functions to log the request details when the request is processed\n- patch the *requests* library forwarding the correlation id in any call to other microservices\n\n**what is the correlation id?**\nin a system build with microservices we need a way to correlate logs coming from different microservices to the same \"external\" call.\nfor example when a user of our system do a call to the microservicea this could need to retrieve some information from the microserviceb,\nif there is an error and we want to check the logs of the microserviceb related to the user call we don't have a way to correlate them,\nto solve this we use the correlation id!\nits a uuid4 that its passed in the headers of the rest calls and will be forwarded automatically when we do calls with the library *requests*,\nif the correlation id its not present in the request headers it will be generated, all of this is taken care in the background by this library.\n\n\nthe usage would be as follows:\n\n.. code-block:: python\n\n    import reconplogger\n    from flask import flask\n\n    ...\n\n    app = flask(__name__)\n\n    ...\n\n    logger = reconplogger.flask_app_logger_setup(app, level='debug')\n\n    ## note: do not change logger beyond this point!\n\n    ...\n\n    ## use logger in code\n    myclass = myclass(..., logger=logger)\n\n    ...\n\n    ## user logger in a flask request\n    @app.route('/')\n    def hello_world():\n        logger.info('i like logs')\n        correlation_id = reconplogger.get_correlation_id()\n        logger.info('correlation id for this request: '+correlation_id)\n        return 'hello, world!'\n\n    ...\n\nas illustrated in the previous example the `get_correlation_id` function\ncan be used to get the correlation id for the current application context.\nhowever, there are cases in which it is desired to set the correlation id,\ninstead of getting a randomly generated one. in this case the\n`get_correlation_id` function is used, for example as follows:\n\n.. code-block:: python\n\n    @app.route('/')\n    def hello_world():\n        reconplogger.set_correlation_id('my_correlation_id')\n        logger.info('i like logs')\n        return 'hello, world!'\n\nan important note is that after configuring the logger, the code should not\nmodify the logger configuration. for example, the logging level should not be\nmodified. adding an additional handler to the logger is not a problem. this\ncould be desired for example to additionally log to a file.\n\nin the helm `values.yaml` file of the microservice, the default values for the\nenvironment variables should be set as:\n\n.. code-block:: yaml\n\n    logger_cfg:\n    logger_name: json_logger\n    logger_level: debug\n\nwith the :code:`json_logger` logger, the format of the logs should look\nsomething like the following::\n\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"info\", \"filename\": \"test_formatter.py\", \"lineno\": 5, \"message\": \"hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"debug\", \"filename\": \"test_formatter.py\", \"lineno\": 9, \"message\": \"hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"error\", \"filename\": \"test_formatter.py\", \"lineno\": 13, \"message\": \"hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"critical\", \"filename\": \"test_formatter.py\", \"lineno\": 17, \"message\": \"hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"error\", \"filename\": \"test_formatter.py\", \"lineno\": 25, \"message\": \"division by zero\"}\n    {\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"error\", \"filename\": \"test_formatter.py\", \"lineno\": 33, \"message\": \"exception has occured\", \"exc_info\": \"traceback (most recent call last):\\n  file \\\"reconplogger/tests/test_formatter.py\\\", line 31, in test_exception_with_trace\\n    b = 100 / 0\\nzerodivisionerror: division by zero\"}\n    {\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"info\", \"filename\": \"test_formatter.py\", \"lineno\": 37, \"message\": \"hello world\", \"context check\": \"check\"}\n\n    {\"asctime\": \"2020-09-02 17:20:16,428\", \"levelname\": \"info\", \"filename\": \"hello.py\", \"lineno\": 12, \"message\": \"i like logs\", \"correlation_id\": \"3958f378-5d48-4e1c-b83b-3c6d9f95faec\"}\n    {\"asctime\": \"2020-09-02 17:20:16,428\", \"levelname\": \"info\", \"filename\": \"reconplogger.py\", \"lineno\": 271, \"message\": \"request is completed\", \"http_endpoint\": \"/\", \"http_method\": \"get\", \"http_response_code\": 200, \"http_response_size\": 56, \"http_input_payload_size\": null, \"http_input_payload_type\": null, \"http_response_time\": \"0.0002014636993408203\", \"correlation_id\": \"3958f378-5d48-4e1c-b83b-3c6d9f95faec\"}\n\n\nuse of the logger object\n------------------------\n\nthe logger objects returned by the setup functions are normal python\n:code:`logging.logger` objects, so all the standard logging functionalities\nshould be used. please refer to the `logging package documentation\n<https://docs.python.org/3/howto/logging.html>`_ for details.\n\na couple of logging features that should be very commonly used are the\nfollowing. to add additional structured information to a log, the :code:`extra`\nargument should be used. a simple example could be::\n\n    logger.info('successfully processed document', extra={'uuid': uuid})\n\nwhen an exception occurs the :code:`exc_info=true` argument should be used, for\nexample::\n\n    try:\n        ...\n    except:\n        logger.critical('failed to run task', exc_info=true)\n\n\nadding a file handler\n---------------------\n\nin some circumstances it is desired to add to a logger a file handler so that\nthe logging messages are also saved to a file. this normally requires at least\nthree lines of code, thus to simplify things reconplogger provides the\n`reconplogger.add_file_handler` function to do the same with a single line\nof code. the use is quite straightforward as::\n\n    reconplogger.add_file_handler(logger, '/path/to/log/file.log')\n\n\nadding a logging property\n-------------------------\n\nwhen implementing classes it is common to add logging support to it. for this an\ninheritable class `.rloggerproperty` is included in reconplogger to add an\n:code:`rlogger` property to easily set and get the reconplogger logger. an\nexample of use is the following:\n\n.. code-block:: python\n\n    from reconplogger import rloggerproperty\n\n    class myclass(rloggerproperty):\n        def __init__(self, logger):\n            self.rlogger = logger\n        def my_method(self):\n            self.rlogger.error('my_method was called')\n\n    myclass(logger=true).my_method()\n\n\noverriding logging configuration\n--------------------------------\n\nan important feature of reconplogger is that the logging configuration of apps\nthat use it can be easily changed via the environment variables. first set the\nenvironment variables with the desired logging configuration and logger name:\n\n.. code-block:: bash\n\n    export logger_name=\"example_logger\"\n\n    export logger_cfg='{\n        \"version\": 1,\n        \"formatters\": {\n            \"verbose\": {\n                \"format\": \"%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s\"\n            }\n        },\n        \"handlers\": {\n            \"console\":{\n                \"level\":\"debug\",\n                \"class\":\"logging.streamhandler\",\n                \"formatter\": \"verbose\"\n            }\n        },\n        \"loggers\": {\n            \"example_logger\": {\n                \"handlers\": [\"console\"],\n                \"level\": \"error\",\n            }\n        }\n    }'\n\nthen, in the python code the logger would be used as follows:\n\n.. code-block:: python\n\n    >>> import reconplogger\n    >>> logger = reconplogger.logger_setup(env_prefix='logger')\n    >>> logger.error('my error message')\n    error 2019-10-18 14:45:22,629 <stdin> 16876 139918773925696 my error message\n\n\nlow level functions\n===================\n\n\nloading configuration\n---------------------\n\nthe `reconplogger.load_config` function allows loading of a python logging\nconfiguration. the format config can be either json or yaml. the loading of\nconfiguration can be from a file (giving its path), from an environment variable\n(giving the variable name), a raw configuration string, or loading the default\nconfiguration that comes with reconplogger. see below examples of loading for\neach of the cases:\n\n.. code-block:: python\n\n    import reconplogger\n\n    ## load from config file\n    reconplogger.load_config('/path/to/config.yaml')\n\n    ## load from environment variable\n    reconplogger.load_config('logger_cfg')\n\n    ## load default config\n    reconplogger.load_config('reconplogger_default_cfg')\n\n\nreplacing logger handlers\n-------------------------\n\nin some cases it might be needed to replace the handlers of some already\nexisting logger. for this reconplogger provides the\n`reconplogger.replace_logger_handlers` function. to use it, simply provide\nthe logger in which to replace the handlers and the logger from where to get the\nhandlers. the procedure would be as follows:\n\n.. code-block:: python\n\n    import reconplogger\n\n    logger = reconplogger.logger_setup('json_logger')\n    reconplogger.replace_logger_handlers('some_logger_name', logger)\n\n\ncontributing\n============\n\ncontributions to this package are very welcome. when you plan to work with the\nsource code, note that this project does not include a `requirements.txt` file.\nthis is by intention. to make it very clear what are the requirements for\ndifferent use cases, all the requirements of the project are stored in the file\n`setup.cfg`. the basic runtime requirements are defined in section\n:code:`[options]` in the :code:`install_requires` entry. all optional\nrequirements are stored in section :code:`[options.extras_require]`. there are\n:code:`test`, :code:`dev` and :code:`doc` extras require to be used by\ndevelopers (e.g. requirements to run the unit tests) and an :code:`all` extras\nrequire for optional runtime requirements, namely flask support.\n\nthe recommended way to work with the source code is the following. first clone\nthe repository, then create a virtual environment, activate it and finally\ninstall the development requirements. more precisely the steps would be:\n\n.. code-block:: bash\n\n    git clone https://github.com/omni-us/reconplogger.git\n    cd reconplogger\n    virtualenv -p python3 venv\n    . venv/bin/activate\n\nthe crucial step is installing the requirements which would be done by running:\n\n.. code-block:: bash\n\n    pip3 install --editable \".[dev]\"\n\nrunning the unit tests can be done either using using `tox\n<https://tox.readthedocs.io/en/stable/>`__ or the :code:`setup.py` script. the\nunit tests are also installed with the package, thus can be used to in a\nproduction system.\n\n.. code-block:: bash\n\n    tox  # run tests using tox\n    ./setup.py test_coverage  # run tests and generate coverage report\n    python3 -m reconplogger_tests  # run tests for installed package\n\n\npull requests\n-------------\n\n- to contribute it is required to create and push to a new branch and issue a\n  pull request.\n\n- a pull request will only be accepted if:\n\n    - all python files pass pylint checks.\n    - all unit tests run successfully.\n    - new code has docstrings and gets included in the html documentation.\n\n- when developing, after cloning be sure to run the githook-pre-commit to setup\n  the pre-commit hook. this will help you by automatically running pylint before\n  every commit.\n\nusing bump version\n------------------\n\nonly the maintainer of this repo should bump versions and this should be done\nonly on the master branch. to bump the version it is required to use the\nbumpversion command that should already be installed if :code:`pip3 install\n--editable .[dev,doc,test,all]` was run as previously instructed.\n\n.. code-block:: bash\n\n    bumpversion major/minor/patch\n\npush the tags to the repository as well.\n\n.. code-block:: bash\n\n    git push; git push --tags\n\nwhen the version tags are pushed, circleci will automatically build the wheel\nfile, test it and if successful, push the package to pypi.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "reconplogger",
  "package_url": "https://pypi.org/project/reconplogger/",
  "project_url": "https://pypi.org/project/reconplogger/",
  "project_urls": {
    "CircleCI": "https://circleci.com/gh/omni-us/reconplogger",
    "Codecov": "https://codecov.io/gh/omni-us/reconplogger",
    "Documentation-latest": "https://reconplogger.readthedocs.io/en/latest/",
    "Documentation-stable": "https://reconplogger.readthedocs.io/en/stable/",
    "GitHub": "https://github.com/omni-us/reconplogger",
    "Homepage": "https://omni-us.github.io/reconplogger",
    "PyPI": "https://pypi.org/project/reconplogger",
    "SonarCloud": "https://sonarcloud.io/dashboard?id=omni-us_reconplogger"
  },
  "release_url": "https://pypi.org/project/reconplogger/4.12.0/",
  "requires_dist": [
    "logmatic-python (>=0.1.7)",
    "PyYAML (>=3.13)",
    "Flask (>=1.1.1) ; extra == 'all'",
    "requests (>=2.24.0) ; extra == 'all'",
    "Flask (>=1.1.1) ; extra == 'dev'",
    "requests (>=2.24.0) ; extra == 'dev'",
    "testfixtures (==6.10.0) ; extra == 'dev'",
    "coverage (>=4.5.1) ; extra == 'dev'",
    "pre-commit (>=2.19.0) ; extra == 'dev'",
    "pylint (>=1.8.3) ; extra == 'dev'",
    "tox (>=3.25.0) ; extra == 'dev'",
    "Sphinx (>=1.7.9) ; extra == 'doc'",
    "sphinx-rtd-theme (>=0.4.3) ; extra == 'doc'",
    "autodocsumm (>=0.1.10) ; extra == 'doc'",
    "sphinx-autodoc-typehints (>=1.11.1) ; extra == 'doc'",
    "bump2version (>=0.5.11) ; extra == 'maintainer'",
    "twine (>=3.1.1) ; extra == 'maintainer'",
    "testfixtures (==6.10.0) ; extra == 'test'",
    "coverage (>=4.5.1) ; extra == 'test'"
  ],
  "requires_python": ">=3.6",
  "summary": "omni:us python logging package",
  "version": "4.12.0",
  "releases": [],
  "developers": [
    "mauricio@omnius.com",
    "nischal_padmanabha"
  ],
  "kwds": "sonarcloud project_badges badge alert_status helm",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_reconplogger",
  "homepage": "https://omni-us.github.io/reconplogger",
  "release_count": 19,
  "dependency_ids": [
    "pypi_autodocsumm",
    "pypi_bump2version",
    "pypi_coverage",
    "pypi_flask",
    "pypi_logmatic_python",
    "pypi_pre_commit",
    "pypi_pylint",
    "pypi_pyyaml",
    "pypi_requests",
    "pypi_sphinx",
    "pypi_sphinx_autodoc_typehints",
    "pypi_sphinx_rtd_theme",
    "pypi_testfixtures",
    "pypi_tox",
    "pypi_twine"
  ]
}