{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "============\ntime-machine\n============\n\n.. image:: https://img.shields.io/github/actions/workflow/status/adamchainz/time-machine/main.yml?branch=main&style=for-the-badge\n   :target: https://github.com/adamchainz/time-machine/actions?workflow=ci\n\n.. image:: https://img.shields.io/badge/coverage-100%25-success?style=for-the-badge\n   :target: https://github.com/adamchainz/time-machine/actions?workflow=ci\n\n.. image:: https://img.shields.io/pypi/v/time-machine.svg?style=for-the-badge\n   :target: https://pypi.org/project/time-machine/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge\n   :target: https://github.com/psf/black\n\n.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logocolor=white&style=for-the-badge\n   :target: https://github.com/pre-commit/pre-commit\n   :alt: pre-commit\n\ntravel through time in your tests.\n\na quick example:\n\n.. code-block:: python\n\n    import datetime as dt\n    from zoneinfo import zoneinfo\n    import time_machine\n\n    hill_valley_tz = zoneinfo(\"america/los_angeles\")\n\n\n    @time_machine.travel(dt.datetime(1985, 10, 26, 1, 24, tzinfo=hill_valley_tz))\n    def test_delorean():\n        assert dt.date.today().isoformat() == \"1985-10-26\"\n\nfor a bit of background, see `the introductory blog post <https://adamj.eu/tech/2020/06/03/introducing-time-machine/>`__ and `the benchmark blog post <https://adamj.eu/tech/2021/02/19/freezegun-versus-time-machine/>`__.\n\ninstallation\n============\n\nuse **pip**:\n\n.. code-block:: sh\n\n    python -m pip install time-machine\n\npython 3.8 to 3.12 supported.\nonly cpython is supported at this time because time-machine directly hooks into the c-level api.\n\n----\n\n**testing a django project?**\ncheck out my book `speed up your django tests <https://adamchainz.gumroad.com/l/suydt>`__ which covers loads of ways to write faster, more accurate tests.\ni created time-machine whilst writing the book.\n\n----\n\nusage\n=====\n\nif you\u2019re coming from freezegun or libfaketime, see also the below section on migrating.\n\n``travel(destination, *, tick=true)``\n-------------------------------------\n\n``travel()`` is a class that allows time travel, to the datetime specified by ``destination``.\nit does so by mocking all functions from python's standard library that return the current date or datetime.\nit can be used independently, as a function decorator, or as a context manager.\n\n``destination`` specifies the datetime to move to.\nit may be:\n\n* a ``datetime.datetime``.\n  if it is naive, it will be assumed to have the utc timezone.\n  if it has ``tzinfo`` set to a |zoneinfo-instance|_, the current timezone will also be mocked.\n* a ``datetime.date``.\n  this will be converted to a utc datetime with the time 00:00:00.\n* a ``datetime.timedelta``.\n  this will be interpreted relative to the current time.\n  if already within a ``travel()`` block, the ``shift()`` method is easier to use (documented below).\n* a ``float`` or ``int`` specifying a `unix timestamp <https://en.m.wikipedia.org/wiki/unix_time>`__\n* a string, which will be parsed with `dateutil.parse <https://dateutil.readthedocs.io/en/stable/parser.html>`__ and converted to a timestamp.\n  if the result is naive, it will be assumed to be local time.\n\n.. |zoneinfo-instance| replace:: ``zoneinfo.zoneinfo`` instance\n.. _zoneinfo-instance: https://docs.python.org/3/library/zoneinfo.html#zoneinfo.zoneinfo\n\nadditionally, you can provide some more complex types:\n\n* a generator, in which case ``next()`` will be called on it, with the result treated as above.\n* a callable, in which case it will be called with no parameters, with the result treated as above.\n\n``tick`` defines whether time continues to \"tick\" after travelling, or is frozen.\nif ``true``, the default, successive calls to mocked functions return values increasing by the elapsed real time *since the first call.*\nso after starting travel to ``0.0`` (the unix epoch), the first call to any datetime function will return its representation of ``1970-01-01 00:00:00.000000`` exactly.\nthe following calls \"tick,\" so if a call was made exactly half a second later, it would return ``1970-01-01 00:00:00.500000``.\n\nmocked functions\n^^^^^^^^^^^^^^^^\n\nall datetime functions in the standard library are mocked to move to the destination current datetime:\n\n* ``datetime.datetime.now()``\n* ``datetime.datetime.utcnow()``\n* ``time.clock_gettime()`` (only for ``clock_realtime``)\n* ``time.clock_gettime_ns()`` (only for ``clock_realtime``)\n* ``time.gmtime()``\n* ``time.localtime()``\n* ``time.monotonic()`` (not a real monotonic clock, returns ``time.time()``)\n* ``time.monotonic_ns()`` (not a real monotonic clock, returns ``time.time_ns()``)\n* ``time.strftime()``\n* ``time.time()``\n* ``time.time_ns()``\n\nthe mocking is done at the c layer, replacing the function pointers for these built-ins.\ntherefore, it automatically affects everywhere those functions have been imported, unlike use of ``unittest.mock.patch()``.\n\nusage with ``start()`` / ``stop()``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nto use independently, create an instance, use ``start()`` to move to the destination time, and ``stop()`` to move back.\nfor example:\n\n.. code-block:: python\n\n    import datetime as dt\n    import time_machine\n\n    traveller = time_machine.travel(dt.datetime(1985, 10, 26))\n    traveller.start()\n    # it's the past!\n    assert dt.date.today() == dt.date(1985, 10, 26)\n    traveller.stop()\n    # we've gone back to the future!\n    assert dt.date.today() > dt.date(2020, 4, 29)\n\n``travel()`` instances are nestable, but you'll need to be careful when manually managing to call their ``stop()`` methods in the correct order, even when exceptions occur.\nit's recommended to use the decorator or context manager forms instead, to take advantage of python features to do this.\n\nfunction decorator\n^^^^^^^^^^^^^^^^^^\n\nwhen used as a function decorator, time is mocked during the wrapped function's duration:\n\n.. code-block:: python\n\n    import time\n    import time_machine\n\n\n    @time_machine.travel(\"1970-01-01 00:00 +0000\")\n    def test_in_the_deep_past():\n        assert 0.0 < time.time() < 1.0\n\nyou can also decorate asynchronous functions (coroutines):\n\n.. code-block:: python\n\n    import time\n    import time_machine\n\n\n    @time_machine.travel(\"1970-01-01 00:00 +0000\")\n    async def test_in_the_deep_past():\n        assert 0.0 < time.time() < 1.0\n\nbeware: time is a *global* state - `see below <#caveats>`__.\n\ncontext manager\n^^^^^^^^^^^^^^^\n\nwhen used as a context manager, time is mocked during the ``with`` block:\n\n.. code-block:: python\n\n    import time\n    import time_machine\n\n\n    def test_in_the_deep_past():\n        with time_machine.travel(0.0):\n            assert 0.0 < time.time() < 1.0\n\nclass decorator\n^^^^^^^^^^^^^^^\n\nonly ``unittest.testcase`` subclasses are supported.\nwhen applied as a class decorator to such classes, time is mocked from the start of ``setupclass()`` to the end of ``teardownclass()``:\n\n.. code-block:: python\n\n    import time\n    import time_machine\n    import unittest\n\n\n    @time_machine.travel(0.0)\n    class deeppasttests(testcase):\n        def test_in_the_deep_past(self):\n            assert 0.0 < time.time() < 1.0\n\nnote this is different to ``unittest.mock.patch()``\\'s behaviour, which is to mock only during the test methods.\nfor pytest-style test classes, see the pattern `documented below <#pytest-plugin>`__.\n\ntimezone mocking\n^^^^^^^^^^^^^^^^\n\nif the ``destination`` passed to ``time_machine.travel()`` or ``coordinates.move_to()`` has its ``tzinfo`` set to a |zoneinfo-instance2|_, the current timezone will be mocked.\nthis will be done by calling |time-tzset|_, so it is only available on unix.\nthe ``zoneinfo`` module is new in python 3.8 - on older python versions use the |backports-zoneinfo-package|_, by the original ``zoneinfo`` author.\n\n.. |zoneinfo-instance2| replace:: ``zoneinfo.zoneinfo`` instance\n.. _zoneinfo-instance2: https://docs.python.org/3/library/zoneinfo.html#zoneinfo.zoneinfo\n\n.. |time-tzset| replace:: ``time.tzset()``\n.. _time-tzset: https://docs.python.org/3/library/time.html#time.tzset\n\n.. |backports-zoneinfo-package| replace:: ``backports.zoneinfo`` package\n.. _backports-zoneinfo-package: https://pypi.org/project/backports.zoneinfo/\n\n``time.tzset()`` changes the ``time`` module\u2019s `timezone constants <https://docs.python.org/3/library/time.html#timezone-constants>`__ and features that rely on those, such as ``time.localtime()``.\nit won\u2019t affect other concepts of \u201cthe current timezone\u201d, such as django\u2019s (which can be changed with its |timezone-override|_).\n\n.. |timezone-override| replace:: ``timezone.override()``\n.. _timezone-override: https://docs.djangoproject.com/en/stable/ref/utils/#django.utils.timezone.override\n\nhere\u2019s a worked example changing the current timezone:\n\n.. code-block:: python\n\n    import datetime as dt\n    import time\n    from zoneinfo import zoneinfo\n    import time_machine\n\n    hill_valley_tz = zoneinfo(\"america/los_angeles\")\n\n\n    @time_machine.travel(dt.datetime(2015, 10, 21, 16, 29, tzinfo=hill_valley_tz))\n    def test_hoverboard_era():\n        assert time.tzname == (\"pst\", \"pdt\")\n        now = dt.datetime.now()\n        assert (now.hour, now.minute) == (16, 29)\n\n``coordinates``\n---------------\n\nthe ``start()`` method and entry of the context manager both return a ``coordinates`` object that corresponds to the given \"trip\" in time.\nthis has a couple methods that can be used to travel to other times.\n\n``move_to(destination, tick=none)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``move_to()`` moves the current time to a new destination.\n``destination`` may be any of the types supported by ``travel``.\n\n``tick`` may be set to a boolean, to change the ``tick`` flag of ``travel``.\n\nfor example:\n\n.. code-block:: python\n\n    import datetime as dt\n    import time\n    import time_machine\n\n    with time_machine.travel(0, tick=false) as traveller:\n        assert time.time() == 0\n\n        traveller.move_to(234)\n        assert time.time() == 234\n\n``shift(delta)``\n^^^^^^^^^^^^^^^^\n\n``shift()`` takes one argument, ``delta``, which moves the current time by the given offset.\n``delta`` may be a ``timedelta`` or a number of seconds, which will be added to destination.\nit may be negative, in which case time will move to an earlier point.\n\nfor example:\n\n.. code-block:: python\n\n    import datetime as dt\n    import time\n    import time_machine\n\n    with time_machine.travel(0, tick=false) as traveller:\n        assert time.time() == 0\n\n        traveller.shift(dt.timedelta(seconds=100))\n        assert time.time() == 100\n\n        traveller.shift(-dt.timedelta(seconds=10))\n        assert time.time() == 90\n\npytest plugin\n-------------\n\ntime-machine also works as a pytest plugin.\nit provides a function-scoped fixture called ``time_machine`` with methods ``move_to()`` and ``shift()``, which have the same signature as their equivalents in ``coordinates``.\nthis can be used to mock your test at different points in time and will automatically be un-mock when the test is torn down.\n\nfor example:\n\n.. code-block:: python\n\n    import datetime as dt\n\n\n    def test_delorean(time_machine):\n        time_machine.move_to(dt.datetime(1985, 10, 26))\n\n        assert dt.date.today().isoformat() == \"1985-10-26\"\n\n        time_machine.move_to(dt.datetime(2015, 10, 21))\n\n        assert dt.date.today().isoformat() == \"2015-10-21\"\n\n        time_machine.shift(dt.timedelta(days=1))\n\n        assert dt.date.today().isoformat() == \"2015-10-22\"\n\nif you are using pytest test classes, you can apply the fixture to all test methods in a class by adding an autouse fixture:\n\n.. code-block:: python\n\n    import time\n\n    import pytest\n\n\n    class testsomething:\n        @pytest.fixture(autouse=true)\n        def set_time(self, time_machine):\n            time_machine.move_to(1000.0)\n\n        def test_one(self):\n            assert int(time.time()) == 1000.0\n\n        def test_two(self, time_machine):\n            assert int(time.time()) == 1000.0\n            time_machine.move_to(2000.0)\n            assert int(time.time()) == 2000.0\n\n``escape_hatch``\n----------------\n\nthe ``escape_hatch`` object provides functions to bypass time-machine.\nthese allow you to call the real datetime functions, without any mocking.\nit also provides a way to check if time-machine is currently time travelling.\n\nthese capabilities are useful in rare circumstances.\nfor example, if you need to authenticate with an external service during time travel, you may need the real value of ``datetime.now()``.\n\nthe functions are:\n\n* ``escape_hatch.is_travelling() -> bool`` - returns ``true`` if ``time_machine.travel()`` is active, ``false`` otherwise.\n\n* ``escape_hatch.datetime.datetime.now()`` - wraps the real ``datetime.datetime.now()``.\n\n* ``escape_hatch.datetime.datetime.utcnow()`` - wraps the real ``datetime.datetime.utcnow()``.\n\n* ``escape_hatch.time.clock_gettime()`` - wraps the real ``time.clock_gettime()``.\n\n* ``escape_hatch.time.clock_gettime_ns()`` - wraps the real ``time.clock_gettime_ns()``.\n\n* ``escape_hatch.time.gmtime()`` - wraps the real ``time.gmtime()``.\n\n* ``escape_hatch.time.localtime()`` - wraps the real ``time.localtime()``.\n\n* ``escape_hatch.time.strftime()`` - wraps the real ``time.strftime()``.\n\n* ``escape_hatch.time.time()`` - wraps the real ``time.time()``.\n\n* ``escape_hatch.time.time_ns()`` - wraps the real ``time.time_ns()``.\n\nfor example:\n\n.. code-block:: python\n\n    import time_machine\n\n\n    with time_machine.travel(...):\n        if time_machine.escape_hatch.is_travelling():\n            print(\"we need to go back to the future!\")\n\n        real_now = time_machine.escape_hatch.datetime.datetime.now()\n        external_authenticate(now=real_now)\n\ncaveats\n=======\n\ntime is a global state.\nany concurrent threads or asynchronous functions are also be affected.\nsome aren't ready for time to move so rapidly or backwards, and may crash or produce unexpected results.\n\nalso beware that other processes are not affected.\nfor example, if you use sql datetime functions on a database server, they will return the real time.\n\ncomparison\n==========\n\nthere are some prior libraries that try to achieve the same thing.\nthey have their own strengths and weaknesses.\nhere's a quick comparison.\n\nunittest.mock\n-------------\n\nthe standard library's `unittest.mock <https://docs.python.org/3/library/unittest.mock.html>`__ can be used to target imports of ``datetime`` and ``time`` to change the returned value for current time.\nunfortunately, this is fragile as it only affects the import location the mock targets.\ntherefore, if you have several modules in a call tree requesting the date/time, you need several mocks.\nthis is a general problem with unittest.mock - see `why your mock doesn't work <https://nedbatchelder.com//blog/201908/why_your_mock_doesnt_work.html>`__.\n\nit's also impossible to mock certain references, such as function default arguments:\n\n.. code-block:: python\n\n    def update_books(_now=time.time):  # set as default argument so faster lookup\n        for book in books:\n            ...\n\nalthough such references are rare, they are occasionally used to optimize highly repeated loops.\n\nfreezegun\n---------\n\nsteve pulec's `freezegun <https://github.com/spulec/freezegun>`__ library is a popular solution.\nit provides a clear api which was much of the inspiration for time-machine.\n\nthe main drawback is its slow implementation.\nit essentially does a find-and-replace mock of all the places that the ``datetime`` and ``time`` modules have been imported.\nthis gets around the problems with using unittest.mock, but it means the time it takes to do the mocking is proportional to the number of loaded modules.\nin large projects, this can take several seconds, an impractical overhead for an individual test.\n\nit's also not a perfect search, since it searches only module-level imports.\nsuch imports are definitely the most common way projects use date and time functions, but they're not the only way.\nfreezegun won\u2019t find functions that have been \u201chidden\u201d inside arbitrary objects, such as class-level attributes.\n\nit also can't affect c extensions that call the standard library functions, including (i believe) cython-ized python code.\n\npython-libfaketime\n------------------\n\nsimon weber's `python-libfaketime <https://github.com/simon-weber/python-libfaketime/>`__ wraps the `libfaketime <https://github.com/wolfcw/libfaketime>`__ library.\nlibfaketime replaces all the c-level system calls for the current time with its own wrappers.\nit's therefore a \"perfect\" mock for the current process, affecting every single point the current time might be fetched, and performs much faster than freezegun.\n\nunfortunately python-libfaketime comes with the limitations of ``ld_preload``.\nthis is a mechanism to replace system libraries for a program as it loads (`explanation <http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/>`__).\nthis causes two issues in particular when you use python-libfaketime.\n\nfirst, ``ld_preload`` is only available on unix platforms, which prevents you from using it on windows.\n\nsecond, you have to help manage ``ld_preload``.\nyou either use python-libfaketime's ``reexec_if_needed()`` function, which restarts (*re-execs*) your test process while loading, or manually manage the ``ld_preload`` environment variable.\nneither is ideal.\nre-execing breaks anything that might wrap your test process, such as profilers, debuggers, and ide test runners.\nmanually managing the environment variable is a bit of overhead, and must be done for each environment you run your tests in, including each developer's machine.\n\ntime-machine\n------------\n\ntime-machine is intended to combine the advantages of freezegun and libfaketime.\nit works without ``ld_preload`` but still mocks the standard library functions everywhere they may be referenced.\nits weak point is that other libraries using date/time system calls won't be mocked.\nthankfully this is rare.\nit's also possible such python libraries can be added to the set mocked by time-machine.\n\none drawback is that it only works with cpython, so can't be used with other python interpreters like pypy.\nhowever it may possible to extend it to support other interpreters through different mocking mechanisms.\n\nmigrating from libfaketime or freezegun\n=======================================\n\nfreezegun has a useful api, and python-libfaketime copies some of it, with a different function name.\ntime-machine also copies some of freezegun's api, in ``travel()``\\'s ``destination``, and ``tick`` arguments, and the ``shift()`` method.\nthere are a few differences:\n\n* time-machine's ``tick`` argument defaults to ``true``, because code tends to make the (reasonable) assumption that time progresses whilst running, and should normally be tested as such.\n  testing with time frozen can make it easy to write complete assertions, but it's quite artificial.\n  write assertions against time ranges, rather than against exact values.\n\n* freezegun interprets dates and naive datetimes in the local time zone (including those parsed from strings with ``dateutil``).\n  this means tests can pass when run in one time zone and fail in another.\n  time-machine instead interprets dates and naive datetimes in utc so they are fixed points in time.\n  provide time zones where required.\n\n* freezegun's ``tick()`` method has been implemented as ``shift()``, to avoid confusion with the ``tick`` argument.\n  it also requires an explicit delta rather than defaulting to 1 second.\n\n* freezegun's ``tz_offset`` argument is not supported, since it only partially mocks the current time zone.\n  time zones are more complicated than a single offset from utc, and freezegun only uses the offset in ``time.localtime()``.\n  instead, time-machine will mock the current time zone if you give it a ``datetime`` with a ``zoneinfo`` timezone.\n\nsome features aren't supported like the ``auto_tick_seconds`` argument.\nthese may be added in a future release.\n\nif you are only fairly simple function calls, you should be able to migrate by replacing calls to ``freezegun.freeze_time()`` and ``libfaketime.fake_time()`` with ``time_machine.travel()``.\n",
  "docs_url": null,
  "keywords": "time,warp,date,datetime,mock,test,tests,testing",
  "license": "mit",
  "name": "time-machine",
  "package_url": "https://pypi.org/project/time-machine/",
  "project_url": "https://pypi.org/project/time-machine/",
  "project_urls": {
    "Changelog": "https://github.com/adamchainz/time-machine/blob/main/CHANGELOG.rst",
    "Homepage": "https://github.com/adamchainz/time-machine",
    "Mastodon": "https://fosstodon.org/@adamchainz",
    "Twitter": "https://twitter.com/adamchainz"
  },
  "release_url": "https://pypi.org/project/time-machine/2.13.0/",
  "requires_dist": [
    "python-dateutil"
  ],
  "requires_python": ">=3.8",
  "summary": "travel through time in your tests.",
  "version": "2.13.0",
  "releases": [],
  "developers": [
    "adam_johnson",
    "me@adamj.eu"
  ],
  "kwds": "time_machine badge fake_time _time timestamp",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_time_machine",
  "homepage": "https://github.com/adamchainz/time-machine",
  "release_count": 28,
  "dependency_ids": [
    "pypi_python_dateutil"
  ]
}