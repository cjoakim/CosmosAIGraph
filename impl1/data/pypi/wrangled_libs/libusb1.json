{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v2 or later (lgplv2+)",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries",
    "topic :: system :: hardware :: hardware drivers"
  ],
  "description": ".. contents::\n\nsupports all transfer types, both in synchronous and asynchronous mode.\n\nhome: http://github.com/vpelletier/python-libusb1\n\npypi: http://pypi.python.org/pypi/libusb1\n\n.. role:: c_code(code)\n  :language: c\n\n.. role:: python_code(code)\n  :language: python\n\ndependencies\n============\n\n- cpython_ 3.6+, pypy_ 2.0+. older versions may work, but are not\n  recommended as there is no automated regression testing set up for them.\n- libusb-1.0_\n\nsupported oses\n==============\n\npython-libusb1 can be expected to work on:\n\n- gnu/linux\n- windows [#]_ native dll or via cygwin_\n- osx [#]_ via macports_, fink_ or homebrew_\n- freebsd (including debian gnu/kfreebsd)\n- openbsd\n\n.. [#] beware of libusb-win32, which implements 0.1 api, not 1.0 .\n\n.. [#] beware of possible lack of select.poll if you want to use asynchronous\n       api.\n\ninstallation\n============\n\nreleases from pypi, with name *libusb1*. installing from command line::\n\n    $ pip install libusb1\n\nlatest version from source tree::\n\n    $ git clone https://github.com/vpelletier/python-libusb1.git\n    $ cd python-libusb1\n    $ pip install .\n\nwindows installation notes\n--------------------------\n\non windows, installing wheels from pypi also installs the libusb dll within the\nusb1 python module. it does not install any driver, so you still need to decide\nwhich of libusbk or winusb to use for each device and install it appropriately\n(possibly using zadig_, or by providing a driver for your users to install).\n\ninstalling from source tree does not install the dll, so you need to install the\nlibrary where ctypes can find it - and of course the driver as well.\n\nchecking release file signature\n-------------------------------\n\npipy releases are signed. to verify the signature:\n\n- download the release file, note its url\n- download its detached signature by adding `.asc` at the end of the release\n  file url\n- add the release key(s) to a gnupg keyring (`keys` file in the home\n  repository), and use gnupg to validate the signature both corresponds to the\n  distribution file and is trusted by your keyring\n- install the already-fetched release file\n\nusage\n=====\n\nfinding a device and gaining exclusive access:\n\n.. code:: python\n\n    import usb1\n    with usb1.usbcontext() as context:\n        handle = context.openbyvendoridandproductid(\n            vendor_id,\n            product_id,\n            skip_on_error=true,\n        )\n        if handle is none:\n            # device not present, or user is not allowed to access device.\n        with handle.claiminterface(interface):\n            # do stuff with endpoints on claimed interface.\n\nsynchronous i/o:\n\n.. code:: python\n\n    while true:\n        data = handle.bulkread(endpoint, buffer_size)\n        # process data...\n\nasynchronous i/o, with more error handling:\n\n.. code:: python\n\n    def processreceiveddata(transfer):\n        if transfer.getstatus() != usb1.transfer_completed:\n            # transfer did not complete successfully, there is no data to read.\n            # this example does not resubmit transfers on errors. you may want\n            # to resubmit in some cases (timeout, ...).\n            return\n        data = transfer.getbuffer()[:transfer.getactuallength()]\n        # process data...\n        # resubmit transfer once data is processed.\n        transfer.submit()\n\n    # build a list of transfer objects and submit them to prime the pump.\n    transfer_list = []\n    for _ in range(transfer_count):\n        transfer = handle.gettransfer()\n        transfer.setbulk(\n            usb1.endpoint_in | endpoint,\n            buffer_size,\n            callback=processreceiveddata,\n        )\n        transfer.submit()\n        transfer_list.append(transfer)\n    # loop as long as there is at least one submitted transfer.\n    while any(x.issubmitted() for x in transfer_list):\n        try:\n            context.handleevents()\n        except usb1.usberrorinterrupted:\n            pass\n\nfor more, see the ``example`` directory.\n\ndocumentation\n=============\n\npython-libusb1 main documentation is accessible with python's standard\n``pydoc`` command.\n\npython-libusb1 follows libusb-1.0 documentation as closely as possible, without\ntaking decisions for you. thanks to this, python-libusb1 does not need to\nduplicate the nice existing `libusb1.0 documentation`_.\n\nsome description is needed though on how to jump from libusb-1.0 documentation\nto python-libusb1, and vice-versa:\n\n``usb1`` module groups libusb-1.0 functions as class methods. the first\nparameter (when it's a ``libusb_...`` pointer) defined the class the function\nbelongs to. for example:\n\n- :c_code:`int libusb_init (libusb_context **context)` becomes usbcontext class\n  constructor, :python_code:`usbcontext.__init__(self)`\n\n- :c_code:`ssize_t libusb_get_device_list (libusb_context *ctx,\n  libusb_device ***list)` becomes an usbcontext method, returning a\n  list of usbdevice instances, :python_code:`usbdevice.getdevicelist(self)`\n\n- :c_code:`uint8_t libusb_get_bus_number (libusb_device *dev)` becomes an\n  usbdevice method, :python_code:`usbdevice.getbusnumber(self)`\n\nerror statuses are converted into :python_code:`usb1.usberror` exceptions, with\nstatus as ``value`` instance property.\n\n``usb1`` module also defines a few more functions and classes, which are\notherwise not so convenient to call from python: the event handling api needed\nby async api.\n\nhistory\n=======\n\n0.0.1\n-----\n\ninitial release\n\n0.1.1\n-----\n\nmassive rework of usb1.py, making it more python-ish and fixing some\nmemory leaks.\n\n0.1.2\n-----\n\ndeprecate \"transfer\" constructor parameter to allow instance reuse.\n\n0.1.3\n-----\n\nsome work on isochronous \"in\" transfers. they don't raise exceptions anymore,\nbut data validity and python-induced latency impact weren't properly checked.\n\n0.2.0\n-----\n\nfix asynchronous configuration transfers.\n\nstand-alone polling thread for multi-threaded apps.\n\nmore libusb methods exposed on objects, including ones not yet part of\nreleased libusb versions (up to their commit 4630fc2).\n\n2to3 friendly.\n\ndrop deprecated usbdevice.reprconfigurations method.\n\n0.2.1\n-----\n\nadd freebsd support.\n\n0.2.2\n-----\n\nadd cygwin support.\n\nopenbsd support checked (no change).\n\n0.2.3\n-----\n\nadd fink and homebrew support on osx.\n\ndrop path_max definition.\n\ntry harder when looking for libusb.\n\n1.0.0\n-----\n\nfix freebsd abi compatibility.\n\neasier to list connected devices.\n\neasier to terminate all async transfers for clean exit.\n\nfix few segfault causes.\n\npypy support.\n\n1.1.0\n-----\n\ndescriptor walk api documented.\n\nversion and capability apis exposed.\n\nsome portability fixes (oses, python versions).\n\nisochronous transfer refuses to round transfer size.\n\nbetter exception handling in enumeration.\n\nadd examples.\n\nbetter documentation.\n\n1.2.0\n-----\n\nwrap hotplug api.\n\nwrap port number api.\n\nwrap kernel auto-detach api.\n\ndrop wrapper for libusb_strerror, with compatibility place-holder.\n\nadd a few new upstream enum values.\n\n1.3.0\n-----\n\n**backward-incompatible change**: enum class now affects caller's local scope,\nnot its global scope. this should not be of much importance, as:\n\n- this class is probably very little used outside libusb1.py\n\n- this class is probably mostly used at module level, where locals == globals.\n\n  it is possible to get former behaviour by providing the new ``scope_dict``\n  parameter to ``enum`` constructor::\n\n    some_enum = libusb1.enum({...}, scope_dict=globals())\n\nimprove start-up time on cpython by not importing standard ``inspect`` module.\n\nfix some more usbtransfer memory leaks.\n\nadd transfer.iteriso for more efficient isochronous reception.\n\n1.3.1\n-----\n\nfixed usbcontext.waitforevent.\n\nfix typo in usbinterfacesetting.getclasstuple method name. backward\ncompatibility preserved.\n\nremove globals accesses from usbdevicehandle destructor.\n\nassorted documentation improvements.\n\n1.3.2\n-----\n\nmade usbdevice instances hashable.\n\nrelaxed licensing by moving from gpl v2+ to lgpl v2.1+, for consistency with\nlibusb1.\n\n1.4.0\n-----\n\nreduce (remove ?) the need to import libusb1 module by exposing usberror and\nconstants in usb1 module.\n\nfix libusb1.libusb_endpoint_endpoint_mask and\nlibusb1.libusb_endpoint_dir_mask naming.\n\nfix pydoc appearance of several usbcontext methods.\n\ndefine exception classes for each error values.\n\n1.4.1\n-----\n\nfix wheel generation (``python3 setup.py bdist_wheel``).\n\n1.5.0\n-----\n\ncontrolwrite, bulkwrite and interruptwrite now reject (with typeerror) numeric\nvalues for ``data`` parameter.\n\nfix libusb1.request_type_* names (were type_*). preserve backward\ncompatibility.\n\nadd usbcontext.getdeviceiterator method.\n\nrename usbcontext.exit as usbcontext.close for consistency with other usb*\nclasses. preserve backward compatibility.\n\nmake usbdevicehandle.claiminterface a context manager, for easier interface\nreleasing.\n\n1.5.1\n-----\n\nintroduce usbpollerthread.stop .\n\nfix usbdevicehandle.getsupportedlanguagelist bug when running under python 3.\nwhile fixing this bug it was realised that this method returned ctypes objects.\nthis was not intended, and it now returns regular integers.\n\n1.5.2\n-----\n\nmake usbtransfer.cancel raise specific error instances.\n\n1.5.3\n-----\n\nfix usbtransfer.cancel exception raising introduced in 1.5.2: it was\naccidentally becomming a bound method, preventing the raise to actually\nhappen (in at least cpython 2.x) or raising type conversion errors (in at least\ncpython 3.5.2).\n\n1.6\n---\n\nimprove asynchronous transfer performance: (very) suboptimal code was used to\ninitialise asynchronous transfer buffer. as a consequence, usb1 now exposes\n``bytearrays`` where it used to expose ``bytes`` or ``str`` objects.\n\ndeprecate libusb1 module import, which should not be needed since all (?)\nneeded constants were re-bound to usb1 module.\n\nmove testusb1 module inside usb1, to eventually only expose usb1 as top-level\nmodule.\n\n1.6.1\n-----\n\nfix getsupportedlanguagelist.\n\nfix and extend get{,ascii}stringdescriptor .\n\nfix iteriso and getisobufferlist.\n\n1.6.2\n-----\n\nfix getasciistringdescriptor: unlike getstringdescriptor, this returns only the\npayload of the string descriptor, without its header.\n\n1.6.3\n-----\n\ndeprecate usbpollerthread . it is mileading users for which the simple version\n(a thread calling ``usbcontext.handleevents``) would be enough. and for more\nadvanced uses (ie, actually needing to poll non-libusb file descriptors), this\nclass only works reliably with epoll: kqueue (which should tehcnically work)\nhas a different api on python level, and poll (which has the same api as epoll\non python level) lacks the critical ability to change the set of monitored file\ndescriptors while a poll is already running, causing long pauses - if not\ndeadlocks.\n\n1.6.4\n-----\n\nfix asynchronous control transfers.\n\n1.6.5\n-----\n\ndocument hotplug handler limitations.\n\nrun 2to3 when running setup.py with python3, and reduce differences with\npython3.\n\nproperly cast libusb_set_pollfd_notifiers arguments.\nfix null pointer value: pointer(none) is the type of a pointer which may be a\nnull pointer, which falls back to c_void_p. but c_void_p() is an actual null\npointer.\n\n1.6.6\n-----\n\nexpose bare string descriptors (aka string indexes) on usbdevice.\n\n1.6.7\n-----\n\nget{,ascii}stringdescriptor now return none for descriptor 0 instead of raising\nunicodedecodeerror. use getsupportedlanguagelist to access it.\n\nmoved getmanufacturer, getproduct and getserialnumber to usbdevicehandle. kept\nshortcuts for these on usbdevice.\n\n1.7\n---\n\nget{,ascii}stringdescriptor now return none for descriptor 0, use\ngetsupportedlanguagelist to get its content.\n\ngetmanufacturer, getproduct and getserialnumber are now on usbdevicehandle,\nwith backward-compatibility aliases on their original location.\n\nsynchronous bulk and interrupt api exposes number of bytes sent and received\nbytes even when a timeout occurs.\n\n1.7.1\n-----\n\nusb1.__version__ is now present, managed by versioneer.\n\nfix an occasional segfault when closing a transfer from inside its callback\nfunction.\n\n1.8\n---\n\nfix getextra and libusb1.libusb_control_transfer_get_data .\n\nfix getmaxpower unit on superspeed devices.\n\n1.8.1\n-----\n\nrelease process rework:\n\n- embed libusb1 dll for easier deployment on windows\n- cryptographically signed releases\n\nuse libusb_free_pollfds whenever available (libusb1>=1.0.20).\n\nfix hotplug callback destruction at context teardown.\n\ndrop remnants of python 2.6 support code.\n\n1.9\n---\n\ndrop usbpollerthread and deprecate libusb-lock-related usbcontext api.\n\n1.9.1\n-----\n\nfix installation from pypi source tarball, broken in 1.8.1 .\n\n1.9.2\n-----\n\nwindows wheels: update bundled libusb to 1.0.24 .\n\nfix soure-only build when wheel is not available.\n\n1.9.3\n-----\n\nadd support for pyinstaller.\n\nimprove the way the windows dlls are embedded in wheels.\n\nfix support for python 3.10 .\n\nadd support for homebrew on apple m1.\n\n1.10.1 (yanked)\n---------------\n\nnote: release yanked_ from pypi and re-released as 2.0.0.\n\n2.0.0\n-----\n\ndrop python <3.4 support.\n\ndo not load the c library on import. allows applications to customise the\nlookup logic (see `usb1.loadlibrary`).\n\nadd libusb_speed_super_plus.\n\nbetter control device iterator end of life.\n\nfix objects escaping control from their parent.\n\n2.0.1\n-----\n\nfix a typeerror exception in usbcontext.handleevents .\n\nfix an attributeerror exception in usbcontext.hotplugregistercallback .\n\nfix segfault in pypy3 when finalizing usbdevice objects .\n\nsource only: convert examples to python3.\n\nrelease process: also run some examples scripts.\n\n3.0.0\n-----\n\nupdate versioneer to be compatible with 3.11 .\n\ndrop python <3.6 support (consequence of versioneer update), hence the major\nversion change.\n\nunreleased\n----------\n\nfix bug preventing use of setpollfdnotifiers.\n\nwrap libusb_interrupt_event_handler, available since libusb 1.0.21, to help\napplications wake an event handling thread (ex: durring exit).\n\nwindows wheels: update bundled libusb dll to 1.0.26 .\n\n.. _cpython: http://www.python.org/\n\n.. _pypy: http://pypy.org/\n\n.. _cygwin: https://www.cygwin.com/\n\n.. _macports: https://www.macports.org/\n\n.. _fink: http://www.finkproject.org/\n\n.. _homebrew: http://brew.sh/\n\n.. _libusb-1.0: https://github.com/libusb/libusb/wiki/\n\n.. _libusb1.0 documentation: http://libusb.sourceforge.net/api-1.0/\n\n.. _zadig: https://zadig.akeo.ie/\n\n.. _yanked: https://www.python.org/dev/peps/pep-0592/\n",
  "docs_url": null,
  "keywords": "usb,libusb",
  "license": "lgplv2.1+",
  "name": "libusb1",
  "package_url": "https://pypi.org/project/libusb1/",
  "project_url": "https://pypi.org/project/libusb1/",
  "project_urls": {
    "Homepage": "https://github.com/vpelletier/python-libusb1"
  },
  "release_url": "https://pypi.org/project/libusb1/3.1.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "pure-python wrapper for libusb-1.0",
  "version": "3.1.0",
  "releases": [],
  "developers": [
    "plr.vincent@gmail.com",
    "vincent_pelletier"
  ],
  "kwds": "libusb_device libusb_control_transfer_get_data libusb_strerror libusb libusb_get_device_list",
  "license_kwds": "lgplv2.1+",
  "libtype": "pypi",
  "id": "pypi_libusb1",
  "homepage": "https://github.com/vpelletier/python-libusb1",
  "release_count": 38,
  "dependency_ids": []
}