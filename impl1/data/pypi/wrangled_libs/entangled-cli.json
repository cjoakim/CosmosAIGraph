{
  "classifiers": [
    "license :: other/proprietary license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12"
  ],
  "description": "# entangled\n[![upload python package](https://github.com/entangled/entangled.py/actions/workflows/deploy.yml/badge.svg)](https://github.com/entangled/entangled.py/actions/workflows/deploy.yml)\n[![python package](https://github.com/entangled/entangled.py/actions/workflows/python-package.yml/badge.svg)](https://github.com/entangled/entangled.py/actions/workflows/python-package.yml)\n\nentangled is a solution for literate programming, a technique in which the programmer writes a human narrative first, then implementing the program in code blocks.\nliterate programming was introduced by donald knuth in 1984 and has since then found several surges in popularity. one thing holding back the popularity of literate programming is the lack of maintainability under increasing program complexity. entangled solves this issue by offering a two-way synchronisation mechanism. you can edit and debug your code as normal in your favourite ide or text editor. entangled will make sure that your markdown files stay up-to-date with your code and vice-versa. because entangled works with markdown, you can use it with most static document generators. to summarise, you keep using:\n\n- your favourite **editor**: entangled runs as a daemon in the background, keeping your text files synchronised.\n- your favourite **programming language**: entangled is agnostic to programming languages.\n- your favourite **document generator**: entangled is configurable to any dialect of markdown.\n\nwe\u2019re trying to increase the visibility of entangled. if you like entangled, please consider adding this badge [![entangled badge](https://img.shields.io/badge/entangled-use%20the%20source!-%2300aeff)](https://entangled.github.io/) to the appropriate location in your project:\n\n```markdown\n[![entangled badge](https://img.shields.io/badge/entangled-use%20the%20source!-%2300aeff)](https://entangled.github.io/)\n```\n\n## get started\nto install entangled, all you need is a python (version &ge;3.11) installation. if you use [`poetry`](https://python-poetry.org), and you start a new project,\n\n```\npoetry init \npoetry add entangled-cli\n```\n\nthe `poetry init` command will create a `pyproject.toml` file and a virtual environment to install python dependencies in. to activate the virtual environment, run `poetry shell` inside the project directory.\n\nor, if you prefer plain old `pip`,\n\n```\npip install entangled-cli\n```\n\n## use\n\n> :warning: **this version of entangled is still in beta.** in general things are working as they should, but there may still be some rough edges in the user experience.\n\nrun the `entangled watch` daemon in the root of your project folder. by default all markdown files are monitored for fenced code blocks like so:\n\n~~~markdown\n``` {.rust #hello file=\"src/world.rs\"}\n...\n```\n~~~\n\nthe syntax of code block properties is the same as css properties: `#hello` gives the block the `hello` identifier, `.rust` adds the `rust` class and the `file` attribute is set to `src/world.rs` (quotes are optional). for entangled to know how to tangle this block, you need to specify a language and a target file. however, now comes the cool stuff. we can split our code in meaningful components by cross-refrences.\n\n### hello world in c++\nthe combined code-blocks in this example compose a compilable source code for \"hello world\". for didactic reasons we don't always give the listing of an entire source file in one go. in stead, we use a system of references known as *noweb* (after ramsey 1994).\n\ninside source fragments you may encounter a line with `<<...>>` marks like,\n\n~~~markdown\n``` {.cpp file=hello_world.cc}\n#include <cstdlib>\n#include <iostream>\n\n<<example-main-function>>\n```\n~~~\n\nwhich is then elsewhere specified. order doesn't matter,\n\n~~~markdown\n``` {.cpp #hello-world}\nstd::cout << \"hello, world!\" << std::endl;\n```\n~~~\n\nso we can reference the `<<hello-world>>` code block later on.\n\n~~~markdown\n``` {.cpp #example-main-function}\nint main(int argc, char **argv)\n{\n    <<hello-world>>\n}\n```\n~~~\n\na definition can be appended with more code as follows (in this case, order does matter!):\n\n~~~markdown\n``` {.cpp #hello-world}\nreturn exit_success;\n```\n~~~\n\nthese blocks of code can be *tangled* into source files.\n\n### configuring\nentangled is configured by putting a `entangled.toml` in the root of your project.\n\n```toml\n# required: the minimum version of entangled\nversion = \"2.0\"            \n\n# default watch_list is [\"**/*.md\"]\nwatch_list = [\"docs/**/*.md\"]\n```\n\nyou may add languages as follows:\n\n```toml\n[[languages]]\nname = \"java\"\nidentifiers = [\"java\"]\ncomment = { open = \"//\" }\n\n# some languages have comments that are not terminated by\n# newlines, like xml or css.\n[[languages]]\nname = \"xml\"\nidentifiers = [\"xml\", \"html\", \"svg\"]\ncomment = { open = \"<!--\", close = \"-->\" }\n```\n\nthe `identifiers` are the tags that you may use in your code block header to identify the language. using the above config, you should be able to write:\n\n~~~markdown\n``` {.html file=index.html}\n<!doctype html>\n<html lang=\"en\">\n    <<header>>\n    <<body>>\n</html>\n```\n\nand so on...\n~~~\n\nif you have a `pyproject.toml` file, either because you use `poetry` to setup entangled or because you're actually developing a python project, you may want to put the configuration in `pyproject.toml` instead. add a section `tools.entangled` like so:\n\n```toml\n[[tools.entangled]]\nversion = \"2.0\"\nwatch_list = [\"docs/**/*.md\"]\n```\n\n## hooks\nentangled has a system of *hooks*: these add actions to the tangling process:\n\n- `build` trigger actions in a generated `makefile`\n- `brei` trigger actions (or tasks) using [brei](https://entangled.github.io/brei), which is automatically installed along with entangled. this is now prefered over the `build` hook.\n- `quatro_attributes` add attributes to the code block in quatro style with `#|` comments at the top of the code block.\n\n## `build` hook\nyou can enable this hook in `entangled.toml`:\n\n```toml\nversion = \"2.0\"\nwatch_list = [\"docs/**/*.md\"]\nhooks = [\"build\"]\n```\n\nthen in your markdown, you may enter code tagged with the `.build` tag.\n\n~~~markdown\n``` {.python .build target=docs/fig/plot.svg}\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nx = np.linspace(-np.pi, np.pi, 100)\ny = np.sin(x)\nplt.plot(x, y)\nplt.savefig(\"docs/fig/plot.svg\")\n```\n~~~\n\nthis code will be saved into a python script in the `.entangled/build` directory, or if you specify the `file=` attribute some other location. second, a `makefile` is generated in `.entangled/build`, that can be invoked as,\n\n```shell\nmake -f .entangled/build/makefile\n```\n\nyou may configure how code from different languages is evaluated in `entangled.toml`. for example, to add gnuplot support, and also make julia code run through `daemonmode.jl`, you may do the following:\n\n```toml\n[hook.build.runners]\ngnuplot = \"gnuplot {script}\"\njulia = \"julia --project=. --startup-file=no -e 'using daemonmode; runargs()' {script}\"\n```\n\nonce you have the code in place to generate figures and markdown tables, you can use the syntax at your disposal to include those into your markdown. in this example that would be\n\n~~~markdown\n![my awesome plot](fig/plot.svg)\n~~~\n\nin the case of tables or other rich content, standard markdown (or commonmark) has no syntax for including other markdown files, so you'll have to check with your own document generator how to do that. in mkdocs, you could use `mkdocs-macro-plugin`, pandoc has `pandoc-include`, etc.\n\nyou can also specify intermediate data generation like so:\n\n~~~markdown\n``` {.python .build target=\"data/result.csv\"}\nimport numpy as np\nimport pandas as pd\n\nresult = np.random.normal(0.0, 1.0, (100, 2))\ndf = pd.dataframe(result, columns=[\"x\", \"y\"])\ndf.to_csv(\"data/result.csv\")\n```\n\n``` {.python .build target=\"fig/plot.svg\" deps=\"data/result.csv\"}\nimport pandas as pd\n\ndf = pd.read_csv(\"data/result.csv\")\nplot = df.plot()\nplot.savefig(\"fig/plot.svg\")\n```\n~~~\n\nthe snippet for generating the data is given as a dependency for that data; to generate the figure, both `result.csv` and the code snippet are dependencies.\n\n### `quarto_attributes` hook\nsometimes using the `build` hook (or the `brei` hook, see below), leads to long header lines. it is then better to specify attributes in a header section of your code. the quarto project came up with a syntax, having the header be indicated by a comment with a vertical bar, e.g. `#|` or `//|` etc. the `quarto_attributes` hook reads those attributes and adds them to the properties of the code block.\n\nexample with the `brei` hook:\n\n~~~markdown\n``` {.python .task}\n#| description: draw a triangle\n#| creates: docs/fig/triangle.svg\n#| collect: figures\nfrom matplotlib import pyplot as plt\nplt.plot([[-1, -0.5], [1, -0.5], [0, 1], [-1, -0.5]])\nplt.savefig(\"docs/fig/triangle.svg\")\n```\n\n![](fig/triangle.svg)\n~~~\n\n## brei\nentangled has a small build engine (similar to gnu make) embedded, called brei. you may give it a list of tasks (specified in toml) that may depend on one another. brei will run these when dependencies are newer than the target. execution is lazy and in parallel. brei supports:\n\n- running tasks by passing a script to any configured interpreter, e.g. bash, python, lua etc.\n- redirecting `stdout` or `stdin` to or from files.\n- defining so called \"phony\" targets.\n- define `template` for programmable reuse.\n- `include` other brei files, even ones that need to be generated by another `task`.\n- variable substitution, including writing `stdout` to variables.\n\nbrei is available as a separate package, see [the brei documentation](https://entangled.github.io/brei).\n\n### examples\nto write out \"hello, world!\" to a file `msg.txt`, we may do the following,\n\n```toml\n[[task]]\nstdout = \"secret.txt\"\nlanguage = \"python\"\nscript = \"\"\"\nprint(\"uryyb, jbeyq!\")\n\"\"\"\n```\n\nto have this message decoded define a pattern,\n\n```toml\n[pattern.rot13]\nstdout = \"{stdout}\"\nstdin = \"{stdin}\"\nlanguage = \"bash\"\nscript = \"\"\"\ntr a-za-z n-za-mn-za-m\n\"\"\"\n\n[[call]]\npattern = \"rot13\"\n  [call.args]\n  stdin = \"secret.txt\"\n  stdout = \"msg.txt\"\n```\n\nto define a phony target \"all\",\n\n```toml\n[[task]]\nname = \"all\"\nrequires = [\"msg.txt\"]\n```\n\n### the `brei` hook\nthe following example uses both `brei` and `quatro_attributes` hooks. to add a brei task, tag a code block with the `.task` class. \n\n~~~markdown\nfirst we generate some data.\n\n``` {.python #some-functions}\n# define some functions\n```\n\nnow we show what that data would look like:\n\n``` {.python .task}\n#| description: generate data\n#| creates: data/data.npy\n\n<<some-functions>>\n\n# generate and save data\n```\n\nthen we plot in another task.\n\n``` {.python .task}\n#| description: plot data\n#| creates: docs/fig/plot.svg\n#| requires: data/data.npy\n#| collect: figures\n\n# load data and plot\n```\n~~~\n\nthe `collect` attribute tells the brei hook to add the `docs/fig/plot.svg` target to the `figures` collection. all figures can then be rendered as follows, having in `entangled.toml`\n\n```toml\nversion = \"2.0\"\nwatch_list = [\"docs/**/*.md\"]\nhooks = [\"quatro_attributes\", \"brei\"]\n\n[brei]\ninclude = [\".entangled/tasks.json\"]\n```\n\nand run\n\n```bash\nentangled brei figures\n```\n\nyou can use `${variable}` syntax inside brei tasks just as you would in a stand-alone brei script.\n\n## support for document generators\nentangled has been used successfully with the following document generators. note that some of these examples were built using older versions of entangled, but they should work just the same.\n\n### pandoc\n[pandoc](https://pandoc.org/) is a very versatile tool for converting documents in any format. it specifically has very wide support for different forms of markdown syntax out in the wild, including a filter system that lets you extend the workings of pandoc. those filters can be written in any language through an api, for instance python filters can be written using `panflute`, but there is also native support for lua.\n\nto work with entangled style literate documents, there is a set of [pandoc filters](https://github.com/entangled/filters) available. the major downside of pandoc, is that it offers no help in making your output html look beautiful. one option is to use the [bootstrap template](https://github.com/entangled/bootstrap), but you may wan't to try out others as well, or design your own. these days a lot can be done with a single well designed css file.\n\n- :heavy_plus_sign: dynamic\n- :heavy_plus_sign: supports most markdown syntax out of the box\n- :heavy_plus_sign: excellent for science: citation, numbered figures, tables and equations\n- :heavy_plus_sign: support for latex\n- :heavy_minus_sign: harder to setup\n- :heavy_minus_sign: takes work to make look good\n\nexample: [hello world in c++](https://entangled.github.io/examples/hello-world.html)\n\n### mkdocs\n[mkdocs](https://www.mkdocs.org/) is specifically taylored towards converting markdown into good looking, easy to navigate html, especially when used in combination with the [`mkdocs-material`](https://squidfunk.github.io/mkdocs-material/) theme. to use entangled style code blocks with mkdocs, you'll need to install the [`mkdocs-entangled-plugin`](https://github.com/entangled/mkdocs-plugin) as well.\n\n- :heavy_plus_sign: specifically designed for markdown to html, i.e. software documentation\n- :heavy_plus_sign: pretty output, out of the box\n- :heavy_plus_sign: easy to install\n- :heavy_minus_sign: not intended for scientific use: numbering and referencing equations, figures and tables is hard to setup\n- :heavy_minus_sign: documentation is on par with most python projects: ok for most things, but really hard if you want specifics\n\nexample: tbd\n\n### documenter.jl\n[documenter.jl]() is the standard tool to write julia documention in. it has internal support for evaluating code block contents.\n\nexample: [intro to code generation in julia](https://jhidding.github.io/macroexercises.jl/dev/)\n\n### pdoc\n[pdoc]() is a tool for documenting smaller python projects. it grabs all documentation from the doc-strings in your python library and generates a page from that. to have it include its own literate source, i had to use some very ugly hacks.\n\nexample: [check-deps, a universal dependency checker in python](https://jhidding.github.io/check-deps/checkdeps.html)\n\n### docsify\n[docsify](https://docsify.js.org/#/) serves the markdown files and does the conversion to html in a javascript library (in browser).\n\nexample: [guide to c++ on the web through wasm](https://nlesc-jcer.github.io/cpp2wasm/#/)\n\n## history\nthis is a rewrite of entangled in python. older versions were written in haskell. the rewrite in python was motivated by ease of installation, larger community and quite frankly, a fit of mental derangement.\n\n## contributing\nif you have an idea for improving entangled, please file an issue before creating a pull request. code in this repository is formatted using `black` and type checked using `mypy`.\n\n## license\ncopyright 2023 netherlands escience center, written by johan hidding, licensed under the apache 2 license, see license.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2",
  "name": "entangled-cli",
  "package_url": "https://pypi.org/project/entangled-cli/",
  "project_url": "https://pypi.org/project/entangled-cli/",
  "project_urls": {
    "Homepage": "https://entangled.github.io/",
    "Repository": "https://github.com/entangled/entangled.py"
  },
  "release_url": "https://pypi.org/project/entangled-cli/2.0.2/",
  "requires_dist": [
    "argh (>=0.30,<0.31)",
    "brei (>=0.2.3,<0.3.0)",
    "copier (>=8.3.0,<9.0.0)",
    "filelock (>=3.12.0,<4.0.0)",
    "mawk (>=0.1.4,<0.2.0)",
    "rich (>=13.3.5,<14.0.0)",
    "rich-argparse (>=1.4.0,<2.0.0)",
    "tomlkit (>=0.12.1,<0.13.0)",
    "watchdog (>=3.0.0,<4.0.0)"
  ],
  "requires_python": ">=3.11,<4.0",
  "summary": "literate programming toolbox",
  "version": "2.0.2",
  "releases": [],
  "developers": [
    "j.hidding@esciencecenter.nl",
    "johan_hidding"
  ],
  "kwds": "entangled tangle python interpreter synchronisation",
  "license_kwds": "apache 2",
  "libtype": "pypi",
  "id": "pypi_entangled_cli",
  "homepage": "https://entangled.github.io/",
  "release_count": 11,
  "dependency_ids": [
    "pypi_argh",
    "pypi_brei",
    "pypi_copier",
    "pypi_filelock",
    "pypi_mawk",
    "pypi_rich",
    "pypi_rich_argparse",
    "pypi_tomlkit",
    "pypi_watchdog"
  ]
}