{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# sql-metadata\n\n[![pypi](https://img.shields.io/pypi/v/sql_metadata.svg)](https://pypi.python.org/pypi/sql_metadata)\n[![tests](https://github.com/macbre/sql-metadata/actions/workflows/python-ci.yml/badge.svg)](https://github.com/macbre/sql-metadata/actions/workflows/python-ci.yml)\n[![coverage status](https://coveralls.io/repos/github/macbre/sql-metadata/badge.svg?branch=master&1)](https://coveralls.io/github/macbre/sql-metadata?branch=master)\n<a href=\"https://github.com/psf/black\"><img alt=\"code style: black\" src=\"https://img.shields.io/badge/code%20style-black-000000.svg\"></a>\n[![maintenance](https://img.shields.io/badge/maintained%3f-yes-green.svg)](https://github.com/macbre/sql-metadata/graphs/commit-activity)\n[![downloads](https://pepy.tech/badge/sql-metadata/month)](https://pepy.tech/project/sql-metadata)\n\nuses tokenized query returned by [`python-sqlparse`](https://github.com/andialbrecht/sqlparse) and generates query metadata.\n\n**extracts column names and tables** used by the query. \nautomatically conduct **column alias resolution**, **sub queries aliases resolution** as well as **tables aliases resolving**.\n\nprovides also a helper for **normalization of sql queries**.\n\nsupported queries syntax:\n\n* mysql\n* postgresql\n* sqlite\n* mssql\n* [apache hive](https://cwiki.apache.org/confluence/display/hive/languagemanual+dml)\n\n(note that listed backends can differ quite substantially but should work in regard of query types supported by `sql-metadata`)\n\nyou can test the capabilities of `sql-metadata` with an interactive demo: [https://sql-app.infocruncher.com/](https://sql-app.infocruncher.com/)\n\n## usage\n\n```\npip install sql-metadata\n```\n\n### extracting raw sql-metadata tokens\n\n```python\nfrom sql_metadata import parser\n\n# extract raw sql-metadata tokens\nparser(\"select * from foo\").tokens\n# ['select', '*', 'from', 'foo']\n```\n\n### extracting columns from query\n\n```python\nfrom sql_metadata import parser\n\n# get columns from query - for more examples see `tests/test_getting_columns.py`\nparser(\"select test, id from foo, bar\").columns\n# ['test', 'id']\n\nparser(\"insert /* votehelper::addvote xxx */  into `page_vote` (article_id,user_id,`time`) values ('442001','27574631','20180228130846')\").columns\n# ['article_id', 'user_id', 'time']\n\nparser = parser(\"select a.* from product_a.users as a join product_b.users as b on a.ip_address = b.ip_address\")\n\n# note that aliases are auto-resolved\nparser.columns\n# ['product_a.*', 'product_a.users.ip_address', 'product_b.users.ip_address']\n\n# note that you can also extract columns with their place in the query\n# which will return dict with lists divided into select, where, order_by, group_by, join, insert and update\nparser.columns_dict\n# {'select': ['product_a.users.*'], 'join': ['product_a.users.ip_address', 'product_b.users.ip_address']}\n```\n\n### extracting columns aliases from query\n\n```python\nfrom sql_metadata import parser\nparser = parser(\"select a, (b + c - u) as alias1, custome_func(d) alias2 from aa, bb order by alias1\")\n\n# note that columns list do not contain aliases of the columns\nparser.columns\n# [\"a\", \"b\", \"c\", \"u\", \"d\"]\n\n# but you can still extract aliases names\nparser.columns_aliases_names\n# [\"alias1\", \"alias2\"]\n\n# aliases are resolved to the columns which they refer to\nparser.columns_aliases\n# {\"alias1\": [\"b\", \"c\", \"u\"], \"alias2\": \"d\"}\n\n# you can also extract aliases used by section of the query in which they are used\nparser.columns_aliases_dict\n# {\"order_by\": [\"alias1\"], \"select\": [\"alias1\", \"alias2\"]}\n\n# the same applies to aliases used in queries section when you extract columns_dict\n# here only the alias is used in order by but it's resolved to actual columns\nassert parser.columns_dict == {'order_by': ['b', 'c', 'u'],\n                               'select': ['a', 'b', 'c', 'u', 'd']}\n```\n\n### extracting tables from query\n\n```python\nfrom sql_metadata import parser\n\n# get tables from query - for more examples see `tests/test_getting_tables.py`\nparser(\"select a.* from product_a.users as a join product_b.users as b on a.ip_address = b.ip_address\").tables\n# ['product_a.users', 'product_b.users']\n\nparser(\"select test, id from foo, bar\").tables\n# ['foo', 'bar']\n\n# you can also extract aliases of the tables as a dictionary\nparser = parser(\"select f.test from foo as f\")\n\n# get table aliases\nparser.tables_aliases\n# {'f': 'foo'}\n\n# note that aliases are auto-resolved for columns\nparser.columns\n# [\"foo.test\"]\n```\n\n### extracting values from insert query\n```python\nfrom sql_metadata import parser\n\nparser = parser(\n    \"insert /* votehelper::addvote xxx */  into `page_vote` (article_id,user_id,`time`) \" \n    \"values ('442001','27574631','20180228130846')\"\n)\n# extract values from query\nparser.values\n# [\"442001\", \"27574631\", \"20180228130846\"]\n\n# extract a dictionary with column-value pairs\nparser.values_dict\n#{\"article_id\": \"442001\", \"user_id\": \"27574631\", \"time\": \"20180228130846\"}\n\n# if column names are not set auto-add placeholders\nparser = parser(\n    \"insert ignore into `table` values (9, 2.15, '123', '2017-01-01');\"\n)\nparser.values\n# [9, 2.15, \"123\", \"2017-01-01\"]\n\nparser.values_dict\n#{\"column_1\": 9, \"column_2\": 2.15, \"column_3\": \"123\", \"column_4\": \"2017-01-01\"}\n```\n\n\n### extracting limit and offset\n```python\nfrom sql_metadata import parser\n\nparser('select foo_limit from bar_offset limit 50 offset 1000').limit_and_offset\n# (50, 1000)\n\nparser('select foo_limit from bar_offset limit 2000,50').limit_and_offset\n# (50, 2000)\n```\n\n### extracting with names\n\n```python\nfrom sql_metadata import parser\n\nparser = parser(\n    \"\"\"\nwith\n    database1.tablefromwith as (select aa.* from table3 as aa \n                                left join table4 on aa.col1=table4.col2),\n    test as (select * from table3)\nselect\n  \"xxxxx\"\nfrom\n  database1.tablefromwith alias\nleft join database2.table2 on (\"tt\".\"ttt\".\"fff\" = \"xx\".\"xxx\")\n\"\"\"\n)\n\n# get names/ aliases of with statements\nparser.with_names\n# [\"database1.tablefromwith\", \"test\"]\n\n# get definition of with queries\nparser.with_queries\n# {\"database1.tablefromwith\": \"select aa.* from table3 as aa left join table4 on aa.col1=table4.col2\"\n#  \"test\": \"select * from table3\"}\n\n# note that names of with statements do not appear in tables\nparser.tables\n# [\"table3\", \"table4\", \"database2.table2\"]\n```\n\n### extracting sub-queries\n\n```python\nfrom sql_metadata import parser\n\nparser = parser(\n\"\"\"\nselect count(1) from\n(select std.task_id from some_task_detail std where std.status = 1) a\njoin (select st.task_id from some_task st where task_type_id = 80) b\non a.task_id = b.task_id;\n\"\"\"\n)\n\n# get sub-queries dictionary\nparser.subqueries\n# {\"a\": \"select std.task_id from some_task_detail std where std.status = 1\",\n#  \"b\": \"select st.task_id from some_task st where task_type_id = 80\"}\n\n\n# get names/ aliases of sub-queries / derived tables\nparser.subqueries_names\n# [\"a\", \"b\"]\n\n# note that columns coming from sub-queries are resolved to real columns\nparser.columns\n#[\"some_task_detail.task_id\", \"some_task_detail.status\", \"some_task.task_id\", \n# \"task_type_id\"]\n\n# same applies for columns_dict, note the join columns are resolved\nparser.columns_dict\n#{'join': ['some_task_detail.task_id', 'some_task.task_id'],\n# 'select': ['some_task_detail.task_id', 'some_task.task_id'],\n# 'where': ['some_task_detail.status', 'task_type_id']}\n\n```\n\nsee `tests` file for more examples of a bit more complex queries.\n\n### queries normalization and comments extraction\n\n```python\nfrom sql_metadata import parser\nparser = parser('select /* test */ foo from bar where id in (1, 2, 56)')\n\n# generalize query\nparser.generalize\n# 'select foo from bar where id in (xyz)'\n\n# remove comments\nparser.without_comments\n# 'select foo from bar where id in (1, 2, 56)'\n\n# extract comments\nparser.comments\n# ['/* test */']\n```\n\nsee `test/test_normalization.py` file for more examples of a bit more complex queries.\n\n## migrating from `sql_metadata` 1.x\n\n`sql_metadata.compat` module has been implemented to make the introduction of sql-metadata v2.0 smoother.\n\nyou can use it by simply changing the imports in your code from:\n\n```python\nfrom sql_metadata import get_query_columns, get_query_tables\n```\n\ninto:\n\n```python\nfrom sql_metadata.compat import get_query_columns, get_query_tables\n```\n\nthe following functions from the old api are available in the `sql_metadata.compat` module:\n\n* `generalize_sql`\n* `get_query_columns` (since #131 columns aliases are not returned by this function)\n* `get_query_limit_and_offset`\n* `get_query_tables`\n* `get_query_tokens`\n* `preprocess_query`\n\n## authors and contributors\n\ncreated and maintained by [@macbre](https://github.com/macbre) with a great contributions from [@collerek](https://github.com/collerek) and the others.\n\n* aborecki (https://github.com/aborecki)\n* collerek (https://github.com/collerek)\n* dylanhogg (https://github.com/dylanhogg)\n* macbre (https://github.com/macbre)\n\n## stargazers over time\n\n[![stargazers over time](https://starchart.cc/macbre/sql-metadata.svg)](https://starchart.cc/macbre/sql-metadata)\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "sql_metadata",
  "package_url": "https://pypi.org/project/sql_metadata/",
  "project_url": "https://pypi.org/project/sql_metadata/",
  "project_urls": {
    "Homepage": "https://github.com/macbre/sql-metadata",
    "Repository": "https://github.com/macbre/sql-metadata"
  },
  "release_url": "https://pypi.org/project/sql_metadata/2.10.0/",
  "requires_dist": [
    "sqlparse (>=0.4.1,<0.5.0)"
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "uses tokenized query returned by python-sqlparse and generates query metadata",
  "version": "2.10.0",
  "releases": [],
  "developers": [
    "maciej.brencz@gmail.com",
    "maciej_brencz"
  ],
  "kwds": "sql_metadata macbre badge metadata yml",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_sql_metadata",
  "homepage": "https://github.com/macbre/sql-metadata",
  "release_count": 32,
  "dependency_ids": [
    "pypi_sqlparse"
  ]
}