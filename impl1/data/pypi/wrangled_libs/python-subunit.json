{
  "classifiers": [
    "intended audience :: developers",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: testing"
  ],
  "description": "\n  subunit: a streaming protocol for test results\n  copyright (c) 2005-2013 robert collins <robertc@robertcollins.net>\n\n  licensed under either the apache license, version 2.0 or the bsd 3-clause\n  license at the users choice. a copy of both licenses are available in the\n  project source as apache-2.0 and bsd. you may not use this file except in\n  compliance with one of these two licences.\n\n  unless required by applicable law or agreed to in writing, software\n  distributed under these licenses is distributed on an \"as is\" basis, without\n  warranties or conditions of any kind, either express or implied.  see the\n  license you chose for the specific language governing permissions and\n  limitations under that license.\n\n  see the copying file for full details on the licensing of subunit.\n\nsubunit\n-------\n\nsubunit is a streaming protocol for test results.\n\nthere are two major revisions of the protocol. version 1 was trivially human\nreadable but had significant defects as far as highly parallel testing was\nconcerned - it had no room for doing discovery and execution in parallel,\nrequired substantial buffering when multiplexing and was fragile - a corrupt\nbyte could cause an entire stream to be misparsed. version 1.1 added\nencapsulation of binary streams which mitigated some of the issues but the\ncore remained.\n\nversion 2 shares many of the good characteristics of version 1 - it can be\nembedded into a regular text stream (e.g. from a build system) and it still\nmodels xunit style test execution. it also fixes many of the issues with\nversion 1 - version 2 can be multiplexed without excessive buffering (in\ntime or space), it has a well defined recovery mechanism for dealing with\ncorrupted streams (e.g. where two processes write to the same stream\nconcurrently, or where the stream generator suffers a bug).\n\nmore details on both protocol version s can be found in the 'protocol' section\nof this document.\n\nsubunit comes with command line filters to process a subunit stream and\nlanguage bindings for python, c, c++ and shell. bindings are easy to write\nfor other languages.\n\na number of useful things can be done easily with subunit:\n * test aggregation: tests run separately can be combined and then\n   reported/displayed together. for instance, tests from different languages\n   can be shown as a seamless whole, and tests running on multiple machines\n   can be aggregated into a single stream through a multiplexer.\n * test archiving: a test run may be recorded and replayed later.\n * test isolation: tests that may crash or otherwise interact badly with each\n   other can be run seperately and then aggregated, rather than interfering\n   with each other or requiring an adhoc test->runner reporting protocol.\n * grid testing: subunit can act as the necessary serialisation and\n   deserialiation to get test runs on distributed machines to be reported in\n   real time.\n\nsubunit supplies the following filters:\n * tap2subunit - convert perl's testanythingprotocol to subunit.\n * subunit2csv - convert a subunit stream to csv.\n * subunit2disk - export a subunit stream to files on disk.\n * subunit2pyunit - convert a subunit stream to pyunit test results.\n * subunit2gtk - show a subunit stream in gtk.\n * subunit2junitxml - convert a subunit stream to junit's xml format.\n * subunit-diff - compare two subunit streams.\n * subunit-filter - filter out tests from a subunit stream.\n * subunit-ls - list info about tests present in a subunit stream.\n * subunit-stats - generate a summary of a subunit stream.\n * subunit-tags - add or remove tags from a stream.\n\nintegration with other tools\n----------------------------\n\nsubunit's language bindings act as integration with various test runners like\n'check', 'cppunit', python's 'unittest'. beyond that a small amount of glue\n(typically a few lines) will allow subunit to be used in more sophisticated\nways.\n\npython\n======\n\nsubunit has excellent python support: most of the filters and tools are written\nin python and there are facilities for using subunit to increase test isolation\nseamlessly within a test suite.\n\nthe most common way is to run an existing python test suite and have it output\nsubunit via the ``subunit.run`` module::\n\n  $ python -m subunit.run mypackage.tests.test_suite\n\nfor more information on the python support subunit offers , please see\n``pydoc subunit``, or the source in ``python/subunit/``\n\nc\n=\n\nsubunit has c bindings to emit the protocol. the 'check' c unit testing project\nhas included subunit support in their project for some years now. see\n'c/readme' for more details.\n\nc++\n===\n\nthe c library is includable and usable directly from c++. a testlistener for\ncppunit is included in the subunit distribution. see 'c++/readme' for details.\n\nshell\n=====\n\nthere are two sets of shell tools. there are filters, which accept a subunit\nstream on stdin and output processed data (or a transformed stream) on stdout.\n\nthen there are unittest facilities similar to those for c : shell bindings\nconsisting of simple functions to output protocol elements, and a patch for\nadding subunit output to the 'shunit' shell test runner. see 'shell/readme' for\ndetails.\n\nfilter recipes\n--------------\n\nto ignore some failing tests whose root cause is already known::\n\n  subunit-filter --without 'attributeerror.*flavor'\n\n\nthe xunit test model\n--------------------\n\nsubunit implements a slightly modified xunit test model. the stock standard\nmodel is that there are tests, which have an id(), can be run, and when run\nstart, emit an outcome (like success or failure) and then finish.\n\nsubunit extends this with the idea of test enumeration (find out about tests\na runner has without running them), tags (allow users to describe tests in\nways the test framework doesn't apply any semantic value to), file attachments\n(allow arbitrary data to make analysing a failure easy) and timestamps.\n\nthe protocol\n------------\n\nversion 2, or v2 is new and still under development, but is intended to\nsupercede version 1 in the very near future. subunit's bundled tools accept\nonly version 2 and only emit version 2, but the new filters subunit-1to2 and\nsubunit-2to1 can be used to interoperate with older third party libraries.\n\nversion 2\n=========\n\nversion 2 is a binary protocol consisting of independent packets that can be\nembedded in the output from tools like make - as long as each packet has no\nother bytes mixed in with it (which 'make -j n>1' has a tendency of doing).\nversion 2 is currently in draft form, and early adopters should be willing\nto either discard stored results (if protocol changes are made), or bulk\nconvert them back to v1 and then to a newer edition of v2.\n\nthe protocol synchronises at the start of the stream, after a packet, or\nafter any 0x0a byte. that is, a subunit v2 packet starts after a newline or\ndirectly after the end of the prior packet.\n\nsubunit is intended to be transported over a reliable streaming protocol such\nas tcp. as such it does not concern itself with out of order delivery of\npackets. however, because of the possibility of corruption due to either\nbugs in the sender, or due to mixed up data from concurrent writes to the same\nfd when being embedded, subunit strives to recover reasonably gracefully from\ndamaged data.\n\na key design goal for subunit version 2 is to allow processing and multiplexing\nwithout forcing buffering for semantic correctness, as buffering tends to hide\nhung or otherwise misbehaving tests. that said, limited time based buffering\nfor network efficiency is a good idea - this is ultimately implementator\nchoice. line buffering is also discouraged for subunit streams, as dropping\ninto a debugger or other tool may require interactive traffic even if line\nbuffering would not otherwise be a problem.\n\nin version two there are two conceptual events - a test status event and a file\nattachment event. events may have timestamps, and the path of multiplexers that\nan event is routed through is recorded to permit sending actions back to the\nsource (such as new tests to run or stdin for driving debuggers and other\ninteractive input). test status events are used to enumerate tests, to report\ntests and test helpers as they run. tests may have tags, used to allow\ntunnelling extra meanings through subunit without requiring parsing of\narbitrary file attachments. things that are not standalone tests get marked\nas such by setting the 'runnable' flag to false. (for instance, individual\nassertions in tap are not runnable tests, only the top level tap test script\nis runnable).\n\nfile attachments are used to provide rich detail about the nature of a failure.\nfile attachments can also be used to encapsulate stdout and stderr both during\nand outside tests.\n\nmost numbers are stored in network byte order - most significant byte first\nencoded using a variation of http://www.dlugosz.com/zip2/vli.html. the first\nbyte's top 2 high order bits encode the total number of octets in the number.\nthis encoding can encode values from 0 to 2**30-1, enough to encode a\nnanosecond. numbers that are not variable length encoded are still stored in\nmsb order.\n\n+--------+--------+---------+------------+\n| prefix | octets | max     | max        |\n+========+========+=========+============+\n| 00     |      1 |  2**6-1 |         63 |\n+--------+--------+---------+------------+\n| 01     |      2 | 2**14-1 |      16383 |\n+--------+--------+---------+------------+\n| 10     |      3 | 2**22-1 |    4194303 |\n+--------+--------+---------+------------+\n| 11     |      4 | 2**30-1 | 1073741823 |\n+--------+--------+---------+------------+\n\nall variable length elements of the packet are stored with a length prefix\nnumber allowing them to be skipped over for consumers that don't need to\ninterpret them.\n\nutf-8 strings are with no terminating nul and should not have any embedded nuls\n(implementations should validate any such strings that they process and take\nsome remedial action (such as discarding the packet as corrupt).\n\nin short the structure of a packet is:\n\n  packet := signature flags packet_length timestamp? testid? tags? mime?\n            filecontent? routing_code? crc32\n\nin more detail...\n\npackets are identified by a single byte signature - 0xb3, which is never legal\nin a utf-8 stream as the first byte of a character. 0xb3 starts with the first\nbit set and the second not, which is the utf-8 signature for a continuation\nbyte. 0xb3 was chosen as 0x73 ('s' in ascii') with the top two bits replaced by\nthe 1 and 0 for a continuation byte.\n\nif subunit packets are being embedded in a non-utf-8 text stream, where 0x73 is\na legal character, consider either recoding the text to utf-8, or using\nsubunit's 'file' packets to embed the text stream in subunit, rather than the\nother way around.\n\nfollowing the signature byte comes a 16-bit flags field, which includes a\n4-bit version field - if the version is not 0x2 then the packet cannot be\nread. it is recommended to signal an error at this point (e.g. by emitting\na synthetic error packet and returning to the top level loop to look for\nnew packets, or exiting with an error). if recovery is desired, treat the\npacket signature as an opaque byte and scan for a new synchronisation point.\nnb: subunit v1 and v2 packets may legitimately included 0xb3 internally,\nas they are an 8-bit safe container format, so recovery from this situation\nmay involve an arbitrary number of false positives until an actual packet\nis encountered : and even then it may still be false, failing after passing\nthe version check due to coincidence.\n\nflags are stored in network byte order too.\n\n+------------+------------+------------------------+\n| high byte               | low byte               |\n+------------+------------+------------------------+\n| 15 14 13 12 11 10  9  8 | 7  6  5  4  3  2  1  0 |\n+------------+------------+------------------------+\n| version    |      feature bits                   |\n+------------+-------------------------------------+\n\nvalid version values are:\n0x2 - version 2\n\nfeature bits:\n\n+---------+-------------+---------------------------+\n| bit 11  | mask 0x0800 | test id present.          |\n+---------+-------------+---------------------------+\n| bit 10  | mask 0x0400 | routing code present.     |\n+---------+-------------+---------------------------+\n| bit  9  | mask 0x0200 | timestamp present.        |\n+---------+-------------+---------------------------+\n| bit  8  | mask 0x0100 | test is 'runnable'.       |\n+---------+-------------+---------------------------+\n| bit  7  | mask 0x0080 | tags are present.         |\n+---------+-------------+---------------------------+\n| bit  6  | mask 0x0040 | file content is present.  |\n+---------+-------------+---------------------------+\n| bit  5  | mask 0x0020 | file mime type is present.|\n+---------+-------------+---------------------------+\n| bit  4  | mask 0x0010 | eof marker.               |\n+---------+-------------+---------------------------+\n| bit  3  | mask 0x0008 | must be zero in version 2.|\n+---------+-------------+---------------------------+\n\ntest status gets three bits:\nbit 2 | bit 1 | bit 0 - mask 0x0007 - a test status enum lookup:\n\n* 000 - undefined / no test\n* 001 - enumeration / existence\n* 002 - in progress\n* 003 - success\n* 004 - unexpected success\n* 005 - skipped\n* 006 - failed\n* 007 - expected failure\n\nafter the flags field is a number field giving the length in bytes for the\nentire packet including the signature and the checksum. this length must\nbe less than 4mib - 4194303 bytes. the encoding can obviously record a larger\nnumber but one of the goals is to avoid requiring large buffers, or causing\nlarge latency in the packet forward/processing pipeline. larger file\nattachments can be communicated in multiple packets, and the overhead in such a\n4mib packet is approximately 0.2%.\n\nthe rest of the packet is a series of optional features as specified by the set\nfeature bits in the flags field. when absent they are entirely absent.\n\nforwarding and multiplexing of packets can be done without interpreting the\nremainder of the packet until the routing code and checksum (which are both at\nthe end of the packet). additionally, routers can often avoid copying or moving\nthe bulk of the packet, as long as the routing code size increase doesn't force\nthe length encoding to take up a new byte (which will only happen to packets\nless than or equal to 16kib in length) - large packets are very efficient to\nroute.\n\ntimestamp when present is a 32 bit unsigned integer for seconds, and a variable\nlength number for nanoseconds, representing utc time since unix epoch in\nseconds and nanoseconds.\n\ntest id when present is a utf-8 string. the test id should uniquely identify\nrunnable tests such that they can be selected individually. for tests and other\nactions which cannot be individually run (such as test\nfixtures/layers/subtests) uniqueness is not required (though being human\nmeaningful is highly recommended).\n\ntags when present is a length prefixed vector of utf-8 strings, one per tag.\nthere are no restrictions on tag content (other than the restrictions on utf-8\nstrings in subunit in general). tags have no ordering.\n\nwhen a mime type is present, it defines the mime type for the file across all\npackets same file (routing code + testid + name uniquely identifies a file,\nreset when eof is flagged). if a file never has a mime type set, it should be\ntreated as application/octet-stream.\n\nfile content when present is a utf-8 string for the name followed by the length\nin bytes of the content, and then the content octets.\n\nif present routing code is a utf-8 string. the routing code is used to\ndetermine which test backend a test was running on when doing data analysis,\nand to route stdin to the test process if interaction is required.\n\nmultiplexers should add a routing code if none is present, and prefix any\nexisting routing code with a routing code ('/' separated) if one is already\npresent. for example, a multiplexer might label each stream it is multiplexing\nwith a simple ordinal ('0', '1' etc), and given an incoming packet with route\ncode '3' from stream '0' would adjust the route code when forwarding the packet\nto be '0/3'.\n\nfollowing the end of the packet is a crc-32 checksum of the contents of the\npacket including the signature.\n\nexample packets\n~~~~~~~~~~~~~~~\n\ntrivial test \"foo\" enumeration packet, with test id, runnable set,\nstatus=enumeration. spaces below are to visually break up signature / flags /\nlength / testid / crc32\n\nb3 2901 0c 03666f6f 08555f1b\n\n\nversion 1 (and 1.1)\n===================\n\nversion 1 (and 1.1) are mostly human readable protocols.\n\nsample subunit wire contents\n----------------------------\n\nthe following::\n\n  test: test foo works\n  success: test foo works\n  test: tar a file.\n  failure: tar a file. [\n  ..\n   ]..  space is eaten.\n  foo.c:34 warning foo is not defined.\n  ]\n  a writeln to stdout\n\nwhen run through subunit2pyunit::\n\n  .f\n  a writeln to stdout\n\n  ========================\n  failure: tar a file.\n  -------------------\n  ..\n  ]..  space is eaten.\n  foo.c:34 warning foo is not defined.\n\n\nsubunit v1 protocol description\n===============================\n\nthis description is being ported to an ebnf style. currently its only partly in\nthat style, but should be fairly clear all the same. when in doubt, refer the\nsource (and ideally help fix up the description!). generally the protocol is\nline orientated and consists of either directives and their parameters, or\nwhen outside a details region unexpected lines which are not interpreted by\nthe parser - they should be forwarded unaltered::\n\n    test|testing|test:|testing: test label\n    success|success:|successful|successful: test label\n    success|success:|successful|successful: test label details\n    failure: test label\n    failure: test label details\n    error: test label\n    error: test label details\n    skip[:] test label\n    skip[:] test label details\n    xfail[:] test label\n    xfail[:] test label details\n    uxsuccess[:] test label\n    uxsuccess[:] test label details\n    progress: [+|-]x\n    progress: push\n    progress: pop\n    tags: [-]tag ...\n    time: yyyy-mm-dd hh:mm:ssz\n\n    label: utf8*\n    name: utf8*\n    details ::= bracketed | multipart\n    bracketed ::= '[' cr utf8-lines ']' cr\n    multipart ::= '[ multipart' cr part* ']' cr\n    part ::= part_type cr name cr part_bytes cr\n    part_type ::= content-type: type/sub-type(;parameter=value,parameter=value)\n    part_bytes ::= (digits cr lf byte{digits})* '0' cr lf\n\nunexpected output on stdout -> stdout.\nexit w/0 or last test completing -> error\n\ntags given outside a test are applied to all following tests\ntags given after a test: line and before the result line for the same test\napply only to that test, and inherit the current global tags.\na '-' before a tag is used to remove tags - e.g. to prevent a global tag\napplying to a single test, or to cancel a global tag.\n\nthe progress directive is used to provide progress information about a stream\nso that stream consumer can provide completion estimates, progress bars and so\non. stream generators that know how many tests will be present in the stream\nshould output \"progress: count\". stream filters that add tests should output\n\"progress: +count\", and those that remove tests should output\n\"progress: -count\". an absolute count should reset the progress indicators in\nuse - it indicates that two separate streams from different generators have\nbeen trivially concatenated together, and there is no knowledge of how many\nmore complete streams are incoming. smart concatenation could scan each stream\nfor their count and sum them, or alternatively translate absolute counts into\nrelative counts inline. it is recommended that outputters avoid absolute counts\nunless necessary. the push and pop directives are used to provide local regions\nfor progress reporting. this fits with hierarchically operating test\nenvironments - such as those that organise tests into suites - the top-most\nrunner can report on the number of suites, and each suite surround its output\nwith a (push, pop) pair. interpreters should interpret a pop as also advancing\nthe progress of the restored level by one step. encountering progress\ndirectives between the start and end of a test pair indicates that a previous\ntest was interrupted and did not cleanly terminate: it should be implicitly\nclosed with an error (the same as when a stream ends with no closing test\ndirective for the most recently started test).\n\nthe time directive acts as a clock event - it sets the time for all future\nevents. the value should be a valid iso8601 time.\n\nthe skip, xfail and uxsuccess outcomes are not supported by all testing\nenvironments. in python the testttools (https://launchpad.net/testtools)\nlibrary is used to translate these automatically if an older python version\nthat does not support them is in use. see the testtools documentation for the\ntranslation policy.\n\nskip is used to indicate a test was discovered but not executed. xfail is used\nto indicate a test that errored in some expected fashion (also know as \"todo\"\ntests in some frameworks). uxsuccess is used to indicate and unexpected success\nwhere a test though to be failing actually passes. it is complementary to\nxfail.\n\nhacking on subunit\n------------------\n\nreleases\n========\n\n* update versions in configure.ac and python/subunit/__init__.py.\n* update news.\n* do a make distcheck, which will update makefile etc.\n* do a pypi release: pythonpath=python python setup.py sdist bdist_wheel; twine upload -s dist/*\n* upload the regular one to lp.\n* push a tagged commit.\n  git push -t origin master:master\n",
  "docs_url": null,
  "keywords": "python test streaming",
  "license": "apache-2.0 or bsd",
  "name": "python-subunit",
  "package_url": "https://pypi.org/project/python-subunit/",
  "project_url": "https://pypi.org/project/python-subunit/",
  "project_urls": {
    "Bug Tracker": "https://bugs.launchpad.net/subunit",
    "Homepage": "http://launchpad.net/subunit",
    "Source Code": "https://github.com/testing-cabal/subunit/"
  },
  "release_url": "https://pypi.org/project/python-subunit/1.4.4/",
  "requires_dist": [
    "iso8601",
    "testtools (>=0.9.34)",
    "docutils ; extra == 'docs'",
    "fixtures ; extra == 'test'",
    "testscenarios ; extra == 'test'",
    "hypothesis ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "python implementation of subunit test streaming protocol",
  "version": "1.4.4",
  "releases": [],
  "developers": [
    "robert_collins",
    "subunit-dev@lists.launchpad.net"
  ],
  "kwds": "python test_suite testttools licenses license",
  "license_kwds": "apache-2.0 or bsd",
  "libtype": "pypi",
  "id": "pypi_python_subunit",
  "homepage": "http://launchpad.net/subunit",
  "release_count": 26,
  "dependency_ids": [
    "pypi_docutils",
    "pypi_fixtures",
    "pypi_hypothesis",
    "pypi_iso8601",
    "pypi_testscenarios",
    "pypi_testtools"
  ]
}