{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "[![pypi version][pypi-img]][pypi] [![python versions][pyver-img]][pypi] [![pypi downloads][pydl-img]][pypi] [![build status][ci-img]][ci] [![coverage status][cov-img]][cov] \n\n\n# opentracing-python-instrumentation\n\na collection of instrumentation tools to enable tracing with \n[opentracing api](http://opentracing.io).\n\n## module\n\nmake sure you are running recent enough versions of `pip` and `setuptools`, e.g. before installing your project requirements execute this:\n\n```\npip install --upgrade \"setuptools>=29\" \"pip>=9\"\n```\n\nthe module name is `opentracing_instrumentation`.\n\n## what's inside\n\n### supported client frameworks\n\nthe following libraries are instrumented for tracing in this module:\n * [boto3](https://github.com/boto/boto3) \u2014 aws sdk for python\n * [celery](https://github.com/celery/celery) \u2014 distributed task queue\n * `urllib2`\n * `requests`\n * `sqlalchemy`\n * `mysqldb`\n * `psycopg2`\n * tornado http client\n *  `redis`\n\n#### limitations\n\nfor some operations, `boto3` uses `threadpoolexecutor` under the hood.\nso, in order to make it thread-safe, the instrumentation is implemented using\n`span_in_stack_context()` which\n[forces you](https://github.com/uber-common/opentracing-python-instrumentation#in-process-context-propagation)\nto use `tornadoscopemanager`.\n\n### server instrumentation\n\nfor inbound requests a helper function `before_request` is provided for creating middleware for frameworks like flask and uwsgi.\n\n### manual instrumentation\n\nfinally, a `@traced_function` decorator is provided for manual instrumentation.\n\n### in-process context propagation\n\nas part of the opentracing 2.0 api, in-process `span` propagation happens through the newly defined\n[scopemanager](https://opentracing-python.readthedocs.io/en/latest/api.html#scope-managers)\ninterface. however, the existing functionality has been kept to provide backwards compatibility and\nease code migration:\n\n`span_in_context()` implements context propagation using the current `opentracing.tracer.scope_manager`,\nexpected to be a thread-local based `scopemanager`, such as `opentracing.scope_managers.threadlocalscopemanager`.\n\n`span_in_stack_context()` implements context propagation for tornado applications\nusing the current `opentracing.tracer.scope_manager` too, expected to be an instance of\n `opentracing.scope_managers.tornado.tornadoscopemanager`.\n\n`get_current_span()` returns the currently active `span`, if any.\n\ndirect access to the `request_context` module as well as usage of `requestcontext` and `requestcontextmanager`\nhave been **fully** deprecated, as they do not integrate with the new opentracing 2.0 api.\nusing them along `get_current_span()` is guaranteed to work, but it is **highly** recommended\nto switch to the previously mentioned functions.\n\n## usage\n\nthis library provides two types of instrumentation, explicit instrumentation\nfor server endpoints, and implicit instrumentation for client call sites.\n\nserver endpoints are instrumented by creating a middleware class that:\n\n 1. initializes the specific tracer implementation\n 2. wraps incoming request handlers into a method that reads the incoming\n    tracing info from the request and creates a new tracing span\n\nclient call sites are instrumented implicitly by executing a set of \navailable `client_hooks` that monkey-patch some api points in several \ncommon libraries like `sqlalchemy`, `urllib2`, tornado async http client.\nthe initialization of those hooks is usually also done from the middleware\nclass's `__init__` method.\n\nthere is a client-server example using this library with flask instrumentation\nfrom opentracing-contrib: https://github.com/opentracing-contrib/python-flask/tree/master/example.\n\nhere's an example of a middleware for [clay framework](https://github.com/uber/clay):\n\n```python\n\nfrom opentracing_instrumentation import span_in_context\nfrom opentracing_instrumentation.http_server import before_request\nfrom opentracing_instrumentation.http_server import wsgirequestwrapper\nfrom opentracing_instrumentation.client_hooks import install_all_patches\n\n\nclass tracermiddleware(object):\n\n    def __init__(self, app, wsgi_app):\n        self.wsgi_app = wsgi_app\n        self.service_name = app.name\n\n        config.app_name = self.service_name\n        config.caller_name_headers.append('x-uber-source')\n        config.callee_endpoint_headers.append('x-uber-endpoint')\n\n        install_all_patches()\n        self.wsgi_app = create_wsgi_middleware(wsgi_app)\n        self.init_tracer()\n\n    def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\n\n    def init_tracer(self):\n        # code specific to your tracer implementation\n        pass\n\n\ndef create_wsgi_middleware(other_wsgi, tracer=none):\n    \"\"\"\n    create a wrapper middleware for another wsgi response handler.\n    if tracer is not passed in, 'opentracing.tracer' is used.\n    \"\"\"\n\n    def wsgi_tracing_middleware(environ, start_response):\n        # todo find out if the route can be retrieved from somewhere\n\n        request = wsgirequestwrapper.from_wsgi_environ(environ)\n        span = before_request(request=request, tracer=tracer)\n\n        # wrapper around the real start_response object to log\n        # additional information to opentracing span\n        def start_response_wrapper(status, response_headers, exc_info=none):\n            if exc_info is not none:\n                span.set_tag('error', str(exc_info))\n            span.finish()\n\n            return start_response(status, response_headers)\n\n        with span_in_context(span):\n            return other_wsgi(environ, start_response_wrapper)\n\n    return wsgi_tracing_middleware\n```\n\nand here's an example for middleware in tornado-based app:\n\n```python\n\nimport opentracing\nfrom opentracing.scope_managers.tornado import tornadoscopemanager\nfrom opentracing_instrumentation import span_in_stack_context, http_server\n\n\nopentracing.tracer = myopentracingtracer(scope_manager=tornadoscopemanager())\n\n\nclass tracermiddleware(object):\n\n    def __init__(self):\n        # perform initialization similar to above, including installing\n        # the client_hooks\n\n    @gen.coroutine\n    def __call__(self, request, handler, next_mw):\n        request_wrapper = http_server.tornadorequestwrapper(request=request)\n        span = http_server.before_request(request=request_wrapper)\n\n        @gen.coroutine\n        def next_middleware_with_span():\n            yield next_mw()\n\n        yield run_coroutine_with_span(span=span,\n                                      func=next_middleware_with_span)\n\n        span.finish()\n\n\ndef run_coroutine_with_span(span, func, *args, **kwargs):\n    \"\"\"wrap the execution of a tornado coroutine func in a tracing span.\n\n    this makes the span available through the get_current_span() function.\n\n    :param span: the tracing span to expose.\n    :param func: co-routine to execute in the scope of tracing span.\n    :param args: positional args to func, if any.\n    :param kwargs: keyword args to func, if any.\n    \"\"\"\n    with span_in_stack_context(span):\n        return func(*args, **kwargs)\n```\n\n### customization\n\nfor the `requests` library, in case you want to set custom tags\nto spans depending on content or some metadata of responses,\nyou can set `response_handler_hook`.\nthe hook must be a method with a signature `(response, span)`,\nwhere `response` and `span` are positional arguments,\nso you can use different names for them if needed.\n\n```python\nfrom opentracing_instrumentation.client_hooks.requests import patcher\n\n\ndef hook(response, span):\n    if not response.ok:\n        span.set_tag('error', 'true')\n\n\npatcher.set_response_handler_hook(hook)\n```\n\nif you have issues with getting the parent span, it is possible to override\ndefault function that retrieves parent span. \n\n```python \nfrom opentracing_instrumentation.client_hooks import install_all_patches,\n     set_current_span_func\n\nset_current_span_func(my_custom_extractor_func)\ninstall_all_patches()\n\n``` \n\n## development\n\n`postgresql`, `rabbitmq`, `redis`, and `dynamodb` are required for certain tests.\n\n```bash\ndocker-compose up -d\n```\n\nto prepare a development environment please execute the following commands.\n```bash\nvirtualenv env\nsource env/bin/activate\nmake bootstrap\nmake test\n```\n\nyou can use [tox](https://tox.readthedocs.io) to run tests as well.\n```bash\ntox\n```\n\n[ci-img]: https://travis-ci.org/uber-common/opentracing-python-instrumentation.svg?branch=master\n[ci]: https://travis-ci.org/uber-common/opentracing-python-instrumentation\n[pypi-img]: https://img.shields.io/pypi/v/opentracing_instrumentation.svg\n[pypi]: https://pypi.python.org/pypi/opentracing_instrumentation\n[cov-img]: https://coveralls.io/repos/github/uber-common/opentracing-python-instrumentation/badge.svg\n[cov]: https://coveralls.io/github/uber-common/opentracing-python-instrumentation\n[pyver-img]: https://img.shields.io/pypi/pyversions/opentracing-instrumentation.svg \n[pydl-img]: https://img.shields.io/pypi/dm/opentracing-instrumentation.svg \n\n\n",
  "docs_url": null,
  "keywords": "opentracing",
  "license": "mit",
  "name": "opentracing-instrumentation",
  "package_url": "https://pypi.org/project/opentracing-instrumentation/",
  "project_url": "https://pypi.org/project/opentracing-instrumentation/",
  "project_urls": {
    "Homepage": "https://github.com/uber-common/opentracing-python-instrumentation"
  },
  "release_url": "https://pypi.org/project/opentracing-instrumentation/3.3.1/",
  "requires_dist": [
    "future",
    "wrapt",
    "tornado (<6,>=4.1)",
    "contextlib2",
    "opentracing (<3,>=2)",
    "six",
    "boto3 ; extra == 'tests'",
    "botocore ; extra == 'tests'",
    "celery ; extra == 'tests'",
    "doubles ; extra == 'tests'",
    "flake8 ; extra == 'tests'",
    "flake8-quotes ; extra == 'tests'",
    "mock ; extra == 'tests'",
    "moto ; extra == 'tests'",
    "psycopg2-binary ; extra == 'tests'",
    "sqlalchemy (>=1.3.7) ; extra == 'tests'",
    "pytest ; extra == 'tests'",
    "pytest-cov ; extra == 'tests'",
    "pytest-localserver ; extra == 'tests'",
    "pytest-mock ; extra == 'tests'",
    "pytest-tornado ; extra == 'tests'",
    "basictracer (<4,>=3) ; extra == 'tests'",
    "redis ; extra == 'tests'",
    "Sphinx ; extra == 'tests'",
    "sphinx-rtd-theme ; extra == 'tests'",
    "testfixtures ; extra == 'tests'",
    "MySQL-python ; (python_version == \"2.7\") and extra == 'tests'"
  ],
  "requires_python": "",
  "summary": "tracing instrumentation using opentracing api (http://opentracing.io)",
  "version": "3.3.1",
  "releases": [],
  "developers": [
    "ys@uber.com",
    "yuri_shkuro"
  ],
  "kwds": "pypi pip opentracing_instrumentation pydl wsgi_tracing_middleware",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_opentracing_instrumentation",
  "homepage": "https://github.com/uber-common/opentracing-python-instrumentation",
  "release_count": 38,
  "dependency_ids": [
    "pypi_basictracer",
    "pypi_boto3",
    "pypi_botocore",
    "pypi_celery",
    "pypi_contextlib2",
    "pypi_doubles",
    "pypi_flake8",
    "pypi_flake8_quotes",
    "pypi_future",
    "pypi_mock",
    "pypi_moto",
    "pypi_mysql_python",
    "pypi_opentracing",
    "pypi_psycopg2_binary",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_localserver",
    "pypi_pytest_mock",
    "pypi_pytest_tornado",
    "pypi_redis",
    "pypi_six",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme",
    "pypi_sqlalchemy",
    "pypi_testfixtures",
    "pypi_tornado",
    "pypi_wrapt"
  ]
}