{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: build tools"
  ],
  "description": "python-proxy\n============\n\n|made-with-python| |pypi-version| |hit-count| |downloads| |downloads-month| |downloads-week|\n\n.. |made-with-python| image:: https://img.shields.io/badge/made%20with-python-1f425f.svg\n   :target: https://www.python.org/\n.. |pypi-version| image:: https://badge.fury.io/py/pproxy.svg\n   :target: https://pypi.python.org/pypi/pproxy/\n.. |hit-count| image:: http://hits.dwyl.io/qwj/python-proxy.svg\n   :target: https://pypi.python.org/pypi/pproxy/\n.. |downloads| image:: https://pepy.tech/badge/pproxy\n   :target: https://pepy.tech/project/pproxy\n.. |downloads-month| image:: https://pepy.tech/badge/pproxy/month\n   :target: https://pepy.tech/project/pproxy\n.. |downloads-week| image:: https://pepy.tech/badge/pproxy/week\n   :target: https://pepy.tech/project/pproxy\n\nhttp/http2/http3/socks4/socks5/shadowsocks/ssh/redirect/pf/quic tcp/udp asynchronous tunnel proxy implemented in python3 asyncio.\n\nquickstart\n----------\n\n.. code:: rst\n\n  $ pip3 install pproxy\n  successfully installed pproxy-1.9.5\n  $ pproxy\n  serving on :8080 by http,socks4,socks5\n  ^c\n  $ pproxy -l ss://chacha20:abc@:8080\n  serving on :8080 by ss (chacha20-py)\n\noptional: (better performance with c ciphers)\n\n.. code:: rst\n\n  $ pip3 install pproxy[accelerated]\n  successfully installed pycryptodome-3.6.4\n\napply os system-wide proxy: (macos, windows)\n\n.. code:: rst\n\n  $ pproxy -r ss://chacha20:abc@server_ip:8080 --sys -vv\n  serving on :8080 by http,socks4,socks5\n  system proxy setting -> socks5 localhost:8080\n  socks5 ::1:57345 -> ss server_ip:8080 -> slack.com:443\n  socks5 ::1:57345 -> ss server_ip:8080 -> www.google.com:443\n  ..... (all local traffic log) ......\n\napply cli proxy: (macos, linux)\n\n.. code:: rst\n\n  $ export http_proxy=http://localhost:8080\n  $ export https_proxy=http://localhost:8080\n\nrun with docker\n---------------\n\n`pproxy` docker container has both python3 (with cryptodome for performance optimizations) and `pypy` versions available.\n\npython3:\n\n``docker run -it -p 8080:8080 mosajjal/pproxy:latest -l http://:8080 -vv``\n\npypy3:\n\n``docker run -it -p 8080:8080 mosajjal/pproxy:latest-pypy -l http://:8080 -vv``\n\nfeatures\n--------\n\n- lightweight single-thread asynchronous io.\n- pure python, no additional library required.\n- proxy client/server for tcp/udp.\n- schedule (load balance) among remote servers.\n- incoming traffic auto-detect.\n- tunnel/jump/backward-jump support.\n- unix domain socket support.\n- http v2, http v3 (quic)\n- user/password authentication support.\n- filter/block hostname by regex patterns.\n- ssl/tls client/server support.\n- shadowsocks ota (one-time-auth_), ssr plugins.\n- statistics by bandwidth and traffic.\n- pac support for javascript configuration.\n- iptables/pf nat redirect packet tunnel.\n- system proxy auto-setting support.\n- client/server api provided.\n\n.. _one-time-auth: https://shadowsocks.org/en/spec/one-time-auth.html\n\nprotocols\n---------\n\n+-------------------+------------+------------+------------+------------+--------------+\n| name              | tcp server | tcp client | udp server | udp client | scheme       |\n+===================+============+============+============+============+==============+\n| http (connect)    | \u2714          | \u2714          |            |            | http://      |\n+-------------------+            +------------+------------+------------+--------------+\n| http              |            | \u2714          |            |            | httponly://  |\n| (get,post,etc)    |            |            |            |            | (as client)  |\n+-------------------+------------+------------+------------+------------+--------------+\n| http v2 (connect) | \u2714          | \u2714          |            |            | h2://        |\n+-------------------+------------+------------+------------+------------+--------------+\n| http v3 (connect) | \u2714 by udp   | \u2714 by udp   |            |            | h3://        |\n+-------------------+------------+------------+------------+------------+--------------+\n| https             | \u2714          | \u2714          |            |            | http+ssl://  |\n+-------------------+------------+------------+------------+------------+--------------+\n| socks4            | \u2714          | \u2714          |            |            | socks4://    |\n+-------------------+------------+------------+------------+------------+--------------+\n| socks5            | \u2714          | \u2714          | \u2714 udp-only | \u2714 udp-only | socks5://    |\n+-------------------+------------+------------+------------+------------+--------------+\n| socks5 over tls   | \u2714          | \u2714          |            |            | socks5+ssl://|\n+-------------------+------------+------------+------------+------------+--------------+\n| shadowsocks       | \u2714          | \u2714          | \u2714          | \u2714          | ss://        |\n+-------------------+------------+------------+------------+------------+--------------+\n| shadowsocks aead  | \u2714          | \u2714          |            |            | ss://        |\n+-------------------+------------+------------+------------+------------+--------------+\n| shadowsocksr      | \u2714          | \u2714          |            |            | ssr://       |\n+-------------------+------------+------------+------------+------------+--------------+\n| trojan            | \u2714          | \u2714          |            |            | trojan://    |\n+-------------------+------------+------------+------------+------------+--------------+\n| ssh tunnel        |            | \u2714          |            |            | ssh://       |\n+-------------------+------------+------------+------------+------------+--------------+\n| quic              | \u2714 by udp   | \u2714 by udp   | \u2714          | \u2714          | http+quic:// |\n+-------------------+------------+------------+------------+------------+--------------+\n| iptables nat      | \u2714          |            |            |            | redir://     |\n+-------------------+------------+------------+------------+------------+--------------+\n| pfctl nat (macos) | \u2714          |            |            |            | pf://        |\n+-------------------+------------+------------+------------+------------+--------------+\n| echo              | \u2714          |            | \u2714          |            | echo://      |\n+-------------------+------------+------------+------------+------------+--------------+\n| tunnel            | \u2714          | \u2714          | \u2714          | \u2714          | tunnel://    |\n| (raw socket)      |            |            |            |            | tunnel{ip}://|\n+-------------------+------------+------------+------------+------------+--------------+\n| websocket         | \u2714          | \u2714          |            |            | ws://        |\n| (simple tunnel)   |            |            |            |            | ws{dst_ip}://|\n+-------------------+------------+------------+------------+------------+--------------+\n| xxx over tls      | \u2714          | \u2714          |            |            | xxx+ssl://   |\n+-------------------+------------+------------+------------+------------+--------------+\n| auto detect       | \u2714          |            | \u2714          |            | a+b+c+d://   |\n+-------------------+------------+------------+------------+------------+--------------+\n\nscheduling algorithms\n---------------------\n\n+-------------------+------------+------------+------------+------------+\n| name              | tcp        | udp        | parameter  | default    |\n+===================+============+============+============+============+\n| first_available   | \u2714          | \u2714          | -s fa      | \u2714          |\n+-------------------+------------+------------+------------+------------+\n| round_robin       | \u2714          | \u2714          | -s rr      |            |\n+-------------------+------------+------------+------------+------------+\n| random_choice     | \u2714          | \u2714          | -s rc      |            |\n+-------------------+------------+------------+------------+------------+\n| least_connection  | \u2714          |            | -s lc      |            |\n+-------------------+------------+------------+------------+------------+\n\nrequirement\n-----------\n\npycryptodome_ is an optional library to enable faster (c version) cipher. **pproxy** has many built-in pure python ciphers. they are lightweight and stable, but slower than c ciphers. after speedup with pypy_, pure python ciphers can get similar performance as c version. if the performance is important and don't have pypy_, install pycryptodome_ instead.\n\nasyncssh_ is an optional library to enable ssh tunnel client support.\n\nthese are some performance benchmarks between python and c ciphers (dataset: 8m):\n\n+---------------------+----------------+\n| chacha20-c          | 0.64 secs      |\n+---------------------+----------------+\n| chacha20-py (pypy3) | 1.32 secs      |\n+---------------------+----------------+\n| chacha20-py         | 48.86 secs     |\n+---------------------+----------------+\n\npypy3 quickstart:\n\n.. code:: rst\n\n  $ pypy3 -m ensurepip\n  $ pypy3 -m pip install asyncio pproxy\n\n.. _pycryptodome: https://pycryptodome.readthedocs.io/en/latest/src/introduction.html\n.. _asyncssh: https://asyncssh.readthedocs.io/en/latest/\n.. _pypy: http://pypy.org\n\nusage\n-----\n\n.. code:: rst\n\n  $ pproxy -h\n  usage: pproxy [-h] [-l listen] [-r rserver] [-ul ulisten] [-ur urserver]\n                [-b block] [-a alived] [-v] [--ssl sslfile] [--pac pac]\n                [--get gets] [--sys] [--test testurl] [--version]\n\n  proxy server that can tunnel among remote servers by regex rules. supported\n  protocols: http,socks4,socks5,shadowsocks,shadowsocksr,redirect,pf,tunnel\n\n  optional arguments:\n    -h, --help        show this help message and exit\n    -l listen         tcp server uri (default: http+socks4+socks5://:8080/)\n    -r rserver        tcp remote server uri (default: direct)\n    -ul ulisten       udp server setting uri (default: none)\n    -ur urserver      udp remote server uri (default: direct)\n    -b block          block regex rules\n    -a alived         interval to check remote alive (default: no check)\n    -s {fa,rr,rc,lc}  scheduling algorithm (default: first_available)\n    -v                print verbose output\n    --ssl sslfile     certfile[,keyfile] if server listen in ssl mode\n    --pac pac         http pac path\n    --get gets        http custom {path,file}\n    --sys             change system proxy setting (mac, windows)\n    --test test       test this url for all remote proxies and exit\n    --version         show program's version number and exit\n\n  online help: <https://github.com/qwj/python-proxy>\n\nuri syntax\n----------\n\n.. code:: rst\n\n  {scheme}://[{cipher}@]{netloc}/[@{localbind}][,{plugins}][?{rules}][#{auth}]\n\n- scheme\n\n  - currently supported scheme: http, socks, ss, ssl, secure. you can use + to link multiple protocols together.\n\n    +----------+-----------------------------+\n    | http     | http protocol (connect)     |\n    +----------+-----------------------------+\n    | httponly | http protocol (get/post)    |\n    +----------+-----------------------------+\n    | socks4   | socks4 protocol             |\n    +----------+-----------------------------+\n    | socks5   | socks5 protocol             |\n    +----------+-----------------------------+\n    | ss       | shadowsocks protocol        |\n    +----------+-----------------------------+\n    | ssr      | shadowsocksr (ssr) protocol |\n    +----------+-----------------------------+\n    | trojan   | trojan_ protocol            |\n    +----------+-----------------------------+\n    | ssh      | ssh client tunnel           |\n    +----------+-----------------------------+\n    | redir    | redirect (iptables nat)     |\n    +----------+-----------------------------+\n    | pf       | pfctl (macos pf nat)        |\n    +----------+-----------------------------+\n    | ssl      | unsecured ssl/tls (no cert) |\n    +----------+-----------------------------+\n    | secure   | secured ssl/tls (cert)      |\n    +----------+-----------------------------+\n    | tunnel   | raw connection              |\n    +----------+-----------------------------+\n    | ws       | websocket connection        |\n    +----------+-----------------------------+\n    | echo     | echo-back service           |\n    +----------+-----------------------------+\n    | direct   | direct connection           |\n    +----------+-----------------------------+\n\n.. _trojan: https://trojan-gfw.github.io/trojan/protocol\n\n  - \"http://\" accepts get/post/connect as server, sends connect as client. \"httponly://\" sends \"get/post\" as client, works only on http traffic.\n\n  - valid schemes: http://, http+socks4+socks5://, http+ssl://, ss+secure://, http+socks5+ss://\n\n  - invalid schemes: ssl://, secure://\n\n- cipher\n\n  - cipher's format: \"cipher_name:cipher_key\". cipher can be base64-encoded. so cipher string with \"ywvzlteyoc1ny206dgvzda==\" is equal to \"aes-128-gcm:test\".\n\n  - full cipher support list:\n\n    +-----------------+------------+-----------+-------------+\n    | cipher          | key length | iv length | score (0-5) |\n    +=================+============+===========+=============+\n    | table-py        | any        | 0         | 0 (lowest)  |\n    +-----------------+------------+-----------+-------------+\n    | rc4             | 16         | 0         | 0 (lowest)  |\n    +-----------------+------------+-----------+-------------+\n    | rc4-md5         | 16         | 16        | 0.5         |\n    +-----------------+------------+-----------+-------------+\n    | chacha20        | 32         | 8         | 5 (highest) |\n    +-----------------+------------+-----------+-------------+\n    | chacha20-ietf   | 32         | 12        | 5           |\n    +-----------------+------------+-----------+-------------+\n    | chacha20-ietf-  |            |           |             |\n    | poly1305-py     | 32         | 32        | aead        |\n    +-----------------+------------+-----------+-------------+\n    | salsa20         | 32         | 8         | 4.5         |\n    +-----------------+------------+-----------+-------------+\n    | aes-128-cfb     | 16         | 16        | 3           |\n    |                 |            |           |             |\n    | aes-128-cfb8    |            |           |             |\n    |                 |            |           |             |\n    | aes-128-cfb1-py |            |           | slow        |\n    +-----------------+------------+-----------+-------------+\n    | aes-192-cfb     | 24         | 16        | 3.5         |\n    |                 |            |           |             |\n    | aes-192-cfb8    |            |           |             |\n    |                 |            |           |             |\n    | aes-192-cfb1-py |            |           | slow        |\n    +-----------------+------------+-----------+-------------+\n    | aes-256-cfb     | 32         | 16        | 4.5         |\n    |                 |            |           |             |\n    | aes-256-ctr     |            |           |             |\n    |                 |            |           |             |\n    | aes-256-ofb     |            |           |             |\n    |                 |            |           |             |\n    | aes-256-cfb8    |            |           |             |\n    |                 |            |           |             |\n    | aes-256-cfb1-py |            |           | slow        |\n    +-----------------+------------+-----------+-------------+\n    | aes-256-gcm     | 32         | 32        | aead        |\n    |                 |            |           |             |\n    | aes-192-gcm     | 24         | 24        | aead        |\n    |                 |            |           |             |\n    | aes-128-gcm     | 16         | 16        | aead        |\n    +-----------------+------------+-----------+-------------+\n    | camellia-256-cfb| 32         | 16        | 4           |\n    |                 |            |           |             |\n    | camellia-192-cfb| 24         | 16        | 4           |\n    |                 |            |           |             |\n    | camellia-128-cfb| 16         | 16        | 4           |\n    +-----------------+------------+-----------+-------------+\n    | bf-cfb          | 16         | 8         | 1           |\n    +-----------------+------------+-----------+-------------+\n    | cast5-cfb       | 16         | 8         | 2.5         |\n    +-----------------+------------+-----------+-------------+\n    | des-cfb         | 8          | 8         | 1.5         |\n    +-----------------+------------+-----------+-------------+\n    | rc2-cfb-py      | 16         | 8         | 2           |\n    +-----------------+------------+-----------+-------------+\n    | idea-cfb-py     | 16         | 8         | 2.5         |\n    +-----------------+------------+-----------+-------------+\n    | seed-cfb-py     | 16         | 16        | 2           |\n    +-----------------+------------+-----------+-------------+\n\n  - *pproxy* ciphers have pure python implementations. program will switch to c cipher if there is c implementation available within pycryptodome_. otherwise, use pure python cipher.\n\n  - aead ciphers use additional payload after each packet. the underlying protocol is different. specifications: aead_.\n\n  - some pure python ciphers (aes-256-cfb1-py) is quite slow, and is not recommended to use without pypy speedup. try install pycryptodome_ and use c version cipher instead.\n\n  - to enable ota encryption with shadowsocks, add '!' immediately after cipher name.\n\n- netloc\n\n  - it can be \"hostname:port\" or \"/unix_domain_socket\". if the hostname is empty, server will listen on all interfaces.\n\n  - valid netloc: localhost:8080, 0.0.0.0:8123, /tmp/domain_socket, :8123\n\n- localbind\n\n  - it can be \"@in\" or @ipv4_address or @ipv6_address\n\n  - valid localbind: @in, @192.168.1.15, @::1\n\n- plugins\n\n  - it can be multiple plugins joined by \",\". supported plugins: plain, origin, http_simple, tls1.2_ticket_auth, verify_simple, verify_deflate\n\n  - valid plugins: /,tls1.2_ticket_auth,verify_simple\n\n- rules\n\n  - the filename that contains regex rules\n\n- auth\n\n  - the username, colon ':', and the password\n\nuris can be joined by \"__\" to indicate tunneling by jump. for example, ss://1.2.3.4:1324__http://4.5.6.7:4321 make remote connection to the first shadowsocks proxy server, and then jump to the second http proxy server.\n\n.. _aead: http://shadowsocks.org/en/spec/aead-ciphers.html\n\nclient api\n----------\n\n- tcp client api\n\n  .. code:: rst\n\n    import asyncio, pproxy\n\n    async def test_tcp(proxy_uri):\n        conn = pproxy.connection(proxy_uri)\n        reader, writer = await conn.tcp_connect('google.com', 80)\n        writer.write(b'get / http/1.1\\r\\n\\r\\n')\n        data = await reader.read(1024*16)\n        print(data.decode())\n\n    asyncio.run(test_tcp('ss://aes-256-cfb:password@remote_host:remote_port'))\n\n- udp client api\n\n  .. code:: rst\n\n    import asyncio, pproxy\n\n    async def test_udp(proxy_uri):\n        conn = pproxy.connection(proxy_uri)\n        answer = asyncio.future()\n        await conn.udp_sendto('8.8.8.8', 53, b'hello the world', answer.set_result)\n        await answer\n        print(answer.result())\n\n    asyncio.run(test_udp('ss://chacha20:password@remote_host:remote_port'))\n\nserver api\n----------\n\n- server api example:\n\n  .. code:: rst\n\n    import asyncio\n    import pproxy\n\n    server = pproxy.server('ss://0.0.0.0:1234')\n    remote = pproxy.connection('ss://1.2.3.4:5678')\n    args = dict( rserver = [remote],\n                 verbose = print )\n\n    loop = asyncio.get_event_loop()\n    handler = loop.run_until_complete(server.start_server(args))\n    try:\n        loop.run_forever()\n    except keyboardinterrupt:\n        print('exit!')\n\n    handler.close()\n    loop.run_until_complete(handler.wait_closed())\n    loop.run_until_complete(loop.shutdown_asyncgens())\n    loop.close()\n\n\nexamples\n--------\n\n- regex rule\n\n  define regex file \"rules\" as follow:\n\n  .. code:: rst\n\n    #google domains\n    (?:.+\\.)?google.*\\.com\n    (?:.+\\.)?gstatic\\.com\n    (?:.+\\.)?gmail\\.com\n    (?:.+\\.)?ntp\\.org\n    (?:.+\\.)?glpals\\.com\n    (?:.+\\.)?akamai.*\\.net\n    (?:.+\\.)?ggpht\\.com\n    (?:.+\\.)?android\\.com\n    (?:.+\\.)?gvt1\\.com\n    (?:.+\\.)?youtube.*\\.com\n    (?:.+\\.)?ytimg\\.com\n    (?:.+\\.)?goo\\.gl\n    (?:.+\\.)?youtu\\.be\n    (?:.+\\.)?google\\..+\n\n  then start *pproxy*\n\n  .. code:: rst\n\n    $ pproxy -r http://aa.bb.cc.dd:8080?rules -vv\n    serving on :8080 by http,socks4,socks5\n    http ::1:57768 -> http aa.bb.cc.dd:8080 -> www.googleapis.com:443\n    http ::1:57772 -> www.yahoo.com:80\n    socks4 ::1:57770 -> http aa.bb.cc.dd:8080 -> www.youtube.com:443\n\n  *pproxy* will serve incoming traffic by http/socks4/socks5 auto-detect protocol, redirect all google traffic to http proxy aa.bb.cc.dd:8080, and visit all other traffic directly from local.\n\n- use cipher\n\n  add cipher encryption to make sure data can't be intercepted. run *pproxy* locally as:\n\n  .. code:: rst\n\n    $ pproxy -l ss://:8888 -r ss://chacha20:cipher_key@aa.bb.cc.dd:12345 -vv\n\n  next, run pproxy.py remotely on server \"aa.bb.cc.dd\". the base64 encoded string of \"chacha20:cipher_key\" is also supported:\n\n  .. code:: rst\n\n    $ pproxy -l ss://chacha20:cipher_key@:12345\n\n  the same as:\n\n  .. code:: rst\n\n    $ pproxy -l ss://y2hhy2hhmja6y2lwagvyx2tleq==@:12345\n\n  the traffic between local and aa.bb.cc.dd is encrypted by stream cipher chacha20 with secret key \"cipher_key\".\n\n- unix domain socket\n\n  a more complex example:\n\n  .. code:: rst\n\n    $ pproxy -l ss://salsa20!:complex_cipher_key@/tmp/pproxy_socket -r http+ssl://domain1.com:443#username:password\n\n  *pproxy* listen on the unix domain socket \"/tmp/pproxy_socket\" with cipher \"salsa20\" and key \"complex_cipher_key\". ota packet protocol is enabled by adding ! after cipher name. the traffic is tunneled to remote https proxy with simple http authentication.\n\n- ssl/tls server\n\n  if you want to listen in ssl/tls, you must specify ssl certificate and private key files by parameter \"--ssl\":\n\n  .. code:: rst\n\n    $ pproxy -l http+ssl://0.0.0.0:443 -l http://0.0.0.0:80 --ssl server.crt,server.key --pac /autopac\n\n  *pproxy* listen on both 80 http and 443 https ports, use the specified ssl/tls certificate and private key files. the \"--pac\" enable pac feature, so you can put \"https://yourdomain.com/autopac\" path in your device's auto-configure url.\n\n  simple guide for generating self-signed ssl certificates:\n\n  .. code:: rst\n\n    $ openssl genrsa -des3 -out server.key 1024\n    $ openssl req -new -key server.key -out server.csr\n    $ cp server.key server.key.org\n    $ openssl rsa -in server.key.org -out server.key\n    $ openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt\n\n- ssr plugins\n\n  shadowsocksr example with plugin \"tls1.2_ticket_auth\" to emulate common tls traffic:\n\n  .. code:: rst\n\n    $ pproxy -l ssr://chacha20:mypass@0.0.0.0:443/,tls1.2_ticket_auth,verify_simple\n\n- local bind ip\n\n  if you want to route the traffic by different local bind, use the @localbind uri syntax. for example, server has three ip interfaces: 192.168.1.15, 111.0.0.1, 112.0.0.1. you want to route traffic matched by \"rule1\" to 111.0.0.2 and traffic matched by \"rule2\" to 222.0.0.2, and the remaining traffic directly:\n\n  .. code:: rst\n\n    $ pproxy -l ss://:8000/@in -r ss://111.0.0.2:8000/@111.0.0.1?rule1 -r ss://222.0.0.2:8000/@222.0.0.1?rule2\n\n- redirect/pf protocol\n\n  iptable nat redirect example (ubuntu):\n\n  .. code:: rst\n\n    $ sudo iptables -t nat -a output -p tcp --dport 80 -j redirect --to-ports 5555\n    $ pproxy -l redir://:5555 -r http://remote_http_server:3128 -vv\n\n  the above example illustrates how to redirect all local output tcp traffic with destination port 80 to localhost port 5555 listened by **pproxy**, and then tunnel the traffic to remote http proxy.\n\n  pf redirect example (macos):\n\n  .. code:: rst\n\n    $ sudo pfctl -ef /dev/stdin\n    rdr pass on lo0 inet proto tcp from any to any port 80 -> 127.0.0.1 port 8080\n    pass out on en0 route-to lo0 inet proto tcp from any to any port 80 keep state\n    ^d\n    $ sudo pproxy -l pf://:8080 -r socks5://remote_socks5_server:1324 -vv\n\n  make sure **pproxy** runs in root mode (sudo), otherwise it cannot redirect pf packet.\n\n- multiple jumps example\n\n  .. code:: rst\n\n    $ pproxy -r http://server1__ss://server2__socks://server3\n\n  *pproxy* will connect to server1 first, tell server1 connect to server2, and tell server2 connect to server3, and make real traffic by server3.\n\n- raw connection tunnel\n\n  tcp raw connection tunnel example:\n\n  .. code:: rst\n\n    $ pproxy -l tunnel{google.com}://:80\n    $ curl -h \"host: google.com\" http://localhost\n\n  udp dns tunnel example:\n\n  .. code:: rst\n\n    $ pproxy -ul tunnel{8.8.8.8}://:53\n    $ nslookup google.com localhost\n\n- udp more complicated example\n\n  run the shadowsocks udp proxy on remote machine:\n\n  .. code:: rst\n\n    $ pproxy -ul ss://remote_server:13245\n\n  run the commands on local machine:\n\n  .. code:: rst\n\n    $ pproxy -ul tunnel{8.8.8.8}://:53 -ur ss://remote_server:13245 -vv\n    udp tunnel 127.0.0.1:60573 -> ss remote_server:13245 -> 8.8.8.8:53\n    udp tunnel 127.0.0.1:60574 -> ss remote_server:13245 -> 8.8.8.8:53\n    ...\n    $ nslookup google.com localhost\n\n- load balance example\n\n  specify multiple -r server, and a scheduling algorithm (rr = round_robin, rc = random_choice, lc = least_connection):\n\n  .. code:: rst\n\n    $ pproxy -r http://server1 -r ss://server2 -r socks5://server3 -s rr -vv\n    http ::1:42356 -> http server1 -> google.com:443\n    http ::1:42357 -> ss server2 -> google.com:443\n    http ::1:42358 -> socks5 server3 -> google.com:443\n    http ::1:42359 -> http server1 -> google.com:443\n    ...\n    $ pproxy -ul tunnel://:53 -ur tunnel://8.8.8.8:53 -ur tunnel://8.8.4.4:53 -s rc -vv\n    udp tunnel ::1:35378 -> tunnel 8.8.8.8:53\n    udp tunnel ::1:35378 -> tunnel 8.8.4.4:53\n    ...\n\n- websocket example\n\n  websocket protocol is similar to tunnel protocol. it is raw and doesn't support any proxy function. it can connect to other proxy like tunnel protocol.\n\n  first run pproxy on remote machine:\n\n  .. code:: rst\n\n    $ pproxy -l ws://:80 -r tunnel:///tmp/myproxy -v\n    $ pproxy -l ss://chacha20:abc@/tmp/myproxy -v\n\n  run pproxy on local machine:\n\n  .. code:: rst\n\n    $ pproxy -l tunnel://:1234 -r ws://remote_ip:80 -vv\n\n  then port :1234 on local machine is connected to the /tmp/myproxy on remote machine by websocket tunnel. you can specify any proxy protocol details on /tmp/myproxy.\n\n  it is a good practice to use some cdn in the middle of local/remote machines. cdn with websocket support can hide remote machine's real ip from public.\n\n- backward proxy\n\n  sometimes, the proxy server hides behind an nat router and doesn't have a public ip. the client side has a public ip \"client_ip\". backward proxy feature enables the server to connect backward to client and wait for proxy requests.\n\n  run **pproxy** client as follows:\n\n  .. code:: rst\n\n    $ pproxy -l http://:8080 -r http+in://:8081 -v\n\n  run **pproxy** server as follows:\n\n  .. code:: rst\n\n    $ pproxy -l http+in://client_ip:8081\n\n  server connects to client_ip:8081 and waits for client proxy requests. the protocol http specified is just an example. it can be any protocol and cipher **pproxy** supports. the scheme \"**in**\" should exist in uri to inform **pproxy** that it is a backward proxy.\n\n  .. code:: rst\n\n    $ pproxy -l http+in://jumpserver__http://client_ip:8081\n\n  it is a complicated example. server connects to client_ip:8081 by jump http://jumpserver. the backward proxy works through jumps.\n\n- ssh client tunnel\n\n  ssh client tunnel support is enabled by installing additional library asyncssh_. after \"pip3 install asyncssh\", you can specify \"**ssh**\" as scheme to proxy via ssh client tunnel.\n\n  .. code:: rst\n\n    $ pproxy -l http://:8080 -r ssh://remote_server.com/#login:password\n\n  if a client private key is used to authenticate, put double colon \"::\" between login and private key path.\n\n  .. code:: rst\n\n    $ pproxy -l http://:8080 -r ssh://remote_server.com/#login::private_key_path\n\n  ssh connection known_hosts feature is disabled by default.\n\n- ssh jump\n\n  ssh jump is supported by using \"__\" concatenation\n\n  .. code:: rst\n\n    $ pproxy -r ssh://server1__ssh://server2__ssh://server3\n\n  first connection to server1 is made. second, ssh connection to server2 is made from server1. finally, connect to server3, and use server3 for proxying traffic.\n\n- ssh remote forward\n\n  .. code:: rst\n\n    $ pproxy -l ssh://server__tunnel://0.0.0.0:1234 -r tunnel://127.0.0.1:1234\n\n  tcp :1234 on remote server is forwarded to 127.0.0.1:1234 on local server\n\n  .. code:: rst\n\n    $ pproxy -l ssh://server1__ssh://server2__ss://0.0.0.0:1234 -r ss://server3:1234\n\n  it is a complicated example. ssh server2 is jumped from ssh server1, and ss://0.0.0.0:1234 on server2 is listened. traffic is forwarded to ss://server3:1234.\n\n- trojan protocol example\n\n  normally trojan:// should be used together with ssl://. you should specify the ssl crt/key file for ssl usage. a typical trojan server would be:\n\n  .. code:: rst\n\n    $ pproxy --ssl ssl.crt,ssl.key -l trojan+tunnel{localhost:80}+ssl://:443#yourpassword -vv\n\n  if trojan password doesn't match, the tunnal{localhost:80} will be switched to. it looks exactly the same as a common https website.\n\n- quic protocol example\n\n  quic is a udp stream protocol used in http/3. library **aioquic** is required if you want to proxy via quic.\n  quic is listened on udp port, but can handle tcp or udp traffic. if you want to handle tcp traffic, you should use \"-l quic+http\" instead of \"-ul quic+http\".\n\n  .. code:: rst\n\n    $ pip3 install aioquic\n    $ pproxy --ssl ssl.crt,ssl.key -l quic+http://:1234\n\n  on the client:\n\n    $ pproxy -r quic+http://server:1234\n\n  quic protocol can transfer a lot of tcp streams on one single udp stream. if the connection number is hugh, quic can benefit by reducing tcp handshake time.\n\n- vpn server example\n\n  you can run vpn server simply by installing pvpn (python vpn), a lightweight vpn server with pproxy tunnel feature.\n\n  .. code:: rst\n\n    $ pip3 install pvpn\n    successfully installed pvpn-0.2.1\n    $ pvpn -wg 9999 -r http://remote_server:remote_port\n    serving on udp :500 :4500...\n    serving on udp :9000 (wireguard)...\n    tcp xx.xx.xx.xx:xx -> http xx.xx.xx.xx:xx -> xx.xx.xx.xx:xx\n\n\nprojects\n--------\n\n+ `python-vpn <https://github.com/qwj/python-vpn>`_ - vpn server (ipsec,ike,ikev2,l2tp,wireguard) in pure python\n+ `shadowproxy <https://github.com/guyingbo/shadowproxy>`_ - awesome python proxy implementation by guyingbo\n\n",
  "docs_url": null,
  "keywords": "proxy socks http shadowsocks shadowsocksr ssr redirect pf tunnel cipher ssl udp",
  "license": "mit",
  "name": "pproxy-ext",
  "package_url": "https://pypi.org/project/pproxy-ext/",
  "project_url": "https://pypi.org/project/pproxy-ext/",
  "project_urls": {
    "Homepage": "https://github.com/localstack/python-proxy"
  },
  "release_url": "https://pypi.org/project/pproxy-ext/2.7.9/",
  "requires_dist": [
    "pycryptodome >=3.7.2 ; extra == 'accelerated'",
    "uvloop >=0.13.0 ; extra == 'accelerated'",
    "python-daemon >=2.2.3 ; extra == 'daemon'",
    "aioquic >=0.9.7 ; extra == 'quic'",
    "asyncssh >=2.5.0 ; extra == 'sshtunnel'"
  ],
  "requires_python": ">=3.6",
  "summary": "proxy server that can tunnel among remote servers by regex rules.",
  "version": "2.7.9",
  "releases": [],
  "developers": [
    "qian_wenjie",
    "qianwenjie@gmail.com"
  ],
  "kwds": "shadowproxy remote_socks5_server pproxy_socket https_proxy server2__socks",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pproxy_ext",
  "homepage": "https://github.com/localstack/python-proxy",
  "release_count": 1,
  "dependency_ids": [
    "pypi_aioquic",
    "pypi_asyncssh",
    "pypi_pycryptodome",
    "pypi_python_daemon",
    "pypi_uvloop"
  ]
}