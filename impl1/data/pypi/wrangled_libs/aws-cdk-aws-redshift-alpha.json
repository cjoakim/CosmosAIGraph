{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: aws cdk",
    "framework :: aws cdk :: 2",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon redshift construct library\n\n<!--begin stability banner-->---\n\n\n![cdk-constructs: experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)\n\n> the apis of higher level constructs in this module are experimental and under active development.\n> they are subject to non-backward compatible changes or removal in any future version. these are\n> not subject to the [semantic versioning](https://semver.org/) model and breaking changes will be\n> announced in the release notes. this means that while you may use them, you may need to update\n> your source code when upgrading to a newer version of this package.\n\n---\n<!--end stability banner-->\n\n## starting a redshift cluster database\n\nto set up a redshift cluster, define a `cluster`. it will be launched in a vpc.\nyou can specify a vpc, otherwise one will be created. the nodes are always launched in private subnets and are encrypted by default.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\n\n\nvpc = ec2.vpc(self, \"vpc\")\ncluster = cluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc\n)\n```\n\nby default, the master password will be generated and stored in aws secrets manager.\n\na default database named `default_db` will be created in the cluster. to change the name of this database set the `defaultdatabasename` attribute in the constructor properties.\n\nby default, the cluster will not be publicly accessible.\ndepending on your use case, you can make the cluster publicly accessible with the `publiclyaccessible` property.\n\n## adding a logging bucket for database audit logging to s3\n\namazon redshift logs information about connections and user activities in your database. these logs help you to monitor the database for security and troubleshooting purposes, a process called database auditing. to send these logs to an s3 bucket, specify the `loggingproperties` when creating a new cluster.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk.aws_s3 as s3\n\n\nvpc = ec2.vpc(self, \"vpc\")\nbucket = s3.bucket.from_bucket_name(self, \"bucket\", \"logging-bucket\")\n\ncluster = cluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc,\n    logging_properties=loggingproperties(\n        logging_bucket=bucket,\n        logging_key_prefix=\"prefix\"\n    )\n)\n```\n\n## connecting\n\nto control who can access the cluster, use the `.connections` attribute. redshift clusters have\na default port, so you don't need to specify the port:\n\n```python\ncluster.connections.allow_default_port_from_any_ipv4(\"open to the world\")\n```\n\nthe endpoint to access your database cluster will be available as the `.clusterendpoint` attribute:\n\n```python\ncluster.cluster_endpoint.socket_address\n```\n\n## database resources\n\nthis module allows for the creation of non-cloudformation database resources such as users\nand tables. this allows you to manage identities, permissions, and stateful resources\nwithin your redshift cluster from your cdk application.\n\nbecause these resources are not available in cloudformation, this library leverages\n[custom\nresources](https://docs.aws.amazon.com/cdk/api/latest/docs/custom-resources-readme.html)\nto manage them. in addition to the iam permissions required to make redshift service\ncalls, the execution role for the custom resource handler requires database credentials to\ncreate resources within the cluster.\n\nthese database credentials can be supplied explicitly through the `adminuser` properties\nof the various database resource constructs. alternatively, the credentials can be\nautomatically pulled from the redshift cluster's default administrator\ncredentials. however, this option is only available if the password for the credentials\nwas generated by the cdk application (ie., no value vas provided for [the `masterpassword`\nproperty](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-redshift.login.html#masterpasswordspan-classapi-icon-api-icon-experimental-titlethis-api-element-is-experimental-it-may-change-without-noticespan)\nof\n[`cluster.masteruser`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-redshift.cluster.html#masteruserspan-classapi-icon-api-icon-experimental-titlethis-api-element-is-experimental-it-may-change-without-noticespan)).\n\n### creating users\n\ncreate a user within a redshift cluster database by instantiating a `user` construct. this\nwill generate a username and password, store the credentials in a [aws secrets manager\n`secret`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-secretsmanager.secret.html),\nand make a query to the redshift cluster to create a new database user with the\ncredentials.\n\n```python\nuser(self, \"user\",\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\nby default, the user credentials are encrypted with your aws account's default secrets\nmanager encryption key. you can specify the encryption key used for this purpose by\nsupplying a key in the `encryptionkey` property.\n\n```python\nimport aws_cdk.aws_kms as kms\n\n\nencryption_key = kms.key(self, \"key\")\nuser(self, \"user\",\n    encryption_key=encryption_key,\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\nby default, a username is automatically generated from the user construct id and its path\nin the construct tree. you can specify a particular username by providing a value for the\n`username` property. usernames must be valid identifiers; see: [names and\nidentifiers](https://docs.aws.amazon.com/redshift/latest/dg/r_names.html) in the *amazon\nredshift database developer guide*.\n\n```python\nuser(self, \"user\",\n    username=\"myuser\",\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\nthe user password is generated by aws secrets manager using the default configuration\nfound in\n[`secretsmanager.secretstringgenerator`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-secretsmanager.secretstringgenerator.html),\nexcept with password length `30` and some sql-incompliant characters excluded. the\nplaintext for the password will never be present in the cdk application; instead, a\n[cloudformation dynamic\nreference](https://docs.aws.amazon.com/awscloudformation/latest/userguide/dynamic-references.html)\nwill be used wherever the password value is required.\n\n### creating tables\n\ncreate a table within a redshift cluster database by instantiating a `table`\nconstruct. this will make a query to the redshift cluster to create a new database table\nwith the supplied schema.\n\n```python\ntable(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\"), column(name=\"col2\", data_type=\"float\")],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\ntables greater than v2.114.1 can have their table name changed, for versions <= v2.114.1, this would not be possible.\ntherefore, changing of table names for <= v2.114.1 have been disabled.\n\n```python\n# example automatically generated from non-compiling source. may contain errors.\ntable(self, \"table\",\n    table_name=\"oldtablename\",  # this value can be change for versions greater than v2.114.1\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\"), column(name=\"col2\", data_type=\"float\")],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\nthe table can be configured to have diststyle attribute and a distkey column:\n\n```python\ntable(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\", dist_key=true), column(name=\"col2\", data_type=\"float\")\n    ],\n    cluster=cluster,\n    database_name=\"databasename\",\n    dist_style=tablediststyle.key\n)\n```\n\nthe table can also be configured to have sortstyle attribute and sortkey columns:\n\n```python\ntable(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\", sort_key=true), column(name=\"col2\", data_type=\"float\", sort_key=true)\n    ],\n    cluster=cluster,\n    database_name=\"databasename\",\n    sort_style=tablesortstyle.compound\n)\n```\n\ntables and their respective columns can be configured to contain comments:\n\n```python\ntable(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\", comment=\"this is a column comment\"), column(name=\"col2\", data_type=\"float\", comment=\"this is a another column comment\")\n    ],\n    cluster=cluster,\n    database_name=\"databasename\",\n    table_comment=\"this is a table comment\"\n)\n```\n\ntable columns can be configured to use a specific compression encoding:\n\n```python\nfrom aws_cdk.aws_redshift_alpha import columnencoding\n\n\ntable(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\", encoding=columnencoding.text32k), column(name=\"col2\", data_type=\"float\", encoding=columnencoding.delta32k)\n    ],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\ntable columns can also contain an `id` attribute, which can allow table columns to be renamed.\n\n**note** to use the `id` attribute, you must also enable the `@aws-cdk/aws-redshift:columnid` feature flag.\n\n```python\ntable(self, \"table\",\n    table_columns=[column(id=\"col1\", name=\"col1\", data_type=\"varchar(4)\"), column(id=\"col2\", name=\"col2\", data_type=\"float\")\n    ],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n```\n\n### granting privileges\n\nyou can give a user privileges to perform certain actions on a table by using the\n`table.grant()` method.\n\n```python\nuser = user(self, \"user\",\n    cluster=cluster,\n    database_name=\"databasename\"\n)\ntable = table(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\"), column(name=\"col2\", data_type=\"float\")],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\n\ntable.grant(user, tableaction.drop, tableaction.select)\n```\n\ntake care when managing privileges via the cdk, as attempting to manage a user's\nprivileges on the same table in multiple cdk applications could lead to accidentally\noverriding these permissions. consider the following two cdk applications which both refer\nto the same user and table. in application 1, the resources are created and the user is\ngiven `insert` permissions on the table:\n\n```python\ndatabase_name = \"databasename\"\nusername = \"myuser\"\ntable_name = \"mytable\"\n\nuser = user(self, \"user\",\n    username=username,\n    cluster=cluster,\n    database_name=database_name\n)\ntable = table(self, \"table\",\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\"), column(name=\"col2\", data_type=\"float\")],\n    cluster=cluster,\n    database_name=database_name\n)\ntable.grant(user, tableaction.insert)\n```\n\nin application 2, the resources are imported and the user is given `insert` permissions on\nthe table:\n\n```python\ndatabase_name = \"databasename\"\nusername = \"myuser\"\ntable_name = \"mytable\"\n\nuser = user.from_user_attributes(self, \"user\",\n    username=username,\n    password=secretvalue.unsafe_plain_text(\"not_for_production\"),\n    cluster=cluster,\n    database_name=database_name\n)\ntable = table.from_table_attributes(self, \"table\",\n    table_name=table_name,\n    table_columns=[column(name=\"col1\", data_type=\"varchar(4)\"), column(name=\"col2\", data_type=\"float\")],\n    cluster=cluster,\n    database_name=\"databasename\"\n)\ntable.grant(user, tableaction.insert)\n```\n\nboth applications attempt to grant the user the appropriate privilege on the table by\nsubmitting a `grant user` sql query to the redshift cluster. note that the latter of these\ntwo calls will have no effect since the user has already been granted the privilege.\n\nnow, if application 1 were to remove the call to `grant`, a `revoke user` sql query is\nsubmitted to the redshift cluster. in general, application 1 does not know that\napplication 2 has also granted this permission and thus cannot decide not to issue the\nrevocation. this leads to the undesirable state where application 2 still contains the\ncall to `grant` but the user does not have the specified permission.\n\nnote that this does not occur when duplicate privileges are granted within the same\napplication, as such privileges are de-duplicated before any sql query is submitted.\n\n## rotating credentials\n\nwhen the master password is generated and stored in aws secrets manager, it can be rotated automatically:\n\n```python\ncluster.add_rotation_single_user()\n```\n\nthe multi user rotation scheme is also available:\n\n```python\nuser = user(self, \"user\",\n    cluster=cluster,\n    database_name=\"databasename\"\n)\ncluster.add_rotation_multi_user(\"multiuserrotation\",\n    secret=user.secret\n)\n```\n\n## adding parameters\n\nyou can add a parameter to a parameter group with`clusterparametergroup.addparameter()`.\n\n```python\nfrom aws_cdk.aws_redshift_alpha import clusterparametergroup\n\n\nparams = clusterparametergroup(self, \"params\",\n    description=\"desc\",\n    parameters={\n        \"require_ssl\": \"true\"\n    }\n)\n\nparams.add_parameter(\"enable_user_activity_logging\", \"true\")\n```\n\nadditionally, you can add a parameter to the cluster's associated parameter group with `cluster.addtoparametergroup()`. if the cluster does not have an associated parameter group, a new parameter group is created.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk as cdk\n# vpc: ec2.vpc\n\n\ncluster = cluster(self, \"cluster\",\n    master_user=login(\n        master_username=\"admin\",\n        master_password=cdk.secretvalue.unsafe_plain_text(\"tooshort\")\n    ),\n    vpc=vpc\n)\n\ncluster.add_to_parameter_group(\"enable_user_activity_logging\", \"true\")\n```\n\n## rebooting for parameter updates\n\nin most cases, existing clusters [must be manually rebooted](https://docs.aws.amazon.com/redshift/latest/mgmt/working-with-parameter-groups.html) to apply parameter changes. you can automate parameter related reboots by setting the cluster's `rebootforparameterchanges` property to `true` , or by using `cluster.enablerebootforparameterchanges()`.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk as cdk\n# vpc: ec2.vpc\n\n\ncluster = cluster(self, \"cluster\",\n    master_user=login(\n        master_username=\"admin\",\n        master_password=cdk.secretvalue.unsafe_plain_text(\"tooshort\")\n    ),\n    vpc=vpc\n)\n\ncluster.add_to_parameter_group(\"enable_user_activity_logging\", \"true\")\ncluster.enable_reboot_for_parameter_changes()\n```\n\n## elastic ip\n\nif you configure your cluster to be publicly accessible, you can optionally select an *elastic ip address* to use for the external ip address. an elastic ip address is a static ip address that is associated with your aws account. you can use an elastic ip address to connect to your cluster from outside the vpc. an elastic ip address gives you the ability to change your underlying configuration without affecting the ip address that clients use to connect to your cluster. this approach can be helpful for situations such as recovery after a failure.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk as cdk\n# vpc: ec2.vpc\n\n\ncluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\",\n        master_password=cdk.secretvalue.unsafe_plain_text(\"tooshort\")\n    ),\n    vpc=vpc,\n    publicly_accessible=true,\n    elastic_ip=\"10.123.123.255\"\n)\n```\n\nif the cluster is in a vpc and you want to connect to it using the private ip address from within the cluster, it is important to enable *dns resolution* and *dns hostnames* in the vpc config. if these parameters would not be set, connections from within the vpc would connect to the elastic ip address and not the private ip address.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\n\nvpc = ec2.vpc(self, \"vpc\",\n    enable_dns_support=true,\n    enable_dns_hostnames=true\n)\n```\n\nnote that if there is already an existing, public accessible cluster, which vpc configuration is changed to use *dns hostnames* and *dns resolution*, connections still use the elastic ip address until the cluster is resized.\n\n### elastic ip vs. cluster node public ip\n\nthe elastic ip address is an external ip address for accessing the cluster outside of a vpc. it's not related to the cluster node public ip addresses and private ip addresses that are accessible via the `clusterendpoint` property. the public and private cluster node ip addresses appear regardless of whether the cluster is publicly accessible or not. they are used only in certain circumstances to configure ingress rules on the remote host. these circumstances occur when you load data from an amazon ec2 instance or other remote host using a secure shell (ssh) connection.\n\n### attach elastic ip after cluster creation\n\nin some cases, you might want to associate the cluster with an elastic ip address or change an elastic ip address that is associated with the cluster. to attach an elastic ip address after the cluster is created, first update the cluster so that it is not publicly accessible, then make it both publicly accessible and add an elastic ip address in the same operation.\n\n## enhanced vpc routing\n\nwhen you use amazon redshift enhanced vpc routing, amazon redshift forces all copy and unload traffic between your cluster and your data repositories through your virtual private cloud (vpc) based on the amazon vpc service. by using enhanced vpc routing, you can use standard vpc features, such as vpc security groups, network access control lists (acls), vpc endpoints, vpc endpoint policies, internet gateways, and domain name system (dns) servers, as described in the amazon vpc user guide. you use these features to tightly manage the flow of data between your amazon redshift cluster and other resources. when you use enhanced vpc routing to route traffic through your vpc, you can also use vpc flow logs to monitor copy and unload traffic.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk as cdk\n# vpc: ec2.vpc\n\n\ncluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\",\n        master_password=cdk.secretvalue.unsafe_plain_text(\"tooshort\")\n    ),\n    vpc=vpc,\n    enhanced_vpc_routing=true\n)\n```\n\nif enhanced vpc routing is not enabled, amazon redshift routes traffic through the internet, including traffic to other services within the aws network.\n\n## default iam role\n\nsome amazon redshift features require amazon redshift to access other aws services on your behalf. for your amazon redshift clusters to act on your behalf, you supply security credentials to your clusters. the preferred method to supply security credentials is to specify an aws identity and access management (iam) role.\n\nwhen you create an iam role and set it as the default for the cluster using console, you don't have to provide the iam role's amazon resource name (arn) to perform authentication and authorization.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk.aws_iam as iam\n# vpc: ec2.vpc\n\n\ndefault_role = iam.role(self, \"defaultrole\",\n    assumed_by=iam.serviceprincipal(\"redshift.amazonaws.com\")\n)\n\ncluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc,\n    roles=[default_role],\n    default_role=default_role\n)\n```\n\na default role can also be added to a cluster using the `adddefaultiamrole` method.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk.aws_iam as iam\n# vpc: ec2.vpc\n\n\ndefault_role = iam.role(self, \"defaultrole\",\n    assumed_by=iam.serviceprincipal(\"redshift.amazonaws.com\")\n)\n\nredshift_cluster = cluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc,\n    roles=[default_role]\n)\n\nredshift_cluster.add_default_iam_role(default_role)\n```\n\n## iam roles\n\nattaching iam roles to a redshift cluster grants permissions to the redshift service to perform actions on your behalf.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk.aws_iam as iam\n# vpc: ec2.vpc\n\n\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"redshift.amazonaws.com\")\n)\ncluster = cluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc,\n    roles=[role]\n)\n```\n\nadditional iam roles can be attached to a cluster using the `addiamrole` method.\n\n```python\nimport aws_cdk.aws_ec2 as ec2\nimport aws_cdk.aws_iam as iam\n# vpc: ec2.vpc\n\n\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"redshift.amazonaws.com\")\n)\ncluster = cluster(self, \"redshift\",\n    master_user=login(\n        master_username=\"admin\"\n    ),\n    vpc=vpc\n)\ncluster.add_iam_role(role)\n```\n\n## resizing\n\nas your data warehousing needs change, it's possible to resize your redshift cluster. if the cluster was deployed via cdk,\nit's important to resize it via cdk so the change is registered in the aws cloudformation template.\nthere are two types of resize operations:\n\n* elastic resize - number of nodes and node type can be changed, but not at the same time. elastic resize is the default behavior,\n  as it's a fast operation and typically completes in minutes. elastic resize is only supported on clusters of the following types:\n\n  * dc1.large (if your cluster is in a vpc)\n  * dc1.8xlarge (if your cluster is in a vpc)\n  * dc2.large\n  * dc2.8xlarge\n  * ds2.xlarge\n  * ds2.8xlarge\n  * ra3.xlplus\n  * ra3.4xlarge\n  * ra3.16xlarge\n* classic resize - number of nodes, node type, or both, can be changed. this operation takes longer to complete,\n  but is useful when the resize operation doesn't meet the criteria of an elastic resize. if you prefer classic resizing,\n  you can set the `classicresizing` flag when creating the cluster.\n\nthere are other constraints to be aware of, for example, elastic resizing does not support single-node clusters and there are\nlimits on the number of nodes you can add to a cluster. see the [aws redshift documentation](https://docs.aws.amazon.com/redshift/latest/mgmt/managing-cluster-operations.html#rs-resize-tutorial) and [aws api documentation](https://docs.aws.amazon.com/redshift/latest/apireference/api_resizecluster.html) for more details.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-redshift-alpha",
  "package_url": "https://pypi.org/project/aws-cdk.aws-redshift-alpha/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-redshift-alpha/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-redshift-alpha/2.116.1a0/",
  "requires_dist": [
    "aws-cdk-lib <3.0.0,>=2.116.1",
    "constructs <11.0.0,>=10.0.0",
    "jsii <2.0.0,>=1.93.0",
    "publication >=0.0.3",
    "typeguard ~=2.13.3"
  ],
  "requires_python": "~=3.8",
  "summary": "the cdk construct library for aws::redshift",
  "version": "2.116.1a0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "redshift_cluster aws_redshift_alpha aws_cdk cdk_aws redshift",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_redshift_alpha",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 172,
  "dependency_ids": [
    "pypi_aws_cdk_lib",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}