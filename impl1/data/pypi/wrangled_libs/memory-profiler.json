{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development"
  ],
  "description": ".. image:: https://travis-ci.org/pythonprofilers/memory_profiler.svg?branch=master\n    :target: https://travis-ci.org/pythonprofilers/memory_profiler\n\n=================\n memory profiler\n=================\n\n\n**note:** this package is no longer actively maintained. i won't be actively responding to issues. if you'd like to volunteer to maintain it, please drop me a line at f@bianp.net\n\nthis is a python module for monitoring memory consumption of a process\nas well as line-by-line analysis of memory consumption for python\nprograms. it is a pure python module which depends on the `psutil\n<http://pypi.python.org/pypi/psutil>`_ module.\n\n\n==============\n installation\n==============\ninstall via pip::\n\n    $ pip install -u memory_profiler\n\nthe package is also available on `conda-forge\n<https://github.com/conda-forge/memory_profiler-feedstock>`_.\n\nto install from source, download the package, extract and type::\n\n    $ pip install .\n\n===========\nquick start\n===========\n\nuse `mprof` to generate a full memory usage report of your executable and to plot it.\n\n.. code-block:: bash\n\n    mprof run executable\n    mprof plot\n\nthe plot would be something like this:\n\n.. image:: https://i.stack.imgur.com/ixch4.png\n\n=======\n usage\n=======\n\n\nline-by-line memory usage\n=========================\n\nthe line-by-line memory usage mode is used much in the same way of the\n`line_profiler <https://pypi.python.org/pypi/line_profiler/>`_: first\ndecorate the function you would like to profile with ``@profile`` and\nthen run the script with a special script (in this case with specific\narguments to the python interpreter).\n\nin the following example, we create a simple function ``my_func`` that\nallocates lists ``a``, ``b`` and then deletes ``b``::\n\n\n    @profile\n    def my_func():\n        a = [1] * (10 ** 6)\n        b = [2] * (2 * 10 ** 7)\n        del b\n        return a\n\n    if __name__ == '__main__':\n        my_func()\n\n\nexecute the code passing the option ``-m memory_profiler`` to the\npython interpreter to load the memory_profiler module and print to\nstdout the line-by-line analysis. if the file name was example.py,\nthis would result in::\n\n    $ python -m memory_profiler example.py\n\noutput will follow::\n\n    line #    mem usage    increment  occurrences   line contents\n    ============================================================\n         3   38.816 mib   38.816 mib           1   @profile\n         4                                         def my_func():\n         5   46.492 mib    7.676 mib           1       a = [1] * (10 ** 6)\n         6  199.117 mib  152.625 mib           1       b = [2] * (2 * 10 ** 7)\n         7   46.629 mib -152.488 mib           1       del b\n         8   46.629 mib    0.000 mib           1       return a\n\n\nthe first column represents the line number of the code that has been\nprofiled, the second column (*mem usage*) the memory usage of the\npython interpreter after that line has been executed. the third column\n(*increment*) represents the difference in memory of the current line\nwith respect to the last one. the last column (*line contents*) prints\nthe code that has been profiled.\n\ndecorator\n=========\na function decorator is also available.  use as follows::\n\n    from memory_profiler import profile\n\n    @profile\n    def my_func():\n        a = [1] * (10 ** 6)\n        b = [2] * (2 * 10 ** 7)\n        del b\n        return a\n\nin this case the script can be run without specifying ``-m\nmemory_profiler`` in the command line.\n\nin function decorator, you can specify the precision as an argument to the\ndecorator function.  use as follows::\n\n    from memory_profiler import profile\n\n    @profile(precision=4)\n    def my_func():\n        a = [1] * (10 ** 6)\n        b = [2] * (2 * 10 ** 7)\n        del b\n        return a\n\nif a python script with decorator ``@profile`` is called using ``-m\nmemory_profiler`` in the command line, the ``precision`` parameter is ignored.\n\ntime-based memory usage\n==========================\nsometimes it is useful to have full memory usage reports as a function of\ntime (not line-by-line) of external processes (be it python scripts or not).\nin this case the executable ``mprof`` might be useful. use it like::\n\n    mprof run <executable>\n    mprof plot\n\nthe first line run the executable and record memory usage along time,\nin a file written in the current directory.\nonce it's done, a graph plot can be obtained using the second line.\nthe recorded file contains a timestamps, that allows for several\nprofiles to be kept at the same time.\n\nhelp on each `mprof` subcommand can be obtained with the `-h` flag,\ne.g. `mprof run -h`.\n\nin the case of a python script, using the previous command does not\ngive you any information on which function is executed at a given\ntime. depending on the case, it can be difficult to identify the part\nof the code that is causing the highest memory usage.\n\nadding the `profile` decorator to a function(ensure no \n`from memory_profiler import profile` statement) and running the python\nscript with\n\n    mprof run --python python <script>\n\nwill record timestamps when entering/leaving the profiled function. running\n\n    mprof plot\n\nafterward will plot the result, making plots (using matplotlib) similar to these:\n\n.. image:: https://camo.githubusercontent.com/3a584c7cfbae38c9220a755aa21b5ef926c1031d/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313930383631382f3836313332302f63623865376337382d663563632d313165322d386531652d3539373237623636663462322e706e67\n   :target: https://github.com/scikit-learn/scikit-learn/pull/2248\n   :height: 350px\n\nor, with ``mprof plot --flame`` (the function and timestamp names will appear on hover):\n\n.. image:: ./images/flamegraph.png\n   :height: 350px\n\na discussion of these capabilities can be found `here <http://fa.bianp.net/blog/2014/plot-memory-usage-as-a-function-of-time/>`_.\n\n.. warning:: if your python file imports the memory profiler `from memory_profiler import profile` these timestamps will not be recorded. comment out the import, leave your functions decorated, and re-run.\n\nthe available commands for `mprof` are:\n\n  - ``mprof run``: running an executable, recording memory usage\n  - ``mprof plot``: plotting one the recorded memory usage (by default,\n    the last one)\n  - ``mprof list``: listing all recorded memory usage files in a\n    user-friendly way.\n  - ``mprof clean``: removing all recorded memory usage files.\n  - ``mprof rm``: removing specific recorded memory usage files\n\ntracking forked child processes\n===============================\nin a multiprocessing context the main process will spawn child processes whose\nsystem resources are allocated separately from the parent process. this can\nlead to an inaccurate report of memory usage since by default only the parent\nprocess is being tracked. the ``mprof`` utility provides two mechanisms to\ntrack the usage of child processes: sum the memory of all children to the\nparent's usage and track each child individual.\n\nto create a report that combines memory usage of all the children and the\nparent, use the ``include-children`` flag in either the ``profile`` decorator or\nas a command line argument to ``mprof``::\n\n    mprof run --include-children <script>\n\nthe second method tracks each child independently of the main process,\nserializing child rows by index to the output stream. use the ``multiprocess``\nflag and plot as follows::\n\n    mprof run --multiprocess <script>\n    mprof plot\n\nthis will create a plot using matplotlib similar to this:\n\n.. image:: https://cloud.githubusercontent.com/assets/745966/24075879/2e85b43a-0bfa-11e7-8dfe-654320dbd2ce.png\n    :target: https://github.com/pythonprofilers/memory_profiler/pull/134\n    :height: 350px\n\nyou can combine both the ``include-children`` and ``multiprocess`` flags to show\nthe total memory of the program as well as each child individually. if using\nthe api directly, note that the return from ``memory_usage`` will include the\nchild memory in a nested list along with the main process memory.\n\nplot settings\n===============================\n\nby default, the command line call is set as the graph title. if you wish to customize it, you can use the ``-t`` option to manually set the figure title.\n\n\n    mprof plot -t 'recorded memory usage'\n\nyou can also hide the function timestamps using the ``n`` flag, such as\n\n    mprof plot -n\n\ntrend lines and its numeric slope can be plotted using the ``s`` flag, such as\n\n    mprof plot -s\n\n.. image:: ./images/trend_slope.png\n   :height: 350px\n\nthe intended usage of the -s switch is to check the labels' numerical slope over a significant time period for : \n\n  - ``>0`` it might mean a memory leak.\n  - ``~0`` if 0 or near 0, the memory usage may be considered stable.\n  - ``<0`` to be interpreted depending on the expected process memory usage patterns, also might mean that the sampling period is too small.\n\nthe trend lines are for ilustrative purposes and are plotted as (very) small dashed lines.\n\n\nsetting debugger breakpoints\n=============================\nit is possible to set breakpoints depending on the amount of memory used.\nthat is, you can specify a threshold and as soon as the program uses more\nmemory than what is specified in the threshold it will stop execution\nand run into the pdb debugger. to use it, you will have to decorate\nthe function as done in the previous section with ``@profile`` and then\nrun your script with the option ``-m memory_profiler --pdb-mmem=x``,\nwhere x is a number representing the memory threshold in mb. for example::\n\n    $ python -m memory_profiler --pdb-mmem=100 my_script.py\n\nwill run ``my_script.py`` and step into the pdb debugger as soon as the code\nuses more than 100 mb in the decorated function.\n\n.. todo: alternatives to decoration (for example when you don't want to modify\n    the file where your function lives).\n\n=====\n api\n=====\nmemory_profiler exposes a number of functions to be used in third-party\ncode.\n\n\n\n``memory_usage(proc=-1, interval=.1, timeout=none)`` returns the memory usage\nover a time interval. the first argument, ``proc`` represents what\nshould be monitored.  this can either be the pid of a process (not\nnecessarily a python program), a string containing some python code to\nbe evaluated or a tuple ``(f, args, kw)`` containing a function and its\narguments to be evaluated as ``f(*args, **kw)``. for example,\n\n\n    >>> from memory_profiler import memory_usage\n    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1)\n    >>> print(mem_usage)\n\t[7.296875, 7.296875, 7.296875, 7.296875, 7.296875]\n\n\nhere i've told memory_profiler to get the memory consumption of the\ncurrent process over a period of 1 second with a time interval of 0.2\nseconds. as pid i've given it -1, which is a special number (pids are\nusually positive) that means current process, that is, i'm getting the\nmemory usage of the current python interpreter. thus i'm getting\naround 7mb of memory usage from a plain python interpreter. if i try\nthe same thing on ipython (console) i get 29mb, and if i try the same\nthing on the ipython notebook it scales up to 44mb.\n\n\nif you'd like to get the memory consumption of a python function, then\nyou should specify the function and its arguments in the tuple ``(f,\nargs, kw)``. for example::\n\n\n    >>> # define a simple function\n    >>> def f(a, n=100):\n        ...     import time\n        ...     time.sleep(2)\n        ...     b = [a] * n\n        ...     time.sleep(1)\n        ...     return b\n        ...\n    >>> from memory_profiler import memory_usage\n    >>> memory_usage((f, (1,), {'n' : int(1e6)}))\n\nthis will execute the code `f(1, n=int(1e6))` and return the memory\nconsumption during this execution.\n\n=========\nreporting\n=========\n\nthe output can be redirected to a log file by passing io stream as\nparameter to the decorator like @profile(stream=fp)\n\n    >>> fp=open('memory_profiler.log','w+')\n    >>> @profile(stream=fp)\n    >>> def my_func():\n        ...     a = [1] * (10 ** 6)\n        ...     b = [2] * (2 * 10 ** 7)\n        ...     del b\n        ...     return a\n\n    for details refer: examples/reporting_file.py\n\n``reporting via logger module:``\n\nsometime it would be very convenient to use logger module specially\nwhen we need to use rotatingfilehandler.\n\nthe output can be redirected to logger module by simply making use of\nlogfile of memory profiler module.\n\n    >>> from memory_profiler import logfile\n    >>> import sys\n    >>> sys.stdout = logfile('memory_profile_log')\n\n``customized reporting:``\n\nsending everything to the log file while running the memory_profiler\ncould be cumbersome and one can choose only entries with increments\nby passing true to reportincrementflag, where reportincrementflag is\na parameter to logfile class of memory profiler module.\n\n    >>> from memory_profiler import logfile\n    >>> import sys\n    >>> sys.stdout = logfile('memory_profile_log', reportincrementflag=false)\n\n    for details refer: examples/reporting_logger.py\n\n=====================\n ipython integration\n=====================\nafter installing the module, if you use ipython, you can use the `%mprun`, `%%mprun`,\n`%memit` and `%%memit` magics.\n\nfor ipython 0.11+, you can use the module directly as an extension, with\n``%load_ext memory_profiler``\n\nto activate it whenever you start ipython, edit the configuration file for your\nipython profile, ~/.ipython/profile_default/ipython_config.py, to register the\nextension like this (if you already have other extensions, just add this one to\nthe list)::\n\n    c.interactiveshellapp.extensions = [\n        'memory_profiler',\n    ]\n\n(if the config file doesn't already exist, run ``ipython profile create`` in\na terminal.)\n\nit then can be used directly from ipython to obtain a line-by-line\nreport using the `%mprun` or `%%mprun` magic command. in this case, you can skip\nthe `@profile` decorator and instead use the `-f` parameter, like\nthis. note however that function my_func must be defined in a file\n(cannot have been defined interactively in the python interpreter)::\n\n    in [1]: from example import my_func, my_func_2\n\n    in [2]: %mprun -f my_func my_func()\n\nor in cell mode::\n\n    in [3]: %%mprun -f my_func -f my_func_2\n       ...: my_func()\n       ...: my_func_2()\n\nanother useful magic that we define is `%memit`, which is analogous to\n`%timeit`. it can be used as follows::\n\n    in [1]: %memit range(10000)\n    peak memory: 21.42 mib, increment: 0.41 mib\n\n    in [2]: %memit range(1000000)\n    peak memory: 52.10 mib, increment: 31.08 mib\n\nor in cell mode (with setup code)::\n\n    in [3]: %%memit l=range(1000000)\n       ...: len(l)\n       ...:\n    peak memory: 52.14 mib, increment: 0.08 mib\n\nfor more details, see the docstrings of the magics.\n\nfor ipython 0.10, you can install it by editing the ipython configuration\nfile ~/.ipython/ipy_user_conf.py to add the following lines::\n\n    # these two lines are standard and probably already there.\n    import ipython.ipapi\n    ip = ipython.ipapi.get()\n\n    # these two are the important ones.\n    import memory_profiler\n    memory_profiler.load_ipython_extension(ip)\n\n===============================\nmemory tracking backends\n===============================\n`memory_profiler` supports different memory tracking backends including: 'psutil', 'psutil_pss', 'psutil_uss', 'posix', 'tracemalloc'.\nif no specific backend is specified the default is to use \"psutil\" which measures rss aka \"resident set size\". \nin some cases (particularly when tracking child processes) rss may overestimate memory usage (see `example/example_psutil_memory_full_info.py` for an example).\nfor more information on \"psutil_pss\" (measuring pss) and \"psutil_uss\" please refer to:\nhttps://psutil.readthedocs.io/en/latest/index.html?highlight=memory_info#psutil.process.memory_full_info \n\ncurrently, the backend can be set via the cli\n\n    $ python -m memory_profiler --backend psutil my_script.py\n\nand is exposed by the api\n\n    >>> from memory_profiler import memory_usage\n    >>> mem_usage = memory_usage(-1, interval=.2, timeout=1, backend=\"psutil\")\n\n    \n============================\n frequently asked questions\n============================\n    * q: how accurate are the results ?\n    * a: this module gets the memory consumption by querying the\n      operating system kernel about the amount of memory the current\n      process has allocated, which might be slightly different from\n      the amount of memory that is actually used by the python\n      interpreter. also, because of how the garbage collector works in\n      python the result might be different between platforms and even\n      between runs.\n\n    * q: does it work under windows ?\n    * a: yes, thanks to the\n      `psutil <http://pypi.python.org/pypi/psutil>`_ module.\n\n\n===========================\n support, bugs & wish list\n===========================\nfor support, please ask your question on `stack overflow\n<http://stackoverflow.com/>`_ and add the `*memory-profiling* tag <http://stackoverflow.com/questions/tagged/memory-profiling>`_.\nsend issues, proposals, etc. to `github's issue tracker\n<https://github.com/pythonprofilers/memory_profiler/issues>`_ .\n\nif you've got questions regarding development, you can email me\ndirectly at f@bianp.net\n\n.. image:: http://fa.bianp.net/static/tux_memory_small.png\n\n\n=============\n development\n=============\nlatest sources are available from github:\n\n    https://github.com/pythonprofilers/memory_profiler\n\n===============================\nprojects using memory_profiler\n===============================\n\n`benchy <https://github.com/python-recsys/benchy>`_\n\n`ipython memory usage <https://github.com/ianozsvald/ipython_memory_usage>`_\n\n`pyspeedit <https://github.com/peter1000/pyspeedit>`_ (uses a reduced version of memory_profiler)\n\n`pydio-sync <https://github.com/pydio/pydio-sync>`_ (uses custom wrapper on top of memory_profiler)\n\n=========\n authors\n=========\nthis module was written by `fabian pedregosa <http://fseoane.net>`_\nand `philippe gervais <https://github.com/pgervais>`_\ninspired by robert kern's `line profiler\n<http://packages.python.org/line_profiler/>`_.\n\n`tom <http://tomforb.es/>`_ added windows support and speed improvements via the\n`psutil <http://pypi.python.org/pypi/psutil>`_ module.\n\n`victor <https://github.com/octavo>`_ added python3 support, bugfixes and general\ncleanup.\n\n`vlad niculae <http://vene.ro/>`_ added the `%mprun` and `%memit` ipython magics.\n\n`thomas kluyver <https://github.com/takluyver>`_ added the ipython extension.\n\n`sagar uday kumar <https://github.com/sagaru>`_ added report generation feature and examples.\n\n`dmitriy novozhilov <https://github.com/demiurg906>`_ and `sergei lebedev <https://github.com/superbobry>`_ added support for `tracemalloc <https://docs.python.org/3/library/tracemalloc.html>`_.\n\n`benjamin bengfort <https://github.com/bbengfort>`_ added support for tracking the usage of individual child processes and plotting them.\n\n`muhammad haseeb tariq <https://github.com/mhaseebtariq>`_ fixed issue #152, which made the whole interpreter hang on functions that launched an exception.\n\n`juan luis cano <https://github.com/juanlu001>`_ modernized the infrastructure and helped with various things.\n\n`martin becker <https://github.com/mgbckr>`_ added pss and uss tracking via the psutil backend.\n\n=========\n license\n=========\nbsd license, see file copying for full text.\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "memory-profiler",
  "package_url": "https://pypi.org/project/memory-profiler/",
  "project_url": "https://pypi.org/project/memory-profiler/",
  "project_urls": {
    "Homepage": "https://github.com/pythonprofilers/memory_profiler"
  },
  "release_url": "https://pypi.org/project/memory-profiler/0.61.0/",
  "requires_dist": [
    "psutil"
  ],
  "requires_python": ">=3.5",
  "summary": "a module for monitoring memory usage of a python program",
  "version": "0.61.0",
  "releases": [],
  "developers": [
    "f@bianp.net",
    "fabian_pedregosa"
  ],
  "kwds": "memory_profiler memory_profile_log ipython_memory_usage memory_usage memory_info",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_memory_profiler",
  "homepage": "https://github.com/pythonprofilers/memory_profiler",
  "release_count": 58,
  "dependency_ids": [
    "pypi_psutil"
  ]
}