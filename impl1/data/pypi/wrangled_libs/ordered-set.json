{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "[![pypi](https://img.shields.io/pypi/v/ordered-set.svg)](https://pypi.python.org/pypi/ordered-set)\n\nan orderedset is a mutable data structure that is a hybrid of a list and a set.\nit remembers the order of its entries, and every entry has an index number that\ncan be looked up.\n\n## installation\n\n`ordered_set` is available on pypi and packaged as a wheel. you can list it\nas a dependency of your project, in whatever form that takes.\n\nto install it into your current python environment:\n\n    pip install ordered-set\n\nto install the code for development, after checking out the repository:\n\n    pip install flit\n    flit install\n\n## usage examples\n\nan orderedset is created and used like a set:\n\n    >>> from ordered_set import orderedset\n\n    >>> letters = orderedset('abracadabra')\n\n    >>> letters\n    orderedset(['a', 'b', 'r', 'c', 'd'])\n\n    >>> 'r' in letters\n    true\n\nit is efficient to find the index of an entry in an orderedset, or find an\nentry by its index. to help with this use case, the `.add()` method returns\nthe index of the added item, whether it was already in the set or not.\n\n    >>> letters.index('r')\n    2\n\n    >>> letters[2]\n    'r'\n\n    >>> letters.add('r')\n    2\n\n    >>> letters.add('x')\n    5\n\norderedsets implement the union (`|`), intersection (`&`), and difference (`-`)\noperators like sets do.\n\n    >>> letters |= orderedset('shazam')\n\n    >>> letters\n    orderedset(['a', 'b', 'r', 'c', 'd', 'x', 's', 'h', 'z', 'm'])\n\n    >>> letters & set('aeiou')\n    orderedset(['a'])\n\n    >>> letters -= 'abcd'\n\n    >>> letters\n    orderedset(['r', 'x', 's', 'h', 'z', 'm'])\n\nthe `__getitem__()` and `index()` methods have been extended to accept any\niterable except a string, returning a list, to perform numpy-like \"fancy\nindexing\".\n\n    >>> letters = orderedset('abracadabra')\n\n    >>> letters[[0, 2, 3]]\n    ['a', 'r', 'c']\n\n    >>> letters.index(['a', 'r', 'c'])\n    [0, 2, 3]\n\norderedset implements `__getstate__` and `__setstate__` so it can be pickled,\nand implements the abstract base classes `collections.mutableset` and\n`collections.sequence`.\n\norderedset can be used as a generic collection type, similar to the collections\nin the `typing` module like list, dict, and set. for example, you can annotate\na variable as having the type `orderedset[str]` or `orderedset[tuple[int,\nstr]]`.\n\n\n## orderedset in data science applications\n\nan orderedset can be used as a bi-directional mapping between a sparse\nvocabulary and dense index numbers. as of version 3.1, it accepts numpy arrays\nof index numbers as well as lists.\n\nthis combination of features makes orderedset a simple implementation of many\nof the things that `pandas.index` is used for, and many of its operations are\nfaster than the equivalent pandas operations.\n\nfor further compatibility with pandas.index, `get_loc` (the pandas method for\nlooking up a single index) and `get_indexer` (the pandas method for fancy\nindexing in reverse) are both aliases for `index` (which handles both cases\nin orderedset).\n\n\n## authors\n\norderedset was implemented by elia robyn lake (maiden name: robyn speer).\njon crall contributed changes and tests to make it fit the python set api.\nroman inflianskas added the original type annotations.\n\n\n## comparisons\n\nthe original implementation of orderedset was a [recipe posted to activestate\nrecipes][recipe] by raymond hettiger, released under the mit license.\n\n[recipe]: https://code.activestate.com/recipes/576694-orderedset/\n\nhettiger's implementation kept its content in a doubly-linked list referenced by a\ndict. as a result, looking up an item by its index was an o(n) operation, while\ndeletion was o(1).\n\nthis version makes different trade-offs for the sake of efficient lookups. its\ncontent is a standard python list instead of a doubly-linked list. this\nprovides o(1) lookups by index at the expense of o(n) deletion, as well as\nslightly faster iteration.\n\nin python 3.6 and later, the built-in `dict` type is inherently ordered. if you\nignore the dictionary values, that also gives you a simple ordered set, with\nfast o(1) insertion, deletion, iteration and membership testing. however, `dict`\ndoes not provide the list-like random access features of orderedset. you\nwould have to convert it to a list in o(n) to look up the index of an entry or\nlook up an entry by its index.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "ordered-set",
  "package_url": "https://pypi.org/project/ordered-set/",
  "project_url": "https://pypi.org/project/ordered-set/",
  "project_urls": {
    "Home": "https://github.com/rspeer/ordered-set"
  },
  "release_url": "https://pypi.org/project/ordered-set/4.1.0/",
  "requires_dist": [
    "pytest ; extra == \"dev\"",
    "black ; extra == \"dev\"",
    "mypy ; extra == \"dev\""
  ],
  "requires_python": ">=3.7",
  "summary": "an orderedset is a custom mutableset that remembers its order, so that every",
  "version": "4.1.0",
  "releases": [],
  "developers": [
    "gh@arborelia.net"
  ],
  "kwds": "ordered_set orderedsets python orderedset pip",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_ordered_set",
  "homepage": "",
  "release_count": 18,
  "dependency_ids": [
    "pypi_black",
    "pypi_mypy",
    "pypi_pytest"
  ]
}