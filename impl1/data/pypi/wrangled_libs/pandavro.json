{
  "classifiers": [],
  "description": "# pandavro\n\n[![python package](https://github.com/ynqa/pandavro/actions/workflows/python-package.yml/badge.svg)](https://github.com/ynqa/pandavro/actions/workflows/python-package.yml)\n\nthe interface between apache avro and pandas dataframe.\n\n## installation\n\n`pandavro` is available to install from [pypi](https://pypi.org/project/pandavro/).\n\n```bash\n$ pip install pandavro\n```\n\n## description\n\nit prepares like pandas apis:\n\n- `read_avro`\n    - read the records from avro file and fit them into pandas dataframe using [fastavro](https://github.com/tebeka/fastavro).\n- `to_avro`\n    - write the rows of pandas dataframe to avro file with the original schema infer.\n\n## what can and can't pandavro do?\n\navro can represent the following kinds of types:\n- primitive types (`null`, `bool`, `int` etc.)\n- complex types (records, arrays, maps etc.)\n- logical types (annotated primitive/complex type to represent e.g. datetime)\n\nwhen converting to avro, pandavro will try to infer the schema. it will output a non-nested schema *without any indexes* set on the dataframe and it will also not try to infer if any column can be nullable so *all columns are set as nullable*, i.e. a boolean will be encoded in avro schema as `['null', 'bool']`.\n\npandavro can handle these primitive types:\n\n| numpy/pandas type                             | avro primitive type |\n|-----------------------------------------------|---------------------|\n| np.bool_                                      | boolean             |\n| np.float32                                    | float               |\n| np.float64                                    | double              |\n| np.unicode_                                   | string              |\n| np.object_                                    | string              |\n| np.int8, np.int16, np.int32                   | int                 |\n| np.uint8, np.uint16, np.uint32                | \"unsigned\" int*     |\n| np.uint64                                     | \"unsigned\" long*    |\n| np.int64, pd.int64dtype                       | long                |\n| pd.int8dtype, pd.int16dtype, pd.int32dtype    | int                 |\n| pd.uint8dtype, pd.uint16dtype, pd.uint32dtype | \"unsigned\" int*     |\n| pd.stringdtype**                              | string              |\n| pd.booleandtype**                             | boolean             |\n\n\\* we represent the unsigned versions of these integers by adding the non-standard \"unsigned\" flag as such: `{'type': 'int', 'unsigned': true}`.  pandas 0.24 added support for nullable integers. writing `pd.uint64dtype` is not supported by fastavro.\n\n\\** pandas 1.0.0 added support for nullable string and boolean datatypes.\n\npandavro also supports these logical types:\n\n| numpy/pandas type                               | avro logical type  |\n|-------------------------------------------------|--------------------|\n| np.datetime64, pd.datetimetzdtype, pd.timestamp | timestamp-micros*  |\nif a boolean column includes empty values, pandas classifies the column as having a dtype of `object` - this is accounted for in complex column handling.\n\n\nand these complex types - all complex types other than 'fixed' will be classified by pandas as having a dtype of `object`, so their underlying python types are used to determine the avro type:\n\n| numpy/python type             | avro complex type |\n|-------------------------------|-------------------|\n| dict, collections.ordereddict | record            |\n| list                          | array             |\n| np.void                       | fixed             |\n\nrecord and array types can be arbitrarily nested within each other.\n\nthe schema definition of a record requires a unique name for the record separate from the column itself. this does not map to any concept in pandas, so for this we just append '_record' to the original column name and a number to ensure that there are zero duplicate 'name' values.\n\nthe remaining avro complex types are not currently supported for the following reasons:\n1. enum: the closest pandas type to avro's enum type is `pd.categorical`, but it still is not a complete match. possible values of the enum type can only be alphanumeric strings, whereas `pd.categorical` values have no such limitation.\n2. map: no strictly matching concept in python/pandas - python dictionaries can have arbitrarily typed keys. functionality can be essentially be achieved with the record type.\n3. union: any column with mixed types (other than empty values/`nonetype`) are treated by pandas as having a dtype of `object`, and will be written as strings. it would be difficult to deterministically infer multiple allowed data types based solely on a column's contents.\n\n\nand these logical types:\n\n| numpy/pandas type                               | avro logical type                 |\n|-------------------------------------------------|-----------------------------------|\n| np.datetime64, pd.datetimetzdtype, pd.timestamp | timestamp-micros/timezone-millis  |\n\nnote that the timestamp must not contain any timezone (it must be naive) because avro does not support timezones.\ntimestamps are encoded as microseconds by default, but can be encoded in milliseconds by using `times_as_micros=false`\n\n\\* if passed `to_avro(..., times_as_micros=false)`, this has a millisecond resolution.\n\ndue to [an inherent design choice in fastavro](https://github.com/fastavro/fastavro/issues/409), it interprets a *naive* datetime in the system's timezone before serializing it. this has the consequence that your *naive* datetime will not correctly roundtrip to and from an avro file. *always indicate a timezone* to avoid the system timezone introducing problems.\n\nif you don't want pandavro to infer the schema but instead define it yourself, pass it using the `schema` kwarg to `to_avro`.\n\n## loading pandas nullable datatypes\nthe nullable datatypes indicated in the table above are easily written to avro, but loading them introduces ambiguity as we can use either the old, default or these new datatypes. we solve this by using a special keyword when loading to force conversion to these new na-supporting datatypes:\n\n```python\nimport pandavro as pdx\n\n# load datatypes as na-compatible datatypes where possible\npdx.read_avro(path, na_dtypes=true)\n```\n\nthis is *different* from [convert_dtypes](https://pandas.pydata.org/docs/whatsnew/v1.0.0.html#convert-dtypes-method-to-ease-use-of-supported-extension-dtypes) as it does not infer the datatype based on the actual values, but it looks at the avro schema so is deterministic and not dependent on the actual values.\n\nalso note that, in \"normal\" mode, numpy int/uint dtypes are all read back as `np.int64` due to how fastavro reads them. (this could be worked around by converting type after loading, prs welcome.) in `na_dtypes=true` mode they are loaded correctly as pandas na-dtypes, but with no less than 32 bits of resolution (less is not supported by avro so we can not infer it from the schema).\n\n## example\n\nsee `tests/pandavro_test.py` for more examples.\n\n```python\nimport os\nimport numpy as np\nimport pandas as pd\nimport pandavro as pdx\n\noutput_path='{}/example.avro'.format(os.path.dirname(__file__))\n\n\ndef main():\n    df = pd.dataframe({\n        \"boolean\": [true, false, true, false],\n        \"pdboolean\": pd.series([true, none, true, false], dtype=pd.booleandtype()),\n        \"float64\": np.random.randn(4),\n        \"int64\": np.random.randint(0, 10, 4),\n        \"pdint64\":  pd.series(list(np.random.randint(0, 10, 3)) + [none], dtype=pd.int64dtype()),\n        \"string\": ['foo', 'bar', 'foo', 'bar'],\n        \"pdstring\": pd.series(['foo', 'bar', 'foo', none], dtype=pd.stringdtype()),\n        \"datetime64\": [pd.timestamp('20190101'), pd.timestamp('20190102'),\n                       pd.timestamp('20190103'), pd.timestamp('20190104')]\n    })\n\n    pdx.to_avro(output_path, df)\n    saved = pdx.read_avro(output_path)\n    print(saved)\n\n\nif __name__ == '__main__':\n    main()\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "pandavro",
  "package_url": "https://pypi.org/project/pandavro/",
  "project_url": "https://pypi.org/project/pandavro/",
  "project_urls": {
    "Homepage": "https://github.com/ynqa/pandavro"
  },
  "release_url": "https://pypi.org/project/pandavro/1.8.0/",
  "requires_dist": [
    "fastavro <2.0.0,>=1.5.1",
    "pandas >=1.1",
    "numpy >=1.15.4",
    "pytest ==7.3.2 ; extra == 'tests'",
    "tox ==4.6.0 ; extra == 'tests'"
  ],
  "requires_python": ">=3.7.0",
  "summary": "the interface between avro and pandas dataframe",
  "version": "1.8.0",
  "releases": [],
  "developers": [
    "makoto_ito",
    "un.pensiero.vano@gmail.com"
  ],
  "kwds": "pandavro_test pandavro read_avro to_avro avro",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pandavro",
  "homepage": "https://github.com/ynqa/pandavro",
  "release_count": 15,
  "dependency_ids": [
    "pypi_fastavro",
    "pypi_numpy",
    "pypi_pandas",
    "pypi_pytest",
    "pypi_tox"
  ]
}