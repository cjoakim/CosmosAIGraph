{
  "classifiers": [],
  "description": "# apiritif\n\napiritif is a number of utilities aimed to simplify the process of maintaining api tests. \napiritif tests fully based on python nose tests. this library can help you to develop and run your existing tests.\nin order to create any valid tests for apiritif you can read [nose test documentation](https://nose.readthedocs.io/en/latest/testing.html).\n\ncheck apiritif version with the following command:\n```\npython -m apiritif -- version\n```\n\nhere described some features of apiritif which can help you to create tests more easily.  \n\n## overview\n\n## http requests\n\napiritif allows to use simple `requests`-like api for making http requests.\n\n```python\nfrom apiritif import http\n\nresponse = http.get(\"http://example.com\")\nresponse.assert_ok()  # will raise assertionerror if request wasn't successful\n```\n\n`http` object provides the following methods:\n```python\nfrom apiritif import http\n\nhttp.get(\"http://api.example.com/posts\")\nhttp.post(\"http://api.example.com/posts\")\nhttp.put(\"http://api.example.com/posts/1\")\nhttp.patch(\"http://api.example.com/posts/1\")\nhttp.delete(\"http://api.example.com/posts/1\")\nhttp.head(\"http://api.example.com/posts\")\n```\n\nall methods (`get`, `post`, `put`, `patch`, `delete`, `head`) support the following arguments:\n```python\ndef get(address,               # url for the request\n        params=none,           # url params dict\n        headers=none,          # http headers\n        cookies=none,          # request cookies\n        data=none,             # raw request data\n        json=none,             # attach json object as request body\n        encrypted_cert=none,   # certificate to use with request \n        allow_redirects=true,  # automatically follow http redirects\n        timeout=30)            # request timeout, by default it's 30 seconds\n```\n\n##### certificate usage\ncurrently `http` supports `pem` and `pkcs12` certificates. \nhere is an example of certificate usage:\n```python\nhttp.get(\"http://api.example.com/posts\", encrypted_cert=('./cert.pem', 'passphrase'))\n```\nfirst parameter is path to certificate, second is the passphrase certificate encrypted with.\n\n## http targets\n\ntarget is an object that captures resource name of the url (protocol, domain, port)\nand allows to set some settings applied to all requests made for a target.\n\n\n```python\nfrom apiritif import http\n\nqa_env = http.target(\"http://192.160.0.2\")\nqa_env.get(\"/api/v4/user\")\nqa_env.get(\"/api/v4/user\")\n```\n\ntarget constructor supports the following options:\n```python\ntarget = apiritif.http.target(\n    address,               # target base address\n    base_path=none,        # base path prepended to all paths (e.g. '/api/v2')\n    use_cookies=true,      # use cookies\n    additional_headers=none,  # additional headers for all requests\n    keep_alive=true,       # reuse opened http connection\n    auto_assert_ok=true,   # automatically invoke 'assert_ok' after each request\n)\n```\n\n\n## assertions\n\napiritif responses provide a lot of useful assertions that can be used on responses.\n\nhere's the list of assertions that can be used:\n```python\nresponse = http.get(\"http://example.com/\")\n\n# assert that request succeeded (status code is 2xx or 3xx)\nresponse.assert_ok()\n# assert that request has failed\nresponse.assert_failed()\n\n# status code based assertions\nresponse.assert_2xx()\nresponse.assert_3xx()\nresponse.assert_4xx()\nresponse.assert_5xx()\nresponse.assert_status_code(code)\nresponse.assert_not_status_code(code)\nresponse.assert_status_code_in(codes)\n\n# content-based assertions\n\n# assert that response body contains a string\nresponse.assert_in_body(member)\n\n# assert that response body doesn't contain a string\nresponse.assert_not_in_body(member)\n\n# search (or match) response body with a regex\nresponse.assert_regex_in_body(regex, match=false)\nresponse.assert_regex_not_in_body(regex, match=false)\n\n# assert that response has header\nresponse.assert_has_header(header)\n\n# assert that response has header with given value\nresponse.assert_header_value(header, value)\n\n# assert that response's headers contains a string\nresponse.assert_in_headers(member)\nresponse.assert_not_in_headers(member)\n\n# search (or match) response body with a regex\nresponse.assert_regex_in_headers(member)\nresponse.assert_regex_not_in_headers(member)\n\n# assert that response body matches jsonpath query\nresponse.assert_jsonpath(jsonpath_query, expected_value=none)\nresponse.assert_not_jsonpath(jsonpath_query)\n\n# assert that response body matches xpath query\nresponse.assert_xpath(xpath_query, parser_type='html', validate=false)\nresponse.assert_not_xpath(xpath_query, parser_type='html', validate=false)\n\n# assert that html response body contains css selector item\nresponse.assert_cssselect(selector, expected_value=none, attribute=none)\nresponse.assert_not_cssselect(selector, expected_value=none, attribute=none)\n\n```\n\nnote that assertions can be chained, so the following construction is entirely valid:\n```python\n\nresponse = http.get(\"http://example.com/\")\nresponse.assert_ok().assert_in_body(\"example\")\n```\n\n## transactions\n\napiritif allows to group multiple requests or actions into a transaction using a `transaction` context manager.\nfor example when we have test action like bellow we want to execute requests according to concrete user as a separate piece.\nalso we want to process test for `users/all` page even if something wrong with previous actions.\n\n```python\ndef test_with_login():\n    user_credentials = data_mock.get_my_user()\n    http.get(\"https://blazedemo.com/user/login?id=\"+user_credentials.id).assert_ok()\n    http.get(\"https://blazedemo.com/user/id/personalpage\").assert_ok()\n    http.get(\"https://blazedemo.com/user/id/getpersonaldata\").assert_ok()\n\n    http.get(\"https://blazedemo.com/users/all\").assert_ok()\n```\n\nhere where we can use transaction in order to wrap login process in one block.\n\n```python\ndef test_with_login():\n    with apiritif.transaction('login'):\n        user_credentials = data_mock.get_my_user()\n        http.get(\"https://blazedemo.com/user/login?id=\"+user_credentials.id).assert_ok()\n        http.get(\"https://blazedemo.com/user/id/personalpage\").assert_ok()\n        http.get(\"https://blazedemo.com/user/id/getpersonaldata\").assert_ok()\n\n    http.get(\"https://blazedemo.com/users/all\").assert_ok()\n```\nat the same time requests to `users/all` page will be executed outside of transaction even if something inside transaction fails.\n\ntransaction defines the name for the block of code. this name with execution results of this particular block will be displayed in the output report.\n\n#### smart transactions\n\n`smart_transaction` is advanced option for test flow control (stop or continue after failed test method).\nlet see another test method example:\n\n```python\nclass tests(testcase):\n    def test_available_pages():\n        http.get(\"https://blazedemo.com/\").assert_ok()\n        http.get(\"https://blazedemo.com/users\").assert_ok()\n    \n        http.get(\"https://blazedemo.com/users/search\").assert_ok()\n        http.get(\"https://blazedemo.com/users/count\").assert_ok()\n        http.get(\"https://blazedemo.com/users/login\").assert_ok()\n\n        http.get(\"https://blazedemo.com/contactus\").assert_ok()\n        http.get(\"https://blazedemo.com/copyright\").assert_ok()\n```\nin this case we have multiple requests divided into blocks. i do not want to test pages under `users` space if it is not available.\nfor this purpose we can use `smart_transaction`.\n\n```python\nclass tests(testcase):\n    def setup(self):\n        apiritif.put_into_thread_store(func_mode=true)\n    \n    def test_available_pages():\n        http.get(\"https://blazedemo.com/\").assert_ok()\n\n        with apiritif.smart_transaction('availability check'):\n            http.get(\"https://blazedemo.com/users\").assert_ok()\n    \n        with apiritif.smart_transaction('test users pages'):\n            http.get(\"https://blazedemo.com/users/search\").assert_ok()\n            http.get(\"https://blazedemo.com/users/count\").assert_ok()\n            http.get(\"https://blazedemo.com/users/login\").assert_ok()\n\n        http.get(\"https://blazedemo.com/contactus\").assert_ok()\n        http.get(\"https://blazedemo.com/copyright\").assert_ok()\n```\nnow this two blocks are wrapped into `smart_transaction` which would help with error test flow handling and logging.\n\nalso each transaction defines the name for the block of code and will be displayed in the output report.\n \nnow about `apiritif.put_into_thread_store(func_mode=true)`, this is test execution mode for apiritif.\nwe can execute all of the transactions in test no matter what or stop after first failed transaction.\nthis flag tells to apiritif \"stop execution if some transaction failed\". `false` says \"run till the end in any case\".\n\n##### nose flow control\nit's one more feature based on smart transactions. it changes `func_mode` if necessary to execute whole teardown block,\nintended to finalize all necessary things.\n\n```python\ndef test_flow-control(self):\n        try:\n            self._method_with_exception()\n            self._skipped_method()\n        finally:\n            apiritif.set_stage(\"teardown\")\n            self._teardown1()\n            self._teardown2()\n```\nif this test will be interrupted in `_method_with_exception`, both of teardown methods will be executed even if them raise exception.\nplease note two differences with usage of `teardown` method of nose:\n1. all parts of teardown stage will be executed as mentioned above (will be interrupted in regular nose execution)\n2. results of teardown steps will be written by apiritif samplewriter into output file (nose lost them as teardown isn't recognised as test).\n\n##### graceful shutdown\nsomethimes waiting of end of test isn't necessary and we prefer to break it but save all current results and handle all teardown steps. (see above)\nit's possible with graceful flag. to use it you can run apiritif with graceful environment variable pointed to any file name.\napiritif will be interrupted as soon as the file is created.\n\n## csv reader\nin order to use data from csv file as test parameters apiritif provides two different csv readers.\nsimple `csvreader` helps you to read data from file line by line and use this data wherever you need:\n\n```python\ndata_reader = apiritif.csvreader('---path to required file---')\nclass tests(testcase):\n    def test_user_page():\n        data_reader.read_vars()\n        vars = data_reader.get_vars()\n        http.get(\"https://blazedemo.com/users/\" + vars.user_id).assert_ok()\n```\n\nin case of multithreading testing you may need to deviate data between threads and ysu uniq lines for each thread.\n`csvreaderperthread` helps to solve this problem: \n\n```python\ndata_per_thread_reader = apiritif.csvreaderperthread('---path to required file---')\nclass tests(testcase):\n    def setup(self):\n        data_per_thread_reader.read_vars()\n        self.vars = data_per_thread_reader.get_vars()\n    \n    def test_user_page():\n        http.get(\"https://blazedemo.com/users/\" + self.vars.user_id).assert_ok()\n```\n\n## execution results\n\napiritif writes output data from tests in `apiritif.#.csv` files by default. here `#` is number of executing process.\nthe output file is similar to this:\n```csv\ntimestamp,elapsed,latency,label,responsecode,responsemessage,success,allthreads,bytes\n1602759519185,0,0,correct test,,,true,0,2\n1602759519186,0,0,correct transaction,,,true,0,2\n1602759519187,0,0,test with exception,,exception: horrible error,false,0,2\n```  \nit contains test and transaction results for executed tests by one process.\n\n### environment variables\n\nthere are environment variables to control length of response/request body to be written into traces and logs:\n  * `apiritif_trace_body_exclimit` - limit of body part to include into exception messages, default is 1024\n  * `apiritif_trace_body_hardlimit` - limit of body length to include into json trace records, default is unlimited\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "apiritif",
  "package_url": "https://pypi.org/project/apiritif/",
  "project_url": "https://pypi.org/project/apiritif/",
  "project_urls": {
    "Download": "https://github.com/Blazemeter/apiritif",
    "Homepage": "https://github.com/Blazemeter/apiritif"
  },
  "release_url": "https://pypi.org/project/apiritif/1.1.3/",
  "requires_dist": [
    "nose2",
    "pytest",
    "requests (>=2.24.0)",
    "jsonpath-ng",
    "lxml",
    "unicodecsv",
    "cssselect",
    "chardet",
    "pyopenssl",
    "codecov"
  ],
  "requires_python": "",
  "summary": "python framework for api testing",
  "version": "1.1.3",
  "releases": [],
  "developers": [
    "dmitri_pribysh",
    "pribysh@blazemeter.com"
  ],
  "kwds": "api testing tests apiritif assert_header_value",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_apiritif",
  "homepage": "https://github.com/blazemeter/apiritif",
  "release_count": 30,
  "dependency_ids": [
    "pypi_chardet",
    "pypi_codecov",
    "pypi_cssselect",
    "pypi_jsonpath_ng",
    "pypi_lxml",
    "pypi_nose2",
    "pypi_pyopenssl",
    "pypi_pytest",
    "pypi_requests",
    "pypi_unicodecsv"
  ]
}