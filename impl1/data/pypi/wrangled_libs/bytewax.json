{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "programming language :: rust",
    "topic :: system :: distributed computing",
    "topic :: system :: networking"
  ],
  "description": "[![actions status](https://github.com/bytewax/bytewax/workflows/ci/badge.svg)](https://github.com/bytewax/bytewax/actions)\n[![pypi](https://img.shields.io/pypi/v/bytewax.svg?style=flat-square)](https://pypi.org/project/bytewax/)\n[![bytewax user guide](https://img.shields.io/badge/user-guide-brightgreen?style=flat-square)](https://bytewax.io/docs)\n\n\n<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/6073079/195393689-7334098b-a8cd-4aaa-8791-e4556c25713e.png\" width=\"350\">\n  <source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/6073079/194626697-425ade3d-3d72-4b4c-928e-47bad174a376.png\" width=\"350\">\n  <img alt=\"bytewax\">\n</picture>\n\n## python stateful stream processing framework\n\nbytewax is a python framework that simplifies event and stream processing. because bytewax couples the stream and event processing capabilities of flink, spark, and kafka streams with the friendly and familiar interface of python, you can re-use the python libraries you already know and love. connect data sources, run stateful transformations and write to various different downstream systems with built-in connectors or existing python libraries.\n\n<img width=\"1303\" alt=\"screen shot 2022-10-07 at 2 22 49 pm\" src=\"https://user-images.githubusercontent.com/6073079/194624582-c16df8d6-d501-46b2-bdbc-78dbed67902e.png\">\n\n\n### how it all works\n\nbytewax is a python framework and rust distributed processing engine that uses a dataflow computational model to provide parallelizable stream processing and event processing capabilities similar to flink, spark, and kafka streams. you can use bytewax for a variety of workloads from moving data \u00e0 la kafka connect style all the way to advanced online machine learning workloads. bytewax is not limited to streaming applications but excels anywhere that data can be distributed at the input and output.\n\nbytewax has an accompanying command line interface, [waxctl](https://bytewax.io/docs/deployment/waxctl/), which supports the deployment of dataflows on cloud vms or kuberentes. you can download it [here](https://bytewax.io/downloads/).\n\n_____________\n\n### getting started with bytewax\n\n```sh\npip install bytewax\n```\n\n[_install waxctl_](https://bytewax.io/downloads/)\n\na bytewax dataflow is python code that will represent an input, a series of processing steps, and an output. the inputs could range from a kafka stream to a websocket and the outputs could vary from a data lake to a key-value store.\n\n```python\nfrom bytewax.dataflow import dataflow\nfrom bytewax.connectors.kafka import kafkainput\n\n# bytewax has input and output helpers for common input and output data sources\n# but you can also create your own with the manualoutputconfig.\n```\n\nat a high-level, the dataflow compute model is one in which a program execution is conceptualized as data flowing through a series of operator-based steps. operators like `map` and `filter` are the processing primitives of bytewax. each of them gives you a \u201cshape\u201d of data transformation, and you give them regular python functions to customize them to a specific task you need. see the documentation for a list of the [available operators](https://bytewax.io/apidocs/bytewax.dataflow#bytewax.dataflow.dataflow)\n\n```python\nimport json\n\n\ndef deserialize(key_bytes__payload_bytes):\n    _, payload_bytes = key_bytes__payload_bytes\n    event_data = json.loads(payload_bytes) if payload_bytes else none\n    return event_data[\"user_id\"], event_data\n\n\ndef anonymize_email(user_id__event_data):\n    user_id, event_data = user_id__event_data\n    event_data[\"email\"] = \"@\".join([\"******\", event_data[\"email\"].split(\"@\")[-1]])\n    return user_id, event_data\n\n\ndef remove_bytewax(user_id__event_data):\n    user_id, event_data = user_id__event_data\n    return \"bytewax\" not in event_data[\"email\"]\n\n\nflow = dataflow()\nflow.input(\"inp\", kafkainput(brokers=[\"localhost:9092\"], topic=\"web_events\"))\nflow.map(deserialize)\nflow.map(anonymize_email)\nflow.filter(remove_bytewax)\n```\n\nbytewax is a stateful stream processing framework, which means that some operations remember information across multiple events.  windows and aggregations are also stateful, and can be reconstructed in the event of failure. bytewax can be configured with different [state recovery mechanisms](https://bytewax.io/apidocs/bytewax.recovery) to durably persist state in order to recover from failure.\n\nthere are multiple stateful operators available like `reduce`, `stateful_map` and `fold_window`. the complete list can be found in the [api documentation for all operators](https://bytewax.io/apidocs/bytewax.dataflow). below we use the `fold_window` operator with a tumbling window based on system time to gather events and calculate the number of times events have occurred on a per-user basis.\n\n```python\nfrom datetime import datetime, timedelta, timezone\nfrom collections import defaultdict\n\nfrom bytewax.window import tumblingwindow, systemclockconfig\n\n\ndef build():\n    return defaultdict(lambda: 0)\n\n\ndef count_events(results, event):\n    results[event[\"type\"]] += 1\n    return results\n\n\ncc = systemclockconfig()\nalign_to = datetime(2023, 1, 1, tzinfo=timezone.utc)\nwc = tumblingwindow(length=timedelta(seconds=5), align_to=align_to)\n\nflow.fold_window(\"session_state_recovery\", cc, wc, build, count_events)\n```\n\noutput mechanisms in bytewax are managed in the [output operator](https://bytewax.io/apidocs/bytewax.dataflow#bytewax.dataflow.dataflow.output). there are a number of helpers that allow you to easily connect and write to other systems ([output docs](https://docs.bytewax.io/apidocs/bytewax.outputs)). if there isn\u2019t a helper built, it is easy to build a custom version, which we will do below. similar the input, bytewax output can be parallelized and the client connection will occur on the worker.\n\n```python\nimport json\n\nimport psycopg2\n\nfrom bytewax.outputs import partitionedoutput, statefulsink\n\n\nclass psqlsink(statefulsink):\n    def __init__(self):\n        self.conn = psycopg2.connect(\"dbname=website user=bytewax\")\n        self.conn.set_session(autocommit=true)\n        self.cur = self.conn.cursor()\n\n    def write(self, user_id__user_data):\n        user_id, user_data = user_id__user_data\n        query_string = \"\"\"\n            insert into events (user_id, data)\n            values (%s, %s)\n            on conflict (user_id)\n            do update set data = %s;\n        \"\"\"\n        self.cur.execute(\n            query_string, (user_id, json.dumps(user_data), json.dumps(user_data))\n        )\n\n    def snapshot(self):\n        pass\n\n    def close(self):\n        self.conn.close()\n\n\nclass psqloutput(partitionedoutput):\n    def list_parts(self):\n        return {\"single\"}\n\n    def assign_part(self, item_key):\n        return \"single\"\n\n    def build_part(for_part, resume_state):\n        return psqlsink()\n\n\nflow.output(\"out\", psqloutput())\n```\n\nbytewax dataflows can be executed on a single host with multiple python processes, or on multiple hosts. when processing data in a distributed fashion, bytewax will ensure that all items with the same key are routed to the same host.\n\n```sh\npython -m bytewax.run my_dataflow:flow\n```\n\nit can also be run in a docker container as described further in the [documentation](https://bytewax.io/docs/deployment/container).\n\n#### kubernetes\n\nthe recommended way to run dataflows at scale is to leverage the [kubernetes ecosystem](https://bytewax.io/docs/deployment/k8s-ecosystem). to help manage deployment, we built [waxctl](https://bytewax.io/docs/deployment/waxctl), which allows you to easily deploy dataflows that will run at huge scale across multiple compute nodes.\n\n```sh\nwaxctl df deploy my_dataflow.py --name my-dataflow\n```\n\n## why bytewax?\n\nat a high level, bytewax provides a few major benefits:\n\n* the operators in bytewax are largely \u201cdata-parallel\u201d, meaning they can operate on independent parts of the data concurrently.\n* bytewax offers the ability to express higher-level control constructs, like iteration.\n* bytewax allows you to develop and run your code locally, and then easily scale that code to multiple workers or processes without changes.\n* bytewax can be used in both a streaming and batch context\n* ability to leverage the python ecosystem directly\n\n## community\n\n[slack](https://join.slack.com/t/bytewaxcommunity/shared_invite/zt-vkos2f6r-_set9pf2~n9aroaei3nd2w) is the main forum for communication and discussion.\n\n[github issues](https://github.com/bytewax/bytewax/issues) is reserved only for actual issues. please use the slack community for discussions.\n\n[code of conduct](https://github.com/bytewax/bytewax/blob/main/code_of_conduct.md)\n\n## usage\n\ninstall the [latest release](https://github.com/bytewax/bytewax/releases/latest) with pip:\n\n```shell\npip install bytewax\n```\n\n### building from source\n\nto build a specific branch, you will need to use maturin and have rust installed on your machine. once those have been installed run\n\n```shell\nmaturin develop -e dev\n```\n\n*important*: if you are testing with a maturin built version from source, you should use `maturin build --release` since `maturin develop` will be slower.\n\n## more examples\n\nfor a more complete example, and documentation on the available operators, check out the [user guide](https://bytewax.io/docs) and the [/examples](/examples) folder.\n\n## license\n\nbytewax is licensed under the [apache-2.0](https://opensource.org/licenses/apache-2.0) license.\n\n## contributing\n\ncontributions are welcome! this community and project would not be what it is without the [contributors](https://github.com/bytewax/bytewax/graphs/contributors). all contributions, from bug reports to new features, are welcome and encouraged. please view the [contribution guidelines](/contributing.md) before getting started.\n\n</br>\n</br>\n\n<p align=\"center\"> with \u2764\ufe0f bytewax</p>\n<p align=\"center\"><img src=\"https://user-images.githubusercontent.com/6073079/157482621-331ad886-df3c-4c92-8948-9e50accd38c9.png\" /> </p>\n<img referrerpolicy=\"no-referrer-when-downgrade\" src=\"https://static.scarf.sh/a.png?x-pxid=07749572-3e76-4ac0-952b-d5dcf3bff737\" />\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "bytewax",
  "package_url": "https://pypi.org/project/bytewax/",
  "project_url": "https://pypi.org/project/bytewax/",
  "project_urls": {
    "Changelog": "https://github.com/bytewax/bytewax/blob/main/CHANGELOG.md",
    "Documentation": "https://docs.bytewax.io/",
    "Issues": "https://github.com/bytewax/bytewax/issues",
    "Source Code": "https://github.com/bytewax/bytewax"
  },
  "release_url": "https://pypi.org/project/bytewax/0.18.0/",
  "requires_dist": [
    "jsonpickle >=3",
    "typing_extensions >=4",
    "ruff ==0.1.8 ; extra == 'cbfmt'",
    "pdoc3 ==0.10.0 ; extra == 'docs'",
    "bytewax[cbfmt,docs,kafka,test] ; extra == 'dev'",
    "pre-commit ==2.19.0 ; extra == 'dev'",
    "ruff ==0.1.8 ; extra == 'dev'",
    "vermin ==1.5.2 ; extra == 'dev'",
    "requests >=2.0 ; extra == 'kafka'",
    "fastavro >=1.8 ; extra == 'kafka'",
    "confluent-kafka <=2.0.2 ; extra == 'kafka'",
    "myst-docutils ==0.17.0 ; extra == 'test'",
    "pytest ==7.1.0 ; extra == 'test'"
  ],
  "requires_python": ">=3.8",
  "summary": "",
  "version": "0.18.0",
  "releases": [],
  "developers": [],
  "kwds": "badge bytewax brightgreen shields png",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_bytewax",
  "homepage": "",
  "release_count": 26,
  "dependency_ids": [
    "pypi_bytewax",
    "pypi_confluent_kafka",
    "pypi_fastavro",
    "pypi_jsonpickle",
    "pypi_myst_docutils",
    "pypi_pdoc3",
    "pypi_pre_commit",
    "pypi_pytest",
    "pypi_requests",
    "pypi_ruff",
    "pypi_typing_extensions",
    "pypi_vermin"
  ]
}