{
  "classifiers": [
    "development status :: 5 - production/stable",
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# json tricks (python)\n\nthe [pyjson-tricks] package brings several pieces of\nfunctionality to python handling of json files:\n\n1.  **store and load numpy arrays** in human-readable format.\n2.  **store and load class instances** both generic and customized.\n3.  **store and load date/times** as a dictionary (including timezone).\n4.  **preserve map order** `{}` using `ordereddict`.\n5.  **allow for comments** in json files by starting lines with `#`.\n6.  sets, complex numbers, decimal, fraction, enums, compression,\n    duplicate keys, pathlib paths, bytes ...\n\nas well as compression and disallowing duplicate keys.\n\n* code: <https://github.com/mverleg/pyjson_tricks>\n* documentation: <http://json-tricks.readthedocs.org/en/latest/>\n* pip: <https://pypi.python.org/pypi/json_tricks>\n\nseveral keys of the format `__keyname__` have special meanings, and more\nmight be added in future releases.\n\nif you're considering json-but-with-comments as a config file format,\nhave a look at [hjson](https://github.com/hjson/hjson-py), it might be\nmore appropriate. for other purposes, keep reading!\n\nthanks for all the github stars\u2b50!\n\n# installation and use\n\nyou can install using\n\n``` bash\npip install json-tricks\n```\n\ndecoding of some data types needs the corresponding package to be\ninstalled, e.g. `numpy` for arrays, `pandas` for dataframes and `pytz`\nfor timezone-aware datetimes.\n\nyou can import the usual json functions dump(s) and load(s), as well as\na separate comment removal function, as follows:\n\n``` bash\nfrom json_tricks import dump, dumps, load, loads, strip_comments\n```\n\nthe exact signatures of these and other functions are in the [documentation](http://json-tricks.readthedocs.org/en/latest/#main-components).\n\nquite some older versions of python are supported. for an up-to-date  list see [the automated tests](./.github/workflows/tests.yml).\n\n# features\n\n## numpy arrays\n\nwhen not compressed, the array is encoded in sort-of-readable and very\nflexible and portable format, like so:\n\n``` python\narr = arange(0, 10, 1, dtype=uint8).reshape((2, 5))\nprint(dumps({'mydata': arr}))\n```\n\nthis yields:\n\n``` javascript\n{\n    \"mydata\": {\n        \"dtype\": \"uint8\",\n        \"shape\": [2, 5],\n        \"corder\": true,\n        \"__ndarray__\": [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\n    }\n}\n```\n\nwhich will be converted back to a numpy array when using\n`json_tricks.loads`. note that the memory order (`corder`) is only\nstored in v3.1 and later and for arrays with at least 2 dimensions.\n\nas you see, this uses the magic key `__ndarray__`. don't use\n`__ndarray__` as a dictionary key unless you're trying to make a numpy\narray (and know what you're doing).\n\nnumpy scalars are also serialized (v3.5+). they are represented by the\nclosest python primitive type. a special representation was not\nfeasible, because python's json implementation serializes some numpy\ntypes as primitives, without consulting custom encoders. if you want to\npreserve the exact numpy type, use\n[encode_scalars_inplace](https://json-tricks.readthedocs.io/en/latest/#json_tricks.np_utils.encode_scalars_inplace).\n\nthere is also a compressed format (thanks `claydugo` for fix). from \nthe next major release, this will be default when using compression.\nfor now, you can use it as:\n\n``` python\ndumps(data, compression=true, properties={'ndarray_compact': true})\n```\n\nthis compressed format encodes the array data in base64, with gzip\ncompression for the array, unless 1) compression has little effect for\nthat array, or 2) the whole file is already compressed. if you only want\ncompact format for large arrays, pass the number of elements to\n`ndarray_compact`.\n\nexample:\n\n``` python\ndata = [linspace(0, 10, 9), array([pi, exp(1)])]\ndumps(data, compression=false, properties={'ndarray_compact': 8})\n\n[{\n   \"__ndarray__\": \"b64.gz:h4siaaaaaaac/2ngqazf7ce0iwoe5opsilbaekrlqeggrshfxqeaz7qfikgaaaa=\",\n   \"dtype\": \"float64\",\n   \"shape\": [9]\n }, {\n   \"__ndarray__\": [3.141592653589793, 2.718281828459045],\n   \"dtype\": \"float64\",\n   \"shape\": [2]\n }]\n```\n\n## class instances\n\n`json_tricks` can serialize class instances.\n\nif the class behaves normally (not generated dynamic, no `__new__` or\n`__metaclass__` magic, etc) *and* all it's attributes are serializable,\nthen this should work by default.\n\n``` python\n# json_tricks/test_class.py\nclass mytestcls:\ndef __init__(self, **kwargs):\n    for k, v in kwargs.items():\n        setattr(self, k, v)\n\ncls_instance = mytestcls(s='ub', dct={'7': 7})\n\njson = dumps(cls_instance, indent=4)\ncls_instance_again = loads(json)\n```\n\nyou'll get your instance back. here the json looks like this:\n\n``` javascript\n{\n   \t\"__instance_type__\": [\n   \t\t\"json_tricks.test_class\",\n   \t\t\"mytestcls\"\n   \t],\n   \t\"attributes\": {\n   \t\t\"s\": \"ub\",\n   \t\t\"dct\": {\n   \t\t\t\"7\": 7\n   \t\t}\n   \t}\n}\n```\n\nas you can see, this stores the module and class name. the class must be\nimportable from the same module when decoding (and should not have\nchanged). if it isn't, you have to manually provide a dictionary to\n`cls_lookup_map` when loading in which the class name can be looked up.\nnote that if the class is imported, then `globals()` is such a\ndictionary (so try `loads(json, cls_lookup_map=glboals())`). also note\nthat if the class is defined in the 'top' script (that you're calling\ndirectly), then this isn't a module and the import part cannot be\nextracted. only the class name will be stored; it can then only be\ndeserialized in the same script, or if you provide `cls_lookup_map`.\n\nnote that this also works with `slots` without having to do anything\n(thanks to `koffie` and `dominicdoty`), which encodes like this (custom\nindentation):\n\n``` javascript\n{\n    \"__instance_type__\": [\"module.path\", \"classname\"],\n    \"slots\": {\"slotattr\": 37},\n    \"attributes\": {\"dictattr\": 42}\n}\n```\n\nif the instance doesn't serialize automatically, or if you want custom\nbehaviour, then you can implement `__json__encode__(self)` and\n`__json_decode__(self, **attributes)` methods, like so:\n\n``` python\nclass customencodecls:\ndef __init__(self):\n    self.relevant = 42\n    self.irrelevant = 37\n\n    def __json_encode__(self):\n    # should return primitive, serializable types like dict, list, int, string, float...\n    return {'relevant': self.relevant}\n\n    def __json_decode__(self, **attrs):\n    # should initialize all properties; note that __init__ is not called implicitly\n    self.relevant = attrs['relevant']\n    self.irrelevant = 12\n```\n\nas you've seen, this uses the magic key `__instance_type__`. don't use\n`__instance_type__` as a dictionary key unless you know what you're\ndoing.\n\n## date, time, datetime and timedelta\n\ndate, time, datetime and timedelta objects are stored as dictionaries of\n\"day\", \"hour\", \"millisecond\" etc keys, for each nonzero property.\n\ntimezone name is also stored in case it is set, as is dst (thanks `eumir`).\nyou'll need to have `pytz` installed to use timezone-aware date/times, \nit's not needed for naive date/times.\n\n``` javascript\n{\n    \"__datetime__\": null,\n    \"year\": 1988,\n    \"month\": 3,\n    \"day\": 15,\n    \"hour\": 8,\n    \"minute\": 3,\n    \"second\": 59,\n    \"microsecond\": 7,\n    \"tzinfo\": \"europe/amsterdam\"\n}\n```\n\nthis approach was chosen over timestamps for readability and consistency\nbetween date and time, and over a single string to prevent parsing\nproblems and reduce dependencies. note that if `primitives=true`,\ndate/times are encoded as iso 8601, but they won't be restored\nautomatically.\n\ndon't use `__date__`, `__time__`, `__datetime__`, `__timedelta__` or\n`__tzinfo__` as dictionary keys unless you know what you're doing, as\nthey have special meaning.\n\n## order\n\ngiven an ordered dictionary like this (see the tests for a longer one):\n\n``` python\nordered = ordereddict((\n    ('elephant', none),\n    ('chicken', none),\n    ('tortoise', none),\n))\n```\n\nconverting to json and back will preserve the order:\n\n``` python\nfrom json_tricks import dumps, loads\njson = dumps(ordered)\nordered = loads(json, preserve_order=true)\n```\n\nwhere `preserve_order=true` is added for emphasis; it can be left out\nsince it's the default.\n\nas a note on [performance](http://stackoverflow.com/a/8177061/723090),\nboth dicts and ordereddicts have the same scaling for getting and\nsetting items (`o(1)`). in python versions before 3.5, ordereddicts were\nimplemented in python rather than c, so were somewhat slower; since\npython 3.5 both are implemented in c. in summary, you should have no\nscaling problems and probably no performance problems at all, especially\nin python 3. python 3.6+ preserves order of dictionaries by default\nmaking this redundant, but this is an implementation detail that should\nnot be relied on.\n\n## comments\n\n*warning: in the next major version, comment parsing will be opt-in, not\ndefault anymore (for performance reasons). update your code now to pass\n`ignore_comments=true` explicitly if you want comment parsing.*\n\nthis package uses `#` and `//` for comments, which seem to be the most\ncommon conventions, though only the latter is valid javascript.\n\nfor example, you could call `loads` on the following string:\n\n{ # \"comment 1\n    \"hello\": \"wor#d\", \"bye\": \"\"m#rk\"\", \"yes\\\\\"\": 5,# comment\" 2\n    \"quote\": \"\"th#t's\" what she said\", // comment \"3\"\n    \"list\": [1, 1, \"#\", \"\"\", \"\\\", 8], \"dict\": {\"q\": 7} #\" comment 4 with quotes\n}\n// comment 5\n\nand it would return the de-commented version:\n\n``` javascript\n{\n    \"hello\": \"wor#d\", \"bye\": \"\"m#rk\"\", \"yes\\\\\"\": 5,\n    \"quote\": \"\"th#t's\" what she said\",\n    \"list\": [1, 1, \"#\", \"\"\", \"\\\", 8], \"dict\": {\"q\": 7}\n}\n```\n\nsince comments aren't stored in the python representation of the data,\nloading and then saving a json file will remove the comments (it also\nlikely changes the indentation).\n\nthe implementation of comments is a bit crude, which means that there are \nsome exceptional cases that aren't handled correctly ([#57](https://github.com/mverleg/pyjson_tricks/issues/57)).\n\nit is also not very fast. for that reason, if `ignore_comments` wasn't \nexplicitly set to true, then json-tricks first tries to parge without \nignoring comments. if that fails, then it will automatically re-try \nwith comment handling. this makes the no-comment case faster at the cost\nof the comment case, so if you are expecting comments make sure to set\n`ignore_comments` to true.\n\n## other features\n\n* special floats like `nan`, `infinity` and\n  `-0` using the `allow_nan=true` argument\n  ([non-standard](https://stackoverflow.com/questions/1423081/json-left-out-infinity-and-nan-json-status-in-ecmascript)\n  json, may not decode in other implementations).\n* sets are serializable and can be loaded. by default the set json\n  representation is sorted, to have a consistent representation.\n* save and load complex numbers (py3) with `1+2j` serializing as\n  `{'__complex__': [1, 2]}`.\n* save and load `decimal` and `fraction` (including nan, infinity, -0\n  for decimal).\n* save and load `enum` (thanks to `jenselme`), either built-in in\n  python3.4+, or with the [enum34](https://pypi.org/project/enum34/)\n  package in earlier versions. `intenum` needs\n  [encode_intenums_inplace](https://json-tricks.readthedocs.io/en/latest/#json_tricks.utils.encode_intenums_inplace).\n* `json_tricks` allows for gzip compression using the\n  `compression=true` argument (off by default).\n* `json_tricks` can check for duplicate keys in maps by setting\n  `allow_duplicates` to false. these are [kind of\n  allowed](http://stackoverflow.com/questions/21832701/does-json-syntax-allow-duplicate-keys-in-an-object),\n  but are handled inconsistently between json implementations. in\n  python, for `dict` and `ordereddict`, duplicate keys are silently\n  overwritten.\n* save and load `pathlib.path` objects (e.g., the current path,\n  `path('.')`, serializes as `{\"__pathlib__\": \".\"}`)\n  (thanks to `bburan`).\n* save and load bytes (python 3+ only), which will be encoded as utf8 if \n  that is valid, or as base64 otherwise. base64 is always used if \n  primitives are requested. serialized as\n  `[{\"__bytes_b64__\": \"agvsbg8=\"}]` vs `[{\"__bytes_utf8__\": \"hello\"}]`.\n* save and load slices (thanks to `claydugo`).\n\n# preserve type vs use primitive\n\nby default, types are encoded such that they can be restored to their\noriginal type when loaded with `json-tricks`. example encodings in this\ndocumentation refer to that format.\n\nyou can also choose to store things as their closest primitive type\n(e.g. arrays and sets as lists, decimals as floats). this may be\ndesirable if you don't care about the exact type, or you are loading\nthe json in another language (which doesn't restore python types).\nit's also smaller.\n\nto forego meta data and store primitives instead, pass `primitives` to\n`dump(s)`. this is available in version `3.8` and later. example:\n\n``` python\ndata = [\n    arange(0, 10, 1, dtype=int).reshape((2, 5)),\n    datetime(year=2017, month=1, day=19, hour=23, minute=00, second=00),\n    1 + 2j,\n    decimal(42),\n    fraction(1, 3),\n    mytestcls(s='ub', dct={'7': 7}),  # see later\n    set(range(7)),\n]\n# encode with metadata to preserve types when decoding\nprint(dumps(data))\n```\n\n``` javascript\n\n// (comments added and indenting changed)\n[\n    // numpy array\n    {\n        \"__ndarray__\": [\n            [0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9]],\n        \"dtype\": \"int64\",\n        \"shape\": [2, 5],\n        \"corder\": true\n    },\n    // datetime (naive)\n    {\n        \"__datetime__\": null,\n        \"year\": 2017,\n        \"month\": 1,\n        \"day\": 19,\n        \"hour\": 23\n    },\n    // complex number\n    {\n        \"__complex__\": [1.0, 2.0]\n    },\n    // decimal & fraction\n    {\n        \"__decimal__\": \"42\"\n    },\n    {\n        \"__fraction__\": true\n        \"numerator\": 1,\n        \"denominator\": 3,\n    },\n    // class instance\n    {\n        \"__instance_type__\": [\n          \"tests.test_class\",\n          \"mytestcls\"\n        ],\n        \"attributes\": {\n          \"s\": \"ub\",\n          \"dct\": {\"7\": 7}\n        }\n    },\n    // set\n    {\n        \"__set__\": [0, 1, 2, 3, 4, 5, 6]\n    }\n]\n```\n\n``` python\n# encode as primitive types; more simple but loses type information\nprint(dumps(data, primitives=true))\n```\n\n``` javascript\n// (comments added and indentation changed)\n[\n    // numpy array\n    [[0, 1, 2, 3, 4],\n    [5, 6, 7, 8, 9]],\n    // datetime (naive)\n    \"2017-01-19t23:00:00\",\n    // complex number\n    [1.0, 2.0],\n    // decimal & fraction\n    42.0,\n    0.3333333333333333,\n    // class instance\n    {\n        \"s\": \"ub\",\n        \"dct\": {\"7\": 7}\n    },\n    // set\n    [0, 1, 2, 3, 4, 5, 6]\n]\n```\n\nnote that valid json is produced either way: ``json-tricks`` stores meta data as normal json, but other packages probably won't interpret it.\n\nnote that valid json is produced either way: `json-tricks` stores meta\ndata as normal json, but other packages probably won't interpret it.\n\n# usage & contributions\n\ncode is under [revised bsd license](license.txt)\nso you can use it for most purposes including commercially.\n\ncontributions are very welcome! bug reports, feature suggestions and\ncode contributions help this project become more useful for everyone!\nthere is a short [contribution\nguide](contributing.md).\n\ncontributors not yet mentioned: `janlo` (performance boost).\n\n# tests\n\ntests are run automatically for commits to the repository for all\nsupported versions. this is the status:\n\n![image](https://github.com/mverleg/pyjson_tricks/workflows/pyjson-tricks/badge.svg?branch=master)\n\nto run the tests manually for your version, see [this guide](tests/run_locally.md).\n\n",
  "docs_url": null,
  "keywords": "json,numpy,ordereddict,comments,pandas,pytz,enum,encode,decode,serialize,deserialize",
  "license": "revised bsd license (license.txt)",
  "name": "json-tricks",
  "package_url": "https://pypi.org/project/json-tricks/",
  "project_url": "https://pypi.org/project/json-tricks/",
  "project_urls": {
    "Homepage": "https://github.com/mverleg/pyjson_tricks"
  },
  "release_url": "https://pypi.org/project/json-tricks/3.17.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "extra features for python's json: comments, order, numpy, pandas, datetimes, and many more! simple but customizable.",
  "version": "3.17.3",
  "releases": [],
  "developers": [
    "mark_v",
    "markv.nl.dev@gmail.com"
  ],
  "kwds": "pyjson_tricks pyjson json_tricks ordereddicts ordereddict",
  "license_kwds": "revised bsd license (license.txt)",
  "libtype": "pypi",
  "id": "pypi_json_tricks",
  "homepage": "https://github.com/mverleg/pyjson_tricks",
  "release_count": 47,
  "dependency_ids": []
}