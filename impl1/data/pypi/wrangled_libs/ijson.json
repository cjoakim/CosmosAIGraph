{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: bsd license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": ".. image:: https://github.com/icrar/ijson/actions/workflows/deploy-to-pypi.yml/badge.svg\n    :target: https://github.com/icrar/ijson/actions/workflows/deploy-to-pypi.yml\n\n.. image:: https://ci.appveyor.com/api/projects/status/32wiho6ojw3eakp8/branch/master?svg=true\n    :target: https://ci.appveyor.com/project/rtobar/ijson/branch/master\n\n.. image:: https://coveralls.io/repos/github/icrar/ijson/badge.svg?branch=master\n    :target: https://coveralls.io/github/icrar/ijson?branch=master\n\n.. image:: https://badge.fury.io/py/ijson.svg\n    :target: https://badge.fury.io/py/ijson\n\n.. image:: https://img.shields.io/pypi/pyversions/ijson.svg\n    :target: https://pypi.python.org/pypi/ijson\n\n.. image:: https://img.shields.io/pypi/dd/ijson.svg\n    :target: https://pypi.python.org/pypi/ijson\n\n.. image:: https://img.shields.io/pypi/dw/ijson.svg\n    :target: https://pypi.python.org/pypi/ijson\n\n.. image:: https://img.shields.io/pypi/dm/ijson.svg\n    :target: https://pypi.python.org/pypi/ijson\n\n\n=====\nijson\n=====\n\nijson is an iterative json parser with standard python iterator interfaces.\n\n.. contents::\n   :local:\n\n\ninstallation\n============\n\nijson is hosted in pypi, so you should be able to install it via ``pip``::\n\n  pip install ijson\n\nbinary wheels are provided\nfor major platforms\nand python versions.\nthese are built and published automatically\nusing `cibuildwheel <https://cibuildwheel.readthedocs.io/en/stable/>`_\nvia travis ci.\n\n\nusage\n=====\n\nall usage example will be using a json document describing geographical\nobjects:\n\n.. code-block:: json\n\n    {\n      \"earth\": {\n        \"europe\": [\n          {\"name\": \"paris\", \"type\": \"city\", \"info\": { ... }},\n          {\"name\": \"thames\", \"type\": \"river\", \"info\": { ... }},\n          // ...\n        ],\n        \"america\": [\n          {\"name\": \"texas\", \"type\": \"state\", \"info\": { ... }},\n          // ...\n        ]\n      }\n    }\n\n\nhigh-level interfaces\n---------------------\n\nmost common usage is having ijson yield native python objects out of a json\nstream located under a prefix.\nthis is done using the ``items`` function.\nhere's how to process all european cities:\n\n.. code-block::  python\n\n    import ijson\n\n    f = urlopen('http://.../')\n    objects = ijson.items(f, 'earth.europe.item')\n    cities = (o for o in objects if o['type'] == 'city')\n    for city in cities:\n        do_something_with(city)\n\nfor how to build a prefix see the prefix_ section below.\n\nother times it might be useful to iterate over object members\nrather than objects themselves (e.g., when objects are too big).\nin that case one can use the ``kvitems`` function instead:\n\n.. code-block::  python\n\n    import ijson\n\n    f = urlopen('http://.../')\n    european_places = ijson.kvitems(f, 'earth.europe.item')\n    names = (v for k, v in european_places if k == 'name')\n    for name in names:\n        do_something_with(name)\n\n\nlower-level interfaces\n----------------------\n\nsometimes when dealing with a particularly large json payload it may worth to\nnot even construct individual python objects and react on individual events\nimmediately producing some result.\nthis is achieved using the ``parse`` function:\n\n.. code-block::  python\n\n    import ijson\n\n    parser = ijson.parse(urlopen('http://.../'))\n    stream.write('<geo>')\n    for prefix, event, value in parser:\n        if (prefix, event) == ('earth', 'map_key'):\n            stream.write('<%s>' % value)\n            continent = value\n        elif prefix.endswith('.name'):\n            stream.write('<object name=\"%s\"/>' % value)\n        elif (prefix, event) == ('earth.%s' % continent, 'end_map'):\n            stream.write('</%s>' % continent)\n    stream.write('</geo>')\n\neven more bare-bones is the ability to react on individual events\nwithout even calculating a prefix\nusing the ``basic_parse`` function:\n\n.. code-block:: python\n\n    import ijson\n\n    events = ijson.basic_parse(urlopen('http://.../'))\n    num_names = sum(1 for event, value in events\n                    if event == 'map_key' and value == 'name')\n\n\n.. _command_line:\n\ncommand line\n------------\n\na command line utility is included with ijson\nto help visualise the output of each of the routines above.\nit reads json from the standard input,\nand it prints the results of the parsing method chosen by the user\nto the standard output.\n\nthe tool is available by running the ``ijson.dump`` module.\nfor example::\n\n $> echo '{\"a\": 0, \"b\": [1, 2, 3, 4]}' | python -m ijson.dump -m parse\n #: path, name, value\n --------------------\n 0: , start_map, none\n 1: , map_key, a\n 2: a, number, 0\n 3: , map_key, b\n 4: b, start_array, none\n 5: b.item, number, 1\n 6: b.item, number, 2\n 7: b.item, number, 3\n 8: b.item, number, 4\n 9: b, end_array, none\n 10: , end_map, none\n\nusing ``-h/--help`` will show all available options.\n\n\n``bytes``/``str`` support\n-------------------------\n\nalthough not usually how they are meant to be run,\nall the functions above also accept\n``bytes`` and ``str`` objects (and ``unicode`` in python 2.7)\ndirectly as inputs.\nthese are then internally wrapped into a file object,\nand further processed.\nthis is useful for testing and prototyping,\nbut probably not extremely useful in real-life scenarios.\n\n\n``asyncio`` support\n-------------------\n\nin python 3.5+ all of the methods above\nwork also on file-like asynchronous objects,\nso they can be iterated asynchronously.\nin other words, something like this:\n\n.. code-block:: python\n\n   import asyncio\n   import ijson\n\n   async def run():\n      f = await async_urlopen('http://..../')\n      async for object in ijson.items(f, 'earth.europe.item'):\n         if object['type'] == 'city':\n            do_something_with(city)\n   asyncio.run(run())\n\nan explicit set of ``*_async`` functions also exists\noffering the same functionality,\nexcept they will fail if anything other\nthan a file-like asynchronous object is given to them.\n(so the example above can also be written using ``ijson.items_async``).\nin fact in ijson version 3.0\nthis was the only way to access\nthe ``asyncio`` support.\n\n\nintercepting events\n-------------------\n\nthe four routines shown above\ninternally chain against each other:\ntuples generated by ``basic_parse``\nare the input for ``parse``,\nwhose results are the input to ``kvitems`` and ``items``.\n\nnormally users don't see this interaction,\nas they only care about the final output\nof the function they invoked,\nbut there are occasions when tapping\ninto this invocation chain this could be handy.\nthis is supported\nby passing the output of one function\n(i.e., an iterable of events, usually a generator)\nas the input of another,\nopening the door for user event filtering or injection.\n\nfor instance if one wants to skip some content\nbefore full item parsing:\n\n.. code-block:: python\n\n  import io\n  import ijson\n\n  parse_events = ijson.parse(io.bytesio(b'[\"skip\", {\"a\": 1}, {\"b\": 2}, {\"c\": 3}]'))\n  while true:\n      prefix, event, value = next(parse_events)\n      if value == \"skip\":\n          break\n  for obj in ijson.items(parse_events, 'item'):\n      print(obj)\n\n\nnote that this interception\nonly makes sense for the ``basic_parse -> parse``,\n``parse -> items`` and ``parse -> kvitems`` interactions.\n\nnote also that event interception\nis currently not supported\nby the ``async`` functions.\n\n\npush interfaces\n---------------\n\nall examples above use a file-like object as the data input\n(both the normal case, and for ``asyncio`` support),\nand hence are \"pull\" interfaces,\nwith the library reading data as necessary.\nif for whatever reason it's not possible to use such method,\nyou can still **push** data\nthrough yet a different interface: `coroutines <https://www.python.org/dev/peps/pep-0342/>`_\n(via generators, not ``asyncio`` coroutines).\ncoroutines effectively allow users\nto send data to them at any point in time,\nwith a final *target* coroutine-like object\nreceiving the results.\n\nin the following example\nthe user is doing the reading\ninstead of letting the library do it:\n\n.. code-block:: python\n\n   import ijson\n\n   @ijson.coroutine\n   def print_cities():\n      while true:\n         obj = (yield)\n         if obj['type'] != 'city':\n            continue\n         print(obj)\n\n   coro = ijson.items_coro(print_cities(), 'earth.europe.item')\n   f = urlopen('http://.../')\n   for chunk in iter(functools.partial(f.read, buf_size)):\n      coro.send(chunk)\n   coro.close()\n\nall four ijson iterators\nhave a ``*_coro`` counterpart\nthat work by pushing data into them.\ninstead of receiving a file-like object\nand option buffer size as arguments,\nthey receive a single ``target`` argument,\nwhich should be a coroutine-like object\n(anything implementing a ``send`` method)\nthrough which results will be published.\n\nan alternative to providing a coroutine\nis to use ``ijson.sendable_list`` to accumulate results,\nproviding the list is cleared after each parsing iteration,\nlike this:\n\n.. code-block:: python\n\n   import ijson\n\n   events = ijson.sendable_list()\n   coro = ijson.items_coro(events, 'earth.europe.item')\n   f = urlopen('http://.../')\n   for chunk in iter(functools.partial(f.read, buf_size)):\n      coro.send(chunk)\n      process_accumulated_events(events)\n      del events[:]\n   coro.close()\n   process_accumulated_events(events)\n\n\n.. _options:\n\noptions\n=======\n\nadditional options are supported by **all** ijson functions\nto give users more fine-grained control over certain operations:\n\n- the ``use_float`` option (defaults to ``false``)\n  controls how non-integer values are returned to the user.\n  if set to ``true`` users receive ``float()`` values;\n  otherwise ``decimal`` values are constructed.\n  note that building ``float`` values is usually faster,\n  but on the other hand there might be loss of precision\n  (which most applications will not care about)\n  and will raise an exception when overflow occurs\n  (e.g., if ``1e400`` is encountered).\n  this option also has the side-effect\n  that integer numbers bigger than ``2^64``\n  (but *sometimes* ``2^32``, see backends_)\n  will also raise an overflow error,\n  due to similar reasons.\n  future versions of ijson\n  might change the default value of this option\n  to ``true``.\n- the ``multiple_values`` option (defaults to ``false``)\n  controls whether multiple top-level values are supported.\n  json content should contain a single top-level value\n  (see `the json grammar <https://tools.ietf.org/html/rfc7159#section-2>`_).\n  however there are plenty of json files out in the wild\n  that contain multiple top-level values,\n  often separated by newlines.\n  by default ijson will fail to process these\n  with a ``parse error: trailing garbage`` error\n  unless ``multiple_values=true`` is specified.\n- similarly the ``allow_comments`` option (defaults to ``false``)\n  controls whether c-style comments (e.g., ``/* a comment */``),\n  which are not supported by the json standard,\n  are allowed in the content or not.\n- for functions taking a file-like object,\n  an additional ``buf_size`` option (defaults to ``65536`` or 64kb)\n  specifies the amount of bytes the library\n  should attempt to read each time.\n- the ``items`` and ``kvitems`` functions, and all their variants,\n  have an optional ``map_type`` argument (defaults to ``dict``)\n  used to construct objects from the json stream.\n  this should be a dict-like type supporting item assignment.\n\n\nevents\n======\n\nwhen using the lower-level ``ijson.parse`` function,\nthree-element tuples are generated\ncontaining a prefix, an event name, and a value.\nevents will be one of the following:\n\n- ``start_map`` and ``end_map`` indicate\n  the beginning and end of a json object, respectively.\n  they carry a ``none`` as their value.\n- ``start_array`` and ``end_array`` indicate\n  the beginning and end of a json array, respectively.\n  they also carry a ``none`` as their value.\n- ``map_key`` indicates the name of a field in a json object.\n  its associated value is the name itself.\n- ``null``, ``boolean``, ``integer``, ``double``, ``number`` and ``string``\n  all indicate actual content, which is stored in the associated value.\n\n\n.. _prefix:\n\nprefix\n======\n\na prefix represents the context within a json document\nwhere an event originates at.\nit works as follows:\n\n- it starts as an empty string.\n- a ``<name>`` part is appended when the parser starts parsing the contents\n  of a json object member called ``name``,\n  and removed once the content finishes.\n- a literal ``item`` part is appended when the parser is parsing\n  elements of a json array,\n  and removed when the array ends.\n- parts are separated by ``.``.\n\nwhen using the ``ijson.items`` function,\nthe prefix works as the selection\nfor which objects should be automatically built and returned by ijson.\n\n\n.. _backends:\n\nbackends\n========\n\nijson provides several implementations of the actual parsing in the form of\nbackends located in ijson/backends:\n\n- ``yajl2_c``: a c extension using `yajl <http://lloyd.github.com/yajl/>`__ 2.x.\n  this is the fastest, but *might* require a compiler and the yajl development files\n  to be present when installing this package.\n  binary wheel distributions exist for major platforms/architectures to spare users\n  from having to compile the package.\n- ``yajl2_cffi``: wrapper around `yajl <http://lloyd.github.com/yajl/>`__ 2.x\n  using cffi.\n- ``yajl2``: wrapper around yajl 2.x using ctypes, for when you can't use cffi\n  for some reason.\n- ``yajl``: deprecated yajl 1.x + ctypes wrapper, for even older systems.\n- ``python``: pure python parser, good to use with pypy\n\nyou can import a specific backend and use it in the same way as the top level\nlibrary:\n\n.. code-block::  python\n\n    import ijson.backends.yajl2_cffi as ijson\n\n    for item in ijson.items(...):\n        # ...\n\nimporting the top level library as ``import ijson``\nuses the first available backend in the same order of the list above,\nand its name is recorded under ``ijson.backend``.\nif the ``ijson_backend`` environment variable is set\nits value takes precedence and is used to select the default backend.\n\nyou can also use the ``ijson.get_backend`` function\nto get a specific backend based on a name:\n\n.. code-block:: python\n\n    backend = ijson.get_backend('yajl2_c')\n    for item in backend.items(...):\n        # ...\n\n\nperformance tips\n================\n\nin more-or-less decreasing order,\nthese are the most common actions you can take\nto ensure you get most of the performance\nout of ijson:\n\n- make sure you use the fastest backend available.\n  see backends_ for details.\n- if you know your json data\n  contains only numbers that are \"well behaved\"\n  consider turning on the ``use_float`` option.\n  see options_ for details.\n- make sure you feed ijson with binary data\n  instead of text data.\n  see faq_ #1 for details.\n- play with the ``buf_size`` option,\n  as depending on your data source and your system\n  a value different from the default\n  might show better performance.\n  see options_ for details.\n\n\n.. _faq:\n\nfaq\n===\n\n#. **q**: does ijson work with ``bytes`` or ``str`` values?\n\n   **a**: in short: both are accepted as input, outputs are only ``str``.\n\n   all ijson functions expecting a file-like object\n   should ideally be given one\n   that is opened in binary mode\n   (i.e., its ``read`` function returns ``bytes`` objects, not ``str``).\n   however if a text-mode file object is given\n   then the library will automatically\n   encode the strings into utf-8 bytes.\n   a warning is currently issued (but not visible by default)\n   alerting users about this automatic conversion.\n\n   on the other hand ijson always returns text data\n   (json string values, object member names, event names, etc)\n   as ``str`` objects in python 3,\n   and ``unicode`` objects in python 2.7.\n   this mimics the behavior of the system ``json`` module.\n\n#. **q**: how are numbers dealt with?\n\n   **a**: ijson returns ``int`` values for integers\n   and ``decimal.decimal`` values for floating-point numbers.\n   this is mostly because of historical reasons.\n   since 3.1 a new ``use_float`` option (defaults to ``false``)\n   is available to return ``float`` values instead.\n   see the options_ section for details.\n\n#. **q**: i'm getting an ``unicodedecodeerror``, or an ``incompletejsonerror`` with no message\n\n   **a**: this error is caused by byte sequences that are not valid in utf-8.\n   in other words, the data given to ijson is not *really* utf-8 encoded,\n   or at least not properly.\n\n   depending on where the data comes from you have different options:\n\n   * if you have control over the source of the data, fix it.\n\n   * if you have a way to intercept the data flow,\n     do so and pass it through a \"byte corrector\".\n     for instance, if you have a shell pipeline\n     feeding data through ``stdin`` into your process\n     you can add something like ``... | iconv -f utf8 -t utf8 -c | ...``\n     in between to correct invalid byte sequences.\n\n   * if you are working purely in python,\n     you can create a utf-8 decoder\n     using codecs' `incrementaldecoder <https://docs.python.org/3/library/codecs.html#codecs.getincrementaldecoder>`_\n     to leniently decode your bytes into strings,\n     and feed those strings (using a file-like class) into ijson\n     (see our `string_reader_async internal class <https://github.com/icrar/ijson/blob/0157f3c65a7986970030d3faa75979ee205d3806/ijson/utils35.py#l19>`_\n     for some inspiration).\n\n   in the future ijson might offer something out of the box\n   to deal with invalid utf-8 byte sequences.\n\n#. **q**: i'm getting ``parse error: trailing garbage`` or ``additional data found`` errors\n\n   **a**: this error signals that the input\n   contains more data than the top-level json value it's meant to contain.\n   this is *usually* caused by json data sources\n   containing multiple values, and is *usually* solved\n   by passing the ``multiple_values=true`` to the ijson function in use.\n   see the options_ section for details.\n\n#. **q**: are there any differences between the backends?\n\n   **a**: apart from their performance,\n   all backends are designed to support the same capabilities.\n   there are however some small known differences:\n\n   * the ``yajl`` backend doesn't support ``multiple_values=true``.\n     it also doesn't complain about additional data\n     found after the end of the top-level json object.\n     when using ``use_float=true`` it also doesn't properly support\n     values greater than 2^32 in 32-bit platforms or windows.\n     numbers with leading zeros are not reported as invalid\n     (although they are invalid json numbers).\n     incomplete json tokens at the end of an incomplete document\n     (e.g., ``{\"a\": fals``) are not reported as ``incompletejsonerror``.\n\n   * the ``python`` backend doesn't support ``allow_comments=true``\n     it also internally works with ``str`` objects, not ``bytes``,\n     but this is an internal detail that users shouldn't need to worry about,\n     and might change in the future.\n\n\nacknowledgements\n================\n\nijson was originally developed and actively maintained until 2016\nby `ivan sagalaev <http://softwaremaniacs.org/>`_.\nin 2019 he\n`handed over <https://github.com/isagalaev/ijson/pull/58#issuecomment-500596815>`_\nthe maintenance of the project and the pypi ownership.\n\npython parser in ijson is relatively simple thanks to `douglas crockford\n<http://www.crockford.com/>`_ who invented a strict, easy to parse syntax.\n\nthe `yajl <https://lloyd.github.io/yajl>`__ library by `lloyd hilaiel\n<http://lloyd.io/>`_ is the most popular and efficient way to parse json in an\niterative fashion.\n\nijson was inspired by `yajl-py <http://pykler.github.com/yajl-py/>`_ wrapper by\n`hatem nassrat <http://www.nassrat.ca/>`_. though ijson borrows almost nothing\nfrom the actual yajl-py code it was used as an example of integration with yajl\nusing ctypes.\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "ijson",
  "package_url": "https://pypi.org/project/ijson/",
  "project_url": "https://pypi.org/project/ijson/",
  "project_urls": {
    "Homepage": "https://github.com/ICRAR/ijson"
  },
  "release_url": "https://pypi.org/project/ijson/3.2.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "iterative json parser with standard python iterator interfaces",
  "version": "3.2.3",
  "releases": [],
  "developers": [
    "maniac@softwaremaniacs.org",
    "rodrigo_tobar",
    "rtobar@icrar.org"
  ],
  "kwds": "ijson_backend ijson yajl2_cffi iconv pypi",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_ijson",
  "homepage": "https://github.com/icrar/ijson",
  "release_count": 39,
  "dependency_ids": []
}