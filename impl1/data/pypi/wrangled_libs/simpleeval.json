{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "simpleeval (simple eval)\n========================\n\n.. image:: https://github.com/danthedeckie/simpleeval/actions/workflows/ci.yml/badge.svg?branch=gh-actions-build\n   :target: https://github.com/danthedeckie/simpleeval/actions/\n   :alt: build status\n\n.. image:: https://codecov.io/gh/danthedeckie/simpleeval/branch/master/graph/badge.svg?token=isrnn1yrca\n   :target: https://codecov.io/gh/danthedeckie/simpleeval\n   :alt: code coverage\n\n.. image:: https://badge.fury.io/py/simpleeval.svg\n   :target: https://badge.fury.io/py/simpleeval\n   :alt: pypi version\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/psf/black\n\n.. image:: https://img.shields.io/badge/linting-pylint-yellowgreen\n   :target: https://github.com/pycqa/pylint\n\n\na single file library for easily adding evaluatable expressions into\npython projects.  say you want to allow a user to set an alarm volume, which\ncould depend on the time of day, alarm level, how many previous alarms had gone\noff, and if there is music playing at the time.\n\nor if you want to allow simple formulae in a web application, but don't want to\ngive full eval() access, or don't want to run in javascript on the client side.\n\nit's deliberately trying to stay simple to use and not have millions of features,\npull it in from pypi (pip or easy_install), or even just a single file you can dump\ninto a project.\n\ninternally, it's using the amazing python ``ast`` module to parse the\nexpression, which allows very fine control of what is and isn't allowed.  it\nshould be completely safe in terms of what operations can be performed by the\nexpression.\n\nthe only issue i know to be aware of is that you can create an expression which\ntakes a long time to evaluate, or which evaluating requires an awful lot of\nmemory, which leaves the potential for dos attacks.  there is basic protection\nagainst this, and you can lock it down further if you desire. (see the\noperators_ section below)\n\nyou should be aware of this when deploying in a public setting.\n\nthe defaults are pretty locked down and basic, and it's easy to add\nwhatever extra specific functionality you need (your own functions,\nvariable/name lookup, etc).\n\nbasic usage\n-----------\n\nto get very simple evaluating:\n\n.. code-block:: python\n\n    from simpleeval import simple_eval\n\n    simple_eval(\"21 + 21\")\n\nreturns ``42``.\n\nexpressions can be as complex and convoluted as you want:\n\n.. code-block:: python\n\n    simple_eval(\"21 + 19 / 7 + (8 % 3) ** 9\")\n\nreturns ``535.714285714``.\n\nyou can add your own functions in as well.\n\n.. code-block:: python\n\n    simple_eval(\"square(11)\", functions={\"square\": lambda x: x*x})\n\nreturns ``121``.\n\nfor more details of working with functions, read further down.\n\nnote:\n~~~~~\nall further examples use ``>>>`` to designate python code, as if you are using\nthe python interactive prompt.\n\n.. _operators:\n\noperators\n---------\nyou can add operators yourself, using the ``operators`` argument, but these are\nthe defaults:\n\n+--------+------------------------------------+\n|  ``+`` | add two things. ``x + y``          |\n|        | ``1 + 1`` -> ``2``                 |\n+--------+------------------------------------+\n|  ``-`` | subtract two things ``x - y``      |\n|        | ``100 - 1`` -> ``99``              |\n+--------+------------------------------------+\n|  ``/`` | divide one thing by another        |\n|        | ``x / y``                          |\n|        | ``100/10`` -> ``10``               |\n+--------+------------------------------------+\n|  ``*`` | multiple one thing by another      |\n|        | ``x * y``                          |\n|        | ``10 * 10`` -> ``100``             |\n+--------+------------------------------------+\n| ``**`` | 'to the power of' ``x**y``         |\n|        | ``2 ** 10`` -> ``1024``            |\n+--------+------------------------------------+\n| ``%``  | modulus. (remainder)  ``x % y``    |\n|        | ``15 % 4`` -> ``3``                |\n+--------+------------------------------------+\n| ``==`` | equals  ``x == y``                 |\n|        | ``15 == 4`` -> ``false``           |\n+--------+------------------------------------+\n| ``<``  | less than. ``x < y``               |\n|        | ``1 < 4`` -> ``true``              |\n+--------+------------------------------------+\n| ``>``  | greater than. ``x > y``            |\n|        | ``1 > 4`` -> ``false``             |\n+--------+------------------------------------+\n| ``<=`` | less than or equal to. ``x <= y``  |\n|        | ``1 < 4`` -> ``true``              |\n+--------+------------------------------------+\n| ``>=`` | greater or equal to ``x >= 21``    |\n|        | ``1 >= 4`` -> ``false``            |\n+--------+------------------------------------+\n| ``>>`` | \"right shift\" the number.          |\n|        | ``100 >> 2`` -> ``25``             |\n+--------+------------------------------------+\n| ``<<`` | \"left shift\" the number.           |\n|        | ``100 << 2`` -> ``400``            |\n+--------+------------------------------------+\n| ``in`` | is something contained within      |\n|        | something else.                    |\n|        | ``\"spam\" in \"my breakfast\"``       |\n|        | -> ``false``                       |\n+--------+------------------------------------+\n| ``^``  | \"bitwise exclusive or\" (xor)       |\n|        | ``62 ^ 20`` -> ``42``              |\n+--------+------------------------------------+\n| ``|``  | \"bitwise or\"                       |\n|        | ``8 | 34`` -> ``42``               |\n+--------+------------------------------------+\n| ``&``  | \"bitwise and\"                      |\n|        | ``100 & 63`` -> ``36``             |\n+--------+------------------------------------+\n| ``~``  | \"bitwise invert\"                   |\n|        | ``~ -43`` -> ``42``                |\n+--------+------------------------------------+\n\n\nthe ``^`` operator is often mistaken for a exponent operator, not the bitwise \noperation that it is in python, so if you want ``3 ^ 2`` to equal ``9``, you can\nreplace the operator like this:\n\n.. code-block:: python\n\n    >>> import ast\n    >>> from simpleeval import safe_power\n\n    >>> s = simpleeval()\n    >>> s.operators[ast.bitxor] = safe_power\n\n    >>> s.eval(\"3 ^ 2\")\n    9\n\nfor example.\n\nlimited power\n~~~~~~~~~~~~~\n\nalso note, the ``**`` operator has been locked down by default to have a\nmaximum input value of ``4000000``, which makes it somewhat harder to make\nexpressions which go on for ever.  you can change this limit by changing the\n``simpleeval.power_max`` module level value to whatever is an appropriate value\nfor you (and the hardware that you're running on) or if you want to completely\nremove all limitations, you can set the ``s.operators[ast.pow] = operator.pow``\nor make your own function.\n\non my computer, ``9**9**5`` evaluates almost instantly, but ``9**9**6`` takes\nover 30 seconds.  since ``9**7`` is ``4782969``, and so over the ``power_max``\nlimit, it throws a ``numbertoohigh`` exception for you. (otherwise it would go\non for hours, or until the computer runs out of memory)\n\nstrings (and other iterables) safety\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthere are also limits on string length (100000 characters,\n``max_string_length``).  this can be changed if you wish.\n\nrelated to this, if you try to create a silly long string/bytes/list, by doing\n``'i want to break free'.split() * 9999999999`` for instance, it will block you.\n\nif expressions\n--------------\n\nyou can use python style ``if x then y else z`` type expressions:\n\n.. code-block:: python\n\n    >>> simple_eval(\"'equal' if x == y else 'not equal'\",\n                    names={\"x\": 1, \"y\": 2})\n    'not equal'\n\nwhich, of course, can be nested:\n\n.. code-block:: python\n\n    >>> simple_eval(\"'a' if 1 == 2 else 'b' if 2 == 3 else 'c'\")\n    'c'\n\n\nfunctions\n---------\n\nyou can define functions which you'd like the expresssions to have access to:\n\n.. code-block:: python\n\n    >>> simple_eval(\"double(21)\", functions={\"double\": lambda x:x*2})\n    42\n\nyou can define \"real\" functions to pass in rather than lambdas, of course too,\nand even re-name them so that expressions can be shorter\n\n.. code-block:: python\n\n    >>> def double(x):\n            return x * 2\n    >>> simple_eval(\"d(100) + double(1)\", functions={\"d\": double, \"double\":double})\n    202\n\nif you don't provide your own ``functions`` dict, then the the following defaults\nare provided in the ``default_functions`` dict:\n\n+----------------+--------------------------------------------------+\n| ``randint(x)`` | return a random ``int`` below ``x``              |\n+----------------+--------------------------------------------------+\n| ``rand()``     | return a random ``float`` between 0 and 1        |\n+----------------+--------------------------------------------------+\n| ``int(x)``     | convert ``x`` to an ``int``.                     |\n+----------------+--------------------------------------------------+\n| ``float(x)``   | convert ``x`` to a ``float``.                    |\n+----------------+--------------------------------------------------+\n| ``str(x)``     | convert ``x`` to a ``str`` (``unicode`` in py2)  |\n+----------------+--------------------------------------------------+\n\nif you want to provide a list of functions, but want to keep these as well,\nthen you can do a normal python ``.copy()`` & ``.update``:\n\n.. code-block:: python\n\n    >>> my_functions = simpleeval.default_functions.copy()\n    >>> my_functions.update(\n            square=(lambda x:x*x),\n            double=(lambda x:x+x),\n        )\n    >>> simple_eval('square(randint(100))', functions=my_functions)\n\nnames\n-----\n\nsometimes it's useful to have variables available, which in python terminology\nare called 'names'.\n\n.. code-block:: python\n\n    >>> simple_eval(\"a + b\", names={\"a\": 11, \"b\": 100})\n    111\n\nyou can also hand the handling of names over to a function, if you prefer:\n\n\n.. code-block:: python\n\n    >>> def name_handler(node):\n            return ord(node.id[0].lower(a))-96\n\n    >>> simple_eval('a + b', names=name_handler)\n    3\n\nthat was a bit of a silly example, but you could use this for pulling values\nfrom a database or file, say, or doing some kind of caching system.\n\nthe two default names that are provided are ``true`` and ``false``.  so if you want to provide your own names, but want ``true`` and ``false`` to keep working, either provide them yourself, or ``.copy()`` and ``.update`` the ``default_names``. (see functions example above).\n\ncreating an evaluator class\n---------------------------\n\nrather than creating a new evaluator each time, if you are doing a lot of\nevaluations, you can create a simpleeval object, and pass it expressions each\ntime (which should be a bit quicker, and certainly more convenient for some use\ncases):\n\n.. code-block:: python\n\n    >>> s = simpleeval()\n\n    >>> s.eval(\"1 + 1\")\n    2\n\n    >>> s.eval('100 * 10')\n    1000\n\n    # and so on...\n\none useful feature of using the ``simpleeval`` object is that you can parse an expression\nonce, and then evaluate it mulitple times using different ``names``:\n\n.. code-block:: python\n\n    # set up & cache the parse tree:\n    expression = \"foo + bar\"\n    parsed = s.parse(expression)\n\n    # evaluate the expression multiple times:\n    for names in [{\"foo\": 1, \"bar\": 10}, {\"foo\": 100, \"bar\": 42}]:\n        s.names = names\n        print(s.eval(expression, previously_parsed=parsed))\n\nfor instance.  this may help with performance.\n\nyou can assign / edit the various options of the ``simpleeval`` object if you\nwant to.  either assign them during creation (like the ``simple_eval``\nfunction)\n\n.. code-block:: python\n\n    def boo():\n        return 'boo!'\n\n    s = simpleeval(functions={\"boo\": boo})\n\nor edit them after creation:\n\n.. code-block:: python\n\n    s.names['fortytwo'] = 42\n\nthis actually means you can modify names (or functions) with functions, if you\nreally feel so inclined:\n\n.. code-block:: python\n\n    s = simpleeval()\n    def set_val(name, value):\n        s.names[name.value] = value.value\n        return value.value\n\n    s.functions = {'set': set_val}\n\n    s.eval(\"set('age', 111)\")\n\nsay.  this would allow a certain level of 'scriptyness' if you had these\nevaluations happening as callbacks in a program.  although you really are\nreaching the end of what this library is intended for at this stage.\n\ncompound types\n--------------\n\ncompound types (``dict``, ``tuple``, ``list``, ``set``) in general just work if\nyou pass them in as named objects.  if you want to allow creation of these, the\n``evalwithcompoundtypes`` class works.  just replace any use of ``simpleeval`` with\nthat.\n\nthe ``evalwithcompoundtypes`` class also contains support for simple comprehensions.\neg: ``[x + 1 for x in [1,2,3]]``.  there's a safety `max_comprehension_length` to control\nhow many items it'll allow before bailing too.  this also takes into account nested\ncomprehensions.\n\nsince the primary intention of this library is short expressions - an extra 'sweetener' is\nenabled by default.  you can access a dict (or similar's) keys using the .attr syntax:\n\n.. code-block:: python\n\n    >>>  simple_eval(\"foo.bar\", names={\"foo\": {\"bar\": 42}})\n    42\n\nfor instance.  you can turn this off either by setting the module global `attr_index_fallback`\nto `false`, or on the ``simpleeval`` instance itself. e.g. ``evaller.attr_index_fallback=false``.\n\nextending\n---------\n\nthe ``simpleeval`` class is pretty easy to extend.  for instance, to create a\nversion that disallows method invocation on objects:\n\n.. code-block:: python\n\n    import ast\n    import simpleeval\n\n    class evalnomethods(simpleeval.simpleeval):\n        def _eval_call(self, node):\n            if isinstance(node.func, ast.attribute):\n                raise simpleeval.featurenotavailable(\"no methods please, we're british\")\n            return super(evalnomethods, self)._eval_call(node)\n\nand then use ``evalnomethods`` instead of the ``simpleeval`` class.\n\nother...\n--------\n\nthe library supports python 3 - but should be mostly compatible (and tested before 0.9.11)\nwith python 2.7 as well.\n\nobject attributes that start with ``_`` or ``func_`` are disallowed by default.\nif you really need that (be careful!), then modify the module global\n``simpleeval.disallow_prefixes``.\n\na few builtin functions are listed in ``simpleeval.disallow_functions``.  ``type``, ``open``, etc.\nif you need to give access to this kind of functionality to your expressions, then be very\ncareful.  you'd be better wrapping the functions in your own safe wrappers.\n\nthe initial idea came from j.f. sebastian on stack overflow\n( http://stackoverflow.com/a/9558001/1973500 ) with modifications and many improvements,\nsee the head of the main file for contributors list.\n\nplease read the ``test_simpleeval.py`` file for other potential gotchas or\ndetails.  i'm very happy to accept pull requests, suggestions, or other issues.\nenjoy!\n\ndeveloping\n----------\n\nrun tests::\n\n    $ make test\n\nor to set the tests running on every file change:\n\n    $ make autotest\n\n(requires ``entr``) \n\ni'm trying to keep the codebase relatively clean with black, isort, pylint & mypy.\nsee::\n\n    $ make format\n\nand::\n\n    $ make lint\n\nbeware\n------\n\ni've done the best i can with this library - but there's no warranty, no guarantee, nada.  a lot of\nvery clever people think the whole idea of trying to sandbox cpython is impossible.  read the code\nyourself, and use it at your own risk.\n",
  "docs_url": null,
  "keywords": "eval,simple,expression,parse,ast",
  "license": "",
  "name": "simpleeval",
  "package_url": "https://pypi.org/project/simpleeval/",
  "project_url": "https://pypi.org/project/simpleeval/",
  "project_urls": {
    "Homepage": "https://github.com/danthedeckie/simpleeval"
  },
  "release_url": "https://pypi.org/project/simpleeval/0.9.13/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a simple, safe single expression evaluator library.",
  "version": "0.9.13",
  "releases": [],
  "developers": [
    "daniel_fairhead",
    "danthedeckie@gmail.com"
  ],
  "kwds": "simple_eval simpleeval test_simpleeval eval evaluator",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_simpleeval",
  "homepage": "https://github.com/danthedeckie/simpleeval",
  "release_count": 18,
  "dependency_ids": []
}