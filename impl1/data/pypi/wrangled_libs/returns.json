{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: hypothesis",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities",
    "typing :: typed"
  ],
  "description": "[![returns logo](https://raw.githubusercontent.com/dry-python/brand/master/logo/returns_white-outline.png)](https://github.com/dry-python/returns)\n\n-----\n\n[![build status](https://github.com/dry-python/returns/workflows/test/badge.svg?branch=master&event=push)](https://github.com/dry-python/returns/actions?query=workflow%3atest)\n[![codecov](https://codecov.io/gh/dry-python/returns/branch/master/graph/badge.svg)](https://codecov.io/gh/dry-python/returns)\n[![documentation status](https://readthedocs.org/projects/returns/badge/?version=latest)](https://returns.readthedocs.io/en/latest/?badge=latest)\n[![python version](https://img.shields.io/pypi/pyversions/returns.svg)](https://pypi.org/project/returns/)\n[![wemake-python-styleguide](https://img.shields.io/badge/style-wemake-000000.svg)](https://github.com/wemake-services/wemake-python-styleguide)\n[![telegram chat](https://img.shields.io/badge/chat-join-blue?logo=telegram)](https://t.me/drypython)\n\n-----\n\nmake your functions return something meaningful, typed, and safe!\n\n\n## features\n\n- brings functional programming to python land\n- provides a bunch of primitives to write declarative business logic\n- enforces better architecture\n- fully typed with annotations and checked with `mypy`, [pep561 compatible](https://www.python.org/dev/peps/pep-0561/)\n- adds emulated higher kinded types support\n- provides type-safe interfaces to create your own data-types with enforced laws\n- has a bunch of helpers for better composition\n- pythonic and pleasant to write and to read \ud83d\udc0d\n- support functions and coroutines, framework agnostic\n- easy to start: has lots of docs, tests, and tutorials\n\n[quickstart](https://returns.readthedocs.io/en/latest/pages/quickstart.html) right now!\n\n\n## installation\n\n```bash\npip install returns\n```\n\nyou can also install `returns` with the latest supported `mypy` version:\n\n```bash\npip install returns[compatible-mypy]\n```\n\nyou would also need to configure our [`mypy` plugin](https://returns.readthedocs.io/en/latest/pages/contrib/mypy_plugins.html):\n\n```ini\n# in setup.cfg or mypy.ini:\n[mypy]\nplugins =\n  returns.contrib.mypy.returns_plugin\n```\n\nor:\n\n```toml\n[tool.mypy]\nplugins = [\"returns.contrib.mypy.returns_plugin\"]\n```\n\nwe also recommend to use the same `mypy` settings [we use](https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/mypy.toml).\n\nmake sure you know how to get started, [check out our docs](https://returns.readthedocs.io/en/latest/)!\n[try our demo](https://repl.it/@sobolevn/returns#ex.py).\n\n\n## contents\n\n- [maybe container](#maybe-container) that allows you to write `none`-free code\n- [requirescontext container](#requirescontext-container) that allows you to use typed functional dependency injection\n- [result container](#result-container) that let's you to get rid of exceptions\n- [io container](#io-container) and [ioresult](#troublesome-io) that marks all impure operations and structures them\n- [future container](#future-container) and [futureresult](#async-code-without-exceptions) to work with `async` code\n- [write your own container!](https://returns.readthedocs.io/en/latest/pages/create-your-own-container.html) you would still have all the features for your own types (including full existing code reuse and type-safety)\n\n\n## maybe container\n\n`none` is called the [worst mistake in the history of computer science](https://www.infoq.com/presentations/null-references-the-billion-dollar-mistake-tony-hoare/).\n\nso, what can we do to check for `none` in our programs?\nyou can use builtin [optional](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type) type\nand write a lot of `if some is not none:` conditions.\nbut, **having `null` checks here and there makes your code unreadable**.\n\n```python\nuser: optional[user]\ndiscount_program: optional['discountprogram'] = none\n\nif user is not none:\n     balance = user.get_balance()\n     if balance is not none:\n         credit = balance.credit_amount()\n         if credit is not none and credit > 0:\n             discount_program = choose_discount(credit)\n```\n\nor you can use\n[maybe](https://returns.readthedocs.io/en/latest/pages/maybe.html) container!\nit consists of `some` and `nothing` types,\nrepresenting existing state and empty (instead of `none`) state respectively.\n\n```python\nfrom typing import optional\nfrom returns.maybe import maybe, maybe\n\n@maybe  # decorator to convert existing optional[int] to maybe[int]\ndef bad_function() -> optional[int]:\n    ...\n\nmaybe_number: maybe[float] = bad_function().bind_optional(\n    lambda number: number / 2,\n)\n# => maybe will return some[float] only if there's a non-none value\n#    otherwise, will return nothing\n```\n\nyou can be sure that `.bind_optional()` method won't be called for `nothing`.\nforget about `none`-related errors forever!\n\nwe can also bind a `optional`-returning function over a container.\nto achieve this, we are going to use `.bind_optional` method.\n\nand here's how your initial refactored code will look:\n\n```python\nuser: optional[user]\n\n# type hint here is optional, it only helps the reader here:\ndiscount_program: maybe['discountprogram'] = maybe.from_optional(\n    user,\n).bind_optional(  # this won't be called if `user is none`\n    lambda real_user: real_user.get_balance(),\n).bind_optional(  # this won't be called if `real_user.get_balance()` is none\n    lambda balance: balance.credit_amount(),\n).bind_optional(  # and so on!\n    lambda credit: choose_discount(credit) if credit > 0 else none,\n)\n```\n\nmuch better, isn't it?\n\n\n## requirescontext container\n\nmany developers do use some kind of dependency injection in python.\nand usually it is based on the idea\nthat there's some kind of a container and assembly process.\n\nfunctional approach is much simpler!\n\nimagine that you have a `django` based game, where you award users with points for each guessed letter in a word (unguessed letters are marked as `'.'`):\n\n```python\nfrom django.http import httprequest, httpresponse\nfrom words_app.logic import calculate_points\n\ndef view(request: httprequest) -> httpresponse:\n    user_word: str = request.post['word']  # just an example\n    points = calculate_points(user_word)\n    ...  # later you show the result to user somehow\n\n# somewhere in your `words_app/logic.py`:\n\ndef calculate_points(word: str) -> int:\n    guessed_letters_count = len([letter for letter in word if letter != '.'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> int:\n    return 0 if guessed < 5 else guessed  # minimum 6 points possible!\n```\n\nawesome! it works, users are happy, your logic is pure and awesome.\nbut, later you decide to make the game more fun:\nlet's make the minimal accountable letters threshold\nconfigurable for an extra challenge.\n\nyou can just do it directly:\n\n```python\ndef _award_points_for_letters(guessed: int, threshold: int) -> int:\n    return 0 if guessed < threshold else guessed\n```\n\nthe problem is that `_award_points_for_letters` is deeply nested.\nand then you have to pass `threshold` through the whole callstack,\nincluding `calculate_points` and all other functions that might be on the way.\nall of them will have to accept `threshold` as a parameter!\nthis is not useful at all!\nlarge code bases will struggle a lot from this change.\n\nok, you can directly use `django.settings` (or similar)\nin your `_award_points_for_letters` function.\nand **ruin your pure logic with framework specific details**. that's ugly!\n\nor you can use `requirescontext` container. let's see how our code changes:\n\n```python\nfrom django.conf import settings\nfrom django.http import httprequest, httpresponse\nfrom words_app.logic import calculate_points\n\ndef view(request: httprequest) -> httpresponse:\n    user_word: str = request.post['word']  # just an example\n    points = calculate_points(user_words)(settings)  # passing the dependencies\n    ...  # later you show the result to user somehow\n\n# somewhere in your `words_app/logic.py`:\n\nfrom typing import protocol\nfrom returns.context import requirescontext\n\nclass _deps(protocol):  # we rely on abstractions, not direct values or types\n    word_threshold: int\n\ndef calculate_points(word: str) -> requirescontext[int, _deps]:\n    guessed_letters_count = len([letter for letter in word if letter != '.'])\n    return _award_points_for_letters(guessed_letters_count)\n\ndef _award_points_for_letters(guessed: int) -> requirescontext[int, _deps]:\n    return requirescontext(\n        lambda deps: 0 if guessed < deps.word_threshold else guessed,\n    )\n```\n\nand now you can pass your dependencies in a really direct and explicit way.\nand have the type-safety to check what you pass to cover your back.\ncheck out [requirescontext](https://returns.readthedocs.io/en/latest/pages/context.html) docs for more. there you will learn how to make `'.'` also configurable.\n\nwe also have [requirescontextresult](https://returns.readthedocs.io/en/latest/pages/context.html#requirescontextresult-container)\nfor context-related operations that might fail. and also [requirescontextioresult](https://returns.readthedocs.io/en/latest/pages/context.html#requirescontextioresult-container) and [requirescontextfutureresult](https://returns.readthedocs.io/en/latest/pages/context.html#requirescontextfutureresult-container).\n\n\n## result container\n\nplease, make sure that you are also aware of\n[railway oriented programming](https://fsharpforfunandprofit.com/rop/).\n\n### straight-forward approach\n\nconsider this code that you can find in **any** `python` project.\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> 'userprofile':\n    \"\"\"fetches userprofile dict from foreign api.\"\"\"\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response.json()\n```\n\nseems legit, does it not?\nit also seems like a pretty straightforward code to test.\nall you need is to mock `requests.get` to return the structure you need.\n\nbut, there are hidden problems in this tiny code sample\nthat are almost impossible to spot at the first glance.\n\n### hidden problems\n\nlet's have a look at the exact same code,\nbut with the all hidden problems explained.\n\n```python\nimport requests\n\ndef fetch_user_profile(user_id: int) -> 'userprofile':\n    \"\"\"fetches userprofile dict from foreign api.\"\"\"\n    response = requests.get('/api/users/{0}'.format(user_id))\n\n    # what if we try to find user that does not exist?\n    # or network will go down? or the server will return 500?\n    # in this case the next line will fail with an exception.\n    # we need to handle all possible errors in this function\n    # and do not return corrupt data to consumers.\n    response.raise_for_status()\n\n    # what if we have received invalid json?\n    # next line will raise an exception!\n    return response.json()\n```\n\nnow, all (probably all?) problems are clear.\nhow can we be sure that this function will be safe\nto use inside our complex business logic?\n\nwe really cannot be sure!\nwe will have to create **lots** of `try` and `except` cases\njust to catch the expected exceptions. our code will become complex and unreadable with all this mess!\n\nor we can go with the top level `except exception:` case\nto catch literally everything.\nand this way we would end up with catching unwanted ones.\nthis approach can hide serious problems from us for a long time.\n\n### pipe example\n\n```python\nimport requests\nfrom returns.result import result, safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind\n\ndef fetch_user_profile(user_id: int) -> result['userprofile', exception]:\n    \"\"\"fetches `userprofile` typeddict from foreign api.\"\"\"\n    return flow(\n        user_id,\n        _make_request,\n        bind(_parse_json),\n    )\n\n@safe\ndef _make_request(user_id: int) -> requests.response:\n    # todo: we are not yet done with this example, read more about `io`:\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.response) -> 'userprofile':\n    return response.json()\n```\n\nnow we have a clean and a safe and declarative way\nto express our business needs:\n\n- we start from making a request, that might fail at any moment,\n- then parsing the response if the request was successful,\n- and then return the result.\n\nnow, instead of returning regular values\nwe return values wrapped inside a special container\nthanks to the\n[@safe](https://returns.readthedocs.io/en/latest/pages/result.html#safe)\ndecorator. it will return [success[yourtype] or failure[exception]](https://returns.readthedocs.io/en/latest/pages/result.html).\nand will never throw exception at us!\n\nwe also use [flow](https://returns.readthedocs.io/en/latest/pages/pipeline.html#flow)\nand [bind](https://returns.readthedocs.io/en/latest/pages/pointfree.html#bind)\nfunctions for handy and declarative composition.\n\nthis way we can be sure that our code won't break in\nrandom places due to some implicit exception.\nnow we control all parts and are prepared for the explicit errors.\n\nwe are not yet done with this example,\nlet's continue to improve it in the next chapter.\n\n\n## io container\n\nlet's look at our example from another angle.\nall its functions look like regular ones:\nit is impossible to tell whether they are [pure](https://en.wikipedia.org/wiki/pure_function)\nor impure from the first sight.\n\nit leads to a very important consequence:\n*we start to mix pure and impure code together*.\nwe should not do that!\n\nwhen these two concepts are mixed\nwe suffer really bad when testing or reusing it.\nalmost everything should be pure by default.\nand we should explicitly mark impure parts of the program.\n\nthat's why we have created `io` container\nto mark impure functions that never fail.\n\nthese impure functions use `random`, current datetime, environment, or console:\n\n```python\nimport random\nimport datetime as dt\n\nfrom returns.io import io\n\ndef get_random_number() -> io[int]:  # or use `@impure` decorator\n    return io(random.randint(1, 10))  # isn't pure, because random\n\nnow: callable[[], io[dt.datetime]] = impure(dt.datetime.now)\n\n@impure\ndef return_and_show_next_number(previous: int) -> int:\n    next_number = previous + 1\n    print(next_number)  # isn't pure, because does io\n    return next_number\n```\n\nnow we can clearly see which functions are pure and which ones are impure.\nthis helps us a lot in building large applications, unit testing you code,\nand composing business logic together.\n\n### troublesome io\n\nas it was already said, we use `io` when we handle functions that do not fail.\n\nwhat if our function can fail and is impure?\nlike `requests.get()` we had earlier in our example.\n\nthen we have to use a special `ioresult` type instead of a regular `result`.\nlet's find the difference:\n\n- our `_parse_json` function always returns\n  the same result (hopefully) for the same input:\n  you can either parse valid `json` or fail on invalid one.\n  that's why we return pure `result`, there's no `io` inside\n- our `_make_request` function is impure and can fail.\n  try to send two similar requests with and without internet connection.\n  the result will be different for the same input.\n  that's why we must use `ioresult` here: it can fail and has `io`\n\nso, in order to fulfill our requirement and separate pure code from impure one,\nwe have to refactor our example.\n\n### explicit io\n\nlet's make our [io](https://returns.readthedocs.io/en/latest/pages/io.html)\nexplicit!\n\n```python\nimport requests\nfrom returns.io import ioresult, impure_safe\nfrom returns.result import safe\nfrom returns.pipeline import flow\nfrom returns.pointfree import bind_result\n\ndef fetch_user_profile(user_id: int) -> ioresult['userprofile', exception]:\n    \"\"\"fetches `userprofile` typeddict from foreign api.\"\"\"\n    return flow(\n        user_id,\n        _make_request,\n        # before: def (response) -> userprofile\n        # after safe: def (response) -> resulte[userprofile]\n        # after bind_result: def (ioresulte[response]) -> ioresulte[userprofile]\n        bind_result(_parse_json),\n    )\n\n@impure_safe\ndef _make_request(user_id: int) -> requests.response:\n    response = requests.get('/api/users/{0}'.format(user_id))\n    response.raise_for_status()\n    return response\n\n@safe\ndef _parse_json(response: requests.response) -> 'userprofile':\n    return response.json()\n```\n\nand later we can use [unsafe_perform_io](https://returns.readthedocs.io/en/latest/pages/io.html#unsafe-perform-io)\nsomewhere at the top level of our program to get the pure (or \"real\") value.\n\nas a result of this refactoring session, we know everything about our code:\n\n- which parts can fail,\n- which parts are impure,\n- how to compose them in a smart, readable, and typesafe manner.\n\n\n## future container\n\nthere are several issues with `async` code in python:\n\n1. you cannot call `async` function from a sync one\n2. any unexpectedly thrown exception can ruin your whole event loop\n3. ugly composition with lots of `await` statements\n\n`future` and `futureresult` containers solve these issues!\n\n### mixing sync and async code\n\nthe main feature of [future](https://returns.readthedocs.io/en/latest/pages/future.html)\nis that it allows to run async code\nwhile maintaining sync context. let's see an example.\n\nlet's say we have two functions,\nthe `first` one returns a number and the `second` one increments it:\n\n```python\nasync def first() -> int:\n    return 1\n\ndef second():  # how can we call `first()` from here?\n    return first() + 1  # boom! don't do this. we illustrate a problem here.\n```\n\nif we try to just run `first()`, we will just create an unawaited coroutine.\nit won't return the value we want.\n\nbut, if we would try to run `await first()`,\nthen we would need to change `second` to be `async`.\nand sometimes it is not possible for various reasons.\n\nhowever, with `future` we can \"pretend\" to call async code from sync code:\n\n```python\nfrom returns.future import future\n\ndef second() -> future[int]:\n    return future(first()).map(lambda num: num + 1)\n```\n\nwithout touching our `first` async function\nor making `second` async we have achieved our goal.\nnow, our async value is incremented inside a sync function.\n\nhowever, `future` still requires to be executed inside a proper eventloop:\n\n```python\nimport anyio  # or asyncio, or any other lib\n\n# we can then pass our `future` to any library: asyncio, trio, curio.\n# and use any event loop: regular, uvloop, even a custom one, etc\nassert anyio.run(second().awaitable) == 2\n```\n\nas you can see `future` allows you\nto work with async functions from a sync context.\nand to mix these two realms together.\nuse raw `future` for operations that cannot fail or raise exceptions.\npretty much the same logic we had with our `io` container.\n\n### async code without exceptions\n\nwe have already covered how [`result`](#result-container) works\nfor both pure and impure code.\nthe main idea is: we don't raise exceptions, we return them.\nit is **especially** critical in async code,\nbecause a single exception can ruin\nall our coroutines running in a single eventloop.\n\nwe have a handy combination of `future` and `result` containers: `futureresult`.\nagain, this is exactly like `ioresult`, but for impure async code.\nuse it when your `future` might have problems:\nlike http requests or filesystem operations.\n\nyou can easily turn any wild throwing coroutine into a calm `futureresult`:\n\n```python\nimport anyio\nfrom returns.future import future_safe\nfrom returns.io import iofailure\n\n@future_safe\nasync def raising():\n    raise valueerror('not so fast!')\n\nioresult = anyio.run(raising.awaitable)  # all `future`s return io containers\nassert ioresult == iofailure(valueerror('not so fast!'))  # true\n```\n\nusing `futureresult` will keep your code safe from exceptions.\nyou can always `await` or execute inside an eventloop any `futureresult`\nto get sync `ioresult` instance to work with it in a sync manner.\n\n### better async composition\n\npreviously, you had to do quite a lot of `await`ing while writing `async` code:\n\n```python\nasync def fetch_user(user_id: int) -> 'user':\n    ...\n\nasync def get_user_permissions(user: 'user') -> 'permissions':\n    ...\n\nasync def ensure_allowed(permissions: 'permissions') -> bool:\n    ...\n\nasync def main(user_id: int) -> bool:\n    # also, don't forget to handle all possible errors with `try / except`!\n    user = await fetch_user(user_id)  # we will await each time we use a coro!\n    permissions = await get_user_permissions(user)\n    return await ensure_allowed(permissions)\n```\n\nsome people are ok with it, but some people don't like this imperative style.\nthe problem is that there was no choice.\n\nbut now, you can do the same thing in functional style!\nwith the help of `future` and `futureresult` containers:\n\n```python\nimport anyio\nfrom returns.future import futureresulte, future_safe\nfrom returns.io import iosuccess, iofailure\n\n@future_safe\nasync def fetch_user(user_id: int) -> 'user':\n    ...\n\n@future_safe\nasync def get_user_permissions(user: 'user') -> 'permissions':\n    ...\n\n@future_safe\nasync def ensure_allowed(permissions: 'permissions') -> bool:\n    ...\n\ndef main(user_id: int) -> futureresulte[bool]:\n    # we can now turn `main` into a sync function, it does not `await` at all.\n    # we also don't care about exceptions anymore, they are already handled.\n    return fetch_user(user_id).bind(get_user_permissions).bind(ensure_allowed)\n\ncorrect_user_id: int  # has required permissions\nbanned_user_id: int  # does not have required permissions\nwrong_user_id: int  # does not exist\n\n# we can have correct business results:\nassert anyio.run(main(correct_user_id).awaitable) == iosuccess(true)\nassert anyio.run(main(banned_user_id).awaitable) == iosuccess(false)\n\n# or we can have errors along the way:\nassert anyio.run(main(wrong_user_id).awaitable) == iofailure(\n    userdoesnotexisterror(...),\n)\n```\n\nor even something really fancy:\n\n```python\nfrom returns.pointfree import bind\nfrom returns.pipeline import flow\n\ndef main(user_id: int) -> futureresulte[bool]:\n    return flow(\n        fetch_user(user_id),\n        bind(get_user_permissions),\n        bind(ensure_allowed),\n    )\n```\n\nlater we can also refactor our logical functions to be sync\nand to return `futureresult`.\n\nlovely, isn't it?\n\n\n## more!\n\nwant more?\n[go to the docs!](https://returns.readthedocs.io)\nor read these articles:\n\n- [python exceptions considered an anti-pattern](https://sobolevn.me/2019/02/python-exceptions-considered-an-antipattern)\n- [enforcing single responsibility principle in python](https://sobolevn.me/2019/03/enforcing-srp)\n- [typed functional dependency injection in python](https://sobolevn.me/2020/02/typed-functional-dependency-injection)\n- [how async should have been](https://sobolevn.me/2020/06/how-async-should-have-been)\n- [higher kinded types in python](https://sobolevn.me/2020/10/higher-kinded-types-in-python)\n- [make tests a part of your app](https://sobolevn.me/2021/02/make-tests-a-part-of-your-app)\n\ndo you have an article to submit? feel free to open a pull request!\n",
  "docs_url": null,
  "keywords": "functional programming,fp,monads,monad,monad transformers,composition,type-safety,mypy,railway-oriented-programming",
  "license": "bsd-3-clause",
  "name": "returns",
  "package_url": "https://pypi.org/project/returns/",
  "project_url": "https://pypi.org/project/returns/",
  "project_urls": {
    "Funding": "https://github.com/sponsors/dry-python",
    "Homepage": "https://returns.readthedocs.io",
    "Repository": "https://github.com/dry-python/returns"
  },
  "release_url": "https://pypi.org/project/returns/0.22.0/",
  "requires_dist": [
    "typing-extensions (>=4.0,<5.0)",
    "mypy (>=1.5,<1.6) ; extra == \"compatible-mypy\""
  ],
  "requires_python": ">=3.8.1,<4.0",
  "summary": "make your functions return something meaningful, typed, and safe!",
  "version": "0.22.0",
  "releases": [],
  "developers": [
    "mail@sobolevn.me",
    "sobolevn"
  ],
  "kwds": "monad monads workflows pythonic documentation",
  "license_kwds": "bsd-3-clause",
  "libtype": "pypi",
  "id": "pypi_returns",
  "homepage": "https://returns.readthedocs.io",
  "release_count": 23,
  "dependency_ids": [
    "pypi_mypy",
    "pypi_typing_extensions"
  ]
}