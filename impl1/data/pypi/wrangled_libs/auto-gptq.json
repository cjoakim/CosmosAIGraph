{
  "classifiers": [
    "environment :: gpu :: nvidia cuda :: 11.7",
    "environment :: gpu :: nvidia cuda :: 11.8",
    "environment :: gpu :: nvidia cuda :: 12",
    "license :: osi approved :: mit license",
    "natural language :: chinese (simplified)",
    "natural language :: english",
    "programming language :: c++",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "<h1 align=\"center\">autogptq</h1>\n<p align=\"center\">an easy-to-use llms quantization package with user-friendly apis, based on gptq algorithm.</p>\n<p align=\"center\">\n    <a href=\"https://github.com/panqiwei/autogptq/releases\">\n        <img alt=\"github release\" src=\"https://img.shields.io/github/release/panqiwei/autogptq.svg\">\n    </a>\n    <a href=\"https://pypi.org/project/auto-gptq/\">\n        <img alt=\"pypi - downloads\" src=\"https://img.shields.io/pypi/dd/auto-gptq\">\n    </a>\n</p>\n<h4 align=\"center\">\n    <p>\n        <b>english</b> |\n        <a href=\"https://github.com/panqiwei/autogptq/blob/main/readme_zh.md\">\u4e2d\u6587</a>\n    </p>\n</h4>\n\n<details>\n\n<summary>the path to v1.0.0</summary>\n\nhi, fellow community members, long time no see! i'm sorry that i haven't been able to update this project more frequently due to personal reasons during this period. the past few weeks have been huge in terms of my career plans. not long ago, i officially bid farewell to the startup team that i joined for two years after graduation. i'm very grateful to the leaders and colleagues of the team for their trust and guidance, which enabled me to grow rapidly in two years; at the same time, i'm also really grateful to the team for allowing me to use the internal a100 gpu server cluster free of charge since the start of the autogptq project to complete various experiments and performance evaluations. (of course, it can no longer be used in the future, so **it will mean a lot to me if there will be new hardware sponsorship!**) in the past two years, i have served as an ai engineer in this team, responsible for the llm based dialogue system's architecture design and develop. we had successfully launched a product called gemsouls, but unfortunately it has ceased operations. now, the team is about to launch a new product called [modelize](https://www.beta.modelize.ai/), which is **a llm-native ai agent platform, where users can use multiple ai agents to build a highly automated team, allowing them to interact with each other in the workflow, collaborate to complete complex projects efficiently.**\n\ngetting back to the topic, i'm very excited to see that in the past few months, research on optimizing the inference performance of llms has made tremendous progress. now we can not only complete the inference of llms on high-end gpus efficiently, but also on cpus and even edge devices. a series of technological advancements make me eager to make more contributions to the open source community. therefore, i will first use about four weeks to gradually update autogptq to the v1.0.0 official version. during this period, there will also be 2~3 minor versions are released to allow users to experience performance optimization and new features timely. in my vision, **by the time v1.0.0 is officially released, autogptq will be able to serve as an extendable and flexible quantization backend that supports all gptq-like methods and automatically quantize llms written by pytorch**. i detailed the development plan in [this issue](https://github.com/panqiwei/autogptq/issues/348), feel free to drop in there for discussion and give your suggestions!\n\n</details>\n\n## news or update\n\n- 2023-08-23 - (news) - \ud83e\udd17 transformers, optimum and peft have integrated `auto-gptq`, so now running and training gptq models can be more available to everyone! see [this blog](https://huggingface.co/blog/gptq-integration) and it's resources for more details!\n- 2023-08-21 - (news) - team of qwen officially released 4bit quantized version of qwen-7b based on `auto-gptq`, and provided [a detailed benchmark results](https://huggingface.co/qwen/qwen-7b-chat-int4#%e9%87%8f%e5%8c%96-quantization)\n- 2023-08-06 - (update) - support exllama's q4 cuda kernel to have at least 1.3x speed up for int4 quantized models when doing inference.\n- 2023-08-04 - (update) - support rocm so that amd gpu users can use auto-gptq with cuda extensions.\n- 2023-07-26 - (update) - an elegant [ppl benchmark script](examples/benchmark/perplexity.py) to get results that can be fairly compared with other libraries such as `llama.cpp`.\n- 2023-06-05 - (update) - integrate with \ud83e\udd17 peft to use gptq quantized model to train adapters, support lora, adalora, adaptionprompt, etc.\n- 2023-05-30 - (update) - support download/upload quantized model from/to \ud83e\udd17 hub.\n\n*for more histories please turn to [here](docs/news_or_update.md)*\n\n## performance comparison\n\n### inference speed\n> the result is generated using [this script](examples/benchmark/generation_speed.py), batch size of input is 1, decode strategy is beam search and enforce the model to generate 512 tokens, speed metric is tokens/s (the larger, the better).\n>\n> the quantized model is loaded using the setup that can gain the fastest inference speed.\n\n| model         | gpu           | num_beams | fp16  | gptq-int4 |\n|---------------|---------------|-----------|-------|-----------|\n| llama-7b      | 1xa100-40g    | 1         | 18.87 | 25.53     |\n| llama-7b      | 1xa100-40g    | 4         | 68.79 | 91.30     |\n| moss-moon 16b | 1xa100-40g    | 1         | 12.48 | 15.25     |\n| moss-moon 16b | 1xa100-40g    | 4         | oom   | 42.67     |\n| moss-moon 16b | 2xa100-40g    | 1         | 06.83 | 06.78     |\n| moss-moon 16b | 2xa100-40g    | 4         | 13.10 | 10.80     |\n| gpt-j 6b      | 1xrtx3060-12g | 1         | oom   | 29.55     |\n| gpt-j 6b      | 1xrtx3060-12g | 4         | oom   | 47.36     |\n\n\n### perplexity\nfor perplexity comparison, you can turn to [here](https://github.com/qwopqwop200/gptq-for-llama#result) and [here](https://github.com/qwopqwop200/gptq-for-llama#gptq-vs-bitsandbytes)\n\n## installation\n\n### quick installation\nyou can install the latest stable release of autogptq from pip with pre-built wheels compatible with **pytorch 2.1**:\n\n* for cuda 12.1: `pip install auto-gptq`\n* for cuda 11.8: `pip install auto-gptq --extra-index-url https://huggingface.github.io/autogptq-index/whl/cu118/`\n* for rocm 5.6.1: `pip install auto-gptq --extra-index-url https://huggingface.github.io/autogptq-index/whl/rocm561/`\n* for rocm 5.7.1: `pip install auto-gptq --extra-index-url https://huggingface.github.io/autogptq-index/whl/rocm571/`\n\nautogptq can be installed with the triton dependency with `pip install auto-gptq[triton]` in order to be able to use the triton backend (currently only supports linux, no 3-bits quantization).\n\n### install from source\n\nclone the source code:\n```shell\ngit clone https://github.com/panqiwei/autogptq.git && cd autogptq\n\na few packages are required in order to build from source: `pip install numpy gekko pandas`.\n\n```\nthen, install from source:\n```shell\npip install -v .\n```\nyou can set `build_cuda_ext=0` to disable pytorch extension building, but this is **strongly discouraged** as autogptq then falls back on a slow python implementation.\n\n#### on rocm systems\n\nto install from source for amd gpus supporting rocm, please specify the `rocm_version` environment variable. example:\n\n```\nrocm_version=5.6 pip install -v -e .\n```\n\nthe compilation can be speeded up by specifying the `pytorch_rocm_arch` variable ([reference](https://github.com/pytorch/pytorch/blob/7b73b1e8a73a1777ebe8d2cd4487eb13da55b3ba/setup.py#l132)) in order to build for a single target device, for example `gfx90a` for mi200 series devices.\n\nfor rocm systems, the packages `rocsparse-dev`, `hipsparse-dev`, `rocthrust-dev`, `rocblas-dev` and `hipblas-dev` are required to build.\n\nthe following combinations are tested:\n\n| rocm version | pytorch version |\n|--------------|-----------------|\n| 5.4.2        | 2.0.1           |\n| 5.6          | 2.1.0           |\n| 5.7          | nightly (2.2.0.dev2023)         |\n\n## quick tour\n\n### quantization and inference\n> warning: this is just a showcase of the usage of basic apis in autogptq, which uses only one sample to quantize a much small model, quality of quantized model using such little samples may not good.\n\nbelow is an example for the simplest use of `auto_gptq` to quantize a model and inference after quantization:\n```python\nfrom transformers import autotokenizer, textgenerationpipeline\nfrom auto_gptq import autogptqforcausallm, basequantizeconfig\nimport logging\n\nlogging.basicconfig(\n    format=\"%(asctime)s %(levelname)s [%(name)s] %(message)s\", level=logging.info, datefmt=\"%y-%m-%d %h:%m:%s\"\n)\n\npretrained_model_dir = \"facebook/opt-125m\"\nquantized_model_dir = \"opt-125m-4bit\"\n\ntokenizer = autotokenizer.from_pretrained(pretrained_model_dir, use_fast=true)\nexamples = [\n    tokenizer(\n        \"auto-gptq is an easy-to-use model quantization library with user-friendly apis, based on gptq algorithm.\"\n    )\n]\n\nquantize_config = basequantizeconfig(\n    bits=4,  # quantize model to 4-bit\n    group_size=128,  # it is recommended to set the value to 128\n    desc_act=false,  # set to false can significantly speed up inference but the perplexity may slightly bad\n)\n\n# load un-quantized model, by default, the model will always be loaded into cpu memory\nmodel = autogptqforcausallm.from_pretrained(pretrained_model_dir, quantize_config)\n\n# quantize model, the examples should be list of dict whose keys can only be \"input_ids\" and \"attention_mask\"\nmodel.quantize(examples)\n\n# save quantized model\nmodel.save_quantized(quantized_model_dir)\n\n# save quantized model using safetensors\nmodel.save_quantized(quantized_model_dir, use_safetensors=true)\n\n# push quantized model to hugging face hub.\n# to use use_auth_token=true, login first via huggingface-cli login.\n# or pass explcit token with: use_auth_token=\"hf_xxxxxxx\"\n# (uncomment the following three lines to enable this feature)\n# repo_id = f\"yourusername/{quantized_model_dir}\"\n# commit_message = f\"autogptq model for {pretrained_model_dir}: {quantize_config.bits}bits, gr{quantize_config.group_size}, desc_act={quantize_config.desc_act}\"\n# model.push_to_hub(repo_id, commit_message=commit_message, use_auth_token=true)\n\n# alternatively you can save and push at the same time\n# (uncomment the following three lines to enable this feature)\n# repo_id = f\"yourusername/{quantized_model_dir}\"\n# commit_message = f\"autogptq model for {pretrained_model_dir}: {quantize_config.bits}bits, gr{quantize_config.group_size}, desc_act={quantize_config.desc_act}\"\n# model.push_to_hub(repo_id, save_dir=quantized_model_dir, use_safetensors=true, commit_message=commit_message, use_auth_token=true)\n\n# load quantized model to the first gpu\nmodel = autogptqforcausallm.from_quantized(quantized_model_dir, device=\"cuda:0\")\n\n# download quantized model from hugging face hub and load to the first gpu\n# model = autogptqforcausallm.from_quantized(repo_id, device=\"cuda:0\", use_safetensors=true, use_triton=false)\n\n# inference with model.generate\nprint(tokenizer.decode(model.generate(**tokenizer(\"auto_gptq is\", return_tensors=\"pt\").to(model.device))[0]))\n\n# or you can also use pipeline\npipeline = textgenerationpipeline(model=model, tokenizer=tokenizer)\nprint(pipeline(\"auto-gptq is\")[0][\"generated_text\"])\n```\n\nfor more advanced features of model quantization, please reference to [this script](examples/quantization/quant_with_alpaca.py)\n\n### customize model\n<details>\n\n<summary>below is an example to extend `auto_gptq` to support `opt` model, as you will see, it's very easy:</summary>\n\n```python\nfrom auto_gptq.modeling import basegptqforcausallm\n\n\nclass optgptqforcausallm(basegptqforcausallm):\n    # chained attribute name of transformer layer block\n    layers_block_name = \"model.decoder.layers\"\n    # chained attribute names of other nn modules that in the same level as the transformer layer block\n    outside_layer_modules = [\n        \"model.decoder.embed_tokens\", \"model.decoder.embed_positions\", \"model.decoder.project_out\",\n        \"model.decoder.project_in\", \"model.decoder.final_layer_norm\"\n    ]\n    # chained attribute names of linear layers in transformer layer module\n    # normally, there are four sub lists, for each one the modules in it can be seen as one operation,\n    # and the order should be the order when they are truly executed, in this case (and usually in most cases),\n    # they are: attention q_k_v projection, attention output projection, mlp project input, mlp project output\n    inside_layer_modules = [\n        [\"self_attn.k_proj\", \"self_attn.v_proj\", \"self_attn.q_proj\"],\n        [\"self_attn.out_proj\"],\n        [\"fc1\"],\n        [\"fc2\"]\n    ]\n```\nafter this, you can use `optgptqforcausallm.from_pretrained` and other methods as shown in basic.\n\n</details>\n\n### evaluation on downstream tasks\nyou can use tasks defined in `auto_gptq.eval_tasks` to evaluate model's performance on specific down-stream task before and after quantization.\n\nthe predefined tasks support all causal-language-models implemented in [\ud83e\udd17 transformers](https://github.com/huggingface/transformers) and in this project.\n\n<details>\n\n<summary>below is an example to evaluate `eleutherai/gpt-j-6b` on sequence-classification task using `cardiffnlp/tweet_sentiment_multilingual` dataset:</summary>\n\n```python\nfrom functools import partial\n\nimport datasets\nfrom transformers import autotokenizer, automodelforcausallm, generationconfig\n\nfrom auto_gptq import autogptqforcausallm, basequantizeconfig\nfrom auto_gptq.eval_tasks import sequenceclassificationtask\n\n\nmodel = \"eleutherai/gpt-j-6b\"\ndataset = \"cardiffnlp/tweet_sentiment_multilingual\"\ntemplate = \"question:what's the sentiment of the given text? choices are {labels}.\\ntext: {text}\\nanswer:\"\nid2label = {\n    0: \"negative\",\n    1: \"neutral\",\n    2: \"positive\"\n}\nlabels = list(id2label.values())\n\n\ndef ds_refactor_fn(samples):\n    text_data = samples[\"text\"]\n    label_data = samples[\"label\"]\n\n    new_samples = {\"prompt\": [], \"label\": []}\n    for text, label in zip(text_data, label_data):\n        prompt = template.format(labels=labels, text=text)\n        new_samples[\"prompt\"].append(prompt)\n        new_samples[\"label\"].append(id2label[label])\n\n    return new_samples\n\n\n#  model = automodelforcausallm.from_pretrained(model).eval().half().to(\"cuda:0\")\nmodel = autogptqforcausallm.from_pretrained(model, basequantizeconfig())\ntokenizer = autotokenizer.from_pretrained(model)\n\ntask = sequenceclassificationtask(\n        model=model,\n        tokenizer=tokenizer,\n        classes=labels,\n        data_name_or_path=dataset,\n        prompt_col_name=\"prompt\",\n        label_col_name=\"label\",\n        **{\n            \"num_samples\": 1000,  # how many samples will be sampled to evaluation\n            \"sample_max_len\": 1024,  # max tokens for each sample\n            \"block_max_len\": 2048,  # max tokens for each data block\n            # function to load dataset, one must only accept data_name_or_path as input\n            # and return datasets.dataset\n            \"load_fn\": partial(datasets.load_dataset, name=\"english\"),\n            # function to preprocess dataset, which is used for datasets.dataset.map,\n            # must return dict[str, list] with only two keys: [prompt_col_name, label_col_name]\n            \"preprocess_fn\": ds_refactor_fn,\n            # truncate label when sample's length exceed sample_max_len\n            \"truncate_prompt\": false\n        }\n    )\n\n# note that max_new_tokens will be automatically specified internally based on given classes\nprint(task.run())\n\n# self-consistency\nprint(\n    task.run(\n        generation_config=generationconfig(\n            num_beams=3,\n            num_return_sequences=3,\n            do_sample=true\n        )\n    )\n)\n```\n\n</details>\n\n## learn more\n[tutorials](docs/tutorial) provide step-by-step guidance to integrate `auto_gptq` with your own project and some best practice principles.\n\n[examples](examples/readme.md) provide plenty of example scripts to use `auto_gptq` in different ways.\n\n## supported models\n\n> you can use `model.config.model_type` to compare with the table below to check whether the model you use is supported by `auto_gptq`.\n>\n> for example, model_type of `wizardlm`, `vicuna` and `gpt4all` are all `llama`, hence they are all supported by `auto_gptq`.\n\n| model type                         | quantization | inference | peft-lora | peft-ada-lora | peft-adaption_prompt                                                                            |\n|------------------------------------|--------------|-----------|-----------|---------------|-------------------------------------------------------------------------------------------------|\n| bloom                              | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n| gpt2                               | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n| gpt_neox                           | \u2705            | \u2705         | \u2705         | \u2705             | \u2705[requires this peft branch](https://github.com/panqiwei/peft/tree/multi_modal_adaption_prompt) |\n| gptj                               | \u2705            | \u2705         | \u2705         | \u2705             | \u2705[requires this peft branch](https://github.com/panqiwei/peft/tree/multi_modal_adaption_prompt) |\n| llama                              | \u2705            | \u2705         | \u2705         | \u2705             | \u2705                                                                                               |\n| moss                               | \u2705            | \u2705         | \u2705         | \u2705             | \u2705[requires this peft branch](https://github.com/panqiwei/peft/tree/multi_modal_adaption_prompt) |\n| opt                                | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n| gpt_bigcode                        | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n| codegen                            | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n| falcon(refinedwebmodel/refinedweb) | \u2705            | \u2705         | \u2705         | \u2705             |                                                                                                 |\n\n## supported evaluation tasks\ncurrently, `auto_gptq` supports: `languagemodelingtask`, `sequenceclassificationtask` and `textsummarizationtask`; more tasks will come soon!\n\n## running tests\n\ntests can be run with:\n\n```\npytest tests/ -s\n```\n\n## acknowledgement\n- specially thanks **elias frantar**, **saleh ashkboos**, **torsten hoefler** and **dan alistarh** for proposing **gptq** algorithm and open source the [code](https://github.com/ist-daslab/gptq).\n- specially thanks **qwopqwop200**, for code in this project that relevant to quantization are mainly referenced from [gptq-for-llama](https://github.com/qwopqwop200/gptq-for-llama/tree/cuda).\n\n\n[![star history chart](https://api.star-history.com/svg?repos=panqiwei/autogptq&type=date)](https://star-history.com/#panqiwei/autogptq&date)\n",
  "docs_url": null,
  "keywords": "gptq,quantization,large-language-models,transformers",
  "license": "",
  "name": "auto-gptq",
  "package_url": "https://pypi.org/project/auto-gptq/",
  "project_url": "https://pypi.org/project/auto-gptq/",
  "project_urls": {
    "Homepage": "https://github.com/PanQiWei/AutoGPTQ"
  },
  "release_url": "https://pypi.org/project/auto-gptq/0.6.0/",
  "requires_dist": [
    "accelerate >=0.22.0",
    "datasets",
    "sentencepiece",
    "numpy",
    "rouge",
    "gekko",
    "torch >=1.13.0",
    "safetensors",
    "transformers >=4.31.0",
    "peft >=0.5.0",
    "tqdm",
    "pytest ; extra == 'test'",
    "parameterized ; extra == 'test'",
    "triton ==2.0.0 ; extra == 'triton'"
  ],
  "requires_python": ">=3.8.0",
  "summary": "an easy-to-use llms quantization package with user-friendly apis, based on gptq algorithm.",
  "version": "0.6.0",
  "releases": [],
  "developers": [
    "panqiwei"
  ],
  "kwds": "autogptq auto_gptq autogptqforcausallm gptq optgptqforcausallm",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_auto_gptq",
  "homepage": "https://github.com/panqiwei/autogptq",
  "release_count": 13,
  "dependency_ids": [
    "pypi_accelerate",
    "pypi_datasets",
    "pypi_gekko",
    "pypi_numpy",
    "pypi_parameterized",
    "pypi_peft",
    "pypi_pytest",
    "pypi_rouge",
    "pypi_safetensors",
    "pypi_sentencepiece",
    "pypi_torch",
    "pypi_tqdm",
    "pypi_transformers",
    "pypi_triton"
  ]
}