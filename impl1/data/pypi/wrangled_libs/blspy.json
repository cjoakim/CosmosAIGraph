{
  "classifiers": [],
  "description": "# bls signatures implementation\n\n[![build and test c++, javascript, and python](https://github.com/chia-network/bls-signatures/actions/workflows/build-test.yaml/badge.svg)](https://github.com/chia-network/bls-signatures/actions/workflows/build-test.yaml)\n![pypi](https://img.shields.io/pypi/v/blspy?logo=pypi)\n![pypi - format](https://img.shields.io/pypi/format/blspy?logo=pypi)\n![github](https://img.shields.io/github/license/chia-network/bls-signatures?logo=github)\n\n[![codeql](https://github.com/chia-network/bls-signatures/actions/workflows/codeql.yml/badge.svg)](https://github.com/chia-network/bls-signatures/actions/workflows/codeql.yml)\n\n[![coverage status](https://coveralls.io/repos/github/chia-network/bls-signatures/badge.svg?branch=main)](https://coveralls.io/github/chia-network/bls-signatures?branch=main)\n\nnote: this library is not yet formally reviewed for security\n\nnote: this library was shifted to the ietf bls specification on 7/16/20\n\nimplements bls signatures with aggregation using [blst library](https://github.com/supranational/blst.git)\nfor cryptographic primitives (pairings, ec, hashing) according to the\n[ietf bls rfc](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/)\nwith [these curve parameters](https://datatracker.ietf.org/doc/draft-irtf-cfrg-pairing-friendly-curves/)\nfor bls12-381.\n\nfeatures:\n\n* non-interactive signature aggregation following ietf specification\n* works on windows, mac, linux, bsd\n* efficient verification using proof of posssesion (only one pairing per distinct message)\n* aggregate public keys and private keys\n* [eip-2333](https://eips.ethereum.org/eips/eip-2333) key derivation (including unhardened bip-32-like keys)\n* key and signature serialization\n* batch verification\n* [python bindings](https://github.com/chia-network/bls-signatures/tree/main/python-bindings)\n* [pure python bls12-381 and signatures](https://github.com/chia-network/bls-signatures/tree/main/python-impl)\n* [javascript bindings](https://github.com/chia-network/bls-signatures/tree/main/js-bindings)\n\n## before you start\n\nthis library uses minimum public key sizes (mpl). a g2element is a signature (96 bytes), and a g1element is a public key (48 bytes). a private key is a 32 byte integer. there are three schemes: basic, augmented, and proofofpossession. augmented should be enough for most use cases, and proofofpossession can be used where verification must be fast.\n\n## import the library\n\n```c++\n#include \"bls.hpp\"\nusing namespace bls;\n```\n\n## creating keys and signatures\n\n```c++\n// example seed, used to generate private key. always use\n// a secure rng with sufficient entropy to generate a seed (at least 32 bytes).\nvector<uint8_t> seed = {0,  50, 6,  244, 24,  199, 1,  25,  52,  88,  192,\n                        19, 18, 12, 89,  6,   220, 18, 102, 58,  209, 82,\n                        12, 62, 89, 110, 182, 9,   44, 20,  254, 22};\n\nprivatekey sk = augschemempl().keygen(seed);\ng1element pk = sk.getg1element();\n\nvector<uint8_t> message = {1, 2, 3, 4, 5};  // message is passed in as a byte vector\ng2element signature = augschemempl().sign(sk, message);\n\n// verify the signature\nbool ok = augschemempl().verify(pk, message, signature);\n```\n\n## serializing keys and signatures to bytes\n\n```c++\nvector<uint8_t> skbytes = sk.serialize();\nvector<uint8_t> pkbytes = pk.serialize();\nvector<uint8_t> signaturebytes = signature.serialize();\n\ncout << util::hexstr(skbytes) << endl;    // 32 bytes printed in hex\ncout << util::hexstr(pkbytes) << endl;    // 48 bytes printed in hex\ncout << util::hexstr(signaturebytes) << endl;  // 96 bytes printed in hex\n```\n\n## loading keys and signatures from bytes\n\n```c++\n// takes vector of 32 bytes\nprivatekey skc = privatekey::frombytevector(skbytes);\n\n// takes vector of 48 bytes\npk = g1element::frombytevector(pkbytes);\n\n// takes vector of 96 bytes\nsignature = g2element::frombytevector(signaturebytes);\n```\n\n## create aggregate signatures\n\n```c++\n// generate some more private keys\nseed[0] = 1;\nprivatekey sk1 = augschemempl().keygen(seed);\nseed[0] = 2;\nprivatekey sk2 = augschemempl().keygen(seed);\nvector<uint8_t> message2 = {1, 2, 3, 4, 5, 6, 7};\n\n// generate first sig\ng1element pk1 = sk1.getg1element();\ng2element sig1 = augschemempl().sign(sk1, message);\n\n// generate second sig\ng1element pk2 = sk2.getg1element();\ng2element sig2 = augschemempl().sign(sk2, message2);\n\n// signatures can be non-interactively combined by anyone\ng2element aggsig = augschemempl().aggregate({sig1, sig2});\n\nok = augschemempl().aggregateverify({pk1, pk2}, {message, message2}, aggsig);\n```\n\n## arbitrary trees of aggregates\n\n```c++\nseed[0] = 3;\nprivatekey sk3 = augschemempl().keygen(seed);\ng1element pk3 = sk3.getg1element();\nvector<uint8_t> message3 = {100, 2, 254, 88, 90, 45, 23};\ng2element sig3 = augschemempl().sign(sk3, message3);\n\n\ng2element aggsigfinal = augschemempl().aggregate({aggsig, sig3});\nok = augschemempl().aggregateverify({pk1, pk2, pk3}, {message, message2, message3}, aggsigfinal);\n\n```\n\n## very fast verification with proof of possession scheme\n\n```c++\n// if the same message is signed, you can use proof of posession (popscheme) for efficiency\n// a proof of possession must be passed around with the pk to ensure security.\n\ng2element popsig1 = popschemempl().sign(sk1, message);\ng2element popsig2 = popschemempl().sign(sk2, message);\ng2element popsig3 = popschemempl().sign(sk3, message);\ng2element pop1 = popschemempl().popprove(sk1);\ng2element pop2 = popschemempl().popprove(sk2);\ng2element pop3 = popschemempl().popprove(sk3);\n\nok = popschemempl().popverify(pk1, pop1);\nok = popschemempl().popverify(pk2, pop2);\nok = popschemempl().popverify(pk3, pop3);\ng2element popsigagg = popschemempl().aggregate({popsig1, popsig2, popsig3});\n\nok = popschemempl().fastaggregateverify({pk1, pk2, pk3}, message, popsigagg);\n\n// aggregate public key, indistinguishable from a single public key\ng1element popaggpk = pk1 + pk2 + pk3;\nok = popschemempl().verify(popaggpk, message, popsigagg);\n\n// aggregate private keys\nprivatekey aggsk = privatekey::aggregate({sk1, sk2, sk3});\nok = (popschemempl().sign(aggsk, message) == popsigagg);\n```\n\n## hd keys using [eip-2333](https://github.com/ethereum/eips/pull/2333)\n\n```c++\n// you can derive 'child' keys from any key, to create arbitrary trees. 4 byte indeces are used.\n// hardened (more secure, but no parent pk -> child pk)\nprivatekey mastersk = augschemempl().keygen(seed);\nprivatekey child = augschemempl().derivechildsk(mastersk, 152);\nprivatekey grandchild = augschemempl().derivechildsk(child, 952)\n\n// unhardened (less secure, but can go from parent pk -> child pk), bip32 style\ng1element masterpk = mastersk.getg1element();\nprivatekey childu = augschemempl().derivechildskunhardened(mastersk, 22);\nprivatekey grandchildu = augschemempl().derivechildskunhardened(childu, 0);\n\ng1element childupk = augschemempl().derivechildpkunhardened(masterpk, 22);\ng1element grandchildupk = augschemempl().derivechildpkunhardened(childupk, 0);\n\nok = (grandchildupk == grandchildu.getg1element();\n```\n\n## build\n\ncmake 3.14+, a c++ compiler, and python3 (for bindings) are required for building.\n\n```bash\nmkdir build\ncd build\ncmake ../\ncmake --build . -- -j 6\n```\n\n### run tests\n\n```bash\n./build/src/runtest\n```\n\n### run benchmarks\n\n```bash\n./build/src/runbench\n```\n\non a 3.5 ghz i7 mac, verification takes about 1.1ms per signature, and signing takes 1.3ms.\n\n### link the library to use it\n\n```bash\ng++ -wl,-no_pie -std=c++11 -ibls-signatures/src -l./bls-signatures/build/ -l bls yourapp.cpp\n```\n\n## notes on dependencies\n\nwe use libsodium which provides secure memory\nallocation. to install it, either download them from github and\nfollow the instructions for each repo, or use a package manager like apt or\nbrew. you can follow the recipe used to build python wheels for multiple\nplatforms in `.github/workflows/`.\n\n## discussion\n\ndiscussion about this library and other chia related development is in the #dev\nchannel of chia's [public keybase channels](https://keybase.io/team/chia_network.public).\n\n## code style\n\n* always use vector<uint8_t> for bytes\n* use size_t for size variables\n* uppercase method names\n* prefer static constructors\n* avoid using templates\n* objects allocate and free their own memory\n* use cpplint with default rules\n* use secalloc and secfree when handling secrets\n\n## ci building\n\nthe primary build process for this repository is to use github actions to\nbuild binary wheels for macos, linux (x64 and aarch64), and windows and publish\nthem with a source wheel on pypi. macos arm64 is supported but not automated\ndue to a lack of m1 ci runners. see `.github/workflows/build.yml`. cmake uses\n[fetchcontent](https://cmake.org/cmake/help/latest/module/fetchcontent.html)\nto download [pybind11](https://github.com/pybind/pybind11) for the python\nbindings. building\nis then managed by [cibuildwheel](https://github.com/joerick/cibuildwheel).\nfurther installation is then available via `pip install blspy` e.g. the ci\nbuilds include a statically linked libsodium.\n\n## contributing and workflow\n\ncontributions are welcome and more details are available in chia-blockchain's\n[contributing.md](https://github.com/chia-network/chia-blockchain/blob/main/contributing.md).\n\nthe main branch is usually the currently released latest version on pypi.\nnote that at times bls-signatures/blspy will be ahead of the release version\nthat chia-blockchain requires in it's main/release version in preparation\nfor a new chia-blockchain release. please branch or fork main and then create\na pull request to the main branch. linear merging is enforced on main and\nmerging requires a completed review. prs will kick off a github actions ci\nbuild and analysis of bls-signatures at\n[lgtm.com](https://lgtm.com/projects/g/chia-network/bls-signatures/?mode=list).\nplease make sure your build is passing and that it does not increase alerts\nat lgtm.\n\n## specification and test vectors\n\nthe [ietf bls draft](https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/)\nis followed. test vectors can also be seen in the python and cpp test files.\n\n## libsodium license\n\nthe libsodium static library is licensed under the isc license which requires\nthe following copyright notice.\n\n>isc license\n>\n>copyright (c) 2013-2020\n>frank denis \\<j at pureftpd dot org\\>\n>\n>permission to use, copy, modify, and/or distribute this software for any\n>purpose with or without fee is hereby granted, provided that the above\n>copyright notice and this permission notice appear in all copies.\n>\n>the software is provided \"as is\" and the author disclaims all warranties\n>with regard to this software including all implied warranties of\n>merchantability and fitness. in no event shall the author be liable for\n>any special, direct, indirect, or consequential damages or any damages\n>whatsoever resulting from loss of use, data or profits, whether in an\n>action of contract, negligence or other tortious action, arising out of\n>or in connection with the use or performance of this software.\n\n## blst license\n\nblst is used with the\n[apache 2.0 license](https://github.com/supranational/blst/blob/master/license)\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "blspy",
  "package_url": "https://pypi.org/project/blspy/",
  "project_url": "https://pypi.org/project/blspy/",
  "project_urls": {
    "Homepage": "https://github.com/Chia-Network/bls-signatures"
  },
  "release_url": "https://pypi.org/project/blspy/2.0.2/",
  "requires_dist": [
    "wheel"
  ],
  "requires_python": ">=3.7",
  "summary": "bls signatures in c++ (python bindings)",
  "version": "2.0.2",
  "releases": [],
  "developers": [
    "mariano@chia.net",
    "mariano_sorgente"
  ],
  "kwds": "bls blspy signaturebytes signatures signature",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_blspy",
  "homepage": "https://github.com/chia-network/bls-signatures",
  "release_count": 89,
  "dependency_ids": [
    "pypi_wheel"
  ]
}