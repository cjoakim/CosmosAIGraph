{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: django",
    "framework :: flask",
    "intended audience :: developers",
    "intended audience :: information technology",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: internet :: www/http",
    "topic :: scientific/engineering :: interface engine/protocol translator",
    "topic :: software development :: libraries :: python modules",
    "topic :: software development :: object brokering",
    "topic :: utilities"
  ],
  "description": "\nthe ``jsonconversion`` package\n==============================\n\nthis python module helps converting arbitrary python objects into json strings and back. it extends the basic features\nof the ``jsonencoder`` and ``jsondecoder`` classes provided by the native ``json`` package. for this purpose,\n``jsonconversion`` ships with these four classes:\n\nthe ``jsonobject`` class\n------------------------\n\nyour serializable classes should inherit from this class. hereby, they must implement the methods ``from_dict`` and\n``to_dict``. the example further down describes how to do so.\n\nthe ``jsonextendedencoder`` class\n---------------------------------\n\nthis is a class used internally by ``jsonobjectencoder``. however, it can also be used directly, if you do not need the\nfeatures of ``jsonobjectencoder`` but want to implement your own encoders.\n\nthe class is especially helpful, if you want custom handling of builtins (``int``, ``dict``, ...) or classes deriving\nfrom builtins. this would not be possible if directly inheriting from ``jsonencoder``. to do so, override the\n``isinstance`` method and return ``false`` for all types you want to handle in the ``default`` method.\n\nif you look at the source code of ``jsonobjectencoder``, you will see how this can be used.\n\nthe ``jsonobjectencoder`` class\n-------------------------------\n\nencodes python objects into json strings. supported objects are:\n\n-  python builtins: ``int``, ``float``, ``str``, ``list``, ``set``, ``dict``, ``tuple``\n-  ``type`` objects: ``isinstance(object, type)``\n-  all classes deriving from ``jsonobject``\n\nthose objects can of course also be nested!\n\nthe ``jsonobjectdecoder`` class\n-------------------------------\n\ndecodes json strings converted using the ``jsonobjectencoder`` back to python objects.\n\nthe class adds a custom keyword argument to the ``load[s]`` method: ``substitute_modules``. this parameter takes a\n``dict`` in the form ``{\"old.module.myclass\": \"new.module.myclass\"}``. it can be used if you have serialized\n``jsonobject``\\s who's module path has changed.\n\nusage\n=====\n\nusing ``jsonconversion`` is easy. you can find further code examples in the ``test`` folder.\n\nencoding and decoding\n---------------------\n\nin order to encode python objects with json conversion and to later decode them, you have to import the python module\n``json``. the module provides the methods ``dump``/``dumps`` for encoding and ``load``/``loads`` for decoding:\n\n.. code:: python\n\n    import json\n\n    from jsonconversion.decoder import jsonobjectdecoder\n    from jsonconversion.encoder import jsonobjectencoder\n\n    var = (1, 2, 3)  # variable to be serialized\n\n    # \"dumps\" converts the variable to a string, \"dump\" directly writes it to a file\n    str_var = json.dumps(var, cls=jsonobjectencoder)\n    # equivalently, \"loads\" converts the object back from a string. \"load\" from a file\n    var_2 = json.loads(str_var, cls=jsonobjectdecoder)\n    assert var == var_2\n\nderiving from jsonobject\n------------------------\n\nin order to serialize arbitrary, self-written classes, they must derive from ``jsonobject`` and implement the two\nmethods ``from_dict`` and ``to_dict``:\n\n.. code:: python\n\n    class myclass(jsonobject):\n\n        def __init__(self, a, b, c):\n            self.a = a\n            self.b = b\n            self.c = c\n\n        @classmethod\n        def from_dict(cls, dict_):\n            return cls(dict_['a'], dict_['b'], dict_['c'])\n\n        def to_dict(self):\n            return {'a': self.a, 'b': self.b, 'c': self.c}\n\n        def __eq__(self, other):\n            return self.a == other.a and self.b == other.b and self.c == other.c\n\ngeneral notes\n-------------\n\n-  ``jsonconversion`` stores the class path in the json string when serializing a jsonobject. when decoding the object\n   back, it automatically imports the correct module. you only have to ensure that the module is within your\n   ``pythonpath``.\n\n-  the ``to_dict`` and ``from_dict`` methods only need to specify the elements of a class, needed to recreate the\n   object. derived attributes of a class (like ``age`` from ``year_born``) do not need to be serialized.\n\n-  if you compare the original object with the object obtained from serialization and deserialization using ``is``, they\n   will differ, as these are objects at different locations in memory. also a comparison of jsonobject with ``==`` will\n   fail, if you do not tell python how to compare two objects. this is why ``myclass`` overrides the ``__eq__`` method.\n\n\n",
  "docs_url": null,
  "keywords": "json,conversion,serialization",
  "license": "bsd",
  "name": "jsonconversion",
  "package_url": "https://pypi.org/project/jsonconversion/",
  "project_url": "https://pypi.org/project/jsonconversion/",
  "project_urls": {
    "Download": "https://github.com/DLR-RM/python-jsonconversion/tarball/master",
    "Homepage": "https://github.com/DLR-RM/python-jsonconversion"
  },
  "release_url": "https://pypi.org/project/jsonconversion/0.2.13/",
  "requires_dist": [],
  "requires_python": ">=2.6",
  "summary": "this python module helps converting arbitrary python objects into json strings and back.",
  "version": "0.2.13",
  "releases": [],
  "developers": [
    "franz.steinmetz@dlr.de",
    "franz_steinmetz"
  ],
  "kwds": "jsonconversion jsonencoder jsondecoder jsonextendedencoder jsonobjectencoder",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_jsonconversion",
  "homepage": "https://github.com/dlr-rm/python-jsonconversion",
  "release_count": 12,
  "dependency_ids": []
}