{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "rfc3986\n=======\n\na python implementation of `rfc 3986`_ including validation and authority\nparsing.\n\ninstallation\n------------\n\nuse pip to install ``rfc3986`` like so::\n\n    pip install rfc3986\n\nlicense\n-------\n\n`apache license version 2.0`_\n\nexample usage\n-------------\n\nthe following are the two most common use cases envisioned for ``rfc3986``.\n\nreplacing ``urlparse``\n``````````````````````\n\nto parse a uri and receive something very similar to the standard library's\n``urllib.parse.urlparse``\n\n.. code-block:: python\n\n    from rfc3986 import urlparse\n\n    ssh = urlparse('ssh://user@git.openstack.org:29418/openstack/glance.git')\n    print(ssh.scheme)  # => ssh\n    print(ssh.userinfo)  # => user\n    print(ssh.params)  # => none\n    print(ssh.port)  # => 29418\n\nto create a copy of it with new pieces you can use ``copy_with``:\n\n.. code-block:: python\n\n    new_ssh = ssh.copy_with(\n        scheme='https'\n        userinfo='',\n        port=443,\n        path='/openstack/glance'\n    )\n    print(new_ssh.scheme)  # => https\n    print(new_ssh.userinfo)  # => none\n    # etc.\n\nstrictly parsing a uri and applying validation\n``````````````````````````````````````````````\n\nto parse a uri into a convenient named tuple, you can simply:\n\n.. code-block:: python\n\n    from rfc3986 import uri_reference\n\n    example = uri_reference('http://example.com')\n    email = uri_reference('mailto:user@domain.com')\n    ssh = uri_reference('ssh://user@git.openstack.org:29418/openstack/keystone.git')\n\nwith a parsed uri you can access data about the components:\n\n.. code-block:: python\n\n    print(example.scheme)  # => http\n    print(email.path)  # => user@domain.com\n    print(ssh.userinfo)  # => user\n    print(ssh.host)  # => git.openstack.org\n    print(ssh.port)  # => 29418\n\nit can also parse uris with unicode present:\n\n.. code-block:: python\n\n    uni = uri_reference(b'http://httpbin.org/get?utf8=\\xe2\\x98\\x83')  # \u2603\n    print(uni.query)  # utf8=%e2%98%83\n\nwith a parsed uri you can also validate it:\n\n.. code-block:: python\n\n    if ssh.is_valid():\n        subprocess.call(['git', 'clone', ssh.unsplit()])\n\nyou can also take a parsed uri and normalize it:\n\n.. code-block:: python\n\n    mangled = uri_reference('http://example.com')\n    print(mangled.scheme)  # => http\n    print(mangled.authority)  # => example.com\n\n    normal = mangled.normalize()\n    print(normal.scheme)  # => http\n    print(mangled.authority)  # => example.com\n\nbut these two uris are (functionally) equivalent:\n\n.. code-block:: python\n\n    if normal == mangled:\n        webbrowser.open(normal.unsplit())\n\nyour paths, queries, and fragments are safe with us though:\n\n.. code-block:: python\n\n    mangled = uri_reference('http://example.com/some/really/bizzare/path')\n    normal = mangled.normalize()\n    assert normal == 'http://example.com/some/really/bizzare/path'\n    assert normal == 'http://example.com/some/really/bizzare/path'\n    assert normal != 'http://example.com/some/really/bizzare/path'\n\nif you do not actually need a real reference object and just want to normalize\nyour uri:\n\n.. code-block:: python\n\n    from rfc3986 import normalize_uri\n\n    assert (normalize_uri('http://example.com/some/really/bizzare/path') ==\n            'http://example.com/some/really/bizzare/path')\n\nyou can also very simply validate a uri:\n\n.. code-block:: python\n\n    from rfc3986 import is_valid_uri\n\n    assert is_valid_uri('http://example.com/some/really/bizzare/path')\n\nrequiring components\n~~~~~~~~~~~~~~~~~~~~\n\nyou can validate that a particular string is a valid uri and require\nindependent components:\n\n.. code-block:: python\n\n    from rfc3986 import is_valid_uri\n\n    assert is_valid_uri('http://localhost:8774/v2/resource',\n                        require_scheme=true,\n                        require_authority=true,\n                        require_path=true)\n\n    # assert that a mailto uri is invalid if you require an authority\n    # component\n    assert is_valid_uri('mailto:user@example.com', require_authority=true) is false\n\nif you have an instance of a ``urireference``, you can pass the same arguments\nto ``urireference#is_valid``, e.g.,\n\n.. code-block:: python\n\n    from rfc3986 import uri_reference\n\n    http = uri_reference('http://localhost:8774/v2/resource')\n    assert uri.is_valid(require_scheme=true,\n                        require_authority=true,\n                        require_path=true)\n\n    # assert that a mailto uri is invalid if you require an authority\n    # component\n    mailto = uri_reference('mailto:user@example.com')\n    assert uri.is_valid(require_authority=true) is false\n\nalternatives\n------------\n\n- `rfc3987 <https://pypi.python.org/pypi/rfc3987/1.3.4>`_\n\n  this is a direct competitor to this library, with extra features,\n  licensed under the gpl.\n\n- `uritools <https://pypi.python.org/pypi/uritools/0.5.1>`_\n\n  this can parse uris in the manner of rfc 3986 but provides no validation and\n  only recently added python 3 support.\n\n- standard library's `urlparse`/`urllib.parse`\n\n  the functions in these libraries can only split a uri (valid or not) and\n  provide no validation.\n\ncontributing\n------------\n\nthis project follows and enforces the python software foundation's `code of\nconduct <https://www.python.org/psf/codeofconduct/>`_.\n\nif you would like to contribute but do not have a bug or feature in mind, feel\nfree to email ian and find out how you can help.\n\nthe git repository for this project is maintained at\nhttps://github.com/python-hyper/rfc3986\n\n.. _rfc 3986: https://datatracker.ietf.org/doc/html/rfc3986/\n.. _apache license version 2.0: https://www.apache.org/licenses/license-2.0\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "rfc3986",
  "package_url": "https://pypi.org/project/rfc3986/",
  "project_url": "https://pypi.org/project/rfc3986/",
  "project_urls": {
    "Homepage": "http://rfc3986.readthedocs.io"
  },
  "release_url": "https://pypi.org/project/rfc3986/2.0.0/",
  "requires_dist": [
    "idna ; extra == 'idna2008'"
  ],
  "requires_python": ">=3.7",
  "summary": "validating uri references per rfc 3986",
  "version": "2.0.0",
  "releases": [],
  "developers": [
    "graffatcolmingov@gmail.com",
    "ian_stapleton_cordasco"
  ],
  "kwds": "_rfc rfc3986 pip rfc rfc3987",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_rfc3986",
  "homepage": "http://rfc3986.readthedocs.io",
  "release_count": 18,
  "dependency_ids": [
    "pypi_idna"
  ]
}