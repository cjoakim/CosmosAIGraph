{
  "classifiers": [
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# sqlalchemy-serializer\nmixin for sqlalchemy models serialization without pain.\n\nif you want to serialize sqlalchemy model instances with only one line of code,\nand tools like `marshmallow` seems to be redundant and too complex for such a simple task,\nthis mixin definitely suits you.\n\n**contents**\n- [installation](#installation)\n- [usage](#usage)\n- [advanced usage](#advanced-usage)\n- [custom formats](#custom-formats)\n- [custom types](#custom-types)\n- [timezones](#timezones)\n- [troubleshooting](#troubleshooting)\n- [tests](#tests)\n\n## installation\n\n```bash\npip install sqlalchemy-serializer\n```\n\n## usage\n\nif you want sqlalchemy model to become serializable,\nadd **serializermixin** in class definition:\n```python\nfrom sqlalchemy_serializer import serializermixin\n\n\nclass somemodel(db.model, serializermixin):\n    ...\n```\n\nthis mixin adds **.to_dict()** method to model instances.\nso now you can do something like this:\n```python\nitem = somemodel.query.filter(...).one()\nresult = item.to_dict()\n```\nyou get values of all sqlalchemy fields in the `result` var, even nested relationships\nin order to change the default output you shuld pass tuple of fieldnames as an argument\n\n- if you want to exclude or add some extra fields (not from database) \n  you should pass `rules` argument\n- if you want to define the only fields to be presented in serializer's output\n  use `only` argument\n\nif you want to exclude a few fields for this exact item:\n```python\nresult = item.to_dict(rules=('-somefield', '-some_relation.nested_one.another_nested_one'))\n```\n\nif you want to add a field which is not defined as an sqlalchemy field:\n```python\nclass somemodel(db.model, serializermixin):\n    non_sql_field = 123\n\n    def method(self):\n        return anything\n\nresult = item.to_dict(rules=('non_sql_field', 'method'))\n```\n**note** that method or a function should have no arguments except ***self***,\nin order to let serializer call it without hesitations.\n\nif you want to get exact fields:\n```python\n\nresult = item.to_dict(only=('non_sql_field', 'method', 'somefield'))\n```\n**note** that if ***somefield*** is an sqlalchemy instance, you get all it's\nserializable fields. so if you want to get only some of them, you should define it like below:\n```python\n\nresult = item.to_dict(only=('non_sql_field', 'method', 'somefield.id', 'somefield.etc'))\n```\nyou can use negative rules in `only` param too.\nso `item.to_dict(only=('somefield', -'somefield.id'))`\nwill return `somefiled` without `id`. see [negative rules in only section](#negative-rules-in-only-section)\n\nif you want to define schema for all instances of particular sqlalchemy model,\nadd serialize properties to model definition:\n```python\nclass somemodel(db.model, serializermixin):\n    serialize_only = ('somefield.id',)\n    serialize_rules = ()\n    ...\n    somefield = db.relationship('anothermodel')\n\nresult = item.to_dict()\n```\nso the `result` in this case will be `{'somefield': [{'id': some_id}]}`\n***serialize_only*** and  ***serialize_rules*** work the same way as ***to_dict's*** arguments\n\n\n# advanced usage \nfor more examples see [tests](https://github.com/n0nsmoker/sqlalchemy-serializer/tree/master/tests)\n\n```python\nclass flatmodel(db.model, serializermixin):\n    \"\"\"\n    to_dict() of all instances of this model now returns only following two fields\n    \"\"\"\n    serialize_only = ('non_sqlalchemy_field', 'id')\n    serialize_rules = ()\n\n    id = db.column(db.integer, primary_key=true)\n    string = db.column(db.string(256), default='some string!')\n    time = db.column(db.datetime, default=datetime.utcnow())\n    date = db.column(db.date, default=datetime.utcnow())\n    boolean = db.column(db.boolean, default=true)\n    boolean2 = db.column(db.boolean, default=false)\n    null = db.column(db.string)\n    non_sqlalchemy_dict = dict(qwerty=123)\n\n\nclass complexmodel(db.model, serializermixin):\n   \"\"\"\n   schema is not defined so\n   we will get all sqlalchemy attributes of the instance by default\n   without `non_sqlalchemy_list`\n   \"\"\"\n\n    id = db.column(db.integer, primary_key=true)\n    string = db.column(db.string(256), default='some string!')\n    boolean = db.column(db.boolean, default=true)\n    null = db.column(db.string)\n    flat_id = db.column(db.foreignkey('test_flat_model.id'))\n    rel = db.relationship('flatmodel')\n    non_sqlalchemy_list = [dict(a=12, b=10), dict(a=123, b=12)]\n\nitem = complexmodel.query.first()\n\n\n# now by default the result looks like this:\nitem.to_dict()\n\ndict(\n    id=1,\n    string='some string!',\n    boolean=true,\n    null=none,\n    flat_id=1,\n    rel=[dict(\n        id=1,\n        non_sqlalchemy_dict=dict(qwerty=123)\n    )]\n\n\n# extend schema\nitem.to_dict(rules=('-id', '-rel.id', 'rel.string', 'non_sqlalchemy_list'))\n\ndict(\n    string='some string!',\n    boolean=true,\n    null=none,\n    flat_id=1,\n    non_sqlalchemy_list=[dict(a=12, b=10), dict(a=123, b=12)],\n    rel=dict(\n        string='some string!',\n        non_sqlalchemy_dict=dict(qwerty=123)\n    )\n)\n\n\n# exclusive schema\nitem.to_dict(only=('id', 'flat_id', 'rel.id', 'non_sqlalchemy_list.a'))\n\ndict(\n    id=1,\n    flat_id=1,\n    non_sqlalchemy_list=[dict(a=12), dict(a=123)],\n    rel=dict(\n        id=1\n    )\n)\n```\n# recursive models and trees\nif your models have references to each other or you work with large trees\nyou need to specify where the serialization should stop.\n```python\nitem.to_dict('-children.children')\n```\nin this case only the first level of `children` will be included\nsee [max recursion](#max-recursion)\n\n# custom formats\nif you want to change datetime/date/time/decimal format in one model you can specify it like below:\n```python\nfrom sqlalchemy_serializer import serializermixin\n\nclass somemodel(db.model, serializermixin):\n    __tablename__ = 'custom_table_name'\n    \n    date_format = '%s'  # unixtimestamp (seconds)\n    datetime_format = '%y %b %d %h:%m:%s.%f'\n    time_format = '%h:%m.%f'\n    decimal_format = '{:0>10.3}'\n\n    id = sa.column(sa.integer, primary_key=true)\n    date = sa.column(sa.date)\n    datetime = sa.column(sa.datetime)\n    time = sa.column(sa.time)\n    money = decimal('12.123')  # same result with sa.float(asdecimal=true, ...)\n```\n\nif you want to change format in every model, you should write\nyour own mixin class inherited from `serializermixin`:\n```python\nfrom sqlalchemy_serializer import serializermixin\n\nclass customserializermixin(serializermixin):\n    date_format = '%s'  # unixtimestamp (seconds)\n    datetime_format = '%y %b %d %h:%m:%s.%f'\n    time_format = '%h:%m.%f'\n    decimal_format = '{:0>10.3}'\n```\nand later use it as usual:\n```python\nfrom decimal import decimal\nimport sqlalchemy as sa\nfrom some.lib.package import customserializermixin\n\n\nclass customserializermodel(db.model, customserializermixin):\n    __tablename__ = 'custom_table_name'\n\n    id = sa.column(sa.integer, primary_key=true)\n    date = sa.column(sa.date)\n    datetime = sa.column(sa.datetime)\n    time = sa.column(sa.time)\n    money = decimal('12.123')  # same result with sa.float(asdecimal=true, ...)\n\n```\nall `date/time/datetime/decimal` fields will be serialized using your custom formats.\n\n- decimal uses python `format` syntax\n- to get **unixtimestamp** use `%s`, \n- other `datetime` formats you can find [in docs](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)\n\n\n# custom types\nby default the library can serialize the following types:\n ```\n - int \n - str \n - float \n - bytes \n - bool \n - type(none)\n - uuid.uuid\n - time\n - datetime\n - date\n - decimal\n - enum\n - dict (if values and keys are one of types mentioned above, or inherit one of them)\n - any iterable (if types of values are mentioned above, or inherit one of them)\n ```\n if you want to add serialization of any other type or redefine the default behaviour. \n you should add something like this:\n\n```python\n\nserialize_types = (\n    (sometype, lambda x: some_expression),\n    (anyothertype, some_function)\n)\n```\nto your own mixin class inherited from `serializermixin`:\n\n```python\nfrom sqlalchemy_serializer import serializermixin\nfrom geoalchemy2.elements import wkbelement\nfrom geoalchemy2.shape import to_shape\n\ndef serialize_int(value):\n    return value + 100\n\nclass customserializermixin(serializermixin):\n    serialize_types = (\n        (wkbelement, lambda x: to_shape(x).to_wkt()),\n        (int, serialize_int)\n    )\n```\n... or directly to the model:\n```python\nfrom geoalchemy2 import geometry\nfrom sqlalchemy_serializer import serializermixin\n\nclass point(base, serializermixin):\n    serialize_types = (\n        (wkbelement, lambda x: to_shape(x).to_wkt()),\n        (anyothertype, serialize_smth)\n    )\n    __tablename__ = 'point'\n    id = column(integer, primary_key=true)\n    position = column(geometry('point'))\n```\n\nunfortunately you can not access formats or tzinfo in that functions.\ni'll implement this logic later if any of users needs it.\n\n\n# timezones\nto keep `datetimes` consistent its better to store it in the database normalized to **utc**.\nbut when you return response, sometimes (mostly in web, mobile applications can do it themselves)\nyou need to convert all `datetimes` to user's timezone.\nso you need to tell serializer what timezone to use.\nthere are two ways to do it:\n-  the simplest one is to pass timezone directly as an argument for `to_dict` function\n```python\nimport pytz\n\nitem.to_dict(timezone=pytz.timezone('europe/moscow'))\n```\n- but if you do not want to write this code in every function, you should define\n  timezone logic in your custom mixin (how to use customized mixin see [castomization](#castomization))\n ```python\nimport pytz\nfrom sqlalchemy_serializer import serializermixin\nfrom some.package import get_current_user\n\nclass customserializermixin(serializermixin):\n    def get_tzinfo(self):\n        # you can write your own logic here, \n        # the example below will work if you store timezone\n        # in user's profile\n        return pytz.timezone(get_current_user()['timezone'])\n```\n\n# troubleshooting\n\n## max recursion\nif you've faced with **maximum recursion depth exceeded** exception,\nmost likely the serializer have found instance of the same class somewhere among model's relationships.\nespecially if you use backrefs. in this case you need to tell it where to stop like below:\n```python\nclass user(base, serializermixin):\n    __tablename__ = 'users'\n    \n    # exclude nested model of the same class to avoid max recursion error\n    serialize_rules = ('-related_models.user',)\n    ...\n    related_models = relationship(\"relatedmodel\", backref='user')\n    \n    \nclass relatedmodel(base, serializermixin):\n    __tablename__ = 'some_table'\n\n    ...\n    user_id = column(integer, foreignkey('users.id'))\n    ...\n```\nif for some reason you need the field `user` to be presented in `related_models` field.\nyou can change `serialize_rules` to `('-related_models.user.related_models',)`\nto break the chain of serialisation a bit further.\n[recursive models and trees](#recursive-models-and-trees)\n\n## controversial rules\nif you add controversial rules like `serialize_rules = ('-prop', 'prop.id')`\nthe serializer will include `prop` in spite of `-prop` rule.\n\n## negative rules in only section\nif you pass rules in `serialize_only` the serializer becomes **not** greedy and returns **only** fields listed there.\nso `serialize_only = ('-model.id',)` will return nothing\nbut `serialize_only = ('model', '-model.id',)` will return `model` field without `id`\n\n## one element tuples\ndo not forget to add **comma** at the end of one element tuples, it is trivial, \nbut a lot of developers forget about it:\n```python\nserialize_only = ('some_field',)  # <--- thats right!\nserialize_only = ('some_field')  # <--- wrong it is actually not a tuple\n\n```\n\n# tests\nto run tests and see tests coverage report just type the following command:(doker and doker-compose should be installed on you local machine)\n```bash\nmake test\n```\nto run a particular test use\n```bash\nmake test file=tests/some_file.py\nmake test file=tests/some_file.py::test_func\n```\n\ni will appreciate any help in improving this library, so feel free to submit issues or pull requests.",
  "docs_url": null,
  "keywords": "sqlalchemy,serialize,to_dict,json",
  "license": "",
  "name": "sqlalchemy-serializer",
  "package_url": "https://pypi.org/project/SQLAlchemy-serializer/",
  "project_url": "https://pypi.org/project/SQLAlchemy-serializer/",
  "project_urls": {
    "Homepage": "https://github.com/n0nSmoker/SQLAlchemy-serializer"
  },
  "release_url": "https://pypi.org/project/SQLAlchemy-serializer/1.4.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "mixin for sqlalchemy-models serialization without pain",
  "version": "1.4.1",
  "releases": [],
  "developers": [],
  "kwds": "sqlalchemy_serializer non_sqlalchemy_dict sqlalchemy non_sqlalchemy_list non_sqlalchemy_field",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_sqlalchemy_serializer",
  "homepage": "https://github.com/n0nsmoker/sqlalchemy-serializer",
  "release_count": 26,
  "dependency_ids": []
}