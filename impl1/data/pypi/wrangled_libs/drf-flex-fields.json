{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7"
  ],
  "description": "# django rest - flexfields\n\n[![package version](https://badge.fury.io/py/drf-flex-fields.svg)](https://pypi.python.org/pypi/drf-flex-fields)\n[![python versions](https://img.shields.io/pypi/status/drf-flex-fields.svg)](https://img.shields.io/pypi/status/django-lifecycle.svg/)\n\nflexible, dynamic fields and nested models for django rest framework serializers.\n\n# overview\n\nflexfields (drf-ff) for [django rest framework](https://django-rest-framework.org) is a package designed to provide a common baseline of functionality for dynamically setting fields and nested models within drf serializers. this package is designed for simplicity, with minimal magic and entanglement with drf's foundational classes.\n\nkey benefits:\n\n- easily set up fields that be expanded to their fully serialized counterparts via query parameters (`users/?expand=organization,friends`)\n- select a subset of fields by either:\n  - specifying which ones should be included (`users/?fields=id,first_name`)\n  - specifying which ones should be excluded (`users/?omit=id,first_name`)\n- use dot notation to dynamically modify fields at arbitrary depths (`users/?expand=organization.owner.roles`)\n- flexible api - options can also be passed directly to a serializer: `userserializer(obj, expand=['organization'])`\n\n# quick start\n\n```python\nfrom rest_flex_fields import flexfieldsmodelserializer\n\nclass stateserializer(flexfieldsmodelserializer):\n    class meta:\n        model = state\n        fields = ('id', 'name')\n\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ('id', 'name', 'population', 'states')\n        expandable_fields = {\n          'states': (stateserializer, {'many': true})\n        }\n\nclass personserializer(flexfieldsmodelserializer):\n    class meta:\n        model = person\n        fields = ('id', 'name', 'country', 'occupation')\n        expandable_fields = {'country': countryserializer}\n```\n\n```\nget /people/142/\n```\n\n```json\n{\n  \"id\": 142,\n  \"name\": \"jim halpert\",\n  \"country\": 1\n}\n```\n\n```\nget /people/142/?expand=country.states\n```\n\n```json\n{\n  \"id\": 142,\n  \"name\": \"jim halpert\",\n  \"country\": {\n    \"id\": 1,\n    \"name\": \"united states\",\n    \"states\": [\n      {\n        \"id\": 23,\n        \"name\": \"ohio\"\n      },\n      {\n        \"id\": 2,\n        \"name\": \"pennsylvania\"\n      }\n    ]\n  }\n}\n```\n\n# table of contents:\n\n- [django rest - flexfields](#django-rest---flexfields)\n- [overview](#overview)\n- [quick start](#quick-start)\n- [table of contents:](#table-of-contents)\n- [setup](#setup)\n- [usage](#usage)\n  - [dynamic field expansion](#dynamic-field-expansion)\n  - [deferred fields](#deferred-fields)\n  - [deep, nested expansion](#deep-nested-expansion)\n  - [field expansion on \"list\" views <a id=\"list-views\"></a>](#field-expansion-on-list-views-)\n  - [expanding a \"many\" relationship <a id=\"expanding-many\"></a>](#expanding-a-many-relationship-)\n  - [dynamically setting fields (sparse fields) <a id=\"dynamically-setting-fields\"></a>](#dynamically-setting-fields-sparse-fields-)\n  - [reference serializer as a string (lazy evaluation) <a id=\"lazy-ref\"></a>](#reference-serializer-as-a-string-lazy-evaluation-)\n  - [increased re-usability of serializers <a id=\"increased-reuse\"></a>](#increased-re-usability-of-serializers-)\n- [serializer options](#serializer-options)\n- [advanced](#advanced)\n  - [customization](#customization)\n  - [serializer introspection](#serializer-introspection)\n  - [use wildcards to match multiple fields](#wildcards)\n  - [combining sparse fields and field expansion <a id=\"combining-sparse-and-expanded\"></a>](#combining-sparse-fields-and-field-expansion-)\n  - [utility functions <a id=\"utils\"></a>](#utility-functions-)\n    - [rest_flex_fields.is_expanded(request, field: str)](#rest_flex_fieldsis_expandedrequest-field-str)\n    - [rest_flex_fields.is_included(request, field: str)](#rest_flex_fieldsis_includedrequest-field-str)\n  - [query optimization (experimental)](#query-optimization-experimental)\n- [changelog <a id=\"changelog\"></a>](#changelog-)\n- [testing](#testing)\n- [license](#license)\n\n# setup\n\nfirst install:\n\n```\npip install drf-flex-fields\n```\n\nthen have your serializers subclass `flexfieldsmodelserializer`:\n\n```python\nfrom rest_flex_fields import flexfieldsmodelserializer\n\nclass stateserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ('id', 'name')\n\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ('id', 'name', 'population', 'states')\n        expandable_fields = {\n          'states': (stateserializer, {'many': true})\n        }\n```\n\nalternatively, you can add the `flexfieldsserializermixin` mixin to a model serializer.\n\n# usage\n\n## dynamic field expansion\n\nto define expandable fields, add an `expandable_fields` dictionary to your serializer's `meta` class. key the dictionary with the name of the field that you want to dynamically expand, and set its value to either the expanded serializer or a tuple where the first element is the serializer and the second is a dictionary of options that will be used to instantiate the serializer.\n\n```python\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ['name', 'population']\n\n\nclass personserializer(flexfieldsmodelserializer):\n    country = serializers.primarykeyrelatedfield(read_only=true)\n\n    class meta:\n        model = person\n        fields = ['id', 'name', 'country', 'occupation']\n\n        expandable_fields = {\n            'country': countryserializer\n        }\n```\n\nif the default serialized response is the following:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": 12,\n  \"occupation\": \"programmer\"\n}\n```\n\nwhen you do a `get /person/13322?expand=country`, the response will change to:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"name\": \"united states\",\n    \"population\": 330000000\n  },\n  \"occupation\": \"programmer\"\n}\n```\n\n## deferred fields\n\nalternatively, you could treat `country` as a \"deferred\" field by not defining it among the default fields. to make a field deferred, only define it within the serializer's `expandable_fields`.\n\n## deep, nested expansion\n\nlet's say you add `stateserializer` as a serializer nested inside the country serializer above:\n\n```python\nclass stateserializer(flexfieldsmodelserializer):\n    class meta:\n        model = state\n        fields = ['name', 'population']\n\n\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ['name', 'population']\n\n        expandable_fields = {\n            'states': (stateserializer, {'many': true})\n        }\n\nclass personserializer(flexfieldsmodelserializer):\n    country = serializers.primarykeyrelatedfield(read_only=true)\n\n    class meta:\n        model = person\n        fields = ['id', 'name', 'country', 'occupation']\n\n        expandable_fields = {\n            'country': countryserializer\n        }\n```\n\nyour default serialized response might be the following for `person` and `country`, respectively:\n\n```json\n{\n  \"id\" : 13322,\n  \"name\" : \"john doe\",\n  \"country\" : 12,\n  \"occupation\" : \"programmer\",\n}\n\n{\n  \"id\" : 12,\n  \"name\" : \"united states\",\n  \"states\" : \"http://www.api.com/countries/12/states\"\n}\n```\n\nbut if you do a `get /person/13322?expand=country.states`, it would be:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"occupation\": \"programmer\",\n  \"country\": {\n    \"id\": 12,\n    \"name\": \"united states\",\n    \"states\": [\n      {\n        \"name\": \"ohio\",\n        \"population\": 11000000\n      }\n    ]\n  }\n}\n```\n\nplease be kind to your database, as this could incur many additional queries. though, you can mitigate this impact through judicious use of `prefetch_related` and `select_related` when defining the queryset for your viewset.\n\n## field expansion on \"list\" views <a id=\"list-views\"></a>\n\nif you request many objects, expanding fields could lead to many additional database queries. subclass `flexfieldsmodelviewset` if you want to prevent expanding fields by default when calling a viewset's `list` method. place those fields that you would like to expand in a `permit_list_expands` property on the viewset:\n\n```python\nfrom rest_flex_fields import is_expanded\n\nclass personviewset(flexfieldsmodelviewset):\n    permit_list_expands = ['employer']\n    serializer_class = personserializer\n\n    def get_queryset(self):\n        queryset = models.person.objects.all()\n        if is_expanded(self.request, 'employer'):\n            queryset = queryset.select_related('employer')\n        return queryset\n```\n\nnotice how this example is using the `is_expanded` utility method as well as `select_related` and `prefetch_related` to efficiently query the database if the field is expanded.\n\n## expanding a \"many\" relationship <a id=\"expanding-many\"></a>\n\nset `many` to `true` in the serializer options to make sure \"to many\" fields are expanded correctly.\n\n```python\nclass stateserializer(flexfieldsmodelserializer):\n    class meta:\n        model = state\n        fields = ['name', 'population']\n\n\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ['name', 'population']\n\n        expandable_fields = {\n            'states': (stateserializer, {'many': true})\n        }\n```\n\na request to `get /countries?expand=states` will return:\n\n```python\n{\n    \"id\" : 12,\n    \"name\" : \"united states\",\n    \"states\" : [\n      {\n        \"name\" : \"alabama\",\n        \"population\": 11000000\n      },\n      //... more states ... //\n      {\n        \"name\" : \"ohio\",\n        \"population\": 11000000\n      }\n    ]\n}\n```\n\n## dynamically setting fields (sparse fields) <a id=\"dynamically-setting-fields\"></a>\n\nyou can use either the `fields` or `omit` keywords to declare only the fields you want to include or to specify fields that should be excluded.\n\nconsider this as a default serialized response:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"name\": \"united states\",\n    \"population\": 330000000\n  },\n  \"occupation\": \"programmer\",\n  \"hobbies\": [\"rock climbing\", \"sipping coffee\"]\n}\n```\n\nto whittle down the fields via url parameters, simply add `?fields=id,name,country` to your requests to get back:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"name\": \"united states\",\n    \"population\": 330000000\n  }\n}\n```\n\nor, for more specificity, you can use dot-notation, `?fields=id,name,country.name`:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"name\": \"united states\"\n  }\n}\n```\n\nor, if you want to leave out the nested country object, do `?omit=country`:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"occupation\": \"programmer\",\n  \"hobbies\": [\"rock climbing\", \"sipping coffee\"]\n}\n```\n\n## reference serializer as a string (lazy evaluation) <a id=\"lazy-ref\"></a>\n\nto avoid circular import problems, it's possible to lazily evaluate a string reference to you serializer class using this syntax:\n\n```python\nexpandable_fields = {\n    'record_set': ('<module_path_to_serializer_class>.relatedserializer', {'many': true})\n}\n```\n\n**note**:\nprior to version `0.9.0`, it was assumed your serializer classes would be in a module with the following path:\n`<app_name>.serializers`.\n\nthis import style will still work, but you can also now specify fully-qualified import paths to any locations.\n\n## increased re-usability of serializers <a id=\"increased-reuse\"></a>\n\nthe `omit` and `fields` options can be passed directly to serializers. rather than defining a separate, slimmer version of a regular serializer, you can re-use the same serializer and declare which fields you want.\n\n```python\nfrom rest_flex_fields import flexfieldsmodelserializer\n\nclass countryserializer(flexfieldsmodelserializer):\n    class meta:\n        model = country\n        fields = ['id', 'name', 'population', 'capital', 'square_miles']\n\nclass personserializer(flexfieldsmodelserializer):\n    country = countryserializer(fields=['id', 'name'])\n\n    class meta:\n        model = person\n        fields = ['id', 'name', 'country']\n\n\nserializer = personserializer(person)\nprint(serializer.data)\n\n>>>{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"id\": 1,\n    \"name\": \"united states\",\n  }\n}\n```\n\n# serializer options\n\ndynamic field options can be passed in the following ways:\n\n- from the request's query parameters; separate multiple values with a commma\n- as keyword arguments directly to the serializer class when its constructed\n- from a dictionary placed as the second element in a tuple when defining `expandable_fields`\n\napproach #1\n\n```\nget /people?expand=friends.hobbies,employer&omit=age\n```\n\napproach #2\n\n```python\nserializer = personserializer(\n  person,\n  expand=[\"friends.hobbies\", \"employer\"],\n  omit=\"friends.age\"\n)\n```\n\napproach #3\n\n```python\n\nclass personserializer(flexfieldsmodelserializer):\n  // your field definitions\n\n  class meta:\n    model = person\n    fields = [\"age\", \"hobbies\", \"name\"]\n    expandable_fields = {\n      'friends': (\n        'serializer.friendserializer',\n        {'many': true, \"expand\": [\"hobbies\"], \"omit\": [\"age\"]}\n      )\n    }\n```\n\n| option |                                 description                                  |\n| ------ | :--------------------------------------------------------------------------: |\n| expand | fields to expand; must be configured in the serializer's `expandable_fields` |\n| fields |         fields that should be included; all others will be excluded          |\n| omit   |         fields that should be excluded; all others will be included          |\n\n# advanced\n\n## customization\n\nparameter names and wildcard values can be configured within a django setting, named `rest_flex_fields`.\n\n| option                        |                                                                                                                                                                                                                                                                         description                                                                                                                                                                                                                                                                          | default         |\n|-------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|-----------------|\n| expand_param                  |                                                                                                                                                                                                                                                   the name of the parameter with the fields to be expanded                                                                                                                                                                                                                                                   | `\"expand\"`      |\n| maximum_expansion_depth       |                                                                                                                                                                                                                                                      the max allowed expansion depth. by default it's unlimited. expanding `state.towns` would equal a depth of 2                                                                                                                                                                                                                                            | `none`          |\n| fields_param                  |                                                                                                                                                                                                                                      the name of the parameter with the fields to be included (others will be omitted)                                                                                                                                                                                                                                       | `\"fields\"`      |\n| omit_param                    |                                                                                                                                                                                                                                                   the name of the parameter with the fields to be omitted                                                                                                                                                                                                                                                    | `\"omit\"`        |\n| recursive_expansion_permitted |                                                                                                                                                                                                                                             if `false`, an exception is raised when a recursive pattern is found                                                                                                                                                                                                                                             | `true`          |\n| wildcard_values               | list of values that stand in for all field names. can be used with the `fields` and `expand` parameters. <br><br>when used with `expand`, a wildcard value will trigger the expansion of all `expandable_fields` at a given level.<br><br>when used with `fields`, all fields are included at a given level. for example, you could pass `fields=name,state.*` if you have a city resource with a nested state in order to expand only the city's name field and all of the state's fields. <br><br>to disable use of wildcards, set this setting to `none`. | `[\"*\", \"~all\"]` |\n\nfor example, if you want your api to work a bit more like [json api](https://jsonapi.org/format/#fetching-includes), you could do:\n\n```python\nrest_flex_fields = {\"expand_param\": \"include\"}\n```\n\n### defining expansion and recursive limits on serializer classes\n\na `maximum_expansion_depth` integer property can be set on a serializer class.\n\n`recursive_expansion_permitted` boolean property can be set on a serializer class.\n\nboth settings raise `serializers.validationerror` when conditions are met but exceptions can be customized by overriding the `recursive_expansion_not_permitted` and `expansion_depth_exceeded` methods. \n\n\n## serializer introspection\n\nwhen using an instance of `flexfieldsmodelserializer`, you can examine the property `expanded_fields` to discover which fields, if any, have been dynamically expanded.\n\n## use of wildcard to match all fields <a id=\"wildcards\"></a>\n\nyou can pass `expand=*` ([or another value of your choosing](#customization)) to automatically expand all fields that are available for expansion at a given level. to refer to nested resources, you can use dot-notation. for example, requesting `expand=menu.sections` for a restaurant resource would expand its nested `menu` resource, as well as that menu's nested `sections` resource.\n\nor, when requesting sparse fields, you can pass `fields=*` to include only the specified fields at a given level. to refer to nested resources, you can use dot-notation. for example, if you have an `order` resource, you could request all of its fields as well as only two fields on its nested `restaurant` resource with the following: `fields=*,restaurent.name,restaurant.address&expand=restaurant`.\n\n## combining sparse fields and field expansion <a id=\"combining-sparse-and-expanded\"></a>\n\nyou may be wondering how things work if you use both the `expand` and `fields` option, and there is overlap. for example, your serialized person model may look like the following by default:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\",\n  \"country\": {\n    \"name\": \"united states\"\n  }\n}\n```\n\nhowever, you make the following request `http get /person/13322?include=id,name&expand=country`. you will get the following back:\n\n```json\n{\n  \"id\": 13322,\n  \"name\": \"john doe\"\n}\n```\n\nthe `fields` parameter takes precedence over `expand`. that is, if a field is not among the set that is explicitly alllowed, it cannot be expanded. if such a conflict occurs, you will not pay for the extra database queries - the expanded field will be silently abandoned.\n\n## utility functions <a id=\"utils\"></a>\n\n### rest_flex_fields.is_expanded(request, field: str)\n\nchecks whether a field has been expanded via the request's query parameters.\n\n**parameters**\n\n- **request**: the request object\n- **field**: the name of the field to check\n\n### rest_flex_fields.is_included(request, field: str)\n\nchecks whether a field has not been excluded via either the `omit` parameter or the `fields` parameter.\n\n**parameters**\n\n- **request**: the request object\n- **field**: the name of the field to check\n\n## query optimization (experimental)\n\nan experimental filter backend is available to help you automatically reduce the number of sql queries and their transfer size. _this feature has not been tested thorougly and any help testing and reporting bugs is greatly appreciated._ you can add flexfieldfilterbackend to `default_filter_backends` in the settings:\n\n```python\n# settings.py\n\nrest_framework = {\n    'default_filter_backends': (\n        'rest_flex_fields.filter_backends.flexfieldsfilterbackend',\n        # ...\n    ),\n    # ...\n}\n```\n\nit will automatically call `select_related` and `prefetch_related` on the current queryset by determining which fields are needed from many-to-many and foreign key-related models. for sparse fields requests (`?omit=fieldx,fieldy` or `?fields=fieldx,fieldy`), the backend will automatically call `only(*field_names)` using only the fields needed for serialization.\n\n**warning:** the optimization currently works only for one nesting level.\n\n# changelog <a id=\"changelog\"></a>\n\n## 1.0.2 (march 2023)\n\n- adds control over whether recursive expansions are allowed and allows setting the max expansion depth. thanks @andruten!\n\n## 1.0.1 (march 2023)\n\n- various bug fixes. thanks @michaelschem, @andruten, and @erielias!\n\n## 1.0.0 (august 2022)\n\n- improvements to the filter backends for generic foreign key handling and docs generation. thanks @krypted974 and @michaelschem!\n\n## 0.9.9 (july 2022)\n\n- fixes bug in `flexfieldsfilterbackend`. thanks @michaelschem!\n- adds `flexfieldsdocsfilterbackend` for schema population. thanks @rjevski!\n\n## 0.9.8 (april 2022)\n\n- set expandable fields as the default example for expand query parameters in `coreapi.field`. thanks @jaspersui!\n\n## 0.9.7 (january 2022)\n\n- includes m2m in prefetch_related clause even if they're not expanded. thanks @pablolmedorado and @adr-007!\n\n## 0.9.6 (november 2021)\n\n- make it possible to use wildcard values with sparse fields requests.\n\n## 0.9.5 (october 2021)\n\n- adds openapi support. thanks @soroush-tabesh!\n- updates tests for django 3.2 and fixes deprecation warning. thanks @giovannicimolin!\n\n## 0.9.3 (august 2021)\n\n- fixes bug where custom parameter names were not passed when constructing nested serializers. thanks @kandeel4411!\n\n## 0.9.2 (june 2021)\n\n- ensures `context` dict is passed down to expanded serializers. thanks @nikeshyad!\n\n## 0.9.1 (june 2021)\n\n- no longer auto removes `source` argument if it's equal to the field name.\n\n## 0.9.0 (april 2021)\n\n- allows fully qualified import strings for lazy serializer classes.\n\n## 0.8.9 (february 2021)\n\n- adds openapi support to experimental filter backend. thanks @lukasberka!\n\n## 0.8.8 (september 2020)\n\n- django 3.1.1 fix. thansks @niyaznz!\n- docs typo fix. thanks @zakjholt!\n\n## 0.8.6 (september 2020)\n\n- adds `is_included` utility function.\n\n## 0.8.5 (may 2020)\n\n- adds options to customize parameter names and wildcard values. closes #10.\n\n## 0.8.1 (may 2020)\n\n- fixes #44, related to the experimental filter backend. thanks @jsatt!\n\n## 0.8.0 (april 2020)\n\n- adds support for `expand`, `omit` and `fields` query parameters for non-get requests.\n  - the common use case is creating/updating a model instance and returning a serialized response with expanded fields\n  - thanks @kotepillar for raising the issue (#25) and @crocmagnon for the idea of delaying field modification to `to_representation()`.\n\n## 0.7.5 (february 2020)\n\n- simplifies declaration of `expandable_fields`\n  - if using a tuple, the second element - to define the serializer settings - is now optional.\n  - instead of a tuple, you can now just use the serializer class or a string to lazily reference that class.\n  - updates documentation.\n\n## 0.7.0 (february 2020)\n\n- adds support for different ways of passing arrays in query strings. thanks @sentyaev!\n- fixes attribute error when map is supplied to split levels utility function. thanks @hemache!\n\n## 0.6.1 (september 2019)\n\n- adds experimental support for automatically sql query optimization via a `flexfieldsfilterbackend`. thanks adr-007!\n- adds circleci config file. thanks mikeifts!\n- moves declaration of `expandable_fields` to `meta` class on serialzer for consistency with drf (will continue to support declaration as class property)\n- python 2 is no longer supported. if you need python 2 support, you can continue to use older versions of this package.\n\n## 0.5.0 (april 2019)\n\n- added support for `omit` keyword for field exclusion. code clean up and improved test coverage.\n\n## 0.3.4 (may 2018)\n\n- handle case where `request` is `none` when accessing request object from serializer. thanks @jsatt!\n\n## 0.3.3 (april 2018)\n\n- exposes `flexfieldsserializermixin` in addition to `flexfieldsmodelserializer`. thanks @jsatt!\n\n# testing\n\ntests are found in a simplified drf project in the `/tests` folder. install the project requirements and do `./manage.py test` to run them.\n\n# license\n\nsee [license](license.md).\n\n\n",
  "docs_url": null,
  "keywords": "django rest api dynamic fields",
  "license": "mit",
  "name": "drf-flex-fields",
  "package_url": "https://pypi.org/project/drf-flex-fields/",
  "project_url": "https://pypi.org/project/drf-flex-fields/",
  "project_urls": {
    "Homepage": "https://github.com/rsinger86/drf-flex-fields"
  },
  "release_url": "https://pypi.org/project/drf-flex-fields/1.0.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "flexible, dynamic fields and nested resources for django rest framework serializers.",
  "version": "1.0.2",
  "releases": [],
  "developers": [
    "robert_singer",
    "robertgsinger@gmail.com"
  ],
  "kwds": "rest_flex_fields rest_flex_fieldsis_expandedrequest rest_flex_fieldsis_includedrequest flexfieldsserializermixin flexfieldsmodelserializer",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_drf_flex_fields",
  "homepage": "https://github.com/rsinger86/drf-flex-fields",
  "release_count": 35,
  "dependency_ids": []
}