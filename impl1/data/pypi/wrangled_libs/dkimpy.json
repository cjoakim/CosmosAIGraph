{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: no input/output (daemon)",
    "intended audience :: developers",
    "license :: dfsg approved",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "topic :: communications :: email :: filters",
    "topic :: communications :: email :: mail transport agents",
    "topic :: internet :: name service (dns)",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "dkimpy - dkim (domainkeys identified mail)\nhttps://launchpad.net/dkimpy/\n\nfriendly fork of:\nhttp://hewgill.com/pydkim/\n\n# introduction\n\ndkimpy is a library that implements dkim (domainkeys identified mail) email\nsigning and verification.  basic dkim requirements are defined in rfc 6376:\n\nhttps://tools.ietf.org/html/rfc6376\n\n# version\n\nthis is dkimpy 1.1.5.\n\n# requirements\n\ndependencies will be automatically included for normal dkim usage.  the\nextras_requires feature 'ed25519' will add the dependencies needed for signing\nand verifying using the new dcrup ed25519-sha256 algorithm.  the\nextras_requires feature 'arc' will add the extra dependencies needed for arc.\nsimilarly, extras_requires feature 'asyncio' will add the extra dependencies\nneeded for asyncio.\n\n - python 3.x >= 3.5.  recent versions have not been on python3 < 3.4, but\n   may still work on earlier python3 versions.\n - dnspython or py3dns. dnspython is preferred if both are present and\n   installed to satisfy the dns module requirement if neither are installed.\n - authres.  needed for arc.\n - pynacl.  needed for use of ed25519 capability.\n - aiodns.  needed for asycnio (requires python3.5 or later)\n\n# installation\n\nthis package includes a scripts and man pages.  for those to be installed when\ninstalling using setup.py, the following incantation is required because\nsetuptools developers decided not being able to do this by default is a\nfeature:\n\n```python3 setup.py install --single-version-externally-managed --record=/dev/null```\n\n# documentation\n\nan online version of the package documentation for the most recent release can\nbe found at:\n\nhttps://pymilter.org/pydkim/\n\n# testing\n\nto run dkimpy's test suite:\n\n```pythonpath=. python3 dkim```\n\nor\n\n```python3 test.py```\n\nor\n\n```pythonpath=. python3 -m unittest dkim.tests.test_suite```\n\n\nalternatively, if you have testrepository installed:\n\n```testr init```\n\n```testr run```\n\nyou should install all optional dependencies required for the test suite, e.g.\nby creating a virtualenv and using:\n\n```pip install -e '.[testing]'```\n\nthe included arc tests are very limited.  the primary testing method for arc\nis using the arc test suite: https://github.com/valimail/arc_test_suite\n\nas of 0.6.0, all tests pass for both python2.7 and python3. the test suite\n ships with test runners for dkimpy.  after downloading the test suite, you\n can run the signing and validation tests like this:\n\n```python3 ./testarc.py sign runners/arcsigntest.py```\n```python3 ./testarc.py validate runners/arcverifytest.py```\n\nas ov version 1.1.0, python2.7 is no longer supported.\n\n# usage\n\nthe dkimpy library offers one module called dkim. the sign() function takes an\nrfc822 formatted message, along with some signing options, and returns a\ndkim-signature header line that can be prepended to the message. the verify()\nfunction takes an rfc822 formatted message, and returns true or false depending\non whether the signature verifies correctly.  there is also a dkim class which\ncan be used to perform these functions in a more modern way.\n\nin version 0.9.0, the default set of header fields that are oversigned was\nchanged from 'from', 'subject', 'date' to 'from' to reduce fragility of\nsignatures.  to restore the previous behavior, you can add them back after\ninstantiating your dkim class using the add_frozen function as shown in the\nfollowing example:\n\n```python\n>>> dkim = dkim()\n>>> dkim.add_frozen((b'date',b'subject'))\n>>> [text(x) for x in sorted(dkim.frozen_sign)]\n['date', 'from', 'subject']\n```\n\n## dkim rsa modernization (rfc 8301)\n\nrfc8301 updated dkim requirements in two ways:\n\n1.  it set the minimum valid rsa key size to 1024 bits.\n2.  it removed use of rsa-sha1.\n\nas of version 0.7, the dkimpy defaults largely support these requirements.\n\nit is possible to override the minimum key size to a lower value, but this is\nstrongly discouraged.  as of 2018, keys much smaller than the minimum are not\ndifficult to factor.\n\nthe code for rsa-sha1 signing and verification is retained, but not used for\nsigning by default.  future releases will raise warnings and then errors when\nverifying rsa-sha1 signatures.  there are still some significant users of\nrsa-sha1 signatures, so operationally it's premature to disable verification\nof rsa-sha1.\n\n## ed25519 (rfc 8463) support\n\nas of version 0.7, experimental signing and verifying of dkim ed25519\nsignatures is supported as described in draft-ietf-dcrup-dkim-crypto:\n\nhttps://datatracker.ietf.org/doc/draft-ietf-dcrup-dkim-crypto/\n\nthe rfc that documents ed25519 dkim signatures, rfc 8463, has been released\nand dkimpy 0.7 and later are aligned to its requirements.  as of 0.8, ed25519\nneed not be considered experimental.  the dkimpy implementation has\nsuccessfully interoperated with three other implementations and the technical\nparameters for ed25519-sha256 are defined and stable.\n\nto install from pypi with the required optional depenencies, use the ed25519\noption:\n\n```pip install -e '.[ed25519]'```\n\n## dkim scripts\n\nthree helper programs are also supplied: dknewkey, dkimsign and\ndkimverify\n\ndknewkey is s script that produces private and public key pairs suitable\nfor use with dkim.  note that the private key file format used for ed25519 is\nnot standardized (there is no standard) and is unique to dkimpy.  creation of\nkeys should be done in a secure environment.  if an unauthorized entity gains\naccess to current private keys they can generate signed email that will pass\ndkim checkes and will be difficult to repudiate.\n\ndkimsign is a filter that reads an rfc822 message on standard input, and\nwrites the same message on standard output with a dkim-signature line\nprepended. the signing options are specified on the command line:\n\ndkimsign selector domain privatekeyfile [identity]\n\nthe identity is optional and defaults to \"@domain\".\n\ndkimverify reads an rfc822 message on standard input, and returns with exit\ncode 0 if the signature verifies successfully. otherwise, it returns with exit\ncode 1. \n\n## arc (authenticated receive chain)\n\nas of version 0.6.0, dkimpy provides experimental support for arc (authenticated\nreceived chain).  see rfc 8617 for the current version of arc:\n\nhttps://tools.ietf.org/html/rfc8617\n\nin addition to arcsign and arcverify, the dkim module now provides\narc_sign and arc_verify functions as well as an arc class.\n\nif an invalid authentication results header field is included in the set for\narc, it is ignored and no error is raised.\n\nboth dkim ed25519 and arc are now considered stable (no longer experimantal).\n\n## async support\n\nas of version 1.0, an alternative to dkim.verify for use in an async\nenvironment is provied.  it requires aiodns, https://pypi.org/project/aiodns/.\nhere is a simple example of dkim.verify_async usage:\n\n```python\n>>> sys.stdin = sys.stdin.detach()\n>>>\n>>> async def main():\n>>>     res = await dkim.verify_async(message)\n>>>     return res\n>>>\n>>> if __name__ == \"__main__\":\n>>>     res = asyncio.run(main())\n```\n\nthis feature requires python3.5 or newer.\n\nif aiodns is available, the async functions will be used.  to avoide async\nwhen aiodns is availale, set dkim.use_async = false.\n\n## tlsrpt (tls report)\n\nas of version 1.0, the rfc 8460 tlsrpt service type is supported:\n\nhttps://tools.ietf.org/html/rfc8460\n\na non-tlsrpt signed with a key record with s=tlsrpt won't verify.  since the\nservice type (s=) is optional in the dkim public key record, it is not\nrequired by rfc 8460.  when checking for a tlsrpt signature, set the tlsrpt=\nflag when verifying the signature:\n\n```python\n>>> res = dkim.verify(smessage, tlsrpt='strict')\n```\n\nif tlsrpt='strict', only public key records with s=tlsrpt will be considered\nvalid.  if set to tlsrpt=true, the service type is not required, but other\nrfc 8460 requirements are applied.\n\n# limitations\n\ndkimpy will correctly sign/verify messages with ascii or utf-8 content.\nmessages that contain other types of content will not verify correctly.  it\ndoes not yet implement rfc 8616, email authentication for internationalized\nmail.\n\n# feedback\n\nbug reports may be submitted to the bug tracker for the dkimpy project on\nlaunchpad.",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-like",
  "name": "dkimpy",
  "package_url": "https://pypi.org/project/dkimpy/",
  "project_url": "https://pypi.org/project/dkimpy/",
  "project_urls": {
    "Homepage": "https://launchpad.net/dkimpy"
  },
  "release_url": "https://pypi.org/project/dkimpy/1.1.5/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "dkim (domainkeys identified mail), arc (authenticated receive chain), and tlsrpt (tls report) email signing and verification",
  "version": "1.1.5",
  "releases": [],
  "developers": [
    "scott@kitterman.com",
    "scott_kitterman"
  ],
  "kwds": "dkimpy dkimverify dkim dkimsign dnspython",
  "license_kwds": "bsd-like",
  "libtype": "pypi",
  "id": "pypi_dkimpy",
  "homepage": "https://launchpad.net/dkimpy",
  "release_count": 33,
  "dependency_ids": []
}