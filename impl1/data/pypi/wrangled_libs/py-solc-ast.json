{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# solc-ast\n\n[![pypi status](https://img.shields.io/pypi/v/py-solc-ast.svg)](https://pypi.org/project/py-solc-ast/) [![build status](https://img.shields.io/github/workflow/status/iamdefinitelyahuman/py-solc-ast/main%20workflow/master)](https://github.com/iamdefinitelyahuman/py-solc-ast/actions) [![coverage status](https://img.shields.io/codecov/c/github/iamdefinitelyahuman/py-solc-ast)](https://codecov.io/gh/iamdefinitelyahuman/py-solc-ast)\n\na tool for exploring the solidity abstrax syntrax tree as generated by the [solc](https://github.com/ethereum/solidity) compiler.\n\n## installation\n\nyou can install the latest release via `pip`:\n\n```bash\n$ pip install py-solc-ast\n```\n\nor clone the repo and use `setuptools`:\n\n```bash\n$ python setup.py install\n```\n\n## usage\n\nfirst, use [py-solc-x](https://github.com/iamdefinitelyahuman/py-solc-x) to compile your contracts to the [standard json output format](https://solidity.readthedocs.io/en/latest/using-the-compiler.html#output-description).\n\n```python\n>>> import json\n>>> import solcx\n>>> input_json = json.load(open('input.json'))\n>>> output_json = solcx.compile_standard(input_json)\n```\n\nnext, import `solcast` and initialize using `from_standard_output_json` or `from_standard_output`. this returns a list of `sourceunit` objects, which each represent the base ast node in a solidity source file.\n\n```python\n>>> import solcast\n>>> nodes = solcast.from_standard_output(output_json)\n>>> nodes\n[<sourceunit iterable 'contracts/token.sol'>, <sourceunit iterable 'contracts/safemath.sol'>]\n```\n\nyou can also generate a single `sourceunit` directly from that source's ast:\n\n```python\n>>> import solcast\n>>> node = solcast.from_ast(output_json[\"sources\"][\"contracts/token.sol\"][\"ast\"])\n>>> node\n<sourceunit iterable 'contracts/token.sol'>\n```\n\n### interacting with nodes\n\neach node has the following attributes:\n\n```python\n>>> node\n<functiondefinition iterable 'mul'>\n\n>>> node.depth  # number of nodes between this node and the sourceunit\n2\n\n>>> node.offset  # absolute source offsets as a (start, stop) tuple\n(1693, 2151)\n\n>>> node.contract_id  # contract id as given by the standard compiler json\n2\n\n>>> node.fields  # list of fields for this node\n['basenodetype', 'documentation', 'id', 'implemented', 'kind', 'modifiers', 'name', 'nodetype', 'nodes', 'parameters', 'returnparameters', 'scope', 'src', 'statemutability', 'superfunction', 'visibility']\n\n```\n\nfields mostly follow the expected [ast grammar](https://solidity.readthedocs.io/en/latest/miscellaneous.html#language-grammar). one notable difference: `block` nodes are omitted and the body of each `block` is available within it's parent as the attribute `nodes`. nodes containing a body are iterable and can be accessed with list-like syntax. additionally, any child node with a `name` field is accessible using dict-like syntax.\n\nthe following additional fields are also available:\n\n* most nodes have a `basenodetype` field as defined in [grammar.py](solcast/grammar.py)\n* `contractdefinition` nodes have `dependencies` and `libraries` fields that point to related `contractdefition` nodes\n\nsome examples:\n\n```python\n>>> source_node\n<sourceunit iterable 'contracts/math/safemath.sol'>\n\n>>> source_node.keys()\n['absolutepath', 'children', 'contract_id', 'depth', 'exportedsymbols', 'id', 'is_child_of', 'is_parent_of', 'keys', 'nodetype', 'nodes', 'offset', 'parent', 'parents', 'src']\n\n>>> source_node.nodes\n[<pragmadirective object>, <contractdefinition iterable 'safemath'>]\n\n>>> source_node[1]\n<contractdefinition iterable 'safemath'>\n\n>>> source_node['safemath']\n<contractdefinition iterable 'safemath'>\n\n>>> source_node['safemath'].keys()\n['basecontracts', 'children', 'contractdependencies', 'contractkind', 'contract_id', 'dependencies', 'depth', 'documentation', 'fullyimplemented', 'id', 'is_child_of', 'is_parent_of', 'keys', 'libraries', 'linearizedbasecontracts', 'name', 'nodetype', 'nodes', 'offset', 'parent', 'parents', 'scope', 'src']\n\n>>> source_node['safemath'].nodes\n[<functiondefinition iterable 'add'>, <functiondefinition iterable 'sub'>, <functiondefinition iterable 'mul'>, <functiondefinition iterable 'div'>, <functiondefinition iterable 'mod'>]\n\n>>> source_node['safemath']['mul']\n<functiondefinition iterable 'mul'>\n\n>>> source_node['safemath']['mul']\n[<ifstatement object>, <variabledeclarationstatement object>, <functioncall object>, <return object>]\n```\n\n### exploring the tree\n\nthe `node.children()` method is used to search and filter through child nodes of a given node. it takes any of the following keyword arguments:\n\n* `depth`: number of levels of children to traverse. `0` returns only this node.\n* `include_self`: includes this node in the results.\n* `include_parents`: includes nodes that match in the results, when they also have child nodes that match.\n* `include_children`: if true, as soon as a match is found it's children will not be included in the search.\n* `required_offset`: only match nodes with a source offset that contains this offset.\n* `offset_limits`: only match nodes when their source offset is contained inside this source offset.\n* `filters`: dictionary of `{'attribute': \"value\"}` that children must match. can also be given as a list of dicts, children that match any of the dicts will be returned.\n* `exclude_filter`: dictionary of `{'attribute': \"value\"}` that children cannot match.\n\n```python\n>>> node = s['token']['transfer']\n>>> node.children(\n    include_children=false,\n    filters={'nodetype': \"functioncall\", \"expression.name\": \"require\"}\n)\n[<functioncall>]\n```\n\n`node.parent()` and `node.parents()` are used to travel back up the tree. they take the following arguments:\n\n* `depth`: depth limit. if given as a negative value, it will be subtracted from this object's depth.\n* `filters`: dictionary of `{'attribute': \"value\"}` that parents must match.\n\n`node.parent()` returns one result, `node.parents()` returns a list of matches.\n\n```python\n>>> node.parents()\n[<contractdefinition iterable 'token'>, <sourceunit iterable object 'contracts/token.sol'>]\n```\n\n## tests\n\nto run the test suite:\n\n```bash\n$ tox\n```\n\n## development\n\ncomments, questions, criticisms and pull requests are welcomed! feel free to open an issue if you encounter a problem or would like to suggest a new feature.\n\n## license\n\nthis project is licensed under the [mit license](license).\n\n\n",
  "docs_url": null,
  "keywords": "ethereum,solidity,solc,ast",
  "license": "mit",
  "name": "py-solc-ast",
  "package_url": "https://pypi.org/project/py-solc-ast/",
  "project_url": "https://pypi.org/project/py-solc-ast/",
  "project_urls": {
    "Homepage": "https://github.com/iamdefinitelyahuman/py-solc-ast"
  },
  "release_url": "https://pypi.org/project/py-solc-ast/1.2.9/",
  "requires_dist": [],
  "requires_python": ">=3.6, <4",
  "summary": "a tool for exploring the abstract syntax tree generated by solc.",
  "version": "1.2.9",
  "releases": [],
  "developers": [
    "ben@hauser.id",
    "ben_hauser"
  ],
  "kwds": "solcx solc documentation ast syntrax",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_py_solc_ast",
  "homepage": "https://github.com/iamdefinitelyahuman/py-solc-ast",
  "release_count": 19,
  "dependency_ids": []
}