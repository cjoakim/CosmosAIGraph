{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "![varname][7]\n\n[![pypi][3]][4] [![github][5]][6] [![pythonvers][8]][4] ![building][10]\n[![docs and api][9]][15] [![codacy][12]][13] [![codacy coverage][14]][13]\n![downloads][17]\n\ndark magics about variable names in python\n\n[changelog][16] | [api][15] | [playground][11] | :fire: [stackoverflow answer][20]\n\n## installation\n\n```shell\npip install -u varname\n```\n\nnote if you use `python < 3.8`, install `varname < 0.11`\n\n## features\n\n- core features:\n\n  - retrieving names of variables a function/class call is assigned to from inside it, using `varname`.\n  - retrieving variable names directly, using `nameof`\n  - detecting next immediate attribute name, using `will`\n  - fetching argument names/sources passed to a function using `argname`\n\n- other helper apis (built based on core features):\n\n  - a value wrapper to store the variable name that a value is assigned to, using `wrapper`\n  - a decorator to register `__varname__` to functions/classes, using `register`\n  - a helper function to create dict without explicitly specifying the key-value pairs, using `jsobj`\n  - a `debug` function to print variables with their names and values\n  - `exec_code` to replace `exec` where source code is available at runtime\n\n## credits\n\nthanks goes to these awesome people/projects:\n\n<table>\n  <tr>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/alexmojaki/executing\">\n        <img src=\"https://ui-avatars.com/api/?color=3333ff&background=ffffff&bold=true&name=e&size=400\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>executing</b></sub>\n      </a>\n    </td>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/alexmojaki\">\n        <img src=\"https://avatars0.githubusercontent.com/u/3627481?s=400&v=4\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>@alexmojaki</b></sub>\n      </a>\n    </td>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/breuleux\">\n        <img src=\"https://avatars.githubusercontent.com/u/599820?s=400&v=4\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>@breuleux</b></sub>\n      </a>\n    </td>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/elcubonegro\">\n        <img src=\"https://avatars.githubusercontent.com/u/5524219?s=400&v=4\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>@elcubonegro</b></sub>\n      </a>\n    </td>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/thewchan\">\n        <img src=\"https://avatars.githubusercontent.com/u/49702524?s=400&v=4\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>@thewchan</b></sub>\n      </a>\n    </td>\n    <td align=\"center\" style=\"min-width: 75px\">\n      <a href=\"https://github.com/lawsofsympathy\">\n        <img src=\"https://avatars.githubusercontent.com/u/96355982?s=400&v=4\" width=\"50px;\" alt=\"\"/>\n        <br /><sub><b>@lawsofsympathy</b></sub>\n      </a>\n    </td>\n  </tr>\n</table>\n\nspecial thanks to [@hanyuulu][2] to give up the name `varname` in pypi for this project.\n\n## usage\n\n### retrieving the variable names using `varname(...)`\n\n- from inside a function\n\n    ```python\n    from varname import varname\n    def function():\n        return varname()\n\n    func = function()  # func == 'func'\n    ```\n\n    when there are intermediate frames:\n\n    ```python\n    def wrapped():\n        return function()\n\n    def function():\n        # retrieve the variable name at the 2nd frame from this one\n        return varname(frame=2)\n\n    func = wrapped() # func == 'func'\n    ```\n\n    or use `ignore` to ignore the wrapped frame:\n\n    ```python\n    def wrapped():\n        return function()\n\n    def function():\n        return varname(ignore=wrapped)\n\n    func = wrapped() # func == 'func'\n    ```\n\n    calls from standard libraries are ignored by default:\n\n    ```python\n    import asyncio\n\n    async def function():\n        return varname()\n\n    func = asyncio.run(function()) # func == 'func'\n    ```\n\n    use `strict` to control whether the call should be assigned to\n    the variable directly:\n\n    ```python\n    def function(strict):\n        return varname(strict=strict)\n\n    func = function(true)     # ok, direct assignment, func == 'func'\n\n    func = [function(true)]   # not a direct assignment, raises improperuseerror\n    func = [function(false)]  # ok, func == ['func']\n\n    func = function(false), function(false)   # ok, func = ('func', 'func')\n    ```\n\n- retrieving name of a class instance\n\n    ```python\n    class foo:\n        def __init__(self):\n            self.id = varname()\n\n        def copy(self):\n            # also able to fetch inside a method call\n            copied = foo() # copied.id == 'copied'\n            copied.id = varname() # assign id to whatever variable name\n            return copied\n\n    foo = foo()   # foo.id == 'foo'\n\n    foo2 = foo.copy() # foo2.id == 'foo2'\n    ```\n\n- multiple variables on left-hand side\n\n    ```python\n    # since v0.5.4\n    def func():\n        return varname(multi_vars=true)\n\n    a = func() # a == ('a',)\n    a, b = func() # (a, b) == ('a', 'b')\n    [a, b] = func() # (a, b) == ('a', 'b')\n\n    # hierarchy is also possible\n    a, (b, c) = func() # (a, b, c) == ('a', 'b', 'c')\n    ```\n\n- some unusual use\n\n    ```python\n    def function(**kwargs):\n        return varname(strict=false)\n\n    func = func1 = function()  # func == func1 == 'func1'\n    # if varname < 0.8: func == func1 == 'func'\n    # a warning will be shown\n    # since you may not want func to be 'func1'\n\n    x = function(y = function())  # x == 'x'\n\n    # get part of the name\n    func_abc = function()[-3:]  # func_abc == 'abc'\n\n    # function alias supported now\n    function2 = function\n    func = function2()  # func == 'func'\n\n    a = lambda: 0\n    a.b = function() # a.b == 'b'\n    ```\n\n### the decorator way to register `__varname__` to functions/classes\n\n- registering `__varname__` to functions\n\n    ```python\n    from varname.helpers import register\n\n    @register\n    def function():\n        return __varname__\n\n    func = function() # func == 'func'\n    ```\n\n    ```python\n    # arguments also allowed (frame, ignore and raise_exc)\n    @register(frame=2)\n    def function():\n        return __varname__\n\n    def wrapped():\n        return function()\n\n    func = wrapped() # func == 'func'\n    ```\n\n- registering `__varname__` as a class property\n\n    ```python\n    @register\n    class foo:\n        ...\n\n    foo = foo()\n    # foo.__varname__ == 'foo'\n    ```\n\n### getting variable names directly using `nameof`\n\n```python\nfrom varname import varname, nameof\n\na = 1\nnameof(a) # 'a'\n\nb = 2\nnameof(a, b) # ('a', 'b')\n\ndef func():\n    return varname() + '_suffix'\n\nf = func() # f == 'f_suffix'\nnameof(f)  # 'f'\n\n# get full names of (chained) attribute calls\nfunc.a = func\nnameof(func.a, vars_only=false) # 'func.a'\n\nfunc.a.b = 1\nnameof(func.a.b, vars_only=false) # 'func.a.b'\n```\n\n### detecting next immediate attribute name\n\n```python\nfrom varname import will\nclass awesomeclass:\n    def __init__(self):\n        self.will = none\n\n    def permit(self):\n        self.will = will(raise_exc=false)\n        if self.will == 'do':\n            # let self handle do\n            return self\n        raise attributeerror('should do something with awesomeclass object')\n\n    def do(self):\n        if self.will != 'do':\n            raise attributeerror(\"you don't have permission to do\")\n        return 'i am doing!'\n\nawesome = awesomeclass()\nawesome.do() # attributeerror: you don't have permission to do\nawesome.permit() # attributeerror: should do something with awesomeclass object\nawesome.permit().do() == 'i am doing!'\n```\n\n### fetching argument names/sources using `argname`\n\n```python\nfrom varname import argname\n\ndef func(a, b=1):\n    print(argname('a'))\n\nx = y = z = 2\nfunc(x) # prints: x\n\n\ndef func2(a, b=1):\n    print(argname('a', 'b'))\nfunc2(y, b=x) # prints: ('y', 'x')\n\n\n# allow expressions\ndef func3(a, b=1):\n    print(argname('a', 'b', vars_only=false))\nfunc3(x+y, y+x) # prints: ('x+y', 'y+x')\n\n\n# positional and keyword arguments\ndef func4(*args, **kwargs):\n    print(argname('args[1]', 'kwargs[c]'))\nfunc4(y, x, c=z) # prints: ('x', 'z')\n\n\n# as of 0.9.0 (see: https://pwwang.github.io/python-varname/changelog/#v090)\n# can also fetch the source of the argument for\n# __getattr__/__getitem__/__setattr/__setitem__/__add__/__lt__, etc.\nclass foo:\n    def __setattr__(self, name, value):\n        print(argname(\"name\", \"value\", func=self.__setattr__))\n\nfoo().a = 1 # prints: (\"'a'\", '1')\n\n```\n\n### value wrapper\n\n```python\nfrom varname.helpers import wrapper\n\nfoo = wrapper(true)\n# foo.name == 'foo'\n# foo.value == true\nbar = wrapper(false)\n# bar.name == 'bar'\n# bar.value == false\n\ndef values_to_dict(*args):\n    return {val.name: val.value for val in args}\n\nmydict = values_to_dict(foo, bar)\n# {'foo': true, 'bar': false}\n```\n\n### creating dictionary using `jsobj`\n\n```python\nfrom varname.helpers import jsobj\n\na = 1\nb = 2\njsobj(a, b) # {'a': 1, 'b': 2}\njsobj(a, b, c=3) # {'a': 1, 'b': 2, 'c': 3}\n```\n\n### debugging with `debug`\n\n```python\nfrom varname.helpers import debug\n\na = 'value'\nb = ['val']\ndebug(a)\n# \"debug: a='value'\\n\"\ndebug(b)\n# \"debug: b=['val']\\n\"\ndebug(a, b)\n# \"debug: a='value'\\ndebug: b=['val']\\n\"\ndebug(a, b, merge=true)\n# \"debug: a='value', b=['val']\\n\"\ndebug(a, repr=false, prefix='')\n# 'a=value\\n'\n# also debug an expression\ndebug(a+a)\n# \"debug: a+a='valuevalue'\\n\"\n# if you want to disable it:\ndebug(a+a, vars_only=true) # improperuseerror\n```\n\n### replacing `exec` with `exec_code`\n\n```python\nfrom varname import argname\nfrom varname.helpers import exec_code\n\nclass obj:\n    def __init__(self):\n        self.argnames = []\n\n    def receive(self, arg):\n        self.argnames.append(argname('arg', func=self.receive))\n\nobj = obj()\n# exec('obj.receive(1)')  # error\nexec_code('obj.receive(1)')\nexec_code('obj.receive(2)')\nobj.argnames # ['1', '2']\n```\n\n## reliability and limitations\n\n`varname` is all depending on `executing` package to look for the node.\nthe node `executing` detects is ensured to be the correct one (see [this][19]).\n\nit partially works with environments where other ast magics apply, including\n`pytest`, `ipython`, `macropy`, `birdseye`, `reticulate` with `r`, etc. neither\n`executing` nor `varname` is 100% working with those environments. use\nit at your own risk.\n\nfor example:\n\n- this will not work with `pytest`:\n\n  ```python\n  a = 1\n  assert nameof(a) == 'a' # pytest manipulated the ast here\n\n  # do this instead\n  name_a = nameof(a)\n  assert name_a == 'a'\n  ```\n\n[1]: https://github.com/pwwang/python-varname\n[2]: https://github.com/hanyuulu\n[3]: https://img.shields.io/pypi/v/varname?style=flat-square\n[4]: https://pypi.org/project/varname/\n[5]: https://img.shields.io/github/tag/pwwang/python-varname?style=flat-square\n[6]: https://github.com/pwwang/python-varname\n[7]: logo.png\n[8]: https://img.shields.io/pypi/pyversions/varname?style=flat-square\n[9]: https://img.shields.io/github/actions/workflow/status/pwwang/python-varname/docs.yml?branch=master\n[10]: https://img.shields.io/github/actions/workflow/status/pwwang/python-varname/build.yml?branch=master\n[11]: https://mybinder.org/v2/gh/pwwang/python-varname/dev?filepath=playground%2fplayground.ipynb\n[12]: https://img.shields.io/codacy/grade/6fdb19c845f74c5c92056e88d44154f7?style=flat-square\n[13]: https://app.codacy.com/gh/pwwang/python-varname/dashboard\n[14]: https://img.shields.io/codacy/coverage/6fdb19c845f74c5c92056e88d44154f7?style=flat-square\n[15]: https://pwwang.github.io/python-varname/api/varname\n[16]: https://pwwang.github.io/python-varname/changelog/\n[17]: https://img.shields.io/pypi/dm/varname?style=flat-square\n[19]: https://github.com/alexmojaki/executing#is-it-reliable\n[20]: https://stackoverflow.com/a/59364138/5088165\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "varname",
  "package_url": "https://pypi.org/project/varname/",
  "project_url": "https://pypi.org/project/varname/",
  "project_urls": {
    "Homepage": "https://github.com/pwwang/python-varname",
    "Repository": "https://github.com/pwwang/python-varname"
  },
  "release_url": "https://pypi.org/project/varname/0.12.2/",
  "requires_dist": [
    "executing (>=2.0,<3.0)",
    "asttokens (==2.*) ; extra == \"all\"",
    "pure_eval (==0.*) ; extra == \"all\""
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "dark magics about variable names in python.",
  "version": "0.12.2",
  "releases": [],
  "developers": [
    "pwwang",
    "pwwang@pwwang.com"
  ],
  "kwds": "pip python __varname__ pythonvers varname",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_varname",
  "homepage": "https://github.com/pwwang/python-varname",
  "release_count": 31,
  "dependency_ids": [
    "pypi_asttokens",
    "pypi_executing",
    "pypi_pure_eval"
  ]
}