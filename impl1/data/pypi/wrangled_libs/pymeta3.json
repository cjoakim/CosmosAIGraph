{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4"
  ],
  "description": "========\npymeta3\n========\n\n--------------------------------------------\na pattern-matching language based on python\n--------------------------------------------\n\nthis is a fork of pymeta 0.5.0 that supports python 2 and 3.\n\n\ninstallation\n============\n\npip install pymeta3\n\n\nsummary\n=======\n\npymeta is an implementation of ometa, an object-oriented pattern-matching\nlanguage developed by alessandro warth\n(http://www.cs.ucla.edu/~awarth/ometa/). pymeta provides a compact syntax based\non parsing expression grammars (pegs) for common lexing, parsing and\ntree-transforming activities in a way that's easy to reason about for python\nprogrammers.\n\n\nhow it works\n============\n\npymeta compiles a grammar to a python class, with the rules as methods. the\nrules specify parsing expressions, which consume input and return values if\nthey succeed in matching.\n\nbasic syntax\n~~~~~~~~~~~~~~~~\n\n``foo ::= ....``\n   define a rule named foo.\n``expr1 expr2``\n   match expr1, and then match expr2 if it succeeds, returning the value of\n   expr2. like python's ``and``.\n``expr1 | expr2``\n  try to match expr1 --- if it fails, match expr2 instead. like python's\n  ``or``.\n``expr*``\n  match expr zero or more times, returning a list of matches.\n``expr+``\n  match expr one or more times, returning a list of matches.\n``expr?``\n  try to match expr. returns none if it fails to match.\n``~expr``\n  fail if the next item in the input matches expr.\n``<rulename>``\n  call the rule ``rulename``.\n``'x'``\n  match the literal character 'x'.\n``expr:name``\n  bind the result of expr to the local variable ``name``.\n``=> pythonexpression``\n  evaluate the given python expression and return its result.\n\ncomments like python comments are supported as well, starting with #\nand extending to the end of the line.\n\ninterface\n=========\n\nthe starting point for defining a new grammar is\n``pymeta.grammar.ometa.makegrammar``, which takes a grammar definition and a\ndict of variable bindings for its embedded expressions and produces a python\nclass. grammars can be subclassed as usual, and makegrammar can be called on\nthese classes to override rules and provide new ones. to invoke a grammar rule,\ncall ``grammarobject.apply()`` with its name.\n\nexample usage\n=============\n\n>>> from pymeta.grammar import ometa\n>>> examplegrammar = \"\"\"\nones ::= '1' '1' => 1\ntwos ::= '2' '2' => 2\nstuff ::= (<ones> | <twos>)+\n\"\"\"\n>>> example = ometa.makegrammar(examplegrammar, {})\n>>> g = example(\"11221111\")\n>>> result, error = g.apply(\"stuff\")\n>>> result\n[1, 2, 1, 1]",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "pymeta3",
  "package_url": "https://pypi.org/project/PyMeta3/",
  "project_url": "https://pypi.org/project/PyMeta3/",
  "project_urls": {
    "Homepage": "https://github.com/wbond/pymeta3"
  },
  "release_url": "https://pypi.org/project/PyMeta3/0.5.1/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "pattern-matching language based on ometa for python 3 and 2",
  "version": "0.5.1",
  "releases": [],
  "developers": [
    "wbond",
    "will@wbond.net"
  ],
  "kwds": "pymeta pymeta3 python pythonexpression pip",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_pymeta3",
  "homepage": "https://github.com/wbond/pymeta3",
  "release_count": 2,
  "dependency_ids": []
}