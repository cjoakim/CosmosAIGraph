{
  "classifiers": [],
  "description": "overview\n--------\n\nthe sentinels module is a small utility providing the sentinel class, along with useful instances.\n\nwhat are sentinels?\n-------------------\n\nsentinels are objects with special meanings. they can be thought of as singletons, but they service the need of having 'special' values in your code, that have special meanings (see example below).\n\nwhy do i need sentinels?\n------------------------\n\nlet's take *nothing* for example. this sentinel is automatically provided with the sentinels import::\n\n  >>> from sentinels import nothing\n\nlet's say you're writing a wrapper around a python dictionary, which supports a special kind of method, *get_default_or_raise*. this method behaves like *get*, but when it does not receive a default and the key does not exist, it raises a *keyerror*. how would you implement such a thing? the naive method is this::\n\n  >>> class mydict(dict):\n  ...     def get_default_or_raise(self, key, default=none):\n  ...         if key not in self and default is none:\n  ...             raise keyerror(key)\n  ...         return self.get(key, default)\n\nor even this::\n\n  >>> class mydict(dict):\n  ...     def get_default_or_raise(self, key, default=none):\n  ...         returned = self.get(key, default)\n  ...         if returned is none:\n  ...             raise keyerror(key)\n  ...         return returned\n\nbut the problem with the above two pieces of code is the same -- when writing a general utility class, we don't know how it will be used later on. more importantly, **none might be a perfectly valid dictionary value!**\n\nthis is where nothing comes in handy::\n\n\n  >>> class mydict(dict):\n  ...     def get_default_or_raise(self, key, default=nothing):\n  ...         returned = self.get(key, default)\n  ...         if returned is nothing:\n  ...             raise keyerror(key)\n  ...         return returned\n\nand tada!\n\nsemantics\n---------\n\nsentinels are always equal to themselves::\n\n  >>> nothing == nothing\n  true\n\nbut never to another object::\n\n  >>> from sentinels import sentinel\n  >>> nothing == 2\n  false\n  >>> nothing == \"nothing\"\n  false\n\ncopying sentinels returns the same object::\n\n  >>> import copy\n  >>> copy.deepcopy(nothing) is nothing\n  true\n\nand of course also pickling/unpickling::\n\n  >>> import pickle\n  >>> nothing is pickle.loads(pickle.dumps(nothing))\n  true\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "sentinels",
  "package_url": "https://pypi.org/project/sentinels/",
  "project_url": "https://pypi.org/project/sentinels/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/sentinels/1.0.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "various objects to denote special meanings in python",
  "version": "1.0.0",
  "releases": [],
  "developers": [
    "rotem_yaari",
    "vmalloc@gmail.com"
  ],
  "kwds": "get_default_or_raise singletons dict mydict sentinel",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_sentinels",
  "homepage": "",
  "release_count": 7,
  "dependency_ids": []
}