{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: aws cdk",
    "framework :: aws cdk :: 2",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon lambda python library\n\n<!--begin stability banner-->---\n\n\n![cdk-constructs: experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)\n\n> the apis of higher level constructs in this module are experimental and under active development.\n> they are subject to non-backward compatible changes or removal in any future version. these are\n> not subject to the [semantic versioning](https://semver.org/) model and breaking changes will be\n> announced in the release notes. this means that while you may use them, you may need to update\n> your source code when upgrading to a newer version of this package.\n\n---\n<!--end stability banner-->\n\nthis library provides constructs for python lambda functions.\n\nto use this module, you will need to have docker installed.\n\n## python function\n\ndefine a `pythonfunction`:\n\n```python\npython.pythonfunction(self, \"myfunction\",\n    entry=\"/path/to/my/function\",  # required\n    runtime=runtime.python_3_8,  # required\n    index=\"my_index.py\",  # optional, defaults to 'index.py'\n    handler=\"my_exported_func\"\n)\n```\n\nall other properties of `lambda.function` are supported, see also the [aws lambda construct library](https://github.com/aws/aws-cdk/tree/main/packages/aws-cdk-lib/aws-lambda).\n\n## python layer\n\nyou may create a python-based lambda layer with `pythonlayerversion`. if `pythonlayerversion` detects a `requirements.txt`\nor `pipfile` or `poetry.lock` with the associated `pyproject.toml` at the entry path, then `pythonlayerversion` will include the dependencies inline with your code in the\nlayer.\n\ndefine a `pythonlayerversion`:\n\n```python\npython.pythonlayerversion(self, \"mylayer\",\n    entry=\"/path/to/my/layer\"\n)\n```\n\na layer can also be used as a part of a `pythonfunction`:\n\n```python\npython.pythonfunction(self, \"myfunction\",\n    entry=\"/path/to/my/function\",\n    runtime=runtime.python_3_8,\n    layers=[\n        python.pythonlayerversion(self, \"mylayer\",\n            entry=\"/path/to/my/layer\"\n        )\n    ]\n)\n```\n\n## packaging\n\nif `requirements.txt`, `pipfile` or `poetry.lock` exists at the entry path, the construct will handle installing all required modules in a [lambda compatible docker container](https://gallery.ecr.aws/sam/build-python3.7) according to the `runtime` and with the docker platform based on the target architecture of the lambda function.\n\npython bundles are only recreated and published when a file in a source directory has changed.\ntherefore (and as a general best-practice), it is highly recommended to commit a lockfile with a\nlist of all transitive dependencies and their exact versions. this will ensure that when any dependency version is updated, the bundle asset is recreated and uploaded.\n\nto that end, we recommend using [`pipenv`] or [`poetry`] which have lockfile support.\n\n* [`pipenv`](https://pipenv-fork.readthedocs.io/en/latest/basics.html#example-pipfile-lock)\n* [`poetry`](https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control)\n\npackaging is executed using the `packaging` class, which:\n\n1. infers the packaging type based on the files present.\n2. if it sees a `pipfile` or a `poetry.lock` file, it exports it to a compatible `requirements.txt` file with credentials (if they're available in the source files or in the bundling container).\n3. installs dependencies using `pip`.\n4. copies the dependencies into an asset that is bundled for the lambda package.\n\n**lambda with a requirements.txt**\n\n```plaintext\n.\n\u251c\u2500\u2500 lambda_function.py # exports a function named 'handler'\n\u251c\u2500\u2500 requirements.txt # has to be present at the entry path\n```\n\n**lambda with a pipfile**\n\n```plaintext\n.\n\u251c\u2500\u2500 lambda_function.py # exports a function named 'handler'\n\u251c\u2500\u2500 pipfile # has to be present at the entry path\n\u251c\u2500\u2500 pipfile.lock # your lock file\n```\n\n**lambda with a poetry.lock**\n\n```plaintext\n.\n\u251c\u2500\u2500 lambda_function.py # exports a function named 'handler'\n\u251c\u2500\u2500 pyproject.toml # your poetry project definition\n\u251c\u2500\u2500 poetry.lock # your poetry lock file has to be present at the entry path\n```\n\n**excluding source files**\n\nyou can exclude files from being copied using the optional bundling string array parameter `assetexcludes`:\n\n```python\npython.pythonfunction(self, \"function\",\n    entry=\"/path/to/poetry-function\",\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        # translates to `rsync --exclude='.venv'`\n        asset_excludes=[\".venv\"]\n    )\n)\n```\n\n**including hashes**\n\nyou can include hashes in `poetry` using the optional boolean parameter `poetryincludehashes`:\n\n```python\npython.pythonfunction(self, \"function\",\n    entry=\"/path/to/poetry-function\",\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        poetry_include_hashes=true\n    )\n)\n```\n\n**excluding urls**\n\nyou can exclude urls in `poetry` using the optional boolean parameter `poetrywithouturls`:\n\n```python\npython.pythonfunction(self, \"function\",\n    entry=\"/path/to/poetry-function\",\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        poetry_without_urls=true\n    )\n)\n```\n\n## custom bundling\n\ncustom bundling can be performed by passing in additional build arguments that point to index urls to private repos, or by using an entirely custom docker images for bundling dependencies. the build args currently supported are:\n\n* `pip_index_url`\n* `pip_extra_index_url`\n* `https_proxy`\n\nadditional build args for bundling that refer to pypi indexes can be specified as:\n\n```python\nentry = \"/path/to/function\"\nimage = dockerimage.from_build(entry)\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        build_args={\"pip_index_url\": \"https://your.index.url/simple/\", \"pip_extra_index_url\": \"https://your.extra-index.url/simple/\"}\n    )\n)\n```\n\nif using a custom docker image for bundling, the dependencies are installed with `pip`, `pipenv` or `poetry` by using the `packaging` class. a different bundling docker image that is in the same directory as the function can be specified as:\n\n```python\nentry = \"/path/to/function\"\nimage = dockerimage.from_build(entry)\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(image=image)\n)\n```\n\nyou can set additional docker options to configure the build environment:\n\n```python\nentry = \"/path/to/function\"\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        network=\"host\",\n        security_opt=\"no-new-privileges\",\n        user=\"user:group\",\n        volumes_from=[\"777f7dc92da7\"],\n        volumes=[dockervolume(host_path=\"/host-path\", container_path=\"/container-path\")]\n    )\n)\n```\n\n## custom bundling with code artifact\n\nto use a code artifact pypi repo, the `pip_index_url` for bundling the function can be customized (requires aws cli in the build environment):\n\n```python\nfrom child_process import exec_sync\n\n\nentry = \"/path/to/function\"\nimage = dockerimage.from_build(entry)\n\ndomain = \"my-domain\"\ndomain_owner = \"111122223333\"\nrepo_name = \"my_repo\"\nregion = \"us-east-1\"\ncode_artifact_auth_token = exec_sync(f\"aws codeartifact get-authorization-token --domain {domain} --domain-owner {domainowner} --query authorizationtoken --output text\").to_string().trim()\n\nindex_url = f\"https://aws:{codeartifactauthtoken}@{domain}-{domainowner}.d.codeartifact.{region}.amazonaws.com/pypi/{reponame}/simple/\"\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        environment={\"pip_index_url\": index_url}\n    )\n)\n```\n\nthe index url or the token are only used during bundling and thus not included in the final asset. setting only environment variable for `pip_index_url` or `pip_extra_index_url` should work for accesing private python repositories with `pip`, `pipenv` and `poetry` based dependencies.\n\nif you also want to use the code artifact repo for building the base docker image for bundling, use `buildargs`. however, note that setting custom build args for bundling will force the base bundling image to be rebuilt every time (i.e. skip the docker cache). build args can be customized as:\n\n```python\nfrom child_process import exec_sync\n\n\nentry = \"/path/to/function\"\nimage = dockerimage.from_build(entry)\n\ndomain = \"my-domain\"\ndomain_owner = \"111122223333\"\nrepo_name = \"my_repo\"\nregion = \"us-east-1\"\ncode_artifact_auth_token = exec_sync(f\"aws codeartifact get-authorization-token --domain {domain} --domain-owner {domainowner} --query authorizationtoken --output text\").to_string().trim()\n\nindex_url = f\"https://aws:{codeartifactauthtoken}@{domain}-{domainowner}.d.codeartifact.{region}.amazonaws.com/pypi/{reponame}/simple/\"\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        build_args={\"pip_index_url\": index_url}\n    )\n)\n```\n\n## command hooks\n\nit is  possible to run additional commands by specifying the `commandhooks` prop:\n\n```python\nentry = \"/path/to/function\"\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        command_hooks={\n            # run tests\n            def before_bundling(self, input_dir):\n                return [\"pytest\"],\n            def after_bundling(self, input_dir):\n                return [\"pylint\"]\n        }\n    )\n)\n```\n\nthe following hooks are available:\n\n* `beforebundling`: runs before all bundling commands\n* `afterbundling`: runs after all bundling commands\n\nthey all receive the directory containing the dependencies file (`inputdir`) and the\ndirectory where the bundled asset will be output (`outputdir`). they must return\nan array of commands to run. commands are chained with `&&`.\n\nthe commands will run in the environment in which bundling occurs: inside the\ncontainer for docker bundling or on the host os for local bundling.\n\n## docker based bundling in complex docker configurations\n\nby default the input and output of docker based bundling is handled via bind mounts.\nin situtations where this does not work, like docker-in-docker setups or when using a remote docker socket, you can configure an alternative, but slower, variant that also works in these situations.\n\n```python\nentry = \"/path/to/function\"\n\npython.pythonfunction(self, \"function\",\n    entry=entry,\n    runtime=runtime.python_3_8,\n    bundling=python.bundlingoptions(\n        bundling_file_access=bundlingfileaccess.volume_copy\n    )\n)\n```\n\n## troubleshooting\n\n### containerfile: no such file or directory\n\nif you are on a mac, using [finch](https://github.com/runfinch/finch) instead of docker, and see an error\nlike this:\n\n```txt\nlstat /private/var/folders/zx/d5wln9n10sn0tcj1v9798f1c0000gr/t/jsii-kernel-9vygro/node_modules/@aws-cdk/aws-lambda-python-alpha/lib/containerfile: no such file or directory\n```\n\nthat is a sign that your temporary directory has not been mapped into the finch vm. add the following to `~/.finch/finch.yaml`:\n\n```yaml\nadditional_directories:\n  - path: /private/var/folders/\n  - path: /var/folders/\n```\n\nthen restart the finch vm by running `finch vm stop && finch vm start`.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-lambda-python-alpha",
  "package_url": "https://pypi.org/project/aws-cdk.aws-lambda-python-alpha/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-lambda-python-alpha/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-lambda-python-alpha/2.116.1a0/",
  "requires_dist": [
    "aws-cdk-lib <3.0.0,>=2.116.1",
    "constructs <11.0.0,>=10.0.0",
    "jsii <2.0.0,>=1.93.0",
    "publication >=0.0.3",
    "typeguard ~=2.13.3"
  ],
  "requires_python": "~=3.8",
  "summary": "the cdk construct library for aws lambda in python",
  "version": "2.116.1a0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "pythonlayerversion lambda_function pythonfunction python3 lambda",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_lambda_python_alpha",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 172,
  "dependency_ids": [
    "pypi_aws_cdk_lib",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}