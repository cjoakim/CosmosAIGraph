{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: pl/sql",
    "programming language :: python :: 3",
    "topic :: scientific/engineering :: information analysis",
    "topic :: scientific/engineering :: mathematics",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "pypika - python query builder\n=============================\n\n.. _intro_start:\n\n|buildstatus|  |coveragestatus|  |codacy|  |docs|  |pypi|  |license|\n\nabstract\n--------\n\nwhat is |brand|?\n\n|brand| is a python api for building sql queries. the motivation behind |brand| is to provide a simple interface for\nbuilding sql queries without limiting the flexibility of handwritten sql. designed with data analysis in mind, |brand|\nleverages the builder design pattern to construct queries to avoid messy string formatting and concatenation. it is also\neasily extended to take full advantage of specific features of sql database vendors.\n\nwhat are the design goals for |brand|?\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n|brand| is a fast, expressive and flexible way to replace handwritten sql (or even orm for the courageous souls amongst you).\nvalidation of sql correctness is not an explicit goal of |brand|. with such a large number of\nsql database vendors providing a robust validation of input data is difficult. instead you are encouraged to check inputs you provide to |brand| or appropriately handle errors raised from\nyour sql database - just as you would have if you were writing sql yourself.\n\n.. _intro_end:\n\nread the docs: http://pypika.readthedocs.io/en/latest/\n\ninstallation\n------------\n\n.. _installation_start:\n\n|brand| supports python ``3.6+``.  it may also work on pypy, cython, and jython, but is not being tested for these versions.\n\nto install |brand| run the following command:\n\n.. code-block:: bash\n\n    pip install pypika\n\n\n.. _installation_end:\n\n\ntutorial\n--------\n\n.. _tutorial_start:\n\nthe main classes in pypika are ``pypika.query``, ``pypika.table``, and ``pypika.field``.\n\n.. code-block:: python\n\n    from pypika import query, table, field\n\n\nselecting data\n^^^^^^^^^^^^^^\n\nthe entry point for building queries is ``pypika.query``.  in order to select columns from a table, the table must\nfirst be added to the query.  for simple queries with only one table, tables and columns can be references using\nstrings.  for more sophisticated queries a ``pypika.table`` must be used.\n\n.. code-block:: python\n\n    q = query.from_('customers').select('id', 'fname', 'lname', 'phone')\n\nto convert the query into raw sql, it can be cast to a string.\n\n.. code-block:: python\n\n    str(q)\n\nalternatively, you can use the `query.get_sql()` function:\n\n.. code-block:: python\n\n    q.get_sql()\n\n\ntables, columns, schemas, and databases\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nin simple queries like the above example, columns in the \"from\" table can be referenced by passing string names into\nthe ``select`` query builder function. in more complex examples, the ``pypika.table`` class should be used. columns can be\nreferenced as attributes on instances of ``pypika.table``.\n\n.. code-block:: python\n\n    from pypika import table, query\n\n    customers = table('customers')\n    q = query.from_(customers).select(customers.id, customers.fname, customers.lname, customers.phone)\n\nboth of the above examples result in the following sql:\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers\n\nan alias for the table can be given using the ``.as_`` function on ``pypika.table``\n\n.. code-block:: sql\n\n    customers = table('x_view_customers').as_('customers')\n    q = query.from_(customers).select(customers.id, customers.phone)\n\n.. code-block:: sql\n\n    select id,phone from x_view_customers customers\n\na schema can also be specified. tables can be referenced as attributes on the schema.\n\n.. code-block:: sql\n\n    from pypika import table, query, schema\n\n    views = schema('views')\n    q = query.from_(views.customers).select(customers.id, customers.phone)\n\n.. code-block:: sql\n\n    select id,phone from views.customers\n\nalso references to databases can be used. schemas can be referenced as attributes on the database.\n\n.. code-block:: sql\n\n    from pypika import table, query, database\n\n    my_db = database('my_db')\n    q = query.from_(my_db.analytics.customers).select(customers.id, customers.phone)\n\n.. code-block:: sql\n\n    select id,phone from my_db.analytics.customers\n\n\nresults can be ordered by using the following syntax:\n\n.. code-block:: python\n\n    from pypika import order\n    query.from_('customers').select('id', 'fname', 'lname', 'phone').orderby('id', order=order.desc)\n\nthis results in the following sql:\n\n.. code-block:: sql\n\n    select \"id\",\"fname\",\"lname\",\"phone\" from \"customers\" order by \"id\" desc\n\narithmetic\n\"\"\"\"\"\"\"\"\"\"\n\narithmetic expressions can also be constructed using pypika.  operators such as `+`, `-`, `*`, and `/` are implemented\nby ``pypika.field`` which can be used simply with a ``pypika.table`` or directly.\n\n.. code-block:: python\n\n    from pypika import field\n\n    q = query.from_('account').select(\n        field('revenue') - field('cost')\n    )\n\n.. code-block:: sql\n\n    select revenue-cost from accounts\n\nusing ``pypika.table``\n\n.. code-block:: python\n\n    accounts = table('accounts')\n    q = query.from_(accounts).select(\n        accounts.revenue - accounts.cost\n    )\n\n.. code-block:: sql\n\n    select revenue-cost from accounts\n\nan alias can also be used for fields and expressions.\n\n.. code-block:: sql\n\n    q = query.from_(accounts).select(\n        (accounts.revenue - accounts.cost).as_('profit')\n    )\n\n.. code-block:: sql\n\n    select revenue-cost profit from accounts\n\nmore arithmetic examples\n\n.. code-block:: python\n\n    table = table('table')\n    q = query.from_(table).select(\n        table.foo + table.bar,\n        table.foo - table.bar,\n        table.foo * table.bar,\n        table.foo / table.bar,\n        (table.foo+table.bar) / table.fiz,\n    )\n\n.. code-block:: sql\n\n    select foo+bar,foo-bar,foo*bar,foo/bar,(foo+bar)/fiz from table\n\n\nfiltering\n\"\"\"\"\"\"\"\"\"\n\nqueries can be filtered with ``pypika.criterion`` by using equality or inequality operators\n\n.. code-block:: python\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id, customers.fname, customers.lname, customers.phone\n    ).where(\n        customers.lname == 'mustermann'\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers where lname='mustermann'\n\nquery methods such as select, where, groupby, and orderby can be called multiple times.  multiple calls to the where\nmethod will add additional conditions as\n\n.. code-block:: python\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id, customers.fname, customers.lname, customers.phone\n    ).where(\n        customers.fname == 'max'\n    ).where(\n        customers.lname == 'mustermann'\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers where fname='max' and lname='mustermann'\n\nfilters such as in and between are also supported\n\n.. code-block:: python\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id,customers.fname\n    ).where(\n        customers.age[18:65] & customers.status.isin(['new', 'active'])\n    )\n\n.. code-block:: sql\n\n    select id,fname from customers where age between 18 and 65 and status in ('new','active')\n\nfiltering with complex criteria can be created using boolean symbols ``&``, ``|``, and ``^``.\n\nand\n\n.. code-block:: python\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id, customers.fname, customers.lname, customers.phone\n    ).where(\n        (customers.age >= 18) & (customers.lname == 'mustermann')\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers where age>=18 and lname='mustermann'\n\nor\n\n.. code-block:: python\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id, customers.fname, customers.lname, customers.phone\n    ).where(\n        (customers.age >= 18) | (customers.lname == 'mustermann')\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers where age>=18 or lname='mustermann'\n\nxor\n\n.. code-block:: python\n\n customers = table('customers')\n q = query.from_(customers).select(\n     customers.id, customers.fname, customers.lname, customers.phone\n ).where(\n     (customers.age >= 18) ^ customers.is_registered\n )\n\n.. code-block:: sql\n\n    select id,fname,lname,phone from customers where age>=18 xor is_registered\n\n\nconvenience methods\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nin the `criterion` class, there are the static methods `any` and `all` that allow building chains and and or expressions with a list of terms.\n\n.. code-block:: python\n\n    from pypika import criterion\n\n    customers = table('customers')\n    q = query.from_(customers).select(\n        customers.id,\n        customers.fname\n    ).where(\n        criterion.all([\n            customers.is_registered,\n            customers.age >= 18,\n            customers.lname == \"jones\",\n        ])\n    )\n\n.. code-block:: sql\n\n    select id,fname from customers where is_registered and age>=18 and lname = \"jones\"\n\n\ngrouping and aggregating\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ngrouping allows for aggregated results and works similar to ``select`` clauses.\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    customers = table('customers')\n    q = query \\\n        .from_(customers) \\\n        .where(customers.age >= 18) \\\n        .groupby(customers.id) \\\n        .select(customers.id, fn.sum(customers.revenue))\n\n.. code-block:: sql\n\n    select id,sum(\"revenue\") from \"customers\" where \"age\">=18 group by \"id\"\n\nafter adding a ``group by`` clause to a query, the ``having`` clause becomes available.  the method\n``query.having()`` takes a ``criterion`` parameter similar to the method ``query.where()``.\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    payments = table('payments')\n    q = query \\\n        .from_(payments) \\\n        .where(payments.transacted[date(2015, 1, 1):date(2016, 1, 1)]) \\\n        .groupby(payments.customer_id) \\\n        .having(fn.sum(payments.total) >= 1000) \\\n        .select(payments.customer_id, fn.sum(payments.total))\n\n.. code-block:: sql\n\n    select customer_id,sum(total) from payments\n    where transacted between '2015-01-01' and '2016-01-01'\n    group by customer_id having sum(total)>=1000\n\n\njoining tables and subqueries\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ntables and subqueries can be joined to any query using the ``query.join()`` method.  joins can be performed with either\na ``using`` or ``on`` clauses.  the ``using`` clause can be used when both tables/subqueries contain the same field and\nthe ``on`` clause can be used with a criterion. to perform a join, ``...join()`` can be chained but then must be\nfollowed immediately by ``...on(<criterion>)`` or ``...using(*field)``.\n\n\njoin types\n~~~~~~~~~~\n\nall join types are supported by |brand|.\n\n.. code-block:: python\n\n    query \\\n        .from_(base_table)\n        ...\n        .join(join_table, jointype.left)\n        ...\n\n\n.. code-block:: python\n\n    query \\\n        .from_(base_table)\n        ...\n        .left_join(join_table) \\\n        .left_outer_join(join_table) \\\n        .right_join(join_table) \\\n        .right_outer_join(join_table) \\\n        .inner_join(join_table) \\\n        .outer_join(join_table) \\\n        .full_outer_join(join_table) \\\n        .cross_join(join_table) \\\n        .hash_join(join_table) \\\n        ...\n\nsee the list of join types here ``pypika.enums.jointypes``\n\nexample of a join using `on`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    history, customers = tables('history', 'customers')\n    q = query \\\n        .from_(history) \\\n        .join(customers) \\\n        .on(history.customer_id == customers.id) \\\n        .select(history.star) \\\n        .where(customers.id == 5)\n\n\n.. code-block:: sql\n\n    select \"history\".* from \"history\" join \"customers\" on \"history\".\"customer_id\"=\"customers\".\"id\" where \"customers\".\"id\"=5\n\nas a shortcut, the ``query.join().on_field()`` function is provided for joining the (first) table in the ``from`` clause\nwith the joined table when the field name(s) are the same in both tables.\n\nexample of a join using `on`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    history, customers = tables('history', 'customers')\n    q = query \\\n        .from_(history) \\\n        .join(customers) \\\n        .on_field('customer_id', 'group') \\\n        .select(history.star) \\\n        .where(customers.group == 'a')\n\n\n.. code-block:: sql\n\n    select \"history\".* from \"history\" join \"customers\" on \"history\".\"customer_id\"=\"customers\".\"customer_id\" and \"history\".\"group\"=\"customers\".\"group\" where \"customers\".\"group\"='a'\n\n\nexample of a join using `using`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    history, customers = tables('history', 'customers')\n    q = query \\\n        .from_(history) \\\n        .join(customers) \\\n        .using('customer_id') \\\n        .select(history.star) \\\n        .where(customers.id == 5)\n\n\n.. code-block:: sql\n\n    select \"history\".* from \"history\" join \"customers\" using \"customer_id\" where \"customers\".\"id\"=5\n\n\nexample of a correlated subquery in the `select`\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    history, customers = tables('history', 'customers')\n    last_purchase_at = query.from_(history).select(\n        history.purchase_at\n    ).where(history.customer_id==customers.customer_id).orderby(\n        history.purchase_at, order=order.desc\n    ).limit(1)\n    q = query.from_(customers).select(\n        customers.id, last_purchase_at.as_('last_purchase_at')\n    )\n\n\n.. code-block:: sql\n\n    select\n      \"id\",\n      (select \"history\".\"purchase_at\"\n       from \"history\"\n       where \"history\".\"customer_id\" = \"customers\".\"customer_id\"\n       order by \"history\".\"purchase_at\" desc\n       limit 1) \"last_purchase_at\"\n    from \"customers\"\n\n\nunions\n\"\"\"\"\"\"\n\nboth ``union`` and ``union all`` are supported. ``union distinct`` is synonomous with \"union`` so |brand| does not\nprovide a separate function for it.  unions require that queries have the same number of ``select`` clauses so\ntrying to cast a unioned query to string will throw a ``setoperationexception`` if the column sizes are mismatched.\n\nto create a union query, use either the ``query.union()`` method or `+` operator with two query instances. for a\nunion all, use ``query.union_all()`` or the `*` operator.\n\n.. code-block:: python\n\n    provider_a, provider_b = tables('provider_a', 'provider_b')\n    q = query.from_(provider_a).select(\n        provider_a.created_time, provider_a.foo, provider_a.bar\n    ) + query.from_(provider_b).select(\n        provider_b.created_time, provider_b.fiz, provider_b.buz\n    )\n\n.. code-block:: sql\n\n    select \"created_time\",\"foo\",\"bar\" from \"provider_a\" union select \"created_time\",\"fiz\",\"buz\" from \"provider_b\"\n\nintersect\n\"\"\"\"\"\"\"\"\"\n\n``intersect`` is supported. intersects require that queries have the same number of ``select`` clauses so\ntrying to cast a intersected query to string will throw a ``setoperationexception`` if the column sizes are mismatched.\n\nto create a intersect query, use the ``query.intersect()`` method.\n\n.. code-block:: python\n\n    provider_a, provider_b = tables('provider_a', 'provider_b')\n    q = query.from_(provider_a).select(\n        provider_a.created_time, provider_a.foo, provider_a.bar\n    )\n    r = query.from_(provider_b).select(\n        provider_b.created_time, provider_b.fiz, provider_b.buz\n    )\n    intersected_query = q.intersect(r)\n\n.. code-block:: sql\n\n    select \"created_time\",\"foo\",\"bar\" from \"provider_a\" intersect select \"created_time\",\"fiz\",\"buz\" from \"provider_b\"\n\nminus\n\"\"\"\"\"\n\n``minus`` is supported. minus require that queries have the same number of ``select`` clauses so\ntrying to cast a minus query to string will throw a ``setoperationexception`` if the column sizes are mismatched.\n\nto create a minus query, use either the ``query.minus()`` method or `-` operator with two query instances.\n\n.. code-block:: python\n\n    provider_a, provider_b = tables('provider_a', 'provider_b')\n    q = query.from_(provider_a).select(\n        provider_a.created_time, provider_a.foo, provider_a.bar\n    )\n    r = query.from_(provider_b).select(\n        provider_b.created_time, provider_b.fiz, provider_b.buz\n    )\n    minus_query = q.minus(r)\n\n    (or)\n\n    minus_query = query.from_(provider_a).select(\n        provider_a.created_time, provider_a.foo, provider_a.bar\n    ) - query.from_(provider_b).select(\n        provider_b.created_time, provider_b.fiz, provider_b.buz\n    )\n\n.. code-block:: sql\n\n    select \"created_time\",\"foo\",\"bar\" from \"provider_a\" minus select \"created_time\",\"fiz\",\"buz\" from \"provider_b\"\n\nexcept\n\"\"\"\"\"\"\n\n``except`` is supported. minus require that queries have the same number of ``select`` clauses so\ntrying to cast a except query to string will throw a ``setoperationexception`` if the column sizes are mismatched.\n\nto create a except query, use the ``query.except_of()`` method.\n\n.. code-block:: python\n\n    provider_a, provider_b = tables('provider_a', 'provider_b')\n    q = query.from_(provider_a).select(\n        provider_a.created_time, provider_a.foo, provider_a.bar\n    )\n    r = query.from_(provider_b).select(\n        provider_b.created_time, provider_b.fiz, provider_b.buz\n    )\n    minus_query = q.except_of(r)\n\n.. code-block:: sql\n\n    select \"created_time\",\"foo\",\"bar\" from \"provider_a\" except select \"created_time\",\"fiz\",\"buz\" from \"provider_b\"\n\ndate, time, and intervals\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nusing ``pypika.interval``, queries can be constructed with date arithmetic.  any combination of intervals can be\nused except for weeks and quarters, which must be used separately and will ignore any other values if selected.\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    fruits = tables('fruits')\n    q = query.from_(fruits) \\\n        .select(fruits.id, fruits.name) \\\n        .where(fruits.harvest_date + interval(months=1) < fn.now())\n\n.. code-block:: sql\n\n    select id,name from fruits where harvest_date+interval 1 month<now()\n\n\ntuples\n\"\"\"\"\"\"\n\ntuples are supported through the class ``pypika.tuple`` but also through the native python tuple wherever possible.\ntuples can be used with ``pypika.criterion`` in **where** clauses for pairwise comparisons.\n\n.. code-block:: python\n\n    from pypika import query, tuple\n\n    q = query.from_(self.table_abc) \\\n        .select(self.table_abc.foo, self.table_abc.bar) \\\n        .where(tuple(self.table_abc.foo, self.table_abc.bar) == tuple(1, 2))\n\n.. code-block:: sql\n\n    select \"foo\",\"bar\" from \"abc\" where (\"foo\",\"bar\")=(1,2)\n\nusing ``pypika.tuple`` on both sides of the comparison is redundant and |brand| supports native python tuples.\n\n.. code-block:: python\n\n    from pypika import query, tuple\n\n    q = query.from_(self.table_abc) \\\n        .select(self.table_abc.foo, self.table_abc.bar) \\\n        .where(tuple(self.table_abc.foo, self.table_abc.bar) == (1, 2))\n\n.. code-block:: sql\n\n    select \"foo\",\"bar\" from \"abc\" where (\"foo\",\"bar\")=(1,2)\n\ntuples can be used in **in** clauses.\n\n.. code-block:: python\n\n    query.from_(self.table_abc) \\\n            .select(self.table_abc.foo, self.table_abc.bar) \\\n            .where(tuple(self.table_abc.foo, self.table_abc.bar).isin([(1, 1), (2, 2), (3, 3)]))\n\n.. code-block:: sql\n\n    select \"foo\",\"bar\" from \"abc\" where (\"foo\",\"bar\") in ((1,1),(2,2),(3,3))\n\n\nstrings functions\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nthere are several string operations and function wrappers included in |brand|.  function wrappers can be found in the\n``pypika.functions`` package.  in addition, `like` and `regex` queries are supported as well.\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    customers = tables('customers')\n    q = query.from_(customers).select(\n        customers.id,\n        customers.fname,\n        customers.lname,\n    ).where(\n        customers.lname.like('mc%')\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname from customers where lname like 'mc%'\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    customers = tables('customers')\n    q = query.from_(customers).select(\n        customers.id,\n        customers.fname,\n        customers.lname,\n    ).where(\n        customers.lname.regex(r'^[abc][a-za-z]+&')\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname from customers where lname regex '^[abc][a-za-z]+&';\n\n\n.. code-block:: python\n\n    from pypika import functions as fn\n\n    customers = tables('customers')\n    q = query.from_(customers).select(\n        customers.id,\n        fn.concat(customers.fname, ' ', customers.lname).as_('full_name'),\n    )\n\n.. code-block:: sql\n\n    select id,concat(fname, ' ', lname) full_name from customers\n\n\ncustom functions\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ncustom functions allows us to use any function on queries, as some functions are not covered by pypika as default, we can appeal\nto custom functions.\n\n.. code-block:: python\n\n    from pypika import customfunction\n\n    customers = tables('customers')\n    datediff = customfunction('date_diff', ['interval', 'start_date', 'end_date'])\n\n    q = query.from_(customers).select(\n        customers.id,\n        customers.fname,\n        customers.lname,\n        datediff('day', customers.created_date, customers.updated_date)\n    )\n\n.. code-block:: sql\n\n    select id,fname,lname,date_diff('day',created_date,updated_date) from customers\n\ncase statements\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\ncase statements allow fow a number of conditions to be checked sequentially and return a value for the first condition\nmet or otherwise a default value.  the case object can be used to chain conditions together along with their output\nusing the ``when`` method and to set the default value using ``else_``.\n\n\n.. code-block:: python\n\n    from pypika import case, functions as fn\n\n    customers = tables('customers')\n    q = query.from_(customers).select(\n        customers.id,\n        case()\n           .when(customers.fname == \"tom\", \"it was tom\")\n           .when(customers.fname == \"john\", \"it was john\")\n           .else_(\"it was someone else.\").as_('who_was_it')\n    )\n\n\n.. code-block:: sql\n\n    select \"id\",case when \"fname\"='tom' then 'it was tom' when \"fname\"='john' then 'it was john' else 'it was someone else.' end \"who_was_it\" from \"customers\"\n\n\nwith clause\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nwith clause allows give a sub-query block a name, which can be referenced in several places within the main sql query.\nthe sql with clause is basically a drop-in replacement to the normal sub-query.\n\n.. code-block:: python\n\n    from pypika import table, aliasedquery, query\n\n    customers = table('customers')\n\n    sub_query = (query\n                .from_(customers)\n                .select('*'))\n\n    test_query = (query\n                .with_(sub_query, \"an_alias\")\n                .from_(aliasedquery(\"an_alias\"))\n                .select('*'))\n\nyou can use as much as `.with_()` as you want.\n\n.. code-block:: sql\n\n    with an_alias as (select * from \"customers\") select * from an_alias\n\n\ninserting data\n^^^^^^^^^^^^^^\n\ndata can be inserted into tables either by providing the values in the query or by selecting them through another query.\n\nby default, data can be inserted by providing values for all columns in the order that they are defined in the table.\n\ninsert with values\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = query.into(customers).insert(1, 'jane', 'doe', 'jane@example.com')\n\n.. code-block:: sql\n\n    insert into customers values (1,'jane','doe','jane@example.com')\n\n.. code-block:: python\n\n    customers =  table('customers')\n\n    q = customers.insert(1, 'jane', 'doe', 'jane@example.com')\n\n.. code-block:: sql\n\n    insert into customers values (1,'jane','doe','jane@example.com')\n\nmultiple rows of data can be inserted either by chaining the ``insert`` function or passing multiple tuples as args.\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = query.into(customers).insert(1, 'jane', 'doe', 'jane@example.com').insert(2, 'john', 'doe', 'john@example.com')\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = query.into(customers).insert((1, 'jane', 'doe', 'jane@example.com'),\n                                     (2, 'john', 'doe', 'john@example.com'))\n\ninsert with constraint violation handling\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nmysql\n~~~~~\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = mysqlquery.into(customers) \\\n        .insert(1, 'jane', 'doe', 'jane@example.com') \\\n        .on_duplicate_key_ignore())\n\n.. code-block:: sql\n\n    insert into `customers` values (1,'jane','doe','jane@example.com') on duplicate key ignore\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = mysqlquery.into(customers) \\\n        .insert(1, 'jane', 'doe', 'jane@example.com') \\\n        .on_duplicate_key_update(customers.email, values(customers.email))\n\n.. code-block:: sql\n\n    insert into `customers` values (1,'jane','doe','jane@example.com') on duplicate key update `email`=values(`email`)\n\n``.on_duplicate_key_update`` works similar to ``.set`` for updating rows, additionally it provides the ``values``\nwrapper to update to the value specified in the ``insert`` clause.\n\npostgresql\n~~~~~~~~~~\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = postgresqlquery.into(customers) \\\n        .insert(1, 'jane', 'doe', 'jane@example.com') \\\n        .on_conflict(customers.email) \\\n        .do_nothing()\n\n.. code-block:: sql\n\n    insert into \"customers\" values (1,'jane','doe','jane@example.com') on conflict (\"email\") do nothing\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = postgresqlquery.into(customers) \\\n        .insert(1, 'jane', 'doe', 'jane@example.com') \\\n        .on_conflict(customers.email) \\\n        .do_update(customers.email, 'bob@example.com')\n\n.. code-block:: sql\n\n    insert into \"customers\" values (1,'jane','doe','jane@example.com') on conflict (\"email\") do update set \"email\"='bob@example.com'\n\n\ninsert from a select sub-query\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n.. code-block:: sql\n\n    insert into \"customers\" values (1,'jane','doe','jane@example.com'),(2,'john','doe','john@example.com')\n\n\nto specify the columns and the order, use the ``columns`` function.\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = query.into(customers).columns('id', 'fname', 'lname').insert(1, 'jane', 'doe')\n\n.. code-block:: sql\n\n    insert into customers (id,fname,lname) values (1,'jane','doe','jane@example.com')\n\n\ninserting data with a query works the same as querying data with the additional call to the ``into`` method in the\nbuilder chain.\n\n.. code-block:: python\n\n    customers, customers_backup = tables('customers', 'customers_backup')\n\n    q = query.into(customers_backup).from_(customers).select('*')\n\n.. code-block:: sql\n\n    insert into customers_backup select * from customers\n\n.. code-block:: python\n\n    customers, customers_backup = tables('customers', 'customers_backup')\n\n    q = query.into(customers_backup).columns('id', 'fname', 'lname')\n        .from_(customers).select(customers.id, customers.fname, customers.lname)\n\n.. code-block:: sql\n\n    insert into customers_backup select \"id\", \"fname\", \"lname\" from customers\n\nthe syntax for joining tables is the same as when selecting data\n\n.. code-block:: python\n\n    customers, orders, orders_backup = tables('customers', 'orders', 'orders_backup')\n\n    q = query.into(orders_backup).columns('id', 'address', 'customer_fname', 'customer_lname')\n        .from_(customers)\n        .join(orders).on(orders.customer_id == customers.id)\n        .select(orders.id, customers.fname, customers.lname)\n\n.. code-block:: sql\n\n   insert into \"orders_backup\" (\"id\",\"address\",\"customer_fname\",\"customer_lname\")\n   select \"orders\".\"id\",\"customers\".\"fname\",\"customers\".\"lname\" from \"customers\"\n   join \"orders\" on \"orders\".\"customer_id\"=\"customers\".\"id\"\n\nupdating data\n^^^^^^^^^^^^^^\npypika allows update queries to be constructed with or without where clauses.\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    query.update(customers).set(customers.last_login, '2017-01-01 10:00:00')\n\n    query.update(customers).set(customers.lname, 'smith').where(customers.id == 10)\n\n.. code-block:: sql\n\n    update \"customers\" set \"last_login\"='2017-01-01 10:00:00'\n\n    update \"customers\" set \"lname\"='smith' where \"id\"=10\n\nthe syntax for joining tables is the same as when selecting data\n\n.. code-block:: python\n\n    customers, profiles = tables('customers', 'profiles')\n\n    query.update(customers)\n         .join(profiles).on(profiles.customer_id == customers.id)\n         .set(customers.lname, profiles.lname)\n\n.. code-block:: sql\n\n   update \"customers\"\n   join \"profiles\" on \"profiles\".\"customer_id\"=\"customers\".\"id\"\n   set \"customers\".\"lname\"=\"profiles\".\"lname\"\n\nusing ``pypika.table`` alias to perform the update\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    customers.update()\n            .set(customers.lname, 'smith')\n            .where(customers.id == 10)\n\n.. code-block:: sql\n\n    update \"customers\" set \"lname\"='smith' where \"id\"=10\n\nusing ``limit`` for performing update\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    customers.update()\n            .set(customers.lname, 'smith')\n            .limit(2)\n\n.. code-block:: sql\n\n    update \"customers\" set \"lname\"='smith' limit 2\n\n\nparametrized queries\n^^^^^^^^^^^^^^^^^^^^\n\npypika allows you to use ``parameter(str)`` term as a placeholder for parametrized queries.\n\n.. code-block:: python\n\n    customers = table('customers')\n\n    q = query.into(customers).columns('id', 'fname', 'lname')\n        .insert(parameter(':1'), parameter(':2'), parameter(':3'))\n\n.. code-block:: sql\n\n    insert into customers (id,fname,lname) values (:1,:2,:3)\n\nthis allows you to build prepared statements, and/or avoid sql-injection related risks.\n\ndue to the mix of syntax for parameters, depending on connector/driver, it is required that you specify the\nparameter token explicitly or use one of the specialized parameter types per [pep-0249](https://www.python.org/dev/peps/pep-0249/#paramstyle):\n``qmarkparameter()``, ``numericparameter(int)``,  ``namedparameter(str)``, ``formatparameter()``, ``pyformatparameter(str)``\n\nan example of some common sql parameter styles used in python drivers are:\n\npostgresql:\n    ``$number`` or ``%s`` + ``:name`` (depending on driver)\nmysql:\n    ``%s``\nsqlite:\n    ``?``\nvertica:\n    ``:name``\noracle:\n    ``:number`` + ``:name``\nmssql:\n    ``%(name)s`` or ``:name`` + ``:number`` (depending on driver)\n\nyou can find out what parameter style is needed for dbapi compliant drivers here: https://www.python.org/dev/peps/pep-0249/#paramstyle or in the db driver documentation.\n\ntemporal support\n^^^^^^^^^^^^^^^^\n\ntemporal criteria can be added to the tables.\n\nselect\n\"\"\"\"\"\"\n\nhere is a select using system time.\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(t.for_(system_time.as_of('2020-01-01'))).select(\"*\")\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for system_time as of '2020-01-01'\n\nyou can also use between.\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(\n        t.for_(system_time.between('2020-01-01', '2020-02-01'))\n    ).select(\"*\")\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for system_time between '2020-01-01' and '2020-02-01'\n\nyou can also use a period range.\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(\n        t.for_(system_time.from_to('2020-01-01', '2020-02-01'))\n    ).select(\"*\")\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for system_time from '2020-01-01' to '2020-02-01'\n\nfinally you can select for all times:\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(t.for_(system_time.all_())).select(\"*\")\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for system_time all\n\na user defined period can also be used in the following manner.\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(\n        t.for_(t.valid_period.between('2020-01-01', '2020-02-01'))\n    ).select(\"*\")\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for \"valid_period\" between '2020-01-01' and '2020-02-01'\n\njoins\n\"\"\"\"\"\n\nwith joins, when the table object is used when specifying columns, it is\nimportant to use the table from which the temporal constraint was generated.\nthis is because `table(\"abc\")` is not the same table as `table(\"abc\").for_(...)`.\nthe following example demonstrates this.\n\n.. code-block:: python\n\n    t0 = table(\"abc\").for_(system_time.as_of('2020-01-01'))\n    t1 = table(\"efg\").for_(system_time.as_of('2020-01-01'))\n    query = (\n        query.from_(t0)\n        .join(t1)\n        .on(t0.foo == t1.bar)\n        .select(\"*\")\n    )\n\nthis produces:\n\n.. code-block:: sql\n\n    select * from \"abc\" for system_time as of '2020-01-01'\n    join \"efg\" for system_time as of '2020-01-01'\n    on \"abc\".\"foo\"=\"efg\".\"bar\"\n\nupdate & deletes\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nan update can be written as follows:\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.update(\n        t.for_portion(\n            system_time.from_to('2020-01-01', '2020-02-01')\n        )\n    ).set(\"foo\", \"bar\")\n\nthis produces:\n\n.. code-block:: sql\n\n    update \"abc\"\n    for portion of system_time from '2020-01-01' to '2020-02-01'\n    set \"foo\"='bar'\n\nhere is a delete:\n\n.. code-block:: python\n\n    t = table(\"abc\")\n    q = query.from_(\n        t.for_portion(t.valid_period.from_to('2020-01-01', '2020-02-01'))\n    ).delete()\n\nthis produces:\n\n.. code-block:: sql\n\n    delete from \"abc\"\n    for portion of \"valid_period\" from '2020-01-01' to '2020-02-01'\n\ncreating tables\n^^^^^^^^^^^^^^^\n\nthe entry point for creating tables is ``pypika.query.create_table``, which is used with the class ``pypika.column``.\nas with selecting data, first the table should be specified. this can be either a\nstring or a `pypika.table`. then the columns, and constraints. here's an example\nthat demonstrates much of the functionality.\n\n.. code-block:: python\n\n    stmt = query \\\n        .create_table(\"person\") \\\n        .columns(\n            column(\"id\", \"int\", nullable=false),\n            column(\"first_name\", \"varchar(100)\", nullable=false),\n            column(\"last_name\", \"varchar(100)\", nullable=false),\n            column(\"phone_number\", \"varchar(20)\", nullable=true),\n            column(\"status\", \"varchar(20)\", nullable=false, default=valuewrapper(\"new\")),\n            column(\"date_of_birth\", \"datetime\")) \\\n        .unique(\"last_name\", \"first_name\") \\\n        .primary_key(\"id\")\n\nthis produces:\n\n.. code-block:: sql\n\n    create table \"person\" (\n        \"id\" int not null,\n        \"first_name\" varchar(100) not null,\n        \"last_name\" varchar(100) not null,\n        \"phone_number\" varchar(20) null,\n        \"status\" varchar(20) not null default 'new',\n        \"date_of_birth\" datetime,\n        unique (\"last_name\",\"first_name\"),\n        primary key (\"id\")\n    )\n\nthere is also support for creating a table from a query.\n\n.. code-block:: python\n\n    stmt = query.create_table(\"names\").as_select(\n        query.from_(\"person\").select(\"last_name\", \"first_name\")\n    )\n\nthis produces:\n\n.. code-block:: sql\n\n        create table \"names\" as (select \"last_name\",\"first_name\" from \"person\")\n\n.. _tutorial_end:\n\n\n.. _license_start:\n\n\nlicense\n-------\n\ncopyright 2020 kayak germany, gmbh\n\nlicensed under the apache license, version 2.0 (the \"license\");\nyou may not use this file except in compliance with the license.\nyou may obtain a copy of the license at\n\n    http://www.apache.org/licenses/license-2.0\n\nunless required by applicable law or agreed to in writing, software\ndistributed under the license is distributed on an \"as is\" basis,\nwithout warranties or conditions of any kind, either express or implied.\nsee the license for the specific language governing permissions and\nlimitations under the license.\n\n\ncrafted with \u2665 in berlin.\n\n.. _license_end:\n\n\n.. _appendix_start:\n\n.. |brand| replace:: *pypika*\n\n.. _appendix_end:\n\n.. _available_badges_start:\n\n.. |buildstatus| image:: https://github.com/kayak/pypika/workflows/unit%20tests/badge.svg\n   :target: https://github.com/kayak/pypika/actions\n.. |coveragestatus| image:: https://coveralls.io/repos/kayak/pypika/badge.svg?branch=master\n   :target: https://coveralls.io/github/kayak/pypika?branch=master\n.. |codacy| image:: https://api.codacy.com/project/badge/grade/6d7e44e5628b4839a23da0bd82eaafcf\n   :target: https://www.codacy.com/app/twheys/pypika\n.. |docs| image:: https://readthedocs.org/projects/pypika/badge/?version=latest\n   :target: http://pypika.readthedocs.io/en/latest/\n.. |pypi| image:: https://img.shields.io/pypi/v/pypika.svg?style=flat\n   :target: https://pypi.python.org/pypi/pypika\n.. |license| image:: https://img.shields.io/hexpm/l/plug.svg?maxage=2592000\n   :target: http://www.apache.org/licenses/license-2.0\n\n.. _available_badges_end:\n\n\n",
  "docs_url": null,
  "keywords": "pypika python query builder querybuilder sql mysql postgres psql oracle vertica aggregated relational database rdbms business analytics bi data science analysis pandas orm object mapper",
  "license": "apache license version 2.0",
  "name": "pypika",
  "package_url": "https://pypi.org/project/PyPika/",
  "project_url": "https://pypi.org/project/PyPika/",
  "project_urls": {
    "Homepage": "https://github.com/kayak/pypika"
  },
  "release_url": "https://pypi.org/project/PyPika/0.48.9/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a sql query builder api for python",
  "version": "0.48.9",
  "releases": [],
  "developers": [
    "theys@kayak.com",
    "timothy_heys"
  ],
  "kwds": "brand querybuilder sql queries querying",
  "license_kwds": "apache license version 2.0",
  "libtype": "pypi",
  "id": "pypi_pypika",
  "homepage": "https://github.com/kayak/pypika",
  "release_count": 214,
  "dependency_ids": []
}