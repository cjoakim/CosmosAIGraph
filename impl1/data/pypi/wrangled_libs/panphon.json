{
  "classifiers": [
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: linguistic"
  ],
  "description": "# panphon\n\n## citing panphon\n\nif you use panphon in research, please cite the [following paper](https://www.aclweb.org/anthology/c/c16/c16-1328.pdf):\n\ndavid r. mortensen, patrick littell, akash bharadwaj, kartik goyal, chris dyer, lori levin (2016). \"panphon: a resource for mapping ipa segments to articulatory feature vectors.\" *proceedings of coling 2016, the 26th international conference on computational linguistics: technical papers*, pages 3475\u20133484, osaka, japan, december 11-17 2016.\n\nor in bibtex:\n\n```\n@inproceedings{mortensen-et-al:2016,\n  author    = {david r. mortensen and\n               patrick littell and\n               akash bharadwaj and\n               kartik goyal and\n               chris dyer and\n               lori s. levin},\n  title     = {panphon: {a} resource for mapping {ipa} segments to articulatory feature vectors},\n  booktitle = {proceedings of {coling} 2016, the 26th international conference on computational linguistics: technical papers},\n  pages     = {3475--3484},\n  publisher = {{acl}},\n  year      = {2016}\n}\n```\n\nthis package constitutes a database of segments in the international phonetic alphabet (ipa) and their equivalents in terms of (articulatory) phonological features. they include both data files and the tool `generate_ipa_all.py`, which allows the application of rules for diacritics and modifiers to collections of ipa characters, data files, and configuration/rule files and well as the tool `validate_ipa.py`, which checks unicode ipa text from stdin for well-formedness.\n\n## python api for accessing phonological features of ipa segments\n\nthe `featuretable` class in the `panphon` module provides a straightforward api that allows users and developers to access the segment-feature relationships encoded in the ipa database consisting of the files `panphon/data/ipa_bases.csv` and `diacritic_definitions.yml`.\n\nnote that a new api using faster, more rational, data structures (see the `segment` class in `panphon.segment`) has been introduced. the old api is still available in the module `_panphon`.\n\n```python\n>>> import panphon\n>>> ft = panphon.featuretable()\n>>> ft.word_fts(u'swit')\n[<segment [-syl, -son, +cons, +cont, -delrel, -lat, -nas, 0strid, -voi, -sg, -cg, +ant, +cor, -distr, -lab, -hi, -lo, -back, -round, -velaric, 0tense, -long]>, <segment [-syl, +son, -cons, +cont, -delrel, -lat, -nas, 0strid, +voi, -sg, -cg, -ant, -cor, 0distr, +lab, +hi, -lo, +back, +round, -velaric, 0tense, -long]>, <segment [+syl, +son, -cons, +cont, -delrel, -lat, -nas, 0strid, +voi, -sg, -cg, 0ant, -cor, 0distr, -lab, +hi, -lo, -back, -round, -velaric, +tense, -long]>, <segment [-syl, -son, +cons, -cont, -delrel, -lat, -nas, 0strid, -voi, -sg, -cg, +ant, +cor, -distr, -lab, -hi, -lo, -back, -round, -velaric, 0tense, -long]>]\n>>> ft.word_fts(u'swit')[0].match({'cor': 1})\ntrue\n>>> ft.word_fts(u'swit')[0] >= {'cor': 1}\ntrue\n>>> ft.word_fts(u'swit')[1] >= {'cor': 1}\nfalse\n>>> ft.word_to_vector_list(u'sau\u0279', numeric=false)\n[[u'-', u'-', u'+', u'+', u'-', u'-', u'-', u'0', u'-', u'-', u'-', u'+', u'+', u'-', u'-', u'-', u'-', u'-', u'-', u'-', u'0', u'-'], [u'+', u'+', u'-', u'+', u'-', u'-', u'-', u'0', u'+', u'-', u'-', u'0', u'-', u'0', u'-', u'-', u'+', u'+', u'-', u'-', u'+', u'-'], [u'+', u'+', u'-', u'+', u'-', u'-', u'-', u'0', u'+', u'-', u'-', u'0', u'-', u'0', u'+', u'+', u'-', u'+', u'+', u'-', u'+', u'-'], [u'-', u'+', u'-', u'+', u'-', u'-', u'-', u'0', u'+', u'-', u'-', u'+', u'+', u'-', u'-', u'+', u'-', u'+', u'+', u'-', u'0', u'-']]\n```\n\n## summary of functionality\n\n### operations on feature sets and segments\n\nthe `featuretable` class includes a broad range of operations on features and segments (consonants and vowels).\n\n### converting words to feature arrays\n\nthe `panphon` class includes the function word2array which takes a list of feature names (as a list of strings) and a panphon word (from featuretable().word_fts()) and returns a numpy array where each row corresponds to a segment in the word and each column corresponds to one of the specified features. basic usage is illustrated in the following example:\n\n\n```python\n>>> import panphon\n>>> ft=panphon.featuretable()\n>>> ft.word_array(['syl', 'son', 'cont'], u's\u0251lti')\narray([[-1, -1,  1],\n       [ 1,  1,  1],\n       [-1,  1,  1],\n       [-1, -1, -1],\n       [ 1,  1,  1]])\n```\n\n\n### segment manipulations\n\nthe `segment` class, defined in the `panphon.segment` module, is used to represent analyzed segments in the new `panphon.featuretable` class (code found in `panphon.featuretable`). it provides performance advantages over the old list-of-tuples representation, is more pythonic, and provides additional functionality.\n\n#### construction\n\nthere are two main ways to construct a `segment` object:\n\n\n```python\n>>> from panphon.segment import segment\n>>> segment(['syl', 'son', 'cont'], {'syl': -1, 'son': -1, 'cont': 1})\n<segment [-syl, -son, +cont]>\n>>> segment(['syl', 'son', 'cont'], ftstr='[-syl, -son, +cont]')\n<segment [-syl, -son, +cont]>\n```\n\nin both cases, the first argument passed to the constructor is a list of feature names. this specifies what features a segment has as well as their canonical ordering (used, for example, when a feature vector for a segment is returned as a list). the second argument is a dictionary of feature name-feature value pairs. the feature values are integers from the set {-1, 0 1} (equivalent to {-, 0, +}). this dictionary can be omitted if the keyword argument `ftstr` is included. this string is scanned for sequences of (-|0|+)(\\w+), which are interpreted as name-value (really value-name) pairs.\n\n#### basic querying and updating\n\n`segment` objects implement a dictionary-like interface for manipulating key-value pairs:\n\n\n```python\n>>> a = segment(['syl', 'son', 'cont'], {'syl': -1, 'son': -1, 'cont': 1})\n>>> a\n<segment [-syl, -son, +cont]>\n>>> a['syl']\n-1\n>>> a['son'] = 1\n>>> a\n<segment [-syl, +son, +cont]>\n>>> a.update({'son': -1, 'cont': -1})\n>>> a\n<segment [-syl, -son, -cont]>\n```\n\n\n#### set operations\n\nthe `match` method asks whether the `segment` object on which it is called has a superset of the features contained in the dictionary passed to it as an argument. the >= operator is an alias for the `match` method:\n\n\n```python\n>>> a = segment(['syl', 'son', 'cont'], {'syl': -1, 'son': -1, 'cont': 1})\n>>> a.match({'son': -1, 'cont': 1})\ntrue\n>>> a.match({'son': -1, 'cont': -1})\nfalse\n>>> a >= {'son': -1, 'cont': 1}\ntrue\n>>> a >= {'son': 1, 'cont': 1}\nfalse\n```\n\n\nthe `intersection` method asks which features the `segment` object on which it is called and the dictionary or `segment` object that is passed to it as an argument share. the & operator is an alias for the `intersection` method:\n\n\n```python\n>>> a = segment(['syl', 'son', 'cont'], {'syl': -1, 'son': -1, 'cont': 1})\n>>> a.intersection({'syl': -1, 'son': 1, 'cont': -1})\n<segment [-syl]>\n>>> a & {'syl': -1, 'son': 1, 'cont': -1}\n<segment [-syl]>\n```\n\n\n#### vector representations\n\n`segment` objects can return their vector representations, either as a list of integers or as a list of strings, using the `numeric` and `string` methods:\n\n\n```python\n>>> a = segment(['syl', 'son', 'cont'], {'syl': -1, 'son': -1, 'cont': 1})\n>>> a.numeric()\n[-1, -1, 1]\n>>> a.strings()\n[u'-', u'-', u'+']\n```\n\n\n### fixed-width pattern matching\n\nthe `featuretable` classes also allows matching of fixed-width, feature-based patterns.\n\n### sonority calculations\n\nthe `sonority` class has methods for computing sonority scores for segments.\n\n### feature edit distance\n\nthe `distance` class includes methods for calculating edit distance, both in which the cost of substitutions is based upon hamming distance between the feature vectors and in which the cost of substitutions are based upon edit weights for individual features.\n\n## the `panphon.distance` module\n\nthis module includes the ```distance``` class, which includes various methods for computing the distance between unicode ipa strings, including convenience methods (really \"inconvenience methods\") for computing levenshtein distance, but--more importantly--methods for computing similarity metrics related to articulatory features. the methods include the following:\n\n`panphon.distance.distance` .**levenshtein_distance**\n\na python implementation of levenshtein's string edit distance.\n\n`panphon.distance.distance` .**fast_levenshtein_distance**\n\na c implementation of levenshtein's string edit distance. unsurprisingly, must faster than the former.\n\n`panphon.distance.distance` .**dogol_prime_distance**\n\nfast levenshtein distance after collapsing segments into an enhanced version of dogolpolsky's equivalence classes.\n\n`panphon.distance.distance` .**feature_edit_distance**\n\nedit distance where each feature-edit has cost 1/22. edits from unspecified to specified cost 1/44.\n\n`panphon.distance.distance` .**hamming_feature_edit_distance**\n\nedit distance where each feature-edit has cost 1/22. edits from unspecified to specified also cost 1/22. insertions and substitutions each cost 1.\n\n`panphon.distance.distance` .**weighted_feature_edit_distance**\n\nedit distance where costs of feature edits are differently weighted depending on their class and subjective variability. all of these methods have the same interface and patterns of usage, demonstrated below:\n\n\n```python\n>>> import panphon.distance\n>>> dst = panphon.distance.distance()\n>>> dst.dogol_prime_distance(u'pops', u'bobz')\n0\n>>> dst.dogol_prime_distance(u'pops', u'bobo')\n1\n```\n\n\n## scripts\n\n### the `generate_ipa_all.py` script\n\n#### summary\n\nthis small python program allows the user to apply sets of rules, defined in yaml, for adding diacritics and modifiers to ipa segments based upon their phonological features.\n\n#### usage\n\nto generate a segment features file (```ipa_all.csv```), use the following **in the panphon data directory**:\n\n\n```bash\n$ generate_ipa_all.py ipa_bases.csv -d diacritic_definitions.yml -s sort_order.yml ipa_all.csv\n```\n\n\nnote that this will overwrite your existing ```ipa_all.csv``` file, which is often what you want.\n\n## data files\n\nthis package also includes multiple data files. the most important of these is ipa_bases.csv, a csv table of ipa characters with definitions in terms of phonological features. from it, and the `diacritics_definitions.yml` file, the comprehensive `ipa_all.csv` is generated.\n\n### ipa character databases: `ipa_bases.csv` and `ipa_all.csv`\n\nthe ipa character table is a csv file in which the first column contains an ipa segment and each subsequent column contains a phonological feature, coded as +, -, or 0. the features are as follows:\n\n* **syl**: syllabic\n* **son**: sonorant\n* **cons**: consonantal\n* **cont**: continuant\n* **delrel**: delayed release\n* **lat**: lateral\n* **nas**: nasal\n* **strid**: strident\n* **voi**: voice\n* **sg**: spread glottis\n* **cg**: constricted glottis\n* **ant**: anterior\n* **cor**: coronal\n* **distr**: distributed\n* **lab**: labial\n* **hi**: high (vowel/consonant, not tone)\n* **lo**: low (vowel/consonant, not tone)\n* **back**: back\n* **round**: round\n* **velaric**: velaric airstream mechanism (click)\n* **tense**: tense\n* **long**: long\n\ninspiration for the data in these tables is drawn primarily from two sources: the data files for [hsspe](https://github.com/dmort27/hsspe) and bruce hayes's [feature spreadsheet](http://www.linguistics.ucla.edu/people/hayes/ip/#features). it has since be re-rationalizeds based on evidence from a wide range of sources. as such, any special relationship to these prior inspirations has been eliminated.\n\nthe ipa character table `ipa_bases.csv` is intended to contain all of the unmodified segmental symbols in ipa, as well as all common affricates and dually-articulated segments. it is meant to be augmented by the rule-driven application of diacritics and modifiers.\n\n## configuration and rule files\n\nthis package includes two files that control the behavior of ```generate_ipa_all.py```. these are intended to be edited by the end user. both are written in [yaml](http://www.yaml.org/), a standardized, human-readable and human-editable data serialization language.\n\n### sort order specification: sort_order.yml\n\nthe file `sort_order.yml` controls the ordering of segments in the output of the diacritic application tool. it is a sequence of maps, each with two fields:\n\n* **name** the name of a feature.\n* **reverse** a boolean value (true or false) specifying whether sorting on the named feature will be reversed or not.\n\nthe order of the features determines the priority of sorting.\n\nthe file `sort_order_schema_.yml` is a [kwalify](http://www.kuwata-lab.com/kwalify/) schema that defines a syntactically valid sort order file.\n\n### diacritic and modifier rules: diacritic_definitions.yml\n\nthe most important file for controlling the diacritic application tool is `diacritic_definitions.yml`, a list of rules for applying diacritics and modifiers to ipa segments based on their phonological features. it has two sections, **diacritics** and **combinations**. each of these is the key to an item in the top-level map.\n\n#### diacritics\n\nthe key **diacritics** points to a list of rules for applying diacritics/modifiers to bases. each rule is a map with the following fields:\n\n* **marker.** the unicode diacritic or modifier.\n* **name.** the name of the series derived from applying the diacritic or modifier.\n* **postion.** the position of the diacritic relative to the base (pre or post).\n* **conditions.** a list of conditions, each of them consisting of an associative array of feature specifications, under which the diacritic or modifier will be applied to a base.\n* **exclude.** a sequence of segments to be excluded from the application of the diacritic/modifier even if they match the conditions.\n* **content.** the feature specifications that will be set if the diacritic or modifier is applied, given as a map of feature specifications.\n\n#### combinations\n\nthe key **combinations** likewise points to a list of rules for combining the rules in **diacritics**. these rules are very simple, and include only the following fields:\n\n* **name.** the name of the combined category.\n* **combines.** a sequence of the names of the rules from\n  **diacritics** that are to be combined.\n\nthe file `diacritic_definitions_schema.yml` is a [kwalify](http://www.kuwata-lab.com/kwalify/) schema that defines a syntactically valid diacritics definition file.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "panphon",
  "package_url": "https://pypi.org/project/panphon/",
  "project_url": "https://pypi.org/project/panphon/",
  "project_urls": {
    "Download": "https://github.com/dmort27/panphon/archive/0.19.1.tar.gz",
    "Homepage": "https://github.com/dmort27/panphon"
  },
  "release_url": "https://pypi.org/project/panphon/0.20.0/",
  "requires_dist": [
    "setuptools",
    "unicodecsv",
    "PyYAML",
    "regex",
    "numpy (>=1.20.2)",
    "editdistance",
    "munkres"
  ],
  "requires_python": "",
  "summary": "tools for using the international phonetic alphabet with phonological features",
  "version": "0.20.0",
  "releases": [],
  "developers": [
    "david_r",
    "dmortens@cs.cmu.edu"
  ],
  "kwds": "ipa_bases linguistics panphon ipa phonetic",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_panphon",
  "homepage": "https://github.com/dmort27/panphon",
  "release_count": 19,
  "dependency_ids": [
    "pypi_editdistance",
    "pypi_munkres",
    "pypi_numpy",
    "pypi_pyyaml",
    "pypi_regex",
    "pypi_setuptools",
    "pypi_unicodecsv"
  ]
}