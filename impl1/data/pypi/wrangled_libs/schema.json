{
  "classifiers": [
    "development status :: 3 - alpha",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: pypy",
    "topic :: utilities"
  ],
  "description": "schema validation just got pythonic\n===============================================================================\n\n**schema** is a library for validating python data structures, such as those\nobtained from config-files, forms, external services or command-line\nparsing, converted from json/yaml (or something else) to python data-types.\n\n\n.. image:: https://secure.travis-ci.org/keleshev/schema.svg?branch=master\n    :target: https://travis-ci.org/keleshev/schema\n\n.. image:: https://img.shields.io/codecov/c/github/keleshev/schema.svg\n    :target: http://codecov.io/github/keleshev/schema\n\nexample\n----------------------------------------------------------------------------\n\nhere is a quick example to get a feeling of **schema**, validating a list of\nentries with personal information:\n\n.. code:: python\n\n    >>> from schema import schema, and, use, optional, schemaerror\n\n    >>> schema = schema([{'name': and(str, len),\n    ...                   'age':  and(use(int), lambda n: 18 <= n <= 99),\n    ...                   optional('gender'): and(str, use(str.lower),\n    ...                                           lambda s: s in ('squid', 'kid'))}])\n\n    >>> data = [{'name': 'sue', 'age': '28', 'gender': 'squid'},\n    ...         {'name': 'sam', 'age': '42'},\n    ...         {'name': 'sacha', 'age': '20', 'gender': 'kid'}]\n\n    >>> validated = schema.validate(data)\n\n    >>> assert validated == [{'name': 'sue', 'age': 28, 'gender': 'squid'},\n    ...                      {'name': 'sam', 'age': 42},\n    ...                      {'name': 'sacha', 'age' : 20, 'gender': 'kid'}]\n\n\nif data is valid, ``schema.validate`` will return the validated data\n(optionally converted with `use` calls, see below).\n\nif data is invalid, ``schema`` will raise ``schemaerror`` exception.\nif you just want to check that the data is valid, ``schema.is_valid(data)`` will\nreturn ``true`` or ``false``.\n\n\ninstallation\n-------------------------------------------------------------------------------\n\nuse `pip <http://pip-installer.org>`_ or easy_install::\n\n    pip install schema\n\nalternatively, you can just drop ``schema.py`` file into your project\u2014it is\nself-contained.\n\n- **schema** is tested with python 2.6, 2.7, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9 and pypy.\n- **schema** follows `semantic versioning <http://semver.org>`_.\n\nhow ``schema`` validates data\n-------------------------------------------------------------------------------\n\ntypes\n~~~~~\n\nif ``schema(...)`` encounters a type (such as ``int``, ``str``, ``object``,\netc.), it will check if the corresponding piece of data is an instance of that type,\notherwise it will raise ``schemaerror``.\n\n.. code:: python\n\n    >>> from schema import schema\n\n    >>> schema(int).validate(123)\n    123\n\n    >>> schema(int).validate('123')\n    traceback (most recent call last):\n    ...\n    schema.schemaunexpectedtypeerror: '123' should be instance of 'int'\n\n    >>> schema(object).validate('hai')\n    'hai'\n\ncallables\n~~~~~~~~~\n\nif ``schema(...)`` encounters a callable (function, class, or object with\n``__call__`` method) it will call it, and if its return value evaluates to\n``true`` it will continue validating, else\u2014it will raise ``schemaerror``.\n\n.. code:: python\n\n    >>> import os\n\n    >>> schema(os.path.exists).validate('./')\n    './'\n\n    >>> schema(os.path.exists).validate('./non-existent/')\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: exists('./non-existent/') should evaluate to true\n\n    >>> schema(lambda n: n > 0).validate(123)\n    123\n\n    >>> schema(lambda n: n > 0).validate(-12)\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: <lambda>(-12) should evaluate to true\n\n\"validatables\"\n~~~~~~~~~~~~~~\n\nif ``schema(...)`` encounters an object with method ``validate`` it will run\nthis method on corresponding data as ``data = obj.validate(data)``. this method\nmay raise ``schemaerror`` exception, which will tell ``schema`` that that piece\nof data is invalid, otherwise\u2014it will continue validating.\n\nan example of \"validatable\" is ``regex``, that tries to match a string or a\nbuffer with the given regular expression (itself as a string, buffer or\ncompiled regex ``sre_pattern``):\n\n.. code:: python\n\n    >>> from schema import regex\n    >>> import re\n\n    >>> regex(r'^foo').validate('foobar')\n    'foobar'\n\n    >>> regex(r'^[a-z]+$', flags=re.i).validate('those-dashes-dont-match')\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: regex('^[a-z]+$', flags=re.ignorecase) does not match 'those-dashes-dont-match'\n\nfor a more general case, you can use ``use`` for creating such objects.\n``use`` helps to use a function or type to convert a value while validating it:\n\n.. code:: python\n\n    >>> from schema import use\n\n    >>> schema(use(int)).validate('123')\n    123\n\n    >>> schema(use(lambda f: open(f, 'a'))).validate('license-mit')\n    <_io.textiowrapper name='license-mit' mode='a' encoding='utf-8'>\n\ndropping the details, ``use`` is basically:\n\n.. code:: python\n\n    class use(object):\n\n        def __init__(self, callable_):\n            self._callable = callable_\n\n        def validate(self, data):\n            try:\n                return self._callable(data)\n            except exception as e:\n                raise schemaerror('%r raised %r' % (self._callable.__name__, e))\n\n\nsometimes you need to transform and validate part of data, but keep original data unchanged.\n``const`` helps to keep your data safe:\n\n.. code:: python\n\n    >> from schema import use, const, and, schema\n\n    >> from datetime import datetime\n\n    >> is_future = lambda date: datetime.now() > date\n\n    >> to_json = lambda v: {\"timestamp\": v}\n\n    >> schema(and(const(and(use(datetime.fromtimestamp), is_future)), use(to_json))).validate(1234567890)\n    {\"timestamp\": 1234567890}\n\nnow you can write your own validation-aware classes and data types.\n\nlists, similar containers\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif ``schema(...)`` encounters an instance of ``list``, ``tuple``, ``set``\nor ``frozenset``, it will validate contents of corresponding data container\nagainst all schemas listed inside that container and aggregate all errors:\n\n.. code:: python\n\n    >>> schema([1, 0]).validate([1, 1, 0, 1])\n    [1, 1, 0, 1]\n\n    >>> schema((int, float)).validate((5, 7, 8, 'not int or float here'))\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: or(<class 'int'>, <class 'float'>) did not validate 'not int or float here'\n    'not int or float here' should be instance of 'int'\n    'not int or float here' should be instance of 'float'\n\ndictionaries\n~~~~~~~~~~~~\n\nif ``schema(...)`` encounters an instance of ``dict``, it will validate data\nkey-value pairs:\n\n.. code:: python\n\n    >>> d = schema({'name': str,\n    ...             'age': lambda n: 18 <= n <= 99}).validate({'name': 'sue', 'age': 28})\n\n    >>> assert d == {'name': 'sue', 'age': 28}\n\nyou can specify keys as schemas too:\n\n.. code:: python\n\n    >>> schema = schema({str: int,  # string keys should have integer values\n    ...                  int: none})  # int keys should be always none\n\n    >>> data = schema.validate({'key1': 1, 'key2': 2,\n    ...                         10: none, 20: none})\n\n    >>> schema.validate({'key1': 1,\n    ...                   10: 'not none here'})\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: key '10' error:\n    none does not match 'not none here'\n\nthis is useful if you want to check certain key-values, but don't care\nabout others:\n\n.. code:: python\n\n    >>> schema = schema({'<id>': int,\n    ...                  '<file>': use(open),\n    ...                  str: object})  # don't care about other str keys\n\n    >>> data = schema.validate({'<id>': 10,\n    ...                         '<file>': 'readme.rst',\n    ...                         '--verbose': true})\n\nyou can mark a key as optional as follows:\n\n.. code:: python\n\n    >>> from schema import optional\n    >>> schema({'name': str,\n    ...         optional('occupation'): str}).validate({'name': 'sam'})\n    {'name': 'sam'}\n\n``optional`` keys can also carry a ``default``, to be used when no key in the\ndata matches:\n\n.. code:: python\n\n    >>> from schema import optional\n    >>> schema({optional('color', default='blue'): str,\n    ...         str: str}).validate({'texture': 'furry'}\n    ...       ) == {'color': 'blue', 'texture': 'furry'}\n    true\n\ndefaults are used verbatim, not passed through any validators specified in the\nvalue.\n\ndefault can also be a callable:\n\n.. code:: python\n\n    >>> from schema import schema, optional\n    >>> schema({optional('data', default=dict): {}}).validate({}) == {'data': {}}\n    true\n\nalso, a caveat: if you specify types, **schema** won't validate the empty dict:\n\n.. code:: python\n\n    >>> schema({int:int}).is_valid({})\n    false\n\nto do that, you need ``schema(or({int:int}, {}))``. this is unlike what happens with\nlists, where ``schema([int]).is_valid([])`` will return true.\n\n\n**schema** has classes ``and`` and ``or`` that help validating several schemas\nfor the same data:\n\n.. code:: python\n\n    >>> from schema import and, or\n\n    >>> schema({'age': and(int, lambda n: 0 < n < 99)}).validate({'age': 7})\n    {'age': 7}\n\n    >>> schema({'password': and(str, lambda s: len(s) > 6)}).validate({'password': 'hai'})\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: key 'password' error:\n    <lambda>('hai') should evaluate to true\n\n    >>> schema(and(or(int, float), lambda x: x > 0)).validate(3.1415)\n    3.1415\n\nin a dictionary, you can also combine two keys in a \"one or the other\" manner. to do\nso, use the `or` class as a key:\n\n.. code:: python\n\n    >>> from schema import or, schema\n    >>> schema = schema({\n    ...    or(\"key1\", \"key2\", only_one=true): str\n    ... })\n\n    >>> schema.validate({\"key1\": \"test\"}) # ok\n    {'key1': 'test'}\n\n    >>> schema.validate({\"key1\": \"test\", \"key2\": \"test\"}) # schemaerror\n    traceback (most recent call last):\n    ...\n    schema.schemaonlyoneallowederror: there are multiple keys present from the or('key1', 'key2') condition\n\nhooks\n~~~~~~~~~~\nyou can define hooks which are functions that are executed whenever a valid key:value is found.\nthe `forbidden` class is an example of this.\n\nyou can mark a key as forbidden as follows:\n\n.. code:: python\n\n    >>> from schema import forbidden\n    >>> schema({forbidden('age'): object}).validate({'age': 50})\n    traceback (most recent call last):\n    ...\n    schema.schemaforbiddenkeyerror: forbidden key encountered: 'age' in {'age': 50}\n\na few things are worth noting. first, the value paired with the forbidden\nkey determines whether it will be rejected:\n\n.. code:: python\n\n    >>> schema({forbidden('age'): str, 'age': int}).validate({'age': 50})\n    {'age': 50}\n\nnote: if we hadn't supplied the 'age' key here, the call would have failed too, but with\nschemawrongkeyerror, not schemaforbiddenkeyerror.\n\nsecond, forbidden has a higher priority than standard keys, and consequently than optional.\nthis means we can do that:\n\n.. code:: python\n\n    >>> schema({forbidden('age'): object, optional(str): object}).validate({'age': 50})\n    traceback (most recent call last):\n    ...\n    schema.schemaforbiddenkeyerror: forbidden key encountered: 'age' in {'age': 50}\n\nyou can also define your own hooks. the following hook will call `_my_function` if `key` is encountered.\n\n.. code:: python\n\n    from schema import hook\n    def _my_function(key, scope, error):\n        print(key, scope, error)\n\n    hook(\"key\", handler=_my_function)\n\nhere's an example where a `deprecated` class is added to log warnings whenever a key is encountered:\n\n.. code:: python\n\n    from schema import hook, schema\n    class deprecated(hook):\n        def __init__(self, *args, **kwargs):\n            kwargs[\"handler\"] = lambda key, *args: logging.warn(f\"`{key}` is deprecated. \" + (self._error or \"\"))\n            super(deprecated, self).__init__(*args, **kwargs)\n\n    schema({deprecated(\"test\", \"custom error message.\"): object}, ignore_extra_keys=true).validate({\"test\": \"value\"})\n    ...\n    warning: `test` is deprecated. custom error message.\n\nextra keys\n~~~~~~~~~~\n\nthe ``schema(...)`` parameter ``ignore_extra_keys`` causes validation to ignore extra keys in a dictionary, and also to not return them after validating.\n\n.. code:: python\n\n    >>> schema = schema({'name': str}, ignore_extra_keys=true)\n    >>> schema.validate({'name': 'sam', 'age': '42'})\n    {'name': 'sam'}\n\nif you would like any extra keys returned, use ``object: object`` as one of the key/value pairs, which will match any key and any value.\notherwise, extra keys will raise a ``schemaerror``.\n\n\ncustomized validation\n~~~~~~~~~~~~~~~~~~~~~~~\n\nthe ``schema.validate`` method accepts additional keyword arguments. the\nkeyword arguments will be propagated to the ``validate`` method of any\nchild validatables (including any ad-hoc ``schema`` objects), or the default\nvalue callable (if a callable is specified) for ``optional`` keys.\n\nthis feature can be used together with inheritance of the ``schema`` class\nfor customized validation.\n\nhere is an example where a \"post-validation\" hook that runs after validation\nagainst a sub-schema in a larger schema:\n\n.. code:: python\n\n    class eventschema(schema.schema):\n\n        def validate(self, data, _is_event_schema=true):\n            data = super(eventschema, self).validate(data, _is_event_schema=false)\n            if _is_event_schema and data.get(\"minimum\", none) is none:\n                data[\"minimum\"] = data[\"capacity\"]\n            return data\n\n\n    events_schema = schema.schema(\n        {\n            str: eventschema({\n                \"capacity\": int,\n                schema.optional(\"minimum\"): int,  # default to capacity\n            })\n        }\n    )\n\n\n    data = {'event1': {'capacity': 1}, 'event2': {'capacity': 2, 'minimum': 3}}\n    events = events_schema.validate(data)\n\n    assert events['event1']['minimum'] == 1  # == capacity\n    assert events['event2']['minimum'] == 3\n\n\nnote that the additional keyword argument ``_is_event_schema`` is necessary to\nlimit the customized behavior to the ``eventschema`` object itself so that it\nwon't affect any recursive invoke of the ``self.__class__.validate`` for the\nchild schemas (e.g., the call to ``schema(\"capacity\").validate(\"capacity\")``).\n\n\nuser-friendly error reporting\n-------------------------------------------------------------------------------\n\nyou can pass a keyword argument ``error`` to any of validatable classes\n(such as ``schema``, ``and``, ``or``, ``regex``, ``use``) to report this error\ninstead of a built-in one.\n\n.. code:: python\n\n    >>> schema(use(int, error='invalid year')).validate('xvii')\n    traceback (most recent call last):\n    ...\n    schema.schemaerror: invalid year\n\nyou can see all errors that occurred by accessing exception's ``exc.autos``\nfor auto-generated error messages, and ``exc.errors`` for errors\nwhich had ``error`` text passed to them.\n\nyou can exit with ``sys.exit(exc.code)`` if you want to show the messages\nto the user without traceback. ``error`` messages are given precedence in that\ncase.\n\na json api example\n-------------------------------------------------------------------------------\n\nhere is a quick example: validation of\n`create a gist <http://developer.github.com/v3/gists/>`_\nrequest from github api.\n\n.. code:: python\n\n    >>> gist = '''{\"description\": \"the description for this gist\",\n    ...            \"public\": true,\n    ...            \"files\": {\n    ...                \"file1.txt\": {\"content\": \"string file contents\"},\n    ...                \"other.txt\": {\"content\": \"another file contents\"}}}'''\n\n    >>> from schema import schema, and, use, optional\n\n    >>> import json\n\n    >>> gist_schema = schema(and(use(json.loads),  # first convert from json\n    ...                          # use str since json returns unicode\n    ...                          {optional('description'): str,\n    ...                           'public': bool,\n    ...                           'files': {str: {'content': str}}}))\n\n    >>> gist = gist_schema.validate(gist)\n\n    # gist:\n    {u'description': u'the description for this gist',\n     u'files': {u'file1.txt': {u'content': u'string file contents'},\n                u'other.txt': {u'content': u'another file contents'}},\n     u'public': true}\n\nusing **schema** with `docopt <http://github.com/docopt/docopt>`_\n-------------------------------------------------------------------------------\n\nassume you are using **docopt** with the following usage-pattern:\n\n    usage: my_program.py [--count=n] <path> <files>...\n\nand you would like to validate that ``<files>`` are readable, and that\n``<path>`` exists, and that ``--count`` is either integer from 0 to 5, or\n``none``.\n\nassuming **docopt** returns the following dict:\n\n.. code:: python\n\n    >>> args = {'<files>': ['license-mit', 'setup.py'],\n    ...         '<path>': '../',\n    ...         '--count': '3'}\n\nthis is how you validate it using ``schema``:\n\n.. code:: python\n\n    >>> from schema import schema, and, or, use\n    >>> import os\n\n    >>> s = schema({'<files>': [use(open)],\n    ...             '<path>': os.path.exists,\n    ...             '--count': or(none, and(use(int), lambda n: 0 < n < 5))})\n\n    >>> args = s.validate(args)\n\n    >>> args['<files>']\n    [<_io.textiowrapper name='license-mit' ...>, <_io.textiowrapper name='setup.py' ...]\n\n    >>> args['<path>']\n    '../'\n\n    >>> args['--count']\n    3\n\nas you can see, **schema** validated data successfully, opened files and\nconverted ``'3'`` to ``int``.\n\njson schema\n-----------\n\nyou can also generate standard `draft-07 json schema <https://json-schema.org/>`_ from a dict ``schema``.\nthis can be used to add word completion, validation, and documentation directly in code editors.\nthe output schema can also be used with json schema compatible libraries.\n\njson: generating\n~~~~~~~~~~~~~~~~\n\njust define your schema normally and call ``.json_schema()`` on it. the output is a python dict, you need to dump it to json.\n\n.. code:: python\n\n    >>> from schema import optional, schema\n    >>> import json\n    >>> s = schema({\"test\": str,\n    ...             \"nested\": {optional(\"other\"): str}\n    ...             })\n    >>> json_schema = json.dumps(s.json_schema(\"https://example.com/my-schema.json\"))\n\n    # json_schema\n    {\n        \"type\":\"object\",\n        \"properties\": {\n            \"test\": {\"type\": \"string\"},\n            \"nested\": {\n                \"type\":\"object\",\n                \"properties\": {\n                    \"other\": {\"type\": \"string\"}\n                },\n                \"required\": [],\n                \"additionalproperties\": false\n            }\n        },\n        \"required\":[\n            \"test\",\n            \"nested\"\n        ],\n        \"additionalproperties\":false,\n        \"$id\":\"https://example.com/my-schema.json\",\n        \"$schema\":\"http://json-schema.org/draft-07/schema#\"\n    }\n\nyou can add descriptions for the schema elements using the ``literal`` object instead of a string. the main schema can also have a description.\n\nthese will appear in ides to help your users write a configuration.\n\n.. code:: python\n\n    >>> from schema import literal, schema\n    >>> import json\n    >>> s = schema({literal(\"project_name\", description=\"names must be unique\"): str}, description=\"project schema\")\n    >>> json_schema = json.dumps(s.json_schema(\"https://example.com/my-schema.json\"), indent=4)\n\n    # json_schema\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"project_name\": {\n                \"description\": \"names must be unique\",\n                \"type\": \"string\"\n            }\n        },\n        \"required\": [\n            \"project_name\"\n        ],\n        \"additionalproperties\": false,\n        \"$id\": \"https://example.com/my-schema.json\",\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"description\": \"project schema\"\n    }\n\n\njson: supported validations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe resulting json schema is not guaranteed to accept the same objects as the library would accept, since some validations are not implemented or\nhave no json schema equivalent. this is the case of the ``use`` and ``hook`` objects for example.\n\nimplemented\n'''''''''''\n\n`object properties <https://json-schema.org/understanding-json-schema/reference/object.html#properties>`_\n    use a dict literal. the dict keys are the json schema properties.\n\n    example:\n\n    ``schema({\"test\": str})``\n\n    becomes\n\n    ``{'type': 'object', 'properties': {'test': {'type': 'string'}}, 'required': ['test'], 'additionalproperties': false}``.\n\n    please note that attributes are required by default. to create optional attributes use ``optional``, like so:\n\n    ``schema({optional(\"test\"): str})``\n\n    becomes\n\n    ``{'type': 'object', 'properties': {'test': {'type': 'string'}}, 'required': [], 'additionalproperties': false}``\n\n    additionalproperties is set to true when at least one of the conditions is met:\n        - ignore_extra_keys is true\n        - at least one key is `str` or `object`\n\n    for example:\n\n    ``schema({str: str})`` and ``schema({}, ignore_extra_keys=true)``\n\n    both becomes\n\n    ``{'type': 'object', 'properties' : {}, 'required': [], 'additionalproperties': true}``\n\n    and\n\n    ``schema({})``\n\n    becomes\n\n    ``{'type': 'object', 'properties' : {}, 'required': [], 'additionalproperties': false}``\n\ntypes\n    use the python type name directly. it will be converted to the json name:\n\n    - ``str`` -> `string <https://json-schema.org/understanding-json-schema/reference/string.html>`_\n    - ``int`` -> `integer <https://json-schema.org/understanding-json-schema/reference/numeric.html#integer>`_\n    - ``float`` -> `number <https://json-schema.org/understanding-json-schema/reference/numeric.html#number>`_\n    - ``bool`` -> `boolean <https://json-schema.org/understanding-json-schema/reference/boolean.html>`_\n    - ``list`` -> `array <https://json-schema.org/understanding-json-schema/reference/array.html>`_\n    - ``dict`` -> `object <https://json-schema.org/understanding-json-schema/reference/object.html>`_\n\n    example:\n\n    ``schema(float)``\n\n    becomes\n\n    ``{\"type\": \"number\"}``\n\n`array items <https://json-schema.org/understanding-json-schema/reference/array.html#items>`_\n    surround a schema with ``[]``.\n\n    example:\n\n    ``schema([str])`` means an array of string and becomes:\n\n    ``{'type': 'array', 'items': {'type': 'string'}}``\n\n`enumerated values <https://json-schema.org/understanding-json-schema/reference/generic.html#enumerated-values>`_\n    use `or`.\n\n    example:\n\n    ``schema(or(1, 2, 3))`` becomes\n\n    ``{\"enum\": [1, 2, 3]}``\n\n`constant values <https://json-schema.org/understanding-json-schema/reference/generic.html#constant-values>`_\n    use the value itself.\n\n    example:\n\n    ``schema(\"name\")`` becomes\n\n    ``{\"const\": \"name\"}``\n\n`regular expressions <https://json-schema.org/understanding-json-schema/reference/regular_expressions.html>`_\n    use ``regex``.\n\n    example:\n\n    ``schema(regex(\"^v\\d+\"))`` becomes\n\n    ``{'type': 'string', 'pattern': '^v\\\\d+'}``\n\n`annotations (title and description) <https://json-schema.org/understanding-json-schema/reference/generic.html#annotations>`_\n    you can use the ``name`` and ``description`` parameters of the ``schema`` object init method.\n\n    to add description to keys, replace a str with a ``literal`` object.\n\n    example:\n\n    ``schema({literal(\"test\", description=\"a description\"): str})``\n\n    is equivalent to\n\n    ``schema({\"test\": str})``\n\n    with the description added to the resulting json schema.\n\n`combining schemas with allof <https://json-schema.org/understanding-json-schema/reference/combining.html#allof>`_\n    use ``and``\n\n    example:\n\n    ``schema(and(str, \"value\"))``\n\n    becomes\n\n    ``{\"allof\": [{\"type\": \"string\"}, {\"const\": \"value\"}]}``\n\n    note that this example is not really useful in the real world, since ``const`` already implies the type.\n\n`combining schemas with anyof <https://json-schema.org/understanding-json-schema/reference/combining.html#anyof>`_\n    use ``or``\n\n    example:\n\n    ``schema(or(str, int))``\n\n    becomes\n\n    ``{\"anyof\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]}``\n\n\nnot implemented\n'''''''''''''''\n\nthe following json schema validations cannot be generated from this library.\n\n- `string length <https://json-schema.org/understanding-json-schema/reference/string.html#length>`_\n    however, those can be implemented using ``regex``\n- `string format <https://json-schema.org/understanding-json-schema/reference/string.html#format>`_\n    however, those can be implemented using ``regex``\n- `object dependencies <https://json-schema.org/understanding-json-schema/reference/object.html#dependencies>`_\n- `array length <https://json-schema.org/understanding-json-schema/reference/array.html#length>`_\n- `array uniqueness <https://json-schema.org/understanding-json-schema/reference/array.html#uniqueness>`_\n- `numeric multiples <https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples>`_\n- `numeric ranges <https://json-schema.org/understanding-json-schema/reference/numeric.html#range>`_\n- `property names <https://json-schema.org/understanding-json-schema/reference/object.html#property-names>`_\n    not implemented. we suggest listing the possible keys instead. as a tip, you can use ``or`` as a dict key.\n\n    example:\n\n    ``schema({or(\"name1\", \"name2\"): str})``\n- `annotations (default and examples) <https://json-schema.org/understanding-json-schema/reference/generic.html#annotations>`_\n- `combining schemas with oneof <https://json-schema.org/understanding-json-schema/reference/combining.html#oneof>`_\n- `not <https://json-schema.org/understanding-json-schema/reference/combining.html#not>`_\n- `object size <https://json-schema.org/understanding-json-schema/reference/object.html#size>`_\n- `additionalproperties having a different schema (true and false is supported)`\n\n\njson: minimizing output size\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nexplicit reuse\n''''''''''''''\n\nif your json schema is big and has a lot of repetition, it can be made simpler and smaller by defining schema objects as reference.\nthese references will be placed in a \"definitions\" section in the main schema.\n\n`you can look at the json schema documentation for more information <https://json-schema.org/understanding-json-schema/structuring.html#reuse>`_\n\n.. code:: python\n\n    >>> from schema import optional, schema\n    >>> import json\n    >>> s = schema({\"test\": str,\n    ...             \"nested\": schema({optional(\"other\"): str}, name=\"nested\", as_reference=true)\n    ...             })\n    >>> json_schema = json.dumps(s.json_schema(\"https://example.com/my-schema.json\"), indent=4)\n\n    # json_schema\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"test\": {\n                \"type\": \"string\"\n            },\n            \"nested\": {\n                \"$ref\": \"#/definitions/nested\"\n            }\n        },\n        \"required\": [\n            \"test\",\n            \"nested\"\n        ],\n        \"additionalproperties\": false,\n        \"$id\": \"https://example.com/my-schema.json\",\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"definitions\": {\n            \"nested\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"other\": {\n                        \"type\": \"string\"\n                    }\n                },\n                \"required\": [],\n                \"additionalproperties\": false\n            }\n        }\n    }\n\nthis becomes really useful when using the same object several times\n\n.. code:: python\n\n    >>> from schema import optional, or, schema\n    >>> import json\n    >>> language_configuration = schema({\"autocomplete\": bool, \"stop_words\": [str]}, name=\"language\", as_reference=true)\n    >>> s = schema({or(\"ar\", \"cs\", \"de\", \"el\", \"eu\", \"en\", \"es\", \"fr\"): language_configuration})\n    >>> json_schema = json.dumps(s.json_schema(\"https://example.com/my-schema.json\"), indent=4)\n\n    # json_schema\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"ar\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"cs\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"de\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"el\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"eu\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"en\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"es\": {\n                \"$ref\": \"#/definitions/language\"\n            },\n            \"fr\": {\n                \"$ref\": \"#/definitions/language\"\n            }\n        },\n        \"required\": [],\n        \"additionalproperties\": false,\n        \"$id\": \"https://example.com/my-schema.json\",\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n        \"definitions\": {\n            \"language\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"autocomplete\": {\n                        \"type\": \"boolean\"\n                    },\n                    \"stop_words\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\"\n                        }\n                    }\n                },\n                \"required\": [\n                    \"autocomplete\",\n                    \"stop_words\"\n                ],\n                \"additionalproperties\": false\n            }\n        }\n    }\n\nautomatic reuse\n'''''''''''''''\n\nif you want to minimize the output size without using names explicitly, you can have the library generate hashes of parts of the output json\nschema and use them as references throughout.\n\nenable this behaviour by providing the parameter ``use_refs`` to the json_schema method.\n\nbe aware that this method is less often compatible with ides and json schema libraries.\nit produces a json schema that is more difficult to read by humans.\n\n.. code:: python\n\n    >>> from schema import optional, or, schema\n    >>> import json\n    >>> language_configuration = schema({\"autocomplete\": bool, \"stop_words\": [str]})\n    >>> s = schema({or(\"ar\", \"cs\", \"de\", \"el\", \"eu\", \"en\", \"es\", \"fr\"): language_configuration})\n    >>> json_schema = json.dumps(s.json_schema(\"https://example.com/my-schema.json\", use_refs=true), indent=4)\n\n    # json_schema\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"ar\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"autocomplete\": {\n                        \"type\": \"boolean\",\n                        \"$id\": \"#6456104181059880193\"\n                    },\n                    \"stop_words\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"$id\": \"#1856069563381977338\"\n                        }\n                    }\n                },\n                \"required\": [\n                    \"autocomplete\",\n                    \"stop_words\"\n                ],\n                \"additionalproperties\": false\n            },\n            \"cs\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"autocomplete\": {\n                        \"$ref\": \"#6456104181059880193\"\n                    },\n                    \"stop_words\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"$ref\": \"#1856069563381977338\"\n                        },\n                        \"$id\": \"#-5377945144312515805\"\n                    }\n                },\n                \"required\": [\n                    \"autocomplete\",\n                    \"stop_words\"\n                ],\n                \"additionalproperties\": false\n            },\n            \"de\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"autocomplete\": {\n                        \"$ref\": \"#6456104181059880193\"\n                    },\n                    \"stop_words\": {\n                        \"$ref\": \"#-5377945144312515805\"\n                    }\n                },\n                \"required\": [\n                    \"autocomplete\",\n                    \"stop_words\"\n                ],\n                \"additionalproperties\": false,\n                \"$id\": \"#-8142886105174600858\"\n            },\n            \"el\": {\n                \"$ref\": \"#-8142886105174600858\"\n            },\n            \"eu\": {\n                \"$ref\": \"#-8142886105174600858\"\n            },\n            \"en\": {\n                \"$ref\": \"#-8142886105174600858\"\n            },\n            \"es\": {\n                \"$ref\": \"#-8142886105174600858\"\n            },\n            \"fr\": {\n                \"$ref\": \"#-8142886105174600858\"\n            }\n        },\n        \"required\": [],\n        \"additionalproperties\": false,\n        \"$id\": \"https://example.com/my-schema.json\",\n        \"$schema\": \"http://json-schema.org/draft-07/schema#\"\n    }\n\n\n",
  "docs_url": null,
  "keywords": "schema json validation",
  "license": "mit",
  "name": "schema",
  "package_url": "https://pypi.org/project/schema/",
  "project_url": "https://pypi.org/project/schema/",
  "project_urls": {
    "Homepage": "https://github.com/keleshev/schema"
  },
  "release_url": "https://pypi.org/project/schema/0.7.5/",
  "requires_dist": [
    "contextlib2 (>=0.5.5)"
  ],
  "requires_python": "",
  "summary": "simple data validation library",
  "version": "0.7.5",
  "releases": [],
  "developers": [
    "vladimir@keleshev.com",
    "vladimir_keleshev"
  ],
  "kwds": "json_schema schemaonlyoneallowederror schemawrongkeyerror schemaforbiddenkeyerror schemaerror",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_schema",
  "homepage": "https://github.com/keleshev/schema",
  "release_count": 25,
  "dependency_ids": [
    "pypi_contextlib2"
  ]
}