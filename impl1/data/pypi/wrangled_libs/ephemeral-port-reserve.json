{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "# `ephemeral-port-reserve`\nsometimes you need a networked program to bind to a port that can't be hard-coded.\ngenerally this is when you want to run several of them in parallel; if they all\nbind to port 8080, only one of them can succeed.\n\nthe usual solution is the \"port 0 trick\". if you bind to port 0, your kernel will\nfind some arbitrary high-numbered port that's unused and bind to that. afterward\nyou can query the actual port that was bound to if you need to use the port number\nelsewhere. however, there are cases where the port 0 trick won't work. for example,\nmysqld takes port 0 to mean \"the port configured in my.cnf\". docker can bind your\ncontainers to port 0, but uses its own implementation to find a free port which\nraces and fails in the face of parallelism.\n\n`ephemeral-port-reserve` provides an implementation of the port 0 trick which\nis reliable and race-free. you can use it like so:\n\n```!bash\nport=\"$(ephemeral-port-reserve)\"\ndocker run -p 127.0.0.1:$port:5000 registry:2\n```\n\n\n`ephemeral-port-reserve` is a utility to bind to an ephemeral port, force it into\nthe `time_wait` state, and unbind it.\n\nthis means that further ephemeral port alloctions won't pick this \"reserved\" port,\nbut subprocesses can still bind to it explicitly, given that they use `so_reuseaddr`.\nby default on linux you have a grace period of 60 seconds to reuse this port.\nto check your own particular value:\n\n```!bash\n$ cat /proc/sys/net/ipv4/tcp_fin_timeout\n60\n```\n\n**note:** by default, the port returned is *specifically* for `localhost`, aka `127.0.0.1`.\nif you bind instead to `0.0.0.0`, you may encounter a port conflict. if you need to\nbind to a non-localhost ip, you can pass it as the first argument.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "ephemeral-port-reserve",
  "package_url": "https://pypi.org/project/ephemeral-port-reserve/",
  "project_url": "https://pypi.org/project/ephemeral-port-reserve/",
  "project_urls": {
    "Homepage": "https://github.com/Yelp/ephemeral-port-reserve/"
  },
  "release_url": "https://pypi.org/project/ephemeral-port-reserve/1.1.4/",
  "requires_dist": [],
  "requires_python": "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,>=2.7",
  "summary": "bind to an ephemeral port, force it into the time_wait state, and unbind it.",
  "version": "1.1.4",
  "releases": [],
  "developers": [],
  "kwds": "port docker tcp_fin_timeout localhost containers",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_ephemeral_port_reserve",
  "homepage": "https://github.com/yelp/ephemeral-port-reserve/",
  "release_count": 8,
  "dependency_ids": []
}