{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "license :: other/proprietary license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing",
    "topic :: utilities"
  ],
  "description": "powerful and intuitive mock object framework for python.\n\n|package-version|\n|python-versions|\n|documentation status|\n\ninstall\n-------\n\n.. code:: bash\n\n   pip install pymox\n\ntutorial\n--------\n\nbasics\n~~~~~~\n\npymox works in a way you set expectations and then enter in replay mode.\nhere is a basic example:\n\n.. code:: python\n\n   class duck:\n       def quack(self, times=1):\n           return ['quack'] * times\n\n       def walk(self):\n           return ['walking']\n\n       def walk_and_quack(self, times=1):\n           return self.walk() + self.quack(times=times)\n\nhere is a ``duck`` class. let's play with our \ud83e\udd86 and pymox!\n\n.. code:: python\n\n   import mox\n\n\n   class testduck:\n\n       def test_quack(self):\n           m = mox.mox()\n           m_duck = m.createmock(duck)\n\n           # expects quack to be called with `times=1`\n           m_duck.quack(times=1).returns(['new quack'])\n\n           m.replay_all()\n           assert m_duck.quack(times=1) == ['new quack']\n           m.verify_all()\n\nlet's change the test a little bit:\n\n.. code:: python\n\n       # [...]\n       def test_quack_2(self):\n           m = mox.mox()\n           m_duck = m.createmock(duck)\n\n           # expects quack to be called with `times=1`\n           m_duck.quack(times=1).returns(['new quack'])\n\n           m.replay_all()\n           assert m_duck.walk() == ['walking']\n           assert m_duck.quack(times=1) == ['new quack']\n           m.verify_all()\n\nthe test above will fail with the following error:\n\n.. code:: python-traceback\n\n       e           mox.mox.unexpectedmethodcallerror: unexpected method call.  unexpected:-  expected:+\n       e           - duck.walk() -> none\n       e           + duck.quack(times=1) -> ['new quack']\n\nsince you expected quack to be called and walk was called instead. you\ncan add an expectation for walk:\n\n.. code:: python\n\n       def test_quack_3(self):\n           m = mox.mox()\n           m_duck = m.createmock(duck)\n\n           # expects quack to be called with `times=1`\n           m_duck.quack(times=1).returns(['new quack'])\n           m_duck.walk().returns(['pretending to be walking'])\n\n           m.replay_all()\n           assert m_duck.quack(times=1) == ['new quack']\n           assert m_duck.walk() == ['pretending to be walking']\n           m.verify_all()\n\nyou can also stub out ``quack`` method only and mox won't care about the\nother methods:\n\n.. code:: python\n\n       def test_quack_4(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n           \"\"\"\n           you can also do with the class:\n           m.stubout(duck, 'quack')\n           \"\"\"\n\n           # expects quack to be called with `times=1`\n           duck.quack(times=1).returns(['new quack'])\n\n           m.replay_all()\n           assert duck.quack(times=1) == ['new quack']\n           assert duck.walk() == ['walking']\n           m.verify_all()\n\nthe order matters, so if you do:\n\n.. code:: python\n\n       def test_quack_5(self):\n           m = mox.mox()\n           m_duck = m.createmock(duck)\n\n           # expects quack to be called with `times=1`\n           m_duck.quack(times=1).returns(['new quack'])\n           m_duck.walk().returns(['pretending to be walking'])\n\n           m.replay_all()\n           assert m_duck.walk() == ['pretending to be walking']\n           assert m_duck.quack(times=1) == ['new quack']\n           m.verify_all()\n\nit fails with:\n\n.. code:: python-traceback\n\n       e           mox.mox.unexpectedmethodcallerror: unexpected method call.  unexpected:-  expected:+\n       e           - duck.walk() -> none\n       e           + duck.quack(times=1) -> ['new quack']\n\nto fix that you can use ``any_order()``:\n\n.. code:: python\n\n       def test_quack_6(self):\n           m = mox.mox()\n           m_duck = m.createmock(duck)\n\n           # expects quack to be called with `times=1`\n           m_duck.quack(times=1).any_order().returns(['new quack'])\n           m_duck.walk().any_order().returns(['pretending to be walking'])\n\n           m.replay_all()\n           assert m_duck.walk() == ['pretending to be walking']\n           assert m_duck.quack(times=1) == ['new quack']\n\ncomparators\n~~~~~~~~~~~\n\nyou can use comparators when you are unsure of the arguments of a method\ncall.\n\n.. code:: python\n\n       def test_quack_7(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           def validate_arg(arg):\n            if arg in [1, 2, 3]:\n             return true\n            return false\n\n           duck.quack(times=mox.is_a(int)).returns(['new quack'])\n           duck.quack(times=mox.not_(mox.is_(4))).returns(['new quack'])\n           duck.quack(times=mox.func(validate_arg)).returns(['new quack'])\n           duck.quack(times=mox.or_(mox.is(1), mox.is_(2), mox.is_(3))).returns(['new quack'])\n\n           duck.quack(times=mox.ignore_arg()).returns(['new quack'])\n           duck.quack(times=mox.is_almost(1.00003, places=4)).returns(['new quack'])\n\n           m.replay_all()\n           assert duck.quack(times=random.choice([1, 2, 3])) == ['new quack']\n           assert duck.quack(times=random.choice([1, 2, 3])) == mox.in_('new quack')\n           assert duck.quack(times=random.choice([1, 2, 3]))[0] == mox.str_contains('quack')\n           assert duck.quack(times=random.choice([1, 2, 3])) == mox.same_elements_as({'new quack'})\n\n           assert duck.quack(times=random.choice([1, 2, 3])) == ['new quack']\n           assert duck.quack(times=1) == ['new quack']\n           m.verify_all()\n\nall the assertions for the test above should pass. there are other cool\ncomparators, like: ``and``, ``contains_attribute_value``,\n``contains_key_value``.\n\nfor more comparators, see:\nhttps://pymox.readthedocs.io/en/latest/reference.html#comparators\n\nremember\n~~~~~~~~\n\nit's possible to also remember a value that might be changed in your\ncode. see the test below:\n\n.. code:: python\n\n       def test_quack_8(self):\n\n           class stopquackingduck:\n\n               def _do_quack(self, choices=none):\n                   return choices\n\n               def quack(self, choices=[], less=false):\n                   if less:\n                       choices.pop()\n                   self._do_quack(choices=choices)\n\n           m = mox.mox()\n           duck = stopquackingduck()\n\n           m.stubout(stopquackingduck, '_do_quack')\n\n           choices_1 = mox.value()\n           choices_2 = mox.value()\n           duck._do_quack(choices=mox.remember(choices_1))\n           duck._do_quack(choices=mox.remember(choices_2))\n           duck._do_quack(choices=mox.remember(choices_2))\n           duck._do_quack(choices=mox.remember(choices_2))\n\n           all_choices = ['quack', 'new quack', 'newest quack']\n\n           m.replay_all()\n           duck.quack(all_choices, less=false)\n           assert choices_1 == ['quack', 'new quack', 'newest quack']\n\n           duck.quack(all_choices, less=true)\n           assert choices_2 == ['quack', 'new quack']\n\n           duck.quack(all_choices, less=true)\n           assert choices_2 == ['quack']\n\n           duck.quack(all_choices, less=true)\n           assert choices_2 == []\n           m.verify_all()\n\nother\n~~~~~\n\nyou can also make a method return a different value the second time it's\ncalled:\n\n.. code:: python\n\n       def test_walk_and_quack_0(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).returns(['new quack'])\n           duck.quack(times=1).returns(['newest quack'])\n\n           m.replay_all()\n           assert duck.walk_and_quack() == ['walking', 'new quack']\n\nbut since we didn't use m.verify_all(), it didn't require the second\ncall to happen. let's add the verify and see what happens:\n\n.. code:: python\n\n       def test_walk_and_quack_1(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).returns(['new quack'])\n           duck.quack(times=1).returns(['newest quack'])\n\n           m.replay_all()\n           assert duck.walk_and_quack() == ['walking', 'new quack']\n           m.verify_all()\n\nit fails with:\n\n.. code:: python-traceback\n\n       e           mox.mox.expectedmethodcallserror: verify: expected methods never called:\n       e             0.  duck.quack.__call__(times=1) -> ['newest quack']\n\nlet's fix it by adding a second call:\n\n.. code:: python\n\n       def test_walk_and_quack_2(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).returns(['new quack'])\n           duck.quack(times=1).returns(['newest quack'])\n\n           m.replay_all()\n           assert duck.walk_and_quack() == ['walking', 'new quack']\n           assert duck.walk_and_quack() == ['walking', 'new quack']\n           m.verify_all()\n\nnow you get the following error, since in the second time it returns\n['newest quack'].\n\n.. code:: python-traceback\n\n       e       assertionerror: assert ['walking', 'newest quack'] == ['walking', 'new quack']\n       e         at index 1 diff: 'newest quack' != 'new quack'\n       e         full diff:\n       e         - ['walking', 'new quack']\n       e         + ['walking', 'newest quack']\n       e         ?                 +++\n\nlet's fix it:\n\n.. code:: python\n\n       def test_walk_and_quack_3(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).returns(['new quack'])\n           duck.quack(times=1).returns(['newest quack'])\n\n           m.replay_all()\n           assert duck.walk_and_quack() == ['walking', 'new quack']\n           assert duck.walk_and_quack() == ['walking', 'newest quack']\n           m.verify_all()\n\nlet's now see how we can mock and assert calls in the context of a loop:\n\n.. code:: python\n\n       def test_walk_and_quack_4(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).returns(['new quack'])\n\n           m.replay_all()\n           assert duck.walk() == ['walking']\n           for _ in range(3):\n               assert duck.walk_and_quack() == ['walking', 'new quack']\n           m.verify_all()\n\nif you run the test above, you get the following:\n\n.. code:: python-traceback\n\n       e           mox.mox.unexpectedmethodcallerror: unexpected method call duck.quack.__call__(times=1) -> none\n\nlet's fix by using the ``multiple_times`` group.\n\n.. code:: python\n\n       def test_walk_and_quack_5(self):\n           m = mox.mox()\n           duck = duck()\n\n           m.stubout(duck, 'quack')\n\n           duck.quack(times=1).multiple_times().returns(['new quack'])\n\n           m.replay_all()\n           assert duck.walk() == ['walking']\n           for _ in range(3):\n               assert duck.walk_and_quack() == ['walking', 'new quack']\n           m.verify_all()\n\nif you know exactly how many calls are made, you can add an argument:\n``.multiple_times(3)``.\n\nnext\n~~~~\n\nthat's it for now! for a more comprehensive tutorial, see:\nhttps://pymox.readthedocs.io/en/latest/tutorial.html\n\nfor more examples, see:\nhttps://pymox.readthedocs.io/en/latest/examples.html\n\nfor the api reference, see:\nhttps://pymox.readthedocs.io/en/latest/reference.html\n\ndocumentation\n-------------\n\nfor full documentation, including installation, tutorials and pdf\ndocuments, please see http://pymox.rtfd.io/.\n\nhttp://pymox.readthedocs.io/en/latest/index.html\n\ndisclaimer\n----------\n\npymox is a fork of mox. mox is copyright 2008 google inc, and licensed\nunder the apache license, version 2.0; see the file copying for details.\n\n.. |package-version| image:: https://badge.fury.io/py/pymox.svg\n.. |python-versions| image:: https://img.shields.io/pypi/pyversions/pymox.svg\n.. |documentation status| image:: https://readthedocs.org/projects/pymox/badge/?version=latest\n\n",
  "docs_url": null,
  "keywords": "mox,mock,test,mocking,unittest,pymox",
  "license": "apache license, version 2.0",
  "name": "pymox",
  "package_url": "https://pypi.org/project/pymox/",
  "project_url": "https://pypi.org/project/pymox/",
  "project_urls": {
    "Homepage": "http://pymox.rtfd.io",
    "Repository": "https://github.com/ivancrneto/pymox"
  },
  "release_url": "https://pypi.org/project/pymox/1.1.0/",
  "requires_dist": [],
  "requires_python": ">=3.3,<4",
  "summary": "mock object framework",
  "version": "1.1.0",
  "releases": [],
  "developers": [
    "ivan.cr.neto@gmail.com",
    "ivan_neto"
  ],
  "kwds": "test_walk_and_quack_0 test_walk_and_quack_1 test_walk_and_quack_2 test_walk_and_quack_3 test_walk_and_quack_5",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_pymox",
  "homepage": "http://pymox.rtfd.io",
  "release_count": 12,
  "dependency_ids": []
}