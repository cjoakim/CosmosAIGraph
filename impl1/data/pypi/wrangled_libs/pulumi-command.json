{
  "classifiers": [],
  "description": "[![actions status](https://github.com/pulumi/pulumi-command/workflows/master/badge.svg)](https://github.com/pulumi/pulumi-command/actions)\n[![slack](http://www.pulumi.com/images/docs/badges/slack.svg)](https://slack.pulumi.com)\n[![npm version](https://badge.fury.io/js/%40pulumi%2fcommand.svg)](https://www.npmjs.com/package/@pulumi/command)\n[![python version](https://badge.fury.io/py/pulumi-command.svg)](https://pypi.org/project/pulumi-command)\n[![nuget version](https://badge.fury.io/nu/pulumi.command.svg)](https://badge.fury.io/nu/pulumi.command)\n[![pkggodev](https://pkg.go.dev/badge/github.com/pulumi/pulumi-command/sdk/go)](https://pkg.go.dev/github.com/pulumi/pulumi-command/sdk/go)\n[![license](https://img.shields.io/npm/l/%40pulumi%2fpulumi.svg)](https://github.com/pulumi/pulumi-command/blob/master/license)\n\n# pulumi command provider (preview)\n\nthe pulumi command provider enables you to execute commands and scripts either locally or remotely as part of the pulumi resource model.  resources in the command package support running scripts on `create` and `destroy` operations, supporting stateful local and remote command execution.\n\nthere are many scenarios where the command package can be useful:\n\n* running a command locally after creating a resource, to register it with an external service\n* running a command locally before deleting a resource, to deregister it with an external service\n* running a command remotely on a remote host immediately after creating it\n* copying a file to a remote host after creating it (potentially as a script to be executed afterwards)\n* as a simple alternative to some use cases for dynamic providers (especially in languages which do not yet support dynamic providers).\n\nsome users may have experience with terraform \"provisioners\", and the command package offers support for similar scenarios.  however, the command package is provided as independent resources which can be combined with other resources in many interesting ways. this has many strengths, but also some differences, such as the fact that a command resource failing does not cause a resource it is operating on to fail.\n\nyou can use the command package from a pulumi program written in any pulumi language: c#, go, javascript/typescript, and python.\nyou'll need to [install and configure the pulumi cli](https://pulumi.com/docs/get-started/install) if you haven't already.\n\n\n> **note**: the command package is in preview.  the api design may change ahead of general availability based on [user feedback](https://github.com/pulumi/pulumi-command/issues). \n\n## examples\n\n### a simple local resource (random)\n\nthe simplest use case for `local.command` is to just run a command on `create`, which can return some value which will be stored in the state file, and will be persistent for the life of the stack (or until the resource is destroyed or replaced).  the example below uses this as an alternative to the `random` package to create some randomness which is stored in pulumi state.\n\n```ts\nimport { local } from \"@pulumi/command\";\n\nconst random = new local.command(\"random\", {\n    create: \"openssl rand -hex 16\",\n});\n\nexport const output = random.stdout;\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-command/sdk/go/command/local\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.run(func(ctx *pulumi.context) error {\n\n\t\trandom, err := local.newcommand(ctx, \"my-bucket\", &local.commandinput{\n\t\t\tcreate: pulumi.string(\"openssl rand -hex 16\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tctx.export(\"output\", random.stdout)\n\t\treturn nil\n\t})\n}\n```\n\n### remote provisioning of an ec2 instance\n\nthis example creates and ec2 instance, and then uses `remote.command` and `remote.copyfile` to run commands and copy files to the remote instance (via ssh). similar things are possible with azure, google cloud and other cloud provider virtual machines.  support for windows-based vms is being tracked [here](https://github.com/pulumi/pulumi-command/issues/15).\n\nnote that implicit and explicit (`dependson`) dependencies can be used to control the order that these `command` and `copyfile` resources are constructed relative to each other and to the cloud resources they depend on.  this ensures that the `create` operations run after all dependencies are created, and the `delete` operations run before all dependencies are deleted.\n\nbecause the `command` and `copyfile` resources replace on changes to their connection, if the ec2 instance is replaced, the commands will all re-run on the new instance (and the `delete` operations will run on the old instance).\n\nnote also that `deletebeforereplace` can be composed with `command` resources to ensure that the `delete` operation on an \"old\" instance is run before the `create` operation of the new instance, in case a scarce resource is managed by the command.  similarly, other resource options can naturally be applied to `command` resources, like `ignorechanges`.\n\n```ts\nimport { interpolate, config } from \"@pulumi/pulumi\";\nimport { local, remote, types } from \"@pulumi/command\";\nimport * as aws from \"@pulumi/aws\";\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport { size } from \"./size\";\n\nconst config = new config();\nconst keyname = config.get(\"keyname\") ?? new aws.ec2.keypair(\"key\", { publickey: config.require(\"publickey\") }).keyname;\nconst privatekeybase64 = config.get(\"privatekeybase64\");\nconst privatekey = privatekeybase64 ? buffer.from(privatekeybase64, 'base64').tostring('ascii') : fs.readfilesync(path.join(os.homedir(), \".ssh\", \"id_rsa\")).tostring(\"utf8\");\n\nconst secgrp = new aws.ec2.securitygroup(\"secgrp\", {\n    description: \"foo\",\n    ingress: [\n        { protocol: \"tcp\", fromport: 22, toport: 22, cidrblocks: [\"0.0.0.0/0\"] },\n        { protocol: \"tcp\", fromport: 80, toport: 80, cidrblocks: [\"0.0.0.0/0\"] },\n    ],\n});\n\nconst ami = aws.ec2.getamioutput({\n    owners: [\"amazon\"],\n    mostrecent: true,\n    filters: [{\n        name: \"name\",\n        values: [\"amzn2-ami-hvm-2.0.????????-x86_64-gp2\"],\n    }],\n});\n\nconst server = new aws.ec2.instance(\"server\", {\n    instancetype: size,\n    ami: ami.id,\n    keyname: keyname,\n    vpcsecuritygroupids: [secgrp.id],\n}, { replaceonchanges: [\"instancetype\"] });\n\n// now set up a connection to the instance and run some provisioning operations on the instance.\n\nconst connection: types.input.remote.connectioninput = {\n    host: server.publicip,\n    user: \"ec2-user\",\n    privatekey: privatekey,\n};\n\nconst hostname = new remote.command(\"hostname\", {\n    connection,\n    create: \"hostname\",\n});\n\nnew remote.command(\"remoteprivateip\", {\n    connection,\n    create: interpolate`echo ${server.privateip} > private_ip.txt`,\n    delete: `rm private_ip.txt`,\n}, { deletebeforereplace: true });\n\nnew local.command(\"localprivateip\", {\n    create: interpolate`echo ${server.privateip} > private_ip.txt`,\n    delete: `rm private_ip.txt`,\n}, { deletebeforereplace: true });\n\nconst sizefile = new remote.copyfile(\"size\", {\n    connection,\n    localpath: \"./size.ts\",\n    remotepath: \"size.ts\",\n})\n\nconst catsize = new remote.command(\"checksize\", {\n    connection,\n    create: \"cat size.ts\",\n}, { dependson: sizefile })\n\nexport const confirmsize = catsize.stdout;\nexport const publicip = server.publicip;\nexport const publichostname = server.publicdns;\nexport const hostnamestdout = hostname.stdout;\n```\n\n### invoking a lambda during pulumi deployment\n\nthere may be cases where it is useful to run some code within an aws lambda or other serverless function during the deployment.  for example, this may allow running some code from within a vpc, or with a specific role, without needing to have persistent compute available (such as the ec2 example above).\n\nnote that the lambda function itself can be created within the same pulumi program, and then invoked after creation.  \n\nthe example below simply creates some random value within the lambda, which is a very roundabout way of doing the same thing as the first \"random\" example above, but this pattern can be used for more complex scenarios where the lambda does things a local script could not.\n\n```ts\nimport { local } from \"@pulumi/command\";\nimport * as aws from \"@pulumi/aws\";\nimport * as crypto from \"crypto\";\n\nconst f = new aws.lambda.callbackfunction(\"f\", {\n    publish: true,\n    callback: async (ev: any) => {\n        return crypto.randombytes(ev.len/2).tostring('hex');\n    }\n});\n\nconst rand = new local.command(\"execf\", {\n    create: `aws lambda invoke --function-name \"$fn\" --payload '{\"len\": 10}' --cli-binary-format raw-in-base64-out out.txt >/dev/null && cat out.txt | tr -d '\"'  && rm out.txt`,\n    environment: {\n        fn: f.qualifiedarn,\n        aws_region: aws.config.region!,\n        aws_pager: \"\",\n    },\n})\n\nexport const output = rand.stdout;\n```\n\n### using `local.command `with curl to manage external rest api\n\nthis example uses `local.command` to create a simple resource provider for managing github labels, by invoking `curl` commands on `create` and `delete` commands against the github rest api.  a similar approach could be applied to build other simple providers against any rest api directly from within pulumi programs in any language.  this approach is somewhat limited by the fact that `local.command` does not yet support `diff`/`update`/`read`.  support for those may be [added in the future](https://github.com/pulumi/pulumi-command/issues/20).\n\nthis example also shows how `local.command` can be used as an implementation detail inside a nicer abstraction, like the `githublabel` component defined below.\n\n```ts\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as random from \"@pulumi/random\";\nimport { local } from \"@pulumi/command\";\n\ninterface labelargs {\n    owner: pulumi.input<string>;\n    repo: pulumi.input<string>;\n    name: pulumi.input<string>;\n    githubtoken: pulumi.input<string>;\n}\n\nclass githublabel extends pulumi.componentresource {\n    public url: pulumi.output<string>;\n\n    constructor(name: string, args: labelargs, opts?: pulumi.componentresourceoptions) {\n        super(\"example:github:label\", name, args, opts);\n\n        const label = new local.command(\"label\", {\n            create: \"./create_label.sh\",\n            delete: \"./delete_label.sh\",\n            environment: {\n                owner: args.owner,\n                repo: args.repo,\n                name: args.name,\n                github_token: args.githubtoken,\n            }\n        }, { parent: this });\n\n        const response = label.stdout.apply(json.parse);\n        this.url = response.apply((x: any) => x.url as string);\n    }\n}\n\nconst config = new pulumi.config();\nconst rand = new random.randomstring(\"s\", { length: 10, special: false });\n\nconst label = new githublabel(\"l\", {\n    owner: \"pulumi\",\n    repo: \"pulumi-command\",\n    name: rand.result,\n    githubtoken: config.requiresecret(\"githubtoken\"),\n});\n\nexport const labelurl = label.url;\n```\n\n```sh\n# create_label.sh\ncurl \\\n  -s \\\n  -x post \\\n  -h \"authorization: bearer $github_token\" \\\n  -h \"accept: application/vnd.github.v3+json\" \\\n  https://api.github.com/repos/$owner/$repo/labels \\\n  -d \"{\\\"name\\\":\\\"$name\\\"}\"\n```\n\n```sh\n# delete_label.sh\ncurl \\\n  -s \\\n  -x delete \\\n  -h \"authorization: bearer $github_token\" \\\n  -h \"accept: application/vnd.github.v3+json\" \\\n  https://api.github.com/repos/$owner/$repo/labels/$name\n```\n\n### graceful cleanup of workloads in a kubernetes cluster\n\nthere are cases where it's important to run some cleanup operation before destroying a resource such as when destroying the resource does not properly handle orderly cleanup.  for example, destroying an eks cluster will not ensure that all kubernetes object finalizers are run, which may lead to leaking external resources managed by those kubernetes resources.  this example shows how we can use a `delete`-only `command` to ensure some cleanup is run within a cluster before destroying it.\n\n```ts\nimport { local } from \"@pulumi/command\";\nimport * as eks from \"@pulumi/eks\";\nimport * as random from \"@pulumi/random\";\nimport { interpolate } from \"@pulumi/pulumi\";\n\nconst cluster = new eks.cluster(\"cluster\", {});\n\n// we could also use `remotecommand` to run this from within a node in the cluster\nconst cleanupkubernetesnamespaces = new local.command(\"cleanupkubernetesnamespaces\", {\n    // this will run before the cluster is destroyed.  everything else will need to \n    // depend on this resource to ensure this cleanup doesn't happen too early.\n    delete: \"kubectl delete --all namespaces\",\n    environment: {\n        kubeconfig: cluster.kubeconfig,\n    },\n});\n```\n\n### working with assets and paths\n\nwhen a local command creates assets as part of its execution, these can be captured by specifying `assetpaths` or `archivepaths`.\n\n```typescript\nconst lambdabuild = local.runoutput({\n    dir: \"../my-function\",\n    command: `yarn && yarn build`,\n    archivepaths: [\"dist/**\"],\n});\n\nnew aws.lambda.function(\"my-function\", {\n    code: lambdabuild.archive,\n   // ...\n});\n```\n\nwhen using the `assetpaths` and `archivepaths`, they take a list of 'globs'.\n- we only include files not directories for assets and archives.\n- path separators are `/` on all platforms - including windows.\n- patterns starting with `!` are 'exclude' rules.\n- rules are evaluated in order, so exclude rules should be after inclusion rules.\n- `*` matches anything except `/`\n- `**` matches anything, _including_ `/`\n- all returned paths are relative to the working directory (without leading `./`) e.g. `file.text` or `subfolder/file.txt`.\n- for full details of the globbing syntax, see [github.com/gobwas/glob](https://github.com/gobwas/glob)\n\n#### asset paths example\n\ngiven the rules:\n```yaml\n- \"assets/**\"\n- \"src/**.js\"\n- \"!**secret.*\"\n```\n\nwhen evaluating against this folder:\n\n```yaml\n- assets/\n  - logos/\n    - logo.svg\n- src/\n  - index.js\n  - secret.js\n```\n\nthe following paths will be returned:\n\n```yaml\n- assets/logos/logo.svg\n- src/index.js\n```\n\n## building\n\n### dependencies\n\n- go 1.17\n- nodejs 10.x.x or later\n- python 3.6 or later\n- .net core 3.1\n\nplease refer to [contributing to pulumi](https://github.com/pulumi/pulumi/blob/master/contributing.md) for installation\nguidance.\n\n### building locally\n\nrun the following commands to install go modules, generate all sdks, and build the provider:\n\n```\n$ make ensure\n$ make build\n$ make install\n```\n\nadd the `bin` folder to your `$path` or copy the `bin/pulumi-resource-aws-native` file to another location in your `$path`.\n\n### running an example\n\nnavigate to the simple example and run pulumi:\n\n```\n$ cd examples/simple\n$ yarn link @pulumi/command\n$ yarn install\n$ pulumi up\n```\n\n",
  "docs_url": null,
  "keywords": "pulumi,command,category/utility,kind/native",
  "license": "apache-2.0",
  "name": "pulumi-command",
  "package_url": "https://pypi.org/project/pulumi-command/",
  "project_url": "https://pypi.org/project/pulumi-command/",
  "project_urls": {
    "Homepage": "https://pulumi.com",
    "Repository": "https://github.com/pulumi/pulumi-command"
  },
  "release_url": "https://pypi.org/project/pulumi-command/0.9.2/",
  "requires_dist": [
    "parver >=0.2.1",
    "pulumi <4.0.0,>=3.0.0",
    "semver >=2.8.1"
  ],
  "requires_python": ">=3.7",
  "summary": "the pulumi command provider enables you to execute commands and scripts either locally or remotely as part of the pulumi resource model.",
  "version": "0.9.2",
  "releases": [],
  "developers": [],
  "kwds": "pulumi commands svg slack command",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_pulumi_command",
  "homepage": "",
  "release_count": 130,
  "dependency_ids": [
    "pypi_parver",
    "pypi_pulumi",
    "pypi_semver"
  ]
}