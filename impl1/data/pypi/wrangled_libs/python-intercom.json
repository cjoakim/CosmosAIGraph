{
  "classifiers": [
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4"
  ],
  "description": "python-intercom\n===============\n\n|pypi version| |pypi downloads| |travis ci build| |coverage status|\n\npython bindings for the intercom api (https://api.intercom.io).\n\n`api documentation <https://developers.intercom.com/reference>`__.\n\n`package\ndocumentation <http://readthedocs.org/docs/python-intercom/>`__.\n\nupgrading information\n---------------------\n\nversion 3 of python-intercom is **not backwards compatible** with\nprevious versions.\n\nversion 3 moves away from a global setup approach to the use of an\nintercom client.\n\ninstallation\n------------\n\n::\n\n    pip install python-intercom\n\nbasic usage\n-----------\n\nconfigure your client\n~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    from intercom.client import client\n    intercom = client(personal_access_token='my_personal_access_token')\n\nnote that certain resources will require an extended scope access token : `setting up personal access tokens <https://developers.intercom.com/docs/personal-access-tokens>`_\n\nresources\n~~~~~~~~~\n\nresources this api supports:\n\n::\n\n    https://api.intercom.io/users\n    https://api.intercom.io/contacts\n    https://api.intercom.io/companies\n    https://api.intercom.io/counts\n    https://api.intercom.io/tags\n    https://api.intercom.io/notes\n    https://api.intercom.io/segments\n    https://api.intercom.io/events\n    https://api.intercom.io/conversations\n    https://api.intercom.io/messages\n    https://api.intercom.io/subscriptions\n    https://api.intercom.io/jobs\n    https://api.intercom.io/bulk\n\nexamples\n~~~~~~~~\n\nusers\n^^^^^\n\n.. code:: python\n\n    # find user by email\n    user = intercom.users.find(email=\"bob@example.com\")\n    # find user by user_id\n    user = intercom.users.find(user_id=\"1\")\n    # find user by id\n    user = intercom.users.find(id=\"1\")\n    # create a user\n    user = intercom.users.create(email=\"bob@example.com\", name=\"bob smith\")\n    # delete a user\n    user = intercom.users.find(id=\"1\")\n    deleted_user = intercom.users.delete(user)\n    # update custom_attributes for a user\n    user.custom_attributes[\"average_monthly_spend\"] = 1234.56\n    intercom.users.save(user)\n    # perform incrementing\n    user.increment('karma')\n    intercom.users.save(user)\n    # iterate over all users\n    for user in intercom.users.all():\n        ...\n\n    # bulk operations.\n    # submit bulk job, to create users, if any of the items in create_items match an existing user that user will be updated\n    intercom.users.submit_bulk_job(create_items=[{'user_id': 25, 'email': 'alice@example.com'}, {'user_id': 25, 'email': 'bob@example.com'}])\n    # submit bulk job, to delete users\n    intercom.users.submit_bulk_job(delete_items=[{'user_id': 25, 'email': 'alice@example.com'}, {'user_id': 25, 'email': 'bob@example.com'}])\n    # submit bulk job, to add items to existing job\n    intercom.users.submit_bulk_job(create_items=[{'user_id': 25, 'email': 'alice@example.com'}], delete_items=[{'user_id': 25, 'email': 'bob@example.com'}], 'job_id': 'job_abcd1234')\n\nadmins\n^^^^^^\n\n.. code:: python\n\n    # iterate over all admins\n    for admin in intercom.admins.all():\n        ...\n\ncompanies\n^^^^^^^^^\n\n.. code:: python\n\n    # add a user to one or more companies\n    user = intercom.users.find(email='bob@example.com')\n    user.companies = [\n        {'company_id': 6, 'name': 'intercom'},\n        {'company_id': 9, 'name': 'test company'}\n    ]\n    intercom.users.save(user)\n    # you can also pass custom attributes within a company as you do this\n    user.companies = [\n        {\n            'id': 6,\n            'name': 'intercom',\n            'custom_attributes': {\n                'referral_source': 'google'\n            }\n        }\n    ]\n    intercom.users.save(user)\n    # find a company by company_id\n    company = intercom.companies.find(company_id='44')\n    # find a company by name\n    company = intercom.companies.find(name='some company')\n    # find a company by id\n    company = intercom.companies.find(id='41e66f0313708347cb0000d0')\n    # update a company\n    company.name = 'updated company name'\n    intercom.companies.save(company)\n    # iterate over all companies\n    for company in intercom.companies.all():\n        ...\n    # get a list of users in a company\n    intercom.companies.users(company.id)\n\ntags\n^^^^\n\n.. code:: python\n\n    # tag users\n    tag = intercom.tags.tag_users(name='blue', users=[{'email': 'test1@example.com'}])\n    # untag users\n    intercom.tags.untag_users(name='blue', users=[{'user_id': '42ea2f1b93891f6a99000427'}])\n    # iterate over all tags\n    for tag in intercom.tags.all():\n        ...\n    # tag companies\n    tag = intercom.tags.tag(name='blue', companies=[{'id': '42ea2f1b93891f6a99000427'}])\n\nsegments\n^^^^^^^^\n\n.. code:: python\n\n    # find a segment\n    segment = intercom.segments.find(id=segment_id)\n    # iterate over all segments\n    for segment in intercom.segments.all():\n        ...\n\nnotes\n^^^^^\n\n.. code:: python\n\n    # find a note by id\n    note = intercom.notes.find(id=note)\n    # create a note for a user\n    note = intercom.notes.create(\n        body=\"<p>text for the note</p>\",\n        email='joe@example.com')\n    # iterate over all notes for a user via their email address\n    for note in intercom.notes.find_all(email='joe@example.com'):\n        ...\n    # iterate over all notes for a user via their user_id\n    for note in intercom.notes.find_all(user_id='123'):\n        ...\n\nconversations\n^^^^^^^^^^^^^\n\n.. code:: python\n\n    # finding conversations for an admin\n    # iterate over all conversations (open and closed) assigned to an admin\n    for convo in intercom.conversations.find_all(type='admin', id='7'):\n        ...\n    # iterate over all open conversations assigned to an admin\n    for convo in intercom.conversations.find_all(type='admin', id=7, open=true):\n        ...\n    # iterate over closed conversations assigned to an admin\n    for convo intercom.conversations.find_all(type='admin', id=7, open=false):\n        ...\n    # iterate over closed conversations for assigned an admin, before a certain\n    # moment in time\n    for convo in intercom.conversations.find_all(\n            type='admin', id= 7, open= false, before=1374844930):\n        ...\n\n    # finding conversations for a user\n    # iterate over all conversations (read + unread, correct) with a user based on\n    # the users email\n    for convo in intercom.onversations.find_all(email='joe@example.com',type='user'):\n        ...\n    # iterate over through all conversations (read + unread) with a user based on\n    # the users email\n    for convo in intercom.conversations.find_all(\n            email='joe@example.com', type='user', unread=false):\n        ...\n    # iterate over all unread conversations with a user based on the users email\n    for convo in intercom.conversations.find_all(\n            email='joe@example.com', type='user', unread=true):\n        ...\n\n    # finding a single conversation\n    conversation = intercom.conversations.find(id='1')\n\n    # interacting with the parts of a conversation\n    # getting the subject of a part (only applies to email-based conversations)\n    conversation.rendered_message.subject\n    # get the part_type of the first part\n    conversation.conversation_parts[0].part_type\n    # get the body of the second part\n    conversation.conversation_parts[1].body\n\n    # replying to conversations\n    # user (identified by email) replies with a comment\n    intercom.conversations.reply(\n        type='user', email='joe@example.com',\n        message_type='comment', body='foo')\n    # admin (identified by email) replies with a comment\n    intercom.conversations.reply(\n        type='admin', email='bob@example.com',\n        message_type='comment', body='bar')\n    # user (identified by email) replies with a comment and attachment\n    intercom.conversations.reply(id=conversation.id, type='user', email='joe@example.com', message_type='comment', body='foo', attachment_urls=['http://www.example.com/attachment.jpg'])\n\n    # open\n    intercom.conversations.open(id=conversation.id, admin_id='123')\n\n    # close\n    intercom.conversations.close(id=conversation.id, admin_id='123')\n\n    # assign\n    intercom.conversations.assign(id=conversation.id, admin_id='123', assignee_id='124')\n\n    # reply and open\n    intercom.conversations.reply(id=conversation.id, type='admin', admin_id='123', message_type='open', body='bar')\n\n    # reply and close\n    intercom.conversations.reply(id=conversation.id, type='admin', admin_id='123', message_type='close', body='bar')\n\n    # assigning conversations to admins\n    intercom.conversations.reply(id=conversation.id, type='admin', assignee_id=assignee_admin.id, admin_id=admin.id, message_type='assignment')\n\n    # marking a conversation as read\n    intercom.conversations.mark_read(conversation.id)\n\nfull loading of an embedded entity\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n    # given a conversation with a partial user, load the full user. this can be\n    # done for any entity\n    intercom.users.load(conversation.user)\n\nsending messages\n^^^^^^^^^^^^^^^^\n\n.. code:: python\n\n    # inapp message from admin to user\n    intercom.messages.create(**{\n        \"message_type\": \"inapp\",\n        \"body\": \"what's up :)\",\n        \"from\": {\n            \"type\": \"admin\",\n            \"id\": \"1234\"\n        },\n        \"to\": {\n            \"type\": \"user\",\n            \"id\": \"5678\"\n        }\n    })\n\n    # email message from admin to user\n    intercom.messages.create(**{\n        \"message_type\": \"email\",\n        \"subject\": \"hey there\",\n        \"body\": \"what's up :)\",\n        \"template\": \"plain\", # or \"personal\",\n        \"from\": {\n            \"type\": \"admin\",\n            \"id\": \"1234\"\n        },\n        \"to\": {\n            \"type\": \"user\",\n            \"id\": \"536e564f316c83104c000020\"\n        }\n    })\n\n    # message from a user\n    intercom.messages.create(**{\n        \"from\": {\n            \"type\": \"user\",\n            \"id\": \"536e564f316c83104c000020\"\n        },\n        \"body\": \"halp\"\n    })\n\n    # message from admin to contact\n    intercom.messages.create(**{\n        'body': 'how can i help :)',\n        'from': {\n            'type': 'admin',\n            'id': '1234'\n        },\n        'to': {\n            'type': 'contact',\n            'id': '536e5643as316c83104c400671'\n        }\n    })\n\n    # message from a contact\n    intercom.messages.create(**{\n        'from' => {\n            'type': 'contact',\n            'id': '536e5643as316c83104c400671'\n        },\n        'body': 'halp'\n    })\n\nevents\n^^^^^^\n\n.. code:: python\n\n    intercom.events.create(\n        event_name='invited-friend',\n        created_at=time.mktime(),\n        email=user.email,\n        metadata={\n            'invitee_email': 'pi@example.org',\n            'invite_code': 'addafriend',\n            'found_date': 12909364407\n        }\n    )\n\n    # retrieve event list for user with id:'123abc'\n    intercom.events.find_all(type='user', \"intercom_user_id\"=\"123abc)\n\nmetadata objects support a few simple types that intercom can present on\nyour behalf\n\n.. code:: python\n\n    intercom.events.create(\n        event_name=\"placed-order\",\n        email=current_user.email,\n        created_at=1403001013\n        metadata={\n            'order_date': time.mktime(),\n            'stripe_invoice': 'inv_3434343434',\n            'order_number': {\n                'value': '3434-3434',\n                'url': 'https://example.org/orders/3434-3434'\n            },\n            'price': {\n                'currency': 'usd',\n                'amount': 2999\n            }\n        }\n    )\n\nthe metadata key values in the example are treated as follows-\n\n-  order\\_date: a date (key ends with '\\_date').\n-  stripe\\_invoice: the identifier of the stripe invoice (has a\n   'stripe\\_invoice' key)\n-  order\\_number: a rich link (value contains 'url' and 'value' keys)\n-  price: an amount in us dollars (value contains 'amount' and\n   'currency' keys)\n\nbulk operations.\n\n.. code:: python\n\n    # submit bulk job, to create events\n    intercom.events.submit_bulk_job(create_items: [\n        {\n            'event_name': 'ordered-item',\n            'created_at': 1438944980,\n            'user_id': '314159',\n            'metadata': {\n                'order_date': 1438944980,\n                'stripe_invoice': 'inv_3434343434'\n            }\n        },\n        {\n            'event_name': 'invited-friend',\n            'created_at': 1438944979,\n            'user_id': '314159',\n            'metadata': {\n                'invitee_email': 'pi@example.org',\n                'invite_code': 'addafriend'\n            }\n        }\n    ])\n\n    # submit bulk job, to add items to existing job\n    intercom.events.submit_bulk_job(create_items=[\n        {\n            'event_name': 'ordered-item',\n            'created_at': 1438944980,\n            'user_id': '314159',\n            'metadata': {\n                'order_date': 1438944980,\n                'stripe_invoice': 'inv_3434343434'\n            }\n        },\n        {\n            'event_name': 'invited-friend',\n            'created_at': 1438944979,\n            'user_id': \"314159\",\n            'metadata': {\n                'invitee_email': 'pi@example.org',\n                'invite_code': 'addafriend'\n            }\n        }\n        ], job_id='job_abcd1234')\n\ncontacts\n^^^^^^^^\n\ncontacts represent logged out users of your application.\n\n.. code:: python\n\n    # create a contact\n    contact = intercom.contacts.create(email=\"some_contact@example.com\")\n\n    # update a contact\n    contact.custom_attributes['foo'] = 'bar'\n    intercom.contacts.save(contact)\n\n    # find contacts by email\n    contacts = intercom.contacts.find_all(email=\"some_contact@example.com\")\n\n    # convert a contact into a user\n    intercom.contacts.convert(contact, user)\n\n    # delete a contact\n    intercom.contacts.delete(contact)\n\ncounts\n^^^^^^\n\n.. code:: python\n\n    # app-wide counts\n    intercom.counts.for_app()\n\n    # users in segment counts\n    intercom.counts.for_type(type='user', count='segment')\n\nsubscriptions\n~~~~~~~~~~~~~\n\nsubscribe to events in intercom to receive webhooks.\n\n.. code:: python\n\n    # create a subscription\n    intercom.subscriptions.create(url='http://example.com', topics=['user.created'])\n\n    # fetch a subscription\n    intercom.subscriptions.find(id='nsub_123456789')\n\n    # list subscriptions\n    intercom.subscriptions.all():\n        ...\n\nbulk jobs\n^^^^^^^^^\n\n.. code:: python\n\n    # fetch a job\n    intercom.jobs.find(id='job_abcd1234')\n\n    # fetch a job's error feed\n    intercom.jobs.errors(id='job_abcd1234')\n\nerrors\n~~~~~~\n\nyou do not need to deal with the http response from an api call\ndirectly. if there is an unsuccessful response then an error that is a\nsubclass of ``intercom.error`` will be raised. if desired, you can get\nat the http\\_code of an ``error`` via it's ``http_code`` method.\n\nthe list of different error subclasses are listed below. as they all\ninherit off ``intercomerror`` you can choose to except ``intercomerror``\nor the more specific error subclass:\n\n.. code:: python\n\n    authenticationerror\n    servererror\n    serviceunavailableerror\n    serviceconnectionerror\n    resourcenotfound\n    badgatewayerror\n    badrequesterror\n    ratelimitexceeded\n    multiplematchinguserserror\n    httperror\n    unexpectederror\n\nrate limiting\n~~~~~~~~~~~~~\n\ncalling your clients ``rate_limit_details`` returns a dict that contains\ndetails about your app's current rate limit.\n\n.. code:: python\n\n    intercom.rate_limit_details\n    # {'limit': 180, 'remaining': 179, 'reset_at': datetime.datetime(2014, 10, 07, 14, 58)}\n\nrunning the tests\n-----------------\n\nunit tests:\n\n.. code:: bash\n\n    nosetests tests/unit\n\nintegration tests:\n\n.. code:: bash\n\n    intercom_personal_access_token=xxx nosetests tests/integration\n\n.. |pypi version| image:: https://img.shields.io/pypi/v/python-intercom.svg\n   :target: https://pypi.python.org/pypi/python-intercom\n.. |pypi downloads| image:: https://img.shields.io/pypi/dm/python-intercom.svg\n   :target: https://pypi.python.org/pypi/python-intercom\n.. |travis ci build| image:: https://travis-ci.org/jkeyes/python-intercom.svg\n   :target: https://travis-ci.org/jkeyes/python-intercom\n.. |coverage status| image:: https://coveralls.io/repos/github/jkeyes/python-intercom/badge.svg?branch=master\n   :target: https://coveralls.io/github/jkeyes/python-intercom?branch=master\n",
  "docs_url": null,
  "keywords": "intercom crm python",
  "license": "mit license",
  "name": "python-intercom",
  "package_url": "https://pypi.org/project/python-intercom/",
  "project_url": "https://pypi.org/project/python-intercom/",
  "project_urls": {
    "Homepage": "http://github.com/jkeyes/python-intercom"
  },
  "release_url": "https://pypi.org/project/python-intercom/3.1.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "intercom api wrapper",
  "version": "3.1.0",
  "releases": [],
  "developers": [
    "john@keyes.ie",
    "john_keyes"
  ],
  "kwds": "intercom_personal_access_token intercomerror intercom intercom_user_id pip",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_python_intercom",
  "homepage": "http://github.com/jkeyes/python-intercom",
  "release_count": 27,
  "dependency_ids": []
}