{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: python software foundation license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: utilities"
  ],
  "description": "=====================================\nfixedint: simple fixed-width integers\n=====================================\n\nthis module provides fixed-size integer classes which retain their fixed nature across\narithmetic operations. it is geared towards users who need to emulate machine integers.\n\nit provides flexible classes for defining integers with a fixed number of bits, as well\nas predefined classes for common machine integer sizes. these classes can be used as\ndrop-in replacements for int/long, and can be sliced to extract bitfields.\n\nmutable versions of these integers are provided, enabling usages such as emulation of\nmachine registers.\n\n\n\nbasic usage\n===========\n\na collection of predefined fixed-width integers for widths 8, 16, 32 and 64 are available\nin signed and unsigned varieties. mutable and immutable versions of each type are provided.\n\nthese are named as ``[mutable][u]int<n>``, e.g. ``uint64`` or ``mutableint8``. use these\nclasses as you would ``int``; arithmetic operations involving these classes will preserve\nfixed width. for example::\n\n    x = uint32(0)\n    print(hex(~x)) # prints 0xffffffff\n\nmutable instances can be modified in-place, preserving their type::\n\n    x = mutableuint32(0)\n    y = x\n    x += 100\n    print(y) # prints 100\n\nto set a mutable integer without losing its type, use slicing::\n\n    x = mutableuint32(0)\n    x[:] = -1\n    print(hex(x)) # prints 0xffffffff\n\n\narithmetic operations\n=====================\n\n``fixedint`` instances support all arithmetic operators. for binary operators, both\noperands are converted to plain python ``int`` and then operated on. with a few\nexceptions, the result will be cast back to a ``fixedint`` large enough to hold either\noperand, provided one of the operands was a ``fixedint``. note that the resulting\n``fixedint`` may not be large enough to hold the complete result, in which case the\nresult will be truncated.\n\nthe exceptions are as follows:\n\n* ``divmod`` returns a tuple of plain ``int`` s\n* true division returns a float\n* ``**``, ``<<`` and ``>>`` will return a ``fixedint`` if the left operand was a\n  ``fixedint``, and plain ``int`` otherwise.\n\nmutable instances additionally support in-place operations, which will modify the\nvalue without altering its type.\n\n\narithmetic operations between two integers of different sizes follow c integer promotion\nrules when determining the type of the final result. these rules boil down to the\nfollowing:\n\n* if the operands are both signed, or both unsigned, the wider of the two operand types is chosen.\n* otherwise, if the unsigned operand is wider, the unsigned operand is chosen.\n* otherwise, the signed operand is chosen.\n\n\n\n\nslicing\n=======\n\n``fixedint`` instances support slicing. slicing with a single integer produces a single\nboolean value representing the bit at that position. slicing with a range produces a\n``fixedint`` containing the range of bits. mutable instances additionally support slice\nassignment. this makes e.g. manipulating a flag register straightforward, without needing\nto use bitwise operations.\n\nall indexing operations treat the least-significant bit (lsb) as bit 0. currently, only\ncontiguous bit sections can be obtained; for more flexibility consider using a module\nsuch as `bitarray`.\n\ngetting a slice results in a ``fixedint`` instance with exactly as many bits as the range.\nthis can be used to perform wraparound arithmetic on a bit field.\n\nslices support two main syntaxes::\n\n    value[<start>:<end>]\n    value[<start>:<length>j]\n\nthe latter syntax is more convenient when dealing with fixed-width fields. either of the\nslice arguments may be omitted, in which case they will default to the lsb and msb of\nthe ``fixedint`` respectively.\n\n\n\nbyte conversion\n===============\n\n``fixedint`` instances can be converted to and from raw byte representations by using the\n``.to_bytes`` instance method and the ``.from_bytes`` classmethod. the usage of these\nmethods matches that of python 3.4's ``int.to_bytes`` and ``int.from_bytes`` methods, but\nthe length is automatically inferred from the integer width.\n\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "psf",
  "name": "fixedint",
  "package_url": "https://pypi.org/project/fixedint/",
  "project_url": "https://pypi.org/project/fixedint/",
  "project_urls": {
    "Homepage": "https://github.com/nneonneo/fixedint"
  },
  "release_url": "https://pypi.org/project/fixedint/0.2.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "simple fixed-width integers",
  "version": "0.2.0",
  "releases": [],
  "developers": [
    "robert.bo.xiao@gmail.com",
    "robert_xiao"
  ],
  "kwds": "bitfields bitwise binary mutableuint32 integers",
  "license_kwds": "psf",
  "libtype": "pypi",
  "id": "pypi_fixedint",
  "homepage": "https://github.com/nneonneo/fixedint",
  "release_count": 8,
  "dependency_ids": []
}