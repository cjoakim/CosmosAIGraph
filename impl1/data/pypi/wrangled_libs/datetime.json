{
  "classifiers": [
    "development status :: 6 - mature",
    "environment :: web environment",
    "framework :: zope :: 4",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": ".. image:: https://github.com/zopefoundation/datetime/workflows/tests/badge.svg\n        :target: https://github.com/zopefoundation/datetime/actions?query=workflow%3atests\n        :alt: ci status\n\n.. image:: https://img.shields.io/pypi/v/datetime.svg\n        :target: https://pypi.org/project/datetime/\n        :alt: current version on pypi\n\n.. image:: https://img.shields.io/pypi/pyversions/datetime.svg\n        :target: https://pypi.org/project/datetime/\n        :alt: supported python versions\n\n\ndatetime\n========\n\nthis package provides a datetime data type, as known from zope.\n\nunless you need to communicate with zope apis, you're probably better\noff using python's built-in datetime module.\n\nfor further documentation, please have a look at `src/datetime/datetime.txt`.\n\n\n.. contents::\n\nthe datetime package\n====================\n\nencapsulation of date/time values.\n\n\nfunction timezones()\n--------------------\n\nreturns the list of recognized timezone names:\n\n  >>> from datetime import timezones\n  >>> zones = set(timezones())\n\nalmost all of the standard pytz timezones are included, with the exception\nof some commonly-used but ambiguous abbreviations, where historical zope\nusage conflicts with the name used by pytz:\n\n  >>> import pytz\n  >>> [x for x in pytz.all_timezones if x not in zones]\n  ['cet', 'eet', 'est', 'met', 'mst', 'wet']\n\nclass datetime\n--------------\n\ndatetime objects represent instants in time and provide interfaces for\ncontrolling its representation without affecting the absolute value of\nthe object.\n\ndatetime objects may be created from a wide variety of string or\nnumeric data, or may be computed from other datetime objects.\ndatetimes support the ability to convert their representations to many\nmajor timezones, as well as the ability to create a datetime object\nin the context of a given timezone.\n\ndatetime objects provide partial numerical behavior:\n\n* two date-time objects can be subtracted to obtain a time, in days\n  between the two.\n\n* a date-time object and a positive or negative number may be added to\n  obtain a new date-time object that is the given number of days later\n  than the input date-time object.\n\n* a positive or negative number and a date-time object may be added to\n  obtain a new date-time object that is the given number of days later\n  than the input date-time object.\n\n* a positive or negative number may be subtracted from a date-time\n  object to obtain a new date-time object that is the given number of\n  days earlier than the input date-time object.\n\ndatetime objects may be converted to integer, long, or float numbers\nof days since january 1, 1901, using the standard int, long, and float\nfunctions (compatibility note: int, long and float return the number\nof days since 1901 in gmt rather than local machine timezone).\ndatetime objects also provide access to their value in a float format\nusable with the python time module, provided that the value of the\nobject falls in the range of the epoch-based time module.\n\na datetime object should be considered immutable; all conversion and numeric\noperations return a new datetime object rather than modify the current object.\n\na datetime object always maintains its value as an absolute utc time,\nand is represented in the context of some timezone based on the\narguments used to create the object.  a datetime object's methods\nreturn values based on the timezone context.\n\nnote that in all cases the local machine timezone is used for\nrepresentation if no timezone is specified.\n\nconstructor for datetime\n------------------------\n\ndatetime() returns a new date-time object.  datetimes may be created\nwith from zero to seven arguments:\n\n* if the function is called with no arguments, then the current date/\n  time is returned, represented in the timezone of the local machine.\n\n* if the function is invoked with a single string argument which is a\n  recognized timezone name, an object representing the current time is\n  returned, represented in the specified timezone.\n\n* if the function is invoked with a single string argument\n  representing a valid date/time, an object representing that date/\n  time will be returned.\n\n  as a general rule, any date-time representation that is recognized\n  and unambiguous to a resident of north america is acceptable.  (the\n  reason for this qualification is that in north america, a date like:\n  2/1/1994 is interpreted as february 1, 1994, while in some parts of\n  the world, it is interpreted as january 2, 1994.) a date/ time\n  string consists of two components, a date component and an optional\n  time component, separated by one or more spaces.  if the time\n  component is omitted, 12:00am is assumed.\n  \n  any recognized timezone name specified as the final element of the\n  date/time string will be used for computing the date/time value.\n  (if you create a datetime with the string,\n  \"mar 9, 1997 1:45pm us/pacific\", the value will essentially be the\n  same as if you had captured time.time() at the specified date and\n  time on a machine in that timezone).  if no timezone is passed, then\n  the timezone configured on the local machine will be used, **except**\n  that if the date format matches iso 8601 ('yyyy-mm-dd'), the instance\n  will use utc / gmt+0 as the timezone.\n\n  o returns current date/time, represented in us/eastern:\n\n    >>> from datetime import datetime\n    >>> e = datetime('us/eastern')\n    >>> e.timezone()\n    'us/eastern'\n\n  o returns specified time, represented in local machine zone:\n\n    >>> x = datetime('1997/3/9 1:45pm')\n    >>> x.parts() # doctest: +ellipsis\n    (1997, 3, 9, 13, 45, ...)\n\n  o specified time in local machine zone, verbose format:\n\n    >>> y = datetime('mar 9, 1997 13:45:00')\n    >>> y.parts() # doctest: +ellipsis\n    (1997, 3, 9, 13, 45, ...)\n    >>> y == x\n    true\n    \n  o specified time in utc via iso 8601 rule:\n  \n    >>> z = datetime('2014-03-24')\n    >>> z.parts() # doctest: +ellipsis\n    (2014, 3, 24, 0, 0, ...)\n    >>> z.timezone()\n    'gmt+0'\n\n  the date component consists of year, month, and day values.  the\n  year value must be a one-, two-, or four-digit integer.  if a one-\n  or two-digit year is used, the year is assumed to be in the\n  twentieth century.  the month may an integer, from 1 to 12, a month\n  name, or a month abbreviation, where a period may optionally follow\n  the abbreviation.  the day must be an integer from 1 to the number of\n  days in the month.  the year, month, and day values may be separated\n  by periods, hyphens, forward slashes, or spaces.  extra spaces are\n  permitted around the delimiters.  year, month, and day values may be\n  given in any order as long as it is possible to distinguish the\n  components.  if all three components are numbers that are less than\n  13, then a month-day-year ordering is assumed.\n\n  the time component consists of hour, minute, and second values\n  separated by colons.  the hour value must be an integer between 0\n  and 23 inclusively.  the minute value must be an integer between 0\n  and 59 inclusively.  the second value may be an integer value\n  between 0 and 59.999 inclusively.  the second value or both the\n  minute and second values may be omitted.  the time may be followed\n  by am or pm in upper or lower case, in which case a 12-hour clock is\n  assumed.\n\n* if the datetime function is invoked with a single numeric argument,\n  the number is assumed to be either a floating point value such as\n  that returned by time.time(), or a number of days after january 1,\n  1901 00:00:00 utc.\n\n  a datetime object is returned that represents either the gmt value\n  of the time.time() float represented in the local machine's\n  timezone, or that number of days after january 1, 1901.  note that\n  the number of days after 1901 need to be expressed from the\n  viewpoint of the local machine's timezone.  a negative argument will\n  yield a date-time value before 1901.\n\n* if the function is invoked with two numeric arguments, then the\n  first is taken to be an integer year and the second argument is\n  taken to be an offset in days from the beginning of the year, in the\n  context of the local machine timezone.  the date-time value returned\n  is the given offset number of days from the beginning of the given\n  year, represented in the timezone of the local machine.  the offset\n  may be positive or negative.  two-digit years are assumed to be in\n  the twentieth century.\n\n* if the function is invoked with two arguments, the first a float\n  representing a number of seconds past the epoch in gmt (such as\n  those returned by time.time()) and the second a string naming a\n  recognized timezone, a datetime with a value of that gmt time will\n  be returned, represented in the given timezone.\n\n    >>> import time\n    >>> t = time.time()\n\n  time t represented as us/eastern:\n\n    >>> now_east = datetime(t, 'us/eastern')\n\n  time t represented as us/pacific:\n\n    >>> now_west = datetime(t, 'us/pacific')\n\n  only their representations are different:\n\n    >>> now_east.equalto(now_west)\n    true\n\n* if the function is invoked with three or more numeric arguments,\n  then the first is taken to be an integer year, the second is taken\n  to be an integer month, and the third is taken to be an integer day.\n  if the combination of values is not valid, then a datetimeerror is\n  raised.  one- or two-digit years up to 69 are assumed to be in the \n  21st century, whereas values 70-99 are assumed to be 20th century.\n  the fourth, fifth, and sixth arguments are floating point, positive\n  or negative offsets in units of hours, minutes, and days, and\n  default to zero if not given.  an optional string may be given as\n  the final argument to indicate timezone (the effect of this is as if\n  you had taken the value of time.time() at that time on a machine in\n  the specified timezone).\n\nif a string argument passed to the datetime constructor cannot be\nparsed, it will raise syntaxerror.  invalid date, time, or\ntimezone components will raise a datetimeerror.\n\nthe module function timezones() will return a list of the timezones\nrecognized by the datetime module.  recognition of timezone names is\ncase-insensitive.\n\ninstance methods for datetime (idatetime interface)\n---------------------------------------------------\n\nconversion and comparison methods\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* ``timetime()`` returns the date/time as a floating-point number in\n  utc, in the format used by the python time module.  note that it is\n  possible to create date /time values with datetime that have no\n  meaningful value to the time module, and in such cases a\n  datetimeerror is raised.  a datetime object's value must generally\n  be between jan 1, 1970 (or your local machine epoch) and jan 2038 to\n  produce a valid time.time() style value.\n\n    >>> dt = datetime('mar 9, 1997 13:45:00 us/eastern')\n    >>> dt.timetime()\n    857933100.0\n\n    >>> datetime('2040/01/01 utc').timetime()\n    2208988800.0\n\n    >>> datetime('1900/01/01 utc').timetime()\n    -2208988800.0\n\n* ``tozone(z)`` returns a datetime with the value as the current\n  object, represented in the indicated timezone:\n\n    >>> dt.tozone('utc')\n    datetime('1997/03/09 18:45:00 utc')\n\n    >>> dt.tozone('utc').equalto(dt)\n    true\n\n* ``isfuture()`` returns true if this object represents a date/time\n  later than the time of the call:\n\n    >>> dt.isfuture()\n    false\n    >>> datetime('jan 1 3000').isfuture() # not time-machine safe!\n    true\n\n* ``ispast()`` returns true if this object represents a date/time\n  earlier than the time of the call:\n\n    >>> dt.ispast()\n    true\n    >>> datetime('jan 1 3000').ispast() # not time-machine safe!\n    false\n\n* ``iscurrentyear()`` returns true if this object represents a\n  date/time that falls within the current year, in the context of this\n  object's timezone representation:\n\n    >>> dt.iscurrentyear()\n    false\n    >>> datetime().iscurrentyear()\n    true\n\n* ``iscurrentmonth()`` returns true if this object represents a\n  date/time that falls within the current month, in the context of\n  this object's timezone representation:\n\n    >>> dt.iscurrentmonth()\n    false\n    >>> datetime().iscurrentmonth()\n    true\n\n* ``iscurrentday()`` returns true if this object represents a\n  date/time that falls within the current day, in the context of this\n  object's timezone representation:\n\n    >>> dt.iscurrentday()\n    false\n    >>> datetime().iscurrentday()\n    true\n\n* ``iscurrenthour()`` returns true if this object represents a\n  date/time that falls within the current hour, in the context of this\n  object's timezone representation:\n\n    >>> dt.iscurrenthour()\n    false\n\n    >>> datetime().iscurrenthour()\n    true\n\n* ``iscurrentminute()`` returns true if this object represents a\n  date/time that falls within the current minute, in the context of\n  this object's timezone representation:\n\n    >>> dt.iscurrentminute()\n    false\n    >>> datetime().iscurrentminute()\n    true\n\n* ``isleapyear()`` returns true if the current year (in the context of\n  the object's timezone) is a leap year:\n\n    >>> dt.isleapyear()\n    false\n    >>> datetime('mar 8 2004').isleapyear()\n    true\n\n* ``earliesttime()`` returns a new datetime object that represents the\n    earliest possible time (in whole seconds) that still falls within\n    the current object's day, in the object's timezone context:\n\n    >>> dt.earliesttime()\n    datetime('1997/03/09 00:00:00 us/eastern')\n\n* ``latesttime()`` return a new datetime object that represents the\n  latest possible time (in whole seconds) that still falls within the\n  current object's day, in the object's timezone context\n\n    >>> dt.latesttime()\n    datetime('1997/03/09 23:59:59 us/eastern')\n\ncomponent access\n~~~~~~~~~~~~~~~~\n\n* ``parts()`` returns a tuple containing the calendar year, month,\n  day, hour, minute second and timezone of the object\n\n    >>> dt.parts() # doctest: +ellipsis\n    (1997, 3, 9, 13, 45, ... 'us/eastern')\n\n* ``timezone()`` returns the timezone in which the object is represented:\n\n    >>> dt.timezone() in timezones()\n    true\n\n* ``tzoffset()`` returns the timezone offset for the objects timezone:\n\n    >>> dt.tzoffset()\n    -18000\n\n* ``year()`` returns the calendar year of the object:\n\n    >>> dt.year()\n    1997\n\n* ``month()`` returns the month of the object as an integer:\n\n    >>> dt.month()\n    3\n\n* ``month()`` returns the full month name:\n\n    >>> dt.month()\n    'march'\n\n* ``amonth()`` returns the abbreviated month name:\n\n    >>> dt.amonth()\n    'mar'\n\n* ``pmonth()`` returns the abbreviated (with period) month name:\n\n    >>> dt.pmonth()\n    'mar.'\n\n* ``day()`` returns the integer day:\n\n    >>> dt.day()\n    9\n\n* ``day()`` returns the full name of the day of the week:\n\n    >>> dt.day()\n    'sunday'\n\n* ``dayofyear()`` returns the day of the year, in context of the\n  timezone representation of the object:\n\n    >>> dt.dayofyear()\n    68\n\n* ``aday()`` returns the abbreviated name of the day of the week:\n\n    >>> dt.aday()\n    'sun'\n\n* ``pday()`` returns the abbreviated (with period) name of the day of\n  the week:\n\n    >>> dt.pday()\n    'sun.'\n\n* ``dow()`` returns the integer day of the week, where sunday is 0:\n\n    >>> dt.dow()\n    0\n\n* ``dow_1()`` returns the integer day of the week, where sunday is 1:\n\n    >>> dt.dow_1()\n    1\n\n* ``h_12()`` returns the 12-hour clock representation of the hour:\n\n    >>> dt.h_12()\n    1\n\n* ``h_24()`` returns the 24-hour clock representation of the hour:\n\n    >>> dt.h_24()\n    13\n\n* ``ampm()`` returns the appropriate time modifier (am or pm):\n\n    >>> dt.ampm()\n    'pm'\n\n* ``hour()`` returns the 24-hour clock representation of the hour:\n\n    >>> dt.hour()\n    13\n\n* ``minute()`` returns the minute:\n\n    >>> dt.minute()\n    45\n\n* ``second()`` returns the second:\n\n    >>> dt.second() == 0\n    true\n\n* ``millis()`` returns the milliseconds since the epoch in gmt.\n\n    >>> dt.millis() == 857933100000\n    true\n\nstrftime()\n~~~~~~~~~~\n\nsee ``tests/test_datetime.py``.\n\ngeneral formats from previous datetime\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n* ``date()`` return the date string for the object:\n\n    >>> dt.date()\n    '1997/03/09'\n\n* ``time()`` returns the time string for an object to the nearest\n  second:\n\n    >>> dt.time()\n    '13:45:00'\n\n* ``timeminutes()`` returns the time string for an object not showing\n  seconds:\n\n    >>> dt.timeminutes()\n    '13:45'\n\n* ``ampm()`` returns the time string for an object to the nearest second:\n\n    >>> dt.ampm()\n    '01:45:00 pm'\n\n* ``ampmminutes()`` returns the time string for an object not showing\n  seconds:\n\n    >>> dt.ampmminutes()\n    '01:45 pm'\n\n* ``precisetime()`` returns the time string for the object:\n\n    >>> dt.precisetime()\n    '13:45:00.000'\n\n* ``preciseampm()`` returns the time string for the object:\n\n    >>> dt.preciseampm()\n    '01:45:00.000 pm'\n\n* ``yy()`` returns the calendar year as a 2 digit string\n\n    >>> dt.yy()\n    '97'\n\n* ``mm()`` returns the month as a 2 digit string\n\n    >>> dt.mm()\n    '03'\n\n* ``dd()`` returns the day as a 2 digit string:\n\n    >>> dt.dd()\n    '09'\n\n* ``rfc822()`` returns the date in rfc 822 format:\n\n    >>> dt.rfc822()\n    'sun, 09 mar 1997 13:45:00 -0500'\n\nnew formats\n~~~~~~~~~~~\n\n* ``fcommon()`` returns a string representing the object's value in\n  the format: march 9, 1997 1:45 pm:\n\n    >>> dt.fcommon()\n    'march 9, 1997 1:45 pm'\n\n* ``fcommonz()`` returns a string representing the object's value in\n  the format: march 9, 1997 1:45 pm us/eastern:\n\n    >>> dt.fcommonz()\n    'march 9, 1997 1:45 pm us/eastern'\n\n* ``acommon()`` returns a string representing the object's value in\n  the format: mar 9, 1997 1:45 pm:\n\n    >>> dt.acommon()\n    'mar 9, 1997 1:45 pm'\n\n* ``acommonz()`` return a string representing the object's value in\n  the format: mar 9, 1997 1:45 pm us/eastern:\n\n    >>> dt.acommonz()\n    'mar 9, 1997 1:45 pm us/eastern'\n\n* ``pcommon()`` returns a string representing the object's value in\n  the format mar. 9, 1997 1:45 pm:\n\n    >>> dt.pcommon()\n    'mar. 9, 1997 1:45 pm'\n\n* ``pcommonz()`` returns a string representing the object's value in\n  the format: mar. 9, 1997 1:45 pm us/eastern:\n\n    >>> dt.pcommonz()\n    'mar. 9, 1997 1:45 pm us/eastern'\n\n* ``iso()`` returns a string with the date/time in iso format.  note:\n  this is not iso 8601-format! see the iso8601 and html4 methods below\n  for iso 8601-compliant output.  dates are output as: yyyy-mm-dd hh:mm:ss\n\n    >>> dt.iso()\n    '1997-03-09 13:45:00'\n\n* ``iso8601()`` returns the object in iso 8601-compatible format\n  containing the date, time with seconds-precision and the time zone\n  identifier - see http://www.w3.org/tr/note-datetime.  dates are\n  output as: yyyy-mm-ddthh:mm:sstzd (t is a literal character, tzd is\n  time zone designator, format +hh:mm or -hh:mm).\n\n  the ``html4()`` method below offers the same formatting, but\n  converts to utc before returning the value and sets the tzd\"z\"\n\n    >>> dt.iso8601()\n    '1997-03-09t13:45:00-05:00'\n\n\n* ``html4()`` returns the object in the format used in the html4.0\n  specification, one of the standard forms in iso8601.  see\n  http://www.w3.org/tr/note-datetime.  dates are output as:\n  yyyy-mm-ddthh:mm:ssz (t, z are literal characters, the time is in\n  utc.):\n\n    >>> dt.html4()\n    '1997-03-09t18:45:00z'\n\n* ``julianday()`` returns the julian day according to\n  http://www.tondering.dk/claus/cal/node3.html#sec-calcjd\n\n    >>> dt.julianday()\n    2450517\n\n* ``week()`` returns the week number according to iso\n  see http://www.tondering.dk/claus/cal/node6.html#section00670000000000000000\n\n    >>> dt.week()\n    10\n\ndeprecated api\n~~~~~~~~~~~~~~\n\n* dayofweek(): see day()\n\n* day_(): see pday()\n\n* mon(): see amonth()\n\n* mon_(): see pmonth\n\ngeneral services provided by datetime\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndatetimes can be repr()'ed; the result will be a string indicating how\nto make a datetime object like this:\n\n  >>> repr(dt)\n  \"datetime('1997/03/09 13:45:00 us/eastern')\"\n\nwhen we convert them into a string, we get a nicer string that could\nactually be shown to a user:\n\n  >>> str(dt)\n  '1997/03/09 13:45:00 us/eastern'\n\nthe hash value of a datetime is based on the date and time and is\nequal for different representations of the datetime:\n\n  >>> hash(dt)\n  3618678\n  >>> hash(dt.tozone('utc'))\n  3618678\n\ndatetime objects can be compared to other datetime objects or floating\npoint numbers such as the ones which are returned by the python time\nmodule by using the equalto method. using this api, true is returned if the\nobject represents a date/time equal to the specified datetime or time module\nstyle time:\n\n  >>> dt.equalto(dt)\n  true\n  >>> dt.equalto(dt.tozone('utc'))\n  true\n  >>> dt.equalto(dt.timetime())\n  true\n  >>> dt.equalto(datetime())\n  false\n\nsame goes for inequalities:\n\n  >>> dt.notequalto(dt)\n  false\n  >>> dt.notequalto(dt.tozone('utc'))\n  false\n  >>> dt.notequalto(dt.timetime())\n  false\n  >>> dt.notequalto(datetime())\n  true\n\nnormal equality operations only work with datetime objects and take the\ntimezone setting into account:\n\n  >>> dt == dt\n  true\n  >>> dt == dt.tozone('utc')\n  false\n  >>> dt == datetime()\n  false\n\n  >>> dt != dt\n  false\n  >>> dt != dt.tozone('utc')\n  true\n  >>> dt != datetime()\n  true\n\nbut the other comparison operations compare the referenced moment in time and\nnot the representation itself:\n\n  >>> dt > dt\n  false\n  >>> datetime() > dt\n  true\n  >>> dt > datetime().timetime()\n  false\n  >>> datetime().timetime() > dt\n  true\n\n  >>> dt.greaterthan(dt)\n  false\n  >>> datetime().greaterthan(dt)\n  true\n  >>> dt.greaterthan(datetime().timetime())\n  false\n\n  >>> dt >= dt\n  true\n  >>> datetime() >= dt\n  true\n  >>> dt >= datetime().timetime()\n  false\n  >>> datetime().timetime() >= dt\n  true\n\n  >>> dt.greaterthanequalto(dt)\n  true\n  >>> datetime().greaterthanequalto(dt)\n  true\n  >>> dt.greaterthanequalto(datetime().timetime())\n  false\n\n  >>> dt < dt\n  false\n  >>> datetime() < dt\n  false\n  >>> dt < datetime().timetime()\n  true\n  >>> datetime().timetime() < dt\n  false\n\n  >>> dt.lessthan(dt)\n  false\n  >>> datetime().lessthan(dt)\n  false\n  >>> dt.lessthan(datetime().timetime())\n  true\n\n  >>> dt <= dt\n  true\n  >>> datetime() <= dt\n  false\n  >>> dt <= datetime().timetime()\n  true\n  >>> datetime().timetime() <= dt\n  false\n\n  >>> dt.lessthanequalto(dt)\n  true\n  >>> datetime().lessthanequalto(dt)\n  false\n  >>> dt.lessthanequalto(datetime().timetime())\n  true\n\nnumeric services provided by datetime\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\na datetime may be added to a number and a number may be added to a\ndatetime:\n\n  >>> dt + 5\n  datetime('1997/03/14 13:45:00 us/eastern')\n  >>> 5 + dt\n  datetime('1997/03/14 13:45:00 us/eastern')\n\ntwo datetimes cannot be added:\n\n  >>> from datetime.interfaces import datetimeerror\n  >>> try:\n  ...     dt + dt\n  ...     print('fail')\n  ... except datetimeerror:\n  ...     print('ok')\n  ok\n\neither a datetime or a number may be subtracted from a datetime,\nhowever, a datetime may not be subtracted from a number:\n\n  >>> datetime('1997/03/10 13:45 us/eastern') - dt\n  1.0\n  >>> dt - 1\n  datetime('1997/03/08 13:45:00 us/eastern')\n  >>> 1 - dt\n  traceback (most recent call last):\n  ...\n  typeerror: unsupported operand type(s) for -: 'int' and 'datetime'\n\ndatetimes can also be converted to integers (number of seconds since\nthe epoch) and floats:\n\n  >>> int(dt)\n  857933100\n  >>> float(dt)\n  857933100.0\n\n\nchangelog\n=========\n\n5.4 (2023-12-15)\n----------------\n\n- fix ``unknowntimezoneerror`` when unpickling ``datetime.datetime().asdatetime()``.\n  (`#58 <https://github.com/zopefoundation/datetime/issues/58>`_)\n\n- repair equality comparison between datetime instances and other types.\n  (`#60 <https://github.com/zopefoundation/datetime/issues/60>`_)\n\n\n5.3 (2023-11-14)\n----------------\n\n- add support for python 3.12.\n\n- add preliminary support for python 3.13a2.\n\n\n5.2 (2023-07-19)\n----------------\n\n- cast int to float in compare methods.\n- fix compare methods between datetime instances and none.\n  (`#52 <https://github.com/zopefoundation/datetime/issues/52>`_)\n\n\n5.1 (2023-03-14)\n----------------\n\n- add missing ``python_requires`` to ``setup.py``.\n\n\n5.0 (2023-01-12)\n----------------\n\n- drop support for python 2.7, 3.5, 3.6.\n\n\n4.8 (2022-12-16)\n----------------\n\n- fix insidious buildout configuration bug that prevented tests on python 2.7\n  and 3.5, and fix test code that was incompatible with python 3.5.\n  (`#44 <https://github.com/zopefoundation/datetime/issues/44>`_)\n\n- add support for python 3.11.\n\n\n4.7 (2022-09-14)\n----------------\n\n- fix rounding problem with `datetime` addition beyond the year 2038\n  (`#41 <https://github.com/zopefoundation/datetime/issues/41>`_)\n\n\n4.6 (2022-09-10)\n----------------\n\n- fix ``__format__`` method for datetime objects\n  (`#39 <https://github.com/zopefoundation/datetime/issues/39>`_)\n\n\n4.5 (2022-07-04)\n----------------\n\n- add ``__format__`` method for datetime objects\n  (`#35 <https://github.com/zopefoundation/datetime/issues/35>`_)\n\n\n4.4 (2022-02-11)\n----------------\n\n- fix wat definition\n  `#31 <https://github.com/zopefoundation/datetime/issues/31>`_.\n\n- add support for python 3.8, 3.9, and 3.10.\n\n- drop support for python 3.4.\n\n4.3 (2018-10-05)\n----------------\n\n- add support for python 3.7.\n\n4.2 (2017-04-26)\n----------------\n\n- add support for python 3.6, drop support for python 3.3.\n\n4.1.1 (2016-04-30)\n------------------\n\n- support unpickling instances having a numeric timezone like `+0430`.\n\n4.1 (2016-04-03)\n----------------\n\n- add support for python 3.4 and 3.5.\n\n- drop support for python 2.6 and 3.2.\n\n4.0.1 (2013-10-15)\n------------------\n\n- provide more backward compatible timezones.\n  [vangheem]\n\n4.0 (2013-02-23)\n----------------\n\n- added support for python 3.2 and 3.3 in addition to 2.6 and 2.7.\n\n- removed unused legacy pytz tests and the datetimezone module and renamed\n  some test internals.\n\n3.0.3 (2013-01-22)\n------------------\n\n- allow timezone argument to be a unicode string while creating a datetime\n  object using two arguments.\n\n3.0.2 (2012-10-21)\n------------------\n\n- lp #1045233: respect date format setting for parsing dates like `11-01-2001`.\n\n3.0.1 (2012-09-23)\n------------------\n\n- add `_dt_reconstructor` function introduced in datetime 2.12.7 to provide\n  forward compatibility with pickles that might reference this function.\n\n3.0 (2011-12-09)\n----------------\n\n- no changes.\n\nbackwards compatibility of datetime 3\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndatetime 3 changes its pickle representation. datetime instances pickled with\nformer versions of datetime can be read, but older datetime versions cannot read\ndatetime instances pickled with version 3.\n\ndatetime 3 changes datetime to be a new-style class with slots instead of being\nan old-style class.\n\ndatetime 3 tries to preserve microsecond resolution throughout most of its api's\nwhile former versions were often only accurate to millisecond resolution. due to\nthe representation of float values in python versions before python 2.7 you\nshouldn't compare string or float representations of datetime instances if you\nwant high accuracy. the same is true for calculated values returned by methods\nlike `timetime()`. you get the highest accuracy of comparing datetime values by\ncalling its `micros()` methods. datetime is not particular well suited to be\nused in comparing timestamps of file systems - use the time and datetime objects\nfrom the python standard library instead.\n\n3.0b3 (2011-10-19)\n------------------\n\n- allow comparison of datetime objects against none.\n\n3.0b2 (2011-10-19)\n------------------\n\n- reverted the single argument `none` special case handling for unpickling and\n  continue to treat it as meaning `now`.\n\n3.0b1 (2011-05-07)\n------------------\n\n- restored `strftimeformatter` as a class.\n\n- added tests for read-only class attributes and interface.\n\n3.0a2 (2011-05-07)\n------------------\n\n- added back support for reading old datetime pickles without a `_micros` value.\n\n- avoid storing `_t` representing the time as a float in seconds since the\n  epoch, as we already have `_micros` doing the same as a long. memory use is\n  down to about 300 bytes per datetime instance.\n\n- updated exception raising syntax to current style.\n\n- avoid storing `_aday`, `_fday`, `_pday`, `_amon`, `_fmon`, `_pmon`, `_pmhour`\n  and `_pm` in memory for every instance but look them up dynamically based on\n  `_dayoffset`, `_month` and `_hour`. this saves another 150 bytes of memory\n  per datetime instance.\n\n- moved various internal parsing related class variables to module constants.\n\n- no longer provide the `dateerror`, `datetimeerror`, `syntaxerror` and\n  `timeerror` exceptions as class attributes, import them from their canonical\n  `datetime.interfaces` location instead.\n\n- removed deprecated `_isdst` and `_localzone` class variables.\n\n- moved pytz cache from `datetime._tzinfo` to a module global `_tzinfo`.\n\n- make datetime a new-style class and limit its available attributes via a\n  slots definition. the pickle size increases to 110 bytes thanks to the\n  `ccopy_reg\\n_reconstructor` stanza. but the memory size drops from 3kb to\n  500 bytes for each instance.\n\n3.0a1 (2011-05-06)\n------------------\n\n- reordered some calculations in `_calcindependentsecondetc` to preserve more\n  floating point precision.\n\n- optimized the pickled data, by only storing a tuple of `_micros` and time\n  zone information - this reduces the pickle size from an average of 300 bytes\n  to just 60 bytes.\n\n- optimized un-pickling, by avoiding the creation of an intermediate datetime\n  value representing the current time.\n\n- removed in-place migration of old datetime pickles without a `_micros` value.\n\n- removed deprecated support for using `datetime.__cmp__`.\n\n- take time zone settings into account when comparing two date times for\n  (non-) equality.\n\n- fixed (possibly unused) _parse_iso8601 function.\n\n- removed unused import of legacy datetimezone, strftime and re.\n  remove trailing whitespace.\n\n- removed reference to missing version section from buildout.\n\n2.12.7 (2012-08-11)\n-------------------\n\n- added forward compatibility with datetime 3 pickle format. datetime\n  instances constructed under version 3 can be read and unpickled by this\n  version. the pickled data is converted to the current versions format\n  (old-style class / no slots). once converted it will be stored again in the\n  old format. this should allow for a transparent upgrade/downgrade path\n  between datetime 2 and 3.\n\n2.12.6 (2010-10-17)\n-------------------\n\n- changed ``testdayofweek`` test to be independent of os locale.\n\n2.12.5 (2010-07-29)\n-------------------\n\n- launchpad #143269: corrected the documentation for year value\n  behavior when constructing a datetime object with three numeric\n  arguments.\n\n- launchpad #142521: removed confusing special case in\n  datetime.__str__ where datetime instances for midnight\n  (e.g. '2010-07-27 00:00:00 us/eastern') values would\n  render only their date and nothing else.\n\n2.12.4 (2010-07-12)\n-------------------\n\n- fixed mapping of edt (was -> 'gmt-0400', now 'gmt-4').\n\n2.12.3 (2010-07-09)\n-------------------\n\n- added edt timezone support. addresses bug #599856.\n  [vangheem]\n\n2.12.2 (2010-05-05)\n-------------------\n\n- launchpad #572715:  relaxed pin on pytz, after applying a patch from\n  marius gedminus which fixes the apparent api breakage.\n\n2.12.1 (2010-04-30)\n-------------------\n\n- removed an undeclared testing dependency on zope.testing.doctest in favor of\n  the standard libraries doctest module.\n\n- added a maximum version requirement on pytz <= 2010b. later versions produce\n  test failures related to timezone changes.\n\n2.12.0 (2009-03-04)\n-------------------\n\n- launchpad #290254: forward-ported fix for '_micros'-less pickles from\n  the zope 2.11 branch version.\n\n2.11.2 (2009-02-02)\n-------------------\n\n- include *all* pytz zone names, not just \"common\" ones.\n\n- fix one fragile doctest, band-aid another.\n\n- fix for launchpad #267545: datetime(datetime()) should preserve the\n  correct hour.\n\n2.11.1 (2008-08-05)\n-------------------\n\n- datetime conversion of datetime objects with non-pytz tzinfo. timezones()\n  returns a copy of the timezone list (allows tests to run).\n\n- merged the slinkp-datetime-200007 branch: fix the datetime(anotherdatetime)\n  constructor to preserve timezones.\n\n2.11.0b1 (2008-01-06)\n---------------------\n\n- split off from the zope2 main source code tree.\n",
  "docs_url": null,
  "keywords": "",
  "license": "zpl 2.1",
  "name": "datetime",
  "package_url": "https://pypi.org/project/DateTime/",
  "project_url": "https://pypi.org/project/DateTime/",
  "project_urls": {
    "Homepage": "https://github.com/zopefoundation/DateTime"
  },
  "release_url": "https://pypi.org/project/DateTime/5.4/",
  "requires_dist": [
    "zope.interface",
    "pytz"
  ],
  "requires_python": ">=3.7",
  "summary": "this package provides a datetime data type, as known from zope. unless you need to communicate with zope apis, you're probably better off using python's built-in datetime module.",
  "version": "5.4",
  "releases": [],
  "developers": [
    "zope-dev@zope.org",
    "zope_foundation_and_contributors"
  ],
  "kwds": "test_datetime datetime datetimeerror datetimes strftimeformatter",
  "license_kwds": "zpl 2.1",
  "libtype": "pypi",
  "id": "pypi_datetime",
  "homepage": "https://github.com/zopefoundation/datetime",
  "release_count": 38,
  "dependency_ids": [
    "pypi_pytz",
    "pypi_zope.interface"
  ]
}