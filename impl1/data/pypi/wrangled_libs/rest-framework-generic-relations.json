{
  "classifiers": [
    "environment :: web environment",
    "framework :: django",
    "intended audience :: developers",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "# rest framework generic relations [![build status](https://github.com/ian-foote/rest-framework-generic-relations/actions/workflows/tests.yml/badge.svg)](https://github.com/ian-foote/rest-framework-generic-relations/actions/workflows/tests.yml)\n\n\nthis library implements [django rest framework](http://www.django-rest-framework.org/) serializers to handle generic foreign keys.\n\n# requirements\n\nany currently-supported combination of django rest framework, python, and django.\n\n# installation\n\ninstall using `pip`...\n```sh\npip install  rest-framework-generic-relations\n```\nadd `'generic_relations'` to your `installed_apps` setting.\n```python\ninstalled_apps = (\n    ...\n    'generic_relations',\n)\n```\n\n\n# api reference\n\n## genericrelatedfield\n\nthis field serializes generic foreign keys. for a primer on generic foreign keys, first see: https://docs.djangoproject.com/en/dev/ref/contrib/contenttypes/\n\n\nlet's assume a `taggeditem` model which has a generic relationship with other arbitrary models:\n\n```python\nclass taggeditem(models.model):\n    tag_name = models.slugfield()\n    content_type = models.foreignkey(contenttype, on_delete=models.cascade)\n    object_id = models.positiveintegerfield()\n    tagged_object = genericforeignkey('content_type', 'object_id')\n```\n\nand the following two models, which may have associated tags:\n\n```python\nclass bookmark(models.model):\n    \"\"\"\n    a bookmark consists of a url, and 0 or more descriptive tags.\n    \"\"\"\n    url = models.urlfield()\n    tags = genericrelation(taggeditem)\n\nclass note(models.model):\n    \"\"\"\n    a note consists of some text, and 0 or more descriptive tags.\n    \"\"\"\n    text = models.charfield(max_length=1000)\n    tags = genericrelation(taggeditem)\n```\n\nnow we define serializers for each model that may get associated with tags.\n\n```python\nclass bookmarkserializer(serializers.modelserializer):\n    class meta:\n        model = bookmark\n        fields = ('url',)\n\nclass noteserializer(serializers.modelserializer):\n    class meta:\n        model = note\n        fields = ('text',)\n```\n\nthe model serializer for the `taggeditem` model could look like this:\n\n```python\nfrom generic_relations.relations import genericrelatedfield\n\nclass tagserializer(serializers.modelserializer):\n    \"\"\"\n    a `taggeditem` serializer with a `genericrelatedfield` mapping all possible\n    models to their respective serializers.\n    \"\"\"\n    tagged_object = genericrelatedfield({\n        bookmark: bookmarkserializer(),\n        note: noteserializer()\n    })\n\n    class meta:\n        model = taggeditem\n        fields = ('tag_name', 'tagged_object')\n```\n\nthe json representation of a `taggeditem` object with `name='django'` and its generic foreign key pointing at a `bookmark` object with `url='https://www.djangoproject.com/'` would look like this:\n\n```json\n{\n    \"tagged_object\": {\n        \"url\": \"https://www.djangoproject.com/\"\n    },\n    \"tag_name\": \"django\"\n}\n```\n\nif you want to have your generic foreign key represented as hyperlink, simply use `hyperlinkedrelatedfield` objects:\n\n```python\nclass tagserializer(serializers.modelserializer):\n    \"\"\"\n    a `tag` serializer with a `genericrelatedfield` mapping all possible\n    models to properly set up `hyperlinkedrelatedfield`s.\n    \"\"\"\n    tagged_object = genericrelatedfield({\n        bookmark: serializers.hyperlinkedrelatedfield(\n            queryset = bookmark.objects.all(),\n            view_name='bookmark-detail',\n        ),\n        note: serializers.hyperlinkedrelatedfield(\n            queryset = note.objects.all(),\n            view_name='note-detail',\n        ),\n    })\n\n    class meta:\n        model = taggeditem\n        fields = ('tag_name', 'tagged_object')\n```\n\nthe json representation of the same `taggeditem` example object could now look something like this:\n\n```json\n{\n    \"tagged_object\": \"/bookmark/1/\",\n    \"tag_name\": \"django\"\n}\n```\n\n## writing to generic foreign keys\n\nthe above `tagserializer` is also writable. by default, a `genericrelatedfield` iterates over its nested serializers and returns the value of the first serializer that is actually able to perform `to_internal_value()` without any errors.\nnote, that (at the moment) only `hyperlinkedrelatedfield` is able to serialize model objects out of the box.\n\n\nthe following operations would create a `taggeditem` object with it's `tagged_object` property pointing at the `bookmark` object found at the given detail end point.\n\n```python\ntag_serializer = tagserializer(data={\n    'tag_name': 'python',\n    'tagged_object': '/bookmark/1/'\n})\n\ntag_serializer.is_valid()\ntag_serializer.save()\n```\n\nif you feel that this default behavior doesn't suit your needs, you can subclass `genericrelatedfield` and override its `get_serializer_for_instance` or `get_deserializer_for_data` respectively to implement your own way of decision-making.\n\n## genericmodelserializer\n\nsometimes you may want to serialize a single list of different top-level things. for instance, suppose i have an api view that returns what items are on my bookshelf. let's define some models:\n\n```python\nfrom django.core.validators import maxvaluevalidator\n\nclass book(models.model):\n    title = models.charfield(max_length=255)\n    author = models.charfield(max_length=255)\n\nclass bluray(models.model):\n    title = models.charfield(max_length=255)\n    rating = models.positivesmallintegerfield(\n        validators=[maxvaluevalidator(5)],\n    )\n```\n\nthen we could have a serializer for each type of object:\n\n```python\nclass bookserializer(serializers.modelserializer):\n    class meta:\n        model = book\n        fields = ('title', 'author')\n\nclass blurayserializer(serializers.modelserializer):\n    class meta:\n        model = bluray\n        fields = ('title', 'rating')\n```\n\nnow we can create a generic list serializer, which delegates to the above serializers based on the type of model it's serializing:\n\n```python\nbookshelf_item_serializer = genericmodelserializer(\n    {\n        book: bookserializer(),\n        bluray: blurayserializer(),\n    },\n    many=true,\n)\n```\n\nthen we can serialize a mixed list of items:\n\n```python\n>>> bookshelf_item_serializer.to_representation([\n    book.objects.get(title='war and peace'),\n    bluray.objects.get(title='die hard'),\n    bluray.objects.get(title='shawshank redemption'),\n    book.objects.get(title='to kill a mockingbird'),\n])\n\n[\n    {'title': 'war and peace', 'author': 'leo tolstoy'},\n    {'title': 'die hard', 'rating': 5},\n    {'title': 'shawshank redemption', 'rating': 5},\n    {'title': 'to kill a mockingbird', 'author': 'harper lee'}\n]\n```\n\n\n## a few things you should note:\n\n* although `genericforeignkey` fields can be set to any model object, the `genericrelatedfield` only handles models explicitly defined in its configuration dictionary.\n* reverse generic keys, expressed using the `genericrelation` field, can be serialized using the regular relational field types, since the type of the target in the relationship is always known.\n* the order in which you register serializers matters as far as write operations are concerned.\n* unless you provide a custom `get_deserializer_for_data()` method, only `hyperlinkedrelatedfield` provides write access to generic model relations.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "rest-framework-generic-relations",
  "package_url": "https://pypi.org/project/rest-framework-generic-relations/",
  "project_url": "https://pypi.org/project/rest-framework-generic-relations/",
  "project_urls": {
    "Homepage": "https://github.com/Ian-Foote/rest-framework-generic-relations"
  },
  "release_url": "https://pypi.org/project/rest-framework-generic-relations/2.1.0/",
  "requires_dist": [
    "djangorestframework (>=3.11.0)"
  ],
  "requires_python": ">=3.6",
  "summary": "generic relations for django rest framework",
  "version": "2.1.0",
  "releases": [],
  "developers": [
    "ian_foote",
    "python@ian.feete.org"
  ],
  "kwds": "generic_relations django foreignkey genericrelatedfield djangoproject",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_rest_framework_generic_relations",
  "homepage": "https://github.com/ian-foote/rest-framework-generic-relations",
  "release_count": 8,
  "dependency_ids": [
    "pypi_djangorestframework"
  ]
}