{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "license :: osi approved :: isc license (iscl)",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "# yaml path and command-line tools\n\n[![build](https://github.com/wwkimball/yamlpath/actions/workflows/build.yml/badge.svg)](https://github.com/wwkimball/yamlpath/actions/workflows/build.yml)\n[![python versions](https://img.shields.io/pypi/pyversions/yamlpath.svg)](https://pypi.org/project/yamlpath/)\n[![pypi version](https://badge.fury.io/py/yamlpath.svg)](https://pypi.org/project/yamlpath/)\n[![downloads](https://pepy.tech/badge/yamlpath)](https://pepy.tech/project/yamlpath)\n[![coverage status](https://coveralls.io/repos/github/wwkimball/yamlpath/badge.svg?branch=master)](https://coveralls.io/github/wwkimball/yamlpath?branch=master)\n[![codacy badge](https://app.codacy.com/project/badge/grade/b146b032a098413cbc2825cdf73fd7b2)](https://www.codacy.com/gh/wwkimball/yamlpath/dashboard?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=wwkimball/yamlpath&amp;utm_campaign=badge_grade)\n\nalong with providing a\n[standard for defining yaml paths](https://github.com/wwkimball/yamlpath/wiki/segments-of-a-yaml-path),\nthis project aims to provide\n[generally-useful command-line tools](https://github.com/wwkimball/yamlpath/wiki/command-line-(cli)-tools)\nwhich implement yaml paths.  these bring intuitive yaml, eyaml, json, and\ncompatible data parsing and editing capabilties to the command-line.  it is\nalso a\n[python library](https://github.com/wwkimball/yamlpath/wiki/python-library)\nfor other projects to readily employ yaml paths.\n\n## contents\n\n1. [introduction](#introduction)\n2. [illustration](#illustration)\n3. [supported yaml path segments](#supported-yaml-path-segments)\n4. [installing](#installing)\n   1. [requirements](#requirements)\n   2. [using pip](#using-pip)\n      1. [very old versions of pip or its setuptools dependency](#very-old-versions-of-pip-or-its-setuptools-dependency)\n   3. [installing eyaml (optional)](#installing-eyaml-optional)\n5. [based on ruamel.yaml](#based-on-ruamelyaml)\n6. [the files of this project](#the-files-of-this-project)\n   1. [command-line tools](#command-line-tools)\n   2. [libraries](#libraries)\n7. [basic usage](#basic-usage)\n   1. [basic usage:  command-line tools](#basic-usage--command-line-tools)\n      1. [rotate your eyaml keys](#rotate-your-eyaml-keys)\n      2. [get the differences between two documents](#get-the-differences-between-two-documents)\n      3. [get a yaml/json/compatible value](#get-a-yamljsoncompatible-value)\n      4. [search for yaml paths](#search-for-yaml-paths)\n      5. [change a yaml/json/compatible value](#change-a-yamljsoncompatible-value)\n      6. [merge yaml/json/compatible files](#merge-yamljsoncompatible-files)\n      7. [validate yaml/json/compatible documents](#validate-yamljsoncompatible-documents)\n\n   2. [basic usage:  libraries](#basic-usage--libraries)\n      1. [initialize ruamel.yaml and these helpers](#initialize-ruamelyaml-and-these-helpers)\n      2. [searching for yaml nodes](#searching-for-yaml-nodes)\n      3. [changing values](#changing-values)\n      4. [merging documents](#merging-documents)\n\n## introduction\n\nthis project presents and utilizes yaml paths, which are a powerful, intuitive\nmeans of identifying one *or more* nodes within [yaml](https://yaml.org/),\n[eyaml](https://github.com/voxpupuli/hiera-eyaml), or compatible data structures\nlike [json](https://www.json.org/).  both dot-notation (inspired by\n[hiera](https://github.com/puppetlabs/hiera)) and forward-slash-notation\n(influenced by [xpath](https://www.w3schools.com/xml/xml_xpath.asp)) are\nsupported.  the [libraries](#libraries) (modules) and several [command-line tool\nimplementations](#command-line-tools) are provided.  with these, you can build\nyaml path support right into your own application or easily use its capabilities\nright away from the command-line to retrieve, update, merge, validate, and scan\nyaml/json/compatible data.\n\nthis implementation of yaml path is a *query language* in addition to a *node\ndescriptor*.  with it, you can describe or select a single precise node or\nsearch for any number of nodes that match some criteria.  keys, values,\nelements, anchors, and aliases can all be searched at any number of levels\nwithin the data structure using the same query.  collectors can also be used to\ngather and further select from otherwise disparate parts of the source data.\n\nthe [project wiki](https://github.com/wwkimball/yamlpath/wiki) provides a\ndeeper dive into these concepts.\n\n## illustration\n\nto illustrate some of these concepts, consider these samples:\n\n```yaml\n---\nhash:\n  child_attr:\n    key: 5280\n```\n\nthis value, `5280`, can be identified via yaml path as any of:\n\n1. `hash.child_attr.key` (dot-notation)\n2. `hash.child_attr[.=key]` (search all child keys for one named, `key`, and\n   yield its value)\n3. `/hash/child_attr/key` (same as 1 but in forward-slash notation)\n4. `/hash/child_attr[.=key]` (same as 2 but in forward-slash notation)\n\n```yaml\n---\naliases:\n  - &first_anchor simple string value\n```\n\nwith yaml path, you can select this anchored value by any of these equivalent\nexpressions:\n\n1. `aliases[0]` (explicit array element number)\n2. `aliases.0` (implicit array element number in dot-notation)\n3. `aliases[&first_anchor]` (search by anchor name)\n4. `aliases[.^simple]` (search for any elements starting with \"simple\")\n5. `aliases[.%string]` (search for any elements containing \"string\")\n6. `aliases[.$value]` (search for any elements ending with \"value\")\n7. `aliases[.=~/^(\\b[ss][a-z]+\\s){2}[a-z]+$/]` (search for any elements matching\n   a complex python regular expression, which happens to match the example)\n8. `/aliases[0]` (same as 1 but in forward-slash notation)\n9. `/aliases/0` (same as 2 but in forward-slash notation)\n10. `/aliases[&first_anchor]` (same as 3 but in forward-slash notation)\n\n```yaml\n---\nusers:\n  - name: user one\n    password: enc[pkcs7,miibiqy...jk==]\n    roles:\n      - writers\n  - name: user two\n    password: enc[pkcs7,miibiqy...vf==]\n    roles:\n      - power users\n      - editors\n```\n\nwith an example like this, yaml path enables:\n\n* selection of single nodes: `/users/0/roles/0` = `writers`\n* all children nodes of any given parent: `/users/1/roles` =\n  `[\"power users\", \"editors\"]`\n* searching by a child attribute: `/users[name=\"user one\"]/password` =\n  `some decrypted value, provided you have the appropriate eyaml keys`\n* pass-through selections against arrays-of-hashes: `/users/roles` =\n  `[\"writers\"]\\n[\"power users\", \"editors\"]` (each user's list of roles are a\n  separate result)\n* collection of disparate results: `(/users/name)` =\n  `[\"user one\", \"user two\"]` (all names appear in a single result instead of\n  one per line)\n\nfor a deeper exploration of yaml path's capabilities, please visit the\n[project wiki](https://github.com/wwkimball/yamlpath/wiki).\n\n## supported yaml path segments\n\na yaml path *segment* is the text between separators which identifies zero or\nmore parent or leaf nodes within the data structure.  for dot-notation, a path\nlike `hash.key` identifies two segments:  `hash` (a parent node) and `key` (a\nleaf node).  the same path in forward-slash notation would be:  `/hash/key`.\n\nyaml path understands these segment types:\n\n* top-level hash key selection: `key`\n* explicit top-level array element selection: `[#]` where `#` is the zero-based\n  element number; `#` can also be negative, causing the element to be selected\n  from the end of the array\n* implicit array element selection **or** numbered hash key selection: `#`\n  where `#` is the 0-based element number **or** exact name of a hash key which\n  is itself a number\n* top-level (hash) anchor lookups: `&anchor_name` (the `&` is required to\n  indicate you are seeking an anchor by name)\n* hash sub-keys:  `hash.child.key` or `/hash/child/key`\n* demarcation for dotted hash keys:  `hash.'dotted.child.key'` or\n  `hash.\"dotted.child.key\"` (not necessary when using forward-slash notation,\n  `/hash/dotted.child.key`)\n* named array element selection:  `array[#]`, `array.#`, `/array[#]`, or\n  `/array/#` where `array` is the name of the hash key containing array data\n  and `#` is the 0-based element number\n* anchor lookups in named arrays:  `array[&anchor_name]`  where `array` is the\n  name of the hash key containing array data and both of the `[]` pair and `&`\n  are required to indicate you are seeking an anchor by name within an array\n* array slicing: `array[start#:stop#]` where `start#` is the first inclusive,\n  zero-based element and `stop#` is the last exclusive element to select;\n  either or both can be negative, causing the elements to be selected from the\n  end of the array; when `start#` and `stop#` are identical, it is the same as\n  `array[start#]`\n* hash slicing: `hash[min:max]` where `min` and `max` are alphanumeric terms\n  between which the hash's keys are compared\n* escape symbol recognition:  `hash.dotted\\.child\\.key`,\n  `/hash/whacked\\/child\\/key`, and `keys_with_\\\\slashes`\n* hash attribute searches (which can return zero or more matches):\n  * exact match:  `hash[name=admin]`\n  * starts with match:  `hash[name^adm]`\n  * ends with match:  `hash[name$min]`\n  * contains match:  `hash[name%dmi]`\n  * less than match: `hash[access_level<500]`\n  * greater than match: `hash[access_level>0]`\n  * less than or equal match: `hash[access_level<=100]`\n  * greater than or equal match: `hash[access_level>=0]`\n  * [python regular expression](https://docs.python.org/3/library/re.html)\n    matches: `hash[access_level=~/^\\d+$/]` (the `/` regular\n    expression delimiter can be substituted for any character you need, except\n    white-space; note that `/` does not interfere with forward-slash notation\n    *and it does not need to be escaped* because the entire search expression is\n    contained within a `[]` pair)\n  * invert any match with `!`, like: `hash[name!=admin]` or even\n    `hash[!name=admin]` (the former syntax is used when yaml paths are\n    stringified but both forms are equivalent)\n  * demarcate and/or escape expression operands, like:\n    `hash[full\\ name=\"some user\\'s name\"]` (note that embedded, single `'` and\n    `\"` must be escaped lest they be deemed unmatched demarcation pairings)\n  * multi-level matching: `hash[name%admin].pass[encrypted!^enc\\[]` or\n    `/hash[name%admin]/pass[encrypted!^enc\\[]`\n  * descendent node searches:\n    `structure[has.descendant.with=something].has.another.field` or\n    `/structure[/has/descendant/with=something]/has/another/field`\n* array element searches with all of the search methods above via `.` (yields\n  any matching elements): `array[.>9000]`\n* hash key-name searches with all of the search methods above via `.` (yields\n  their values, not the keys themselves): `hash[.^app_]`\n* array-of-hashes pass-through selection:  omit a selector for the elements of\n  an array-of-hashes and all matching hash attributes at that level will be\n  yielded (or searched when there is more to the path).  for example,\n  `warriors[1].power_level` or `/warriors[1]/power_level` will return the\n  power_level attribute of only the second hash in an array-of-hashes while\n  `warriors.power_level` or `/warriors/power_level` will return the power_level\n  attribute of every hash in the same array-of-hashes.  of course these results\n  can be filtered in multiple ways, like `warriors[power_level>9000]`,\n  `/warriors[power_level>9000]`, `warriors.power_level[.>9000]`, and\n  `/warriors/power_level[.>9000]` all yield only the power_level from *all*\n  warriors with power_levels over 9,000 within the same array of warrior hashes.\n* unordered set value accessing and searching with all above search methods.\n* wildcard searches: the `*` symbol can be used as shorthand for the `[]`\n  search operator against text keys and values: `/warriors/name/go*`; it also\n  returns every immediate child, regardless its key or value.\n* deep traversals:  the `**` symbol pair deeply traverses the document:\n  * when it is the last or only segment of a yaml path, it selects every leaf\n    node from the remainder of the document's tree: `/shows/**`\n  * when another segment follows, it matches every node within the remainder\n    of the document's tree for which the following (and subsequent) segments\n    match: `/shows/**/name/star*`\n* search keywords:  advanced search capabilities not otherwise possible using\n  other yaml path segments.  taking the form of `[keyword(parameters)]`, these\n  keywords are\n  [deeply explored on the wiki](https://github.com/wwkimball/yamlpath/wiki/search-keywords)\n  and include:\n  * `[distinct(name)]`: match exactly one of every value within collections,\n    discarding duplicates; i.e.:  [1, 2, 2, 3] has distinct values, [1, 2, 3]\n  * `[has_child(name)]`: match nodes having a named child key\n  * `[max([name])]`: match nodes having the maximum value\n  * `[min([name])]`: match nodes having the minimum value\n  * `[name()]`: match only the name of the present node, discarding all\n    children\n  * `[parent([steps])]`, step up 1-n levels in the document from the present\n    node\n  * `[unique(name)]`: match only values which have no duplicates within\n    collections; i.e.:  [1, 2, 2, 3] has unique values, [1, 3]\n* collectors:  placing any portion of the yaml path within parenthesis defines a\n  virtual list collector, like `(yaml path)`; concatenation, exclusion, and\n  intersection operators are supported -- `+`, `-`, and `&`, respectively --\n  along with nesting, like `(...)-((...)+(...))&(...)`\n* complex combinations:\n  `some::deep.hierarchy[with!=\"\"].'any.valid'[.=~/(yaml|json)/][data%structure].or.complexity[4].2`\n  or `/some::deep/hierarchy[with!=\"\"]/any*.*valid[.=~/(yaml|json)/][data%structure]/or/compl*xity[4]/2/**`\n\nthis implementation of yaml path encourages creativity.  use whichever notation\nand segment types that make the most sense to you in each application.\n\nthe [project wiki provides more illustrative details of yaml path segments](https://github.com/wwkimball/yamlpath/wiki/segments-of-a-yaml-path).\n\n## installing\n\nsome os distributions offer some versions of yamlpath -- and its dependencies\n-- via packages.  while these versions of yamlpath are often outdated, they can\nbe convenient to install using your os' native package manager (`apt`, `yum`,\n`npm`, and such).  otherwise, python's own package manager `pip` will always\noffer the latest version of yamlpath and -- even better -- can be isolated to\nephemeral or longer-lasting virtual python environments.\n\n### requirements\n\nthis project requires [python](https://www.python.org/) 3.  it is rigorously\ntested against pythons 3.6 through 3.11.  most operating systems and\ndistributions have access to python 3 even if only python 2 -- or no python, at\nall -- came pre-installed.  it is generally safe to have more than one version\nof python on your system at the same time, especially when using\n[virtual python environments](https://docs.python.org/3/library/venv.html).\n\n*yamlpath* depends on *ruamel.yaml* (derived from and greatly extending pyyaml)\nand *python-dateutil*.  when using os-native packages or `pip`, you do not need\nto pre-install these libraries yourself except under extraordinary\ncircumstances like using very old versions of `pip` or its own dependency,\n*setuptools*.\n\n### using pip\n\nlike most others, this python project is published to [pypi](https://pypi.org/)\nso that it can be easily installed via python's `pip` command (or its\nversion-specific `pip3`, `pip3.7`, and such depending on how your python was\ninstalled).\n\npython's `pip` command is ever-changing.  it is updated very frequently.  this\ncommand further depends on other libraries to do its job, namely *setuptools*.\nit so happens that *setuptools* is also updated very frequently.  both of these\nare separate from python itself, despite versions of them being pre-installed\nwith python.  it is your responsibility to keep `pip` and *setuptools*\nup-to-date.  when `pip` or *setuptools* become outdated, _you will experience\nerrors_ when trying to install newer python packages like *yamlpath* **unless\nyou preinstall such packages' dependencies**.  in the case of *yamlpath*, this\nmeans you'd need to preinstall *ruamel.yaml* and *python-dateutil* if you\ncannot or choose not to upgrade `pip` and/or *setuptools*.\n\nas long as your `pip` and *setuptools* are up-to-date, installing *yamlpath* is\nas simple as a single command (the \"3.7\" suffix to the `pip` command is\noptional, depending on how your python 3 was installed):\n\n```shell\npip3.7 install yamlpath\n```\n\n#### very old versions of pip or its setuptools dependency\n\nvery old versions of python 3 ship with seriously outdated versions of `pip` and\nits *setuptools* dependency.  when using versions of `pip` older than **18.1**\nor *setuptools* older than version **46.4.0**, you will not be able to install\n*yamlpath* with a single command.  in this case, you have two options:  either\npre-install *ruamel.yaml* and *python-dateutil* before installing *yamlpath* or\nupdate `pip` and/or *setuptools* to at least the minimum required versions so\n`pip` can auto-determine and install dependencies.  this issue is not unique to\n*yamlpath*.\n\nupgrading `pip` and *setuptools* is trivially simple as long as you have\nsufficient access rights to do so on your local machine.  depending on your\nsituation, you may need to prefix these with `sudo` and/or you may need to\nsubstitute `python3` and `pip3` for `python` and `pip`, or even `python3.7` and\n`pip3.7` (or another specific version of python 3), respectively.  to reiterate\nthat this project requires python 3, these sample commands will be\ndemonstrated using such prefixes:\n\n```shell\npython3.7 -m pip install --upgrade pip\npip3.7 install --upgrade setuptools\n```\n\nwhen you cannot or will not update `pip` or *setuptools*, just pre-install\n*ruamel.yaml* and *python-dateutil* before yamlpath.  each must be installed\nseparately and in order, like this (you **cannot** combine these installations\ninto a single command):\n\n```shell\npip3.7 install ruamel.yaml python-dateutil\npip3.7 install yamlpath\n```\n\nthe downside to choosing this manual installation path is that you may end up\nwith an incompatible version of *ruamel.yaml* or *python-dateutil*.  this will\nmanifest either as an inability to install *yamlpath* at all, or only certain\nversions of *yamlpath*, or *yamlpath* may experience unexpected errors caused\nby the incompatible code.  for the best experience, you are strongly encouraged\nto just keep `pip` and *setuptools* up-to-date, particularly as a routine part\nof installing any new python packages.\n\n### installing eyaml (optional)\n\neyaml support is entirely optional.  you do not need eyaml to use yaml path.\nthat yaml path supports eyaml is a service to a substantial audience:  puppet\nusers.  at the time of this writing, eyaml (classified as a hiera\nback-end/plug-in) is available only as a ruby gem.  that said, it provides a\ncommand-line tool, `eyaml`, which can be employed by this otherwise python\nproject.  to enjoy eyaml support, install compatible versions of ruby and\nrubygems, then execute:\n\n```shell\ngem install hiera-eyaml\n```\n\nif this puts the `eyaml` command on your system `path`, nothing more need be\ndone apart from generating or obtaining your encryption keys.  otherwise, you\ncan tell yaml path library and tools where to find the `eyaml` command.\n\n## based on ruamel.yaml\n\nin order to support the best available yaml editing capability (so called,\nround-trip editing with support for comment preservation), this project is based\non [ruamel.yaml](https://sourceforge.net/projects/ruamel-yaml/) for\npython 3.  while ruamel.yaml is based on pyyaml --\npython's \"standard\" yaml library -- ruamel.yaml is [objectively better than\npyyaml](https://yaml.readthedocs.io/en/latest/pyyaml.html), which lacks critical\nround-trip editing capabilities as well as up-to-date yaml/compatible data\nparsing capabilities (at the time of this writing).\n\nshould pyyaml ever merge with -- or at least, catch up with -- ruamel.yaml, this\nproject can be (lightly) adapted to depend on it, instead.  these conversations\nmay offer some insight into when or whether this might happen:\n\n* [is this time to pass the baton?](https://github.com/yaml/pyyaml/issues/31)\n* [rebase off ruamel? - many new valuable features](https://github.com/yaml/pyyaml/issues/46)\n\n## the files of this project\n\nthis repository contains:\n\n1. generally-useful python library files.  these contain the reusable core of\n   this project's yaml path capabilities.\n2. some implementations of those libraries, exhibiting their capabilities and\n   simple-to-use apis as command-line tools.\n3. various support, documentation, and build files.\n\n### command-line tools\n\nthis project provides some command-line tool implementations which utilize yaml\npath.  for some use-case examples of these tools,\n[see below](#basic-usage--command-line-tools).\n\nthe supplied command-line tools include:\n\n* [eyaml-rotate-keys](yamlpath/commands/eyaml_rotate_keys.py)\n\n```text\nusage: eyaml-rotate-keys [-h] [-v] [-d | -v | -q] [-b] [-x eyaml]\n                         -i oldprivatekey -c oldpublickey\n                         -r newprivatekey -u newpublickey\n                         yaml_file [yaml_file ...]\n\nrotates the encryption keys used for all eyaml values within a set of yaml\nfiles, decrypting with old keys and re-encrypting using replacement keys.\n\npositional arguments:\n  yaml_file             one or more yaml files containing eyaml values\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n  -b, --backup          save a backup of each modified yaml_file with an extra\n                        .bak file-extension\n  -x eyaml, --eyaml eyaml\n                        the eyaml binary to use when it isn't on the path\n\neyaml_keys:\n  all key arguments are required\n\n  -r newprivatekey, --newprivatekey newprivatekey\n                        the new eyaml private key\n  -u newpublickey, --newpublickey newpublickey\n                        the new eyaml public key\n  -i oldprivatekey, --oldprivatekey oldprivatekey\n                        the old eyaml private key\n  -c oldpublickey, --oldpublickey oldpublickey\n                        the old eyaml public key\n\nany yaml_files lacking eyaml values will not be modified (or backed up, even\nwhen -b/--backup is specified).\n```\n\n* [yaml-diff](yamlpath/commands/yaml_diff.py)\n\n```text\nusage: yaml-diff [-h] [-v] [-a] [-s | -o]\n                 [-t ['.', '/', 'auto', 'dot', 'fslash']] [-x eyaml]\n                 [-r privatekey] [-u publickey] [-e] [-d | -v | -q]\n                 yaml_file yaml_file\n\ncalculate the functional difference between two yaml/json/compatible\ndocuments. immaterial differences (which yaml/json parsers discard) are\nignored. eyaml can be employed to compare encrypted values.\n\npositional arguments:\n  yaml_file             exactly two yaml/json/compatible files to compare; use\n                        - to read one document from stdin\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -a, --sync-arrays     synchronize array elements before comparing them,\n                        resulting only in add, delete, and same differences\n                        (no changes because the positions of elements are\n                        disregarded); array-of-hash elements must completely\n                        and perfectly match or they will be deemed additions\n                        or deletions\n  -s, --same            show all nodes which are the same in addition to\n                        differences\n  -o, --onlysame        show only nodes which are the same, still reporting\n                        that differences exist -- when they do -- with an\n                        exit-state of 1\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which yaml path separator to use when\n                        rendering results; default=dot\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except system errors\n\neyaml options:\n  left unset, the eyaml keys will default to your system or user defaults.\n  both keys must be set either here or in your system or user eyaml\n  configuration file when using eyaml.\n\n  -x eyaml, --eyaml eyaml\n                        the eyaml binary to use when it isn't on the path\n  -r privatekey, --privatekey privatekey\n                        eyaml private key\n  -u publickey, --publickey publickey\n                        eyaml public key\n  -e, --ignore-eyaml-values\n                        do not use eyaml to compare encrypted data; rather,\n                        treat enc[...] values as regular strings\n\nonly one yaml_file may be the - pseudo-file for reading from stdin. for more\ninformation about yaml paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n```\n\n* [yaml-get](yamlpath/commands/yaml_get.py)\n\n```text\nusage: yaml-get [-h] [-v] -p yaml_path\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-s] [-x eyaml]\n                [-r privatekey] [-u publickey] [-d | -v | -q]\n                [yaml_file]\n\nretrieves one or more values from a yaml/json/compatible file at a specified\nyaml path. output is printed to stdout, one line per result. when a result is\na complex data-type (array or hash), a json dump is produced to represent it.\neyaml can be employed to decrypt the values.\n\npositional arguments:\n  yaml_file             the yaml file to query; omit or use - to read from\n                        stdin\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which yaml path separator to use when\n                        rendering results; default=dot\n  -s, --nostdin         do not implicitly read from stdin, even when yaml_file\n                        is not set and the session is non-tty\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -p yaml_path, --query yaml_path\n                        yaml path to query\n\neyaml options:\n  left unset, the eyaml keys will default to your system or user defaults.\n  both keys must be set either here or in your system or user eyaml\n  configuration file when using eyaml.\n\n  -x eyaml, --eyaml eyaml\n                        the eyaml binary to use when it isn't on the path\n  -r privatekey, --privatekey privatekey\n                        eyaml private key\n  -u publickey, --publickey publickey\n                        eyaml public key\n\nfor more information about yaml paths, please visit\nhttps://github.com/wwkimball/yamlpath.\n```\n\n* [yaml-merge](yamlpath/commands/yaml_merge.py)\n\n```text\nusage: yaml-merge [-h] [-v] [-c config] [-a {stop,left,right,rename}]\n                  [-a {all,left,right,unique}] [-h {deep,left,right}]\n                  [-o {all,deep,left,right,unique}] [-m yaml_path]\n                  [-o output | -w overwrite] [-b] [-d {auto,json,yaml}] [-s]\n                  [-d | -v | -q]\n                  [yaml_file [yaml_file ...]]\n\nmerges two or more yaml/json/compatible files together.\n\npositional arguments:\n  yaml_file             one or more yaml files to merge, order-significant;\n                        omit or use - to read from stdin\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -c config, --config config\n                        ini syle configuration file for yaml path specified\n                        merge control options\n  -a {stop,left,right,rename}, --anchors {stop,left,right,rename}\n                        means by which anchor name conflicts are resolved\n                        (overrides [defaults]anchors set via --config|-c and\n                        cannot be overridden by [rules] because anchors apply\n                        to the whole file); default=stop\n  -a {all,left,right,unique}, --arrays {all,left,right,unique}\n                        default means by which arrays are merged together\n                        (overrides [defaults]arrays but is overridden on a\n                        yaml path basis via --config|-c); default=all\n  -h {deep,left,right}, --hashes {deep,left,right}\n                        default means by which hashes are merged together\n                        (overrides [defaults]hashes but is overridden on a\n                        yaml path basis in [rules] set via --config|-c);\n                        default=deep\n  -o {all,deep,left,right,unique}, --aoh {all,deep,left,right,unique}\n                        default means by which arrays-of-hashes are merged\n                        together (overrides [defaults]aoh but is overridden on\n                        a yaml path basis in [rules] set via --config|-c);\n                        default=all\n  -m yaml_path, --mergeat yaml_path\n                        yaml path indicating where in left yaml_file the right\n                        yaml_file content is to be merged; default=/\n  -o output, --output output\n                        write the merged result to the indicated nonexistent\n                        file\n  -w overwrite, --overwrite overwrite\n                        write the merged result to the indicated file; will\n                        replace the file when it already exists\n  -b, --backup          save a backup overwrite file with an extra .bak\n                        file-extension; applies only to overwrite\n  -d {auto,json,yaml}, --document-format {auto,json,yaml}\n                        force the merged result to be presented in one of the\n                        supported formats or let it automatically match the\n                        known file-name extension of output|overwrite (when\n                        provided), or match the type of the first document;\n                        default=auto\n  -s, --nostdin         do not implicitly read from stdin, even when there are\n                        no - pseudo-files in yaml_files with a non-tty session\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors (implied when\n                        -o|--output is not set)\n\n            the config file is an ini file with up to three sections:\n            [defaults] sets equivalents of -a|--anchors, -a|--arrays,\n                       -h|--hashes, and -o|--aoh.\n            [rules]    each entry is a yaml path assigning -a|--arrays,\n                       -h|--hashes, or -o|--aoh for precise nodes.\n            [keys]     wherever -o|--aoh=deep, each entry is treated as a\n                       record with an identity key.  in order to match rhs\n                       records to lhs records, a key must be known and is\n                       identified on a yaml path basis via this section.\n                       where not specified, the first attribute of the first\n                       record in the array-of-hashes is presumed the identity\n                       key for all records in the set.\n\n            the left-to-right order of yaml_files is significant.  except\n            when this behavior is deliberately altered by your options, data\n            from files on the right overrides data in files to their left.\n            only one input file may be the - pseudo-file (read from stdin).\n            when no yaml_files are provided, - will be inferred as long as you\n            are running this program without a tty (unless you set\n            --nostdin|-s).  any file, including input from stdin, may be a\n            multi-document yaml or json file.\n\n            for more information about yaml paths, please visit\n            https://github.com/wwkimball/yamlpath.\n```\n\n* [yaml-paths](yamlpath/commands/yaml_paths.py)\n\n```text\nusage: yaml-paths [-h] [-v] -s expression [-c expression] [-m] [-l] [-f] [-x]\n                  [-p] [-n] [-t ['.', '/', 'auto', 'dot', 'fslash']]\n                  [-i | -k | -k] [-a] [-a | -y | -y | -l] [-e] [-x eyaml]\n                  [-r privatekey] [-u publickey] [-s] [-d | -v | -q]\n                  [yaml_file [yaml_file ...]]\n\nreturns zero or more yaml paths indicating where in given yaml/json/compatible\ndata one or more search expressions match. values, keys, and/or anchors can be\nsearched. eyaml can be employed to search encrypted values.\n\npositional arguments:\n  yaml_file             one or more yaml files to search; omit or use - to\n                        read from stdin\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -c expression, --except expression\n                        except results matching this search expression; can be\n                        set more than once\n  -m, --expand          expand matching parent nodes to list all permissible\n                        child leaf nodes (see \"reference handling options\" for\n                        restrictions)\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which yaml path separator to use when\n                        rendering results; default=dot\n  -a, --refnames        also search the names of &anchor and *alias references\n  -s, --nostdin         do not implicitly read from stdin, even when there are\n                        no - pseudo-files in yaml_files with a non-tty session\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all non-result output except errors\n\nrequired settings:\n  -s expression, --search expression\n                        the search expression; can be set more than once\n\nresult printing options:\n  -l, --values          print the values or elements along with each yaml path\n                        (complex results are emitted as json; use --expand to\n                        emit only simple values)\n  -f, --nofile          omit source file path and name decorators from the\n                        output (applies only when searching multiple files)\n  -x, --noexpression    omit search expression decorators from the output\n  -p, --noyamlpath      omit yaml paths from the output (useful with --values\n                        or to indicate whether a file has any matches without\n                        printing them all, perhaps especially with\n                        --noexpression)\n  -n, --noescape        omit escape characters from special characters in\n                        printed yaml paths; this is unsafe for feeding the\n                        resulting yaml paths into other yaml path commands\n                        because the symbols that would be escaped have special\n                        meaning to yaml path processors\n\nkey name searching options:\n  -i, --ignorekeynames  (default) do not search key names\n  -k, --keynames        search key names in addition to values and array\n                        elements\n  -k, --onlykeynames    only search key names (ignore all values and array\n                        elements)\n\nreference handling options:\n  indicate how to treat anchor and alias references. an anchor is an\n  original, reusable key or value. all aliases become replaced by the\n  anchors they reference when yaml data is read. these options specify how\n  to handle this duplication of keys and values. note that the default\n  behavior includes all aliased keys but not aliased values.\n\n  -a, --anchorsonly     include only original matching key and value anchors\n                        in results, discarding all aliased keys and values\n                        (including child nodes)\n  -y, --allowkeyaliases\n                        (default) include matching key aliases, permitting\n                        search traversal into their child nodes\n  -y, --allowvaluealiases\n                        include matching value aliases (does not permit search\n                        traversal into aliased keys)\n  -l, --allowaliases    include all matching key and value aliases\n\neyaml options:\n  left unset, the eyaml keys will default to your system or user defaults.\n  both keys must be set either here or in your system or user eyaml\n  configuration file when using eyaml.\n\n  -e, --decrypt         decrypt eyaml values in order to search them\n                        (otherwise, search the encrypted blob)\n  -x eyaml, --eyaml eyaml\n                        the eyaml binary to use when it isn't on the path\n  -r privatekey, --privatekey privatekey\n                        eyaml private key\n  -u publickey, --publickey publickey\n                        eyaml public key\n\na search or exception expression takes the form of a yaml path search operator\n-- %, $, =, ^, >, <, >=, <=, =~, or ! -- followed by the search term, omitting\nthe left-hand operand. for more information about yaml paths, please visit\nhttps://github.com/wwkimball/yamlpath/wiki. to report issues with this tool or\nto request enhancements, please visit\nhttps://github.com/wwkimball/yamlpath/issues.\n```\n\n* [yaml-set](yamlpath/commands/yaml_set.py)\n\n```text\nusage: yaml-set [-h] [-v] -g yaml_path\n                [-a value | -a anchor | -f file | -i | -r length | -n | -d]\n                [-f {bare,boolean,default,dquote,float,folded,int,literal,squote}]\n                [-c check] [-s yaml_path] [-m] [-b]\n                [-t ['.', '/', 'auto', 'dot', 'fslash']] [-m chars] [-h anchor]\n                [-t tag] [-e] [-x eyaml] [-r privatekey] [-u publickey] [-s]\n                [-d | -v | -q]\n                [yaml_file]\n\nchanges one or more scalar values in a yaml/json/compatible document at a\nspecified yaml path. matched values can be checked before they are replaced to\nmitigate accidental change. when matching singular results, the value can be\narchived to another key before it is replaced. further, eyaml can be employed to\nencrypt the new values and/or decrypt an old value before checking it.\n\npositional arguments:\n  yaml_file             the yaml file to update; omit or use - to read from\n                        stdin\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -v, --version         show program's version number and exit\n  -f {bare,boolean,default,dquote,float,folded,int,literal,squote}, --format {bare,boolean,default,dquote,float,folded,int,literal,squote}\n                        override automatic formatting of the new value\n  -c check, --check check\n                        check the value before replacing it\n  -s yaml_path, --saveto yaml_path\n                        save the old value to yaml_path before replacing it;\n                        implies --mustexist\n  -m, --mustexist       require that the --change yaml_path already exist in\n                        yaml_file\n  -b, --backup          save a backup yaml_file with an extra .bak file-\n                        extension\n  -t ['.', '/', 'auto', 'dot', 'fslash'], --pathsep ['.', '/', 'auto', 'dot', 'fslash']\n                        indicate which yaml path separator to use when rendering\n                        results; default=dot\n  -m chars, --random-from chars\n                        characters from which to build a value for --random;\n                        default=all upper- and lower-case letters and all digits\n  -h anchor, --anchor anchor\n                        when --aliasof|-a points to a value which is not already\n                        anchored, a new anchor with this name is created;\n                        renames an existing anchor if already set\n  -t tag, --tag tag     assign a custom yaml (data-type) tag to the changed\n                        nodes; can be used without other input options to assign\n                        or change a tag\n  -s, --nostdin         do not implicitly read from stdin, even when there is no\n                        yaml_file with a non-tty session\n  -d, --debug           output debugging details\n  -v, --verbose         increase output verbosity\n  -q, --quiet           suppress all output except errors\n\nrequired settings:\n  -g yaml_path, --change yaml_path\n                        yaml path where the target value is found\n\ninput options:\n  -a value, --value value\n                        set the new value from the command-line instead of stdin\n  -a anchor, --aliasof anchor\n                        set the value as a yaml alias of an existing anchor, by\n                        name (merely copies the target value for non-yaml files)\n  -f file, --file file  read the new value from file (discarding any trailing\n                        new-lines)\n  -i, --stdin           accept the new value from stdin (best for sensitive\n                        data)\n  -r length, --random length\n                        randomly generate a replacement value of a set length\n  -n, --null            sets the value to null\n  -d, --delete          delete rather than change target node(s); implies\n                        --mustexist|-m\n\neyaml options:\n  left unset, the eyaml keys will default to your system or user defaults. you\n  do not need to supply a private key unless you enable --check and the old\n  value is encrypted.\n\n  -e, --eyamlcrypt      encrypt the new value using eyaml\n  -x eyaml, --eyaml eyaml\n                        the eyaml binary to use when it isn't on the path\n  -r privatekey, --privatekey privatekey\n                        eyaml private key\n  -u publickey, --publickey publickey\n                        eyaml public key\n\nwhen no changes are made, no backup is created, even when -b/--backup is\nspecified. for more information about yaml paths, please visit\nhttps://github.com/wwkimball/yamlpath/wiki. to report issues with this tool or\nto request enhancements, please visit\nhttps://github.com/wwkimball/yamlpath/issues.\n```\n\n* [yaml-validate](yamlpath/commands/yaml_validate.py)\n\n```text\nusage: yaml-validate [-h] [-v] [-s] [-d | -v | -q] [yaml_file [yaml_file ...]]\n\nvalidate yaml, json, and compatible files.\n\npositional arguments:\n  yaml_file      one or more single- or multi-document yaml/json/compatible\n                 files to validate; omit or use - to read from stdin\n\noptional arguments:\n  -h, --help     show this help message and exit\n  -v, --version  show program's version number and exit\n  -s, --nostdin  do not implicitly read from stdin, even when there are no -\n                 pseudo-files in yaml_files with a non-tty session\n  -d, --debug    output debugging details\n  -v, --verbose  increase output verbosity (show valid documents)\n  -q, --quiet    suppress all output except system errors\n\nexcept when suppressing all report output with --quiet|-q, validation issues\nare printed to stdout (not stderr). further, the exit-state will report 0 when\nthere are no issues, 1 when there is an issue with the supplied command-line\narguments, or 2 when validation has failed for any document.\n```\n\n### libraries\n\nwhile there are several supporting library files like enumerations, types, and\nexceptions, the most interesting library files include:\n\n* [yamlpath.py](yamlpath/yamlpath.py) -- the core yaml path parser logic.\n* [processor.py](yamlpath/processor.py) -- processes yamlpath instances to read\n  or write data to yaml/compatible sources.\n* [eyamlprocessor.py](yamlpath/eyaml/eyamlprocessor.py) -- extends the\n  processor class to support eyaml data encryption and decryption.\n* [merger.py](yamlpath/merger/merger.py) -- the core document merging logic.\n\n## basic usage\n\nthe files of this project can be used either as command-line tools or as\nlibraries to supplement your own work.\n\n### basic usage:  command-line tools\n\nthe command-line tools are self-documented and [their documentation is captured\nabove](#command-line-tools) for easy reference.  simply pass `--help` to them in\norder to obtain the same detailed documentation.\n\nplease review [the comprehensive test_commands_*.py unit tests](/tests/) to\nexplore samples of yaml files and the many ways these tools help get and set\ntheir data.\n\nthe following are some simple examples of their typical use-cases.\n\n#### rotate your eyaml keys\n\nif the eyaml command is already on your path (if not, be sure to also supply\nthe optional `--eyaml` or `-x` argument):\n\n```shell\neyaml-rotate-keys \\\n  --oldprivatekey=~/old-keys/private_key.pkcs7.pem \\\n  --oldpublickey=~/old-keys/public_key.pkcs7.pem \\\n  --newprivatekey=~/new-keys/private_key.pkcs7.pem \\\n  --newpublickey=~/new-keys/public_key.pkcs7.pem \\\n  my_1st_yaml_file.yaml my_2nd_yaml_file.eyaml ... my_nth_yaml_file.yaml\n```\n\nyou could combine this with `find` and `xargs` if your e/yaml file are\ndispersed through a directory hierarchy, as with hiera data.\n\n##### eyaml compatibility alert\n\nthe maintainers of the hiera-eyaml project have released version 3.x and it is\n*not backward compatible* with encryption certificates generated for\nhiera-eyaml version 2.x.  this has nothing to do with yaml path and is alerted\nhere only as a courtesy to yaml path users.  **if you upgrade your\ninstallation of hiera-eyaml without first updating your encryption\ncertificates and using a tool like eyaml-rotate-keys (provided here) to\nre-encrypt your data with the replacement certificates, hiera-eyaml 3.x will\nfail to decrypt your data!**  this is *not* a problem with yaml path.\nhiera-eyaml certificate compatibility is well outside the purview of yaml path\nand its tools.\n\n#### get the differences between two documents\n\nfor routine use:\n\n```shell\nyaml-diff yaml_file1.yaml yaml_file2.yaml\n```\n\noutput is very similar to that of standard gnu diff against text files, except\nit is generated against the *data* within the input files.  this excludes\nevaluating purely structural and immaterial differences between them like value\ndemarcation, white-space, and comments.  when you need to evaluate the two\nfiles as if they were just text files, use gnu diff or any of its clones.\n\nto see all identical entries along with differences:\n\n```shell\nyaml-diff --same yaml_file1.yaml yaml_file2.yaml\n```\n\nto see *only* entries which are identical between the documents:\n\n```shell\nyaml-diff --onlysame yaml_file1.yaml yaml_file2.yaml\n```\n\nadvanced:  arrays can be evaluated such that they are synchronized before\nevaluation.  rather than compare elements by identical index in both\ndocuments -- reporting differences between them as changes and any additional\nelements as additions or deletions -- they can instead be compared by matching\nup all identical elements and then reporting only those values which are unique\nto either document (and optionally identical matches).\n\n```shell\nyaml-diff --sync-arrays yaml_file1.yaml yaml_file2.yaml\n```\n\n#### get a yaml/json/compatible value\n\nat its simplest:\n\n```shell\nyaml-get \\\n  --query=see.documentation.above.for.many.samples \\\n  my_yaml_file.yaml\n```\n\n#### search for yaml paths\n\nsimplest use:\n\n```shell\nyaml-paths \\\n  --search=%word \\\n  /some/directory/*.yaml\n```\n\nsearch for multiple expressions and exclude unwanted results:\n\n```shell\nyaml-paths \\\n  --search=^another \\\n  --search=$word \\\n  --except=%bad \\\n  /some/directory/*.yaml\n```\n\nreturn all leaf nodes under matching parents (most useful when matching against hash keys and you only want the original leaf nodes beneath them):\n\n```shell\nyaml-paths \\\n  --expand \\\n  --keynames \\\n  --search==parent_node \\\n  /some/directory/*.yaml\n```\n\n#### change a yaml/json/compatible value\n\nfor a no-frills change to a yaml file with deeply nested hash structures:\n\n```shell\nyaml-set \\\n  --change=see.documentation.above.for.many.samples \\\n  --value=\"new value\" \\\n  my_yaml_file.yaml\n```\n\nto rotate a password, preserving the old password perhaps so your automation can\napply the new password to your application(s):\n\n```shell\nyaml-set \\\n  --mustexist \\\n  --change=the.new.password \\\n  --saveto=the.old.password \\\n  --value=\"new password\" \\\n  my_yaml_file.yaml\n```\n\nfor the extremely cautious, you could check the old password before rotating\nit and save a backup of the original file:\n\n```shell\nyaml-set \\\n  --mustexist \\\n  --change=the.new.password \\\n  --saveto=the.old.password \\\n  --check=\"old password\" \\\n  --value=\"new password\" \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nyou can also add eyaml encryption (assuming the `eyaml` command is on your\npath; if not, you can pass `--eyaml` to specify its location).  in this example,\ni add the optional `--format=folded` so that the long eyaml value is broken up\ninto a multi-line value rather than one very long string.  this is the preferred\nformat for human legibility as well as eyaml consumers like\n[puppet](http://puppet.com).  note that `--format` has several other settings\nand applies only to new values.\n\n```shell\nyaml-set \\\n  --change=the.new.password \\\n  --mustexist \\\n  --saveto=the.old.password \\\n  --check=\"old password\" \\\n  --value=\"new password\" \\\n  --eyamlcrypt \\\n  --format=folded \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nyou can even tell eyaml which keys to use, if not your default system or user\nkeys:\n\n```shell\nyaml-set \\\n  --change=the.new.password \\\n  --mustexist \\\n  --saveto=the.old.password \\\n  --check=\"old password\" \\\n  --value=\"new password\" \\\n  --eyamlcrypt \\\n  --format=folded \\\n  --privatekey=/secret/keys/private_key.pkcs7.pem \\\n  --publickey=/secret/keys/public_key.pkcs7.pem \\\n  --backup \\\n  my_yaml_file.yaml\n```\n\nnote that for even greater security scenarios, you can keep the new value off of\nyour command-line, process list, and command history by swapping out `--value`\nfor one of `--stdin`, `--file`, or even `--random length` (use python's\nstrongest random value generator if you don't need to specify the replacement\nvalue in advance).\n\n#### merge yaml/json/compatible files\n\nat its simplest, the `yaml-merge` command accepts two or more input files and\nmerges them together from left-to-right, writing the result to stdout:\n\n```shell\nyaml-merge leftmost.yaml middle.yaml right.json\n```\n\nif you'd rather write the results to a new output file (which must not already\nexist):\n\n```shell\nyaml-merge \\\n  --output=newfile.yaml \\\n  leftmost.yaml \\\n  middle.yaml \\\n  right.json\n```\n\nshould you wish to merge the content of the files into a specific location (or\neven multiple locations) within the leftmost document, specify a yaml path via\nthe `--mergeat` or `-m` argument:\n\n```shell\nyaml-merge \\\n  --mergeat=/anywhere/within/the/document \\\n  leftmost.yaml \\\n  middle.yaml \\\n  right.json\n```\n\nto write arbitrary data from stdin into a document, use the `-` pseudo-file:\n\n```shell\necho \"{arbitrary: [document, structure]}\" | yaml-merge target.yaml -\n```\n\ncombine `--mergeat` or `-m` with the stdin pseudo-file to control where the\ndata is to be written:\n\n```shell\necho \"{arbitrary: [document, structure]}\" | \\\n  yaml-merge \\\n    --mergeat=/anywhere/within/the/document \\\n    target.yaml -\n```\n\nthere are many options for precisely controlling how the merge is performed,\nincluding the ability to specify complex rules on a yaml path basis via a\nconfiguration file.  review the command's `--help` or the\n[related wiki](https://github.com/wwkimball/yamlpath/wiki/yaml-merge) for\nmore detail.\n\n#### validate yaml/json/compatible documents\n\nvalidating the structure of yaml, json, and compatible files is as simple as\nrunning:\n\n```shell\nyaml-validate /path/to/any/files.yaml /path/to/more/files.json\n```\n\nin this default configuration, the command will output no report when all input\ndocuments are valid.  it will also report an exit-state of zero (0).  should\nthere be any validation errors, each will be printed to the screen and the\nexit-state will be 2.  an exit-state of 1 means your command-line arguments\nwere incorrect and an appropritae user error message will be displayed.\n\nwhen there are validation issues, the offending file-name(s) and sub-document\nindex(es) (zero-based) will be displayed along with a detailed validation error\nmessage.\n\n### basic usage:  libraries\n\nas for the libraries, they are also heavily documented and the example\nimplementations may perhaps serve as good copy-paste fodder (provided you give\ncredit to the source).  that said, here's a general flow/synopsis.\n\n#### initialize ruamel.yaml and these helpers\n\nyour preferences may differ, but i use this setup for round-trip yaml parsing\nand editing with ruamel.yaml.  when you need to process eyaml encrypted data,\nreplace `yamlpath.processor` with `yamlpath.eyaml.eyamlprocessor` and add error\nhandling for `yamlpath.eyaml.eyamlcommandexception`.\n\nnote also that these examples use `consoleprinter` to handle stdout and stderr\nmessaging.  you don't have to.  however, some kind of logger must be passed to\nthese libraries so they can write messages _somewhere_.  your custom message\nhandler or logger must provide the same api as `consoleprinter`; review the\nheader documentation in [consoleprinter.py](yamlpath/wrappers/consoleprinter.py)\nfor details.  generally speaking, it would be trivial to write your own custom\nwrapper for python's standard logging facilities if you require targets other\nthan stdout and stderr.\n\n```python\nfrom types import simplenamespace\n\nfrom yamlpath.common import parsers\nfrom yamlpath.wrappers import consoleprinter\nfrom yamlpath import processor\n\n\n# the various classes of this library must be able to write messages somewhere\n# when things go bad.  this project provides a cli-centric logging class named\n# consoleprinter.  even when not writing a cli tool, you must still configure\n# and pass consoleprinter or a class of your own with the same public api.  for\n# just muting logging output -- except for unrecoverable errors -- you can use\n# this simple configuration object:\nlogging_args = simplenamespace(quiet=true, verbose=false, debug=false)\nlog = consoleprinter(logging_args)\n\n# prep the yaml parser and round-trip editor (tweak to your needs).  you do not\n# have to use parsers.get_yaml_editor() but you must create a properly-\n# configured instance of ruamel.yaml.yaml.\nyaml = parsers.get_yaml_editor()\n\n# at this point, you'd load or parse your yaml file, stream, or string.  this\n# example demonstrates loading yaml data from an external file.  you could also\n# use the same function to load data from stdin or even a string variable.  see\n# the parser class for more detail.\nyaml_file = \"your-file.yaml\"\n(yaml_data, doc_loaded) = parsers.get_yaml_data(yaml, log, yaml_file)\nif not doc_loaded:\n    # there was an issue loading the file; an error message has already been\n    # printed via consoleprinter.\n    exit(1)\n\n# pass the logging facility and parsed yaml data to the yamlpath processor\nprocessor = processor(log, yaml_data)\n\n# at this point, the processor is ready to handle yaml paths\n```\n\n#### searching for yaml nodes\n\nthese libraries use [generators](https://wiki.python.org/moin/generators) to get\nnodes from parsed yaml data.  identify which node(s) to get via yaml path\nstrings.  you should also catch `yamlpath.exceptions.yamlpathexception`s\nunless you prefer python's native stack traces.  when using eyaml, you should\nalso catch `yamlpath.eyaml.exceptions.eyamlcommandexception`s for the same\nreason.  whether you are working with a single result or many, you should\nconsume the generator output with a pattern similar to:\n\n```python\nfrom yamlpath import yamlpath\nfrom yamlpath.exceptions import yamlpathexception\n\nyaml_path = yamlpath(\"see.documentation.above.for.many.samples\")\ntry:\n    for node_coordinate in processor.get_nodes(yaml_path, mustexist=true):\n        log.debug(\"got {} from '{}'.\".format(node_coordinate, yaml_path))\n        # do something with each node_coordinate.node (the actual data)\nexcept yamlpathexception as ex:\n    # if merely retrieving data, this exception may be deemed non-critical\n    # unless your later code absolutely depends upon a result.\n    log.error(ex)\n```\n\n#### changing values\n\nat its simplest, you only need to supply the the yaml path to one or more nodes\nto update, and the value to apply to them.  catching\n`yamlpath.exceptions.yamlpathexception` is optional but usually preferred over\nallowing python to dump the call stack in front of your users.  when using\neyaml, the same applies to `yamlpath.eyaml.exceptions.eyamlcommandexception`.\n\n```python\nfrom yamlpath.exceptions import yamlpathexception\n\ntry:\n    processor.set_value(yaml_path, new_value)\nexcept yamlpathexception as ex:\n    log.critical(ex, 119)\nexcept eyamlcommandexception as ex:\n    log.critical(ex, 120)\n```\n\n#### merging documents\n\na document merge naturally requires at least two documents.  at the code-level,\nthis means two populated dom objects (populated instances of `yaml_data` from\nabove).  you do not need to use a `processor` for merging.  in the least amount\nof code, a merge looks like:\n\n```python\nfrom yamlpath.exceptions import yamlpathexception\nfrom yamlpath.merger.exceptions import mergeexception\nfrom yamlpath.merger import merger, mergerconfig\n\n# obtain or build the lhs_data and rhs_data objects using get_yaml_data or\n# equivalent.\n\n# you'll still need to supply a logger and some arguments used by the merge\n# engine.  for purely default behavior, you could create args as a bare\n# simplenamespace.  initialize the new merger instance with the lhs document.\nmerger = merger(log, lhs_data, mergerconfig(log, args))\n\n# merge rhs into lhs\ntry:\n    merger.merge_with(rhs_data)\nexcept mergeexception as mex:\n    log.critical(mex, 129)\nexcept yamlpathexception as yex:\n    log.critical(yex, 130)\n\n# at this point, merger.data is the merged result; do what you will with it,\n# including merging more data into it.  when you are ready to dump (write)\n# out the merged data, you must prepare the document and your\n# ruamel.yaml.yaml instance -- usually obtained from func.get_yaml_editor()\n# -- like this:\nmerger.prepare_for_dump(my_yaml_editor)\n```\n",
  "docs_url": null,
  "keywords": "yaml eyaml json yaml-path diff merge",
  "license": "isc",
  "name": "yamlpath",
  "package_url": "https://pypi.org/project/yamlpath/",
  "project_url": "https://pypi.org/project/yamlpath/",
  "project_urls": {
    "Homepage": "https://github.com/wwkimball/yamlpath"
  },
  "release_url": "https://pypi.org/project/yamlpath/3.8.1/",
  "requires_dist": [
    "ruamel.yaml !=0.17.18,<=0.17.21,>0.17.5",
    "python-dateutil <=3"
  ],
  "requires_python": ">3.6.0",
  "summary": "command-line get/set/merge/validate/scan/convert/diff processors for yaml/json/compatible data using powerful, intuitive, command-line friendly syntax",
  "version": "3.8.1",
  "releases": [],
  "developers": [
    "github-yamlpath@kimballstuff.com",
    "william_w"
  ],
  "kwds": "yamlpath yaml_paths yaml_files yaml_path yaml_file",
  "license_kwds": "isc",
  "libtype": "pypi",
  "id": "pypi_yamlpath",
  "homepage": "https://github.com/wwkimball/yamlpath",
  "release_count": 48,
  "dependency_ids": [
    "pypi_python_dateutil",
    "pypi_ruamel.yaml"
  ]
}