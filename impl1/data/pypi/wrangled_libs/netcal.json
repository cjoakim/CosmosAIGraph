{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "topic :: scientific/engineering :: artificial intelligence"
  ],
  "description": "# net:cal - uncertainty calibration\n\n<div style=\"text-align: justify\">\n\nthe **net:cal** calibration framework is a python 3 library for measuring and mitigating miscalibration of uncertainty estimates, e.g., by a neural network. \nfor full api reference documentation, visit\n<https://efs-opensource.github.io/calibration-framework>.\n\ncopyright &copy; 2019-2023 ruhr west university of applied sciences,\nbottrop, germany and e:fs techhub gmbh, gaimersheim, germany.\n\nthis source code form is subject to the terms of the apache license 2.0.\nif a copy of the apl2 was not distributed with this file, you can obtain\none at <https://www.apache.org/licenses/license-2.0.txt>.\n\n**important: updated references!** if you use this framework\n(*classification or detection*) or parts of it for your research, please\ncite it by:\n\n```\n@inproceedings{kueppers_2020_cvpr_workshops,\n   author = {k\u00fcppers, fabian and kronenberger, jan and shantia, amirhossein and haselhoff, anselm},\n   title = {multivariate confidence calibration for object detection},\n   booktitle = {the ieee/cvf conference on computer vision and pattern recognition (cvpr) workshops},\n   month = {june},\n   year = {2020}\n}\n```\n\n*if you use bayesian calibration methods with uncertainty, please cite\nit by*:\n\n```\n@inproceedings{kueppers_2021_iv,\n   author = {k\u00fcppers, fabian and kronenberger, jan and schneider, jonas and haselhoff, anselm},\n   title = {bayesian confidence calibration for epistemic uncertainty modelling},\n   booktitle = {proceedings of the ieee intelligent vehicles symposium (iv)},\n   month = {july},\n   year = {2021},\n}\n```\n\n*if you use regression calibration methods, please cite it by*:\n\n```\n@inproceedings{kueppers_2022_eccv_workshops,\n  author    = {k\u00fcppers, fabian and schneider, jonas and haselhoff, anselm},\n  title     = {parametric and multivariate uncertainty calibration for regression and object detection},\n  booktitle = {european conference on computer vision (eccv) workshops},\n  year      = {2022},\n  month     = {october},\n  publisher = {springer},\n}\n```\n\n## table of contents\n\n- [overview](#overview)\n  - [update on version 1.3](#update-on-version-13)\n  - [update on version 1.2](#update-on-version-12)\n  - [update on version 1.1](#update-on-version-11)\n- [installation](#installation)\n- [requirements](#requirements)\n- [calibration metrics](#calibration-metrics)\n  - [confidence calibration metrics](#confidence-calibration-metrics)\n  - [regression calibration metrics](#regression-calibration-metrics)\n- [methods](#methods)\n  - [confidence calibration methods](#confidence-calibration-methods)\n    - [binning](#binning)\n    - [scaling](#scaling)\n    - [regularization](#regularization)\n  - [regression calibration methods](#regression-calibration-methods)\n    - [non-parametric calibration](#non-parametric-calibration)\n    - [parametric calibration](#parametric-calibration)\n- [visualization](#visualization)\n- [examples](#examples)\n  - [classification](#classification)\n    - [post-hoc calibration for classification](#post-hoc-calibration-for-classification)\n    - [measuring miscalibration for classification](#measuring-miscalibration-for-classification)\n    - [visualizing miscalibration for classification](#visualizing-miscalibration-for-classification)\n  - [detection (confidence of objects)](#detection-confidence-of-objects)\n    - [post-hoc calibration for detection](#post-hoc-calibration-for-detection)\n    - [measuring miscalibration for detection](#measuring-miscalibration-for-detection)\n    - [visualizing miscalibration for detection](#visualizing-miscalibration-for-detection)\n  - [uncertainty in confidence calibration](#uncertainty-in-confidence-calibration)\n    - [post-hoc calibration with uncertainty](#post-hoc-calibration-with-uncertainty)\n    - [measuing miscalibration with uncertainty](#measuring-miscalibration-with-uncertainty)\n  - [probabilistic regression](#probabilistic-regression)\n    - [post-hoc calibration (parametric)](#post-hoc-calibration-parametric)\n    - [post-hoc calibration (non-parametric)](#post-hoc-calibration-non-parametric)\n    - [correlation estimation and recalibration](#correlation-estimation-and-recalibration)\n    - [measuring miscalibration for regression](#measuring-miscalibration-for-regression)\n    - [visualizing miscalibration for regression](#visualizing-miscalibration-for-regression)\n- [references](#references)\n\n## overview\n\nthis framework is designed to calibrate the confidence estimates of\nclassifiers like neural networks. modern neural networks are likely to\nbe overconfident with their predictions. however, reliable confidence\nestimates of such classifiers are crucial especially in safety-critical\napplications.\n\nfor example: given 100 predictions with a confidence of 80% of each\nprediction, the observed accuracy should also match 80% (neither more\nnor less). this behaviour is achievable with several calibration\nmethods.\n\n### update on version 1.3\n\ntl;dr:\n\n- regression calibration methods: train and infer methods to rescale the uncertainty of probabilistic regression models\n- new package: *netcal.regression* with regression calibration methods:   \n  - isotonic regression (*netcal.regression.isotonicregression*)\n  - variance scaling (*netcal.regression.variancescaling*)\n  - gp-beta (*netcal.regression.gpbeta*)\n  - gp-normal (*netcal.regression.gpnormal*)\n  - gp-cauchy (*netcal.regression.gpcauchy*)\n- implement *netcal.regression.gpnormal* method with correlation estimation and recalibration\n- restructured *netcal.metrics* package to distinguish between (semantic) confidence calibration in *netcal.confidence* and regression uncertainty calibration in *netcal.regression*:\n  - expected calibration error (ece - *netcal.confidence.ece*)\n  - maximum calibration error (mce - *netcal.confidence.mce*)\n  - average calibration error (ace - *netcal.confidence.ace*)\n  - maximum mean calibration error (mmce - *netcal.confidence.mmce*)\n  - negative log likelihood (nll - *netcal.regression.nll*)\n  - prediction interval coverage probability (picp - *netcal.regression.picp*)\n  - pinball loss (*netcal.regression.pinballloss*)\n  - uncertainty calibration error (uce - *netcal.regression.uce*)\n  - expected normalized calibration error (ence - *netcal.regression.ence*)\n  - quantile calibration error (qce - *netcal.regression.qce*)\n\n- added new types of reliability diagrams to visualize regression calibration properties:   \n  - reliability regression diagram to visualize calibration for different quantile levels (preferred - *netcal.presentation.reliabilityregression*)\n  - reliability qce diagram to visualize qce over stddev (*netcal.presentation.qce*)\n- updated examples\n- minor bugfixes\n- use library [tikzplotlib](https://github.com/texworld/tikzplotlib) within the *netcal.presentation* package to enable a direct conversion of *matplotlib.figure* objects to tikz-code (e.g., can be used for latex figures)\n\nwithin this release, we provide a new package *netcal.regression* to\nenable recalibration of probabilistic regression tasks. within\nprobabilistic regression, a regression model does not output a single\nscore for each prediction but rather a probability distribution (e.g.,\ngaussian with mean/variance) that targets the true output score. similar\nto (semantic) confidence calibration, regression calibration requires\nthat the estimated uncertainty matches the observed error distribution.\nthere exist several definitions for regression calibration which the\nprovided calibration methods aim to mitigate (cf. readme within the\n*netcal.regression* package). we distinguish the provided calibration\nmethods into non-parametric and parametric methods. non-parametric\ncalibration methods take a probability distribution as input and apply\nrecalibration in terms of quantiles on the cumulative (cdf). this leads\nto a recalibrated probability distribution that, however, has no\nanalytical representation but is given by certain points defining a cdf\ndistribution. non-parametric calibration methods are\n*netcal.regression.isotonicregression* and *netcal.regression.gpbeta*.\n\nin contrast, parametric calibration methods also take a probability\ndistribution as input and provide a recalibrated distribution that has\nan analytical expression (e.g., gaussian). parametric calibration\nmethods are *netcal.regression.variancescaling*,\n*netcal.regression.gpnormal*, and *netcal.regression.gpcauchy*.\n\nthe calibration methods are designed to also work with multiple\nindependent dimensions. the methods\n*netcal.regression.isotonicregression* and\n*netcal.regression.variancescaling* apply a recalibration of each\ndimension independently of each other. in contrast, the gp methods\n*netcal.regression.gpbeta*, *netcal.regression.gpnormal*, and\n*netcal.regression.gpcauchy* use a single gp to apply recalibration.\nfurthermore, the gp-normal *netcal.regression.gpnormal* is can model\npossible correlations within the training data to transform multiple\nunivariate probability distributions of a single sample to a joint\nmultivariate (normal) distribution with possible correlations. this\ncalibration scheme is denoted as *correlation estimation*. additionally,\nthe gp-normal is also able to take a multivariate (normal) distribution\nwith correlations as input and applies a recalibration of the whole\ncovariance matrix. this is referred to as *correlation recalibration*.\n\nbesides the recalibration methods, we restructured the *netcal.metrics*\npackage which now also holds several metrics for regression calibration\n(cf. *netcal.metrics* package documentation for detailed information).\nfinally, we provide several ways to visualize regression miscalibration\nwithin the *netcal.presentation* package.\n\nall plot-methods within the *netcal.presentation* package now support\nthe option \"tikz=true\" which switches from standard\n*matplotlib.figure* objects to strings with tikz-code. tikz-code can be\ndirectly used for latex documents to render images as vector graphics\nwith high quality. thus, this option helps to improve the quality of\nyour reliability diagrams if you are planning to use this library for\nany type of publication/document\n\n### update on version 1.2\n\ntl;dr:\n\n- bayesian confidence calibration: train and infer scaling methods using variational inference (vi) and mcmc sampling\n- new metrics: mmce [[13]](#ref13) and picp [[14]](#ref14) (*netcal.metrics.mmce* and *netcal.metrics.picp*)\n- new regularization methods: mmce [[13]](#ref13) and dca [[15]](#ref15) (*netcal.regularization.mmcepenalty* and *netcal.regularization.dcapenalty*)\n- updated examples\n- switched license from mpl2 to apl2\n\nnow you can also use bayesian methods to obtain uncertainty within a\ncalibration mapping mainly in the *netcal.scaling* package. we adapted\nmarkov-chain monte-carlo sampling (mcmc) as well as variational\ninference (vi) on common calibration methods. it is also easily possible\nto bring the scaling methods to cuda in order to speed-up the\ncomputations. we further provide new metrics to evaluate confidence\ncalibration (mmce) and to evaluate the quality of prediction intervals\n(picp). finally, we updated our framework by new regularization methods\nthat can be used during model training (mmce and dca).\n\n### update on version 1.1\n\nthis framework can also be used to calibrate object detection models. it\nhas recently been shown that calibration on object detection also\ndepends on the position and/or scale of a predicted object [[12]](#ref12). we\nprovide calibration methods to perform confidence calibration w.r.t. the\nadditional box regression branch. for this purpose, we extended the\ncommonly used histogram binning [[3]](#ref3), logistic calibration alias platt\nscaling [[10]](#ref10) and the beta calibration method [[2]](#ref2) to also include the\nbounding box information into a calibration mapping. furthermore, we\nprovide two new methods called the *dependent logistic calibration* and\nthe *dependent beta calibration* that are not only able to perform a\ncalibration mapping w.r.t. additional bounding box information but also\nto model correlations and dependencies between all given quantities [[12]](#ref12).\nthose methods should be preffered over their counterparts in object\ndetection mode.\n\nthe framework is structured as follows:\n\n    netcal\n      .binning         # binning methods (confidence calibration)\n      .scaling         # scaling methods (confidence calibration)\n      .regularization  # regularization methods (confidence calibration)\n      .presentation    # presentation methods (confidence/regression calibration)\n      .metrics         # metrics for measuring miscalibration (confidence/regression calibration)\n      .regression      # methods for regression uncertainty calibration (regression calibration)\n\n    examples           # example code snippets\n\n## installation\n\nthe installation of the calibration suite is quite easy as it registered\nin the python package index (pypi). you can either install this\nframework using pip:\n```shell\n$ python3 -m pip install netcal\n```\nor simply invoke the following command to install the calibration suite when installing from source:\n```shell\n$ git clone https://github.com/efs-opensource/calibration-framework\n$ cd calibration-framework\n$ python3 -m pip install .\n```\n\nnote: with update 1.3, we switched from *setup.py* to *pyproject.toml*\naccording to pep-518. the *setup.py* is only for backwards\ncompatibility.\n\n### requirements\naccording to *requierments.txt*:\n\n-   numpy\\>=1.18\n-   scipy\\>=1.4\n-   matplotlib\\>=3.3\n-   scikit-learn\\>=0.24\n-   torch\\>=1.9\n-   torchvision\\>=0.10.0\n-   tqdm\\>=4.40\n-   pyro-ppl\\>=1.8\n-   tikzplotlib\\>=0.9.8\n-   tensorboard\\>=2.2\n-   gpytorch\\>=1.5.1\n\n## calibration metrics\n\nwe further distinguish between *onfidence calibration* which aims to\nrecalibrate confidence estimates in the [0, 1] interval, and\n*regression uncertainty calibration* which addresses the problem of\ncalibration in probabilistic regression settings.\n\n### confidence calibration metrics\n\nthe most common metric to determine miscalibration in the scope of\nclassification is the *expected calibration error* (ece) [[1]](#ref1). this\nmetric divides the confidence space into several bins and measures the\nobserved accuracy in each bin. the bin gaps between observed accuracy\nand bin confidence are summed up and weighted by the amount of samples\nin each bin. the *maximum calibration error* (mce) denotes the highest\ngap over all bins. the *average calibration error* (ace) [[11]](#ref11) denotes\nthe average miscalibration where each bin gets weighted equally. for\nobject detection, we implemented the *detection calibration error*\n(d-ece) [[12]](#ref12) that is the natural extension of the ece to object\ndetection tasks. the miscalibration is determined w.r.t. the bounding\nbox information provided (e.g. box location and/or scale). for this\npurpose, all available information gets binned in a multidimensional\nhistogram. the accuracy is then calculated in each bin separately to\ndetermine the mean deviation between confidence and accuracy.\n\n- (detection) expected calibration error [[1]](#ref1), [[12]](#ref12) (*netcal.metrics.ece*)\n- (detection) maximum calibration error [[1]](#ref1), [[12]](#ref12)  (*netcal.metrics.mce*)\n- (detection) average calibration error [[11]](#ref11), [[12]](#ref12) (*netcal.metrics.ace*)\n- maximum mean calibration error (mmce) [[13]](#ref13) (*netcal.metrics.mmce*) (no position-dependency)\n\n### regression calibration metrics\n\nin regression calibration, the most common metric is the *negative log\nlikelihood* (nll) to measure the quality of a predicted probability\ndistribution w.r.t. the ground-truth:\n\n- negative log likelihood (nll) (*netcal.metrics.nll*)\n\nthe metrics *pinball loss*, *prediction interval coverage probability*\n(picp), and *quantile calibration error* (qce) evaluate the estimated\ndistributions by means of the predicted quantiles. for example, if a\nforecaster makes 100 predictions using a probability distribution for\neach estimate targeting the true ground-truth, we can measure the\ncoverage of the ground-truth samples for a certain quantile level (e.g.,\n95% quantile). if the relative amount of ground-truth samples falling\ninto a certain predicted quantile is above or below the specified\nquantile level, a forecaster is told to be miscalibrated in terms of\n*quantile calibration*. appropriate metrics in this context are\n\n- pinball loss (*netcal.metrics.pinballloss*)\n- prediction interval coverage probability (picp) [[14]](#ref14) (*netcal.metrics.picp*)\n- quantile calibration error (qce) [[15]](#ref15) (*netcal.metrics.qce*)\n\nfinally, if we work with normal distributions, we can measure the\nquality of the predicted variance/stddev estimates. for *variance\ncalibration*, it is required that the predicted variance mathes the\nobserved error variance which is equivalent to then mean squared error\n(mse). metrics for *variance calibration* are\n\n- expected normalized calibration error (ence) [[17]](#ref17) (*netcal.metrics.ence*)\n- uncertainty calibration error (uce) [[18]](#ref18) (*netcal.metrics.uce*)\n\n## methods\n\nwe further give an overview about the post-hoc calibration methods for\n(semantic) confidence calibration as well as about the methods for\nregression uncertainty calibration.\n\n### confidence calibration methods\n\nthe post-hoc calibration methods are separated into binning and scaling\nmethods. the binning methods divide the available information into\nseveral bins (like ece or d-ece) and perform calibration on each bin.\nthe scaling methods scale the confidence estimates or logits directly to\ncalibrated confidence estimates - on detection calibration, this is done\nw.r.t. the additional regression branch of a network.\n\nimportant: if you use the detection mode, you need to specifiy the flag\n\"detection=true\" in the constructor of the according method (this is\nnot necessary for *netcal.scaling.logisticcalibrationdependent* and\n*netcal.scaling.betacalibrationdependent*).\n\nmost of the calibration methods are designed for binary classification\ntasks. for binning methods, multi-class calibration is performed in\n\"one vs. all\" by default.\n\nsome methods such as \"isotonic regression\" utilize methods from the\nscikit-learn api [[9]](#ref9).\n\nanother group are the regularization tools which are added to the loss\nduring the training of a neural network.\n\n#### binning\n\nimplemented binning methods are:\n\n- histogram binning for classification [[3]](#ref3), [[4]](#ref4) and object detection [[12]](#ref12) (*netcal.binning.histogrambinning*)\n- isotonic regression [[4]](#ref4),[[5]](#ref5) (*netcal.binning.isotonicregression*)\n- bayesian binning into quantiles (bbq) [[1]](#ref1) (*netcal.binning.bbq*)\n- ensemble of near isotonic regression (enir) [[6]](#ref6) (*netcal.binning.enir*)\n\n#### scaling\n\nimplemented scaling methods are:\n\n- logistic calibration/platt scaling for classification [[10]](#ref10) and object detection [[12]](#ref12) (*netcal.scaling.logisticcalibration*)\n- dependent logistic calibration for object detection [[12]](#ref12) (*netcal.scaling.logisticcalibrationdependent*) - on detection, this method is able to capture correlations between all input quantities and should be preferred over logistic calibration for object detection\n- temperature scaling for classification [[7]](#ref7) and object detection [[12]](#ref12) (*netcal.scaling.temperaturescaling*)\n- beta calibration for classification [[2]](#ref2) and object detection [[12]](#ref12) (*netcal.scaling.betacalibration*)\n- dependent beta calibration for object detection [[12]](#ref12) (*netcal.scaling.betacalibrationdependent*) - on detection, this method is able to capture correlations between all input quantities and should be preferred over beta calibration for object detection\n\n**new on version 1.2:** you can provide a parameter named \"method\" to\nthe constructor of each scaling method. this parameter could be one of\nthe following: - 'mle': use the method feed-forward with maximum\nlikelihood estimates on the calibration parameters (standard) -\n'momentum': use non-convex momentum optimization (e.g. default on\ndependent beta calibration) - 'mcmc': use markov-chain monte-carlo\nsampling to obtain multiple parameter sets in order to quantify\nuncertainty in the calibration - 'variational': use variational\ninference to obtain multiple parameter sets in order to quantify\nuncertainty in the calibration\n\n#### regularization\n\nwith some effort, it is also possible to push the model training towards\ncalibrated confidences by regularization. implemented regularization\nmethods are:\n\n- confidence penalty [[8]](#ref8) (*netcal.regularization.confidence\\_penalty* and *netcal.regularization.confidencepenalty* - the latter one is a pytorch implementation that might be used as a regularization term)\n- maximum mean calibration error (mmce) [[13]](#ref13) (*netcal.regularization.mmcepenalty* - pytorch regularization module)\n- dca [[15]](#ref15) (*netcal.regularization.dcapenalty* - pytorch regularization module)\n\n### regression calibration methods\n\nthe *netcal* library provides post-hoc methods to recalibrate the\nuncertainty of probabilistic regression tasks. we distinguish the\ncalibration methods into non-parametric and parametric methods.\nnon-parametric calibration methods take a probability distribution as\ninput and apply recalibration in terms of quantiles on the cumulative\n(cdf). this leads to a recalibrated probability distribution that,\nhowever, has no analytical representation but is given by certain points\ndefining a cdf distribution. in contrast, parametric calibration methods\nalso take a probability distribution as input and provide a recalibrated\ndistribution that has an analytical expression (e.g., gaussian).\n\n#### non-parametric calibration\n\nthe common non-parametric recalibration methods use the predicted\ncumulative (cdf) distribution functions to learn a mapping from the\nuncalibrated quantiles to the observed quantile coverage. using a\nrecalibrated cdf, it is possible to derive the respective density\nfunctions (pdf) or to extract statistical moments such as mean and\nvariance. non-parametric calibration methods within the\n*netcal.regression* package are\n\n- isotonic regression [[19]](#ref19) which applies a (marginal) recalibration of the cdf (*netcal.regression.isotonicregression*)\n- gp-beta [[20]](#ref20) which applies an input-dependent recalibration of the cdf using a gaussian process for parameter estimation (*netcal.regression.gpbeta*)\n\n#### parametric calibration\n\nthe parametric recalibration methods apply a recalibration of the\nestimated distributions so that the resulting distribution is given in\nterms of a distribution with an analytical expression (e.g., a\ngaussian). these methods are suitable for applications where a\nparametric distribution is required for subsequent applications, e.g.,\nwithin kalman filtering. we implemented the following parametric\ncalibration methods:\n\n- variance scaling [[17]](#ref17), [[18]](#ref18) which is nothing else but a temperature scaling for the predicted variance (*netcal.regression.variancescaling*)\n- gp-normal [[16]](#ref16) which applies an input-dependent rescaling of the predicted variance (*netcal.regression.gpnormal*). note: this method is also able to capture correlations between multiple input dimensions and can return a joint multivariate normal distribution as calibration output (cf. examples section).\n- gp-cauchy [[16]](#ref16) is similar to gp-normal but utilizes a cauchy distribution as calibration output (*netcal.regression.gpcauchy*)\n\n## visualization\n\nfor visualization of miscalibration, one can use a confidence histograms\n& reliability diagrams for (semantic) confidence calibration as well as\nfor regression uncertainty calibration. within confidence calibration,\nthese diagrams are similar to ece. the output space is divided into\nequally spaced bins. the calibration gap between bin accuracy and bin\nconfidence is visualized as a histogram.\n\nfor detection calibration, the miscalibration can be visualized either\nalong one additional box information (e.g. the x-position of the\npredictions) or distributed over two additional box information in terms\nof a heatmap.\n\nfor regression uncertainty calibration, the reliability diagram shows\nthe relative prediction interval coverage of the ground-truth samples\nfor different quantile levels.\n\n- reliability diagram [[1]](#ref1), [[12]](#ref12) (*netcal.presentation.reliabilitydiagram*)\n- reliability diagram for regression calibration (*netcal.presentation.reliabilityregression*)\n- reliability qce diagram [[16]](#ref16) shows the quantile calibration error (qce) for different variance levels (*netcal.presentation.reliabilityqce*)\n\n**new on version 1.3:** all plot-methods within the\n*netcal.presentation* package now support the option \"tikz=true\" which\nswitches from standard *matplotlib.figure* objects to strings with\ntikz-code. tikz-code can be directly used for latex documents to render\nimages as vector graphics with high quality. thus, this option helps to\nimprove the quality of your reliability diagrams if you are planning to\nuse this library for any type of publication/document\n\n## examples\n\nthe calibration methods work with the predicted confidence estimates of\na neural network and on detection also with the bounding box regression\nbranch.\n\n### classification\n\nthis is a basic example which uses softmax predictions of a\nclassification task with 10 classes and the given numpy arrays:\n\n```python\nground_truth  # this is a numpy 1-d array with ground truth digits between 0-9 - shape: (n_samples,)\nconfidences   # this is a numpy 2-d array with confidence estimates between 0-1 - shape: (n_samples, n_classes)\n```\n\n#### post-hoc calibration for classification\n\nthis is an example for *netcal.scaling.temperaturescaling* but also\nworks for every calibration method (remind different constructor\nparameters):\n\n```python\nimport numpy as np\nfrom netcal.scaling import temperaturescaling\n\ntemperature = temperaturescaling()\ntemperature.fit(confidences, ground_truth)\ncalibrated = temperature.transform(confidences)\n```\n\n#### measuring miscalibration for classification\n\nthe miscalibration can be determined with the ece:\n\n```python\nfrom netcal.metrics import ece\n\nn_bins = 10\n\nece = ece(n_bins)\nuncalibrated_score = ece.measure(confidences, ground_truth)\ncalibrated_score = ece.measure(calibrated, ground_truth)\n```\n\n#### visualizing miscalibration for classification\n\nthe miscalibration can be visualized with a reliability diagram:\n\n```python\nfrom netcal.presentation import reliabilitydiagram\n\nn_bins = 10\n\ndiagram = reliabilitydiagram(n_bins)\ndiagram.plot(confidences, ground_truth)  # visualize miscalibration of uncalibrated\ndiagram.plot(calibrated, ground_truth)   # visualize miscalibration of calibrated\n\n# you can also use this method to create a tikz file with tikz code\n# that can be directly used within latex documents:\ndiagram.plot(confidences, ground_truth, tikz=true, filename=\"diagram.tikz\")\n```\n\n### detection (confidence of objects)\n\nin this example we use confidence predictions of an object detection\nmodel with the according x-position of the predicted bounding boxes. our\nground-truth provided to the calibration algorithm denotes if a bounding\nbox has matched a ground-truth box with a certain iou and the correct\nclass label.\n\n```python\nmatched                # binary numpy 1-d array (0, 1) that indicates if a bounding box has matched a ground truth at a certain iou with the right label - shape: (n_samples,)\nconfidences            # numpy 1-d array with confidence estimates between 0-1 - shape: (n_samples,)\nrelative_x_position    # numpy 1-d array with relative center-x position between 0-1 of each prediction - shape: (n_samples,)\n```\n\n#### post-hoc calibration for detection\n\nthis is an example for *netcal.scaling.logisticcalibration* and\n*netcal.scaling.logisticcalibrationdependent* but also works for every\ncalibration method (remind different constructor parameters):\n\n```python\nimport numpy as np\nfrom netcal.scaling import logisticcalibration, logisticcalibrationdependent\n\ninput = np.stack((confidences, relative_x_position), axis=1)\n\nlr = logisticcalibration(detection=true, use_cuda=false)    # flag 'detection=true' is mandatory for this method\nlr.fit(input, matched)\ncalibrated = lr.transform(input)\n\nlr_dependent = logisticcalibrationdependent(use_cuda=false) # flag 'detection=true' is not necessary as this method is only defined for detection\nlr_dependent.fit(input, matched)\ncalibrated = lr_dependent.transform(input)\n```\n\n#### measuring miscalibration for detection\n\nthe miscalibration can be determined with the d-ece:\n\n```python\nfrom netcal.metrics import ece\n\nn_bins = [10, 10]\ninput_calibrated = np.stack((calibrated, relative_x_position), axis=1)\n\nece = ece(n_bins, detection=true)           # flag 'detection=true' is mandatory for this method\nuncalibrated_score = ece.measure(input, matched)\ncalibrated_score = ece.measure(input_calibrated, matched)\n```\n\n#### visualizing miscalibration for detection\n\nthe miscalibration can be visualized with a reliability diagram:\n\n```python\nfrom netcal.presentation import reliabilitydiagram\n\nn_bins = [10, 10]\n\ndiagram = reliabilitydiagram(n_bins, detection=true)    # flag 'detection=true' is mandatory for this method\ndiagram.plot(input, matched)                # visualize miscalibration of uncalibrated\ndiagram.plot(input_calibrated, matched)     # visualize miscalibration of calibrated\n\n# you can also use this method to create a tikz file with tikz code\n# that can be directly used within latex documents:\ndiagram.plot(input, matched, tikz=true, filename=\"diagram.tikz\")\n```\n\n### uncertainty in confidence calibration\n\nwe can also quantify the uncertainty in a calibration mapping if we use\na bayesian view on the calibration models. we can sample multiple\nparameter sets using mcmc sampling or vi. in this example, we reuse the\ndata of the previous detection example.\n\n```python\nmatched                # binary numpy 1-d array (0, 1) that indicates if a bounding box has matched a ground truth at a certain iou with the right label - shape: (n_samples,)\nconfidences            # numpy 1-d array with confidence estimates between 0-1 - shape: (n_samples,)\nrelative_x_position    # numpy 1-d array with relative center-x position between 0-1 of each prediction - shape: (n_samples,)\n```\n\n#### post-hoc calibration with uncertainty\n\nthis is an example for *netcal.scaling.logisticcalibration* and\n*netcal.scaling.logisticcalibrationdependent* but also works for every\ncalibration method (remind different constructor parameters):\n\n```python\nimport numpy as np\nfrom netcal.scaling import logisticcalibration, logisticcalibrationdependent\n\ninput = np.stack((confidences, relative_x_position), axis=1)\n\n# flag 'detection=true' is mandatory for this method\n# use variational inference with 2000 optimization steps for creating this calibration mapping\nlr = logisticcalibration(detection=true, method'variational', vi_epochs=2000, use_cuda=false)\nlr.fit(input, matched)\n\n# 'num_samples=1000': sample 1000 parameter sets from vi\n# thus, 'calibrated' has shape [1000, n_samples]\ncalibrated = lr.transform(input, num_samples=1000)\n\n# flag 'detection=true' is not necessary as this method is only defined for detection\n# this time, use markov-chain monte-carlo sampling with 250 warm-up steps, 250 parameter samples and one chain\nlr_dependent = logisticcalibrationdependent(method='mcmc',\n                                            mcmc_warmup_steps=250, mcmc_steps=250, mcmc_chains=1,\n                                            use_cuda=false)\nlr_dependent.fit(input, matched)\n\n# 'num_samples=1000': although we have only sampled 250 different parameter sets,\n# we can randomly sample 1000 parameter sets from mcmc\ncalibrated = lr_dependent.transform(input)\n```\n\n#### measuring miscalibration with uncertainty\n\nyou can directly pass the output to the d-ece and picp instance to\nmeasure miscalibration and mask quality:\n\n```python\nfrom netcal.metrics import ece\nfrom netcal.metrics import picp\n\nn_bins = 10\nece = ece(n_bins, detection=true)\npicp = picp(n_bins, detection=true)\n\n# the following function calls are equivalent:\nmiscalibration = ece.measure(calibrated, matched, uncertainty=\"mean\")\nmiscalibration = ece.measure(np.mean(calibrated, axis=0), matched)\n\n# now determine uncertainty quality\nuncertainty = picp.measure(calibrated, matched, kind=\"confidence\")\n\nprint(\"d-ece:\", miscalibration)\nprint(\"picp:\", uncertainty.picp) # prediction coverage probability\nprint(\"mpiw:\", uncertainty.mpiw) # mean prediction interval width\n```\n\nif we want to measure miscalibration and uncertainty quality by means of\nthe relative x position, we need to broadcast the according information:\n\n```python\n# broadcast and stack x information to calibrated information\nbroadcasted = np.broadcast_to(relative_x_position, calibrated.shape)\ncalibrated = np.stack((calibrated, broadcasted), axis=2)\n\nn_bins = [10, 10]\nece = ece(n_bins, detection=true)\npicp = picp(n_bins, detection=true)\n\n# the following function calls are equivalent:\nmiscalibration = ece.measure(calibrated, matched, uncertainty=\"mean\")\nmiscalibration = ece.measure(np.mean(calibrated, axis=0), matched)\n\n# now determine uncertainty quality\nuncertainty = picp.measure(calibrated, matched, uncertainty=\"mean\")\n\nprint(\"d-ece:\", miscalibration)\nprint(\"picp:\", uncertainty.picp) # prediction coverage probability\nprint(\"mpiw:\", uncertainty.mpiw) # mean prediction interval width\n```\n\n### probabilistic regression\n\nthe following example shows how to use the post-hoc calibration methods\nfor probabilistic regression tasks. within probabilistic regression, a\nforecaster (e.g. with gaussian prior) outputs a mean and a variance\ntargeting the true ground-truth score. thus, the following information\nis required to construct the calibration methods:\n\n```python\nmean          # numpy n-d array holding the estimated mean of shape (n, d) with n samples and d dimensions\nstddev        # numpy n-d array holding the estimated stddev (independent) of shape (n, d) with n samples and d dimensions\nground_truth  # numpy n-d array holding the ground-truth scores of shape (n, d) with n samples and d dimensions\n```\n\n#### post-hoc calibration (parametric)\n\nthese information might result e.g. from object detection where the\nposition information of the objects (bounding boxes) are parametrized by\nnormal distributions. we start by using parametric calibration methods\nsuch as variance scaling:\n\n```python\nfrom netcal.regression import variancescaling, gpnormal\n\n# the initialization of the variance scaling method is pretty simple\nvarscaling = variancescaling()\n\n# the gp-normal requires a little bit more parameters to parametrize the underlying gp\ngpnormal = gpnormal(\n    n_inducing_points=12,    # number of inducing points\n    n_random_samples=256,    # random samples used for likelihood\n    n_epochs=256,            # optimization epochs\n    use_cuda=false,          # can also use cuda for computations\n)\n\n# fit the variance scaling\n# note that we need to pass the first argument as tuple as the input distributions\n# are parametrized by mean and variance\nvarscaling.fit((mean, stddev), ground_truth)\n\n# fit gp-normal - similar parameters here!\ngpnormal.fit((mean, stddev), ground_truth)\n\n# transform distributions to obtain recalibrated stddevs\nstddev_varscaling = varscaling.transform((mean, stddev))  # numpy array with stddev - has shape (n, d)\nstddev_gpnormal = gpnormal.transform((mean, stddev))  # numpy array with stddev - has shape (n, d)\n```\n\n#### post-hoc calibration (non-parametric)\n\nwe can also use non-parametric calibration methods. in this case, the\ncalibrated distributions are defined by their density (pdf) and\ncumulative (cdf) functions:\n\n```python\nfrom netcal.regression import isotonicregression, gpbeta\n\n# the initialization of the isotonic regression method is pretty simple\nisotonic = isotonicregression()\n\n# the gp-normal requires a little bit more parameters to parametrize the underlying gp\ngpbeta = gpbeta(\n    n_inducing_points=12,    # number of inducing points\n    n_random_samples=256,    # random samples used for likelihood\n    n_epochs=256,            # optimization epochs\n    use_cuda=false,          # can also use cuda for computations\n)\n\n# fit the isotonic regression\n# note that we need to pass the first argument as tuple as the input distributions\n# are parametrized by mean and variance\nisotonic.fit((mean, stddev), ground_truth)\n\n# fit gp-beta - similar parameters here!\ngpbeta.fit((mean, stddev), ground_truth)\n\n# transform distributions to obtain recalibrated distributions\nt_isotonic, pdf_isotonic, cdf_isotonic = varscaling.transform((mean, stddev))\nt_gpbeta, pdf_gpbeta, cdf_gpbeta = gpbeta.transform((mean, stddev))\n\n# note: the transformation results are numpy n-d arrays with shape (t, n, d)\n# with t as the number of points that define the pdf/cdf,\n# with n as the number of samples, and\n# with d as the number of dimensions.\n\n# the resulting variables can be interpreted as follows:\n# - t_isotonic/t_gpbeta: x-values of the pdf/cdf with shape (t, n, d)\n# - pdf_isotonic/pdf_gpbeta: y-values of the pdf with shape (t, n, d)\n# - cdf_isotonic/cdf_gpbeta: y-values of the cdf with shape (t, n, d)\n```\n\nyou can visualize the non-parametric distribution of a single sample\nwithin a single dimension using matplotlib:\n\n```python\nfrom matplotlib import pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(2, 1)\n\n# plot the recalibrated pdf within a single axis after calibration\nax1.plot(\n    t_isotonic[:, 0, 0], pdf_isotonic[:, 0, 0],\n    t_gpbeta[:, 0, 0], pdf_gpbeta[:, 0, 0],\n)\n\n# plot the recalibrated pdf within a single axis after calibration\nax2.plot(\n    t_isotonic[:, 0, 0], cdf_isotonic[:, 0, 0],\n    t_gpbeta[:, 0, 0], cdf_gpbeta[:, 0, 0],\n)\n\nplt.show()\n```\n\nwe provide a method to extract the statistical moments expectation and\nvariance from the recalibrated cumulative (cdf). note that we advise to\nuse one of the parametric calibration methods if you need e.g. a\ngaussian for subsequent applications such as kalman filtering.\n\n```python\nfrom netcal import cumulative_moments\n\n# extract the expectation (mean) and the variance from the recalibrated cdf\nymean_isotonic, yvar_isotonic = cumulative_moments(t_isotonic, cdf_isotonic)\nymean_gpbeta, yvar_gpbeta = cumulative_moments(t_gpbeta, cdf_gpbeta)\n\n# each of these variables has shape (n, d) and holds the\n# mean/variance for each sample and in each dimension\n```\n\n#### correlation estimation and recalibration\n\nwith the gp-normal *netcal.regression.gpnormal*, it is also possible to\ndetect possible correlations between multiple input dimensions that have\noriginally been trained/modelled independently from each other:\n\n```python\nfrom netcal.regression import gpnormal\n\n# the gp-normal requires a little bit more parameters to parametrize the underlying gp\ngpnormal = gpnormal(\n    n_inducing_points=12,    # number of inducing points\n    n_random_samples=256,    # random samples used for likelihood\n    n_epochs=256,            # optimization epochs\n    use_cuda=false,          # can also use cuda for computations\n    correlations=true,       # enable correlation capturing between the input dimensions\n)\n\n# fit gp-normal\n# note that we need to pass the first argument as tuple as the input distributions\n# are parametrized by mean and variance\ngpnormal.fit((mean, stddev), ground_truth)\n\n# transform distributions to obtain recalibrated covariance matrices\ncov = gpnormal.transform((mean, stddev))  # numpy array with covariance - has shape (n, d, d)\n\n# note: if the input is already given by multivariate normal distributions\n# (stddev is covariance and has shape (n, d, d)), the methods works similar\n# and simply applies a covariance recalibration of the input\n```\n\n#### measuring miscalibration for regression\n\nmeasuring miscalibration is as simple as the training of the methods:\n\n```python\nimport numpy as np\nfrom netcal.metrics import nll, pinballloss, qce\n\n# define the quantile levels that are used to evaluate the pinball loss and the qce\nquantiles = np.linspace(0.1, 0.9, 9)\n\n# initialize nll, pinball, and qce objects\nnll = nll()\npinball = pinballloss()\nqce = qce(marginal=true)  # if \"marginal=false\", we can also measure the qce by means of the predicted variance levels (realized by binning the variance space)\n\n# measure miscalibration with the initialized metrics\n# note: the parameter \"reduction\" has a major influence to the return shape of the metrics\n# see the method docstrings for detailed information\nnll.measure((mean, stddev), ground_truth, reduction=\"mean\")\npinball.measure((mean, stddev), ground_truth, q=quantiles, reduction=\"mean\")\nqce.measure((mean, stddev), ground_truth, q=quantiles, reduction=\"mean\")\n```\n\n#### visualizing miscalibration for regression\n\nexample visualization code block using the\n*netcal.presentation.reliabilityregression* class:\n\n```python\nfrom netcal.presentation import reliabilityregression\n\n# define the quantile levels that are used for the quantile evaluation\nquantiles = np.linspace(0.1, 0.9, 9)\n\n# initialize the diagram object\ndiagram = reliabilityregression(quantiles=quantiles)\n\n# visualize miscalibration with the initialized object\ndiagram.plot((mean, stddev), ground_truth)\n\n# you can also use this method to create a tikz file with tikz code\n# that can be directly used within latex documents:\ndiagram.plot((mean, stddev), ground_truth, tikz=true, filename=\"diagram.tikz\")\n```\n</div>\n\n## references\n\n<a name=\"ref1\">[1]</a> naeini, mahdi pakdaman, gregory cooper, and milos hauskrecht: \"obtaining well calibrated probabilities using bayesian binning.\" twenty-ninth aaai conference on artificial intelligence, 2015.\n\n<a name=\"ref2\">[2]</a> kull, meelis, telmo silva filho, and peter flach: \"beta calibration: a well-founded and easily implemented improvement on logistic calibration for binary classifiers.\" artificial intelligence and statistics, pmlr 54:623-631, 2017.\n\n<a name=\"ref3\">[3]</a> zadrozny, bianca and elkan, charles: \"obtaining calibrated probability estimates from decision trees and naive bayesian classifiers.\" in icml, pp. 609\u2013616, 2001.\n\n<a name=\"ref4\">[4]</a> zadrozny, bianca and elkan, charles: \"transforming classifier scores into accurate multiclass probability estimates.\" in kdd, pp. 694\u2013699, 2002.\n\n<a name=\"ref5\">[5]</a> ryan j tibshirani, holger hoefling, and robert tibshirani: \"nearly-isotonic regression.\" technometrics, 53(1):54\u201361, 2011.\n\n<a name=\"ref6\">[6]</a> naeini, mahdi pakdaman, and gregory f. cooper: \"binary classifier calibration using an ensemble of near isotonic regression models.\" 2016 ieee 16th international conference on data mining (icdm). ieee, 2016.\n\n<a name=\"ref7\">[7]</a> chuan guo, geoff pleiss, yu sun and kilian q. weinberger: \"on calibration of modern neural networks.\" proceedings of the 34th international conference on machine learning, 2017.\n\n<a name=\"ref8\">[8]</a> pereyra, g., tucker, g., chorowski, j., kaiser, l. and hinton, g.: \u201cregularizing neural networks by penalizing confident output distributions.\u201d corr, 2017.\n\n<a name=\"ref9\">[9]</a> pedregosa, f., varoquaux, g., gramfort, a., michel, v., thirion, b., grisel, o., blondel, m., prettenhofer, p., weiss, r., dubourg, v., vanderplas, j., passos, a., cournapeau, d., brucher, m., perrot, m. and duchesnay, e.: \"scikit-learn: machine learning in python.\" in journal of machine learning research, volume 12 pp 2825-2830, 2011.\n\n<a name=\"ref10\">[10]</a> platt, john: \"probabilistic outputs for support vector machines and comparisons to regularized likelihood methods.\" advances in large margin classifiers, 10(3): 61\u201374, 1999.\n\n<a name=\"ref11\">[11]</a> neumann, lukas, andrew zisserman, and andrea vedaldi: \"relaxed softmax: efficient confidence auto-calibration for safe pedestrian detection.\" conference on neural information processing systems (nips) workshop mlits, 2018.\n\n<a name=\"ref12\">[12]</a> fabian k\u00fcppers, jan kronenberger, amirhossein shantia, and anselm haselhoff: \"multivariate confidence calibration for object detection\".\" the ieee/cvf conference on computer vision and pattern recognition (cvpr) workshops, 2020\n\n<a name=\"ref13\">[13]</a> kumar, aviral, sunita sarawagi, and ujjwal jain: \"trainable calibration measures for neural networks from _kernel mean embeddings.\" international conference on machine learning. 2018\n\n<a name=\"ref14\">[14]</a> jiayu  yao,  weiwei  pan,  soumya  ghosh,  and  finale  doshi-velez: \"quality of uncertainty quantification for bayesian neural network inference.\" workshop on uncertainty and robustness in deep learning, icml, 2019\n\n<a name=\"ref15\">[15]</a> liang, gongbo, et al.: \"improved trainable calibration method for neural networks on medical imaging classification.\" arxiv preprint arxiv:2009.04057 (2020)\n\n<a name=\"ref16\">[16]</a> fabian k\u00fcppers, jonas schneider, jonas, and anselm haselhoff: \"parametric and multivariate uncertainty calibration for regression and object detection.\" in: proceedings of the european conference on computer vision (eccv) workshops, springer, october 2022\n\n<a name=\"ref17\">[17]</a> levi, dan, et al.: \"evaluating and calibrating uncertainty prediction in regression tasks.\" arxiv preprint arxiv:1905.11659 (2019).\n\n<a name=\"ref18\">[18]</a> laves, max-heinrich, et al.: \"well-calibrated regression uncertainty in medical imaging with deep learning.\" medical imaging with deep learning. pmlr, 2020.\n\n<a name=\"ref19\">[19]</a> volodymyr kuleshov, nathan fenner, and stefano ermon: \"accurate uncertainties for deep learning using calibrated regression.\" international conference on machine learning. pmlr, 2018.\n\n<a name=\"ref20\">[20]</a> hao song, tom diethe, meelis kull and peter flach: \"distribution calibration for regression.\" international conference on machine learning. pmlr, 2019.\n",
  "docs_url": null,
  "keywords": "netcal,calibration,uncertainty,neural,network,confidence,classification,object,detection,regression",
  "license": "apache-2.0",
  "name": "netcal",
  "package_url": "https://pypi.org/project/netcal/",
  "project_url": "https://pypi.org/project/netcal/",
  "project_urls": {
    "Documentation": "https://efs-opensource.github.io/calibration-framework",
    "Homepage": "https://github.com/EFS-OpenSource/calibration-framework"
  },
  "release_url": "https://pypi.org/project/netcal/1.3.5/",
  "requires_dist": [
    "numpy (>=1.18)",
    "scipy (>=1.4)",
    "matplotlib (>=3.3)",
    "scikit-learn (>=0.24)",
    "torch (>=1.9)",
    "torchvision (>=0.10.0)",
    "tqdm (>=4.40)",
    "pyro-ppl (>=1.8)",
    "tikzplotlib (==0.9.8)",
    "tensorboard (>=2.2)",
    "gpytorch (>=1.5.1)"
  ],
  "requires_python": ">=3.6",
  "summary": "the net:cal calibration framework is a python 3 library for measuring and mitigating miscalibration of uncertainty estimates, e.g., by a neural network.",
  "version": "1.3.5",
  "releases": [],
  "developers": [
    "fabian.kueppers@efs-techhub.com"
  ],
  "kwds": "calibration calibrating calibrate calibrated_score calibrated",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_netcal",
  "homepage": "",
  "release_count": 13,
  "dependency_ids": [
    "pypi_gpytorch",
    "pypi_matplotlib",
    "pypi_numpy",
    "pypi_pyro_ppl",
    "pypi_scikit_learn",
    "pypi_scipy",
    "pypi_tensorboard",
    "pypi_tikzplotlib",
    "pypi_torch",
    "pypi_torchvision",
    "pypi_tqdm"
  ]
}