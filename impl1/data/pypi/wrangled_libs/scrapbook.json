{
  "classifiers": [
    "intended audience :: developers",
    "intended audience :: science/research",
    "intended audience :: system administrators",
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8"
  ],
  "description": "<img width=\"616\" alt=\"scrapbook logo\" src=\"https://user-images.githubusercontent.com/836375/52512549-31260f00-2bba-11e9-9556-515ba5ff0b4b.png\">\n\n# scrapbook\n\n<!---(binder links generated at https://mybinder.readthedocs.io/en/latest/howto/badges.html and compressed at https://tinyurl.com) -->\n\n[![travis build status](https://travis-ci.org/nteract/scrapbook.svg?branch=main)](https://travis-ci.org/nteract/scrapbook)\n[![image](https://codecov.io/github/nteract/scrapbook/coverage.svg?branch=main)](https://codecov.io/github/nteract/scrapbook=main)\n[![documentation status](https://readthedocs.org/projects/nteract-scrapbook/badge/?version=latest)](https://nteract-scrapbook.readthedocs.io/en/latest/?badge=latest)\n[![badge](https://tinyurl.com/y3moqkmc)](https://mybinder.org/v2/gh/nteract/scrapbook/main?filepath=binder%2freglue_highlight_dates.ipynb)\n[![badge](https://tinyurl.com/ybk8qa3j)](https://mybinder.org/v2/gh/nteract/scrapbook/main?filepath=binder%2fresultsdemo.ipynb)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\nthe **scrapbook** library records a notebook\u2019s data values and generated visual\ncontent as \"scraps\". recorded scraps can be read at a future time.\n\n[see the scrapbook documentation](https://nteract-scrapbook.readthedocs.io/) for\nmore information on how to use scrapbook.\n\n## use cases\n\nnotebook users may wish to record data produced during a notebook's execution.\nthis recorded data, **scraps**, can be used at a later time or passed in a\nworkflow to another notebook as input.\n\nnamely, scrapbook lets you:\n\n- **persist** data and visual content displays in a notebook as scraps\n- **recall** any persisted scrap of data\n- **summarize collections** of notebooks\n\n## python version support\n\nthis library's long term support target is python 3.5+. it currently also\nsupports python 2.7 until python 2 reaches end-of-life in 2020. after this\ndate, python 2 support will halt, and only 3.x versions will be maintained.\n\n## installation\n\ninstall using `pip`:\n\n```{.sourcecode .bash}\npip install scrapbook\n```\n\nfor installing optional io dependencies, you can specify individual store bundles,\nlike `s3` or `azure`:\n\n```{.sourcecode .bash}\npip install scrapbook[s3]\n```\n\nor use `all`:\n\n```{.sourcecode .bash}\npip install scrapbook[all]\n```\n\n---\n\n## models and terminology\n\nscrapbook defines the following items:\n\n- **scraps**: serializable data values and visualizations such as strings, lists of\n  objects, pandas dataframes, charts, images, or data references.\n- **notebook**: a wrapped nbformat notebook object with extra methods for interacting\n  with scraps.\n- **scrapbook**: a collection of notebooks with an interface for asking questions of\n  the collection.\n- **encoders**: a registered translator of data to/from notebook\n  storage formats.\n\n### `scrap` model\n\nthe `scrap` model houses a few key attributes in a tuple, including:\n\n- **name**: the name of the scrap\n- **data**: any data captured by the scrapbook api call\n- **encoder**: the name of the encoder used to encode/decode data to/from the notebook\n- **display**: any display data used by ipython to display visual content\n\n---\n\n## api\n\nscrapbook adds a few basic api commands which enable saving and retrieving data\nincluding:\n\n- `glue` to persist scraps with or without _display output_\n- `read_notebook` reads one notebook\n- `scraps` provides a searchable dictionary of all scraps by name\n- `reglue` which copies a scrap from another notebook to the current notebook\n- `read_notebooks` reads many notebooks from a given path\n- `scraps_report` displays a report about collected scraps\n- `papermill_dataframe` and `papermill_metrics` for backward compatibility\n  for two deprecated papermill features\n\nthe following sections provide more detail on these api commands.\n\n### `glue` to persist scraps\n\nrecords a `scrap` (data or display value) in the given notebook cell.\n\nthe `scrap` (recorded value) can be retrieved during later inspection of the\noutput notebook.\n\n```python\n\"\"\"glue example for recording data values\"\"\"\nimport scrapbook as sb\n\nsb.glue(\"hello\", \"world\")\nsb.glue(\"number\", 123)\nsb.glue(\"some_list\", [1, 3, 5])\nsb.glue(\"some_dict\", {\"a\": 1, \"b\": 2})\nsb.glue(\"non_json\", df, 'arrow')\n```\n\nthe scrapbook library can be used later to recover `scraps` from the output\nnotebook:\n\n```python\n# read a notebook and get previously recorded scraps\nnb = sb.read_notebook('notebook.ipynb')\nnb.scraps\n```\n\n**scrapbook** will imply the storage format by the value type of any registered\ndata encoders. alternatively, the implied encoding format can be overwritten by\nsetting the `encoder` argument to the registered name (e.g. `\"json\"`) of a\nparticular encoder.\n\nthis data is persisted by generating a display output with a special media type\nidentifying the content encoding format and data. these outputs are not always\nvisible in notebook rendering but still exist in the document. scrapbook can\nthen rehydrate the data associated with the notebook in the future by reading\nthese cell outputs.\n\n#### with _display output_\n\nto display a named scrap with visible display outputs, you need to indicate that\nthe scrap is directly renderable.\n\nthis can be done by toggling the `display` argument.\n\n```python\n# record a ui message along with the input string\nsb.glue(\"hello\", \"hello world\", display=true)\n```\n\nthe call will save the data and the display attributes of the scrap object,\nmaking it visible as well as encoding the original data. this leans on the\n`ipython.core.formatters.format_display_data` function to translate the data\nobject into a display and metadata dict for the notebook kernel to parse.\n\nanother pattern that can be used is to specify that **only the display data**\nshould be saved, and not the original object. this is achieved by setting\nthe encoder to be `display`.\n\n```python\n# record an image without the original input object\nsb.glue(\"sharable_png\",\n  ipython.display.image(filename=\"sharable.png\"),\n  encoder='display'\n)\n```\n\nfinally the media types that are generated can be controlled by passing\na list, tuple, or dict object as the display argument.\n\n```python\nsb.glue(\"media_as_text_only\",\n  media_obj,\n  encoder='display',\n  display=('text/plain',) # this passes [text/plain] to format_display_data's include argument\n)\n\nsb.glue(\"media_without_text\",\n  media_obj,\n  encoder='display',\n  display={'exclude': 'text/plain'} # forward to format_display_data's kwargs\n)\n```\n\nlike data scraps, these can be retrieved at a later time be accessing the scrap's\n`display` attribute. though usually one will just use notebook's `reglue` method\n(described below).\n\n### `read_notebook` reads one notebook\n\nreads a notebook object loaded from the location specified at `path`.\nyou've already seen how this function is used in the above api call examples,\nbut essentially this provides a thin wrapper over an `nbformat`'s notebooknode\nwith the ability to extract scrapbook scraps.\n\n```python\nnb = sb.read_notebook('notebook.ipynb')\n```\n\nthis notebook object adheres to the [nbformat's json schema](https://github.com/jupyter/nbformat/blob/master/nbformat/v4/nbformat.v4.schema.json),\nallowing for access to its required fields.\n\n```python\nnb.cells # the cells from the notebook\nnb.metadata\nnb.nbformat\nnb.nbformat_minor\n```\n\nthere's a few additional methods provided, most of which are outlined in more detail\nbelow:\n\n```python\nnb.scraps\nnb.reglue\n```\n\nthe abstraction also makes saved content available as a dataframe referencing each\nkey and source. more of these methods will be made available in later versions.\n\n```python\n# produces a data frame with [\"name\", \"data\", \"encoder\", \"display\", \"filename\"] as columns\nnb.scrap_dataframe # warning: this might be a large object if data or display is large\n```\n\nthe notebook object also has a few legacy functions for backwards compatibility\nwith papermill's notebook object model. as a result, it can be used to read\npapermill execution statistics as well as scrapbook abstractions:\n\n```python\nnb.cell_timing # list of cell execution timings in cell order\nnb.execution_counts # list of cell execution counts in cell order\nnb.papermill_metrics # dataframe of cell execution counts and times\nnb.papermill_record_dataframe # dataframe of notebook records (scraps with only data)\nnb.parameter_dataframe # dataframe of notebook parameters\nnb.papermill_dataframe # dataframe of notebook parameters and cell scraps\n```\n\nthe notebook reader relies on [papermill's registered iorw](https://papermill.readthedocs.io/en/latest/reference/papermill-io.html)\nto enable access to a variety of sources such as -- but not limited to -- s3,\nazure, and google cloud.\n\n### `scraps` provides a name -> scrap lookup\n\nthe `scraps` method allows for access to all of the scraps in a particular notebook.\n\n```python\nnb = sb.read_notebook('notebook.ipynb')\nnb.scraps # prints a dict of all scraps by name\n```\n\nthis object has a few additional methods as well for convenient conversion and\nexecution.\n\n```python\nnb.scraps.data_scraps # filters to only scraps with `data` associated\nnb.scraps.data_dict # maps `data_scraps` to a `name` -> `data` dict\nnb.scraps.display_scraps # filters to only scraps with `display` associated\nnb.scraps.display_dict # maps `display_scraps` to a `name` -> `display` dict\nnb.scraps.dataframe # generates a dataframe with [\"name\", \"data\", \"encoder\", \"display\"] as columns\n```\n\nthese methods allow for simple use-cases to not require digging through model\nabstractions.\n\n### `reglue` copys a scrap into the current notebook\n\nusing `reglue` one can take any scrap glue'd into one notebook and glue into the\ncurrent one.\n\n```python\nnb = sb.read_notebook('notebook.ipynb')\nnb.reglue(\"table_scrap\") # this copies both data and displays\n```\n\nany data or display information will be copied verbatim into the currently\nexecuting notebook as though the user called `glue` again on the original source.\n\nit's also possible to rename the scrap in the process.\n\n```python\nnb.reglue(\"table_scrap\", \"old_table_scrap\")\n```\n\nand finally if one wishes to try to reglue without checking for existence the\n`raise_on_missing` can be set to just display a message on failure.\n\n```python\nnb.reglue(\"maybe_missing\", raise_on_missing=false)\n# => \"no scrap found with name 'maybe_missing' in this notebook\"\n```\n\n### `read_notebooks` reads many notebooks\n\nreads all notebooks located in a given `path` into a scrapbook object.\n\n```python\n# create a scrapbook named `book`\nbook = sb.read_notebooks('path/to/notebook/collection/')\n# get the underlying notebooks as a list\nbook.notebooks # or `book.values`\n```\n\nthe path reuses [papermill's registered `iorw`](https://papermill.readthedocs.io/en/latest/reference/papermill-io.html)\nto list and read files form various sources, such that non-local urls can load data.\n\n```python\n# create a scrapbook named `book`\nbook = sb.read_notebooks('s3://bucket/key/prefix/to/notebook/collection/')\n```\n\nthe scrapbook (`book` in this example) can be used to recall all scraps across\nthe collection of notebooks:\n\n```python\nbook.notebook_scraps # dict of shape `notebook` -> (`name` -> `scrap`)\nbook.scraps # merged dict of shape `name` -> `scrap`\n```\n\n### `scraps_report` displays a report about collected scraps\n\nthe scrapbook collection can be used to generate a `scraps_report` on all the\nscraps from the collection as a markdown structured output.\n\n```python\nbook.scraps_report()\n```\n\nthis display can filter on scrap and notebook names, as well as enable or disable\nan overall header for the display.\n\n```python\nbook.scraps_report(\n  scrap_names=[\"scrap1\", \"scrap2\"],\n  notebook_names=[\"result1\"], # matches `/notebook/collections/result1.ipynb` pathed notebooks\n  header=false\n)\n```\n\nby default the report will only populate with visual elements. to also\nreport on data elements set include_data.\n\n```python\nbook.scraps_report(include_data=true)\n```\n\n### papermill support\n\nfinally the scrapbook provides two backwards compatible features for deprecated\n`papermill` capabilities:\n\n```python\nbook.papermill_dataframe\nbook.papermill_metrics\n```\n\n## encoders\n\nencoders are accessible by key names to encoder objects registered\nagainst the `encoders.registry` object. to register new data encoders\nsimply call:\n\n```python\nfrom encoder import registry as encoder_registry\n# add encoder to the registry\nencoder_registry.register(\"custom_encoder_name\", mycustomencoder())\n```\n\nthe encode class must implement two methods, `encode` and `decode`:\n\n```python\nclass mycustomencoder(object):\n    def encode(self, scrap):\n        # scrap.data is any type, usually specific to the encoder name\n        pass  # return a `scrap` with `data` type one of [none, list, dict, *six.integer_types, *six.string_types]\n\n    def decode(self, scrap):\n        # scrap.data is one of [none, list, dict, *six.integer_types, *six.string_types]\n        pass  # return a `scrap` with `data` type as any type, usually specific to the encoder name\n```\n\nthis can read transform scraps into a json object representing their contents or\nlocation and load those strings back into the original data objects.\n\n### `text`\n\na basic string storage format that saves data as python strings.\n\n```python\nsb.glue(\"hello\", \"world\", \"text\")\n```\n\n### `json`\n\n```python\nsb.glue(\"foo_json\", {\"foo\": \"bar\", \"baz\": 1}, \"json\")\n```\n\n### `pandas`\n\n```python\nsb.glue(\"pandas_df\",pd.dataframe({'col1': [1, 2], 'col2': [3, 4]}), \"pandas\")\n```\n\n## papermill's deprecated `record` feature\n\n**scrapbook** provides a robust and flexible recording schema. this library replaces [papermill](https://papermill.readthedocs.io)'s existing\n`record` functionality.\n\n[documentation for papermill `record`](https://papermill.readthedocs.io/en/latest/usage-recording.html?#recording-values-to-the-notebook) exists on readthedocs.\nin brief, the deprecated `record` function:\n\n`pm.record(name, value)`: enables values to be saved\nwith the notebook [[api documentation]](https://papermill.readthedocs.io/en/latest/reference/papermill.html#papermill.api.record)\n\n```python\npm.record(\"hello\", \"world\")\npm.record(\"number\", 123)\npm.record(\"some_list\", [1, 3, 5])\npm.record(\"some_dict\", {\"a\": 1, \"b\": 2})\n```\n\n`pm.read_notebook(notebook)`: pandas could be used later to recover recorded\nvalues by reading the output notebook into a dataframe. for example:\n\n```python\nnb = pm.read_notebook('notebook.ipynb')\nnb.dataframe\n```\n\n### rationale for papermill `record` deprecation\n\npapermill's `record` function was deprecated due to these limitations and challenges:\n\n- the `record` function didn't follow papermill's pattern of linear execution\n  of a notebook. it was awkward to describe `record` as an additional\n  feature of papermill, and really felt like describing a second less\n  developed library.\n- recording / reading required data translation to json for everything. this is\n  a tedious, painful process for dataframes.\n- reading recorded values into a dataframe would result in unintuitive dataframe\n  shapes.\n- less modularity and flexiblity than other papermill components where custom\n  operators can be registered.\n\nto overcome these limitations in papermill, a decision was made to create\n**scrapbook**.\n\n\n",
  "docs_url": null,
  "keywords": "jupyter,mapreduce,nteract,pipeline,notebook",
  "license": "bsd",
  "name": "scrapbook",
  "package_url": "https://pypi.org/project/scrapbook/",
  "project_url": "https://pypi.org/project/scrapbook/",
  "project_urls": {
    "Documentation": "https://nteract-scrapbook.readthedocs.io",
    "Funding": "https://nteract.io",
    "Homepage": "https://github.com/nteract/scrapbook",
    "Source": "https://github.com/nteract/scrapbook/",
    "Tracker": "https://github.com/nteract/scrapbook/issues"
  },
  "release_url": "https://pypi.org/project/scrapbook/0.5.0/",
  "requires_dist": [
    "pandas",
    "papermill",
    "jsonschema",
    "ipython",
    "pyarrow",
    "papermill[all] ; extra == 'all'",
    "papermill[azure] ; extra == 'azure'",
    "bumpversion ; extra == 'dev'",
    "wheel (>=0.31.0) ; extra == 'dev'",
    "setuptools (>=38.6.0) ; extra == 'dev'",
    "twine (>=1.11.0) ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "tox ; extra == 'dev'",
    "mock ; extra == 'dev'",
    "ipython ; extra == 'dev'",
    "papermill[dev] ; extra == 'dev'",
    "pytest (>=4.1) ; extra == 'dev'",
    "pytest-cov (>=2.6.1) ; extra == 'dev'",
    "pytest-mock (>=1.10) ; extra == 'dev'",
    "pytest-env (>=0.6.2) ; extra == 'dev'",
    "codecov ; extra == 'dev'",
    "coverage ; extra == 'dev'",
    "papermill[gcs] ; extra == 'gcs'",
    "papermill[s3] ; extra == 's3'",
    "bumpversion ; extra == 'test'",
    "wheel (>=0.31.0) ; extra == 'test'",
    "setuptools (>=38.6.0) ; extra == 'test'",
    "twine (>=1.11.0) ; extra == 'test'",
    "flake8 ; extra == 'test'",
    "tox ; extra == 'test'",
    "mock ; extra == 'test'",
    "ipython ; extra == 'test'",
    "papermill[dev] ; extra == 'test'",
    "pytest (>=4.1) ; extra == 'test'",
    "pytest-cov (>=2.6.1) ; extra == 'test'",
    "pytest-mock (>=1.10) ; extra == 'test'",
    "pytest-env (>=0.6.2) ; extra == 'test'",
    "codecov ; extra == 'test'",
    "coverage ; extra == 'test'"
  ],
  "requires_python": ">=3.5",
  "summary": "a library for recording and reading data in jupyter and nteract notebooks",
  "version": "0.5.0",
  "releases": [],
  "developers": [
    "nteract@googlegroups.com",
    "nteract_contributors"
  ],
  "kwds": "scrapbook notebook_scraps scrap2 data_scraps scrap1",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_scrapbook",
  "homepage": "https://github.com/nteract/scrapbook",
  "release_count": 1,
  "dependency_ids": [
    "pypi_bumpversion",
    "pypi_codecov",
    "pypi_coverage",
    "pypi_flake8",
    "pypi_ipython",
    "pypi_jsonschema",
    "pypi_mock",
    "pypi_pandas",
    "pypi_papermill",
    "pypi_pyarrow",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_env",
    "pypi_pytest_mock",
    "pypi_setuptools",
    "pypi_tox",
    "pypi_twine",
    "pypi_wheel"
  ]
}