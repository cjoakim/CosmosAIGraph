{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "framework :: django :: 4.1",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: utilities"
  ],
  "description": "# `django-notifications` documentation\n\n[![build-status](https://travis-ci.org/django-notifications/django-notifications.svg)](https://travis-ci.org/django-notifications/django-notifications)\n[![coverage status](https://coveralls.io/repos/github/django-notifications/django-notifications/badge.svg?branch=master)](https://coveralls.io/github/django-notifications/django-notifications?branch=master)\n\n\n[django-notifications](https://github.com/django-notifications/django-notifications) is a github notification alike app for django, it was derived from [django-activity-stream](https://github.com/justquick/django-activity-stream)\n\nthe major difference between `django-notifications` and `django-activity-stream`:\n\n- `django-notifications` is for building something like github \"notifications\"\n- while `django-activity-stream` is for building github \"news feed\"\n\nnotifications are actually actions events, which are categorized by four main components.\n\n-   `actor`. the object that performed the activity.\n-   `verb`. the verb phrase that identifies the action of the activity.\n-   `action object`. *(optional)* the object linked to the action\n    itself.\n-   `target`. *(optional)* the object to which the activity was\n    performed.\n\n`actor`, `action object` and `target` are `genericforeignkeys` to any\narbitrary django object. an action is a description of an action that\nwas performed (`verb`) at some instant in time by some `actor` on some\noptional `target` that results in an `action object` getting\ncreated/updated/deleted.\n\nfor example: [justquick](https://github.com/justquick/) `(actor)`\n*closed* `(verb)` [issue\n2](https://github.com/justquick/django-activity-stream/issues/2)\n`(action_object)` on\n[activity-stream](https://github.com/justquick/django-activity-stream/)\n`(target)` 12 hours ago\n\nnomenclature of this specification is based on the activity streams\nspec: <http://activitystrea.ms/specs/atom/1.0/>\n\n## requirements\n\n-   python 3.7, 3.8, 3.9, 3.10, 3.11\n-   django 3.2, 4.0, 4.1\n\n## installation\n\ninstallation is easy using `pip` and will install all required\nlibraries.\n```bash\n$ pip install django-notifications-hq\n```\nor get it from source\n\n```bash\n$ git clone https://github.com/django-notifications/django-notifications\n$ cd django-notifications\n$ python setup.py sdist\n$ pip install dist/django-notifications-hq*\n```\n\nnote that [django-model-utils](http://pypi.python.org/pypi/django-model-utils)\nwill be installed: this is required for the pass-through queryset manager.\n\nthen to add the django notifications to your project add the app\n`notifications` to your `installed_apps` and urlconf.\n\nthe app should go somewhere after all the apps that are going to be\ngenerating notifications like `django.contrib.auth`\n\n```python\ninstalled_apps = (\n    'django.contrib.auth',\n    ...\n    'notifications',\n    ...\n)\n```\n\nadd the notifications urls to your urlconf:\n\n```python\nimport notifications.urls\n\nurlpatterns = [\n    ...\n    url('^inbox/notifications/', include(notifications.urls, namespace='notifications')),\n    ...\n]\n```\n\nthe method of installing these urls, importing rather than using\n`'notifications.urls'`, is required to ensure that the urls are\ninstalled in the `notifications` namespace.\n\nto run schema migration, execute\n`python manage.py migrate notifications`.\n\n## generating notifications\n\ngenerating notifications is probably best done in a separate signal.\n\n```python\nfrom django.db.models.signals import post_save\nfrom notifications.signals import notify\nfrom myapp.models import mymodel\n\ndef my_handler(sender, instance, created, **kwargs):\n    notify.send(instance, verb='was saved')\n\npost_save.connect(my_handler, sender=mymodel)\n```\nto generate an notification anywhere in your code, simply import the\nnotify signal and send it with your actor, recipient, and verb.\n\n```python\nfrom notifications.signals import notify\n\nnotify.send(user, recipient=user, verb='you reached level 10')\n```\n\nthe complete syntax is.\n\n```python\nnotify.send(actor, recipient, verb, action_object, target, level, description, public, timestamp, **kwargs)\n```\n\narguments:\n\n-   **actor**: an object of any type. (required) note: use\n    **sender** instead of **actor** if you intend to use keyword\n    arguments\n-   **recipient**: a **group** or a **user queryset** or a list of\n    **user**. (required)\n-   **verb**: an string. (required)\n-   **action\\_object**: an object of any type. (optional)\n-   **target**: an object of any type. (optional)\n-   **level**: one of notification.levels (\\'success\\', \\'info\\',\n    \\'warning\\', \\'error\\') (default=info). (optional)\n-   **description**: an string. (optional)\n-   **public**: an boolean (default=true). (optional)\n-   **timestamp**: an tzinfo (default=timezone.now()). (optional)\n\n### extra data\n\nyou can attach arbitrary data to your notifications by doing the\nfollowing:\n\n-   add to your settings.py:\n    `django_notifications_config = { 'use_jsonfield': true}`\n\nthen, any extra arguments you pass to `notify.send(...)` will be\nattached to the `.data` attribute of the notification object. these will\nbe serialised using the jsonfield\\'s serialiser, so you may need to take\nthat into account: using only objects that will be serialised is a good\nidea.\n\n### soft delete\n\nby default, `delete/(?p<slug>\\d+)/` deletes specified notification\nrecord from db. you can change this behaviour to \\\"mark\n`notification.deleted` field as `true`\\\" by:\n\n-   add to your settings.py:\n    `django_notifications_config = { 'soft_delete': true}`\n\nwith this option, queryset methods `unread` and `read` contain one more\nfilter: `deleted=false`. meanwhile, queryset methods `deleted`,\n`active`, `mark_all_as_deleted`, `mark_all_as_active` are turned on. see\nmore details in queryset methods section.\n\n## api\n\n### queryset methods\n\nusing `django-model-utils`, we get the ability to add queryset methods\nto not only the manager, but to all querysets that will be used,\nincluding related objects. this enables us to do things like:\n\n```python\n    notification.objects.unread()\n```\n\nwhich returns all unread notifications. to do this for a single user, we\ncan do:\n\n```python\n    user = user.objects.get(pk=pk)\n    user.notifications.unread()\n```\n\nthere are some other queryset methods, too.\n\n#### `qs.unsent()`\n\nreturn all of the unsent notifications, filtering the current queryset.\n(emailed=false)\n\n#### `qs.sent()`\n\nreturn all of the sent notifications, filtering the current queryset.\n(emailed=true)\n\n#### `qs.unread()`\n\nreturn all of the unread notifications, filtering the current queryset.\nwhen `soft_delete=true`, this filter contains `deleted=false`.\n\n#### `qs.read()`\n\nreturn all of the read notifications, filtering the current queryset.\nwhen `soft_delete=true`, this filter contains `deleted=false`.\n\n#### `qs.mark_all_as_read()` \\| `qs.mark_all_as_read(recipient)`\n\nmark all of the unread notifications in the queryset (optionally also\nfiltered by `recipient`) as read.\n\n#### `qs.mark_all_as_unread()` \\| `qs.mark_all_as_unread(recipient)`\n\nmark all of the read notifications in the queryset (optionally also\nfiltered by `recipient`) as unread.\n\n#### `qs.mark_as_sent()` \\| `qs.mark_as_sent(recipient)`\n\nmark all of the unsent notifications in the queryset (optionally also\nfiltered by `recipient`) as sent.\n\n#### `qs.mark_as_unsent()` \\| `qs.mark_as_unsent(recipient)`\n\nmark all of the sent notifications in the queryset (optionally also\nfiltered by `recipient`) as unsent.\n\n#### `qs.deleted()`\n\nreturn all notifications that have `deleted=true`, filtering the current\nqueryset. must be used with `soft_delete=true`.\n\n#### `qs.active()`\n\nreturn all notifications that have `deleted=false`, filtering the\ncurrent queryset. must be used with `delete=true`.\n\n#### `qs.mark_all_as_deleted()` \\| `qs.mark_all_as_deleted(recipient)`\n\nmark all notifications in the queryset (optionally also filtered by\n`recipient`) as `deleted=true`. must be used with `delete=true`.\n\n#### `qs.mark_all_as_active()` \\| `qs.mark_all_as_active(recipient)`\n\nmark all notifications in the queryset (optionally also filtered by\n`recipient`) as `deleted=false`. must be used with `soft_delete=true`.\n\n### model methods\n\n#### `obj.timesince([datetime])`\n\na wrapper for django\\'s `timesince` function.\n\n#### `obj.mark_as_read()`\n\nmark the current object as read.\n\n### template tags\n\nput `{% load notifications\\_tags %}` in the template before\nyou actually use notification tags.\n\n### `notifications_unread`\n\n```python\n    {% notifications_unread %}\n```\n\ngive the number of unread notifications for a user, or nothing (an empty\nstring) for an anonymous user.\n\nstoring the count in a variable for further processing is advised, such\nas:\n\n```python\n    {% notifications_unread as unread_count %}\n    ...\n    {% if unread_count %}\n        you have <strong>{{ unread_count }}</strong> unread notifications.\n    {% endif %}\n```\n\n## live-updater api\n\nto ensure users always have the most up-to-date notifications,\n`django-notifications` includes a simple javascript api for\nupdating specific fields within a django template.\n\nthere are two possible api calls that can be made:\n\n1.  `api/unread_count/` that returns a javascript object with 1 key:\n    `unread_count` eg:\n\n        {\"unread_count\":1}\n\n2.  `api/unread_list/` that returns a javascript object with 2 keys:\n    `unread_count` and `unread_list` eg:\n\n        {\n         \"unread_count\":1,\n         \"unread_list\":[--list of json representations of notifications--]\n        }\n\n    representations of notifications are based on the django method:\n    `model_to_dict`\n\n    query string arguments:\n\n    -   **max** - maximum length of unread list.\n    -   **mark\\_as\\_read** - mark notification in list as read.\n\n    for example, get `api/unread_list/?max=3&mark_as_read=true` returns\n    3 notifications and mark them read (remove from list on next\n    request).\n\n### how to use:\n\n1.  put `{% load notifications_tags %}` in the template before you\n    actually use notification tags.\n\n2.  in the area where you are loading javascript resources add the\n    following tags in the order below:\n\n        <script src=\"{% static 'notifications/notify.js' %}\" type=\"text/javascript\"></script>\n        {% register_notify_callbacks callbacks='fill_notification_list,fill_notification_badge' %}\n\n    `register_notify_callbacks` takes the following arguments:\n\n    1.  `badge_class` (default `live_notify_badge`) - the identifier\n        `class` of the element to show the unread count,\n        that will be periodically updated.\n    2.  `menu_class` (default `live_notify_list`) - the identifier\n        `class` of the element to insert a list of unread\n        items, that will be periodically updated.\n    3.  `refresh_period` (default `15`) - how often to fetch unread\n        items from the server (integer in seconds).\n    4.  `fetch` (default `5`) - how many notifications to fetch each\n        time.\n    5.  `callbacks` (default `<empty string>`) - a comma-separated list\n        of javascript functions to call each period.\n    6.  `api_name` (default `list`) - the name of the api to call (this\n        can be either `list` or `count`).\n    7. ``mark_as_read`` (default ``false``) - marks notifications as read when fetched.\n\n3.  to insert a live-updating unread count, use the following template:\n\n        {% live_notify_badge %}\n\n    `live_notify_badge` takes the following arguments:\n\n    -  `badge_class` (default `live_notify_badge`) - the identifier\n        `class` for the `<span>` element that will be created to show\n        the unread count.\n\n4.  to insert a live-updating unread list, use the following template:\n\n        {% live_notify_list %}\n\n    `live_notify_list` takes the following arguments:\n\n    -  `list_class` (default `live_notify_list`) - the identifier\n        `class` for the `<ul>` element that will be created to insert\n        the list of notifications into.\n\n### using the live-updater with bootstrap\n\nthe live-updater can be incorporated into bootstrap with minimal code.\n\nto create a live-updating bootstrap badge containing the unread count,\nsimply use the template tag:\n\n    {% live_notify_badge badge_class=\"badge\" %}\n\nto create a live-updating bootstrap dropdown menu containing a selection\nof recent unread notifications, simply use the template tag:\n\n    {% live_notify_list list_class=\"dropdown-menu\" %}\n\n### customising the display of notifications using javascript callbacks\n\nwhile the live notifier for unread counts should suit most use cases,\nusers may wish to alter how unread notifications are shown.\n\nthe `callbacks` argument of the `register_notify_callbacks` dictates\nwhich javascript functions are called when the unread api call is made.\n\nto add a custom javascript callback, simply add this to the list, like\nso:\n\n    {% register_notify_callbacks callbacks='fill_notification_badge,my_special_notification_callback' %}\n\nthe above would cause the callback to update the unread count badge, and\nwould call the custom function\n`my_special_notification_callback`. all callback\nfunctions are passed a single argument by convention called\n`data`, which contains the entire result from the api.\n\nfor example, the below function would get the recent list of unread\nmessages and log them to the console:\n\n```javascript\nfunction my_special_notification_callback(data) {\n    for (var i=0; i < data.unread_list.length; i++) {\n        msg = data.unread_list[i];\n        console.log(msg);\n    }\n}\n```\n\n### testing the live-updater\n\n1.  clone the repo\n2.  run `./manage.py runserver`\n3.  browse to `yourserverip/test/`\n4.  click \\'make a notification\\' and a new notification should appear\n    in the list in 5-10 seconds.\n\n## serializing the django-notifications model\n\nsee here - <http://www.django-rest-framework.org/api-guide/relations/#generic-relationships>\n\nin this example the target object can be of type foo or bar and the\nappropriate serializer will be used.\n\n```python\nclass genericnotificationrelatedfield(serializers.relatedfield):\n\n    def to_representation(self, value):\n        if isinstance(value, foo):\n            serializer = fooserializer(value)\n        if isinstance(value, bar):\n            serializer = barserializer(value)\n\n        return serializer.data\n\n\nclass notificationserializer(serializers.serializer):\n    recipient = publicuserserializer(user, read_only=true)\n    unread = serializers.booleanfield(read_only=true)\n    target = genericnotificationrelatedfield(read_only=true)\n```\n\nthanks to @dawy\n\n### `abstractnotification` model\n\nin case you need to customize the notification model in order to add\nfield or customised features that depend on your application, you can\ninherit and extend the `abstractnotification` model, example:\n\n```python\n#in your_app/models.py\n\nfrom django.db import models\nfrom notifications.base.models import abstractnotification\n\n\nclass notification(abstractnotification):\n    # custom field example\n    category = models.foreignkey('myapp.category',\n                                 on_delete=models.cascade)\n\n    class meta(abstractnotification.meta):\n        abstract = false\n```\n\nyou will require to define `notifications_notification_model` setting in\n`setting.py` as follows:\n\n```python\n# in your_project/settings.py\n\nnotifications_notification_model = 'your_app.notification'\n```\n\n## notes\n\n### email notification\n\nsending email to users has not been integrated into this library. so for\nnow you need to implement it if needed. there is a reserved field\n`notification.emailed` to make it easier.\n\n### sample app\n\na sample app has been implemented in\n`notifications/tests/sample_notifications` that extends\n`django-notifications` with the sole purpose of testing its\nextensibility. you can run the sample app by setting the environment\nvariable `sample_app` as follows\n\n```bash\nexport sample_app=1\n# run the django development server with sample_notifications app installed\npython manage.py runserver\n# unset sample_app to remove sample_notifications app from list of installed_apps\nunset sample_app\n```\n\n## `django-notifications` team\n\ncore contributors (in alphabetical order):\n\n-   [alvaro leonel](https://github.com/alvarolqueiroz)\n-   [federico capoano](https://github.com/nemesisdesign)\n-   [samuel spencer](https://github.com/legostormtroopr)\n-   [yang yubo](https://github.com/yangyubo)\n-   [ypcrumble](https://github.com/ypcrumble)\n-   [zhongyuan zhang](https://github.com/zhang-z)\n\n## contribute\n\nwe are looking for contributors, for anyone who\\'d like to contribute\nand willing to put time and energy on this project, please contact [yang\nyubo](https://github.com/yangyubo).\n",
  "docs_url": null,
  "keywords": "django notifications github action event stream",
  "license": "mit",
  "name": "django-notifications-hq",
  "package_url": "https://pypi.org/project/django-notifications-hq/",
  "project_url": "https://pypi.org/project/django-notifications-hq/",
  "project_urls": {
    "Homepage": "http://github.com/django-notifications/django-notifications"
  },
  "release_url": "https://pypi.org/project/django-notifications-hq/1.8.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "github notifications alike app for django.",
  "version": "1.8.3",
  "releases": [],
  "developers": [
    "django",
    "yang@yangyubo.com"
  ],
  "kwds": "django_notifications_config notifications_notification_model notifications_tags notifications sample_notifications",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_django_notifications_hq",
  "homepage": "http://github.com/django-notifications/django-notifications",
  "release_count": 19,
  "dependency_ids": []
}