{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "framework :: django :: 4.1",
    "framework :: django :: 4.2",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http",
    "topic :: software development :: libraries :: application frameworks",
    "topic :: software development :: libraries :: python modules",
    "typing :: typed"
  ],
  "description": "dataclasses serializer\n======================\n\na `dataclasses <https://docs.python.org/3/library/dataclasses.html>`__ serializer for the `django rest framework\n<http://www.django-rest-framework.org/>`__.\n\n.. image:: https://github.com/oxan/djangorestframework-dataclasses/workflows/ci/badge.svg\n   :target: https://github.com/oxan/djangorestframework-dataclasses/actions?query=workflow%3aci\n.. image:: https://codecov.io/gh/oxan/djangorestframework-dataclasses/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/oxan/djangorestframework-dataclasses\n.. image:: https://badge.fury.io/py/djangorestframework-dataclasses.svg\n   :target: https://badge.fury.io/py/djangorestframework-dataclasses\n.. image:: https://img.shields.io/static/v1?label=sponsor&message=%e2%9d%a4&logo=github&color=success\n   :target: https://github.com/sponsors/oxan\n\n|\n\n.. contents:: :local:\n\nrequirements\n------------\n\n* python (3.8+)\n* django (3.2+)\n* django rest framework (3.11+)\n\nthese are the supported python and package versions. older versions will probably work as well, but aren't tested.\n\ninstallation\n------------\n\n::\n\n    $ pip install djangorestframework-dataclasses\n\nthis package follows `semantic versioning`_. see `changelog`_ for breaking changes and new features, and `license`_ for\nthe complete license (bsd-3-clause).\n\n.. _`semantic versioning`: https://semver.org/\n.. _`changelog`: https://github.com/oxan/djangorestframework-dataclasses/blob/master/changelog.rst\n.. _`license`: https://github.com/oxan/djangorestframework-dataclasses/blob/master/license\n\nbasic usage\n-----------\n\nthe package provides the ``dataclassserializer`` serializer, defined in the ``rest_framework_dataclasses.serializers``\nnamespace.\n\n.. code:: python\n\n    from rest_framework_dataclasses.serializers import dataclassserializer\n\nthis serializer provides a shortcut that lets you automatically create a ``serializer`` class with fields that\ncorrespond to the fields on a dataclass. in usage, the ``dataclassserializer`` is the same as a regular ``serializer``\nclass, except that:\n\n* it will automatically generate fields for you, based on the declaration in the dataclass.\n* to make this possible it requires that a ``dataclass`` property is specified in the ``meta`` subclass, with as value\n  a dataclass that has type annotations.\n* it includes default implementations of ``.create()`` and ``.update()``.\n\nfor example, define a dataclass as follows:\n\n.. code:: python\n\n    @dataclass\n    class person:\n        name: str\n        email: str\n        alive: bool\n        gender: typing.literal['male', 'female']\n        birth_date: typing.optional[datetime.date]\n        phone: typing.list[str]\n        movie_ratings: typing.dict[str, int]\n\nthe serializer for this dataclass can now trivially be defined without having to duplicate all fields:\n\n.. code:: python\n\n    class personserializer(dataclassserializer):\n        class meta:\n            dataclass = person\n\n    # is equivalent to\n    class personserializer(serializer):\n        name = fields.charfield()\n        email = fields.charfield()\n        alive = fields.booleanfield()\n        gender = fields.choicefield(choices=['male', 'female'])\n        birth_date = fields.datefield(allow_null=true)\n        phone = fields.listfield(child=fields.charfield())\n        movie_ratings = fields.dictfield(child=fields.integerfield())\n\nyou can add extra fields or override default fields by declaring them explicitly on the class, just as you would for a\nregular ``serializer`` class. this allows to specify extra field options or change a field type.\n\n.. code:: python\n\n    class personserializer(serializer):\n        email = fields.emailfield()\n\n        class meta:\n            dataclass = person\n\ndataclass serializers behave in the same way and can be used in the same places as the built-in serializers from django\nrest framework: you can retrieve the serialized representation using the ``.data`` property, and the deserialized\ndataclass instance using the ``.validated_data`` property. furthermore, the ``save()`` method is implemented to create\nor update an existing dataclass instance. you can find more information on serializer usage in the\n`django rest framework <https://www.django-rest-framework.org/api-guide/serializers/>`__ documentation.\n\nnote that this usage pattern is very similar to that of the built-in ``modelserializer``. this is intentional, with the\nwhole api modelled after that of ``modelserializer``. most features and behaviour known from ``modelserializer`` applies\nto dataclass serializers as well.\n\nfield mapping\n-------------\n\ncurrently, automatic field generation is supported for the following types and their subclasses:\n\n* ``str``, ``bool``, ``int`` and ``float``.\n* ``date``, ``datetime``, ``time`` and ``timedelta`` from the ``datetime`` package.\n* ``decimal.decimal`` (``max_digits`` and ``decimal_places`` default to ``none`` and ``2`` respectively).\n* ``uuid.uuid``\n* ``enum.enum`` (mapped to a ``enumfield``)\n* ``typing.iterable`` (including ``typing.list`` and `pep 585`_-style generics such as ``list[int]``).\n* ``typing.mapping`` (including ``typing.dict`` and `pep 585`_-style generics such as ``dict[str, int]``).\n* ``typing.literal`` (mapped to a ``choicefield``).\n* ``typing.union`` (mapped to a ``unionfield``, including `pep 604`_-style unions such as ``str | int``, see\n  `unionfield`_ section below for more information).\n* ``django.db.model``\n\nthe serializer also supports type variables that have an upper bound or are constrained.\n\ncustomize field generation\n--------------------------\n\nthe auto-generated serializer fields are configured based on type qualifiers in the dataclass (these can be mixed):\n\n* fields with a default value (factory) are marked as optional on the serializer (``required=false``). this means that\n  these fields don't need to be supplied during deserialization.\n\n* fields marked as nullable through ``typing.optional``, ``typing.union[x, none]`` or ``x | none`` (`pep 604`_) are\n  marked as nullable on the serializer (``allow_null=true``). this means that ``none`` is accepted as a valid value\n  during deserialization.\n\n* fields marked as final through ``typing.final`` (as in `pep 591`_) are marked as read-only on the serializer\n  (``read_only=true``).\n\n.. code:: python\n\n    @dataclass\n    class person:\n        birth_date: typing.optional[datetime.date]\n        alive: bool = true\n        species: typing.final[str] = 'human'\n\n    # the autogenerated serializer will be equal to\n    class personserializer(serializer):\n        birth_date = fields.datefield(allow_null=true)\n        alive = fields.booleanfield(required=false)\n        species = fields.charfield(read_only=true)\n\nbesides overriding fields by declaring them explicitly on the serializer, you can also change or override the generated\nserializer field using metadata on the dataclass field. currently, two keys are recognized in this dictionary:\n\n* ``serializer_field`` can be used to replace the auto-generated field with a user-supplied one. should contain an\n  instance of a field, not a field type.\n\n* ``serializer_kwargs`` can be used to specify arbitrary additional keyword arguments for the generated field. manually\n  specified arguments will have precedence over generated arguments (so e.g. by supplying ``{required: true}``, a field\n  with a default value can be made required).\n\n.. code:: python\n\n    @dataclasses.dataclass\n    class person:\n        email: str = dataclasses.field(metadata={'serializer_field': fields.emailfield()})\n        age: int = dataclasses.field(metadata={'serializer_kwargs': {'min_value': 0}})\n\n    # the autogenerated serializer will be equal to\n    class personserializer(serializer):\n        email = fields.emailfield()\n        age = fields.integerfield(min_value=0)\n\nto further customize the serializer, the ``dataclassserializer`` accepts the following options in the ``meta``\nsubclass. all options have the same behaviour as the identical options in ``modelserializer``.\n\n* ``dataclass`` specifies the type of dataclass used by the serializer. this is equivalent to the ``model`` option in\n  ``modelserializer``.\n\n* ``fields`` and ``exclude`` can be used to specify which fields should respectively be included and excluded in the\n  serializer. these cannot both be specified.\n\n  the ``fields`` option accepts the magic value ``__all__`` to specify that all fields on the dataclass should be used.\n  this is also the default value, so it is not mandatory to specify either ``fields`` or ``exclude``.\n\n* ``read_only_fields`` can be used to mark a subset of fields as read-only.\n\n* ``extra_kwargs`` can be used to specify arbitrary additional keyword arguments on fields. this can be useful to\n  extend or change the autogenerated field without explicitly declaring the field on the serializer. this option should\n  be a dictionary, mapping field names to a dictionary of keyword arguments.\n\n  if the autogenerated field is a composite field (a list or dictionary), the arguments are applied to the composite\n  field. to add keyword arguments to the composite field's child field (that is, the field used for the items in the\n  list or dictionary), they should be specified as a nested dictionary under the ``child_kwargs`` name (see\n  `nested dataclasses`_ section below for an example).\n\n  .. code:: python\n\n    class personserializer(dataclassserializer):\n        class meta:\n            extra_kwargs = {\n                'height': { 'decimal_places': 1 },\n                'movie_ratings': { 'child_kwargs': { 'min_value': 0, 'max_value': 10 } }\n            }\n\n* ``validators`` functionality is unchanged.\n\n* ``depth`` (as known from ``modelserializer``) is not supported, it will always nest infinitely deep.\n\nchanging default behaviour\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nadditionally, it is possible to change the default behaviour of the ``dataclassserializer`` by setting one of these\nproperties on the class:\n\n* the ``serializer_field_mapping`` property contains a dictionary that maps types to rest framework serializer classes.\n  you can override or extend this mapping to change the serializer field classes that are used for fields based on\n  their type. this dictionary also accepts dataclasses as keys to change the serializer used for a nested dataclass.\n\n* the ``serializer_related_field`` property is the serializer field class that is used for relations to models.\n\n* the ``serializer_union_field`` property is the serializer field class that is used for union types.\n\n* the ``serializer_dataclass_field`` property is the serializer field class that is used for nested dataclasses. note\n  that since python process the class body before it defines the class, this property is implemented using the\n  `property decorator`_ to allow it to reference the containing class.\n\nfinally, you can create a subclass that overrides methods of the ``dataclassserializer``. the field generation is\ncontrolled by the following methods, which are considered a stable part of the api:\n\n* the ``build_unknown_field()`` method is called to create serializer fields for dataclass fields that are not\n  understood. by default this just throws an error, but you can extend this with custom logic to create serializer\n  fields.\n\n* the ``build_property_field()`` method is called to create serializer fields for methods. by default this creates a\n  read-only field with the method return value.\n\n* the ``build_standard_field()``, ``build_relational_field()``, ``build_dataclass_field()``, ``build_union_field()``,\n  ``build_enum_field()``, ``build_literal_field()`` and ``build_composite_field()`` methods are used to process\n  respectively fields, nested models, nested dataclasses, union types, enums, literals, and lists or dictionaries. these\n  can be overridden to change the field generation logic.\n\nnote that when creating a subclass of ``dataclassserializer``, most likely you will want to set the\n``serializer_dataclass_field`` property to the subclass, so that any nested dataclasses are serialized using the\nsubclass as well.\n\n.. code:: python\n\n    class customdataclassserializer(dataclassserializer):\n        @property\n        def serializer_dataclass_field(self):\n            return customdataclassserializer\n\n        # implement additional and/or override existing methods here\n\n.. _`pep 591`: https://www.python.org/dev/peps/pep-0591/\n.. _`pep 585`: https://www.python.org/dev/peps/pep-0585/\n.. _`pep 604`: https://www.python.org/dev/peps/pep-0604/\n.. _`property decorator`: https://docs.python.org/3/library/functions.html#property\n\nnesting\n-------\n\nnested dataclasses\n~~~~~~~~~~~~~~~~~~\n\nif your dataclass has a field that also contains a dataclass instance, the ``dataclassserializer`` will automatically\ncreate another ``dataclassserializer`` for that field, so that its value will be nested. this also works for dataclasses\ncontained in lists or dictionaries, or even several layers deep.\n\n.. code:: python\n\n    @dataclass\n    class house:\n        address: str\n        owner: person\n        residents: typing.list[person]\n\n    class houseserializer(dataclassserializer):\n        class meta:\n            dataclass = house\n\nthis will serialize as:\n\n.. code:: python\n\n    >>> serializer = houseserializer(instance=house)\n    >>> serializer.data\n    {\n        'address': 'main street 5',\n        'owner': { 'name': 'alice' }\n        'residents': [\n            { 'name': 'alice', 'email': 'alice@example.org', ... },\n            { 'name': 'bob', 'email': 'bob@example.org', ... },\n            { 'name': 'charles', 'email': 'charles@example.org', ... }\n        ]\n    }\n\nthis does not give the ability to customize the field generation of the nested dataclasses. if that is needed, you\nshould declare the serializer to be used for the nested field explicitly. alternatively, you could use the\n``extra_kwargs`` option to provide arguments to fields belonging to the nested dataclasses. consider the following:\n\n.. code:: python\n\n    @dataclass\n    class transaction:\n       amount: decimal\n       account_number: str\n\n    @dataclass\n    class company:\n       sales: list[transaction]\n\nin order to tell drf to give 2 decimal places to the transaction account number, write the serializer as follows:\n\n.. code:: python\n\n    class companyserializer(dataclassserializer):\n        class meta:\n            dataclass = company\n\n            extra_kwargs = {\n                'sales': {\n                    # arguments here are for the listfield generated for the sales field on company\n                    'min_length': 1,   # requires at least 1 item to be present in the sales list\n                    'child_kwargs': {\n                        # arguments here are passed to the dataclassserializer for the transaction dataclass\n                        'extra_kwargs': {\n                            # arguments here are the extra arguments for the fields in the transaction dataclass\n                            'amount': {\n                                'max_digits': 6,\n                                'decimal_places': 2\n                            }\n                        }\n                    }\n                }\n            }\n\nnesting models\n~~~~~~~~~~~~~~\n\nlikewise, if your dataclass has a field that contains a django model, the ``dataclassserializer`` will automatically\ngenerate a relational field for you.\n\n.. code:: python\n\n    class company(models.model):\n        name = models.charfield()\n\n    @dataclass\n    class person:\n        name: str\n        employer: company\n\nthis will serialize as:\n\n.. code:: python\n\n    >>> serializer = personserializer(instance=user)\n    >>> print(repr(serializer))\n    personserializer():\n        name = fields.charfield()\n        employer = fields.primarykeyrelatedfield(queryset=company.objects.all())\n    >>> serializer.data\n    {\n        \"name\": \"alice\",\n        \"employer\": 1\n    }\n\nif you want to nest the model in the serialized representation, you should specify the model serializer to be used by\ndeclaring the field explicitly.\n\nif you prefer to use hyperlinks to represent relationships rather than primary keys, in the same package you can find\nthe ``hyperlinkeddataclassserializer`` class: it generates a ``hyperlinkedrelatedfield`` instead of a\n``primarykeyrelatedfield``.\n\nnew serializer field types\n--------------------------\nto handle some types for which drf does not ship a serializer field, some new serializer field types are shipped in the\n``rest_framework_dataclasses.fields`` namespace. these fields can be used independently of the ``dataclassserializer``\nas well.\n\ndefaultdecimalfield\n~~~~~~~~~~~~~~~~~~~\na subclass of `decimalfield`_ that defaults ``max_digits`` to ``none`` and ``decimal_places`` to 2. used to represent\ndecimal values which there is no explicit field configured.\n\nenumfield\n~~~~~~~~~\na subclass of `choicefield`_ to represent python `enumerations`_. the enumeration members can be represented by either\ntheir name or value. the member name is used as display name.\n\n**signature**: ``enumfield(enum_class, by_name=false)``\n\n* ``enum_class``: the enumeration class.\n* ``by_name``: whether members are represented by their value (``false``) or name (``true``).\n\niterablefield\n~~~~~~~~~~~~~\na subclass of `listfield`_ that can return values that aren't of type ``list``, such as ``set``.\n\n**signature**: ``iterablefield(container=list)``\n\n* ``container``: the type of the returned iterable. must have a constructor that accepts a single parameter of type\n  ``list``, containing the values for the iterable.\n\nmappingfield\n~~~~~~~~~~~~\na subclass of `dictfield`_ that can return values that aren't of type ``dict``, such as ``collections.ordereddict``.\n\n**signature**: ``mappingfield(container=dict)``\n\n* ``container``: the type of the returned mapping. must have a constructor that accepts a single parameter of type\n  ``dict``, containing the values for the mapping.\n\nunionfield\n~~~~~~~~~~\na field that can serialize and deserialize values of multiple types (i.e. values of a union type). the serialized\nrepresentation of this field includes an extra discriminator field (by default named ``type``) that indicates the actual\ntype of the value.\n\n.. code:: python\n\n    @dataclass\n    class a:\n        a: str\n\n    @dataclass\n    class b:\n        b: int\n\n    @dataclass\n    class response:\n        obj: a | b\n\n    class responseserializer(dataclassserializer):\n        class meta:\n            dataclass = response\n\n.. code:: python\n\n    >>> response = response(obj=a('hello'))\n    >>> serializer = responseserializer(instance=response)\n    >>> serializer.data\n    {\n        'obj': {'type': 'a', 'a': 'hello'}\n    }\n    >>> deserializer = responseserializer(data={'obj': {'type': 'b', 'b': 42}})\n    >>> deserializer.is_valid()\n    true\n    >>> deserializer.validated_data\n    response(obj=b(b=42))\n\nthe name of the discriminator field can be changed by setting the ``discriminator_field_name`` keyword argument for the\nfield:\n\n.. code:: python\n\n    @dataclass\n    class response:\n        obj: a | b = dataclasses.field(metadata={'serializer_kwargs': {'discriminator_field_name': 'a_or_b'}})\n\n    # or:\n    class responseserializer(dataclassserializer):\n        class meta:\n            dataclass = response\n            extra_kwargs = {\n                'obj': {'discriminator_field_name': 'a_or_b'}\n            }\n\nunions containing a type that does not serialize to a mapping (e.g. an integer or string) can be serialized by enabling\nnesting with the ``nest_value`` keyword argument:\n\n.. code:: python\n\n    @dataclass\n    class response:\n        amount: int | float\n\n    class responseserializer(dataclassserializer):\n        class meta:\n            dataclass = response\n            extra_kwargs = {\n                'amount': {'nest_value': true}\n            }\n\n.. code:: python\n\n    >>> response = response(amount=42)\n    >>> serializer = responseserializer(instance=response)\n    >>> serializer.data\n    {\n        'amount': {'type': 'int', 'value': 42}\n    }\n\n**signature**: ``unionfield(child_fields, nest_value=false, discriminator_field_name=none, value_field_name=none)``.\n\n* ``child_fields``: a dictionary mapping the individual types to the serializer field to be used for them.\n* ``nest_value``: whether the value should be put under a key (``true``), or merged directly into the serialized\n  representation of this field (``false``). this is disabled by default, and should usually only be set to ``true`` if\n  any of the union member types is a primitive.\n* ``discriminator_field_name``: name of the discriminator field, defaults to ``type``.\n* ``value_field_name``: name of the field under which values are nested if ``nest_value`` is used defaults to ``value``.\n\nthe values used in the discriminator field can be changed by subclassing ``unionfield`` and overriding the\n``get_discriminator(self, type)`` method. the lone argument to this method is one of the member types of union (a key\nfrom the ``child_fields`` parameter), and it should return the appropriate string to be used in the discriminator field\nfor values of this type.\n\n.. _`enumerations`: https://docs.python.org/3/library/enum.html\n.. _`choicefield`: https://www.django-rest-framework.org/api-guide/fields/#choicefield\n.. _`decimalfield`: https://www.django-rest-framework.org/api-guide/fields/#decimalfield\n.. _`listfield`: https://www.django-rest-framework.org/api-guide/fields/#listfield\n.. _`dictfield`: https://www.django-rest-framework.org/api-guide/fields/#dictfield\n\nadvanced usage\n--------------\n\n* the output of methods or properties on the dataclass can be included as a (read-only) field in the serialized state\n  by adding their name to the ``fields`` option in the ``meta`` class.\n\n* if you don't need to customize the generated fields, ``dataclassserializer`` can also be used directly without\n  creating a subclass. in that case, the dataclass should be specified using the ``dataclass`` constructor parameter:\n\n  .. code:: python\n\n    serializer = dataclassserializer(data=request.data, dataclass=person)\n\n* partial updates are supported by setting the ``partial`` argument to ``true``. nested dataclasses will also be\n  partially updated, but nested fields and dictionaries will be replaced in full with the supplied value:\n\n  .. code:: python\n\n    @dataclass\n    class company:\n        name: str\n        location: optional[str] = none\n\n    @dataclass\n    class person:\n        name: str\n        current_employer: company\n        past_employers: list[company]\n\n    alice = person(name='alice',\n                   current_employer=company('acme corp.', 'new york city'),\n                   past_employers=[company('psf', 'delaware'), company('ministry of silly walks', 'london')])\n\n    data = {'current_employer': {'location': 'los angeles'}, 'past_employers': [{'name': 'oscorp', 'location': 'nyc'}]}\n\n    >>> serializer = personserializer(partial=true, instance=alice, data=data)\n    >>> print(serializer.save())\n    person(name='alice',\n           current_employer=company('acme corp.', 'los angeles'),\n           past_employers=[company(name='oscorp', location='nyc')])\n\n* if you override the ``create()`` or ``update()`` methods, the dataclass instance passed in the ``validated_data``\n  argument will have the special ``rest_framework.fields.empty`` value for any fields for which no data was provided.\n  this is required to distinguish between not-provided fields and fields with the default value, as needed for (both\n  regular and partial) updates. you can get rid of these ``empty`` markers and replace them with the default value by\n  calling the parent ``update()`` or ``create()`` methods - this is the only thing they do.\n\n  .. code:: python\n\n    class companyserializer(dataclassserializer):\n        def create(self, validated_data):\n            instance = super(companyserializer, self).create(validated_data)\n            # if no value is provided for location, these will both hold\n            assert validated_data.location == rest_framework.fields.empty\n            assert instance.location is none  # none is the default value of company.location (see previous example)\n\n  the ``validated_data`` property on the serializer has these ``empty`` markers stripped as well, and replaced with the\n  default values for not-provided fields. note that this means you cannot access ``validated_data`` on the serializer\n  for partial updates where no data has been provided for fields without a default value, an exception will be thrown.\n\nschemas\n-------\n\nstarting from version 0.21.2, `drf-spectacular`_ natively supports ``dataclassserializer``. for previous versions, you\ncan include the `extension`_ in your project manually. you don't need to configure it, but you do need to import the\nmodule that contains the extension.\n\n.. _`drf-spectacular`: https://github.com/tfranzel/drf-spectacular\n.. _`extension`: https://github.com/tfranzel/drf-spectacular/blob/master/drf_spectacular/contrib/rest_framework_dataclasses.py\n",
  "docs_url": null,
  "keywords": "",
  "license": "copyright (c) 2019-2021, oxan van leeuwen  redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  1. redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.  2. redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  3. neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.  this software is provided by the copyright holders and contributors \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. in no event shall the copyright holder or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage. ",
  "name": "djangorestframework-dataclasses",
  "package_url": "https://pypi.org/project/djangorestframework-dataclasses/",
  "project_url": "https://pypi.org/project/djangorestframework-dataclasses/",
  "project_urls": {
    "Changelog": "https://github.com/oxan/djangorestframework-dataclasses/blob/master/CHANGELOG.rst",
    "Documentation": "https://github.com/oxan/djangorestframework-dataclasses/blob/master/README.rst",
    "Repository": "https://github.com/oxan/djangorestframework-dataclasses",
    "Sponsor": "https://github.com/sponsors/oxan"
  },
  "release_url": "https://pypi.org/project/djangorestframework-dataclasses/1.3.1/",
  "requires_dist": [
    "django >=2.0",
    "djangorestframework >=3.9",
    "typing-extensions >=3.7.4 ; python_version < \"3.8\"",
    "django-stubs ; extra == 'dev'",
    "djangorestframework-stubs ; extra == 'dev'",
    "mypy ~=1.5.1 ; extra == 'dev'",
    "coverage[toml] ; extra == 'test'",
    "tox ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "a dataclasses serializer for django rest framework",
  "version": "1.3.1",
  "releases": [],
  "developers": [
    "oxan@oxanvanleeuwen.nl"
  ],
  "kwds": "djangorestframework serializer_dataclass_field serializer_related_field serializer_field rest_framework_dataclasses",
  "license_kwds": "copyright liability liable redistributions redistribution",
  "libtype": "pypi",
  "id": "pypi_djangorestframework_dataclasses",
  "homepage": "",
  "release_count": 16,
  "dependency_ids": [
    "pypi_coverage",
    "pypi_django",
    "pypi_django_stubs",
    "pypi_djangorestframework",
    "pypi_djangorestframework_stubs",
    "pypi_mypy",
    "pypi_tox",
    "pypi_typing_extensions"
  ]
}