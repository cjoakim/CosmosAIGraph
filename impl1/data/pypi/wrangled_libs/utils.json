{
  "classifiers": [
    "license :: osi approved :: gnu lesser general public license v3 or later (lgplv3+)",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "topic :: software development :: libraries"
  ],
  "description": "utils\n=====\n\n.. image:: https://travis-ci.org/haaksmash/pyutils.svg?branch=master\n    :target: https://travis-ci.org/haaksmash/pyutils\n\nsometimes you write a function over and over again; sometimes you look up at\nthe ceiling and ask \"why, guido, why isn't this included in the standard\nlibrary?\"\n\nwell, we perhaps can't answer that question. but we can collect those functions\ninto a centralized place!\n\nprovided things\n+++++++++++++++\n\nutils is broken up into broad swathes of functionality, to ease the task of\nremembering where exactly something lives.\n\nenum\n----\n\npython doesn't have a built-in way to define an enum, so this module provides (what i think) is a pretty clean way to go about them.\n\n.. code-block:: python\n\n    from utils import enum\n\n    class colors(enum.enum):\n        red = 0\n        green = 1\n\n        # defining an enum class allows you to specify a few\n        # things about the way it's going to behave.\n        class options:\n            frozen = true # can't change attributes\n            strict = true # can only compare to itself; i.e., colors.red == animals.cow\n                          # will raise an exception.\n\n    # or use the enum factory (no options, though)\n    colorsalso = enum.enum(\"red\", \"green\")\n\nonce defined, use is straightforward:\n\n.. code-block:: python\n\n    >>> colors\n    <class 'blahblah.colors'>\n    >>> colors.red\n    <enumitem: red [0]>\n    >>> colors.red == 0\n    true\n    >>> colors.red == colors.red\n    true\n    >>> colors.red = 2\n    traceback (most recent call last):\n      file \"<stdin>\", line 1, in <module>\n      file \"utils/enum.py\", line 114, in __setattr__\n        raise typeerror(\"can't set attributes on a frozen enum\")\n    typeerror: can't set attributes on a frozen enum\n\nmath\n----\n\ncurrently only has the multiplicative analogue of the built-in ``sum``.\n\ndicts\n-----\n\nintersections, differences, winnowing, a few specialized dicts...\n\nlists\n-----\n\nflatten and unlisting. also ``flat_map``!\n\nbools\n-----\n\ncurrently only provides an ``xor`` function.\n\ndates\n-----\n\nmostly cool for the ``timeperiod`` classes:\n\n.. code-block:: python\n\n    >>> from datetime import date # will also work with datetimes\n    >>> time_period = timeperiod(date(2013, 5, 10), date(2013, 8, 11))\n    >>> time_period\n    <timeperiod: 2013-05-10 00:00:00-2013-08-11 23:59:59>\n    >>> date(2013, 6, 12) in time_period\n    true\n    >>> other_time_period = timeperiod(date(2013, 6, 1), date(2013, 6, 30))\n    >>> other_time_period in time_period\n    true\n    >>> another_time_period = timeperiod(date(2013, 8, 1), date(2013, 8, 30))\n    >>> time_period.overlaps(another_time_period)\n    true\n    >>> timeperiod.get_containing_period(time_period, another_time_period)\n    <timeperiod: 2013-05-08 00:00:00-2013-08-30 23:59:59>\n\n\nand so on and so forth. there's also a ``discontinoustimeperiod`` class, which\nstores a collection of timeperiods.\n\nthere's also helper functions for common operations like ``days_ahead`` and\n``days_ago``, which pretty much do what they say on the tin.\n\nobjects\n-------\n\nprovides ``get_attr``, which is really just a convenient way to do deep ``getattr`` chaining:\n\n.. code-block:: python\n\n    >>> get_attr(complicated, 'this.is.a.deep.string', default=none)\n    \"the deep string\"  # or none, if anything in the lookup chain didn't exist\n\nthere's also an ``immutable`` utility, which will wrap an object and preven all attribute changes,\nrecursively by default. any attempt to set attributes on the wrapped object will raise an ``attributeerror``:\n\n.. code-block:: python\n\n    >>> imm = immutable(something)\n    >>> imm\n    <immutable something: <something>>\n    >>> imm.red\n    <immutable somethingelse: <somethingelse: red>>\n    >>> imm.red = somethingelse('blue')\n    # ...\n    attributeerror: this object has been marked as immutable; you cannot set its attributes.\n    >>> something.red = somethingelse('blue')\n    >>> imm.red\n    <immutable somethingelse: <somethingelse: blue>>\n\nyou can toggle the recursive immutability by specifying the 'recursive' flag.\n\ninstallation (via pip)\n++++++++++++++++++++++\n\n    pip install utils\n\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "utils",
  "package_url": "https://pypi.org/project/utils/",
  "project_url": "https://pypi.org/project/utils/",
  "project_urls": {
    "Homepage": "http://github.com/haaksmash/pyutils"
  },
  "release_url": "https://pypi.org/project/utils/1.0.1/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "a grab-bag of utility functions and objects",
  "version": "1.0.1",
  "releases": [],
  "developers": [
    "haak.erling@gmail.com",
    "haak_saxberg"
  ],
  "kwds": "enum pyutils python module colors",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_utils",
  "homepage": "http://github.com/haaksmash/pyutils",
  "release_count": 11,
  "dependency_ids": []
}