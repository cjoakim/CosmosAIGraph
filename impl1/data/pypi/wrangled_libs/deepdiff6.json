{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development"
  ],
  "description": "# deepdiff v 6.2.0\n\n![downloads](https://img.shields.io/pypi/dm/deepdiff.svg?style=flat)\n![python versions](https://img.shields.io/pypi/pyversions/deepdiff.svg?style=flat)\n![license](https://img.shields.io/pypi/l/deepdiff.svg?version=latest)\n[![build status](https://github.com/seperman/deepdiff/workflows/unit%20tests/badge.svg)](https://github.com/seperman/deepdiff/actions)\n[![codecov](https://codecov.io/gh/seperman/deepdiff/branch/master/graph/badge.svg?token=kkhz3sia3m)](https://codecov.io/gh/seperman/deepdiff)\n\n## deepdiff overview\n\n- deepdiff: deep difference of dictionaries, iterables, strings and other objects. it will recursively look for all the changes.\n- deepsearch: search for objects within other objects.\n- deephash: hash any object based on their content.\n\ntested on python 3.7+ and pypy3.\n\n- **[documentation](https://zepworks.com/deepdiff/6.2.0/)**\n\n## what is new?\n\ndeepdiff 6-2-0\n\n- major improvement in the diff report for lists when items are all hashable and the order of items is important.\n\ndeepdiff 6-1-0\n\n- deepdiff.affected_paths can be used to get the list of all paths where a change, addition, or deletion was reported for.\n- deepdiff.affected_root_keys can be used to get the list of all paths where a change, addition, or deletion was reported for.  \n- bugfix: valueerror when using decimal 0.x #339  by [enric pou](https://github.com/epou)\n- serialization of uuid \n\ndeepdiff 6-0-0\n\n- [exclude obj callback strict](https://github.com/seperman/deepdiff/pull/320/files) parameter is added to deepdiff by mikhail khviyuzov [mskhviyu](https://github.com/mskhviyu).\n- a fix for diffing using `iterable_compare_func` with nested objects by [dtorres-sf](https://github.com/dtorres-sf) who originally contributed this feature.\n- temporarily we are publishing deepdiff under `deepdiff6` on pypi until further notice.\n\nnote: there are no breaking changes in deepdiff 6 compared to the latest deepdiff 5 releases.\n\n## installation\n\n### install from pypi:\n\n`pip install deepdiff6`\n\nif you want to use deepdiff from commandline:\n\n`pip install \"deepdiff6[cli]\"`\n\n\n> note: prior to deepdiff 6, it was published under deepdiff name on pypi.\n> deepdiff 6 is being published under deepdiff6 package name on pypi temporarily until further notice.\n\n\n### importing\n\n```python\n>>> from deepdiff import deepdiff  # for deep difference of 2 objects\n>>> from deepdiff import grep, deepsearch  # for finding if item exists in an object\n>>> from deepdiff import deephash  # for hashing objects based on their contents\n```\n\nnote: if you want to use deepdiff via commandline, make sure to run `pip install \"deepdiff6[cli]\"`. then you can access the commands via:\n\n- deepdiff\n    - `$ deep diff --help`\n- delta\n    - `$ deep patch --help`\n- grep\n    - `$ deep grep --help`\n- extract\n    - `$ deep extract --help`\n\n# deep diff\n\ndeepdiff gets the difference of 2 objects.\n\n> - please take a look at the [deepdiff docs](https://zepworks.com/deepdiff/6.2.0/diff.html)\n> - the full documentation of all modules can be found on <https://zepworks.com/deepdiff/6.2.0/>\n> - tutorials and posts about deepdiff can be found on <https://zepworks.com/tags/deepdiff/>\n\n## a few examples\n\n> note: this is just a brief overview of what deepdiff can do. please visit <https://zepworks.com/deepdiff/6.2.0/> for full documentation.\n\n### list difference ignoring order or duplicates\n\n```python\n>>> t1 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 2, 3]}}\n>>> t2 = {1:1, 2:2, 3:3, 4:{\"a\":\"hello\", \"b\":[1, 3, 2, 3]}}\n>>> ddiff = deepdiff(t1, t2, ignore_order=true)\n>>> print (ddiff)\n{}\n```\n\n### report repetitions\n\nthis flag only works when ignoring order is enabled.\n\n```python\nt1 = [1, 3, 1, 4]\nt2 = [4, 4, 1]\nddiff = deepdiff(t1, t2, ignore_order=true, report_repetition=true)\nprint(ddiff)\n```\n\nwhich will print you:\n\n```python\n{'iterable_item_removed': {'root[1]': 3},\n  'repetition_change': {'root[0]': {'old_repeat': 2,\n                                    'old_indexes': [0, 2],\n                                    'new_indexes': [2],\n                                    'value': 1,\n                                    'new_repeat': 1},\n                        'root[3]': {'old_repeat': 1,\n                                    'old_indexes': [3],\n                                    'new_indexes': [0, 1],\n                                    'value': 4,\n                                    'new_repeat': 2}}}\n```\n\n### exclude certain types from comparison:\n\n```python\n>>> l1 = logging.getlogger(\"test\")\n>>> l2 = logging.getlogger(\"test2\")\n>>> t1 = {\"log\": l1, 2: 1337}\n>>> t2 = {\"log\": l2, 2: 1337}\n>>> print(deepdiff(t1, t2, exclude_types={logging.logger}))\n{}\n```\n\n### exclude part of your object tree from comparison\n\n```python\n>>> t1 = {\"for life\": \"vegan\", \"ingredients\": [\"no meat\", \"no eggs\", \"no dairy\"]}\n>>> t2 = {\"for life\": \"vegan\", \"ingredients\": [\"veggies\", \"tofu\", \"soy sauce\"]}\n>>> print (deepdiff(t1, t2, exclude_paths={\"root['ingredients']\"}))\n{}\n```\n\n### exclude regex paths\n\n\nyou can also exclude using regular expressions by using `exclude_regex_paths` and pass a set or list of path regexes to exclude. the items in the list could be raw regex strings or compiled regex objects.\n\n```python\n>>> t1 = [{'a': 1, 'b': 2}, {'c': 4, 'b': 5}]\n>>> t2 = [{'a': 1, 'b': 3}, {'c': 4, 'b': 5}]\n>>> print(deepdiff(t1, t2, exclude_regex_paths={r\"root\\[\\d+\\]\\['b'\\]\"}))\n{}\n>>> exclude_path = re.compile(r\"root\\[\\d+\\]\\['b'\\]\")\n>>> print(deepdiff(t1, t2, exclude_regex_paths=[exclude_path]))\n{}\n```\n\n### significant digits\n\ndigits **after** the decimal point. internally it uses \"{:.xf}\".format(your number) to compare numbers where x=significant_digits\n\n```python\n>>> t1 = decimal('1.52')\n>>> t2 = decimal('1.57')\n>>> deepdiff(t1, t2, significant_digits=0)\n{}\n>>> deepdiff(t1, t2, significant_digits=1)\n{'values_changed': {'root': {'old_value': decimal('1.52'), 'new_value': decimal('1.57')}}}\n```\n\n### ignore type number - list that contains float and integer:\n\n```py\n>>> from deepdiff import deepdiff\n>>> from pprint import pprint\n>>> t1 = [1, 2, 3]\n>>> t2 = [1.0, 2.0, 3.0]\n>>> ddiff = deepdiff(t1, t2)\n>>> pprint(ddiff, indent=2)\n{ 'type_changes': { 'root[0]': { 'new_type': <class 'float'>,\n                         'new_value': 1.0,\n                         'old_type': <class 'int'>,\n                         'old_value': 1},\n            'root[1]': { 'new_type': <class 'float'>,\n                         'new_value': 2.0,\n                         'old_type': <class 'int'>,\n                         'old_value': 2},\n            'root[2]': { 'new_type': <class 'float'>,\n                         'new_value': 3.0,\n                         'old_type': <class 'int'>,\n                         'old_value': 3}}}\n>>> ddiff = deepdiff(t1, t2, ignore_type_in_groups=[(int, float)])\n{}\n```\n\n## views\n\nstarting with deepdiff v 3, there are two different views into your diffed data: text view (original) and tree view (new).\n\n### text view\n\ntext view is the original and currently the default view of deepdiff.\n\nit is called text view because the results contain texts that represent the path to the data:\n\nexample of using the text view.\n\n```python\n>>> from deepdiff import deepdiff\n>>> t1 = {1:1, 3:3, 4:4}\n>>> t2 = {1:1, 3:3, 5:5, 6:6}\n>>> ddiff = deepdiff(t1, t2)\n>>> print(ddiff)\n{'dictionary_item_added': {'root[5]', 'root[6]'}, 'dictionary_item_removed': {'root[4]'}}\n```\n\nso for example `ddiff['dictionary_item_removed']` is a set if strings thus this is called the text view.\n\n    the following examples are using the *default text view.*\n    the tree view is introduced in deepdiff v3\n    and provides traversing capabilities through your diffed data and more!\n    read more about the tree view at the [tree view section](#tree-view) of this page.\n\n\n### tree view\n\nstarting the version v3 you can choose the view into the deepdiff results.\nthe tree view provides you with tree objects that you can traverse through to find the parents of the objects that are diffed and the actual objects that are being diffed.\n\n\n#### value of an item has changed (tree view)\n\n```python\n>>> from deepdiff import deepdiff\n>>> from pprint import pprint\n>>> t1 = {1:1, 2:2, 3:3}\n>>> t2 = {1:1, 2:4, 3:3}\n>>> ddiff_verbose0 = deepdiff(t1, t2, verbose_level=0, view='tree')\n>>> ddiff_verbose0\n{'values_changed': {<root[2]>}}\n>>>\n>>> ddiff_verbose1 = deepdiff(t1, t2, verbose_level=1, view='tree')\n>>> ddiff_verbose1\n{'values_changed': {<root[2] t1:2, t2:4>}}\n>>> set_of_values_changed = ddiff_verbose1['values_changed']\n>>> # since set_of_values_changed includes only one item in a set\n>>> # in order to get that one item we can:\n>>> (changed,) = set_of_values_changed\n>>> changed  # another way to get this is to do: changed=list(set_of_values_changed)[0]\n<root[2] t1:2, t2:4>\n>>> changed.t1\n2\n>>> changed.t2\n4\n>>> # you can traverse through the tree, get to the parents!\n>>> changed.up\n<root t1:{1: 1, 2: 2,...}, t2:{1: 1, 2: 4,...}>\n```\n\n### serialization\n\nin order to convert the deepdiff object into a normal python dictionary, use the to_dict() method.\nnote that to_dict will use the text view even if you did the diff in tree view.\n\nexample:\n\n```python\n>>> t1 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": [1, 2, 3]}}\n>>> t2 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": \"world\\n\\n\\nend\"}}\n>>> ddiff = deepdiff(t1, t2, view='tree')\n>>> ddiff.to_dict()\n{'type_changes': {\"root[4]['b']\": {'old_type': <class 'list'>, 'new_type': <class 'str'>, 'old_value': [1, 2, 3], 'new_value': 'world\\n\\n\\nend'}}}\n```\n\nin order to do safe json serialization, use the to_json() method.\n\nexample:\n\n```python\n>>> t1 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": [1, 2, 3]}}\n>>> t2 = {1: 1, 2: 2, 3: 3, 4: {\"a\": \"hello\", \"b\": \"world\\n\\n\\nend\"}}\n>>> ddiff = deepdiff(t1, t2, view='tree')\n>>> ddiff.to_json()\n'{\"type_changes\": {\"root[4][\\'b\\']\": {\"old_type\": \"list\", \"new_type\": \"str\", \"old_value\": [1, 2, 3], \"new_value\": \"world\\\\n\\\\n\\\\nend\"}}}'\n```\n\n\n> - please take a look at the [deepdiff docs](https://zepworks.com/deepdiff/6.2.0/diff.html)\n> - the full documentation can be found on <https://zepworks.com/deepdiff/6.2.0/>\n\n\n# deep search\n\ndeepdiff comes with a utility to find the path to the item you are looking for.\nit is called deepsearch and it has a similar interface to deepdiff.\n\nlet's say you have a huge nested object and want to see if any item with the word `somewhere` exists in it.\njust grep through your objects as you would in shell!\n\n```py\nfrom deepdiff import grep\nobj = {\"long\": \"somewhere\", \"string\": 2, 0: 0, \"somewhere\": \"around\"}\nds = obj | grep(\"somewhere\")\nprint(ds)\n```\n\nwhich will print:\n\n```py\n{'matched_paths': {\"root['somewhere']\"},\n 'matched_values': {\"root['long']\"}}\n```\n\nand you can pass all the same kwargs as deepsearch to grep too:\n\n```py\n>>> obj | grep(item, verbose_level=2)\n{'matched_paths': {\"root['somewhere']\": 'around'}, 'matched_values': {\"root['long']\": 'somewhere'}}\n```\n\n> - please take a look at the [deepsearch docs](https://zepworks.com/deepdiff/6.2.0/dsearch.html)\n> - the full documentation can be found on <https://zepworks.com/deepdiff/6.2.0/>\n\n# deep hash\n(new in v4-0-0)\n\ndeephash is designed to give you hash of any python object based on its contents even if the object is not considered hashable!\ndeephash is supposed to be deterministic in order to make sure 2 objects that contain the same data, produce the same hash.\n\n> - please take a look at the [deephash docs](https://zepworks.com/deepdiff/6.2.0/deephash.html)\n> - the full documentation can be found on <https://zepworks.com/deepdiff/6.2.0/>\n\nlet's say you have a dictionary object.\n\n```py\n>>> from deepdiff import deephash\n>>>\n>>> obj = {1: 2, 'a': 'b'}\n```\n\nif you try to hash it:\n\n```py\n>>> hash(obj)\ntraceback (most recent call last):\n  file \"<stdin>\", line 1, in <module>\ntypeerror: unhashable type: 'dict'\n```\n\nbut with deephash:\n\n```py\n>>> from deepdiff import deephash\n>>> obj = {1: 2, 'a': 'b'}\n>>> deephash(obj)\n{4355639248: 2468916477072481777512283587789292749, 4355639280: -35787773492556653776377555218122431491, 4358636128: -88390647972316138151822486391929534118, 4358009664: 8833996863197925870419376694314494743, 4357467952: 34150898645750099477987229399128149852}\n```\n\nso what is exactly the hash of obj in this case?\ndeephash is calculating the hash of the obj and any other object that obj contains.\nthe output of deephash is a dictionary of object ids to their hashes.\nin order to get the hash of obj itself, you need to use the object (or the id of object) to get its hash:\n\n```py\n>>> hashes = deephash(obj)\n>>> hashes[obj]\n34150898645750099477987229399128149852\n```\n\nwhich you can write as:\n\n```py\n>>> hashes = deephash(obj)[obj]\n```\n\nat first it might seem weird why deephash(obj)[obj] but remember that deephash(obj) is a dictionary of hashes of all other objects that obj contains too.\n\n\n> - please take a look at the [deephash docs](https://zepworks.com/deepdiff/6.2.0/deephash.html)\n> - the full documentation can be found on <https://zepworks.com/deepdiff/6.2.0/>\n\n\n# using deepdiff in unit tests\n\n`result` is the output of the function that is being tests.\n`expected` is the expected output of the function.\n\n```python\nself.assertequal(deepdiff(expected, result), {})\n```\n\nor if you are using pytest:\n\n\n```python\nassert not deepdiff(expected, result)\n```\n\nin other words, assert that there is no diff between the expected and the result.\n\n# difference with json patch\n\nunlike [json patch](https://tools.ietf.org/html/rfc6902) which is designed only for json objects, deepdiff is designed specifically for almost all python types. in addition to that, deepdiff checks for type changes and attribute value changes that json patch does not cover since there are no such things in json. last but not least, deepdiff gives you the exact path of the item(s) that were changed in python syntax.\n\nexample in json patch for replacing:\n\n`{ \"op\": \"replace\", \"path\": \"/a/b/c\", \"value\": 42 }`\n\nexample in deepdiff for the same operation:\n\n```python\n>>> item1 = {'a':{'b':{'c':'foo'}}}\n>>> item2 = {'a':{'b':{'c':42}}}\n>>> deepdiff(item1, item2)\n{'type_changes': {\"root['a']['b']['c']\": {'old_type': <type 'str'>, 'new_value': 42, 'old_value': 'foo', 'new_type': <type 'int'>}}}\n```\n\n\n# documentation\n\n<https://zepworks.com/deepdiff/current/>\n\n\n# pycon 2016\n\ni was honored to give a talk about the basics of how deepdiff does what it does at pycon 2016. please check out the video and let me know what you think:\n\n[diff it to dig it video](https://www.youtube.com/watch?v=j5r99ejixf4)\nand here is more info: <http://zepworks.com/blog/diff-it-to-digg-it/>\n\n# changelog\n\nplease take a look at the [changelog](changelog.md) file.\n\n# releases\n\nwe use bump2version to bump and tag releases.\n\n```bash\ngit checkout master && git pull\nbumpversion {patch|minor|major}\ngit push && git push --tags\n```\n\n# contribute\n\n1. please make your pr against the dev branch\n2. please make sure that your pr has tests. since deepdiff is used in many sensitive data driven projects, we strive to maintain around 100% test coverage on the code.\n\nplease run `pytest --cov=deepdiff --runslow` to see the coverage report. note that the `--runslow` flag will run some slow tests too. in most cases you only want to run the fast tests which so you wont add the `--runslow` flag.\n\nor to see a more user friendly version, please run: `pytest --cov=deepdiff --cov-report term-missing --runslow`.\n\nthank you!\n\n# citing\n\nhow to cite this library (apa style):\n\n    dehpour, s. (2022). deepdiff (version 6.2.0) [software]. available from https://github.com/seperman/deepdiff.\n\nhow to cite this library (chicago style):\n\n    dehpour, sep. 2022. deepdiff (version 6.2.0).\n\n# authors\n\nplease take a look at the [authors](authors.md) file.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "deepdiff6",
  "package_url": "https://pypi.org/project/deepdiff6/",
  "project_url": "https://pypi.org/project/deepdiff6/",
  "project_urls": {
    "Download": "https://github.com/seperman/deepdiff/tarball/master",
    "Homepage": "https://github.com/seperman/deepdiff"
  },
  "release_url": "https://pypi.org/project/deepdiff6/6.2.0/",
  "requires_dist": [
    "ordered-set (<4.2.0,>=4.0.2)",
    "click (==8.1.3) ; extra == 'cli'",
    "pyyaml (==6.0) ; extra == 'cli'",
    "toml (==0.10.2) ; extra == 'cli'",
    "clevercsv (==0.7.4) ; extra == 'cli'"
  ],
  "requires_python": ">=3.7",
  "summary": "deep difference and search of any python object/data. recreate objects by adding adding deltas to each other.",
  "version": "6.2.0",
  "releases": [],
  "developers": [
    "sep@zepworks.com",
    "seperman"
  ],
  "kwds": "deepdiff deepdiff6 deephash badge deepsearch",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_deepdiff6",
  "homepage": "https://github.com/seperman/deepdiff",
  "release_count": 3,
  "dependency_ids": [
    "pypi_clevercsv",
    "pypi_click",
    "pypi_ordered_set",
    "pypi_pyyaml",
    "pypi_toml"
  ]
}