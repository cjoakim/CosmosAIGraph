{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: microsoft :: windows",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "locket.py: file-based locks for python on linux and windows\n===========================================================\n\nlocket implements a file-based lock that can be used by multiple processes provided they use the same path.\n\n.. code-block:: python\n\n    import locket\n\n    # wait for lock\n    with locket.lock_file(\"path/to/lock/file\"):\n        perform_action()\n\n    # raise lockerror if lock cannot be acquired immediately\n    with locket.lock_file(\"path/to/lock/file\", timeout=0):\n        perform_action()\n\n    # raise lockerror if lock cannot be acquired after thirty seconds\n    with locket.lock_file(\"path/to/lock/file\", timeout=30):\n        perform_action()\n\n    # without context managers:\n    lock = locket.lock_file(\"path/to/lock/file\")\n    try:\n        lock.acquire()\n        perform_action()\n    finally:\n        lock.release()\n\nlocks largely behave as (non-reentrant) ``lock`` instances from the ``threading``\nmodule in the standard library. specifically, their behaviour is:\n\n* locks are uniquely identified by the file being locked,\n  both in the same process and across different processes.\n\n* locks are either in a locked or unlocked state.\n\n* when the lock is unlocked, calling ``acquire()`` returns immediately and changes\n  the lock state to locked.\n\n* when the lock is locked, calling ``acquire()`` will block until the lock state\n  changes to unlocked, or until the timeout expires.\n\n* if a process holds a lock, any thread in that process can call ``release()`` to\n  change the state to unlocked.\n\n* calling ``release()`` on an unlocked lock raises ``lockerror``.\n\n* behaviour of locks after ``fork`` is undefined.\n\ninstallation\n------------\n\n.. code-block:: sh\n\n    pip install locket\n\n\n",
  "docs_url": null,
  "keywords": "lock filelock lockfile process",
  "license": "bsd-2-clause",
  "name": "locket",
  "package_url": "https://pypi.org/project/locket/",
  "project_url": "https://pypi.org/project/locket/",
  "project_urls": {
    "Homepage": "http://github.com/mwilliamson/locket.py"
  },
  "release_url": "https://pypi.org/project/locket/1.0.0/",
  "requires_dist": [],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*",
  "summary": "file-based locks for python on linux and windows",
  "version": "1.0.0",
  "releases": [],
  "developers": [
    "michael_williamson",
    "mike@zwobble.org"
  ],
  "kwds": "lock_file lockfile filelock locks lock",
  "license_kwds": "bsd-2-clause",
  "libtype": "pypi",
  "id": "pypi_locket",
  "homepage": "http://github.com/mwilliamson/locket.py",
  "release_count": 5,
  "dependency_ids": []
}