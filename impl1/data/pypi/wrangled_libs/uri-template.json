{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# uri-template\n\nan implementation of rfc 6570 uri templates.\n\nthis packages implements uri template expansion in strict adherence to rfc 6570,\nbut adds a few extensions.\n\n## rfc 6570 extensions\n\n### non-string values\n\nrfc 6570 is silent regarding variable values that are not strings, lists, associative arrays, or null.\n\nthis package handles value types as follows:\n\n  * values that are instances of `str` are treated as strings.\n  * values implementing `collections.abc.sequence` are treated as lists.\n  * values implementing `collections.abc.mapping` are treated as associative arrays.\n  * `none` values are treated as null.\n  * boolean values are converted to the lower case strings 'true' and 'false'.\n  * all other values will be converted to strings using the python `str()` function.\n\n### nested structures\n\nthis package handles variable values with nested structure,\nfor example, lists containing other lists or associative arrays,\nor associative arrays containing lists or other associative arrays.\n\nnested values for variables that do not use the array modifier ('[]') are treated as follows:\n\n  * lists containing lists are flattened into a single list.\n  * lists containing associative arrays are treated as a single combined associative array.\n  * associative arrays represent nested data using dot notation (\".\") for the variable names.\n\nnested values for variables that use the array modifier extend the variable name with \nthe value's index or key written as an array subscript, e.g. \"foo[0]\" or \"foo[bar]\".\n\n### default values\n\nthis package allows default string values for variables per early drafts of rfc 6570.\ne.g. \"{foo=bar}\" will expand to \"bar\" if a value for `foo` is not given.\n\nlist and associtative array default values are not supported at this time.\n\n### specifying value keys\n\nsometimes a uri template is used to provide glue between an api and a given set of data.\nin this case, the names of values needed in the final url may not match the data provided \nfor the expansion.\n\nthis package allows specifying the key used to pass data into the template. \ne.g. \"{?foo/bar}\" will expand to \"?foo=<the value provided as bar>\"\n\n### partial expansion\n\nthis package allows partial expansion of uri templates.\n\nin a partial expansion, missing values preseve their expansion in the resultant output.\ne.g. a partial expansion of \"{one}/{two}\" with a value for `one` of \"foo\" and `two` missing will result in:\n\"foo/{two}\".\n\nin order to allow partial expansions to preserve value joiners with expanded output,\nexpansions accept an optional \"trailing joiner\" of \",\", \".\", \"/\", \";\", or \"&\",\nif this joiner is present after all variables, \nit will be appended to the output of the expansion and will suppress the output prefix.\ne.g.: \"{#one,two}\" with a missing value for `one` and a value of \"bar\" for `two`, \nwill partially expand to: \"#{#one,}bar\", which when provided with a value of \"foo\" for `one` \nwill expand to \"#foo,bar\"\n\nsome partial expansions that have some output, but have missing values, \nwill convert the remaining variables to a different type of expansion so that \nfurther expansions will produce the same output as if all values were originally present.\n\n   * partial simple string expansions will convert to comma expansions.\n   * partial reserved expansions partial fragment expansions will convert to reserved comma expansions.\n   * partial form-style query expansions will convert to form-style query continuations.\n\nin order to preserve the resultant value of templates that are paritally expanded, \nthe following additional expression expansions are supported:\n\n#### comma expansion: {,var}\n\nsimilar to label expansion with dot-prefix, \ncomma expansion prefixes the expansion output with a single comma \",\".\n\n#### reserved comma expansion: {,+var}\n\nsimilar to comma expansion, \nreserved comma expansion prefixes the expansion output with a single comma \",\",\nbut otherwise performs a reserved expansion ({+var}).\n\n## api \n\nthe package provides three functions:\n\n#### uri_template.expand(template: str, **kwargs) -> (str | none): ...\n\nexpand the given template, skipping missing values per rfc 6570.\n\nreturns `none` if the template is invalid or expansion fails.\n\n\n#### uri_template.partial(template: str, **kwargs) -> (str | none): ...\n\npartially expand the given template, \nreplacing missing variables with further expansions.\n\nreturns `none` if the template is invalid or expansion fails.\n\n\n#### uri_template.validate(template: str) -> bool: ...\n\nreturn `true` if the template is valid.\n\n---\n\nand the following classes:\n\n### uri_template.uritemplate\n\n#### uritemplate(template: str)\n\nconstruct a uritemplate for a given template string.\n\nraises `expansioninvalid`, `expansionreserved`, or `variableinvalid` if the template is invalid or unsupported.\n\n#### uritemplate.variables: iterable[variable]\n\nall variables present in the template.\nduplicates are returned once, order is preserved.\n\n#### uritemplate.variable_names: iterable[str]\n\nthe names of all variables present in the template.\nduplicates are returned once, order is preserved.\n\n#### uritemplate.expanded: bool\n\ndetermine if template is fully expanded.\n\n#### uritemplate.expand(**kwargs) -> str\n\nreturns the result of the expansion, skips missing variables.\n\nraises `expansionfailed` if the expansion fails due to a composite value being passed to a variable with a prefix modifier.\n\n#### uritemplate.partial(**kwargs) -> uritemplate\n\nexpand the template, replacing missing variables with further expansions.\n\nraises `expansionfailed` if the expansion fails due to a composite value being passed to a variable with a prefix modifier.\n\n#### uritemplate.__str__() -> str\n\nconvert the uritemplate object back into its original string form.\n\n---\n\n### uri_template.variable\n\n#### variable(var_spec: str)\n\nconstruct a variable.\n\n#### variable.name: str\n\nthe name of the variable\n\n#### variable.max_length: int\n\nthe speicified max length, or `0`.\n\n#### variable.explode: bool\n\nexplode modifier is present.\n\n#### variable.array: bool\n\narray modifier is present.\n\n#### variable.default: (str | none)\n\nspecified default value, or `none`.\n\n#### variable.__str__() -> str\n\nconvert the variable back to its original string form.\n\n---\n\nand the following exceptions:\n\n#### uri_template.expansioninvalid\n\nexpansion specification is invalid. \n\nraised by uritemplate constructor.\n\n#### uri_template.expansionreserved\n\nexpansion contains a reserved operator.\n\nraised by uritemplate constructor.\n\n#### uri_template.variableinvalid\n\nvariable specification is invalid.\n\nraised by uritemplate constructor.\n\n#### uri_template.expansionfailed\n\nexpansion failed, currently only possible when a composite value is passed to a variable with a prefix modifier.\n\nraised by uritemplate.expand() or uritemplate.partial() methods.\n\n\n## installation\n\ninstall with pip:\n\n    pip install uri-template\n",
  "docs_url": null,
  "keywords": "config",
  "license": "mit license",
  "name": "uri-template",
  "package_url": "https://pypi.org/project/uri-template/",
  "project_url": "https://pypi.org/project/uri-template/",
  "project_urls": {
    "homepage": "https://gitlab.linss.com/open-source/python/uri-template"
  },
  "release_url": "https://pypi.org/project/uri-template/1.3.0/",
  "requires_dist": [
    "types-PyYAML ; extra == 'dev'",
    "mypy ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "flake8-annotations ; extra == 'dev'",
    "flake8-bandit ; extra == 'dev'",
    "flake8-bugbear ; extra == 'dev'",
    "flake8-commas ; extra == 'dev'",
    "flake8-comprehensions ; extra == 'dev'",
    "flake8-continuation ; extra == 'dev'",
    "flake8-datetimez ; extra == 'dev'",
    "flake8-docstrings ; extra == 'dev'",
    "flake8-import-order ; extra == 'dev'",
    "flake8-literal ; extra == 'dev'",
    "flake8-modern-annotations ; extra == 'dev'",
    "flake8-noqa ; extra == 'dev'",
    "flake8-pyproject ; extra == 'dev'",
    "flake8-requirements ; extra == 'dev'",
    "flake8-typechecking-import ; extra == 'dev'",
    "flake8-use-fstring ; extra == 'dev'",
    "pep8-naming ; extra == 'dev'"
  ],
  "requires_python": ">=3.7",
  "summary": "rfc 6570 uri template processor",
  "version": "1.3.0",
  "releases": [],
  "developers": [
    "pypi@linss.com"
  ],
  "kwds": "uri_template rfc variable_names string strings",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_uri_template",
  "homepage": "",
  "release_count": 5,
  "dependency_ids": [
    "pypi_flake8",
    "pypi_flake8_annotations",
    "pypi_flake8_bandit",
    "pypi_flake8_bugbear",
    "pypi_flake8_commas",
    "pypi_flake8_comprehensions",
    "pypi_flake8_continuation",
    "pypi_flake8_datetimez",
    "pypi_flake8_docstrings",
    "pypi_flake8_import_order",
    "pypi_flake8_literal",
    "pypi_flake8_modern_annotations",
    "pypi_flake8_noqa",
    "pypi_flake8_pyproject",
    "pypi_flake8_requirements",
    "pypi_flake8_typechecking_import",
    "pypi_flake8_use_fstring",
    "pypi_mypy",
    "pypi_pep8_naming",
    "pypi_types_pyyaml"
  ]
}