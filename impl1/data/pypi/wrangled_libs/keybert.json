{
  "classifiers": [
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: artificial intelligence"
  ],
  "description": "[![pypi - python](https://img.shields.io/badge/python-3.6%20|%203.7%20|%203.8-blue.svg)](https://pypi.org/project/keybert/)\r\n[![pypi - license](https://img.shields.io/badge/license-mit-green.svg)](https://github.com/maartengr/keybert/blob/master/license)\r\n[![pypi - pypi](https://img.shields.io/pypi/v/keybert)](https://pypi.org/project/keybert/)\r\n[![build](https://img.shields.io/github/actions/workflow/status/maartengr/keybert/testing.yml?branch=master)](https://pypi.org/keybert/)\r\n[![open in colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1oxpgwkqszodto3vs7xe1nemzmcaimckx?usp=sharing)\r\n\r\n<img src=\"images/logo.png\" width=\"35%\" height=\"35%\" align=\"right\" />\r\n\r\n# keybert\r\n\r\nkeybert is a minimal and easy-to-use keyword extraction technique that leverages bert embeddings to\r\ncreate keywords and keyphrases that are most similar to a document.\r\n\r\ncorresponding medium post can be found [here](https://towardsdatascience.com/keyword-extraction-with-bert-724efca412ea).\r\n\r\n<a name=\"toc\"/></a>\r\n## table of contents  \r\n<!--ts-->  \r\n   1. [about the project](#about)  \r\n   2. [getting started](#gettingstarted)  \r\n        2.1. [installation](#installation)  \r\n        2.2. [basic usage](#usage)  \r\n        2.3. [max sum distance](#maxsum)  \r\n        2.4. [maximal marginal relevance](#maximal)  \r\n        2.5. [embedding models](#embeddings)  \r\n   3. [large language models](#llms)  \r\n<!--te-->  \r\n\r\n\r\n<a name=\"about\"/></a>\r\n## 1. about the project\r\n[back to toc](#toc)\r\n\r\nalthough there are already many methods available for keyword generation\r\n(e.g.,\r\n[rake](https://github.com/aneesha/rake),\r\n[yake!](https://github.com/liaad/yake), tf-idf, etc.)\r\ni wanted to create a very basic, but powerful method for extracting keywords and keyphrases.\r\nthis is where **keybert** comes in! which uses bert-embeddings and simple cosine similarity\r\nto find the sub-phrases in a document that are the most similar to the document itself.\r\n\r\nfirst, document embeddings are extracted with bert to get a document-level representation.\r\nthen, word embeddings are extracted for n-gram words/phrases. finally, we use cosine similarity\r\nto find the words/phrases that are the most similar to the document. the most similar words could\r\nthen be identified as the words that best describe the entire document.\r\n\r\nkeybert is by no means unique and is created as a quick and easy method\r\nfor creating keywords and keyphrases. although there are many great\r\npapers and solutions out there that use bert-embeddings\r\n(e.g.,\r\n[1](https://github.com/pranav-ust/bert-keyphrase-extraction),\r\n[2](https://github.com/ibatra/bert-keyword-extractor),\r\n[3](https://www.preprints.org/manuscript/201908.0073/download/final_file),\r\n), i could not find a bert-based solution that did not have to be trained from scratch and\r\ncould be used for beginners (**correct me if i'm wrong!**).\r\nthus, the goal was a `pip install keybert` and at most 3 lines of code in usage.\r\n\r\n<a name=\"gettingstarted\"/></a>\r\n## 2. getting started\r\n[back to toc](#toc)\r\n\r\n<a name=\"installation\"/></a>\r\n###  2.1. installation\r\ninstallation can be done using [pypi](https://pypi.org/project/keybert/):\r\n\r\n```\r\npip install keybert\r\n```\r\n\r\nyou may want to install more depending on the transformers and language backends that you will be using. the possible installations are:\r\n\r\n```\r\npip install keybert[flair]\r\npip install keybert[gensim]\r\npip install keybert[spacy]\r\npip install keybert[use]\r\n```\r\n\r\n<a name=\"usage\"/></a>\r\n###  2.2. usage\r\n\r\nthe most minimal example can be seen below for the extraction of keywords:\r\n```python\r\nfrom keybert import keybert\r\n\r\ndoc = \"\"\"\r\n         supervised learning is the machine learning task of learning a function that\r\n         maps an input to an output based on example input-output pairs. it infers a\r\n         function from labeled training data consisting of a set of training examples.\r\n         in supervised learning, each example is a pair consisting of an input object\r\n         (typically a vector) and a desired output value (also called the supervisory signal).\r\n         a supervised learning algorithm analyzes the training data and produces an inferred function,\r\n         which can be used for mapping new examples. an optimal scenario will allow for the\r\n         algorithm to correctly determine the class labels for unseen instances. this requires\r\n         the learning algorithm to generalize from the training data to unseen situations in a\r\n         'reasonable' way (see inductive bias).\r\n      \"\"\"\r\nkw_model = keybert()\r\nkeywords = kw_model.extract_keywords(doc)\r\n```\r\n\r\nyou can set `keyphrase_ngram_range` to set the length of the resulting keywords/keyphrases:\r\n\r\n```python\r\n>>> kw_model.extract_keywords(doc, keyphrase_ngram_range=(1, 1), stop_words=none)\r\n[('learning', 0.4604),\r\n ('algorithm', 0.4556),\r\n ('training', 0.4487),\r\n ('class', 0.4086),\r\n ('mapping', 0.3700)]\r\n```\r\n\r\nto extract keyphrases, simply set `keyphrase_ngram_range` to (1, 2) or higher depending on the number\r\nof words you would like in the resulting keyphrases:\r\n\r\n```python\r\n>>> kw_model.extract_keywords(doc, keyphrase_ngram_range=(1, 2), stop_words=none)\r\n[('learning algorithm', 0.6978),\r\n ('machine learning', 0.6305),\r\n ('supervised learning', 0.5985),\r\n ('algorithm analyzes', 0.5860),\r\n ('learning function', 0.5850)]\r\n```\r\n\r\nwe can highlight the keywords in the document by simply setting `highlight`:\r\n\r\n```python\r\nkeywords = kw_model.extract_keywords(doc, highlight=true)\r\n```\r\n<img src=\"images/highlight.png\" width=\"75%\" height=\"75%\" />\r\n\r\n\r\n**note**: for a full overview of all possible transformer models see [sentence-transformer](https://www.sbert.net/docs/pretrained_models.html).\r\ni would advise either `\"all-minilm-l6-v2\"` for english documents or `\"paraphrase-multilingual-minilm-l12-v2\"`\r\nfor multi-lingual documents or any other language.\r\n\r\n<a name=\"maxsum\"/></a>\r\n###  2.3. max sum distance\r\n\r\nto diversify the results, we take the 2 x top_n most similar words/phrases to the document.\r\nthen, we take all top_n combinations from the 2 x top_n words and extract the combination\r\nthat are the least similar to each other by cosine similarity.\r\n\r\n```python\r\n>>> kw_model.extract_keywords(doc, keyphrase_ngram_range=(3, 3), stop_words='english',\r\n                              use_maxsum=true, nr_candidates=20, top_n=5)\r\n[('set training examples', 0.7504),\r\n ('generalize training data', 0.7727),\r\n ('requires learning algorithm', 0.5050),\r\n ('supervised learning algorithm', 0.3779),\r\n ('learning machine learning', 0.2891)]\r\n```\r\n\r\n\r\n<a name=\"maximal\"/></a>\r\n###  2.4. maximal marginal relevance\r\n\r\nto diversify the results, we can use maximal margin relevance (mmr) to create\r\nkeywords / keyphrases which is also based on cosine similarity. the results\r\nwith **high diversity**:\r\n\r\n```python\r\n>>> kw_model.extract_keywords(doc, keyphrase_ngram_range=(3, 3), stop_words='english',\r\n                              use_mmr=true, diversity=0.7)\r\n[('algorithm generalize training', 0.7727),\r\n ('labels unseen instances', 0.1649),\r\n ('new examples optimal', 0.4185),\r\n ('determine class labels', 0.4774),\r\n ('supervised learning algorithm', 0.7502)]\r\n```\r\n\r\nthe results with **low diversity**:\r\n\r\n```python\r\n>>> kw_model.extract_keywords(doc, keyphrase_ngram_range=(3, 3), stop_words='english',\r\n                              use_mmr=true, diversity=0.2)\r\n[('algorithm generalize training', 0.7727),\r\n ('supervised learning algorithm', 0.7502),\r\n ('learning machine learning', 0.7577),\r\n ('learning algorithm analyzes', 0.7587),\r\n ('learning algorithm generalize', 0.7514)]\r\n```\r\n\r\n\r\n<a name=\"embeddings\"/></a>\r\n###  2.5. embedding models\r\nkeybert supports many embedding models that can be used to embed the documents and words:\r\n\r\n* sentence-transformers\r\n* flair\r\n* spacy\r\n* gensim\r\n* use\r\n\r\nclick [here](https://maartengr.github.io/keybert/guides/embeddings.html) for a full overview of all supported embedding models.\r\n\r\n**sentence-transformers**  \r\nyou can select any model from `sentence-transformers` [here](https://www.sbert.net/docs/pretrained_models.html)\r\nand pass it through keybert with `model`:\r\n\r\n```python\r\nfrom keybert import keybert\r\nkw_model = keybert(model='all-minilm-l6-v2')\r\n```\r\n\r\nor select a sentencetransformer model with your own parameters:\r\n\r\n```python\r\nfrom keybert import keybert\r\nfrom sentence_transformers import sentencetransformer\r\n\r\nsentence_model = sentencetransformer(\"all-minilm-l6-v2\")\r\nkw_model = keybert(model=sentence_model)\r\n```\r\n\r\n**flair**  \r\n[flair](https://github.com/flairnlp/flair) allows you to choose almost any embedding model that\r\nis publicly available. flair can be used as follows:\r\n\r\n```python\r\nfrom keybert import keybert\r\nfrom flair.embeddings import transformerdocumentembeddings\r\n\r\nroberta = transformerdocumentembeddings('roberta-base')\r\nkw_model = keybert(model=roberta)\r\n```\r\n\r\nyou can select any \ud83e\udd17 transformers model [here](https://huggingface.co/models).\r\n\r\n<a name=\"llms\"/></a>\r\n## 3. large language models\r\n[back to toc](#toc)\r\n\r\nwith `keyllm` you can new perform keyword extraction with large language models (llm). you can find the full documentation [here](https://maartengr.github.io/keybert/guides/keyllm.html) but there are two examples that are common with this new method. make sure to install the openai package through `pip install openai` before you start.\r\n\r\nfirst, we can ask openai directly to extract keywords:\r\n\r\n```python\r\nimport openai\r\nfrom keybert.llm import openai\r\nfrom keybert import keyllm\r\n\r\n# create your llm\r\nopenai.api_key = \"sk-...\"\r\nllm = openai()\r\n\r\n# load it in keyllm\r\nkw_model = keyllm(llm)\r\n```\r\n\r\nthis will query any chatgpt model and ask it to extract keywords from text.\r\n\r\nsecond, we can find documents that are likely to have the same keywords and only extract keywords for those. \r\nthis is much more efficient then asking the keywords for every single documents. there are likely documents that \r\nhave the exact same keywords. doing so is straightforward:\r\n\r\n```python\r\nimport openai\r\nfrom keybert.llm import openai\r\nfrom keybert import keyllm\r\nfrom sentence_transformers import sentencetransformer\r\n\r\n# extract embeddings\r\nmodel = sentencetransformer('all-minilm-l6-v2')\r\nembeddings = model.encode(my_documents, convert_to_tensor=true)\r\n\r\n# create your llm\r\nopenai.api_key = \"sk-...\"\r\nllm = openai()\r\n\r\n# load it in keyllm\r\nkw_model = keyllm(llm)\r\n\r\n# extract keywords\r\nkeywords = kw_model.extract_keywords(my_documents, embeddings=embeddings, threshold=.75)\r\n```\r\n\r\nyou can use the `threshold` parameter to decide how similar documents need to be in order to receive the same keywords.\r\n\r\n## citation\r\nto cite keybert in your work, please use the following bibtex reference:\r\n\r\n```bibtex\r\n@misc{grootendorst2020keybert,\r\n  author       = {maarten grootendorst},\r\n  title        = {keybert: minimal keyword extraction with bert.},\r\n  year         = 2020,\r\n  publisher    = {zenodo},\r\n  version      = {v0.3.0},\r\n  doi          = {10.5281/zenodo.4461265},\r\n  url          = {https://doi.org/10.5281/zenodo.4461265}\r\n}\r\n```\r\n\r\n## references\r\nbelow, you can find several resources that were used for the creation of keybert\r\nbut most importantly, these are amazing resources for creating impressive keyword extraction models:\r\n\r\n**papers**:\r\n* sharma, p., & li, y. (2019). [self-supervised contextual keyword and keyphrase retrieval with self-labelling.](https://www.preprints.org/manuscript/201908.0073/download/final_file)\r\n\r\n**github repos**:\r\n* https://github.com/thunlp/bert-kpe\r\n* https://github.com/ibatra/bert-keyword-extractor\r\n* https://github.com/pranav-ust/bert-keyphrase-extraction\r\n* https://github.com/swisscom/ai-research-keyphrase-extraction\r\n\r\n**mmr**:\r\nthe selection of keywords/keyphrases was modeled after:\r\n* https://github.com/swisscom/ai-research-keyphrase-extraction\r\n\r\n**note**: if you find a paper or github repo that has an easy-to-use implementation\r\nof bert-embeddings for keyword/keyphrase extraction, let me know! i'll make sure to\r\nadd a reference to this repo.\r\n",
  "docs_url": null,
  "keywords": "nlp bert keyword extraction embeddings",
  "license": "",
  "name": "keybert",
  "package_url": "https://pypi.org/project/keybert/",
  "project_url": "https://pypi.org/project/keybert/",
  "project_urls": {
    "Homepage": "https://github.com/MaartenGr/keyBERT"
  },
  "release_url": "https://pypi.org/project/keybert/0.8.3/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "keybert performs keyword extraction with state-of-the-art transformer models.",
  "version": "0.8.3",
  "releases": [],
  "developers": [
    "maarten_grootendorst",
    "maartengrootendorst@gmail.com"
  ],
  "kwds": "extract_keywords bert grootendorst2020keybert keybert keyphrases",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_keybert",
  "homepage": "https://github.com/maartengr/keybert",
  "release_count": 16,
  "dependency_ids": []
}