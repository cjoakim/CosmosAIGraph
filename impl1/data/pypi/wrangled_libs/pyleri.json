{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: text processing :: linguistic"
  ],
  "description": "[![ci](https://github.com/cesbit/pyleri/workflows/ci/badge.svg)](https://github.com/cesbit/pyleri/actions)\n[![release version](https://img.shields.io/github/release/cesbit/pyleri)](https://github.com/cesbit/pyleri/releases)\n\npython left-right parser\n========================\npyleri is an easy-to-use parser created for [siridb](http://siridb.net/). we first used [lrparsing](http://lrparsing.sourceforge.net/doc/html/) and wrote [jsleri](https://github.com/cesbit/jsleri) for auto-completion and suggestions in our web console. later we found small issues within the `lrparsing` module and also had difficulties keeping the language the same in all projects. that is when we decided to create pyleri which can export a created grammar to javascript, c, python, go and java.\n\ngabriele tomassetti [wrote a tutorial](https://tomassetti.me/pyleri-tutorial/) about the pyleri library.\n\n---------------------------------------\n  * [related projects](#related-projects)\n  * [installation](#installation)\n  * [quick usage](#quick-usage)\n  * [grammar](#grammar)\n    * [grammar.parse()](#parse)\n    * [grammar.export_js()](#export_js)\n    * [grammar.export_c()](#export_c)\n    * [grammar.export_go()](#export_go)\n    * [grammar.export_java()](#export_java)\n    * [grammar.export_py()](#export_py)\n  * [result](#result)\n    * [is_valid](#is_valid)\n    * [position](#position)\n    * [tree](#tree)\n    * [expecting](#expecting)\n  * [elements](#elements)\n    * [keyword](#keyword)\n    * [regex](#regex)\n    * [token](#token)\n    * [tokens](#tokens)\n    * [sequence](#sequence)\n    * [choice](#choice)\n    * [repeat](#repeat)\n    * [list](#list)\n    * [optional](#optional)\n    * [ref](#ref)\n    * [prio](#prio)\n\n\n---------------------------------------\n## related projects\n- [jsleri](https://github.com/cesbit/jsleri): javascript parser\n- [libcleri](https://github.com/cesbit/libcleri): c parser\n- [goleri](https://github.com/cesbit/goleri): go parser\n- [jleri](https://github.com/cesbit/jleri): java parser\n\n## installation\nthe easiest way is to use pypi:\n\n    sudo pip3 install pyleri\n\n## quick usage\n```python\n# imports, note that we skip the imports in other examples...\nfrom pyleri import (\n    grammar,\n    keyword,\n    regex,\n    sequence)\n\n# create a grammar class to define your language\nclass mygrammar(grammar):\n    r_name = regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = keyword('hi')\n    start = sequence(k_hi, r_name)\n\n# compile your grammar by creating an instance of the grammar class.\nmy_grammar = mygrammar()\n\n# use the compiled grammar to parse 'strings'\nprint(my_grammar.parse('hi \"iris\"').is_valid) # => true\nprint(my_grammar.parse('bye \"iris\"').is_valid) # => false\nprint(my_grammar.parse('bye \"iris\"').as_str()) # => error at position 0, expecting: hi\n```\n\n## grammar\nwhen writing a grammar you should subclass grammar. a grammar expects at least a `start` property so the parser knows where to start parsing. grammar has some default properties which can be overwritten like `re_keywords`, which will be explained later. grammar also has a parse method: `parse()`, and a few export methods: [export_js()](#export_js), [export_c()](#export_c), [export_py()](#export_py), [export_go()](#export_go) and [export_java()](#export_java) which are explained below.\n\n\n### parse\nsyntax:\n```python\ngrammar().parse(string)\n```\nthe `parse()` method returns a result object which has the following properties that are further explained in [result](#result):\n- `expecting`\n- `is_valid`\n- `pos`\n- `tree`\n\n\n### export_js\nsyntax:\n```python\ngrammar().export_js(\n    js_module_name='jsleri',\n    js_template=grammar.js_template,\n    js_indent=' ' * 4)\n```\noptional keyword arguments:\n- `js_module_name`: name of the javascript module. (default: 'jsleri')\n- `js_template`: template string used for the export. you might want to look at the default string which can be found at grammar.js_template.\n- `js_indent`: indentation used in the javascript file. (default: 4 spaces)\n\nfor example when using our quick usage grammar, this is the output when running `my_grammar.export_js()`:\n```javascript\n/* jshint newcap: false */\n\n/*\n * this grammar is generated using the grammar.export_js() method and\n * should be used with the jsleri javascript module.\n *\n * source class: mygrammar\n * created at: 2015-11-04 10:06:06\n */\n\n'use strict';\n\n(function (\n            regex,\n            sequence,\n            keyword,\n            grammar\n        ) {\n    var r_name = regex('^(?:\"(?:[^\"]*)\")+');\n    var k_hi = keyword('hi');\n    var start = sequence(\n        k_hi,\n        r_name\n    );\n\n    window.mygrammar = grammar(start, '^\\w+');\n\n})(\n    window.jsleri.regex,\n    window.jsleri.sequence,\n    window.jsleri.keyword,\n    window.jsleri.grammar\n);\n```\n\n### export_c\nsyntax:\n```python\ngrammar().export_c(\n    target=grammar.c_target,\n    c_indent=' ' * 4)\n```\noptional keyword arguments:\n- `target`: name of the c module. (default: 'grammar')\n- `c_indent`: indentation used in the c files. (default: 4 spaces)\n\nthe return value is a tuple containing the source (c) file and header (h) file.\n\nfor example when using our quick usage grammar, this is the output when running `my_grammar.export_c()`:\n```c\n/*\n * grammar.c\n *\n * this grammar is generated using the grammar.export_c() method and\n * should be used with the libcleri module.\n *\n * source class: mygrammar\n * created at: 2016-05-09 12:16:49\n */\n\n#include \"grammar.h\"\n#include <stdio.h>\n\n#define cleri_case_sensitive 0\n#define cleri_case_insensitive 1\n\n#define cleri_first_match 0\n#define cleri_most_greedy 1\n\ncleri_grammar_t * compile_grammar(void)\n{\n    cleri_t * r_name = cleri_regex(cleri_gid_r_name, \"^(?:\\\"(?:[^\\\"]*)\\\")+\");\n    cleri_t * k_hi = cleri_keyword(cleri_gid_k_hi, \"hi\", cleri_case_insensitive);\n    cleri_t * start = cleri_sequence(\n        cleri_gid_start,\n        2,\n        k_hi,\n        r_name\n    );\n\n    cleri_grammar_t * grammar = cleri_grammar(start, \"^\\\\w+\");\n\n    return grammar;\n}\n```\nand the header file...\n```c\n/*\n * grammar.h\n *\n * this grammar is generated using the grammar.export_c() method and\n * should be used with the libcleri module.\n *\n * source class: mygrammar\n * created at: 2016-05-09 12:16:49\n */\n#ifndef cleri_export_grammar_h_\n#define cleri_export_grammar_h_\n\n#include <grammar.h>\n#include <cleri/cleri.h>\n\ncleri_grammar_t * compile_grammar(void);\n\nenum cleri_grammar_ids {\n    cleri_none,   // used for objects with no name\n    cleri_gid_k_hi,\n    cleri_gid_r_name,\n    cleri_gid_start,\n    cleri_end // can be used to get the enum length\n};\n\n#endif /* cleri_export_grammar_h_ */\n\n```\n### export_go\nsyntax:\n```python\ngrammar().export_go(\n    go_template=grammar.go_template,\n    go_indent='\\t',\n    go_package='grammar')\n```\noptional keyword arguments:\n- `go_template`: template string used for the export. you might want to look at the default string which can be found at grammar.go_template.\n- `go_indent`: indentation used in the go file. (default: one tab)\n- `go_package`: name of the go package. (default: 'grammar')\n\nfor example when using our quick usage grammar, this is the output when running `my_grammar.export_go()`:\n```go\npackage grammar\n\n// this grammar is generated using the grammar.export_go() method and\n// should be used with the goleri module.\n//\n// source class: mygrammar\n// created at: 2017-03-14 19:07:09\n\nimport (\n        \"regexp\"\n\n        \"github.com/cesbit/goleri\"\n)\n\n// element indentifiers\nconst (\n        nogid = iota\n        gidkhi = iota\n        gidrname = iota\n        gidstart = iota\n)\n\n// mygrammar returns a compiled goleri grammar.\nfunc mygrammar() *goleri.grammar {\n        rname := goleri.newregex(gidrname, regexp.mustcompile(`^(?:\"(?:[^\"]*)\")+`))\n        khi := goleri.newkeyword(gidkhi, \"hi\", false)\n        start := goleri.newsequence(\n                gidstart,\n                khi,\n                rname,\n        )\n        return goleri.newgrammar(start, regexp.mustcompile(`^\\w+`))\n}\n```\n### export_java\nsyntax:\n```python\ngrammar().export_java(\n    java_template=grammar.java_template,\n    java_indent=' ' * 4,\n    java_package=none,\n    is_public=true)\n```\noptional keyword arguments:\n- `java_template`: template string used for the export. you might want to look at the default string which can be found at grammar.java_template.\n- `java_indent`: indentation used in the java file. (default: four spaces)\n- `java_package`: name of the java package or none when no package is specified. (default: none)\n- `is_public`: class and constructor are defined as public when true, else they will be defined as package private.\n\nfor example when using our quick usage grammar, this is the output when running `my_grammar.export_java()`:\n```java\n/**\n * this grammar is generated using the grammar.export_java() method and\n * should be used with the jleri module.\n *\n * source class: mygrammar\n * created at: 2018-07-04 12:12:34\n */\n\nimport jleri.grammar;\nimport jleri.element;\nimport jleri.sequence;\nimport jleri.regex;\nimport jleri.keyword;\n\npublic class mygrammar extends grammar {\n    enum ids {\n        k_hi,\n        r_name,\n        start\n    }\n\n    private static final element r_name = new regex(ids.r_name, \"^(?:\\\"(?:[^\\\"]*)\\\")+\");\n    private static final element k_hi = new keyword(ids.k_hi, \"hi\", false);\n    private static final element start = new sequence(\n        ids.start,\n        k_hi,\n        r_name\n    );\n\n    public mygrammar() {\n        super(start, \"^\\\\w+\");\n    }\n}\n```\n### export_py\nsyntax:\n```python\ngrammar().export_py(\n    py_module_name='pyleri',\n    py_template=grammar.py_template,\n    py_indent=' ' * 4)\n```\noptional keyword arguments:\n- `py_module_name`: name of the pyleri module. (default: 'pyleri')\n- `py_template`: template string used for the export. you might want to look at the default string which can be found at grammar.py_template.\n- `py_indent`: indentation used in the python file. (default: 4 spaces)\n\nfor example when using our quick usage grammar, this is the output when running `my_grammar.export_py()`:\n```python\n\"\"\"\n this grammar is generated using the grammar.export_py() method and\n should be used with the pyleri python module.\n\n source class: mygrammar\n created at: 2017-03-14 19:14:51\n\"\"\"\nimport re\nfrom pyleri import sequence\nfrom pyleri import keyword\nfrom pyleri import grammar\nfrom pyleri import regex\n\nclass mygrammar(grammar):\n\n    re_keywords = re.compile('^\\\\w+')\n    r_name = regex('^(?:\"(?:[^\"]*)\")+')\n    k_hi = keyword('hi')\n    start = sequence(\n        k_hi,\n        r_name\n    )\n```\n\n## result\nthe result of the `parse()` method contains 4 properties that will be explained next. a function `as_str(translate=none)` is also available which will\nshow the result as a string. the `translate` argument should be a function which accepts an element as argument. this function can be used to\nreturn custom strings for certain elements. if the return value of `translate` is `none` then the function will fall try to generate a string value. if\nthe return value is an empty string, the value will be ignored.\n\nexample of translate functions:\n```python\n# in case a translation function returns an empty string, no text is used\ndef translate(elem):\n    return ''  # as a result you get something like: 'error at position x'\n\n# text may be returned based on gid\ndef translate(elem):\n    if elem is some_elem:\n        return 'a'   # something like: error at position x, expecting: a\n    elif elem is other_elem:\n        return ''    # other_elem will be ignored\n    else:\n        return none  # normal parsing\n\n# a translate function can be used as follow:\nprint(my_grammar.parse('some string').as_str(translate=translate))\n```\n\n### is_valid\n`is_valid` returns a boolean value, `true` when the given string is valid according to the given grammar, `false` when not valid.\n\nlet us take the example from quick usage.\n```python\nres = my_grammar.parse('bye \"iris\"')\nprint(res.is_valid) # => false\n```\n\n### position\n`pos` returns the position where the parser had to stop. (when `is_valid` is `true` this value will be equal to the length of the given string with `str.rstrip()` applied)\n\nlet us take the example from quick usage.\n```python\nresult = my_grammar.parse('hi iris')\nprint(res.is_valid, result.pos) # => false, 3\n```\n\n### tree\n`tree` contains the parse tree. even when `is_valid` is `false` the parse tree is returned but will only contain results as far as parsing has succeeded. the tree is the root node which can include several `children` nodes. the structure will be further clarified in the following example which explains a way of visualizing the parse tree.\n\nexample:\n```python\nimport json\nfrom pyleri import choice\nfrom pyleri import grammar\nfrom pyleri import keyword\nfrom pyleri import regex\nfrom pyleri import repeat\nfrom pyleri import sequence\n\n\n# create a grammar class to define your language\nclass mygrammar(grammar):\n    r_name = regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = keyword('hi')\n    k_bye = keyword('bye')\n    start = repeat(sequence(choice(k_hi, k_bye), r_name))\n\n\n# returns properties of a node object as a dictionary:\ndef node_props(node, children):\n    return {\n        'start': node.start,\n        'end': node.end,\n        'name': node.element.name if hasattr(node.element, 'name') else none,\n        'element': node.element.__class__.__name__,\n        'string': node.string,\n        'children': children}\n\n\n# recursive method to get the children of a node object:\ndef get_children(children):\n    return [node_props(c, get_children(c.children)) for c in children]\n\n\n# view the parse tree:\ndef view_parse_tree(res):\n    start = res.tree.children[0] \\\n        if res.tree.children else res.tree\n    return node_props(start, get_children(start.children))\n\n\nif __name__ == '__main__':\n    # compile your grammar by creating an instance of the grammar class:\n    my_grammar = mygrammar()\n    res = my_grammar.parse('hi \"pyleri\" bye \"pyleri\"')\n    # the parse tree is visualized as a json object:\n    print(json.dumps(view_parse_tree(res), indent=2))\n```\n\npart of the output is shown below.\n\n```json\n\n    {\n    \"start\": 0,\n    \"end\": 23,\n    \"name\": \"start\",\n    \"element\": \"repeat\",\n    \"string\": \"hi \\\"pyleri\\\" bye \\\"pyleri\\\"\",\n    \"children\": [\n        {\n        \"start\": 0,\n        \"end\": 11,\n        \"name\": null,\n        \"element\": \"sequence\",\n        \"string\": \"hi \\\"pyleri\\\"\",\n        \"children\": [\n            {\n            \"start\": 0,\n            \"end\": 2,\n            \"name\": null,\n            \"element\": \"choice\",\n            \"string\": \"hi\",\n            \"children\": [\n                {\n                \"start\": 0,\n                \"end\": 2,\n                \"name\": \"k_hi\",\n                \"element\": \"keyword\",\n                \"string\": \"hi\",\n                \"children\": []\n                }\n            ]\n            },\n            {\n            \"start\": 3,\n            \"end\": 11,\n            \"name\": \"r_name\",\n            \"element\": \"regex\",\n            \"string\": \"\\\"pyleri\\\"\",\n            \"children\": []\n            }\n\n            \"...\"\n            \"...\"\n\n\n```\na node contains 5 properties that will be explained next:\n\n- `start` property returns the start of the node object.\n- `end` property returns the end of the  node object.\n- `element` returns the [element](#elements)'s type (e.g. repeat, sequence, keyword, etc.). an element can be assigned to a variable; for instance in the example above `keyword('hi')` was assigned to `k_hi`. with `element.name` the assigned name `k_hi` will be returned. note that it is not a given that an element is named; in our example `sequence` was not assigned, thus in this case the element has no attribute `name`.\n- `string` returns the string that is parsed.\n- `children` can return a node object containing deeper layered nodes provided that there are any. in our example the root node has an element type `repeat()`, starts at 0 and ends at 24, and it has two `children`. these children are node objects that have both an element type `sequence`, start at 0 and 12 respectively, and so on.\n\n\n### expecting\n`expecting` returns a python set() containing elements which pyleri expects at `pos`. even if `is_valid` is true there might be elements in this set, for example when an `optional()` element could be added to the string. \"expecting\" is useful if you want to implement things like auto-completion, syntax error handling, auto-syntax-correction etc. the following example will illustrate a way of implementation.\n\nexample:\n```python\nimport re\nimport random\nfrom pyleri import choice\nfrom pyleri import grammar\nfrom pyleri import keyword\nfrom pyleri import repeat\nfrom pyleri import sequence\nfrom pyleri import end_of_statement\n\n\n# create a grammar class to define your language.\nclass mygrammar(grammar):\n    re_keywords = re.compile(r'\\s+')\n    r_name = keyword('\"pyleri\"')\n    k_hi = keyword('hi')\n    k_bye = keyword('bye')\n    start = repeat(sequence(choice(k_hi, k_bye), r_name), mi=2)\n\n\n# print the expected elements as a indented and numbered list.\ndef print_expecting(node_expecting, string_expecting):\n    for loop, e in enumerate(node_expecting):\n        string_expecting = '{}\\n\\t({}) {}'.format(string_expecting, loop, e)\n    print(string_expecting)\n\n\n# complete a string until it is valid according to the grammar.\ndef auto_correction(string, my_grammar):\n    node = my_grammar.parse(string)\n    print('\\nparsed string: {}'.format(node.tree.string))\n\n    if node.is_valid:\n        string_expecting = 'string is valid. \\nexpected: '\n        print_expecting(node.expecting, string_expecting)\n\n    else:\n        string_expecting = 'string is not valid.\\nexpected: ' \\\n            if not node.pos \\\n            else 'string is not valid. \\nafter \"{}\" expected: '.format(\n                                                  node.tree.string[:node.pos])\n        print_expecting(node.expecting, string_expecting)\n\n        selected = random.choice(list(node.expecting))\n        string = '{} {}'.format(node.tree.string[:node.pos],\n                                selected\n                                if selected\n                                is not end_of_statement else '')\n\n        auto_correction(string, my_grammar)\n\n\nif __name__ == '__main__':\n    # compile your grammar by creating an instance of the grammar class.\n    my_grammar = mygrammar()\n    string = 'hello \"pyleri\"'\n    auto_correction(string, my_grammar)\n\n```\n\noutput:\n```\nparsed string: hello \"pyleri\"\nstring is not valid.\nexpected:\n        (1) hi\n        (2) bye\n\nparsed string:  bye\nstring is not valid.\nafter \" bye\" expected:\n        (1) \"pyleri\"\n\nparsed string:  bye \"pyleri\"\nstring is not valid.\nafter \" bye \"pyleri\"\" expected:\n        (1) hi\n        (2) bye\n\nparsed string:  bye \"pyleri\" hi\nstring is not valid.\nafter \" bye \"pyleri\" hi\" expected:\n        (1) \"pyleri\"\n\nparsed string:  bye \"pyleri\" hi \"pyleri\"\nstring is valid.\nexpected:\n        (1) hi\n        (2) bye\n\n```\nin the above example we parsed an invalid string according to the grammar class. the `auto-correction()` method that we built for this example combines all properties from the `parse()` to create a valid string. the output shows every recursion of the `auto-correction()` method and prints successively the set of expected elements. it takes one randomly and adds it to the string. when the string corresponds to the grammar, the property `is_valid` will return `true`. notably the `expecting` property still contains elements even if the `is_valid` returned `true`. the reason in this example is due to the [repeat](#repeat) element.\n\n## elements\npyleri has several elements which are all subclasses of [element](#element) and can be used to create a grammar.\n\n### keyword\nsyntax:\n```python\nkeyword(keyword, ign_case=false)\n```\nthe parser needs to match the keyword which is just a string. when matching keywords we need to tell the parser what characters are allowed in keywords. by default pyleri uses `^\\w+` which is both in python and javascript equal to `^[a-za-z0-9_]+`. we can overwrite the default by setting `re_keywords` in the grammar. keyword() accepts one keyword argument `ign_case` to tell the parser if we should match case insensitive.\n\nexample:\n\n```python\nclass tictactoe(grammar):\n    # let's allow keywords with alphabetic characters and dashes.\n    re_keywords = re.compile('^[a-za-z-]+')\n\n    start = keyword('tic-tac-toe', ign_case=true)\n\nttt_grammar = tictactoe()\nttt_grammar.parse('tic-tac-toe').is_valid  # => true\n```\n\n### regex\nsyntax:\n```python\nregex(pattern, flags=0)\n```\nthe parser compiles a regular expression using the `re` module. the current version of pyleri has only support for the `re.ignorecase` flag.\nsee the [quick usage](#quick-usage) example for how to use `regex`.\n\n### token\nsyntax:\n```python\ntoken(token)\n```\na token can be one or more characters and is usually used to match operators like `+`, `-`, `//` and so on. when we parse a string object where pyleri expects an element, it will automatically be converted to a `token()` object.\n\nexample:\n```python\nclass ni(grammar):\n    t_dash = token('-')\n    # we could just write delimiter='-' because\n    # any string will be converted to token()\n    start = list(keyword('ni'), delimiter=t_dash)\n\nni = ni()\nni.parse('ni-ni-ni-ni-ni').is_valid  # => true\n```\n\n### tokens\nsyntax:\n```python\ntokens(tokens)\n```\ncan be used to register multiple tokens at once. the `tokens` argument should be a string with tokens separated by spaces. if given tokens are different in size the parser will try to match the longest tokens first.\n\nexample:\n```python\nclass ni(grammar):\n    tks = tokens('+ - !=')\n    start = list(keyword('ni'), delimiter=tks)\n\nni = ni()\nni.parse('ni + ni != ni - ni').is_valid  # => true\n```\n\n### sequence\nsyntax:\n```python\nsequence(element, element, ...)\n```\nthe parser needs to match each element in a sequence.\n\nexample:\n```python\nclass tictactoe(grammar):\n    start = sequence(keyword('tic'), keyword('tac'), keyword('toe'))\n\nttt_grammar = tictactoe()\nttt_grammar.parse('tic tac toe').is_valid  # => true\n```\n\n### choice\nsyntax:\n```python\nchoice(element, element, ..., most_greedy=true)\n```\nthe parser needs to choose between one of the given elements. choice accepts one keyword argument `most_greedy` which is `true` by default. when `most_greedy` is set to `false` the parser will stop at the first match. when `true` the parser will try each element and returns the longest match. setting `most_greedy` to `false` can provide some extra performance. note that the parser will try to match each element in the exact same order they are parsed to choice.\n\nexample: let us use `choice` to modify the quick usage example to allow the string 'bye \"iris\"'\n```python\nclass mygrammar(grammar):\n    r_name = regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = keyword('hi')\n    k_bye = keyword('bye')\n    start = sequence(choice(k_hi, k_bye), r_name)\n\nmy_grammar = mygrammar()\nmy_grammar.parse('hi \"iris\"').is_valid  # => true\nmy_grammar.parse('bye \"iris\"').is_valid  # => true\n```\n\n### repeat\nsyntax:\n```python\nrepeat(element, mi=0, ma=none)\n```\nthe parser needs at least `mi` elements and at most `ma` elements. when `ma` is set to `none` we allow unlimited number of elements. `mi` can be any integer value equal or higher than 0 but not larger then `ma`.\n\nexample:\n```python\nclass ni(grammar):\n    start = repeat(keyword('ni'))\n\nni = ni()\nni.parse('ni ni ni ni ni').is_valid  # => true\n```\n\nit is not allowed to bind a name to the same element twice and repeat(element, 1, 1) is a common solution to bind the element a second (or more) time(s).\n\nfor example consider the following:\n```python\nclass mygrammar(grammar):\n    r_name = regex('(?:\"(?:[^\"]*)\")+')\n\n    # raises a syntaxerror because we try to bind a second time.\n    r_address = r_name # wrong\n\n    # instead use repeat\n    r_address = repeat(r_name, 1, 1) # right\n```\n\n### list\nsyntax:\n```python\nlist(element, delimiter=',', mi=0, ma=none, opt=false)\n```\nlist is like repeat but with a delimiter. a comma is used as default delimiter but any element is allowed. when a string is used as delimiter it will be converted to a `token` element. `mi` and `ma` work exactly like with repeat. an optional keyword argument `opt` can be set to `true` to allow the list to end with a delimiter. by default this is set to `false` which means the list has to end with an element.\n\nexample:\n```python\nclass ni(grammar):\n    start = list(keyword('ni'))\n\nni = ni()\nni.parse('ni, ni, ni, ni, ni').is_valid  # => true\n```\n\n### optional\nsyntax:\n```python\noptional(element)\n```\nthe parser looks for an optional element. it is like using `repeat(element, 0, 1)` but we encourage to use `optional` since it is more readable. (and slightly faster)\n\nexample:\n```python\nclass mygrammar(grammar):\n    r_name = regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = keyword('hi')\n    start = sequence(k_hi, optional(r_name))\n\nmy_grammar = mygrammar()\nmy_grammar.parse('hi \"iris\"').is_valid  # => true\nmy_grammar.parse('hi').is_valid  # => true\n```\n\n### ref\nsyntax:\n```python\nref()\n```\nthe grammar can make a forward reference to make recursion possible. in the example below we create a forward reference to start but note that\na reference to any element can be made.\n\n>warning: a reference is not protected against testing the same position in\n>a string. this could potentially lead to an infinite loop.\n>for example:\n>```python\n>r = ref()\n>r = optional(r)  # don't do this\n>```\n>use [prio](#prio) if such recursive construction is required.\n\nexample:\n```python\nclass nestedni(grammar):\n    start = ref()\n    ni_item = choice(keyword('ni'), start)\n    start = sequence('[', list(ni_item), ']')\n\nnested_ni = nestedni()\nnested_ni.parse('[ni, ni, [ni, [], [ni, ni]]]').is_valid  # => true\n```\n\n### prio\nsyntax:\n```python\nprio(element, element, ...)\n```\nchoose the first match from the prio elements and allow `this` for recursive operations. with `this` we point to the `prio` element. probably the example below explains how `prio` and `this` can be used.\n\n>note: use a [ref](#ref) when possible.\n>a `prio` element is required when the same position in a string is potentially\n>checked more than once.\n\nexample:\n```python\nclass ni(grammar):\n    k_ni = keyword('ni')\n    start = prio(\n        k_ni,\n        # '(' and ')' are automatically converted to token('(') and token(')')\n        sequence('(', this, ')'),\n        sequence(this, keyword('or'), this),\n        sequence(this, keyword('and'), this))\n\nni = ni()\nni.parse('(ni or ni) and (ni or ni)').is_valid  # => true\n```",
  "docs_url": null,
  "keywords": "parser,grammar,autocompletion",
  "license": "",
  "name": "pyleri",
  "package_url": "https://pypi.org/project/pyleri/",
  "project_url": "https://pypi.org/project/pyleri/",
  "project_urls": {
    "Download": "https://github.com/cesbit/pyleri/tarball/1.4.2",
    "Homepage": "https://github.com/cesbit/pyleri"
  },
  "release_url": "https://pypi.org/project/pyleri/1.4.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python left-right parser",
  "version": "1.4.2",
  "releases": [],
  "developers": [
    "jeroen@cesbit.com",
    "jeroen_van_der_heijden"
  ],
  "kwds": "autocompletion parser parsing parse parsed",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pyleri",
  "homepage": "https://github.com/cesbit/pyleri",
  "release_count": 22,
  "dependency_ids": []
}