{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: information technology",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: cython",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: software development"
  ],
  "description": "fastrlock\n---------\n\nthis is a c-level implementation of a fast, re-entrant, optimistic lock for cpython.\nit is a drop-in replacement for\n`threading.rlock <https://docs.python.org/3/library/threading.html#threading.rlock>`_.\nfastrlock is implemented in `cython <https://cython.org>`_ and also provides a c-api\nfor direct use from cython code via ``from fastrlock cimport rlock`` or\n``from cython.cimports.fastrlock import rlock``.\n\nunder normal conditions, it is about 10x faster than ``threading.rlock`` in python 2.7\nbecause it avoids all locking unless two or more threads try to acquire it at the\nsame time.  under congestion, it is still about 10% faster than rlock due to being\nimplemented in cython.\n\nthis is mostly equivalent to the revised rlock implementation in python 3.2,\nbut still faster due to being implemented in cython.  however, in python 3.4 and\nlater, the ``threading.rlock`` implementation in the stdlib tends to be as fast\nor even faster than the lock provided by this package, when called through the\npython api.  ``fastrlock`` is still faster also on these systems when called\nthrough its cython api from other cython modules.\n\nit was initially published as a code recipe here:\nhttps://code.activestate.com/recipes/577336-fast-re-entrant-optimistic-lock-implemented-in-cyt/\n\nfastrlock has been used and tested in `lupa <https://github.com/scoder/lupa>`_ for several years.\n\n\nhow does it work?\n-----------------\n\nthe fastrlock implementation optimises for the non-congested case.  it works by\nexploiting the availability of the gil.  since it knows that it holds the gil when\nthe acquire()/release() methods are called, it can safely check the lock for being\nheld by other threads and just count any re-entries as long as it is always the\nsame thread that acquires it.  this is a lot faster than actually acquiring the\nunderlying lock.\n\nwhen a second thread wants to acquire the lock as well, it first checks the lock\ncount and finds out that the lock is already owned.  if the underlying lock is also\nheld by another thread already, it then just frees the gil and asks for acquiring\nthe lock, just like rlock does.  if the underlying lock is not held, however, it\nacquires it immediately and basically hands over the ownership by telling the\ncurrent owner to free it when it's done.  then, it falls back to the normal\nnon-owner behaviour that asks for the lock and will eventually acquire it when it\ngets released.  this makes sure that the real lock is only acquired when at least\ntwo threads want it.\n\nall of these operations are basically atomic because any thread that modifies the\nlock state always holds the gil.  note that the implementation must not call any\npython code while handling the lock, as calling into python may lead to a context\nswitch which hands over the gil to another thread and thus breaks atomicity.\ntherefore, the code misuses cython's 'nogil' annotation to make sure that no python\ncode slips in accidentally.\n\n\nhow fast is it?\n---------------\n\nhere are some timings for python 2.7 for the following scenarios:\n\n1) five acquire-release cycles ('lock_unlock')\n2) five acquire calls followed by five release calls (nested locking, 'reentrant_lock_unlock')\n3) a mixed and partly nested sequence of acquire and release calls ('mixed_lock_unlock')\n4) five acquire-release cycles that do not block ('lock_unlock_nonblocking')\n\nall four are benchmarked for the single threaded case and the multi threaded case\nwith 10 threads.  i also tested it with 20 threads only to see that it then takes\nabout twice the time for both versions.  note also that the congested case is\nsubstantially slower for both locks and the benchmark includes the thread\ncreation time, so i only looped 1000x here to get useful\ntimings instead of 100000x for the single threaded case.\n\n::\n\n    testing _rlock (2.7.18)\n\n    sequential (x100000):\n    lock_unlock              :    853.55 msec\n    reentrant_lock_unlock    :    684.52 msec\n    mixed_lock_unlock        :    758.27 msec\n    lock_unlock_nonblocking  :    860.40 msec\n    context_manager          :   2876.00 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   2210.69 msec\n    reentrant_lock_unlock    :   1864.38 msec\n    mixed_lock_unlock        :   1963.10 msec\n    lock_unlock_nonblocking  :   3709.91 msec\n    context_manager          :   2640.32 msec\n\n    testing fastrlock (0.8.1)\n\n    sequential (x100000):\n    lock_unlock              :    139.76 msec\n    reentrant_lock_unlock    :    137.56 msec\n    mixed_lock_unlock        :    140.75 msec\n    lock_unlock_nonblocking  :    164.64 msec\n    context_manager          :    593.06 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   1621.13 msec\n    reentrant_lock_unlock    :   1807.09 msec\n    mixed_lock_unlock        :   1834.21 msec\n    lock_unlock_nonblocking  :   1642.06 msec\n    context_manager          :   1730.29 msec\n\n    testing cython interface of fastrlock (0.8.1)\n\n    sequential (x100000):\n    lock_unlock              :     19.14 msec\n    reentrant_lock_unlock    :     19.12 msec\n    mixed_lock_unlock        :     16.81 msec\n    lock_unlock_nonblocking  :     14.49 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   1511.85 msec\n    reentrant_lock_unlock    :   1541.96 msec\n    mixed_lock_unlock        :   1585.70 msec\n    lock_unlock_nonblocking  :   1585.35 msec\n\n\nhow does it compare to python 3.7 and later?\n--------------------------------------------\n\nthe results here are more mixed.  depending on the optimisation of the cpython\ninstallation, it can be faster, about the same speed, or somewhat slower.\nin any case, the direct cython interface is always faster than going through\nthe python api, because it avoids the python call overhead and executes\na c call instead.\n\n::\n\n    testing rlock (3.10.1)\n\n    sequential (x100000):\n    lock_unlock              :    138.36 msec\n    reentrant_lock_unlock    :     95.35 msec\n    mixed_lock_unlock        :    102.05 msec\n    lock_unlock_nonblocking  :    131.44 msec\n    context_manager          :    616.83 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   1386.60 msec\n    reentrant_lock_unlock    :   1207.75 msec\n    mixed_lock_unlock        :   1319.62 msec\n    lock_unlock_nonblocking  :   1325.07 msec\n    context_manager          :   1357.93 msec\n\n    testing fastrlock (0.8.1)\n\n    sequential (x100000):\n    lock_unlock              :     77.47 msec\n    reentrant_lock_unlock    :     64.14 msec\n    mixed_lock_unlock        :     73.51 msec\n    lock_unlock_nonblocking  :     70.31 msec\n    context_manager          :    393.34 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   1214.13 msec\n    reentrant_lock_unlock    :   1171.75 msec\n    mixed_lock_unlock        :   1184.33 msec\n    lock_unlock_nonblocking  :   1207.42 msec\n    context_manager          :   1232.20 msec\n\n    testing cython interface of fastrlock (0.8.1)\n\n    sequential (x100000):\n    lock_unlock              :     18.70 msec\n    reentrant_lock_unlock    :     15.88 msec\n    mixed_lock_unlock        :     14.96 msec\n    lock_unlock_nonblocking  :     13.47 msec\n\n    threaded 10t (x1000):\n    lock_unlock              :   1236.21 msec\n    reentrant_lock_unlock    :   1245.77 msec\n    mixed_lock_unlock        :   1194.25 msec\n    lock_unlock_nonblocking  :   1206.96 msec\n\n\n===================\nfastrlock changelog\n===================\n\n0.8.2 (2023-08-27)\n==================\n\n* rebuilt with cython 3.0.2 to add python 3.12 support.\n\n\n0.8.1 (2022-11-02)\n==================\n\n* rebuilt with cython 3.0.0a11 to add python 3.11 support.\n\n\n0.8 (2021-10-22)\n================\n\n* rebuilt with cython 3.0.0a9 to improve the performance in recent\n  python 3.x versions.\n\n\n0.7 (2021-10-21)\n================\n\n* adapted for unsigned thread ids, as used by py3.7+.\n  (original patch by guilherme dantas)\n\n* build with cython 0.29.24 to support py3.10 and later.\n\n\n0.6 (2021-03-21)\n================\n\n* rebuild with cython 0.29.22 to support py3.9 and later.\n\n\n0.5 (2020-06-05)\n================\n\n* rebuild with cython 0.29.20 to support py3.8 and later.\n\n\n0.4 (2018-08-24)\n================\n\n* rebuild with cython 0.28.5.\n\n* linux wheels are faster through profile guided optimisation.\n\n* add missing file to sdist.\n  (patch by mark harfouche, github issue #5)\n\n\n0.3 (2017-08-10)\n================\n\n* improve cimport support of c-api\n  (patch by naotoshi seo, github issue #3)\n\n* provide ``fastrlock.__version__``\n\n\n0.2 (2017-08-09)\n================\n\n* add missing readme file to sdist\n\n\n0.1 (2017-06-04)\n================\n\n* initial release\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit style",
  "name": "fastrlock",
  "package_url": "https://pypi.org/project/fastrlock/",
  "project_url": "https://pypi.org/project/fastrlock/",
  "project_urls": {
    "Homepage": "https://github.com/scoder/fastrlock"
  },
  "release_url": "https://pypi.org/project/fastrlock/0.8.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "fast, re-entrant optimistic lock implemented in cython",
  "version": "0.8.2",
  "releases": [],
  "developers": [
    "stefan_behnel",
    "stefan_ml@behnel.de"
  ],
  "kwds": "cython rlock fastrlock cpython _rlock",
  "license_kwds": "mit style",
  "libtype": "pypi",
  "id": "pypi_fastrlock",
  "homepage": "https://github.com/scoder/fastrlock",
  "release_count": 10,
  "dependency_ids": []
}