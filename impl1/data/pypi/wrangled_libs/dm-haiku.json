{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering :: mathematics",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# haiku: [sonnet] for [jax]\n\n[**overview**](#overview)\n| [**why haiku?**](#why-haiku)\n| [**quickstart**](#quickstart)\n| [**installation**](#installation)\n| [**examples**](https://github.com/deepmind/dm-haiku/tree/main/examples/)\n| [**user manual**](#user-manual)\n| [**documentation**](https://dm-haiku.readthedocs.io/)\n| [**citing haiku**](#citing-haiku)\n\n![pytest](https://github.com/deepmind/dm-haiku/workflows/pytest/badge.svg)\n![docs](https://readthedocs.org/projects/dm-haiku/badge/?version=latest)\n![pypi](https://img.shields.io/pypi/v/dm-haiku)\n\n> [!important]\n> \ud83d\udce3 **as of july 2023 [google deepmind] recommends that new projects adopt\n> [flax] (a neural network library originally developed by [google brain] and\n> now by [google deepmind]) instead of haiku.** \ud83d\udce3\n>\n> at the time of writing [flax] has superset of the features available in haiku,\n> a [larger](https://github.com/google/flax/graphs/contributors) and\n> [more active](https://github.com/google/flax/activity) development team and\n> more adoption with users outside of alphabet. [flax] has\n> [more extensive documentation](https://flax.readthedocs.io/),\n> [examples](https://github.com/huggingface/transformers/tree/main/examples/flax)\n> and an [active community](https://huggingface.co/flax-community) creating end\n> to end examples.\n>\n> haiku will remain best-effort supported, however the project will enter\n> [maintenance mode](https://en.wikipedia.org/wiki/maintenance_mode), meaning\n> that development efforts will be focussed on bug fixes and compatibility with\n> new releases of jax.\n>\n> new releases will be made to keep haiku working with newer versions of python\n> and [jax], however we will not be adding (or accepting prs for) new features.\n>\n> we have significant usage of haiku internally at [google deepmind] and\n> currently plan to support haiku in this mode indefinitely.\n\n## what is haiku?\n\n> haiku is a tool<br>\n> for building neural networks<br>\n> think: \"[sonnet] for [jax]\"\n\nhaiku is a simple neural network library for [jax] developed by some of the\nauthors of [sonnet], a neural network library for [tensorflow].\n\ndocumentation on haiku can be found at https://dm-haiku.readthedocs.io/.\n\n**disambiguation:** if you are looking for haiku the operating system then\nplease see https://haiku-os.org/.\n\n## overview<a id=\"overview\"></a>\n\n[jax] is a numerical computing library that combines numpy, automatic\ndifferentiation, and first-class gpu/tpu support.\n\nhaiku is a simple neural network library for jax that enables users to use\nfamiliar **object-oriented programming models** while allowing full access to\njax's pure function transformations.\n\nhaiku provides two core tools: a module abstraction, `hk.module`, and a simple\nfunction transformation, `hk.transform`.\n\n`hk.module`s are python objects that hold references to their own parameters,\nother modules, and methods that apply functions on user inputs.\n\n`hk.transform` turns functions that use these object-oriented, functionally\n\"impure\" modules into pure functions that can be used with `jax.jit`,\n`jax.grad`, `jax.pmap`, etc.\n\n## why haiku?<a id=\"why-haiku\"></a>\n\nthere are a number of neural network libraries for jax. why should you choose\nhaiku?\n\n### haiku has been tested by researchers at deepmind at scale.\n\n- deepmind has reproduced a number of experiments in haiku and jax with relative\n  ease. these include large-scale results in image and language processing,\n  generative models, and reinforcement learning.\n\n### haiku is a library, not a framework.\n\n- haiku is designed to make specific things simpler: managing model parameters\n  and other model state.\n- haiku can be expected to compose with other libraries and work well with the\n  rest of jax.\n- haiku otherwise is designed to get out of your way - it does not define custom\n  optimizers, checkpointing formats, or replication apis.\n\n### haiku does not reinvent the wheel.\n\n- haiku builds on the programming model and apis of sonnet, a neural network\n  library with near universal adoption at deepmind. it preserves sonnet's\n  `module`-based programming model for state management while retaining access\n  to jax's function transformations.\n- haiku apis and abstractions are as close as reasonable to sonnet. many users\n  have found sonnet to be a productive programming model in tensorflow; haiku\n  enables the same experience in jax.\n\n### transitioning to haiku is easy.\n\n- by design, transitioning from tensorflow and sonnet to jax and haiku is easy.\n- outside of new features (e.g. `hk.transform`), haiku aims to match the api of\n  sonnet 2. modules, methods, argument names, defaults, and initialization\n  schemes should match.\n\n### haiku makes other aspects of jax simpler.\n\n- haiku offers a trivial model for working with random numbers. within a\n  transformed function, `hk.next_rng_key()` returns a unique rng key.\n- these unique keys are deterministically derived from an initial random key\n  passed into the top-level transformed function, and are thus safe to use with\n  jax program transformations.\n\n## quickstart<a id=\"quickstart\"></a>\n\nlet's take a look at an example neural network, loss function, and training\nloop. (for more examples, see our\n[examples directory](https://github.com/deepmind/dm-haiku/tree/main/examples/).\nthe\n[mnist example](https://github.com/deepmind/dm-haiku/tree/main/examples/mnist.py)\nis a good place to start.)\n\n```python\nimport haiku as hk\nimport jax.numpy as jnp\n\ndef softmax_cross_entropy(logits, labels):\n  one_hot = jax.nn.one_hot(labels, logits.shape[-1])\n  return -jnp.sum(jax.nn.log_softmax(logits) * one_hot, axis=-1)\n\ndef loss_fn(images, labels):\n  mlp = hk.sequential([\n      hk.linear(300), jax.nn.relu,\n      hk.linear(100), jax.nn.relu,\n      hk.linear(10),\n  ])\n  logits = mlp(images)\n  return jnp.mean(softmax_cross_entropy(logits, labels))\n\nloss_fn_t = hk.transform(loss_fn)\nloss_fn_t = hk.without_apply_rng(loss_fn_t)\n\nrng = jax.random.prngkey(42)\ndummy_images, dummy_labels = next(input_dataset)\nparams = loss_fn_t.init(rng, dummy_images, dummy_labels)\n\ndef update_rule(param, update):\n  return param - 0.01 * update\n\nfor images, labels in input_dataset:\n  grads = jax.grad(loss_fn_t.apply)(params, images, labels)\n  params = jax.tree_util.tree_map(update_rule, params, grads)\n```\n\nthe core of haiku is `hk.transform`. the `transform` function allows you to\nwrite neural network functions that rely on parameters (here the weights of the\n`linear` layers) without requiring you to explicitly write the boilerplate\nfor initialising those parameters. `transform` does this by transforming the\nfunction into a pair of functions that are _pure_ (as required by jax) `init`\nand `apply`.\n\n### `init`\n\nthe `init` function, with signature `params = init(rng, ...)` (where `...` are\nthe arguments to the untransformed function), allows you to **collect** the\ninitial value of any parameters in the network. haiku does this by running your\nfunction, keeping track of any parameters requested through `hk.get_parameter`\n(called by e.g. `hk.linear`) and returning them to you.\n\nthe `params` object returned is a nested data structure of all the\nparameters in your network, designed for you to inspect and manipulate. \nconcretely, it is a mapping of module name to module parameters, where a module\nparameter is a mapping of parameter name to parameter value. for example:\n\n```\n{'linear': {'b': ndarray(..., shape=(300,), dtype=float32),\n            'w': ndarray(..., shape=(28, 300), dtype=float32)},\n 'linear_1': {'b': ndarray(..., shape=(100,), dtype=float32),\n              'w': ndarray(..., shape=(1000, 100), dtype=float32)},\n 'linear_2': {'b': ndarray(..., shape=(10,), dtype=float32),\n              'w': ndarray(..., shape=(100, 10), dtype=float32)}}\n```\n\n### `apply`\n\nthe `apply` function, with signature `result = apply(params, rng, ...)`, allows\nyou to **inject** parameter values into your function. whenever\n`hk.get_parameter` is called, the value returned will come from the `params` you\nprovide as input to `apply`:\n\n```python\nloss = loss_fn_t.apply(params, rng, images, labels)\n```\n\nnote that since the actual computation performed by our loss function doesn't\nrely on random numbers, passing in a random number generator is unnecessary, so\nwe could also pass in `none` for the `rng` argument. (note that if your\ncomputation _does_ use random numbers, passing in `none` for `rng` will cause\nan error to be raised.) in our example above, we ask haiku to do this for us\nautomatically with:\n\n```python\nloss_fn_t = hk.without_apply_rng(loss_fn_t)\n```\n\nsince `apply` is a pure function we can pass it to `jax.grad` (or any of jax's\nother transforms):\n\n```python\ngrads = jax.grad(loss_fn_t.apply)(params, images, labels)\n```\n\n### training\n\nthe training loop in this example is very simple. one detail to note is the use\nof `jax.tree_util.tree_map` to apply the `sgd` function across all matching\nentries in `params` and `grads`. the result has the same structure as the\nprevious `params` and can again be used with `apply`.\n\n\n## installation<a id=\"installation\"></a>\n\nhaiku is written in pure python, but depends on c++ code via jax.\n\nbecause jax installation is different depending on your cuda version, haiku does\nnot list jax as a dependency in `requirements.txt`.\n\nfirst, follow [these instructions](https://github.com/google/jax#installation)\nto install jax with the relevant accelerator support.\n\nthen, install haiku using pip:\n\n```bash\n$ pip install git+https://github.com/deepmind/dm-haiku\n```\n\nalternatively, you can install via pypi:\n\n```bash\n$ pip install -u dm-haiku\n```\n\nour examples rely on additional libraries (e.g. [bsuite](https://github.com/deepmind/bsuite)). you can install the full set of additional requirements using pip:\n\n```bash\n$ pip install -r examples/requirements.txt\n```\n\n## user manual<a id=\"user-manual\"></a>\n\n### writing your own modules\n\nin haiku, all modules are a subclass of `hk.module`. you can implement any\nmethod you like (nothing is special-cased), but typically modules implement\n`__init__` and `__call__`.\n\nlet's work through implementing a linear layer:\n\n```python\nclass mylinear(hk.module):\n\n  def __init__(self, output_size, name=none):\n    super().__init__(name=name)\n    self.output_size = output_size\n\n  def __call__(self, x):\n    j, k = x.shape[-1], self.output_size\n    w_init = hk.initializers.truncatednormal(1. / np.sqrt(j))\n    w = hk.get_parameter(\"w\", shape=[j, k], dtype=x.dtype, init=w_init)\n    b = hk.get_parameter(\"b\", shape=[k], dtype=x.dtype, init=jnp.zeros)\n    return jnp.dot(x, w) + b\n```\n\nall modules have a name. when no `name` argument is passed to the module, its\nname is inferred from the name of the python class (for example `mylinear`\nbecomes `my_linear`). modules can have named parameters that are accessed\nusing `hk.get_parameter(param_name, ...)`. we use this api (rather than just\nusing object properties) so that we can convert your code into a pure function\nusing `hk.transform`.\n\nwhen using modules you need to define functions and transform them into a pair\nof pure functions using `hk.transform`. see our [quickstart](#quickstart) for\nmore details about the functions returned from `transform`:\n\n```python\ndef forward_fn(x):\n  model = mylinear(10)\n  return model(x)\n\n# turn `forward_fn` into an object with `init` and `apply` methods. by default,\n# the `apply` will require an rng (which can be none), to be used with\n# `hk.next_rng_key`.\nforward = hk.transform(forward_fn)\n\nx = jnp.ones([1, 1])\n\n# when we run `forward.init`, haiku will run `forward_fn(x)` and collect initial\n# parameter values. haiku requires you pass a rng key to `init`, since parameters\n# are typically initialized randomly:\nkey = hk.prngsequence(42)\nparams = forward.init(next(key), x)\n\n# when we run `forward.apply`, haiku will run `forward_fn(x)` and inject parameter\n# values from the `params` that are passed as the first argument.  note that\n# models transformed using `hk.transform(f)` must be called with an additional\n# `rng` argument: `forward.apply(params, rng, x)`. use\n# `hk.without_apply_rng(hk.transform(f))` if this is undesirable.\ny = forward.apply(params, none, x)\n```\n\n### working with stochastic models\n\nsome models may require random sampling as part of the computation.\nfor example, in variational autoencoders with the reparametrization trick,\na random sample from the standard normal distribution is needed. for dropout we\nneed a random mask to drop units from the input. the main hurdle in making this\nwork with jax is in management of prng keys.\n\nin haiku we provide a simple api for maintaining a prng key sequence associated\nwith modules: `hk.next_rng_key()` (or `next_rng_keys()` for multiple keys):\n\n```python\nclass mydropout(hk.module):\n\n  def __init__(self, rate=0.5, name=none):\n    super().__init__(name=name)\n    self.rate = rate\n\n  def __call__(self, x):\n    key = hk.next_rng_key()\n    p = jax.random.bernoulli(key, 1.0 - self.rate, shape=x.shape)\n    return x * p / (1.0 - self.rate)\n\nforward = hk.transform(lambda x: mydropout()(x))\n\nkey1, key2 = jax.random.split(jax.random.prngkey(42), 2)\nparams = forward.init(key1, x)\nprediction = forward.apply(params, key2, x)\n```\n\nfor a more complete look at working with stochastic models, please see our\n[vae example](https://github.com/deepmind/dm-haiku/tree/main/examples/vae.py).\n\n**note:** `hk.next_rng_key()` is not functionally pure which means you should\navoid using it alongside jax transformations which are inside `hk.transform`.\nfor more information and possible workarounds, please consult the docs on\n[haiku transforms](https://dm-haiku.readthedocs.io/en/latest/notebooks/transforms.html)\nand available\n[wrappers for jax transforms inside haiku networks](https://dm-haiku.readthedocs.io/en/latest/api.html#haiku-transforms).\n\n### working with non-trainable state\n\nsome models may want to maintain some internal, mutable state. for example, in\nbatch normalization a moving average of values encountered during training is\nmaintained.\n\nin haiku we provide a simple api for maintaining mutable state that is\nassociated with modules: `hk.set_state` and `hk.get_state`. when using these\nfunctions you need to transform your function using `hk.transform_with_state`\nsince the signature of the returned pair of functions is different:\n\n```python\ndef forward(x, is_training):\n  net = hk.nets.resnet50(1000)\n  return net(x, is_training)\n\nforward = hk.transform_with_state(forward)\n\n# the `init` function now returns parameters **and** state. state contains\n# anything that was created using `hk.set_state`. the structure is the same as\n# params (e.g. it is a per-module mapping of named values).\nparams, state = forward.init(rng, x, is_training=true)\n\n# the apply function now takes both params **and** state. additionally it will\n# return updated values for state. in the resnet example this will be the\n# updated values for moving averages used in the batch norm layers.\nlogits, state = forward.apply(params, state, rng, x, is_training=true)\n```\n\nif you forget to use `hk.transform_with_state` don't worry, we will print a\nclear error pointing you to `hk.transform_with_state` rather than silently\ndropping your state.\n\n### distributed training with `jax.pmap`\n\nthe pure functions returned from `hk.transform` (or `hk.transform_with_state`)\nare fully compatible with `jax.pmap`. for more details on spmd programming with\n`jax.pmap`,\n[look here](https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap).\n\none common use of `jax.pmap` with haiku is for data-parallel training on many\naccelerators, potentially across multiple hosts. with haiku, that might look\nlike this:\n\n```python\ndef loss_fn(inputs, labels):\n  logits = hk.nets.mlp([8, 4, 2])(x)\n  return jnp.mean(softmax_cross_entropy(logits, labels))\n\nloss_fn_t = hk.transform(loss_fn)\nloss_fn_t = hk.without_apply_rng(loss_fn_t)\n\n# initialize the model on a single device.\nrng = jax.random.prngkey(428)\nsample_image, sample_label = next(input_dataset)\nparams = loss_fn_t.init(rng, sample_image, sample_label)\n\n# replicate params onto all devices.\nnum_devices = jax.local_device_count()\nparams = jax.tree_util.tree_map(lambda x: np.stack([x] * num_devices), params)\n\ndef make_superbatch():\n  \"\"\"constructs a superbatch, i.e. one batch of data per device.\"\"\"\n  # get n batches, then split into list-of-images and list-of-labels.\n  superbatch = [next(input_dataset) for _ in range(num_devices)]\n  superbatch_images, superbatch_labels = zip(*superbatch)\n  # stack the superbatches to be one array with a leading dimension, rather than\n  # a python list. this is what `jax.pmap` expects as input.\n  superbatch_images = np.stack(superbatch_images)\n  superbatch_labels = np.stack(superbatch_labels)\n  return superbatch_images, superbatch_labels\n\ndef update(params, inputs, labels, axis_name='i'):\n  \"\"\"updates params based on performance on inputs and labels.\"\"\"\n  grads = jax.grad(loss_fn_t.apply)(params, inputs, labels)\n  # take the mean of the gradients across all data-parallel replicas.\n  grads = jax.lax.pmean(grads, axis_name)\n  # update parameters using sgd or adam or ...\n  new_params = my_update_rule(params, grads)\n  return new_params\n\n# run several training updates.\nfor _ in range(10):\n  superbatch_images, superbatch_labels = make_superbatch()\n  params = jax.pmap(update, axis_name='i')(params, superbatch_images,\n                                           superbatch_labels)\n```\n\nfor a more complete look at distributed haiku training, take a look at our\n[resnet-50 on imagenet example](https://github.com/deepmind/dm-haiku/tree/main/examples/imagenet/).\n\n## citing haiku<a id=\"citing-haiku\"></a>\n\nto cite this repository:\n\n```\n@software{haiku2020github,\n  author = {tom hennigan and trevor cai and tamara norman and lena martens and igor babuschkin},\n  title = {{h}aiku: {s}onnet for {jax}},\n  url = {http://github.com/deepmind/dm-haiku},\n  version = {0.0.10},\n  year = {2020},\n}\n```\n\nin this bibtex entry, the version number is intended to be from\n[`haiku/__init__.py`](https://github.com/deepmind/dm-haiku/blob/main/haiku/__init__.py),\nand the year corresponds to the project's open-source release.\n\n[jax]: https://github.com/google/jax\n[sonnet]: https://github.com/deepmind/sonnet\n[tensorflow]: https://github.com/tensorflow/tensorflow\n[flax]: https://github.com/google/flax\n[google deepmind]: https://blog.google/technology/ai/april-ai-update/\n[google brain]: https://research.google/teams/brain/\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "dm-haiku",
  "package_url": "https://pypi.org/project/dm-haiku/",
  "project_url": "https://pypi.org/project/dm-haiku/",
  "project_urls": {
    "Homepage": "https://github.com/deepmind/dm-haiku"
  },
  "release_url": "https://pypi.org/project/dm-haiku/0.0.11/",
  "requires_dist": [
    "absl-py >=0.7.1",
    "jmp >=0.0.2",
    "numpy >=1.18.0",
    "tabulate >=0.8.9",
    "flax >=0.7.1",
    "jax >=0.4.16 ; extra == 'jax'",
    "jaxlib >=0.4.16 ; extra == 'jax'"
  ],
  "requires_python": "",
  "summary": "haiku is a library for building neural networks in jax.",
  "version": "0.0.11",
  "releases": [],
  "developers": [
    "deepmind",
    "haiku-dev-os@google.com"
  ],
  "kwds": "haiku haiku2020github sonnet pytest overview",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_dm_haiku",
  "homepage": "https://github.com/deepmind/dm-haiku",
  "release_count": 14,
  "dependency_ids": [
    "pypi_absl_py",
    "pypi_flax",
    "pypi_jax",
    "pypi_jaxlib",
    "pypi_jmp",
    "pypi_numpy",
    "pypi_tabulate"
  ]
}