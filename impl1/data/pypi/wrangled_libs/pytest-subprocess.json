{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: testing"
  ],
  "description": "\npytest-subprocess\n=================\n\n.. image:: https://img.shields.io/pypi/v/pytest-subprocess.svg\n    :target: https://pypi.org/project/pytest-subprocess\n    :alt: pypi version\n\n.. image:: https://img.shields.io/pypi/pyversions/pytest-subprocess.svg\n    :target: https://pypi.org/project/pytest-subprocess\n    :alt: python versions\n\n.. image:: https://codecov.io/gh/aklajnert/pytest-subprocess/branch/master/graph/badge.svg?token=jau1cgoyl8\n  :target: https://codecov.io/gh/aklajnert/pytest-subprocess\n\n.. image:: https://readthedocs.org/projects/pytest-subprocess/badge/?version=latest\n   :target: https://pytest-subprocess.readthedocs.io/en/latest/?badge=latest\n   :alt: documentation status\n\npytest plugin to fake subprocess.\n\n.. contents:: :local:\n\n.. include-start\n\nusage\n=====\n\nthe plugin adds the ``fake_process`` fixture (and ``fp`` as an alias).\nit can be used it to register subprocess results so you won't need to rely on\nthe real processes. the plugin hooks on the ``subprocess.popen()``, which is\nthe base for other subprocess functions. that makes the ``subprocess.run()``,\n``subprocess.call()``, ``subprocess.check_call()`` and\n``subprocess.check_output()`` methods also functional.\n\ninstallation\n------------\n\nyou can install ``pytest-subprocess`` via `pip`_ from `pypi`_::\n\n    $ pip install pytest-subprocess\n\n\nbasic usage\n-----------\n\nthe most important method is ``fp.register()``\n(or ``register_subprocess`` if you prefer to be more verbose), which\nallows defining the fake processes behavior.\n\n.. code-block:: python\n\n    def test_echo_null_byte(fp):\n        fp.register([\"echo\", \"-ne\", \"\\x00\"], stdout=bytes.fromhex(\"00\"))\n\n        process = subprocess.popen(\n            [\"echo\", \"-ne\", \"\\x00\"],\n            stdout=subprocess.pipe,\n        )\n        out, _ = process.communicate()\n\n        assert process.returncode == 0\n        assert out == b\"\\x00\"\n\noptionally, the ``stdout`` and ``stderr`` parameters can be a list (or tuple)\nof lines to be joined together with a trailing ``os.linesep`` on each line.\n\n.. code-block:: python\n\n    def test_git(fp):\n        fp.register([\"git\", \"branch\"], stdout=[\"* fake_branch\", \"  master\"])\n\n        process = subprocess.popen(\n            [\"git\", \"branch\"],\n            stdout=subprocess.pipe,\n            universal_newlines=true,\n        )\n        out, _ = process.communicate()\n\n        assert process.returncode == 0\n        assert out == \"* fake_branch\\n  master\\n\"\n\npassing input\n-------------\n\nby default, if you use ``input`` argument to the ``popen.communicate()``\nmethod, it won't crash, but also won't do anything useful. by passing\na function as ``stdin_callable`` argument for the\n``fp.register()`` method you can specify the behavior\nbased on the input. the function shall accept one argument, which will be\nthe input data. if the function will return a dictionary with ``stdout`` or\n``stderr`` keys, its value will be appended to according stream.\n\n.. code-block:: python\n\n    def test_pass_input(fp):\n        def stdin_function(input):\n            return {\n                \"stdout\": \"this input was added: {data}\".format(\n                    data=input.decode()\n                )\n            }\n\n        fp.register(\n            [\"command\"],\n            stdout=[b\"just stdout\"],\n            stdin_callable=stdin_function,\n        )\n\n        process = subprocess.popen(\n            [\"command\"],\n            stdin=subprocess.pipe,\n            stdout=subprocess.pipe,\n        )\n        out, _ = process.communicate(input=b\"sample input\\n\")\n\n        assert out.splitlines() == [\n            b\"just stdout\",\n            b\"this input was added: sample input\",\n        ]\n\nunregistered commands\n---------------------\n\nby default, when the ``fp`` fixture is being used, any attempt to\nrun subprocess that has not been registered will raise\nthe ``processnotregisterederror`` exception. to allow it, use\n``fp.allow_unregistered(true)``, which will execute all unregistered\nprocesses with real ``subprocess``, or use\n``fp.pass_command(\"command\")`` to allow just a single command.\n\n.. code-block:: python\n\n    def test_real_process(fp):\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            # this will fail, as \"ls\" command is not registered\n            subprocess.call(\"ls\")\n\n        fp.pass_command(\"ls\")\n        # now it should be fine\n        assert subprocess.call(\"ls\") == 0\n\n        # allow all commands to be called by real subprocess\n        fp.allow_unregistered(true)\n        assert subprocess.call([\"ls\", \"-l\"]) == 0\n\n\ndiffering results\n-----------------\n\neach ``register()`` or ``pass_command()`` method call will register\nonly one command execution. you can call those methods multiple times, to\nchange the faked output on each subprocess run. when you call subprocess more\nwill be raised. to prevent that, call ``fp.keep_last_process(true)``,\nwhich will keep the last registered process forever.\n\n.. code-block:: python\n\n    def test_different_output(fp):\n        # register process with output changing each execution\n        fp.register(\"test\", stdout=\"first execution\")\n        # the second execution will return non-zero exit code\n        fp.register(\"test\", stdout=\"second execution\", returncode=1)\n\n        assert subprocess.check_output(\"test\") == b\"first execution\"\n        second_process = subprocess.run(\"test\", stdout=subprocess.pipe)\n        assert second_process.stdout == b\"second execution\"\n        assert second_process.returncode == 1\n\n        # 3rd time shall raise an exception\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            subprocess.check_call(\"test\")\n\n        # now, register two processes once again,\n        # but the last one will be kept forever\n        fp.register(\"test\", stdout=\"first execution\")\n        fp.register(\"test\", stdout=\"second execution\")\n        fp.keep_last_process(true)\n\n        # now the processes can be called forever\n        assert subprocess.check_output(\"test\") == b\"first execution\"\n        assert subprocess.check_output(\"test\") == b\"second execution\"\n        assert subprocess.check_output(\"test\") == b\"second execution\"\n        assert subprocess.check_output(\"test\") == b\"second execution\"\n\n\nusing callbacks\n---------------\n\nyou can pass a function as ``callback`` argument to the ``register()``\nmethod which will be executed instead of the real subprocess. the callback function\ncan raise exceptions which will be interpreted in tests as an exception raised\nby the subprocess. the fixture will pass ``fakepopen`` class instance into the\ncallback function, that can be used to change the return code or modify output\nstreams.\n\n.. code-block:: python\n\n    def callback_function(process):\n        process.returncode = 1\n        raise permissionerror(\"exception raised by subprocess\")\n\n\n    def test_raise_exception(fp):\n        fp.register([\"test\"], callback=callback_function)\n\n        with pytest.raises(\n            permissionerror, match=\"exception raised by subprocess\"\n        ):\n            process = subprocess.popen([\"test\"])\n            process.wait()\n\n        assert process.returncode == 1\n\nit is possible to pass additional keyword arguments into ``callback`` by using\nthe ``callback_kwargs`` argument:\n\n.. code-block:: python\n\n    def callback_function_with_kwargs(process, return_code):\n        process.returncode = return_code\n\n\n    def test_callback_with_arguments(fp):\n        return_code = 127\n\n        fp.register(\n            [\"test\"],\n            callback=callback_function_with_kwargs,\n            callback_kwargs={\"return_code\": return_code},\n        )\n\n        process = subprocess.popen([\"test\"])\n        process.wait()\n\n        assert process.returncode == return_code\n\nas a context manager\n--------------------\n\nthe ``fp`` fixture provides ``context()`` method that allows us to\nuse it as a context manager. it can be used to limit the scope when a certain\ncommand is allowed, e.g. to make sure that the code doesn't want to execute\nit somewhere else.\n\n.. code-block:: python\n\n    def test_context_manager(fp):\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            # command not registered, so will raise an exception\n            subprocess.check_call(\"test\")\n\n        with fp.context() as nested_process:\n            nested_process.register(\"test\", occurrences=3)\n            # now, we can call the command 3 times without error\n            assert subprocess.check_call(\"test\") == 0\n            assert subprocess.check_call(\"test\") == 0\n\n        # the command was called 2 times, so one occurrence left, but since the\n        # context manager has been left, it is not registered anymore\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            subprocess.check_call(\"test\")\n\nnon-exact command matching\n--------------------------\n\nif you need to catch a command with some non-predictable elements, like a path\nto a randomly-generated file name, you can use ``fake_subprocess.any()`` for\nthat purpose. the number of arguments that should be matched can be controlled\nby ``min`` and ``max`` arguments. to use ``fake_subprocess.any()`` you need\nto define the command as a ``tuple`` or ``list``. the matching will work even\nif the subprocess command will be called with a string argument.\n\n.. code-block:: python\n\n    def test_non_exact_matching(fp):\n        # define a command that will take any number of arguments\n        fp.register([\"ls\", fp.any()])\n        assert subprocess.check_call(\"ls -lah\") == 0\n\n        # `fake_subprocess.any()` is ok even with no arguments\n        fp.register([\"ls\", fp.any()])\n        assert subprocess.check_call(\"ls\") == 0\n\n        # but it can force a minimum amount of arguments\n        fp.register([\"cp\", fp.any(min=2)])\n\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            # only one argument is used, so registered command won't match\n            subprocess.check_call(\"cp /source/dir\")\n        # but two arguments will be fine\n        assert subprocess.check_call(\"cp /source/dir /tmp/random-dir\") == 0\n\n        # the `max` argument can be used to limit maximum amount of arguments\n        fp.register([\"cd\", fp.any(max=1)])\n\n        with pytest.raises(fp.exceptions.processnotregisterederror):\n            # cd with two arguments won't match with max=1\n            subprocess.check_call(\"cd ~/ /tmp\")\n        # but any single argument is fine\n        assert subprocess.check_call(\"cd ~/\") == 0\n\n        # `min` and `max` can be used together\n        fp.register([\"my_app\", fp.any(min=1, max=2)])\n        assert subprocess.check_call([\"my_app\", \"--help\"]) == 0\n\n\nyou can also specify just the command name, and have it match any command with\nthe same name, regardless of the location. this is accomplished with\n``fake_subprocess.program(\"name\")``.\n\n.. code-block:: python\n\n    def test_any_matching_program(fp):\n        # define a command that can come from anywhere\n        fp.register([fp.program(\"ls\")])\n        assert subprocess.check_call(\"/bin/ls\") == 0\n\n\ncheck if process was called\n---------------------------\n\nyou may want to simply check if a certain command was called, you can do this\nby accessing ``fp.calls``, where all commands are stored as-called.\nyou can also use a utility function ``fp.call_count()`` to see\nhow many a command has been called. the latter supports ``fp.any()``.\n\n.. code-block:: python\n\n    def test_check_if_called(fp):\n        fp.keep_last_process(true)\n        # any command can be called\n        fp.register([fp.any()])\n\n        subprocess.check_call([\"cp\", \"/tmp/source\", \"/source\"])\n        subprocess.check_call([\"cp\", \"/source\", \"/destination\"])\n        subprocess.check_call([\"cp\", \"/source\", \"/other/destination\"])\n\n        # you can check if command is in ``fp.calls``\n        assert [\"cp\", \"/tmp/source\", \"/source\"] in fp.calls\n        assert [\"cp\", \"/source\", \"/destination\"] in fp.calls\n        assert [\"cp\", \"/source\", \"/other/destination\"] in fp.calls\n\n        # or check how many it was called, possibly with wildcard arguments\n        assert fp.call_count([\"cp\", \"/source\", \"/destination\"]) == 1\n\n        # with ``call_count()`` you don't need to use the same type as\n        # the subprocess was called\n        assert fp.call_count(\"cp /tmp/source /source\") == 1\n\n        # can be used with ``fp.any()`` to match more calls\n        assert fp.call_count([\"cp\", fp.any()]) == 3\n\n\nhandling signals\n----------------\n\nyou can use standard ``kill()``, ``terminate()`` or ``send_signal()`` methods\nin ``popen`` instances. there is an additional ``received_signals()`` method\nto get a tuple of all signals received by the process. it is also possible to\nset up an optional callback function for signals.\n\n.. code-block:: python\n\n    import signal\n\n\n    def test_signal_callback(fp):\n        \"\"\"test that signal callbacks work.\"\"\"\n\n        def callback(process, sig):\n            if sig == signal.sigterm:\n                process.returncode = -1\n\n        # the `register()` method returns a progressrecorder object, where\n        # all future matching `popen()` instances will be appended\n        process_recorder = fp.register(\"test\", signal_callback=callback)\n\n        process = subprocess.popen(\"test\")\n        process.send_signal(signal.sigterm)\n        process.wait()\n\n        assert process.returncode == -1\n        assert process.received_signals() == (signal.sigterm,)\n\n        # the instance appended to `register()` output is the `popen` instance\n        # created later\n        assert process_recorder.first_call is process\n\n\nasyncio support\n---------------\n\nthe plugin now supports asyncio and works for ``asyncio.create_subprocess_shell``\nand ``asyncio.create_subprocess_exec``:\n\n.. code-block:: python\n\n    @pytest.mark.asyncio\n    async def test_basic_usage(\n        fp,\n    ):\n        fp.register(\n            [\"some-command-that-is-definitely-unavailable\"], returncode=500\n        )\n\n        process = await asyncio.create_subprocess_shell(\n            \"some-command-that-is-definitely-unavailable\"\n        )\n        returncode = await process.wait()\n\n        assert process.returncode == returncode\n        assert process.returncode == 500\n\n.. _`pip`: https://pypi.org/project/pip/\n.. _`pypi`: https://pypi.org/project\n\n\n.. include-end\n\ndocumentation\n-------------\n\nfor full documentation, including api reference, please see https://pytest-subprocess.readthedocs.io/en/latest/.\n\ncontributing\n------------\ncontributions are very welcome. tests can be run with `tox`_, please ensure\nthe coverage at least stays the same before you submit a pull request.\n\nlicense\n-------\n\ndistributed under the terms of the `mit`_ license, \"pytest-subprocess\" is free and open source software\n\n\nissues\n------\n\nif you encounter any problems, please `file an issue`_ along with a detailed description.\n\n----\n\nthis `pytest`_ plugin was generated with `cookiecutter`_ along with `@hackebrot`_'s `cookiecutter-pytest-plugin`_ template.\n\n.. _`cookiecutter`: https://github.com/audreyr/cookiecutter\n.. _`@hackebrot`: https://github.com/hackebrot\n.. _`mit`: http://opensource.org/licenses/mit\n.. _`bsd-3`: http://opensource.org/licenses/bsd-3-clause\n.. _`gnu gpl v3.0`: http://www.gnu.org/licenses/gpl-3.0.txt\n.. _`apache software license 2.0`: http://www.apache.org/licenses/license-2.0\n.. _`cookiecutter-pytest-plugin`: https://github.com/pytest-dev/cookiecutter-pytest-plugin\n.. _`file an issue`: https://github.com/aklajnert/pytest-subprocess/issues\n.. _`pytest`: https://github.com/pytest-dev/pytest\n.. _`tox`: https://tox.readthedocs.io/en/latest/\n\nhistory\n=======\n\n1.5.0 (2023-01-28)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#109 <https://github.com/aklajnert/pytest-subprocess/pull/109>`_: match also `os.pathlike`.\n* `#105 <https://github.com/aklajnert/pytest-subprocess/pull/105>`_: add program matcher.\n\nother changes  \n~~~~~~~~~~~~~\n* `#110 <https://github.com/aklajnert/pytest-subprocess/pull/110>`_: produce typeerror on win py<3.8 for path args.\n\n1.4.2 (2022-10-02)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#87 <https://github.com/aklajnert/pytest-subprocess/pull/87>`_: add support for python 3.11.\n* `#80 <https://github.com/aklajnert/pytest-subprocess/pull/80>`_, `#86 <https://github.com/aklajnert/pytest-subprocess/pull/86>`_: the `register()` method returns an auxiliary object that will contain all matching `fakepopen` instances.\n\nbug fixes  \n~~~~~~~~~\n* `#93 <https://github.com/aklajnert/pytest-subprocess/pull/93>`_: raise callback exceptions on `communicate()` calls.\n\nother changes  \n~~~~~~~~~~~~~\n* `#97 <https://github.com/aklajnert/pytest-subprocess/pull/97>`_: fixed warnings in tests, treat warnings as errors.\n* `#91 <https://github.com/aklajnert/pytest-subprocess/pull/91>`_: use `sys.executable` instead just `\"python\"` in tests while invoking python subprocess.\n* `#90 <https://github.com/aklajnert/pytest-subprocess/pull/90>`_: fix documentation build, add ci check for it.\n\n1.4.1 (2022-02-09)  \n------------------\n\nother changes  \n~~~~~~~~~~~~~\n* `#74 <https://github.com/aklajnert/pytest-subprocess/pull/74>`_: add ``fp`` alias for the fixture, and ``register`` for the ``regisiter_subprocess``.\n\n1.4.0 (2022-01-23)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#71 <https://github.com/aklajnert/pytest-subprocess/pull/71>`_: add support for stdin with asyncio.\n\nbug fixes  \n~~~~~~~~~\n* `#68 <https://github.com/aklajnert/pytest-subprocess/pull/68>`_: make `stdout` and `stderr` an `asyncio.streamreader` instance when using asyncio functions.\n* `#63 <https://github.com/aklajnert/pytest-subprocess/pull/63>`_, `#67 <https://github.com/aklajnert/pytest-subprocess/pull/67>`_: add missing items to `asyncio.subprocess`.\n\nother changes  \n~~~~~~~~~~~~~\n* `#69 <https://github.com/aklajnert/pytest-subprocess/pull/69>`_: extracted code into separate files to improve navigation.\n\n1.3.2 (2021-11-07)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#61 <https://github.com/aklajnert/pytest-subprocess/pull/61>`_: fixed behavior of ``asyncio.create_subproess_exec()``.\n\n1.3.1 (2021-11-01)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#58 <https://github.com/aklajnert/pytest-subprocess/pull/58>`_: correctly handle file stream output.\n\n1.3.0 (2021-10-24)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#55 <https://github.com/aklajnert/pytest-subprocess/pull/55>`_: add support for ``terminate()``, ``kill()``, ``send_signal()``.\n\n1.2.0 (2021-10-09)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#49 <https://github.com/aklajnert/pytest-subprocess/pull/49>`_, `#52 <https://github.com/aklajnert/pytest-subprocess/pull/52>`_: add support for ``asyncio``.\n\nother changes  \n~~~~~~~~~~~~~\n* `#50 <https://github.com/aklajnert/pytest-subprocess/pull/50>`_: change docs theme.\n\n1.1.2 (2021-07-17)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#47 <https://github.com/aklajnert/pytest-subprocess/pull/47>`_: prevent `allow_unregistered()` and `keep_last_process()` from affecting other tests.\n\n1.1.1 (2021-06-18)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#43 <https://github.com/aklajnert/pytest-subprocess/pull/43>`_: wait for callback thread to finish when calling ``communicate()``.\n\nother changes  \n~~~~~~~~~~~~~\n* `#42 <https://github.com/aklajnert/pytest-subprocess/pull/42>`_: fix type annotations for `register_subprocess()`.\n\n1.1.0 (2021-04-18)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#37 <https://github.com/aklajnert/pytest-subprocess/pull/37>`_: preserve original command in `proc.args` to prevent leaking the internal `command` type.\n\nother changes  \n~~~~~~~~~~~~~\n* `#38 <https://github.com/aklajnert/pytest-subprocess/pull/38>`_: switched ci from azure pipelines to github actions.\n* `#35 <https://github.com/aklajnert/pytest-subprocess/pull/35>`_: drop support for python 3.4 and 3.5. move type annotations from `.pyi` files into sources.\n\n1.0.1 (2021-03-20)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#34 <https://github.com/aklajnert/pytest-subprocess/pull/34>`_: prevent appending newlines to outputs unless defined as list/tuple.\n\nother changes  \n~~~~~~~~~~~~~\n* `#32 <https://github.com/aklajnert/pytest-subprocess/pull/32>`_: make the ``command`` class iterable.\n\n1.0.0 (2020-08-22)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#29 <https://github.com/aklajnert/pytest-subprocess/pull/29>`_: remember subprocess calls to check if expected commands were executed.\n* `#28 <https://github.com/aklajnert/pytest-subprocess/pull/28>`_: allow to match a command with variable arguments (non-exact matching).\n\n0.1.5 (2020-06-19)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#26 <https://github.com/aklajnert/pytest-subprocess/pull/26>`_: `encoding` and `errors` arguments will properly trigger `text` mode.\n\n0.1.4 (2020-04-28)  \n------------------\n\nbug fixes  \n~~~~~~~~~\n* `#22 <https://github.com/aklajnert/pytest-subprocess/pull/22>`_: the `returncode` will not be ignored when `callback` is used.\n* `#21 <https://github.com/aklajnert/pytest-subprocess/pull/21>`_: the exception raised from callback will take precedence over those from subprocess.\n* `#20 <https://github.com/aklajnert/pytest-subprocess/pull/20>`_: registering process will be now consistent regardless of the command type.\n* `#19 <https://github.com/aklajnert/pytest-subprocess/pull/19>`_: fixed crash for stderr redirect with an empty stream definition.\n\n0.1.3 (2020-03-04)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#13 <https://github.com/aklajnert/pytest-subprocess/pull/13>`_: allow passing keyword arguments into callbacks.\n\nbug fixes  \n~~~~~~~~~\n* `#12 <https://github.com/aklajnert/pytest-subprocess/pull/12>`_: properly raise exceptions from callback functions.\n\ndocumentation changes  \n~~~~~~~~~~~~~~~~~~~~~\n* `#15 <https://github.com/aklajnert/pytest-subprocess/pull/15>`_: add documentation chapter about the callback functions.\n\n0.1.2 (2020-01-17)  \n------------------\n\nfeatures  \n~~~~~~~~\n* `#3 <https://github.com/aklajnert/pytest-subprocess/pull/3>`_: add basic support for process input.\n\nbug fixes  \n~~~~~~~~~\n* `#5 <https://github.com/aklajnert/pytest-subprocess/pull/5>`_: make ``wait()`` method to raise ``timeouterror`` after the desired time will elapse.\n\ndocumentation changes  \n~~~~~~~~~~~~~~~~~~~~~\n* `#7 <https://github.com/aklajnert/pytest-subprocess/pull/7>`_, `#8 <https://github.com/aklajnert/pytest-subprocess/pull/8>`_, `#9 <https://github.com/aklajnert/pytest-subprocess/pull/9>`_: create sphinx documentation.\n\nother changes  \n~~~~~~~~~~~~~\n* `#10 <https://github.com/aklajnert/pytest-subprocess/pull/10>`_:  switch from ``tox`` to ``nox`` for running tests and tasks.\n* `#4 <https://github.com/aklajnert/pytest-subprocess/pull/4>`_: add classifier for python 3.9. update ci config to test also on that interpreter version.\n\n0.1.1 (2019-11-24)  \n------------------\n\nother changes  \n~~~~~~~~~~~~~\n* `#1 <https://github.com/aklajnert/pytest-subprocess/pull/1>`_, `#2 <https://github.com/aklajnert/pytest-subprocess/pull/2>`_: enable support for python 3.4, add ci tests for that version.\n\n0.1.0 (2019-11-23)  \n------------------\n\ninitial release  \n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "pytest-subprocess",
  "package_url": "https://pypi.org/project/pytest-subprocess/",
  "project_url": "https://pypi.org/project/pytest-subprocess/",
  "project_urls": {
    "Documentation": "https://pytest-subprocess.readthedocs.io",
    "Source": "https://github.com/aklajnert/pytest-subprocess",
    "Tracker": "https://github.com/aklajnert/pytest-subprocess/issues"
  },
  "release_url": "https://pypi.org/project/pytest-subprocess/1.5.0/",
  "requires_dist": [
    "pytest (>=4.0.0)",
    "nox ; extra == 'dev'",
    "changelogd ; extra == 'dev'",
    "sphinx ; extra == 'docs'",
    "furo ; extra == 'docs'",
    "sphinxcontrib-napoleon ; extra == 'docs'",
    "sphinx-autodoc-typehints ; extra == 'docs'",
    "changelogd ; extra == 'docs'",
    "pytest (>=4.0) ; extra == 'test'",
    "coverage ; extra == 'test'",
    "docutils (>=0.12) ; extra == 'test'",
    "Pygments (>=2.0) ; extra == 'test'",
    "pytest-rerunfailures ; extra == 'test'",
    "pytest-asyncio (>=0.15.1) ; extra == 'test'",
    "anyio ; extra == 'test'"
  ],
  "requires_python": ">=3.6",
  "summary": "a plugin to fake subprocess for pytest",
  "version": "1.5.0",
  "releases": [],
  "developers": [
    "andrzej_klajnert",
    "python@aklajnert.pl"
  ],
  "kwds": "pytest subprocess create_subprocess_exec register_subprocess create_subprocess_shell",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytest_subprocess",
  "homepage": "",
  "release_count": 19,
  "dependency_ids": [
    "pypi_anyio",
    "pypi_changelogd",
    "pypi_coverage",
    "pypi_docutils",
    "pypi_furo",
    "pypi_nox",
    "pypi_pygments",
    "pypi_pytest",
    "pypi_pytest_asyncio",
    "pypi_pytest_rerunfailures",
    "pypi_sphinx",
    "pypi_sphinx_autodoc_typehints",
    "pypi_sphinxcontrib_napoleon"
  ]
}