{
  "classifiers": [],
  "description": "welcome to python-rex\n=====================\n\n.. image:: https://pypip.in/v/python-rex/badge.png\n   :target: https://crate.io/packages/python-rex\n.. image:: https://pypip.in/d/python-rex/badge.png\n   :target: https://crate.io/packages/python-rex\n.. image:: https://travis-ci.org/cypreess/python-rex.png?branch=master\n   :target: https://travis-ci.org/cypreess/python-rex\n.. image:: https://coveralls.io/repos/cypreess/python-rex/badge.png?branch=master\n   :target: https://coveralls.io/r/cypreess/python-rex?branch=master\n   \npython **rex** is regular expressions for humans. (**rex** is also abbreviation from **re** **x** tended).\n\n**rex** is for the `re standard module <http://docs.python.org/2/library/index.html>`_ as\n`requests <http://docs.python-requests.org/en/latest/>`_ is for `urllib module <http://docs.python.org/2/library/urllib.html>`_.\n\n**rex** also is `latin for \"king\" <http://en.wikipedia.org/wiki/rex>`_, and the king of regular expressions is perl.\nso **rex** api tries to mimic at least some perl's idioms.\n\nsupported python versions: 2.6, 2.7, 3.3\n\ninstallation\n============\n\n::\n\n    pip install python-rex\n\nor\n\n::\n   \n   pip install -e git+https://github.com/cypreess/python-rex.git#egg=rex-dev\n\nthere are no external dependencies. \n\n\n::\n   \n   from rex import rex\n\n\n\nquickstart\n==========\n\ndo that::\n\n   from rex import rex\n   print (\"your ticket number: xyz-1047. have fun!\" == rex(\"/[a-z]{3}-(\\d{4})/i\"))[1]\n    \n\ninstead of doing that::\n\n   import re\n   regex = re.compile(\"[a-z]{3}-(\\d{4})\", flags=re.ignorecase)\n   m = regex.search(\"your ticket number: xyz-1047. have fun!\")\n   \n   if m is not none:\n      print m.group(1)\n   else:\n      print none\n   \n   # or in shorter way\n   print m.group(1) if m else none\n\n\n(both should print ``1047``).\n\ndocs\n====\n\nso far **rex** supports:\n\n* simple matching (first match),\n* substitution,\n* all python re flags.\n\n\n\nmatching \n--------\n\nthe most obvious usage - test condition by matching to string::\n\n    if 'this is a dog' == rex('/dog/'):\n        print 'oh yeah'\n\n\nor::\n\n    if 'my lucky 777 number' == rex('/[0-9]+/'):\n        print 'number found'\n\n\nyou can use perl notation and prepend ``m`` character to your search::\n\n\n    if 'my lucky 777 number' == rex('m/[0-9]+/'):\n        print 'number found'\n\n\nbut you can also simply check your match::\n\n\n    if ('my lucky 777 number' == rex('m/[0-9]+/'))[0] == '777':\n        print 'number found'\n\nor even groups::\n\n\n    if ('my lucky 777 number' == rex('m/(?p<number>[0-9]+)/'))['number'] == '777':\n        print 'number found'\n\n\nremember a mess with re module when it does not match anything? rex won't let you down,\nit will kindly return ``none`` for whatever you ask::\n\n    >>> print ('my lucky 777 number' == rex('m/(?p<number>[0-9]+)/'))['no_such_group']\n    none\n\n    >>> print (\"i don't tell you my lucky number\" == rex('m/(?p<number>[0-9]+)/'))['number']\n    none\n\n\nsubstituting\n------------\n\nsubstitution can be made by prefixing pattern with ``s`` character (like in perl expression)::\n\n    >>> print \"this is a cat\" == rex('s/cat/dog/i')\n    this is a dog\n\n\nflags\n-----\n\nevery **rex** pattern as in perl patterns allows to suffix some flags, e.g. ``rex('/pattern/iu')`` for enabling ``i`` and ``u`` flag. **rex** supports all standard python re flags:\n\n* ``d`` - re.debug\n* ``i`` - re.ignorecase\n* ``l`` - re.locale\n* ``m`` - re.multiline\n* ``s`` - re.dotall\n* ``u`` - re.unicode\n* ``x`` - re.verbose\n\ncaching\n-------\n\n**rex** caches all patterns so reusing patterns is super fast. you can always clear **rex** cache by calling ``rex_clear_cache()`` or\ndisable caching for specific patterns ``rex('/pattern/', cache=false)``.\n\n\nrex for orthodox\n----------------\n\nif you are so orthodox pythonist that couldn't leave with overloaded ``==`` operator syntax in your codebase,\nyou can use \"orthodox mode\" of rex. just put the string to match/substitute against as a second argument::\n\n    >>> bool(rex(\"/dog/\", \"this is a dog\"))\n    true\n    >>> rex(\"s/cat/dog/\", \"this is a cat\")\n    'this is a dog'\n\nadditionally rex objects are callable. this is especially useful in situations where you need to process many values\nagainst the same regular expression::\n\n    >>> my_re = rex(\"/foo/\")\n    >>> for thing in [\"foobar\", \"bar\", \"barfoo\"]:\n    ...     print bool(my_re(thing))\n    true\n    false\n    true\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "python-rex",
  "package_url": "https://pypi.org/project/python-rex/",
  "project_url": "https://pypi.org/project/python-rex/",
  "project_urls": {
    "Download": "UNKNOWN",
    "Homepage": "https://github.com/cypreess/python-rex"
  },
  "release_url": "https://pypi.org/project/python-rex/0.4/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "python regular expressions for humans",
  "version": "0.4",
  "releases": [],
  "developers": [
    "cypreess@gmail.com",
    "krzysztof_dorosz"
  ],
  "kwds": "rex pythonist python abbreviation pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_python_rex",
  "homepage": "https://github.com/cypreess/python-rex",
  "release_count": 6,
  "dependency_ids": []
}