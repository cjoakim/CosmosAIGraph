{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# cma-es\n\n[![software license](https://img.shields.io/badge/license-mit-brightgreen.svg?style=flat-square)](./license) [![pypi - downloads](https://img.shields.io/pypi/dw/cmaes)](https://pypistats.org/packages/cmaes)\n\nlightweight covariance matrix adaptation evolution strategy (cma-es) [1] implementation.\n\n![visualize-six-hump-camel](https://user-images.githubusercontent.com/5564044/73486622-db5cff00-43e8-11ea-98fb-8246dbacab6d.gif)\n\n## news\n* **2023/05/23** our paper, [m. nomura, y. akimoto, and i. ono, cma-es with learning rate adaptation: can cma-es with default population size solve multimodal and noisy problems?](https://arxiv.org/abs/2304.03473), has been nominated for the best paper award in the enum track at gecco'23 :whale:\n* **2023/04/01** two papers have been accepted to gecco'23 enum track: (1) [m. nomura, y. akimoto, and i. ono, cma-es with learning rate adaptation: can cma-es with default population size solve multimodal and noisy problems?](https://arxiv.org/abs/2304.03473), and (2) [y. watanabe, k. uchida, r. hamano, s. saito, m. nomura, and s. shirakawa, (1+1)-cma-es with margin for discrete and mixed-integer problems](https://arxiv.org/abs/2305.00849) :tada:\n* **2022/05/13** the paper, [\"cma-es with margin: lower-bounding marginal probability for mixed-integer black-box optimization\"](https://arxiv.org/abs/2205.13482) written by hamano, saito, [@nomuramasahir0](https://github.com/nomuramasahir0) (the maintainer of this library), and shirakawa, has been nominated as best paper at gecco'22 enum track.\n* **2021/03/10** [\"introduction to cma-es sampler\"](https://medium.com/optuna/introduction-to-cma-es-sampler-ee68194c8f88) is published at optuna medium blog. this article explains when and how to make the best use out of cma-es sampler. please check it out!\n* **2021/02/02** the paper [\"warm starting cma-es for hyperparameter optimization\"](https://arxiv.org/abs/2012.06932) written by [@nomuramasahir0](https://github.com/nomuramasahir0), the maintainer of this library, is accepted at aaai 2021 :tada:\n* **2020/07/29** optuna's built-in cma-es sampler which uses this library under the hood is stabled at optuna v2.0. please check out the [v2.0 release blog](https://medium.com/optuna/optuna-v2-3165e3f1fc2).\n\n## installation\n\nsupported python versions are 3.7 or later.\n\n```\n$ pip install cmaes\n```\n\nor you can install via [conda-forge](https://anaconda.org/conda-forge/cmaes).\n\n```\n$ conda install -c conda-forge cmaes\n```\n\n## usage\n\nthis library provides an \"ask-and-tell\" style interface.\n\n```python\nimport numpy as np\nfrom cmaes import cma\n\ndef quadratic(x1, x2):\n    return (x1 - 3) ** 2 + (10 * (x2 + 2)) ** 2\n\nif __name__ == \"__main__\":\n    optimizer = cma(mean=np.zeros(2), sigma=1.3)\n\n    for generation in range(50):\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x = optimizer.ask()\n            value = quadratic(x[0], x[1])\n            solutions.append((x, value))\n            print(f\"#{generation} {value} (x1={x[0]}, x2 = {x[1]})\")\n        optimizer.tell(solutions)\n```\n\nand you can use this library via [optuna](https://github.com/optuna/optuna) [2], an automatic hyperparameter optimization framework.\noptuna's built-in cma-es sampler which uses this library under the hood is available from [v1.3.0](https://github.com/optuna/optuna/releases/tag/v1.3.0) and stabled at [v2.0.0](https://github.com/optuna/optuna/releases/tag/v2.2.0).\nsee [the documentation](https://optuna.readthedocs.io/en/stable/reference/samplers/generated/optuna.samplers.cmaessampler.html) or [v2.0 release blog](https://medium.com/optuna/optuna-v2-3165e3f1fc2) for more details.\n\n```python\nimport optuna\n\ndef objective(trial: optuna.trial):\n    x1 = trial.suggest_uniform(\"x1\", -4, 4)\n    x2 = trial.suggest_uniform(\"x2\", -4, 4)\n    return (x1 - 3) ** 2 + (10 * (x2 + 2)) ** 2\n\nif __name__ == \"__main__\":\n    sampler = optuna.samplers.cmaessampler()\n    study = optuna.create_study(sampler=sampler)\n    study.optimize(objective, n_trials=250)\n```\n\n\n## cma-es variants\n\n#### cma-es with margin [3]\n\ncma-es with margin introduces a lower bound on the marginal probability associated with each discrete dimension so that samples can avoid being fixed to a single point.\nit can be applied to mixed spaces of continuous (float) and discrete (including integer and binary).\n\n|cma-es|cma-eswm|\n|---|---|\n|![cma-es](https://raw.githubusercontent.com/evoconjp/cma-es_with_margin/main/fig/cma-es.gif)|![cma-eswm](https://raw.githubusercontent.com/evoconjp/cma-es_with_margin/main/fig/cma-eswm.gif)|\n\nthe above figures are taken from [evoconjp/cma-es_with_margin](https://github.com/evoconjp/cma-es_with_margin).\n\n<details>\n<summary>source code</summary>\n\n```python\nimport numpy as np\nfrom cmaes import cmawm\n\n\ndef ellipsoid_onemax(x, n_zdim):\n    n = len(x)\n    n_rdim = n - n_zdim\n    r = 10\n    if len(x) < 2:\n        raise valueerror(\"dimension must be greater one\")\n    ellipsoid = sum([(1000 ** (i / (n_rdim - 1)) * x[i]) ** 2 for i in range(n_rdim)])\n    onemax = n_zdim - (0.0 < x[(n - n_zdim) :]).sum()\n    return ellipsoid + r * onemax\n\n\ndef main():\n    binary_dim, continuous_dim = 10, 10\n    dim = binary_dim + continuous_dim\n    bounds = np.concatenate(\n        [\n            np.tile([-np.inf, np.inf], (continuous_dim, 1)),\n            np.tile([0, 1], (binary_dim, 1)),\n        ]\n    )\n    steps = np.concatenate([np.zeros(continuous_dim), np.ones(binary_dim)])\n    optimizer = cmawm(mean=np.zeros(dim), sigma=2.0, bounds=bounds, steps=steps)\n    print(\" evals    f(x)\")\n    print(\"======  ==========\")\n\n    evals = 0\n    while true:\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x_for_eval, x_for_tell = optimizer.ask()\n            value = ellipsoid_onemax(x_for_eval, binary_dim)\n            evals += 1\n            solutions.append((x_for_tell, value))\n            if evals % 300 == 0:\n                print(f\"{evals:5d}  {value:10.5f}\")\n        optimizer.tell(solutions)\n\n        if optimizer.should_stop():\n            break\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nsource code is also available [here](./examples/cmaes_with_margin.py).\n\n</details>\n\n#### warm starting cma-es [4]\n\nwarm starting cma-es is a method to transfer prior knowledge on similar hpo tasks through the initialization of cma-es.\nhere is the result of an experiment that tuning lightgbm for kaggle's toxic comment classification challenge data, a multilabel classification dataset.\nin this benchmark, we use 10% of a full dataset as the source task, and a full dataset as the target task.\nplease refer [the paper](https://arxiv.org/abs/2012.06932) and/or https://github.com/c-bata/benchmark-warm-starting-cmaes for more details of experiment settings.\n\n![benchmark-lightgbm-toxic](https://github.com/c-bata/benchmark-warm-starting-cmaes/raw/main/result.png)\n\n<details>\n<summary>source code</summary>\n\n```python\nimport numpy as np\nfrom cmaes import cma, get_warm_start_mgd\n\ndef source_task(x1: float, x2: float) -> float:\n    b = 0.4\n    return (x1 - b) ** 2 + (x2 - b) ** 2\n\ndef target_task(x1: float, x2: float) -> float:\n    b = 0.6\n    return (x1 - b) ** 2 + (x2 - b) ** 2\n\nif __name__ == \"__main__\":\n    # generate solutions from a source task\n    source_solutions = []\n    for _ in range(1000):\n        x = np.random.random(2)\n        value = source_task(x[0], x[1])\n        source_solutions.append((x, value))\n\n    # estimate a promising distribution of the source task,\n    # then generate parameters of the multivariate gaussian distribution.\n    ws_mean, ws_sigma, ws_cov = get_warm_start_mgd(\n        source_solutions, gamma=0.1, alpha=0.1\n    )\n    optimizer = cma(mean=ws_mean, sigma=ws_sigma, cov=ws_cov)\n\n    # run ws-cma-es\n    print(\" g    f(x1,x2)     x1      x2  \")\n    print(\"===  ==========  ======  ======\")\n    while true:\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x = optimizer.ask()\n            value = target_task(x[0], x[1])\n            solutions.append((x, value))\n            print(\n                f\"{optimizer.generation:3d}  {value:10.5f}\"\n                f\"  {x[0]:6.2f}  {x[1]:6.2f}\"\n            )\n        optimizer.tell(solutions)\n\n        if optimizer.should_stop():\n            break\n```\n\nthe full source code is available [here](./examples/ws_cma_es.py).\n\n</details>\n\n#### separable cma-es [5]\n\nsep-cma-es is an algorithm which constrains the covariance matrix to be diagonal.\ndue to the reduction of the number of parameters, the learning rate for the covariance matrix can be increased.\nconsequently, this algorithm outperforms cma-es on separable functions.\n\n<details>\n<summary>source code</summary>\n\n```python\nimport numpy as np\nfrom cmaes import sepcma\n\ndef ellipsoid(x):\n    n = len(x)\n    if len(x) < 2:\n        raise valueerror(\"dimension must be greater one\")\n    return sum([(1000 ** (i / (n - 1)) * x[i]) ** 2 for i in range(n)])\n\nif __name__ == \"__main__\":\n    dim = 40\n    optimizer = sepcma(mean=3 * np.ones(dim), sigma=2.0)\n    print(\" evals    f(x)\")\n    print(\"======  ==========\")\n\n    evals = 0\n    while true:\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x = optimizer.ask()\n            value = ellipsoid(x)\n            evals += 1\n            solutions.append((x, value))\n            if evals % 3000 == 0:\n                print(f\"{evals:5d}  {value:10.5f}\")\n        optimizer.tell(solutions)\n\n        if optimizer.should_stop():\n            break\n```\n\nfull source code is available [here](./examples/sepcma_ellipsoid_function.py).\n\n</details>\n\n#### ipop-cma-es [6]\n\nipop-cma-es is a method to restart cma-es with increasing population size like below.\n\n![visualize-ipop-cmaes-himmelblau](https://user-images.githubusercontent.com/5564044/88472274-f9e12480-cf4b-11ea-8aff-2a859eb51a15.gif)\n\n<details>\n<summary>source code</summary>\n\n```python\nimport math\nimport numpy as np\nfrom cmaes import cma\n\ndef ackley(x1, x2):\n    # https://www.sfu.ca/~ssurjano/ackley.html\n    return (\n        -20 * math.exp(-0.2 * math.sqrt(0.5 * (x1 ** 2 + x2 ** 2)))\n        - math.exp(0.5 * (math.cos(2 * math.pi * x1) + math.cos(2 * math.pi * x2)))\n        + math.e + 20\n    )\n\nif __name__ == \"__main__\":\n    bounds = np.array([[-32.768, 32.768], [-32.768, 32.768]])\n    lower_bounds, upper_bounds = bounds[:, 0], bounds[:, 1]\n\n    mean = lower_bounds + (np.random.rand(2) * (upper_bounds - lower_bounds))\n    sigma = 32.768 * 2 / 5  # 1/5 of the domain width\n    optimizer = cma(mean=mean, sigma=sigma, bounds=bounds, seed=0)\n\n    for generation in range(200):\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x = optimizer.ask()\n            value = ackley(x[0], x[1])\n            solutions.append((x, value))\n            print(f\"#{generation} {value} (x1={x[0]}, x2 = {x[1]})\")\n        optimizer.tell(solutions)\n\n        if optimizer.should_stop():\n            # popsize multiplied by 2 (or 3) before each restart.\n            popsize = optimizer.population_size * 2\n            mean = lower_bounds + (np.random.rand(2) * (upper_bounds - lower_bounds))\n            optimizer = cma(mean=mean, sigma=sigma, population_size=popsize)\n            print(f\"restart cma-es with popsize={popsize}\")\n```\n\nfull source code is available [here](./examples/ipop_cmaes.py).\n\n</details>\n\n#### bipop-cma-es [7]\n\nbipop-cma-es applies two interlaced restart strategies, one with an increasing population size and one with varying small population sizes.\n\n![visualize-bipop-cmaes-himmelblau](https://user-images.githubusercontent.com/5564044/88471815-55111800-cf48-11ea-8933-5a4b48c49eba.gif)\n\n<details>\n<summary>source code</summary>\n\n```python\nimport math\nimport numpy as np\nfrom cmaes import cma\n\ndef ackley(x1, x2):\n    # https://www.sfu.ca/~ssurjano/ackley.html\n    return (\n        -20 * math.exp(-0.2 * math.sqrt(0.5 * (x1 ** 2 + x2 ** 2)))\n        - math.exp(0.5 * (math.cos(2 * math.pi * x1) + math.cos(2 * math.pi * x2)))\n        + math.e + 20\n    )\n\nif __name__ == \"__main__\":\n    bounds = np.array([[-32.768, 32.768], [-32.768, 32.768]])\n    lower_bounds, upper_bounds = bounds[:, 0], bounds[:, 1]\n\n    mean = lower_bounds + (np.random.rand(2) * (upper_bounds - lower_bounds))\n    sigma = 32.768 * 2 / 5  # 1/5 of the domain width\n    optimizer = cma(mean=mean, sigma=sigma, bounds=bounds, seed=0)\n\n    n_restarts = 0  # a small restart doesn't count in the n_restarts\n    small_n_eval, large_n_eval = 0, 0\n    popsize0 = optimizer.population_size\n    inc_popsize = 2\n\n    # initial run is with \"normal\" population size; it is\n    # the large population before first doubling, but its\n    # budget accounting is the same as in case of small\n    # population.\n    poptype = \"small\"\n\n    for generation in range(200):\n        solutions = []\n        for _ in range(optimizer.population_size):\n            x = optimizer.ask()\n            value = ackley(x[0], x[1])\n            solutions.append((x, value))\n            print(f\"#{generation} {value} (x1={x[0]}, x2 = {x[1]})\")\n        optimizer.tell(solutions)\n\n        if optimizer.should_stop():\n            n_eval = optimizer.population_size * optimizer.generation\n            if poptype == \"small\":\n                small_n_eval += n_eval\n            else:  # poptype == \"large\"\n                large_n_eval += n_eval\n\n            if small_n_eval < large_n_eval:\n                poptype = \"small\"\n                popsize_multiplier = inc_popsize ** n_restarts\n                popsize = math.floor(\n                    popsize0 * popsize_multiplier ** (np.random.uniform() ** 2)\n                )\n            else:\n                poptype = \"large\"\n                n_restarts += 1\n                popsize = popsize0 * (inc_popsize ** n_restarts)\n\n            mean = lower_bounds + (np.random.rand(2) * (upper_bounds - lower_bounds))\n            optimizer = cma(\n                mean=mean,\n                sigma=sigma,\n                bounds=bounds,\n                population_size=popsize,\n            )\n            print(\"restart cma-es with popsize={} ({})\".format(popsize, poptype))\n```\n\nfull source code is available [here](./examples/bipop_cmaes.py).\n\n</details>\n\n## benchmark results\n\n| [rosenbrock function](https://www.sfu.ca/~ssurjano/rosen.html) | [six-hump camel function](https://www.sfu.ca/~ssurjano/camel6.html) |\n| ------------------- | ----------------------- |\n| ![rosenbrock](https://user-images.githubusercontent.com/5564044/73486735-0cd5ca80-43e9-11ea-9e6e-35028edf4ee8.png) | ![six-hump-camel](https://user-images.githubusercontent.com/5564044/73486738-0e9f8e00-43e9-11ea-8e65-d60fd5853b8d.png) |\n\nthis implementation (green) stands comparison with [pycma](https://github.com/cma-es/pycma) (blue).\nsee [benchmark](./benchmark) for details.\n\n## links\n\n**projects using cmaes:**\n\n* [optuna](https://github.com/optuna/optuna) : a hyperparameter optimization framework that supports cma-es using this library under the hood.\n* (if you have a project which uses `cmaes` and want your own project to be listed here, please submit a github issue.)\n\n**other libraries:**\n\ni respect all libraries involved in cma-es.\n\n* [pycma](https://github.com/cma-es/pycma) : most famous cma-es implementation by nikolaus hansen.\n* [pymoo](https://github.com/msu-coinlab/pymoo) : multi-objective optimization in python.\n* [evojax](https://github.com/google/evojax) : evojax provides a jax-port of this library.\n* [evosax](https://github.com/roberttlange/evosax) : evosax provides jax-based cma-es and sep-cma-es implementation, which is inspired by this library.\n\n**references:**\n\n* [1] [n. hansen, the cma evolution strategy: a tutorial. arxiv:1604.00772, 2016.](https://arxiv.org/abs/1604.00772)\n* [2] [t. akiba, s. sano, t. yanase, t. ohta, m. koyama, optuna: a next-generation hyperparameter optimization framework, kdd, 2019.](https://dl.acm.org/citation.cfm?id=3330701)\n* [3] [r. hamano, s. saito, m. nomura, s. shirakawa, cma-es with margin: lower-bounding marginal probability for mixed-integer black-box optimization, gecco, 2022.](https://arxiv.org/abs/2205.13482)\n* [4] [m. nomura, s. watanabe, y. akimoto, y. ozaki, m. onishi, warm starting cma-es for hyperparameter optimization, aaai, 2021.](https://arxiv.org/abs/2012.06932)\n* [5] [r. ros, n. hansen, a simple modification in cma-es achieving linear time and space complexity, ppsn, 2008.](https://hal.inria.fr/inria-00287367/document)\n* [6] [a. auger, n. hansen, a restart cma evolution strategy with increasing population size, cec, 2005.](https://sci2s.ugr.es/sites/default/files/files/tematicwebsites/eamhco/contributionscec05/auger05arcma.pdf)\n* [7] [n. hansen, benchmarking a bi-population cma-es on the bbob-2009 function testbed, gecco workshop, 2009.](https://hal.inria.fr/inria-00382093/document)\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license  copyright (c) 2020-2021 cyberagent, inc.  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software. ",
  "name": "cmaes",
  "package_url": "https://pypi.org/project/cmaes/",
  "project_url": "https://pypi.org/project/cmaes/",
  "project_urls": {
    "Homepage": "https://github.com/CyberAgentAILab/cmaes"
  },
  "release_url": "https://pypi.org/project/cmaes/0.10.0/",
  "requires_dist": [
    "numpy",
    "scipy ; extra == 'cmawm'"
  ],
  "requires_python": ">=3.7",
  "summary": "lightweight covariance matrix adaptation evolution strategy (cma-es) implementation for python 3.",
  "version": "0.10.0",
  "releases": [],
  "developers": [
    "m.shibata1020@gmail.com",
    "nomura_masahiro@cyberagent.co.jp"
  ],
  "kwds": "adaptation cma cmaes multimodal cmawm",
  "license_kwds": "copyright liable license mit liability",
  "libtype": "pypi",
  "id": "pypi_cmaes",
  "homepage": "",
  "release_count": 18,
  "dependency_ids": [
    "pypi_numpy",
    "pypi_scipy"
  ]
}