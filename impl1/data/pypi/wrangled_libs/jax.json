{
  "classifiers": [
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.9"
  ],
  "description": "<div align=\"center\">\n<img src=\"https://raw.githubusercontent.com/google/jax/main/images/jax_logo_250px.png\" alt=\"logo\"></img>\n</div>\n\n# jax: autograd and xla\n\n![continuous integration](https://github.com/google/jax/actions/workflows/ci-build.yaml/badge.svg)\n![pypi version](https://img.shields.io/pypi/v/jax)\n\n[**quickstart**](#quickstart-colab-in-the-cloud)\n| [**transformations**](#transformations)\n| [**install guide**](#installation)\n| [**neural net libraries**](#neural-network-libraries)\n| [**change logs**](https://jax.readthedocs.io/en/latest/changelog.html)\n| [**reference docs**](https://jax.readthedocs.io/en/latest/)\n\n\n## what is jax?\n\njax is [autograd](https://github.com/hips/autograd) and [xla](https://www.tensorflow.org/xla),\nbrought together for high-performance numerical computing, including\nlarge-scale machine learning research.\n\nwith its updated version of [autograd](https://github.com/hips/autograd),\njax can automatically differentiate native\npython and numpy functions. it can differentiate through loops, branches,\nrecursion, and closures, and it can take derivatives of derivatives of\nderivatives. it supports reverse-mode differentiation (a.k.a. backpropagation)\nvia [`grad`](#automatic-differentiation-with-grad) as well as forward-mode differentiation,\nand the two can be composed arbitrarily to any order.\n\nwhat\u2019s new is that jax uses [xla](https://www.tensorflow.org/xla)\nto compile and run your numpy programs on gpus and tpus. compilation happens\nunder the hood by default, with library calls getting just-in-time compiled and\nexecuted. but jax also lets you just-in-time compile your own python functions\ninto xla-optimized kernels using a one-function api,\n[`jit`](#compilation-with-jit). compilation and automatic differentiation can be\ncomposed arbitrarily, so you can express sophisticated algorithms and get\nmaximal performance without leaving python. you can even program multiple gpus\nor tpu cores at once using [`pmap`](#spmd-programming-with-pmap), and\ndifferentiate through the whole thing.\n\ndig a little deeper, and you'll see that jax is really an extensible system for\n[composable function transformations](#transformations). both\n[`grad`](#automatic-differentiation-with-grad) and [`jit`](#compilation-with-jit)\nare instances of such transformations. others are\n[`vmap`](#auto-vectorization-with-vmap) for automatic vectorization and\n[`pmap`](#spmd-programming-with-pmap) for single-program multiple-data (spmd)\nparallel programming of multiple accelerators, with more to come.\n\nthis is a research project, not an official google product. expect bugs and\n[sharp edges](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html).\nplease help by trying it out, [reporting\nbugs](https://github.com/google/jax/issues), and letting us know what you\nthink!\n\n```python\nimport jax.numpy as jnp\nfrom jax import grad, jit, vmap\n\ndef predict(params, inputs):\n  for w, b in params:\n    outputs = jnp.dot(inputs, w) + b\n    inputs = jnp.tanh(outputs)  # inputs to the next layer\n  return outputs                # no activation on last layer\n\ndef loss(params, inputs, targets):\n  preds = predict(params, inputs)\n  return jnp.sum((preds - targets)**2)\n\ngrad_loss = jit(grad(loss))  # compiled gradient evaluation function\nperex_grads = jit(vmap(grad_loss, in_axes=(none, 0, 0)))  # fast per-example grads\n```\n\n### contents\n* [quickstart: colab in the cloud](#quickstart-colab-in-the-cloud)\n* [transformations](#transformations)\n* [current gotchas](#current-gotchas)\n* [installation](#installation)\n* [neural net libraries](#neural-network-libraries)\n* [citing jax](#citing-jax)\n* [reference documentation](#reference-documentation)\n\n## quickstart: colab in the cloud\njump right in using a notebook in your browser, connected to a google cloud gpu.\nhere are some starter notebooks:\n- [the basics: numpy on accelerators, `grad` for differentiation, `jit` for compilation, and `vmap` for vectorization](https://jax.readthedocs.io/en/latest/notebooks/quickstart.html)\n- [training a simple neural network, with tensorflow dataset data loading](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/neural_network_with_tfds_data.ipynb)\n\n**jax now runs on cloud tpus.** to try out the preview, see the [cloud tpu\ncolabs](https://github.com/google/jax/tree/main/cloud_tpu_colabs).\n\nfor a deeper dive into jax:\n- [the autodiff cookbook, part 1: easy and powerful automatic differentiation in jax](https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html)\n- [common gotchas and sharp edges](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html)\n- see the [full list of\nnotebooks](https://github.com/google/jax/tree/main/docs/notebooks).\n\n## transformations\n\nat its core, jax is an extensible system for transforming numerical functions.\nhere are four transformations of primary interest: `grad`, `jit`, `vmap`, and\n`pmap`.\n\n### automatic differentiation with `grad`\n\njax has roughly the same api as [autograd](https://github.com/hips/autograd).\nthe most popular function is\n[`grad`](https://jax.readthedocs.io/en/latest/jax.html#jax.grad)\nfor reverse-mode gradients:\n\n```python\nfrom jax import grad\nimport jax.numpy as jnp\n\ndef tanh(x):  # define a function\n  y = jnp.exp(-2.0 * x)\n  return (1.0 - y) / (1.0 + y)\n\ngrad_tanh = grad(tanh)  # obtain its gradient function\nprint(grad_tanh(1.0))   # evaluate it at x = 1.0\n# prints 0.4199743\n```\n\nyou can differentiate to any order with `grad`.\n\n```python\nprint(grad(grad(grad(tanh)))(1.0))\n# prints 0.62162673\n```\n\nfor more advanced autodiff, you can use\n[`jax.vjp`](https://jax.readthedocs.io/en/latest/jax.html#jax.vjp) for\nreverse-mode vector-jacobian products and\n[`jax.jvp`](https://jax.readthedocs.io/en/latest/jax.html#jax.jvp) for\nforward-mode jacobian-vector products. the two can be composed arbitrarily with\none another, and with other jax transformations. here's one way to compose those\nto make a function that efficiently computes [full hessian\nmatrices](https://jax.readthedocs.io/en/latest/_autosummary/jax.hessian.html#jax.hessian):\n\n```python\nfrom jax import jit, jacfwd, jacrev\n\ndef hessian(fun):\n  return jit(jacfwd(jacrev(fun)))\n```\n\nas with [autograd](https://github.com/hips/autograd), you're free to use\ndifferentiation with python control structures:\n\n```python\ndef abs_val(x):\n  if x > 0:\n    return x\n  else:\n    return -x\n\nabs_val_grad = grad(abs_val)\nprint(abs_val_grad(1.0))   # prints 1.0\nprint(abs_val_grad(-1.0))  # prints -1.0 (abs_val is re-evaluated)\n```\n\nsee the [reference docs on automatic\ndifferentiation](https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation)\nand the [jax autodiff\ncookbook](https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html)\nfor more.\n\n### compilation with `jit`\n\nyou can use xla to compile your functions end-to-end with\n[`jit`](https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit),\nused either as an `@jit` decorator or as a higher-order function.\n\n```python\nimport jax.numpy as jnp\nfrom jax import jit\n\ndef slow_f(x):\n  # element-wise ops see a large benefit from fusion\n  return x * x + x * 2.0\n\nx = jnp.ones((5000, 5000))\nfast_f = jit(slow_f)\n%timeit -n10 -r3 fast_f(x)  # ~ 4.5 ms / loop on titan x\n%timeit -n10 -r3 slow_f(x)  # ~ 14.5 ms / loop (also on gpu via jax)\n```\n\nyou can mix `jit` and `grad` and any other jax transformation however you like.\n\nusing `jit` puts constraints on the kind of python control flow\nthe function can use; see\nthe [gotchas\nnotebook](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html#python-control-flow-+-jit)\nfor more.\n\n### auto-vectorization with `vmap`\n\n[`vmap`](https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap) is\nthe vectorizing map.\nit has the familiar semantics of mapping a function along array axes, but\ninstead of keeping the loop on the outside, it pushes the loop down into a\nfunction\u2019s primitive operations for better performance.\n\nusing `vmap` can save you from having to carry around batch dimensions in your\ncode. for example, consider this simple *unbatched* neural network prediction\nfunction:\n\n```python\ndef predict(params, input_vec):\n  assert input_vec.ndim == 1\n  activations = input_vec\n  for w, b in params:\n    outputs = jnp.dot(w, activations) + b  # `activations` on the right-hand side!\n    activations = jnp.tanh(outputs)        # inputs to the next layer\n  return outputs                           # no activation on last layer\n```\n\nwe often instead write `jnp.dot(activations, w)` to allow for a batch dimension on the\nleft side of `activations`, but we\u2019ve written this particular prediction function to\napply only to single input vectors. if we wanted to apply this function to a\nbatch of inputs at once, semantically we could just write\n\n```python\nfrom functools import partial\npredictions = jnp.stack(list(map(partial(predict, params), input_batch)))\n```\n\nbut pushing one example through the network at a time would be slow! it\u2019s better\nto vectorize the computation, so that at every layer we\u2019re doing matrix-matrix\nmultiplication rather than matrix-vector multiplication.\n\nthe `vmap` function does that transformation for us. that is, if we write\n\n```python\nfrom jax import vmap\npredictions = vmap(partial(predict, params))(input_batch)\n# or, alternatively\npredictions = vmap(predict, in_axes=(none, 0))(params, input_batch)\n```\n\nthen the `vmap` function will push the outer loop inside the function, and our\nmachine will end up executing matrix-matrix multiplications exactly as if we\u2019d\ndone the batching by hand.\n\nit\u2019s easy enough to manually batch a simple neural network without `vmap`, but\nin other cases manual vectorization can be impractical or impossible. take the\nproblem of efficiently computing per-example gradients: that is, for a fixed set\nof parameters, we want to compute the gradient of our loss function evaluated\nseparately at each example in a batch. with `vmap`, it\u2019s easy:\n\n```python\nper_example_gradients = vmap(partial(grad(loss), params))(inputs, targets)\n```\n\nof course, `vmap` can be arbitrarily composed with `jit`, `grad`, and any other\njax transformation! we use `vmap` with both forward- and reverse-mode automatic\ndifferentiation for fast jacobian and hessian matrix calculations in\n`jax.jacfwd`, `jax.jacrev`, and `jax.hessian`.\n\n### spmd programming with `pmap`\n\nfor parallel programming of multiple accelerators, like multiple gpus, use\n[`pmap`](https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap).\nwith `pmap` you write single-program multiple-data (spmd) programs, including\nfast parallel collective communication operations. applying `pmap` will mean\nthat the function you write is compiled by xla (similarly to `jit`), then\nreplicated and executed in parallel across devices.\n\nhere's an example on an 8-gpu machine:\n\n```python\nfrom jax import random, pmap\nimport jax.numpy as jnp\n\n# create 8 random 5000 x 6000 matrices, one per gpu\nkeys = random.split(random.prngkey(0), 8)\nmats = pmap(lambda key: random.normal(key, (5000, 6000)))(keys)\n\n# run a local matmul on each device in parallel (no data transfer)\nresult = pmap(lambda x: jnp.dot(x, x.t))(mats)  # result.shape is (8, 5000, 5000)\n\n# compute the mean on each device in parallel and print the result\nprint(pmap(jnp.mean)(result))\n# prints [1.1566595 1.1805978 ... 1.2321935 1.2015157]\n```\n\nin addition to expressing pure maps, you can use fast [collective communication\noperations](https://jax.readthedocs.io/en/latest/jax.lax.html#parallel-operators)\nbetween devices:\n\n```python\nfrom functools import partial\nfrom jax import lax\n\n@partial(pmap, axis_name='i')\ndef normalize(x):\n  return x / lax.psum(x, 'i')\n\nprint(normalize(jnp.arange(4.)))\n# prints [0.         0.16666667 0.33333334 0.5       ]\n```\n\nyou can even [nest `pmap` functions](https://colab.research.google.com/github/google/jax/blob/main/cloud_tpu_colabs/pmap_cookbook.ipynb#scrollto=mdrscr5monun) for more\nsophisticated communication patterns.\n\nit all composes, so you're free to differentiate through parallel computations:\n\n```python\nfrom jax import grad\n\n@pmap\ndef f(x):\n  y = jnp.sin(x)\n  @pmap\n  def g(z):\n    return jnp.cos(z) * jnp.tan(y.sum()) * jnp.tanh(x).sum()\n  return grad(lambda w: jnp.sum(g(w)))(x)\n\nprint(f(x))\n# [[ 0.        , -0.7170853 ],\n#  [-3.1085174 , -0.4824318 ],\n#  [10.366636  , 13.135289  ],\n#  [ 0.22163185, -0.52112055]]\n\nprint(grad(lambda x: jnp.sum(f(x)))(x))\n# [[ -3.2369726,  -1.6356447],\n#  [  4.7572474,  11.606951 ],\n#  [-98.524414 ,  42.76499  ],\n#  [ -1.6007166,  -1.2568436]]\n```\n\nwhen reverse-mode differentiating a `pmap` function (e.g. with `grad`), the\nbackward pass of the computation is parallelized just like the forward pass.\n\nsee the [spmd\ncookbook](https://colab.research.google.com/github/google/jax/blob/main/cloud_tpu_colabs/pmap_cookbook.ipynb)\nand the [spmd mnist classifier from scratch\nexample](https://github.com/google/jax/blob/main/examples/spmd_mnist_classifier_fromscratch.py)\nfor more.\n\n## current gotchas\n\nfor a more thorough survey of current gotchas, with examples and explanations,\nwe highly recommend reading the [gotchas\nnotebook](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html).\nsome standouts:\n\n1. jax transformations only work on [pure functions](https://en.wikipedia.org/wiki/pure_function), which don't have side-effects and respect [referential transparency](https://en.wikipedia.org/wiki/referential_transparency) (i.e. object identity testing with `is` isn't preserved). if you use a jax transformation on an impure python function, you might see an error like `exception: can't lift traced...`  or `exception: different traces at same level`.\n1. [in-place mutating updates of\n   arrays](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html#in-place-updates), like `x[i] += y`, aren't supported, but [there are functional alternatives](https://jax.readthedocs.io/en/latest/jax.ops.html). under a `jit`, those functional alternatives will reuse buffers in-place automatically.\n1. [random numbers are\n   different](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html#random-numbers), but for [good reasons](https://github.com/google/jax/blob/main/docs/jep/263-prng.md).\n1. if you're looking for [convolution\n   operators](https://jax.readthedocs.io/en/latest/notebooks/convolutions.html),\n   they're in the `jax.lax` package.\n1. jax enforces single-precision (32-bit, e.g. `float32`) values by default, and\n   [to enable\n   double-precision](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html#double-64bit-precision)\n   (64-bit, e.g. `float64`) one needs to set the `jax_enable_x64` variable at\n   startup (or set the environment variable `jax_enable_x64=true`).\n   on tpu, jax uses 32-bit values by default for everything _except_ internal\n   temporary variables in 'matmul-like' operations, such as `jax.numpy.dot` and `lax.conv`.\n   those ops have a `precision` parameter which can be used to simulate\n   true 32-bit, with a cost of possibly slower runtime.\n1. some of numpy's dtype promotion semantics involving a mix of python scalars\n   and numpy types aren't preserved, namely `np.add(1, np.array([2],\n   np.float32)).dtype` is `float64` rather than `float32`.\n1. some transformations, like `jit`, [constrain how you can use python control\n   flow](https://jax.readthedocs.io/en/latest/notebooks/common_gotchas_in_jax.html#control-flow).\n   you'll always get loud errors if something goes wrong. you might have to use\n   [`jit`'s `static_argnums`\n   parameter](https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit),\n   [structured control flow\n   primitives](https://jax.readthedocs.io/en/latest/jax.lax.html#control-flow-operators)\n   like\n   [`lax.scan`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.scan.html#jax.lax.scan),\n   or just use `jit` on smaller subfunctions.\n\n## installation\n\n### supported platforms\n\n|            | linux x86_64 | linux aarch64 | mac x86_64   | mac arm      | windows x86_64 | windows wsl2 x86_64 |\n|------------|--------------|---------------|--------------|--------------|----------------|---------------------|\n| cpu        | yes          | yes           | yes          | yes          | yes            | yes                 |\n| nvidia gpu | yes          | yes           | no           | n/a          | no             | experimental        |\n| google tpu | yes          | n/a           | n/a          | n/a          | n/a            | n/a                 |\n| amd gpu    | experimental | no            | no           | n/a          | no             | no                  |\n| apple gpu  | n/a          | no            | experimental | experimental | n/a            | n/a                 |\n\n\n### instructions\n\n| hardware   | instructions                                                                                                    |\n|------------|-----------------------------------------------------------------------------------------------------------------|\n| cpu        | `pip install -u \"jax[cpu]\"`                                                                                       |\n| nvidia gpu on x86_64 | `pip install -u \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html`        |\n| google tpu | `pip install -u \"jax[tpu]\" -f https://storage.googleapis.com/jax-releases/libtpu_releases.html`                 |\n| amd gpu    | use [docker](https://hub.docker.com/r/rocm/jax) or [build from source](https://jax.readthedocs.io/en/latest/developer.html#additional-notes-for-building-a-rocm-jaxlib-for-amd-gpus). |\n| apple gpu  | follow [apple's instructions](https://developer.apple.com/metal/jax/).                                          |\n\nsee [the documentation](https://jax.readthedocs.io/en/latest/installation.html)\nfor information on alternative installation strategies. these include compiling\nfrom source, installing with docker, using other versions of cuda, a\ncommunity-supported conda build, and answers to some frequently-asked questions.\n\n\n\n## neural network libraries\n\nmultiple google research groups develop and share libraries for training neural\nnetworks in jax. if you want a fully featured library for neural network\ntraining with examples and how-to guides, try\n[flax](https://github.com/google/flax).\n\ngoogle x maintains the neural network library\n[equinox](https://github.com/patrick-kidger/equinox). this is used as the\nfoundation for several other libraries in the jax ecosystem.\n\nin addition, deepmind has open-sourced an [ecosystem of libraries around\njax](https://deepmind.com/blog/article/using-jax-to-accelerate-our-research)\nincluding [optax](https://github.com/deepmind/optax) for gradient processing and\noptimization, [rlax](https://github.com/deepmind/rlax) for rl algorithms, and\n[chex](https://github.com/deepmind/chex) for reliable code and testing. (watch\nthe neurips 2020 jax ecosystem at deepmind talk\n[here](https://www.youtube.com/watch?v=idxjxiyzsim))\n\n## citing jax\n\nto cite this repository:\n\n```\n@software{jax2018github,\n  author = {james bradbury and roy frostig and peter hawkins and matthew james johnson and chris leary and dougal maclaurin and george necula and adam paszke and jake vander{p}las and skye wanderman-{m}ilne and qiao zhang},\n  title = {{jax}: composable transformations of {p}ython+{n}um{p}y programs},\n  url = {http://github.com/google/jax},\n  version = {0.3.13},\n  year = {2018},\n}\n```\n\nin the above bibtex entry, names are in alphabetical order, the version number\nis intended to be that from [jax/version.py](../main/jax/version.py), and\nthe year corresponds to the project's open-source release.\n\na nascent version of jax, supporting only automatic differentiation and\ncompilation to xla, was described in a [paper that appeared at sysml\n2018](https://mlsys.org/conferences/2019/doc/2018/146.pdf). we're currently working on\ncovering jax's ideas and capabilities in a more comprehensive and up-to-date\npaper.\n\n## reference documentation\n\nfor details about the jax api, see the\n[reference documentation](https://jax.readthedocs.io/).\n\nfor getting started as a jax developer, see the\n[developer documentation](https://jax.readthedocs.io/en/latest/developer.html).\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "jax",
  "package_url": "https://pypi.org/project/jax/",
  "project_url": "https://pypi.org/project/jax/",
  "project_urls": {
    "Homepage": "https://github.com/google/jax"
  },
  "release_url": "https://pypi.org/project/jax/0.4.23/",
  "requires_dist": [
    "ml-dtypes >=0.2.0",
    "numpy >=1.22",
    "opt-einsum",
    "scipy >=1.9",
    "importlib-metadata >=4.6 ; python_version < \"3.10\"",
    "numpy >=1.23.2 ; python_version >= \"3.11\"",
    "numpy >=1.26.0 ; python_version >= \"3.12\"",
    "scipy >=1.11.1 ; python_version >= \"3.12\"",
    "protobuf <4,>=3.13 ; extra == 'australis'",
    "jaxlib ==0.4.22 ; extra == 'ci'",
    "jaxlib ==0.4.23 ; extra == 'cpu'",
    "jaxlib ==0.4.23+cuda11.cudnn86 ; extra == 'cuda'",
    "jaxlib ==0.4.23+cuda11.cudnn86 ; extra == 'cuda11_cudnn86'",
    "jaxlib ==0.4.23+cuda11.cudnn86 ; extra == 'cuda11_local'",
    "jaxlib ==0.4.23+cuda11.cudnn86 ; extra == 'cuda11_pip'",
    "nvidia-cublas-cu11 >=11.11 ; extra == 'cuda11_pip'",
    "nvidia-cuda-cupti-cu11 >=11.8 ; extra == 'cuda11_pip'",
    "nvidia-cuda-nvcc-cu11 >=11.8 ; extra == 'cuda11_pip'",
    "nvidia-cuda-runtime-cu11 >=11.8 ; extra == 'cuda11_pip'",
    "nvidia-cudnn-cu11 >=8.8 ; extra == 'cuda11_pip'",
    "nvidia-cufft-cu11 >=10.9 ; extra == 'cuda11_pip'",
    "nvidia-cusolver-cu11 >=11.4 ; extra == 'cuda11_pip'",
    "nvidia-cusparse-cu11 >=11.7 ; extra == 'cuda11_pip'",
    "nvidia-nccl-cu11 >=2.18.3 ; extra == 'cuda11_pip'",
    "jaxlib ==0.4.23 ; extra == 'cuda12'",
    "jax-cuda12-plugin ==0.4.23 ; extra == 'cuda12'",
    "nvidia-cublas-cu12 >=12.2.5.6 ; extra == 'cuda12'",
    "nvidia-cuda-cupti-cu12 >=12.2.142 ; extra == 'cuda12'",
    "nvidia-cuda-nvcc-cu12 >=12.2.140 ; extra == 'cuda12'",
    "nvidia-cuda-runtime-cu12 >=12.2.140 ; extra == 'cuda12'",
    "nvidia-cudnn-cu12 >=8.9 ; extra == 'cuda12'",
    "nvidia-cufft-cu12 >=11.0.8.103 ; extra == 'cuda12'",
    "nvidia-cusolver-cu12 >=11.5.2 ; extra == 'cuda12'",
    "nvidia-cusparse-cu12 >=12.1.2.141 ; extra == 'cuda12'",
    "nvidia-nccl-cu12 >=2.18.3 ; extra == 'cuda12'",
    "nvidia-nvjitlink-cu12 >=12.2 ; extra == 'cuda12'",
    "jaxlib ==0.4.23+cuda12.cudnn89 ; extra == 'cuda12_local'",
    "jaxlib ==0.4.23+cuda12.cudnn89 ; extra == 'cuda12_pip'",
    "nvidia-cublas-cu12 >=12.2.5.6 ; extra == 'cuda12_pip'",
    "nvidia-cuda-cupti-cu12 >=12.2.142 ; extra == 'cuda12_pip'",
    "nvidia-cuda-nvcc-cu12 >=12.2.140 ; extra == 'cuda12_pip'",
    "nvidia-cuda-runtime-cu12 >=12.2.140 ; extra == 'cuda12_pip'",
    "nvidia-cudnn-cu12 >=8.9 ; extra == 'cuda12_pip'",
    "nvidia-cufft-cu12 >=11.0.8.103 ; extra == 'cuda12_pip'",
    "nvidia-cusolver-cu12 >=11.5.2 ; extra == 'cuda12_pip'",
    "nvidia-cusparse-cu12 >=12.1.2.141 ; extra == 'cuda12_pip'",
    "nvidia-nccl-cu12 >=2.18.3 ; extra == 'cuda12_pip'",
    "nvidia-nvjitlink-cu12 >=12.2 ; extra == 'cuda12_pip'",
    "jaxlib ==0.4.19 ; extra == 'minimum-jaxlib'",
    "jaxlib ==0.4.23 ; extra == 'tpu'",
    "libtpu-nightly ==0.1.dev20231213 ; extra == 'tpu'",
    "requests ; extra == 'tpu'"
  ],
  "requires_python": ">=3.9",
  "summary": "differentiate, compile, and transform numpy code.",
  "version": "0.4.23",
  "releases": [],
  "developers": [
    "jax-dev@google.com",
    "jax_team"
  ],
  "kwds": "jax_logo_250px jax jaxlib jax2018github jax_enable_x64",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_jax",
  "homepage": "https://github.com/google/jax",
  "release_count": 157,
  "dependency_ids": [
    "pypi_importlib_metadata",
    "pypi_jax_cuda12_plugin",
    "pypi_jaxlib",
    "pypi_libtpu_nightly",
    "pypi_ml_dtypes",
    "pypi_numpy",
    "pypi_nvidia_cublas_cu11",
    "pypi_nvidia_cublas_cu12",
    "pypi_nvidia_cuda_cupti_cu11",
    "pypi_nvidia_cuda_cupti_cu12",
    "pypi_nvidia_cuda_nvcc_cu11",
    "pypi_nvidia_cuda_nvcc_cu12",
    "pypi_nvidia_cuda_runtime_cu11",
    "pypi_nvidia_cuda_runtime_cu12",
    "pypi_nvidia_cudnn_cu11",
    "pypi_nvidia_cudnn_cu12",
    "pypi_nvidia_cufft_cu11",
    "pypi_nvidia_cufft_cu12",
    "pypi_nvidia_cusolver_cu11",
    "pypi_nvidia_cusolver_cu12",
    "pypi_nvidia_cusparse_cu11",
    "pypi_nvidia_cusparse_cu12",
    "pypi_nvidia_nccl_cu11",
    "pypi_nvidia_nccl_cu12",
    "pypi_nvidia_nvjitlink_cu12",
    "pypi_opt_einsum",
    "pypi_protobuf",
    "pypi_requests",
    "pypi_scipy"
  ]
}