{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: unix",
    "programming language :: python :: 3",
    "topic :: documentation :: sphinx",
    "topic :: education"
  ],
  "description": "# binarytree: python library for studying binary trees\n\n![build](https://github.com/joowani/binarytree/workflows/build/badge.svg)\n![codeql](https://github.com/joowani/binarytree/workflows/codeql/badge.svg)\n[![codecov](https://codecov.io/gh/joowani/binarytree/branch/main/graph/badge.svg?token=c2x2ompl65)](https://codecov.io/gh/joowani/binarytree)\n[![pypi version](https://badge.fury.io/py/binarytree.svg)](https://badge.fury.io/py/binarytree)\n[![github license](https://img.shields.io/github/license/joowani/binarytree?color=brightgreen)](https://github.com/joowani/binarytree/blob/main/license)\n![python version](https://img.shields.io/badge/python-3.7%2b-blue)\n\nare you studying binary trees for your next exam, assignment or technical interview?\n\n**binarytree** is a python library which lets you generate, visualize, inspect and\nmanipulate [binary trees](https://en.wikipedia.org/wiki/binary_tree). skip the tedious\nwork of setting up test data, and dive straight into practising your algorithms.\n[heaps](https://en.wikipedia.org/wiki/heap_(data_structure)) and\n[binary search trees](https://en.wikipedia.org/wiki/binary_search_tree) are also supported.\nself-balancing search trees like [red-black](https://en.wikipedia.org/wiki/red%e2%80%93black_tree)\nor [avl](https://en.wikipedia.org/wiki/avl_tree) will be added in the future.\n\ncheck out the [documentation](http://binarytree.readthedocs.io) for more details.\n\n![ipython demo](gifs/demo.gif)\n\nbinarytree can be used with [graphviz](https://graphviz.org) and\n[jupyter notebooks](https://jupyter.org) as well:\n\n![jupyter demo](gifs/jupyter.gif)\n\n## requirements\n\npython 3.7+\n\n## installation\n\ninstall via [pip](https://pip.pypa.io):\n\n```shell\npip install binarytree --upgrade\n```\n\nfor [conda](https://docs.conda.io) users:\n\n```shell\nconda install binarytree -c conda-forge\n```\n\n## getting started\n\nbinarytree uses the following class to represent a node:\n\n```python\nclass node:\n\n    def __init__(self, value, left=none, right=none):\n        self.value = value  # the node value (float/int/str)\n        self.left = left    # left child\n        self.right = right  # right child\n```\n\ngenerate and pretty-print various types of binary trees:\n\n```python\nfrom binarytree import tree, bst, heap\n\n# generate a random binary tree and return its root node.\nmy_tree = tree(height=3, is_perfect=false)\n\n# generate a random bst and return its root node.\nmy_bst = bst(height=3, is_perfect=true)\n\n# generate a random max heap and return its root node.\nmy_heap = heap(height=3, is_max=true, is_perfect=false)\n\n# pretty-print the trees in stdout.\nprint(my_tree)\n#\n#        _______1_____\n#       /             \\\n#      4__          ___3\n#     /   \\        /    \\\n#    0     9      13     14\n#         / \\       \\\n#        7   10      2\n#\nprint(my_bst)\n#\n#            ______7_______\n#           /              \\\n#        __3__           ___11___\n#       /     \\         /        \\\n#      1       5       9         _13\n#     / \\     / \\     / \\       /   \\\n#    0   2   4   6   8   10    12    14\n#\nprint(my_heap)\n#\n#              _____14__\n#             /         \\\n#        ____13__        9\n#       /        \\      / \\\n#      12         7    3   8\n#     /  \\       /\n#    0    10    6\n#\n```\ngenerate trees with letter values instead of numbers:\n\n```python\nfrom binarytree import tree\n\nmy_tree = tree(height=3, is_perfect=false, letters=true)\n\nprint(my_tree)\n#\n#          ____h____\n#         /         \\\n#      __e__         f__\n#     /     \\       /   \\\n#    m       g     j     b\n#     \\     /     /     / \\\n#      o   l     d     i   a\n#\n```\n\n\nbuild your own trees:\n\n```python\nfrom binarytree import node\n\nroot = node(1)\nroot.left = node(2)\nroot.right = node(3)\nroot.left.right = node(4)\n\nprint(root)\n#\n#      __1\n#     /   \\\n#    2     3\n#     \\\n#      4\n#\n```\n\ninspect tree properties:\n\n```python\nfrom binarytree import node\n\nroot = node(1)\nroot.left = node(2)\nroot.right = node(3)\nroot.left.left = node(4)\nroot.left.right = node(5)\n\nprint(root)\n#\n#        __1\n#       /   \\\n#      2     3\n#     / \\\n#    4   5\n#\nassert root.height == 2\nassert root.is_balanced is true\nassert root.is_bst is false\nassert root.is_complete is true\nassert root.is_max_heap is false\nassert root.is_min_heap is true\nassert root.is_perfect is false\nassert root.is_strict is true\nassert root.leaf_count == 3\nassert root.max_leaf_depth == 2\nassert root.max_node_value == 5\nassert root.min_leaf_depth == 1\nassert root.min_node_value == 1\nassert root.size == 5\n\n# see all properties at once.\nassert root.properties == {\n    'height': 2,\n    'is_balanced': true,\n    'is_bst': false,\n    'is_complete': true,\n    'is_max_heap': false,\n    'is_min_heap': true,\n    'is_perfect': false,\n    'is_strict': true,\n    'leaf_count': 3,\n    'max_leaf_depth': 2,\n    'max_node_value': 5,\n    'min_leaf_depth': 1,\n    'min_node_value': 1,\n    'size': 5\n}\n\nprint(root.leaves)\n# [node(3), node(4), node(5)]\n\nprint(root.levels)\n# [[node(1)], [node(2), node(3)], [node(4), node(5)]]\n```\n\ncompare and clone trees:\n```python\nfrom binarytree import tree\n\noriginal = tree()\n\n# clone the binary tree.\nclone = original.clone()\n\n# check if the trees are equal.\noriginal.equals(clone)\n```\n\n\nuse [level-order (breadth-first)](https://en.wikipedia.org/wiki/tree_traversal#breadth-first_search) \nindexes to manipulate nodes:\n\n```python\nfrom binarytree import node\n\nroot = node(1)                  # index: 0, value: 1\nroot.left = node(2)             # index: 1, value: 2\nroot.right = node(3)            # index: 2, value: 3\nroot.left.right = node(4)       # index: 4, value: 4\nroot.left.right.left = node(5)  # index: 9, value: 5\n\nprint(root)\n#\n#      ____1\n#     /     \\\n#    2__     3\n#       \\\n#        4\n#       /\n#      5\n#\nroot.pprint(index=true)\n#\n#       _________0-1_\n#      /             \\\n#    1-2_____        2-3\n#            \\\n#           _4-4\n#          /\n#        9-5\n#\nprint(root[9])\n# node(5)\n\n# replace the node/subtree at index 4.\nroot[4] = node(6, left=node(7), right=node(8))\nroot.pprint(index=true)\n#\n#       ______________0-1_\n#      /                  \\\n#    1-2_____             2-3\n#            \\\n#           _4-6_\n#          /     \\\n#        9-7     10-8\n#\n\n# delete the node/subtree at index 1.\ndel root[1]\nroot.pprint(index=true)\n#\n#    0-1_\n#        \\\n#        2-3\n```\n\ntraverse trees using different algorithms:\n\n```python\nfrom binarytree import node\n\nroot = node(1)\nroot.left = node(2)\nroot.right = node(3)\nroot.left.left = node(4)\nroot.left.right = node(5)\n\nprint(root)\n#\n#        __1\n#       /   \\\n#      2     3\n#     / \\\n#    4   5\n#\nprint(root.inorder)\n# [node(4), node(2), node(5), node(1), node(3)]\n\nprint(root.preorder)\n# [node(1), node(2), node(4), node(5), node(3)]\n\nprint(root.postorder) \n# [node(4), node(5), node(2), node(3), node(1)]\n\nprint(root.levelorder) \n# [node(1), node(2), node(3), node(4), node(5)]\n\nprint(list(root)) # equivalent to root.levelorder\n# [node(1), node(2), node(3), node(4), node(5)]\n```\n\nconvert to [list representations](https://en.wikipedia.org/wiki/binary_tree#arrays):\n\n```python\nfrom binarytree import build\n\n# build a tree from list representation\nvalues = [7, 3, 2, 6, 9, none, 1, 5, 8]\nroot = build(values)\nprint(root)\n#\n#            __7\n#           /   \\\n#        __3     2\n#       /   \\     \\\n#      6     9     1\n#     / \\\n#    5   8\n#\n\n# go back to list representation\nprint(root.values) \n# [7, 3, 2, 6, 9, none, 1, 5, 8]\n```\n\nbinarytree supports another representation which is more compact but without\nthe [indexing properties](https://en.wikipedia.org/wiki/binary_tree#arrays) \n(this method is often used in [leetcode](https://leetcode.com/)):\n\n```python\nfrom binarytree import build, build2, node\n\n# first let's create an example tree.\nroot = node(1)\nroot.left = node(2)\nroot.left.left = node(3)\nroot.left.left.left = node(4)\nroot.left.left.right = node(5)\nprint(root)\n#\n#           1\n#          /\n#       __2\n#      /\n#     3\n#    / \\\n#   4   5\n\n# first representation is already shown above.\n# all \"null\" nodes in each level are present.\nprint(root.values)\n# [1, 2, none, 3, none, none, none, 4, 5]\n\n# second representation is more compact but without the indexing properties.\nprint(root.values2)\n# [1, 2, none, 3, none, 4, 5]\n\n# build trees from the list representations\ntree1 = build(root.values)\ntree2 = build2(root.values2)\nassert tree1.equals(tree2) is true\n```\n\ncheck out the [documentation](http://binarytree.readthedocs.io) for more details.\n\n\n",
  "docs_url": null,
  "keywords": "tree,heap,bst,education",
  "license": "mit",
  "name": "binarytree",
  "package_url": "https://pypi.org/project/binarytree/",
  "project_url": "https://pypi.org/project/binarytree/",
  "project_urls": {
    "Homepage": "https://github.com/joowani/binarytree"
  },
  "release_url": "https://pypi.org/project/binarytree/6.5.1/",
  "requires_dist": [
    "graphviz",
    "setuptools (>=60.8.2)",
    "setuptools-scm[toml] (>=5.0.1)",
    "black (>=22.1.0) ; extra == 'dev'",
    "flake8 (>=4.0.1) ; extra == 'dev'",
    "isort (>=5.10.1) ; extra == 'dev'",
    "mypy (>=0.931) ; extra == 'dev'",
    "pre-commit (>=2.17.0) ; extra == 'dev'",
    "pytest (>=6.2.1) ; extra == 'dev'",
    "pytest-cov (>=2.10.1) ; extra == 'dev'",
    "sphinx ; extra == 'dev'",
    "sphinx-rtd-theme ; extra == 'dev'",
    "types-setuptools ; extra == 'dev'",
    "types-dataclasses ; extra == 'dev'"
  ],
  "requires_python": ">=3.7",
  "summary": "python library for studying binary trees",
  "version": "6.5.1",
  "releases": [],
  "developers": [
    "joohwan.oh@outlook.com",
    "joohwan_oh"
  ],
  "kwds": "binarytree binary_tree binary_search_tree tree2 tree1",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_binarytree",
  "homepage": "https://github.com/joowani/binarytree",
  "release_count": 12,
  "dependency_ids": [
    "pypi_black",
    "pypi_flake8",
    "pypi_graphviz",
    "pypi_isort",
    "pypi_mypy",
    "pypi_pre_commit",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_setuptools",
    "pypi_setuptools_scm",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme",
    "pypi_types_dataclasses",
    "pypi_types_setuptools"
  ]
}