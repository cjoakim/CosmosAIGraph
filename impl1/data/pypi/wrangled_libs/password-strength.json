{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "[![build status](https://api.travis-ci.org/kolypto/py-password-strength.png?branch=master)](https://travis-ci.org/kolypto/py-password-strength)\n[![pythons](https://img.shields.io/badge/python-2.7%20%7c%203.4%e2%80%933.7%20%7c%20pypy-blue.svg)](.travis.yml)\n\n\npassword strength\n=================\n\npassword strength and validation.\n\n\ntutorial\n========\n\n\n### uppercase, numbers, special characters\n\nyou test your passwords using the policy object that controls what kind of password is acceptable in your system.\n\nfirst, create the policy object and define the rules that apply to passwords in your system:\n\n```python\nfrom password_strength import passwordpolicy\n\npolicy = passwordpolicy.from_names(\n    length=8,  # min length: 8\n    uppercase=2,  # need min. 2 uppercase letters\n    numbers=2,  # need min. 2 digits\n    special=2,  # need min. 2 special characters\n    nonletters=2,  # need min. 2 non-letter characters (digits, specials, anything)\n)\n```\n\nnow, when you have the `passwordpolicy` object, you can use it to test your passwords,\nand it will tell you which tests have failed:\n\n```python\npolicy.test('abcd12!')\n# -> [length(8), special(2)]\n```\n\nthis tells us that 2 tests have failed: password is not long enough, and it does not have enough special characters.\nyou can use this information to tell the user what precisely is wrong with their password.\n\n```python\npolicy.test('abcd12!@')\n# -> []\n```\n\nempty list tells us that this password is alright.\n\nthis test, however, enabled uses to use passwords that have a lot of repetition.\n\n### so-called entropy bits\n\nhere's a test that's even better. you don't really need to define complex rules with special characters and stuff.\nall you actually need is a password that's long enough, complex enough, and easy to remember\n(see [xkcd](https://xkcd.com/936/) and\n[article: everything we've been told about passwords is wrong](https://www.inc.com/thomas-koulopoulos/all-that-advice-about-passwords-turns-out-to-be-to.html)).\n\nso, instead of defining all these rules, let's just require the password to be complex enough.\nentropy bits is something that defines how much variety does your password have. '01111010010011' is long enough,\nbut has only 2 entropy bits: that's how many bits you need to store its alphabet. however, a password that uses\nplenty of characters has more entropy.\n\n```python\npolicy = passwordpolicy.from_names(\n    entropybits=30  # need a password that has minimum 30 entropy bits (the power of its alphabet)\n)\n\nprint(policy.test('0123456789'))\n# -> []\n```\n\nthis password is not long enough, or secure enough, but has enough entropy: its vocabulary has 10 different characters.\nput this test together with other requirements to make sure there's no repetition in your passwords.\n\n### complexity\n\nentropy bits are important, but difficult to understand. an even better, more intuitive test, is to require\nthe password to be \"complex enough\".\ncomplexity is a number in the range of 0.00..0.99. good, strong passwords start at 0.66.\n\nlet's first see how different passwords score:\n\n```python\nfrom password_strength import passwordstats\n\nstats = passwordstats('qwerty123')\nprint(stats.strength())  #-> its strength is 0.316\n\nstats = passwordstats('g00dpassw0rd?!')\nprint(stats.strength())  #-> its strength is 0.585\n\nstats = passwordstats('v3ryg00dpassw0rd?!')\nprint(stats.strength())  #-> its strength is 0.767\n```\n\nso, 0.66 will be a very good indication of a good password.\nlet's implement our policy:\n\n```python\npolicy = passwordpolicy.from_names(\n    strength=0.66  # need a password that scores at least 0.5 with its strength\n)\n\nprint(policy.test('v3ryg00dpassw0rd?!'))\n# -> []  -- empty list means a good password\n```\n\none good thing about using strength is that it allows users to use national aplhabets with passwords,\nwhich are most secure:\n\n```python\ntested_pass = policy.password('mixed-\u6c49\u5821\u5305/\u6f22\u5821\u5305, \u6c49\u5821/\u6f22\u5821')\nprint(tested_pass.strength())  # -> 0.812 -- very good!\nprint(tested_pass.test())\n#-> []  - good password; it actually scored 0.812\n```\n\nnotice how in the last example we use a different approach: `policy.password()` analyzes the password, and then we can\nboth get its `.strength()`, and `.test()` it according to the current policy.\n\npasswordpolicy\n==============\n\nperform tests on a password.\n\ninit policy\n-----------\n\n```python\npasswordpolicy(*tests)\n```\n\ninit password policy with a list of tests\n\nalternatively:\n\n```python\npasswordpolicy.from_names(**tests)\n```\n\ninit password policy from a dictionary of test definitions.\n\na test definition is simply:\n\n    { test-name: argument } or { test-name: [arguments] }\n\ntest name is just a lowercased class name.\n\nexample:\n\n    passwordpolicy.from_names(\n        length=8,\n        strength=(0.33, 30),\n    )\n\n\nbundled tests\n-------------\n\nthese objects perform individual tests on a password, and report `true` of `false`.\n\n\n#### tests.entropybits(bits)\ntest whether the password has >= `bits` entropy bits.\n\nentropy bits is the number of bits that is required to store the alphabet that's used in a password.\nit's a measure of how long is the alphabet.\n\n#### tests.length(length)\ntests whether password length >= `length`\n\n#### tests.nonletters(count)\ntest whether the password has >= `count` non-letter characters\n\n#### tests.nonletterslc(count)\ntest whether the password has >= `count` non-lowercase characters\n\n#### tests.numbers(count)\ntest whether the password has >= `count` numeric characters\n\n#### tests.special(count)\ntest whether the password has >= `count` special characters\n\n#### tests.strength(strength, weak_bits=30)\ntest whether the password has >= `strength` strength.\n\na password is evaluated to the strength of 0.333 when it has `weak_bits` entropy bits,\nwhich is considered to be a weak password. strong passwords start at 0.666.\n\n#### tests.uppercase(count)\ntest whether the password has >= `count` uppercase characters\n\n\ntesting\n-------\n\nafter the `passwordpolicy` is initialized, there are two methods to test:\n\n### passwordpolicy.password\n```python\npassword(password)\n```\nget password stats bound to the tests declared in this policy.\n\nif in addition to tests you need to get statistics (e.g. strength) -- use this object to double calculations.\n\nsee [`passwordstats`](#passwordstats) for more details.\n\n### passwordpolicy.test\n```python\ntest(password)\n```\nperform tests on a password.\n\nshortcut for: `passwordpolicy.password(password).test()`.\n\n\ncustom tests\n------------\n\natest is a base class for password tests.\n\nto create a custom test, just subclass it and implement the following methods:\n\n* __init__() that takes configuration arguments\n* test(ps) that tests a password, where `ps` is a `passwordstats` object.\n\n\npasswordstats\n-------------\n\npasswordstats allows to calculate statistics on a password.\n\nit considers a password as a unicode string, and all statistics are unicode-based.\n\nconstructor:\n\n```python\nfrom password_strength import passwordstats\npasswordstats(password)\n```\n\n\n#### passwordstats.alphabet\nget alphabet: set of used characters\n\n#### passwordstats.alphabet_cardinality\nget alphabet cardinality: alphabet length\n\n#### passwordstats.char_categories\ncharacter count per top-level category\n\nthe following top-level categories are defined:\n\n- l: letter\n- m: mark\n- n: number\n- p: punctuation\n- s: symbol\n- z: separator\n- c: other\n\n#### passwordstats.char_categories_detailed\ncharacter count per unicode category, detailed format.\n\nsee: http://www.unicode.org/reports/tr44/#gc_values_table\n\n#### passwordstats.combinations\nthe number of possible combinations with the current alphabet\n\n#### passwordstats.count(*categories)\ncount characters of the specified classes only\n\n#### passwordstats.count_except(*categories)\ncount characters of all classes except the specified ones\n\n#### passwordstats.entropy_bits\nget information entropy bits: log2 of the number of possible passwords\n\nhttps://en.wikipedia.org/wiki/password_strength\n\n#### passwordstats.entropy_density\nget information entropy density factor, ranged {0 .. 1}.\n\nthis is ratio of entropy_bits() to max bits a password of this length could have.\ne.g. if all characters are unique -- then it's 1.0.\nif half of the characters are reused once -- then it's 0.5.\n\n#### passwordstats.length\nget password length\n\n#### passwordstats.letters\ncount all letters\n\n#### passwordstats.letters_lowercase\ncount lowercase letters\n\n#### passwordstats.letters_uppercase\ncount uppercase letters\n\n#### passwordstats.numbers\ncount numbers\n\n#### passwordstats.repeated_patterns_length\ndetect and return the length of repeated patterns.\n\nyou will probably be comparing it with the length of the password itself and ban if it's longer than 10%\n\n#### passwordstats.sequences_length\ndetect and return the length of used sequences:\n\n- alphabet letters: abcd...\n- keyboard letters: qwerty, etc\n- keyboard special characters in the top row: ~!@#$%^&*()_+\n- numbers: 0123456\n\n#### passwordstats.special_characters\ncount special characters\n\nspecial characters is everything that's not a letter or a number\n\n#### passwordstats.strength(weak_bits=30)\nget password strength as a number normalized to range {0 .. 1}.\n\nnormalization is done in the following fashion:\n\n1. if entropy_bits <= weak_bits   -- linear in range{0.0 .. 0.33} (weak)\n2. if entropy_bits <= weak_bits*2 -- almost linear in range{0.33 .. 0.66} (medium)\n3. if entropy_bits > weak_bits*3  -- asymptotic towards 1.0 (strong)\n\n#### passwordstats.test(tests)\ntest the password against a list of tests\n\n#### passwordstats.weakness_factor\nget weakness factor as a float in range {0 .. 1}\n\nthis detects the portion of the string that contains:\n* repeated patterns\n* sequences\n\ne.g. a value of 1.0 means the whole string is weak, and 0.5 means half of the string is weak.\n\ntypical usage:\n\npassword_strength = (1 - weakness_factor) * strength\n\n\n\n",
  "docs_url": null,
  "keywords": "password,strength,policy,security",
  "license": "bsd",
  "name": "password-strength",
  "package_url": "https://pypi.org/project/password-strength/",
  "project_url": "https://pypi.org/project/password-strength/",
  "project_urls": {
    "Homepage": "https://github.com/kolypto/py-password-strength"
  },
  "release_url": "https://pypi.org/project/password-strength/0.0.3.post2/",
  "requires_dist": [
    "six"
  ],
  "requires_python": "",
  "summary": "password strength and validation",
  "version": "0.0.3.post2",
  "releases": [],
  "developers": [
    "kolypto@gmail.com",
    "mark_vartanyan"
  ],
  "kwds": "password_strength passwordpolicy passwordstats password passwords",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_password_strength",
  "homepage": "https://github.com/kolypto/py-password-strength",
  "release_count": 6,
  "dependency_ids": [
    "pypi_six"
  ]
}