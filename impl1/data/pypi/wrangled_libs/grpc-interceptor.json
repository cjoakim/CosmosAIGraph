{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8"
  ],
  "description": "[![tests](https://github.com/d5h-foss/grpc-interceptor/workflows/tests/badge.svg)](https://github.com/d5h-foss/grpc-interceptor/actions?workflow=tests)\n[![codecov](https://codecov.io/gh/d5h-foss/grpc-interceptor/branch/master/graph/badge.svg)](https://codecov.io/gh/d5h-foss/grpc-interceptor)\n[![read the docs](https://readthedocs.org/projects/grpc-interceptor/badge/)](https://grpc-interceptor.readthedocs.io/)\n[![pypi](https://img.shields.io/pypi/v/grpc-interceptor.svg)](https://pypi.org/project/grpc-interceptor/)\n\n# summary\n\nsimplified python grpc interceptors.\n\nthe python `grpc` package provides service interceptors, but they're a bit hard to\nuse because of their flexibility. the `grpc` interceptors don't have direct access\nto the request and response objects, or the service context. access to these are often\ndesired, to be able to log data in the request or response, or set status codes on the\ncontext.\n\n# installation\n\nto just get the interceptors (and probably not write your own):\n\n```console\n$ pip install grpc-interceptor\n```\n\nto also get the testing framework, which is good if you're writing your own interceptors:\n\n```console\n$ pip install grpc-interceptor[testing]\n```\n\n# usage\n\n## server interceptor\n\nto define your own interceptor (we can use `exceptiontostatusinterceptor` as an example):\n\n```python\nfrom grpc_interceptor import serverinterceptor\nfrom grpc_interceptor.exceptions import grpcexception\n\nclass exceptiontostatusinterceptor(serverinterceptor):\n    def intercept(\n        self,\n        method: callable,\n        request_or_iterator: any,\n        context: grpc.servicercontext,\n        method_name: str,\n    ) -> any:\n        \"\"\"override this method to implement a custom interceptor.\n         you should call method(request_or_iterator, context) to invoke the\n         next handler (either the rpc method implementation, or the\n         next interceptor in the list).\n         args:\n             method: the next interceptor, or method implementation.\n             request_or_iterator: the rpc request, as a protobuf message.\n             context: the servicercontext pass by grpc to the service.\n             method_name: a string of the form\n                 \"/protobuf.package.service/method\"\n         returns:\n             this should generally return the result of\n             method(request_or_iterator, context), which is typically the rpc\n             method response, as a protobuf message. the interceptor\n             is free to modify this in some way, however.\n         \"\"\"\n        try:\n            return method(request_or_iterator, context)\n        except grpcexception as e:\n            context.set_code(e.status_code)\n            context.set_details(e.details)\n            raise\n```\n\nthen inject your interceptor when you create the `grpc` server:\n\n```python\ninterceptors = [exceptiontostatusinterceptor()]\nserver = grpc.server(\n    futures.threadpoolexecutor(max_workers=10),\n    interceptors=interceptors\n)\n```\n\nto use `exceptiontostatusinterceptor`:\n\n```python\nfrom grpc_interceptor.exceptions import notfound\n\nclass myservice(my_pb2_grpc.myserviceservicer):\n    def myrpcmethod(\n        self, request: myrequest, context: grpc.servicercontext\n    ) -> myresponse:\n        thing = lookup_thing()\n        if not thing:\n            raise notfound(\"sorry, your thing is missing\")\n        ...\n```\n\nthis results in the grpc status status code being set to `not_found`,\nand the details `\"sorry, your thing is missing\"`. this saves you the hassle of\ncatching exceptions in your service handler, or passing the context down into\nhelper functions so they can call `context.abort` or `context.set_code`. it allows\nthe more pythonic approach of just raising an exception from anywhere in the code,\nand having it be handled automatically.\n\n## client interceptor\n\nwe will use an invocation metadata injecting interceptor as an example of defining\na client interceptor:\n\n```python\nfrom grpc_interceptor import clientcalldetails, clientinterceptor\n\nclass metadataclientinterceptor(clientinterceptor):\n\n    def intercept(\n        self,\n        method: callable,\n        request_or_iterator: any,\n        call_details: grpc.clientcalldetails,\n    ):\n        \"\"\"override this method to implement a custom interceptor.\n\n        this method is called for all unary and streaming rpcs. the interceptor\n        implementation should call `method` using a `grpc.clientcalldetails` and the\n        `request_or_iterator` object as parameters. the `request_or_iterator`\n        parameter may be type checked to determine if this is a singluar request\n        for unary rpcs or an iterator for client-streaming or client-server streaming\n        rpcs.\n\n        args:\n            method: a function that proceeds with the invocation by executing the next\n                interceptor in the chain or invoking the actual rpc on the underlying\n                channel.\n            request_or_iterator: rpc request message or iterator of request messages\n                for streaming requests.\n            call_details: describes an rpc to be invoked.\n\n        returns:\n            the type of the return should match the type of the return value received\n            by calling `method`. this is an object that is both a\n            `call <https://grpc.github.io/grpc/python/grpc.html#grpc.call>`_ for the\n            rpc and a `future <https://grpc.github.io/grpc/python/grpc.html#grpc.future>`_.\n\n            the actual result from the rpc can be got by calling `.result()` on the\n            value returned from `method`.\n        \"\"\"\n        new_details = clientcalldetails(\n            call_details.method,\n            call_details.timeout,\n            [(\"authorization\", \"bearer mysecrettoken\")],\n            call_details.credentials,\n            call_details.wait_for_ready,\n            call_details.compression,\n        )\n\n        return method(request_or_iterator, new_details)\n```\n\nnow inject your interceptor when you create the ``grpc`` channel:\n\n```python\ninterceptors = [metadataclientinterceptor()]\nwith grpc.insecure_channel(\"grpc-server:50051\") as channel:\n    channel = grpc.intercept_channel(channel, *interceptors)\n    ...\n```\n\nclient interceptors can also be used to\n[retry rpcs](https://github.com/d5h-foss/grpc-interceptor/blob/4b6bb6a59aae97aec058c0d4072dd19de8f408bc/tests/test_client.py#l39-l56)\nthat fail due to specific errors, or a host of other use cases. there are some basic\napproaches in\n[the tests](https://github.com/d5h-foss/grpc-interceptor/blob/master/tests/test_client.py)\nto get you started.\n\nnote: the `method` in a client interceptor is a `continuation` as described in the\n[client interceptor section of the grpc docs](https://grpc.github.io/grpc/python/grpc.html#grpc.unaryunaryclientinterceptor.intercept_unary_unary).\nwhen you invoke the continuation, you get a future back, which resolves to either the\nresult, or exception. this is different than invoking a client stub, which returns the\nresult directly. if the interceptor needs the value returned by the call, or to catch\nexceptions, then you'll need to do `future = method(request_or_iterator, call_details)`,\nfollowed by `future.result()`. check out the tests for\n[examples](https://github.com/d5h-foss/grpc-interceptor/blob/4b6bb6a59aae97aec058c0d4072dd19de8f408bc/tests/test_client.py#l39-l56).\n\n\n# documentation\n\nthe examples above showed usage for simple unary-unary rpc calls. for examples of\nstreaming and asyncio rpcs, read the\n[complete documentation here](https://grpc-interceptor.readthedocs.io/).\n\nnote that there is no asyncio client interceptors at the moment, though contributions\nare welcome.\n\n",
  "docs_url": null,
  "keywords": "grpc,interceptor",
  "license": "mit",
  "name": "grpc-interceptor",
  "package_url": "https://pypi.org/project/grpc-interceptor/",
  "project_url": "https://pypi.org/project/grpc-interceptor/",
  "project_urls": {
    "Documentation": "https://grpc-interceptor.readthedocs.io",
    "Homepage": "https://github.com/d5h-foss/grpc-interceptor",
    "Repository": "https://github.com/d5h-foss/grpc-interceptor"
  },
  "release_url": "https://pypi.org/project/grpc-interceptor/0.15.4/",
  "requires_dist": [
    "grpcio (>=1.49.1,<2.0.0)",
    "protobuf (>=4.21.9); extra == \"testing\""
  ],
  "requires_python": ">=3.7,<4.0",
  "summary": "simplifies grpc interceptors",
  "version": "0.15.4",
  "releases": [],
  "developers": [
    "dan_hipschman"
  ],
  "kwds": "grpc_interceptor interceptor interceptors grpc grpcexception",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_grpc_interceptor",
  "homepage": "https://github.com/d5h-foss/grpc-interceptor",
  "release_count": 17,
  "dependency_ids": [
    "pypi_grpcio",
    "pypi_protobuf"
  ]
}