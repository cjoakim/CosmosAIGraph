{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering :: astronomy"
  ],
  "description": "\nthis package compiles the official c++ code from `revisiting spacetrack\nreport #3`_ (aiaa 2006-6753) \u2014 specifically, the 2023 may\u00a009 release\nfrom david vallado\u2019s `fundamentals of astrodynamics and applications`_\nwebpage \u2014 and uses it to compute the positions of satellites in earth\norbit.  satellite orbital elements can be loaded from either a legacy\ntle file or from a modern omm element set, both of which you can fetch\nfrom a site like `celestrak <https://celestrak.com/>`_.\n\n.. _revisiting spacetrack report #3: https://celestrak.org/publications/aiaa/2006-6753/\n\n.. _fundamentals of astrodynamics and applications: https://celestrak.org/software/vallado-sw.php\n\nif your machine can\u2019t install or compile the c++ code, then this package\nfalls back to using a slower pure-python implementation of sgp4.  tests\nmake sure that its positions **agree to within 0.1\u00a0mm** with the\nstandard version of the algorithm \u2014 an error far less than the\n1\u20133\u00a0km/day by which satellites themselves deviate from the ideal orbits\ndescribed in tle files.\n\nan accelerated routine is available that, given a series of times and of\nsatellites, computes a whole array of output positions using a fast c++\nloop.  see the \u201carray acceleration\u201d section below.\n\nnote that the sgp4 propagator returns raw *x,y,z* cartesian coordinates\nin a \u201ctrue equator mean equinox\u201d (teme) reference frame that\u2019s centered\non the earth but does not rotate with it \u2014 an \u201cearth centered inertial\u201d\n(eci) reference frame.  the sgp4 propagator itself does not implement\nthe math to convert these positions into more official eci frames like\nj2000 or the icrs, nor into any earth-centered earth-fixed (ecef) frames\nlike the itrs, nor into latitudes and longitudes through an earth\nellipsoid like wgs84.  for conversions into these other coordinate\nframes, look for a comprehensive astronomy library, like the `skyfield\n<https://rhodesmill.org/skyfield/>`_ library that is built atop this one\n(see the `section on earth satellites\n<https://rhodesmill.org/skyfield/earth-satellites.html>`_ in its\ndocumentation).\n\nusage\n-----\n\nyou will probably first want to to check whether your machine has\nsuccessfully installed the fast sgp4 c++ code, or is using the slow\npython version (in which case this value will be false):\n\n>>> from sgp4.api import accelerated\n>>> print(accelerated)\ntrue\n\nthis library uses the same function names as the official c++ code, to\nhelp users who are already familiar with sgp4 in other languages.  here\nis how to compute the x,y,z position and velocity for the international\nspace station at 20:42:00 on 2019\u00a0december\u00a09:\n\n>>> from sgp4.api import satrec\n>>>\n>>> s = '1 25544u 98067a   19343.69339541  .00001764  00000-0  38792-4 0  9991'\n>>> t = '2 25544  51.6439 211.2001 0007417  17.6667  85.6398 15.50103472202482'\n>>> satellite = satrec.twoline2rv(s, t)\n>>>\n>>> jd, fr = 2458826.5, 0.8625\n>>> e, r, v = satellite.sgp4(jd, fr)\n>>> e\n0\n>>> print(r)  # true equator mean equinox position (km)\n(-6088.92..., -936.13..., -2866.44...)\n>>> print(v)  # true equator mean equinox velocity (km/s)\n(-1.525..., -5.538..., 5.068...)\n\nas input, you can provide either:\n\n* a simple floating-point julian date for ``jd`` and the value 0.0 for\n  ``fr``, if you are happy with the precision of a 64-bit floating point\n  number.  note that modern julian dates are greater than 2,450,000\n  which means that nearly half of the precision of a 64-bit float will\n  be consumed by the whole part that specifies the day.  the remaining\n  digits will provide a precision for the fraction of around 20.1\u00a0\u00b5s.\n  this should be no problem for the accuracy of your result \u2014 satellite\n  positions usually off by a few kilometers anyway, far less than a\n  satellite moves in 20.1\u00a0\u00b5s \u2014 but if you run a solver that dives down\n  into the microseconds while searching for a rising or setting time,\n  the solver might be bothered by the 20.1\u00a0\u00b5s plateau between each jump\n  in the satellite\u2019s position.\n\n* or, you can provide a coarse date ``jd`` plus a very precise fraction\n  ``fr`` that supplies the rest of the value.  the julian date for which\n  the satellite position is computed is the sum of the two values.  one\n  common practice is to provide the whole number as ``jd`` and the\n  fraction as ``fr``; another is to have ``jd`` carry the fraction 0.5\n  since utc midnight occurs halfway through each julian date.  either\n  way, splitting the value allows a solver to run all the way down into\n  the nanoseconds and still see sgp4 respond smoothly to tiny date\n  adjustments with tiny changes in the resulting satellite position.\n\nhere is how to intrepret the results:\n\n* ``e`` will be a non-zero error code if the satellite position could\n  not be computed for the given date.  you can ``from sgp4.api import\n  sgp4_errors`` to access a dictionary mapping error codes to error\n  messages explaining what each code means.\n\n* ``r`` measures the satellite position in **kilometers** from the\n  center of the earth in the idiosyncratic true equator mean equinox\n  coordinate frame used by sgp4.\n\n* ``v`` velocity is the rate at which the position is changing,\n  expressed in **kilometers per second**.\n\nif your application does not natively handle julian dates, you can\ncompute ``jd`` and ``fr`` from calendar dates using ``jday()``.\n\n>>> from sgp4.api import jday\n>>> jd, fr = jday(2019, 12, 9, 20, 42, 0)\n>>> jd\n2458826.5\n>>> fr\n0.8625\n\ndouble-checking your tle lines\n------------------------------\n\nbecause tle is an old punch-card fixed-width format, it\u2019s very sensitive\nto whether exactly the right number of spaces are positioned in exactly\nthe right columns.  if you suspect that your satellite elements aren\u2019t\ngetting loaded correctly, try calling the slow pure-python version of\n``twoline2rv()``, which performs extra checks that the fast c++ doesn\u2019t:\n\n>>> from sgp4.earth_gravity import wgs72\n>>> from sgp4.io import twoline2rv\n>>> assert twoline2rv(s, t, wgs72)\n\nany tle formatting errors will be raised as a ``valueerror``.\n\nusing omm elements instead of tle\n---------------------------------\n\nthe industry is migrating away from the original tle format, because it\nwill soon run out of satellite numbers.\n\n* some tle files now use a new \u201calpha-5\u201d convention that expands the\n  range of satellite numbers by using an initial letter; for example,\n  \u201ce8493\u201d means satellite 148493.  this library supports the alpha-5\n  convention and should return the correct integer in python.\n\n* some authorities are now distributing satellite elements in an \u201comm\u201d\n  orbit mean elements message format that replaces the tle format.  you\n  can learn about omm in dr.\u00a0t.s. kelso\u2019s `\u201ca new way to obtain gp data\u201d\n  <https://celestrak.com/norad/documentation/gp-data-formats.php>`_ at\n  the celestrak site.\n\nyou can already try out experimental support for omm:\n\n>>> from sgp4 import omm\n\nreading omm data takes two steps, because omm supports several different\ntext formats.  first, parse the input text to recover the field names\nand values that it stores; second, build a python satellite object from\nthose field values.  for example, to load omm from xml:\n\n>>> with open('sample_omm.xml') as f:\n...     fields = next(omm.parse_xml(f))\n>>> sat = satrec()\n>>> omm.initialize(sat, fields)\n\nor, to load omm from csv:\n\n>>> with open('sample_omm.csv') as f:\n...     fields = next(omm.parse_csv(f))\n>>> sat = satrec()\n>>> omm.initialize(sat, fields)\n\neither way, the satellite object should wind up properly initialized and\nready to start producing positions.\n\nif you are interested in saving satellite parameters using the new omm\nformat, then read the section on \u201cexport\u201d below.\n\nepoch\n-----\n\nover a given satellite\u2019s lifetime, dozens or hundreds of different tle\nrecords will be produced as its orbit evolves.  each tle record\nspecifies the \u201cepoch date\u201d for which it is most accurate.  typically a\ntle is only useful for a couple of weeks to either side of its epoch\ndate, beyond which its predictions become unreliable.\n\nsatellite objects natively provide their epoch as a two-digit year and\nthen a fractional number of days into the year:\n\n>>> satellite.epochyr\n19\n>>> satellite.epochdays\n343.69339541\n\nbecause sputnik was launched in 1957, satellite element sets will never\nrefer to an earlier year, so years 57 through 99 mean 1957\u20131999 while 0\nthrough 56 mean 2000\u20132056.  the tle format will presumably be obsolete\nin 2057 and have to be upgraded to 4-digit years.\n\nto turn the number of days and its fraction into a calendar date and\ntime, use the ``days2mdhms()`` function.\n\n>>> from sgp4.api import days2mdhms\n>>> month, day, hour, minute, second = days2mdhms(19, 343.69339541)\n>>> month\n12\n>>> day\n9\n>>> hour\n16\n>>> minute\n38\n>>> second\n29.363424\n\nthe sgp4 library also translates those two numbers into a julian date\nand fractional julian date, since julian dates are more commonly used in\nastronomy.\n\n>>> satellite.jdsatepoch\n2458826.5\n>>> satellite.jdsatepochf\n0.69339541\n\nfinally, a convenience function is available in the library if you need\nthe epoch date and time as python ``datetime``.\n\n>>> from sgp4.conveniences import sat_epoch_datetime\n>>> sat_epoch_datetime(satellite)\ndatetime.datetime(2019, 12, 9, 16, 38, 29, 363423, tzinfo=utc)\n\narray acceleration\n------------------\n\nto avoid the expense of running a python loop when you have many dates\nand times for which you want a position, you can pass your julian dates\nas arrays.  the array routine is only faster if your machine has\nsuccessfully installed or compiled the sgp4 c++ code, so you might want\nto check first:\n\n>>> from sgp4.api import accelerated\n>>> print(accelerated)\ntrue\n\nto call the array routine, make numpy arrays for ``jd`` and ``fr`` that\nare the same length:\n\n>>> import numpy as np\n>>> np.set_printoptions(precision=2)\n\n>>> jd = np.array((2458826, 2458826, 2458826, 2458826))\n>>> fr = np.array((0.0001, 0.0002, 0.0003, 0.0004))\n\n>>> e, r, v = satellite.sgp4_array(jd, fr)\n\n>>> print(e)\n[0 0 0 0]\n>>> print(r)\n[[-3431.31  2620.15 -5252.97]\n [-3478.86  2575.14 -5243.87]\n [-3526.09  2529.89 -5234.28]\n [-3572.98  2484.41 -5224.19]]\n>>> print(v)\n[[-5.52 -5.19  1.02]\n [-5.49 -5.22  1.08]\n [-5.45 -5.25  1.14]\n [-5.41 -5.28  1.2 ]]\n\nto avoid the expense of python loops when you have many satellites and\ndates, build a ``satrecarray`` from several individual satellites.  its\n``sgp4()`` method will expect both ``jd`` and ``fr`` to be numpy arrays,\nso if you only have one date, be sure to provide numpy arrays of length\none.  here is a sample computation for 2 satellites and 4 dates:\n\n>>> u = '1 20580u 90037b   19342.88042116  .00000361  00000-0  11007-4 0  9996'\n>>> w = '2 20580  28.4682 146.6676 0002639 185.9222 322.7238 15.09309432427086'\n>>> satellite2 = satrec.twoline2rv(u, w)\n\n>>> from sgp4.api import satrecarray\n>>> a = satrecarray([satellite, satellite2])\n>>> e, r, v = a.sgp4(jd, fr)\n\n>>> np.set_printoptions(precision=2)\n>>> print(e)\n[[0 0 0 0]\n [0 0 0 0]]\n>>> print(r)\n[[[-3431.31  2620.15 -5252.97]\n  [-3478.86  2575.14 -5243.87]\n  [-3526.09  2529.89 -5234.28]\n  [-3572.98  2484.41 -5224.19]]\n<blankline>\n [[ 5781.85  2564.   -2798.22]\n  [ 5749.36  2618.59 -2814.63]\n  [ 5716.35  2672.94 -2830.78]\n  [ 5682.83  2727.05 -2846.68]]]\n>>> print(v)\n[[[-5.52 -5.19  1.02]\n  [-5.49 -5.22  1.08]\n  [-5.45 -5.25  1.14]\n  [-5.41 -5.28  1.2 ]]\n<blankline>\n [[-3.73  6.33 -1.91]\n  [-3.79  6.3  -1.88]\n  [-3.85  6.28 -1.85]\n  [-3.91  6.25 -1.83]]]\n\nexport\n------\n\nif you have a ``satrec`` you want to share with friends or persist to a\nfile, there\u2019s an export routine that will turn it back into a tle:\n\n>>> from sgp4 import exporter\n>>> line1, line2 = exporter.export_tle(satellite)\n>>> line1\n'1 25544u 98067a   19343.69339541  .00001764  00000-0  38792-4 0  9991'\n>>> line2\n'2 25544  51.6439 211.2001 0007417  17.6667  85.6398 15.50103472202482'\n\nhappily, these are exactly the two tle lines that we used to create this\nsatellite object:\n\n>>> (s == line1) and (t == line2)\ntrue\n\nanother export routine is available that produces the fields defined by\nthe new omm format (see the \u201comm\u201d section above):\n\n>>> from pprint import pprint\n>>> fields = exporter.export_omm(satellite, 'iss (zarya)')\n>>> pprint(fields)\n{'arg_of_pericenter': 17.6667,\n 'bstar': 3.8792e-05,\n 'center_name': 'earth',\n 'classification_type': 'u',\n 'eccentricity': 0.0007417,\n 'element_set_no': 999,\n 'ephemeris_type': 0,\n 'epoch': '2019-12-09t16:38:29.363423',\n 'inclination': 51.6439,\n 'mean_anomaly': 85.6398,\n 'mean_element_theory': 'sgp4',\n 'mean_motion': 15.501034720000002,\n 'mean_motion_ddot': 0.0,\n 'mean_motion_dot': 1.764e-05,\n 'norad_cat_id': 25544,\n 'object_id': '1998-067a',\n 'object_name': 'iss (zarya)',\n 'ra_of_asc_node': 211.2001,\n 'ref_frame': 'teme',\n 'rev_at_epoch': 20248,\n 'time_system': 'utc'}\n\ngravity\n-------\n\nthe sgp4 algorithm operates atop a set of constants specifying how\nstrong the earth\u2019s gravity is.  the most recent official paper on sgp4\n(see below) specifies that \u201cwe use wgs-72 as the default value\u201d, so this\npython module uses the same default.  but in case you want to use either\nthe old legacy version of the wgs-72 constants, or else the non-standard\nbut more modern wgs-84 constants, the ``twoline2rv()`` constructor takes\nan optional argument:\n\n>>> from sgp4.api import wgs72old, wgs72, wgs84\n>>> satellite3 = satrec.twoline2rv(s, t, wgs84)\n\nyou will in general get less accurate results if you choose wgs-84.\neven though it reflects more recent and accurate measures of the earth,\nsatellite tles across the industry are most likely generated with wgs-72\nas their basis.  the positions you generate will better agree with the\nreal positions of each satellite if you use the same underlying gravity\nconstants as were used to generate the tle.\n\nproviding your own elements\n---------------------------\n\nif instead of parsing a tle you want to specify orbital elements\ndirectly, you can pass them as floating point numbers to a satellite\nobject\u2019s ``sgp4init()`` method.  for example, here\u2019s how to build the\nsame international space station orbit that we loaded from a tle in the\nfirst code example above:\n\n>>> satellite2 = satrec()\n>>> satellite2.sgp4init(\n...     wgs72,                # gravity model\n...     'i',                  # 'a' = old afspc mode, 'i' = improved mode\n...     25544,                # satnum: satellite number\n...     25545.69339541,       # epoch: days since 1949 december 31 00:00 ut\n...     3.8792e-05,           # bstar: drag coefficient (1/earth radii)\n...     0.0,                  # ndot: ballistic coefficient (radians/minute^2)\n...     0.0,                  # nddot: mean motion 2nd derivative (radians/minute^3)\n...     0.0007417,            # ecco: eccentricity\n...     0.3083420829620822,   # argpo: argument of perigee (radians)\n...     0.9013560935706996,   # inclo: inclination (radians)\n...     1.4946964807494398,   # mo: mean anomaly (radians)\n...     0.06763602333248933,  # no_kozai: mean motion (radians/minute)\n...     3.686137125541276,    # nodeo: r.a. of ascending node (radians)\n... )\n\nthese numbers don\u2019t look the same as the numbers in the tle, because the\nunderlying ``sgp4init()`` routine uses different units: radians rather\nthan degrees.  but this is the same orbit and will produce the same\npositions.\n\nnote that ``ndot`` and ``nddot`` are ignored by the sgp4 propagator, so\nyou can leave them ``0.0`` without any effect on the resulting satellite\npositions.  but they do at least get saved to the satellite object, and\nwritten out if you write the parameters to a tle or omm file (see the\n\u201cexport\u201d section, above).\n\nto compute the \u201cepoch\u201d argument, take the epoch\u2019s julian date and\nsubtract 2433281.5 days.\n\nwhile the underlying ``sgp4init()`` routine leaves the attributes\n``epochyr``, ``epochdays``, ``jdsatepoch``, and ``jdsatepochf`` unset,\nthis library goes ahead and sets them anyway for you, using the epoch\nyou provided.\n\nsee the next section for the complete list of attributes that are\navailable from the satellite record once it has been initialized.\n\nattributes\n----------\n\nthere are several dozen ``satrec`` attributes that expose data from the\nunderlying c++ sgp4 record.  they fall into the following categories.\n\n*identification*\n\nthese are copied directly from the tle record but aren\u2019t used by the\npropagation math.\n\n| ``satnum_str`` \u2014 satellite number, as a 5-character string.\n| ``satnum`` \u2014 satellite number, converted to an integer.\n| ``classification`` \u2014 ``'u'``, ``'c'``, or ``'s'``\n  indicating the element set is unclassified, classified, or secret.\n| ``ephtype`` \u2014 integer \u201cephemeris type\u201d, used internally by space\n  agencies to mark element sets that are not ready for publication;\n  this field should always be ``0`` in published tles.\n| ``elnum`` \u2014 element set number.\n| ``revnum`` \u2014 satellite\u2019s revolution number at the moment of the epoch,\n  presumably counting from 1 following launch.\n\n*orbital elements*\n\nthese are the orbital parameters, copied verbatim from the text of the\ntle record.  they describe the orbit at the moment of the tle\u2019s epoch\nand so remain constant even as the satellite record is used over and\nover again to propagate positions for different times.\n\n| ``epochyr`` \u2014 epoch date: the last two digits of the year.\n| ``epochdays`` \u2014 epoch date: the number of days into the year,\n  including a decimal fraction for the utc time of day.\n| ``ndot`` \u2014 first time derivative of the mean motion\n  (loaded from the tle, but otherwise ignored).\n| ``nddot`` \u2014 second time derivative of the mean motion\n  (loaded from the tle, but otherwise ignored).\n| ``bstar`` \u2014 ballistic drag coefficient b* (1/earth\u00a0radii).\n| ``inclo`` \u2014 inclination (radians).\n| ``nodeo`` \u2014 right ascension of ascending node (radians).\n| ``ecco`` \u2014 eccentricity.\n| ``argpo`` \u2014 argument of perigee (radians).\n| ``mo`` \u2014 mean anomaly (radians).\n| ``no_kozai`` \u2014 mean motion (radians/minute).\n| ``no`` \u2014 alias for ``no_kozai``, for compatibility with old code.\n\nyou can also access the epoch as a julian date:\n\n| ``jdsatepoch`` \u2014 whole part of the epoch\u2019s julian date.\n| ``jdsatepochf`` \u2014 fractional part of the epoch\u2019s julian date.\n\n*computed orbit properties*\n\nthese are computed when the satellite is first loaded,\nas a convenience for callers who might be interested in them.\nthey aren\u2019t used by the sgp4 propagator itself.\n\n| ``a`` \u2014 semi-major axis (earth\u00a0radii).\n| ``altp`` \u2014 altitude of the satellite at perigee\n  (earth\u00a0radii, assuming a spherical earth).\n| ``alta`` \u2014 altitude of the satellite at apogee\n  (earth\u00a0radii, assuming a spherical earth).\n| ``argpdot`` \u2014 rate at which the argument of perigee is changing\n  (radians/minute).\n| ``gsto`` \u2014 greenwich sidereal time at the satellite\u2019s epoch (radians).\n| ``mdot`` \u2014 rate at which the mean anomaly is changing (radians/minute)\n| ``nodedot`` \u2014 rate at which the right ascension of the ascending node\n  is changing (radians/minute).\n\n*propagator mode*\n\n| ``operationmode`` \u2014 a single character that directs sgp4\n  to either operate in its modern ``'i'`` improved mode\n  or in its legacy ``'a'`` afspc mode.\n| ``method`` \u2014 a single character, chosen automatically\n  when the orbital elements were loaded, that indicates whether sgp4\n  has chosen to use its built-in ``'n'`` near earth\n  or ``'d'`` deep space mode for this satellite.\n\n*result of most recent propagation*\n\n| ``t`` \u2014\n  the time you gave when you most recently asked sgp4\n  to compute this satellite\u2019s position,\n  measured in minutes before (negative) or after (positive)\n  the satellite\u2019s epoch.\n| ``error`` \u2014\n  error code produced by the most recent sgp4 propagation\n  you performed with this element set.\n\nthe possible ``error`` codes are:\n\n0. no error.\n1. mean eccentricity is outside the range 0\u00a0\u2264\u00a0e\u00a0<\u00a01.\n2. mean motion has fallen below zero.\n3. perturbed eccentricity is outside the range 0\u00a0\u2264\u00a0e\u00a0\u2264\u00a01.\n4. length of the orbit\u2019s semi-latus rectum has fallen below zero.\n5. (no longer used.)\n6. orbit has decayed: the computed position is underground.\n   (the position is still returned, in case the vector is helpful\n   to software that might be searching for the moment of re-entry.)\n\n*mean elements from most recent propagation*\n\npartway through each propagation, the sgp4 routine saves a set of\n\u201csingly averaged mean elements\u201d that describe the orbit\u2019s shape at the\nmoment for which a position is being computed.  they are averaged with\nrespect to the mean anomaly and include the effects of secular gravity,\natmospheric drag, and \u2014 in deep space mode \u2014 of those pertubations from\nthe sun and moon that sgp4 averages over an entire revolution of each of\nthose bodies.  they omit both the shorter-term and longer-term periodic\npertubations from the sun and moon that sgp4 applies right before\ncomputing each position.\n\n| ``am`` \u2014 average semi-major axis (earth\u00a0radii).\n| ``em`` \u2014 average eccentricity.\n| ``im`` \u2014 average inclination (radians).\n| ``om`` \u2014 average right ascension of ascending node (radians).\n| ``om`` \u2014 average argument of perigee (radians).\n| ``mm`` \u2014 average mean anomaly (radians).\n| ``nm`` \u2014 average mean motion (radians/minute).\n\n*gravity model parameters*\n\nwhen the satellite record is initialized, your choice of gravity model\nresults in a slate of eight constants being copied in:\n\n| ``tumin`` \u2014 minutes in one \u201ctime unit\u201d.\n| ``xke`` \u2014 the reciprocal of ``tumin``.\n| ``mu`` \u2014 earth\u2019s gravitational parameter (km\u00b3/s\u00b2).\n| ``radiusearthkm`` \u2014 radius of the earth (km).\n| ``j2``, ``j3``, ``j4`` \u2014 un-normalized zonal harmonic values j\u2082, j\u2083, and j\u2084.\n| ``j3oj2`` \u2014 the ratio j\u2083/j\u2082.\n\nprinting satellite attributes\n-----------------------------\n\nif you want to print out a satellite, this library provides a convenient\n\u201cattribute dump\u201d routine that takes a satellite and generates lines that\nlist its attributes::\n\n    from sys import stdout\n    from sgp4.conveniences import dump_satrec\n\n    stdout.writelines(dump_satrec(satellite))\n\nif you want to compare two satellites, then simply pass a second\nargument; the second satellite\u2019s attributes will be printed in a second\ncolumn next to those of the first. ::\n\n    stdout.writelines(dump_satrec(satellite, satellite2))\n\nvalidation against the official algorithm\n-----------------------------------------\n\nthis implementation passes all of the automated tests in the august 2010\nrelease of the reference implementation of sgp4 by vallado et\u00a0al., who\noriginally published their revision of sgp4 in\u00a02006:\n\n    vallado, david a., paul crawford, richard hujsak, and t.s. kelso,\n    \u201crevisiting spacetrack report #3,\u201d presented at the aiaa/aas\n    astrodynamics specialist conference, keystone, co, 2006 august\n    21\u201324.\n\nif you would like to review the paper, it is `available online\n<https://www.celestrak.com/publications/aiaa/2006-6753/>`_.  you can\nalways download the latest version of their code for comparison against\nthis python module (or other implementations) at `aiaa-2006-6753.zip\n<https://www.celestrak.com/publications/aiaa/2006-6753/aiaa-2006-6753.zip>`_.\n\nfor developers\n--------------\n\ndevelopers can check out this full project from github:\n\nhttps://github.com/brandon-rhodes/python-sgp4\n\nto run its unit tests, install python\u00a02, python\u00a03, and the ``tox``\ntesting tool.  the tests runing in python\u00a02 will exercise the fallback\npure-python version of the routines, while python\u00a03 exercises the fast\nnew c++ accelerated code::\n\n    cd python-sgp4\n    tox\n\nlegacy api\n----------\n\nbefore this library pivoted to wrapping vallado's official c++ code and\nwas operating in pure python only, it had a slightly quirkier api, which\nis still supported for compatibility with older clients.  you can learn\nabout it by reading the documentation from version 1.4 or earlier:\n\nhttps://pypi.org/project/sgp4/1.4/\n\nchangelog\n---------\n\n2023-10-01 \u2014 2.23\n\n* tweaked tests to resolve breakage introduced by python\u00a03.12.\n\n2023-04-27 \u2014 2.22\n\n* added a ``satnum_str`` attribute, exposing the fact that the c++ now\n  stores the satellite number as a string; and check that ``satnum`` is\n  never greater than 339999.\n\n* fixed the units of the ``nddot`` attribute when the value is loaded\n  from an omm record.  (since the tle computation itself ignores this\n  attribute, this did not affect any satellite positions.)\n\n* enhanced the fallback python version of ``twoline2rv()`` to verify\n  that tle lines are ascii, and added documentation using it to\n  double-check tles that might suffer from non-ascii characters.\n\n* if the user doesn\u2019t set a satellite\u2019s ``classification``, it now\n  defaults to ``'u'`` for \u2018unclassified\u2019.\n\n2022-04-06 \u2014 2.21\n\n* added ``dump_satrec()`` to the ``sgp4.conveniences`` module.\n\n* fixed the ``satrec`` attribute ``.error``, which was previously\n  building a nonsense integer from the wrong data in memory.\n\n* removed ``.whichconst`` from python ``satrec``, to help users avoid\n  writing code that will break when the c++ extension is available.\n\n2021-07-01 \u2014 2.20\n\n* taught ``sgp4init()`` to round both ``epochdays`` and ``jdsatepochf``\n  to the same 8 decimal places used for the date fraction in a tle, if\n  the user-supplied ``epoch`` itself has 8 or fewer digits behind the\n  decimal point.  this should make it easier to build satellites that\n  round-trip to tle format with perfect accuracy.\n\n* fixed how ``export_tle()`` formats the bstar field when its value, if\n  written in scientific notation, has a positive exponent.\n\n* fixed the ``epochyr`` assigned by ``sgp4init()`` so years before 2000\n  have two digits instead of three (for example, so that 1980 produces\n  an ``epochyr`` of 80 instead of 980).\n\n2021-04-22 \u2014 2.19\n\n* extended the documentation on the python package index and in the\n  module docstring so it lists every ``satrec`` attribute that this\n  library exposes; even the more obscure ones might be useful to folks\n  working to analyze satellite orbits.\n\n2021-03-08 \u2014 2.18\n\n* if a tle satellite number lacks the required 5 digits,\n  ``twoline2rv()`` now gives the underlying c++ library a little help so\n  it can still parse the classification and international designator\n  correctly.\n\n* the ``satrec`` attributes ``jdsatepoch``, ``jdsatepochf``,\n  ``epochyr``, and ``epochdays`` are now writeable, so users can adjust\n  their values manually \u2014 which should make up for the fact that the\n  ``sgp4init()`` method can\u2019t set them with full floating point\n  precision.\n\n| 2021-02-17 \u2014 2.17 \u2014 fixed where in the output array the ``sgp4_array()`` method writes nan values when an sgp4 propagation fails.\n| 2021-02-12 \u2014 2.16 \u2014 fixed ``days2mdhms()`` rounding to always match tle epoch.\n| 2021-01-08 \u2014 2.15 \u2014 fixed parsing of the ``satnum`` tle field in the python fallback code, when the field has a leading space; added omm export routine.\n| 2020-12-16 \u2014 2.14 \u2014 new data formats: added omm message support for both xml and csv, and added support for the new alpha-5 extension to tle files.\n| 2020-10-14 \u2014 2.13 \u2014 enhanced ``sgp4init()`` with custom code that also sets the ``epochdays`` and ``epochyr`` satellite attributes.\n| 2020-05-28 \u2014 2.12 \u2014 moved the decision of whether to set the locale during ``twoline2rv()`` from import time to runtime, for users who change locales after their application is up and running.\n| 2020-05-24 \u2014 2.11 \u2014 fixed a regression in how dates are split into hours, minutes, and seconds that would sometimes produce a time whose second=60, crashing the pure-python version of the library.\n| 2020-05-22 \u2014 2.10 \u2014 switch the locale temporarily to ``c`` during the c++ accelerated ``twoline2rv()``, since it does not protect its ``sscanf()`` calls from locales that, like german, expect comma decimal points instead of the period decimal points always used in a tle.\n| 2020-05-21 \u2014 2.9 \u2014 added ``sat_epoch_datetime()``, expanded documentation around converting a satellite epoch to a date and time, and started rounding the epoch to exactly the digits provided in the tle; and removed the ``satrec.epoch`` attribute from python fallback code to better match the c++ version.\n| 2020-05-07 \u2014 2.8 \u2014 new function ``jday_datetime()`` is now available in the ``sgp4.conveniences`` module, thanks to egemen imre.\n| 2020-04-24 \u2014 2.7 \u2014 new method ``sgp4init()`` (thank you, chris lewicki!) is available.\n| 2020-04-20 \u2014 2.6 \u2014 new routine ``export_tle()`` (thank you, egemen imre!) is available. improved how the accelerated c++ backend parses the ``intldesg`` string and the ``revnum`` integer.\n| 2020-03-22 \u2014 2.5 \u2014 gave the new accelerated ``twoline2rv()`` an optional argument that lets the user choose a non-standard set of gravity constants.\n| 2020-02-25 \u2014 2.4 \u2014 improved the ``jday()`` docstring; made the old legacy python resilient if the day of the month is out-of-range (past the end of the month) in a tle; and mark rutten fixed the c++ so it compiles on windows!\n| 2020-02-04 \u2014 2.3 \u2014 removed experimental code that caused performance problems for users with numba installed.\n| 2020-02-02 \u2014 2.2 \u2014 a second release on palindrome day: fix the satrec ``.epochyr`` attribute so it behaves the same way in python as it does in the official c library, where it is only the last 2 digits of the year; and make ``.no`` available in the python fallback case as well.\n| 2020-02-02 \u2014 2.1 \u2014 add vectorized array method to satrec object; add ``.no`` attribute to new satrec object to support old code that has not migrated to the new name ``.no_kozai``; gave python wrapper classes ``__slots__`` to avoid the expense of a per-object attribute dictionary.\n| 2020-01-30 \u2014 2.0 \u2014 rewrite api to use genuine vallado c++ code on those systems where it can be compiled; add accelerated vectorized array interface; make ``gstime()`` a public function; clarify format error message.\n| 2015-01-15 \u2014 1.4 \u2014 display detailed help when tle input does not match format.\n| 2014-06-26 \u2014 1.3 \u2014 return ``(nan,nan,nan)`` vectors on error and set ``.error_message``\n| 2013-11-29 \u2014 1.2 \u2014 made ``epochyr`` 4 digits; add ``datetime`` for ``.epoch``\n| 2012-11-22 \u2014 1.1 \u2014 python\u00a03 compatibility; more documentation\n| 2012-08-27 \u2014 1.0 \u2014 initial release\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "sgp4",
  "package_url": "https://pypi.org/project/sgp4/",
  "project_url": "https://pypi.org/project/sgp4/",
  "project_urls": {
    "Homepage": "https://github.com/brandon-rhodes/python-sgp4"
  },
  "release_url": "https://pypi.org/project/sgp4/2.23/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "track earth satellites given tle data, using up-to-date 2020 sgp4 routines.",
  "version": "2.23",
  "releases": [],
  "developers": [
    "brandon@rhodesmill.org",
    "brandon_rhodes"
  ],
  "kwds": "satellites sgp4_array spacetrack orbit sgp4_errors",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_sgp4",
  "homepage": "https://github.com/brandon-rhodes/python-sgp4",
  "release_count": 28,
  "dependency_ids": []
}