{
  "classifiers": [
    "development status :: 6 - mature",
    "development status :: 7 - inactive",
    "intended audience :: developers",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.4",
    "programming language :: python :: 2.5",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "* new in 0.8: source and tests are compatible with python 3 (w/o ``setup.py``)\r\n\r\n  * 0.8.1: setup.py is now compatible with python 3 as well\r\n\r\n* new in 0.7: `multiple types or objects`_\r\n\r\n* new in 0.6: `inspection and extension`_, and thread-safe method registration\r\n\r\nthe ``simplegeneric`` module lets you define simple single-dispatch\r\ngeneric functions, akin to python's built-in generic functions like\r\n``len()``, ``iter()`` and so on.  however, instead of using\r\nspecially-named methods, these generic functions use simple lookup\r\ntables, akin to those used by e.g. ``pickle.dump()`` and other\r\ngeneric functions found in the python standard library.\r\n\r\nas you can see from the above examples, generic functions are actually\r\nquite common in python already, but there is no standard way to create\r\nsimple ones.  this library attempts to fill that gap, as generic\r\nfunctions are an `excellent alternative to the visitor pattern`_, as\r\nwell as being a great substitute for most common uses of adaptation.\r\n\r\nthis library tries to be the simplest possible implementation of generic\r\nfunctions, and it therefore eschews the use of multiple or predicate\r\ndispatch, as well as avoiding speedup techniques such as c dispatching\r\nor code generation.  but it has absolutely no dependencies, other than\r\npython 2.4, and the implementation is just a single python module of\r\nless than 100 lines.\r\n\r\n\r\nusage\r\n-----\r\n\r\ndefining and using a generic function is straightforward::\r\n\r\n    >>> from simplegeneric import generic\r\n    >>> @generic\r\n    ... def move(item, target):\r\n    ...     \"\"\"default implementation goes here\"\"\"\r\n    ...     print(\"what you say?!\")\r\n\r\n    >>> @move.when_type(int)\r\n    ... def move_int(item, target):\r\n    ...     print(\"in ad %d, %s was beginning.\" % (item, target))\r\n\r\n    >>> @move.when_type(str)\r\n    ... def move_str(item, target):\r\n    ...     print(\"how are you %s!!\" % item)\r\n    ...     print(\"all your %s are belong to us.\" % (target,))\r\n\r\n    >>> zig = object()\r\n    >>> @move.when_object(zig)\r\n    ... def move_zig(item, target):\r\n    ...     print(\"you know what you %s.\" % (target,))\r\n    ...     print(\"for great justice!\")\r\n\r\n    >>> move(2101, \"war\")\r\n    in ad 2101, war was beginning.\r\n\r\n    >>> move(\"gentlemen\", \"base\")\r\n    how are you gentlemen!!\r\n    all your base are belong to us.\r\n\r\n    >>> move(zig, \"doing\")\r\n    you know what you doing.\r\n    for great justice!\r\n\r\n    >>> move(27.0, 56.2)\r\n    what you say?!\r\n\r\n\r\ninheritance and allowed types\r\n-----------------------------\r\n\r\ndefining multiple methods for the same type or object is an error::\r\n\r\n    >>> @move.when_type(str)\r\n    ... def this_is_wrong(item, target):\r\n    ...     pass\r\n    traceback (most recent call last):\r\n    ...\r\n    typeerror: <function move...> already has method for type <...'str'>\r\n\r\n    >>> @move.when_object(zig)\r\n    ... def this_is_wrong(item, target): pass\r\n    traceback (most recent call last):\r\n      ...\r\n    typeerror: <function move...> already has method for object <object ...>\r\n\r\nand the ``when_type()`` decorator only accepts classes or types::\r\n\r\n    >>> @move.when_type(23)\r\n    ... def move_23(item, target):\r\n    ...     print(\"you have no chance to survive!\")\r\n    traceback (most recent call last):\r\n      ...\r\n    typeerror: 23 is not a type or class\r\n\r\nmethods defined for supertypes are inherited following mro order::\r\n\r\n    >>> class mystring(str):\r\n    ...     \"\"\"string subclass\"\"\"\r\n\r\n    >>> move(mystring(\"ladies\"), \"drinks\")\r\n    how are you ladies!!\r\n    all your drinks are belong to us.\r\n\r\nclassic class instances are also supported (although the lookup process\r\nis slower than for new-style instances)::\r\n\r\n    >>> class x: pass\r\n    >>> class y(x): pass\r\n\r\n    >>> @move.when_type(x)\r\n    ... def move_x(item, target):\r\n    ...     print(\"someone set us up the %s!!!\" % (target,))\r\n\r\n    >>> move(x(), \"bomb\")\r\n    someone set us up the bomb!!!\r\n\r\n    >>> move(y(), \"dance\")\r\n    someone set us up the dance!!!\r\n\r\n\r\nmultiple types or objects\r\n-------------------------\r\n\r\nas a convenience, you can now pass more than one type or object to the\r\nregistration methods::\r\n\r\n    >>> @generic\r\n    ... def isbuiltin(ob):\r\n    ...     return false\r\n    >>> @isbuiltin.when_type(int, str, float, complex, type)\r\n    ... @isbuiltin.when_object(none, ellipsis)\r\n    ... def yes(ob):\r\n    ...     return true\r\n    \r\n    >>> isbuiltin(1)\r\n    true\r\n    >>> isbuiltin(object)\r\n    true\r\n    >>> isbuiltin(object())\r\n    false\r\n    >>> isbuiltin(x())\r\n    false\r\n    >>> isbuiltin(none)\r\n    true\r\n    >>> isbuiltin(ellipsis)\r\n    true\r\n\r\n\r\ndefaults and docs\r\n-----------------\r\n\r\nyou can obtain a function's default implementation using its ``default``\r\nattribute::\r\n\r\n    >>> @move.when_type(y)\r\n    ... def move_y(item, target):\r\n    ...     print(\"someone set us up the %s!!!\" % (target,))\r\n    ...     move.default(item, target)\r\n\r\n    >>> move(y(), \"dance\")\r\n    someone set us up the dance!!!\r\n    what you say?!\r\n\r\n\r\n``help()`` and other documentation tools see generic functions as normal\r\nfunction objects, with the same name, attributes, docstring, and module as\r\nthe prototype/default function::\r\n\r\n    >>> help(move)\r\n    help on function move:\r\n    ...\r\n    move(*args, **kw)\r\n        default implementation goes here\r\n    ...\r\n\r\n\r\ninspection and extension\r\n------------------------\r\n\r\nyou can find out if a generic function has a method for a type or object using\r\nthe ``has_object()`` and ``has_type()`` methods::\r\n\r\n    >>> move.has_object(zig)\r\n    true\r\n    >>> move.has_object(42)\r\n    false\r\n\r\n    >>> move.has_type(x)\r\n    true\r\n    >>> move.has_type(float)\r\n    false\r\n\r\nnote that ``has_type()`` only queries whether there is a method registered for\r\nthe *exact* type, not subtypes or supertypes::\r\n\r\n    >>> class z(x): pass\r\n    >>> move.has_type(z)\r\n    false\r\n\r\nyou can create a generic function that \"inherits\" from an existing generic\r\nfunction by calling ``generic()`` on the existing function::\r\n\r\n    >>> move2 = generic(move)\r\n    >>> move(2101, \"war\")\r\n    in ad 2101, war was beginning.\r\n\r\nany methods added to the new generic function override *all* methods in the\r\n\"base\" function::\r\n\r\n    >>> @move2.when_type(x)\r\n    ... def move2_x(item, target):\r\n    ...     print(\"you have no chance to survive make your %s!\" % (target,))\r\n\r\n    >>> move2(x(), \"time\")\r\n    you have no chance to survive make your time!\r\n\r\n    >>> move2(y(), \"time\")\r\n    you have no chance to survive make your time!\r\n\r\nnotice that even though ``move()`` has a method for type ``y``, the method\r\ndefined for ``x`` in ``move2()`` takes precedence.  this is because the\r\n``move`` function is used as the ``default`` method of ``move2``, and ``move2``\r\nhas no method for type ``y``::\r\n\r\n    >>> move2.default is move\r\n    true\r\n    >>> move.has_type(y)\r\n    true\r\n    >>> move2.has_type(y)\r\n    false\r\n\r\n\r\nlimitations\r\n-----------\r\n\r\n* the first argument is always used for dispatching, and it must always be\r\n  passed *positionally* when the function is called.\r\n\r\n* documentation tools don't see the function's original argument signature, so\r\n  you have to describe it in the docstring.\r\n\r\n* if you have optional arguments, you must duplicate them on every method in\r\n  order for them to work correctly.  (on the plus side, it means you can have\r\n  different defaults or required arguments for each method, although relying on\r\n  that quirk probably isn't a good idea.)\r\n\r\nthese restrictions may be lifted in later releases, if i feel the need.  they\r\nwould require runtime code generation the way i do it in ``ruledispatch``,\r\nhowever, which is somewhat of a pain.  (alternately i could use the\r\n``bytecodeassembler`` package to do the code generation, as that's a lot easier\r\nto use than string-based code generation, but that would introduce more\r\ndependencies, and i'm trying to keep this simple so i can just\r\ntoss it into chandler without a big footprint increase.)\r\n\r\n.. _excellent alternative to the visitor pattern: http://peak.telecommunity.com/devcenter/visitorrevisited",
  "docs_url": null,
  "keywords": "",
  "license": "zpl 2.1",
  "name": "simplegeneric",
  "package_url": "https://pypi.org/project/simplegeneric/",
  "project_url": "https://pypi.org/project/simplegeneric/",
  "project_urls": {
    "Download": "UNKNOWN",
    "Homepage": "http://cheeseshop.python.org/pypi/simplegeneric"
  },
  "release_url": "https://pypi.org/project/simplegeneric/0.8.1/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "simple generic functions (similar to python's own len(), pickle.dump(), etc.)",
  "version": "0.8.1",
  "releases": [],
  "developers": [
    "peak@eby-sarna.com",
    "phillip_j"
  ],
  "kwds": "python when_type has_type types py",
  "license_kwds": "zpl 2.1",
  "libtype": "pypi",
  "id": "pypi_simplegeneric",
  "homepage": "http://cheeseshop.python.org/pypi/simplegeneric",
  "release_count": 5,
  "dependency_ids": []
}