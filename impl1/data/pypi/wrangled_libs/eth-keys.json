{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# ethereum keys\n\n\na common api for ethereum key operations with pluggable backends.\n\n\n> this library and repository was previously located at https://github.com/pipermerriam/ethereum-keys.  it was transferred to the ethereum foundation github in november 2017 and renamed to `eth-keys`.  the pypi package was also renamed from `ethereum-keys` to `eth-keys`.\n\n## installation\n\n```sh\npip install eth-keys\n```\n\n## development\n\n```sh\npip install -e .[dev]\n```\n\n\n### running the tests\n\nyou can run the tests with:\n\n```sh\npy.test tests\n```\n\nor you can install `tox` to run the full test suite.\n\n\n### releasing\n\npandoc is required for transforming the markdown readme to the proper format to\nrender correctly on pypi.\n\nfor debian-like systems:\n\n```\napt install pandoc\n```\n\nor on osx:\n\n```sh\nbrew install pandoc\n```\n\nto release a new version:\n\n```sh\nmake release bump=$$version_part_to_bump$$\n```\n\n\n#### how to bumpversion\n\nthe version format for this repo is `{major}.{minor}.{patch}` for stable, and\n`{major}.{minor}.{patch}-{stage}.{devnum}` for unstable (`stage` can be alpha or beta).\n\nto issue the next version in line, specify which part to bump,\nlike `make release bump=minor` or `make release bump=devnum`.\n\nif you are in a beta version, `make release bump=stage` will switch to a stable.\n\nto issue an unstable version when the current version is stable, specify the\nnew version explicitly, like `make release bump=\"--new-version 2.0.0-alpha.1 devnum\"`\n\n\n\n## quickstart\n\n```python\n>>> from eth_keys import keys\n>>> pk = keys.privatekey(b'\\x01' * 32)\n>>> signature = pk.sign_msg(b'a message')\n>>> pk\n'0x0101010101010101010101010101010101010101010101010101010101010101'\n>>> pk.public_key\n'0x1b84c5567b126440995d3ed5aaba0565d71e1834604819ff9c17f5e9d5dd078f70beaf8f588b541507fed6a642c5ab42dfdf8120a7f639de5122d47a69a8e8d1'\n>>> signature\n'0xccda990dba7864b79dc49158fea269338a1cf5747bc4c4bf1b96823e31a0997e7d1e65c06c5bf128b7109e1b4b9ba8d1305dc33f32f624695b2fa8e02c12c1e000'\n>>> pk.public_key.to_checksum_address()\n'0x1a642f0e3c3af545e7acbd38b07251b3990914f1'\n>>> signature.verify_msg(b'a message', pk.public_key)\ntrue\n>>> signature.recover_public_key_from_msg(b'a message') == pk.public_key\ntrue\n```\n\n\n## documentation\n\n### `keyapi(backend=none)`\n\nthe `keyapi` object is the primary api for interacting with the `eth-keys`\nlibary.  the object takes a single optional argument in its constructor which\ndesignates what backend will be used for eliptical curve cryptography\noperations.  the built-in backends are:\n\n* `eth_keys.backends.nativeeccbackend`: a pure python implementation of the ecc operations.\n* `eth_keys.backends.coincurveeccbackend`: uses the [`coincurve`](https://github.com/ofek/coincurve) library for ecc operations.\n\nby default, `eth-keys` will *try* to use the `coincurveeccbackend`,\nfalling back to the `nativeeccbackend` if the `coincurve` library is not\navailable.\n\n> note: the `coincurve` library is not automatically installed with `eth-keys` and must be installed separately.\n\nthe `backend` argument can be given in any of the following forms.\n\n* instance of the backend class\n* the backend class\n* string with the dot-separated import path for the backend class.\n\n```python\n>>> from eth_keys import keyapi\n>>> from eth_keys.backends import nativeeccbackend\n# these are all the same\n>>> keys = keyapi(nativeeccbackend)\n>>> keys = keyapi(nativeeccbackend())\n>>> keys = keyapi('eth_keys.backends.nativeeccbackend')\n# or for the coincurve base backend\n>>> keys = keyapi('eth_keys.backends.coincurveeccbackend')\n```\n\nthe backend can also be configured using the environment variable\n`ecc_backend_class` which should be set to the dot-separated python import path\nto the desired backend.\n\n```python\n>>> import os\n>>> os.environ['ecc_backend_class'] = 'eth_keys.backends.coincurveeccbackend'\n```\n\n\n### `keyapi.ecdsa_sign(message_hash, private_key) -> signature`\n\nthis method returns a signature for the given `message_hash`, signed by the\nprovided `private_key`.\n\n* `message_hash`: **must** be a byte string of length 32\n* `private_key`: **must** be an instance of `privatekey`\n\n\n### `keyapi.ecdsa_verify(message_hash, signature, public_key) -> bool`\n\nreturns `true` or `false` based on whether the provided `signature` is a valid\nsignature for the provided `message_hash` and `public_key`.\n\n* `message_hash`: **must** be a byte string of length 32\n* `signature`: **must** be an instance of `signature`\n* `public_key`: **must** be an instance of `publickey`\n\n\n### `keyapi.ecdsa_recover(message_hash, signature) -> publickey`\n\nreturns the `publickey` instances recovered from the given `signature` and\n`message_hash`.\n\n* `message_hash`: **must** be a byte string of length 32\n* `signature`: **must** be an instance of `signature`\n\n\n### `keyapi.private_key_to_public_key(private_key) -> publickey`\n\nreturns the `publickey` instances computed from the given `private_key`\ninstance.\n\n* `private_key`: **must** be an instance of `publickey`\n\n\n### common apis for `publickey`, `privatekey` and `signature`\n\nthere is a common api for the following objects.\n\n* `publickey`\n* `privatekey`\n* `signature`\n\neach of these objects has all of the following apis.\n\n* `obj.to_bytes()`: returns the object in it's canonical `bytes` serialization.\n* `obj.to_hex()`: returns a text string of the hex encoded canonical representation.\n\n\n### `keyapi.publickey(public_key_bytes)`\n\nthe `publickey` class takes a single argument which must be a bytes string with length 64.\n\n> note that there are two other common formats for public keys: 65 bytes with a leading `\\x04` byte\n> and 33 bytes starting with either `\\x02` or `\\x03`. to use the former with the `publickey` object,\n> remove the first byte. for the latter, refer to `publickey.from_compressed_bytes`.\n\nthe following methods are available:\n\n\n#### `publickey.from_compressed_bytes(compressed_bytes) -> publickey`\n\nthis `classmethod` returns a new `publickey` instance computed from its compressed representation.\n\n* `compressed_bytes` **must** be a byte string of length 33 starting with `\\x02` or `\\x03`.\n\n\n#### `publickey.from_private(private_key) -> publickey`\n\nthis `classmethod` returns a new `publickey` instance computed from the\ngiven `private_key`.  \n\n* `private_key` may either be a byte string of length 32 or an instance of the `keyapi.privatekey` class.\n\n\n#### `publickey.recover_from_msg(message, signature) -> publickey`\n\nthis `classmethod` returns a new `publickey` instance computed from the\nprovided `message` and `signature`.\n\n* `message` **must** be a byte string\n* `signature` **must** be an instance of `keyapi.signature`\n\n\n#### `publickey.recover_from_msg_hash(message_hash, signature) -> publickey`\n\nsame as `publickey.recover_from_msg` except that `message_hash` should be the keccak\nhash of the `message`.\n\n\n#### `publickey.verify_msg(message, signature) -> bool`\n\nthis method returns `true` or `false` based on whether the signature is a valid\nfor the given message.\n\n\n#### `publickey.verify_msg_hash(message_hash, signature) -> bool`\n\nsame as `publickey.verify_msg` except that `message_hash` should be the keccak\nhash of the `message`.\n\n\n#### `publickey.to_compressed_bytes() -> bytes`\n\nreturns the compressed representation of this public key.\n\n\n#### `publickey.to_address() -> text`\n\nreturns the hex encoded ethereum address for this public key.\n\n\n#### `publickey.to_checksum_address() -> text`\n\nreturns the erc55 checksum formatted ethereum address for this public key.\n\n\n#### `publickey.to_canonical_address() -> bytes`\n\nreturns the 20-byte representation of the ethereum address for this public key.\n\n\n### `keyapi.privatekey(private_key_bytes)`\n\nthe `privatekey` class takes a single argument which must be a bytes string with length 32.\n\nthe following methods and properties are available\n\n\n#### `privatekey.public_key`\n\nthis *property* holds the `publickey` instance coresponding to this private key.\n\n\n#### `privatekey.sign_msg(message) -> signature`\n\nthis method returns a signature for the given `message` in the form of a\n`signature` instance\n\n* `message` **must** be a byte string.\n\n\n#### `privatekey.sign_msg_hash(message_hash) -> signature`\n\nsame as `privatekey.sign` except that `message_hash` should be the keccak\nhash of the `message`.\n\n\n### `keyapi.signature(signature_bytes=none, vrs=none)`\n\nthe `signature` class can be instantiated in one of two ways.\n\n* `signature_bytes`: a bytes string with length 65.\n* `vrs`: a 3-tuple composed of the integers `v`, `r`, and `s`.\n\n> note: if using the `signature_bytes` to instantiate, the byte string should be encoded as `r_bytes | s_bytes | v_bytes` where `|` represents concatenation.  `r_bytes` and `s_bytes` should be 32 bytes in length.  `v_bytes` should be a single byte `\\x00` or `\\x01`.\n\nsignatures are expected to use `1` or `0` for their `v` value.\n\nthe following methods and properties are available\n\n\n#### `signature.v`\n\nthis property returns the `v` value from the signature as an integer.\n\n\n#### `signature.r`\n\nthis property returns the `r` value from the signature as an integer.\n\n\n#### `signature.s`\n\nthis property returns the `s` value from the signature as an integer.\n\n\n#### `signature.vrs`\n\nthis property returns a 3-tuple of `(v, r, s)`.\n\n\n#### `signature.verify_msg(message, public_key) -> bool`\n\nthis method returns `true` or `false` based on whether the signature is a valid\nfor the given public key.\n\n* `message`: **must** be a byte string.\n* `public_key`: **must** be an instance of `publickey`\n\n\n#### `signature.verify_msg_hash(message_hash, public_key) -> bool`\n\nsame as `signature.verify_msg` except that `message_hash` should be the keccak\nhash of the `message`.\n\n\n#### `signature.recover_public_key_from_msg(message) -> publickey`\n\nthis method returns a `publickey` instance recovered from the signature.\n\n* `message`: **must** be a byte string.\n\n\n#### `signature.recover_public_key_from_msg_hash(message_hash) -> publickey`\n\nsame as `signature.recover_public_key_from_msg` except that `message_hash`\nshould be the keccak hash of the `message`.\n\n\n### exceptions\n\n#### `eth_api.exceptions.validationerror`\n\nthis error is raised during instantaition of any of the `publickey`,\n`privatekey` or `signature` classes if their constructor parameters are\ninvalid.\n\n\n#### `eth_api.exceptions.badsignature`\n\nthis error is raised from any of the `recover` or `verify` methods involving\nsignatures if the signature is invalid.\n\n\n",
  "docs_url": null,
  "keywords": "ethereum",
  "license": "mit",
  "name": "eth-keys",
  "package_url": "https://pypi.org/project/eth-keys/",
  "project_url": "https://pypi.org/project/eth-keys/",
  "project_urls": {
    "Homepage": "https://github.com/ethereum/eth-keys"
  },
  "release_url": "https://pypi.org/project/eth-keys/0.4.0/",
  "requires_dist": [
    "eth-utils (<3.0.0,>=2.0.0)",
    "eth-typing (<4,>=3.0.0)",
    "coincurve (<16.0.0,>=7.0.0) ; extra == 'coincurve'",
    "tox (==3.20.0) ; extra == 'dev'",
    "bumpversion (==0.5.3) ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "eth-utils (<3.0.0,>=2.0.0) ; extra == 'dev'",
    "eth-typing (<4,>=3.0.0) ; extra == 'dev'",
    "flake8 (==3.0.4) ; extra == 'dev'",
    "mypy (==0.782) ; extra == 'dev'",
    "asn1tools (<0.147,>=0.146.2) ; extra == 'dev'",
    "factory-boy (<3.1,>=3.0.1) ; extra == 'dev'",
    "pyasn1 (<0.5,>=0.4.5) ; extra == 'dev'",
    "pytest (==6.2.5) ; extra == 'dev'",
    "hypothesis (<6.0.0,>=5.10.3) ; extra == 'dev'",
    "eth-hash[pysha3] ; (implementation_name == \"cpython\") and extra == 'dev'",
    "eth-hash[pycryptodome] ; (implementation_name == \"pypy\") and extra == 'dev'",
    "eth-utils (<3.0.0,>=2.0.0) ; extra == 'eth-keys'",
    "eth-typing (<4,>=3.0.0) ; extra == 'eth-keys'",
    "flake8 (==3.0.4) ; extra == 'lint'",
    "mypy (==0.782) ; extra == 'lint'",
    "asn1tools (<0.147,>=0.146.2) ; extra == 'test'",
    "factory-boy (<3.1,>=3.0.1) ; extra == 'test'",
    "pyasn1 (<0.5,>=0.4.5) ; extra == 'test'",
    "pytest (==6.2.5) ; extra == 'test'",
    "hypothesis (<6.0.0,>=5.10.3) ; extra == 'test'",
    "eth-hash[pysha3] ; (implementation_name == \"cpython\") and extra == 'test'",
    "eth-hash[pycryptodome] ; (implementation_name == \"pypy\") and extra == 'test'"
  ],
  "requires_python": "",
  "summary": "common api for ethereum key operations.",
  "version": "0.4.0",
  "releases": [],
  "developers": [
    "piper_merriam",
    "pipermerriam@gmail.com"
  ],
  "kwds": "eth_keys pip pypi keyapi tests",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_eth_keys",
  "homepage": "https://github.com/ethereum/eth-keys",
  "release_count": 17,
  "dependency_ids": [
    "pypi_asn1tools",
    "pypi_bumpversion",
    "pypi_coincurve",
    "pypi_eth_hash",
    "pypi_eth_typing",
    "pypi_eth_utils",
    "pypi_factory_boy",
    "pypi_flake8",
    "pypi_hypothesis",
    "pypi_mypy",
    "pypi_pyasn1",
    "pypi_pytest",
    "pypi_tox",
    "pypi_twine"
  ]
}