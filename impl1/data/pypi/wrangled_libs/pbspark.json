{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: database"
  ],
  "description": "# pbspark\n\nthis package provides a way to convert protobuf messages into pyspark dataframes and vice versa using pyspark `udf`s.\n\n## installation\n\nto install:\n\n```bash\npip install pbspark\n```\n\n## usage\n\nsuppose we have a pyspark dataframe which contains a column `value` which has protobuf encoded messages of our `simplemessage`:\n\n```protobuf\nsyntax = \"proto3\";\n\npackage example;\n\nmessage simplemessage {\n  string name = 1;\n  int64 quantity = 2;\n  float measure = 3;\n}\n```\n\n### basic conversion functions\n\nthere are two functions for operating on columns, `to_protobuf` and `from_protobuf`. these operations convert to/from an encoded protobuf column to a column of a struct representing the inferred message structure. `messageconverter` instances (discussed below) can optionally be passed to these functions.\n\n```python\nfrom pyspark.sql.session import sparksession\nfrom example.example_pb2 import simplemessage\nfrom pbspark import from_protobuf\nfrom pbspark import to_protobuf\n\nspark = sparksession.builder.getorcreate()\n\nexample = simplemessage(name=\"hello\", quantity=5, measure=12.3)\ndata = [{\"value\": example.serializetostring()}]\ndf_encoded = spark.createdataframe(data)\n\ndf_decoded = df_encoded.select(from_protobuf(df_encoded.value, simplemessage).alias(\"value\"))\ndf_expanded = df_decoded.select(\"value.*\")\ndf_expanded.show()\n\n# +-----+--------+-------+\n# | name|quantity|measure|\n# +-----+--------+-------+\n# |hello|       5|   12.3|\n# +-----+--------+-------+\n\ndf_reencoded = df_decoded.select(to_protobuf(df_decoded.value, simplemessage).alias(\"value\"))\n```\n\nthere are two helper functions, `df_to_protobuf` and `df_from_protobuf` for use on dataframes. they have a kwarg `expanded`, which will also take care of expanding/contracting the data between the single `value` column used in these examples and a dataframe which contains a column for each message field. `messageconverter` instances (discussed below) can optionally be passed to these functions.\n\n```python\nfrom pyspark.sql.session import sparksession\nfrom example.example_pb2 import simplemessage\nfrom pbspark import df_from_protobuf\nfrom pbspark import df_to_protobuf\n\nspark = sparksession.builder.getorcreate()\n\nexample = simplemessage(name=\"hello\", quantity=5, measure=12.3)\ndata = [{\"value\": example.serializetostring()}]\ndf_encoded = spark.createdataframe(data)\n\n# expanded=true will perform a `.select(\"value.*\")` after converting,\n# resulting in each protobuf field having its own column\ndf_expanded = df_from_protobuf(df_encoded, simplemessage, expanded=true)\ndf_expanded.show()\n\n# +-----+--------+-------+\n# | name|quantity|measure|\n# +-----+--------+-------+\n# |hello|       5|   12.3|\n# +-----+--------+-------+\n\n# expanded=true will first pack data using `struct([df[c] for c in df.columns])`,\n# use this if the passed dataframe is already expanded\ndf_reencoded = df_to_protobuf(df_expanded, simplemessage, expanded=true)\n```\n\n### column conversion using the `messageconverter`\n\nthe four helper functions above are also available as methods on the `messageconverter` class. using an instance of `messageconverter` we can decode the column of encoded messages into a column of spark `structtype` and then expand the fields.\n\n```python\nfrom pyspark.sql.session import sparksession\nfrom pbspark import messageconverter\nfrom example.example_pb2 import simplemessage\n\nspark = sparksession.builder.getorcreate()\n\nexample = simplemessage(name=\"hello\", quantity=5, measure=12.3)\ndata = [{\"value\": example.serializetostring()}]\ndf_encoded = spark.createdataframe(data)\n\nmc = messageconverter()\ndf_decoded = df_encoded.select(mc.from_protobuf(df_encoded.value, simplemessage).alias(\"value\"))\ndf_expanded = df_decoded.select(\"value.*\")\ndf_expanded.show()\n\n# +-----+--------+-------+\n# | name|quantity|measure|\n# +-----+--------+-------+\n# |hello|       5|   12.3|\n# +-----+--------+-------+\n\ndf_expanded.schema\n# structtype(list(structfield(name,stringtype,true),structfield(quantity,integertype,true),structfield(measure,floattype,true))\n```\n\nwe can also re-encode them into protobuf.\n\n```python\ndf_reencoded = df_decoded.select(mc.to_protobuf(df_decoded.value, simplemessage).alias(\"value\"))\n```\n\nfor expanded data, we can also encode after packing into a struct column:\n\n```python\nfrom pyspark.sql.functions import struct\n\ndf_unexpanded = df_expanded.select(\n    struct([df_expanded[c] for c in df_expanded.columns]).alias(\"value\")\n)\ndf_reencoded = df_unexpanded.select(\n    mc.to_protobuf(df_unexpanded.value, simplemessage).alias(\"value\")\n)\n```\n\n### conversion details\n\ninternally, `pbspark` uses protobuf's `messagetodict`, which deserializes everything into json compatible objects by default. the exceptions are\n* protobuf's bytes type, which `messagetodict` would decode to a base64-encoded string; `pbspark` will decode any bytes fields directly to a spark `binarytype`.\n* protobuf's well known type, timestamp type, which `messagetodict` would decode to a string; `pbspark` will decode any timestamp messages directly to a spark `timestamptype` (via python datetime objects).\n* protobuf's int64 types, which `messagetodict` would decode to a string for compatibility reasons; `pbspark` will decode these to `longtype`.\n\n### custom conversion of message types\n\ncustom serde is also supported. suppose we use our `nestedmessage` from the repository's example and we want to serialize the key and value together into a single string.\n\n```protobuf\nmessage nestedmessage {\n  string key = 1;\n  string value = 2;\n}\n```\n\nwe can create and register a custom serializer with the `messageconverter`.\n\n```python\nfrom pbspark import messageconverter\nfrom example.example_pb2 import examplemessage\nfrom example.example_pb2 import nestedmessage\nfrom pyspark.sql.types import stringtype\n\nmc = messageconverter()\n\n# register a custom serializer\n# this will serialize the nestedmessages into a string rather than a\n# struct with `key` and `value` fields\nencode_nested = lambda message:  message.key + \":\" + message.value\n\nmc.register_serializer(nestedmessage, encode_nested, stringtype())\n\n# ...\n\nfrom pyspark.sql.session import sparksession\nfrom pyspark import sparkcontext\nfrom pyspark.serializers import cloudpickleserializer\n\nsc = sparkcontext(serializer=cloudpickleserializer())\nspark = sparksession(sc).builder.getorcreate()\n\nmessage = examplemessage(nested=nestedmessage(key=\"hello\", value=\"world\"))\ndata = [{\"value\": message.serializetostring()}]\ndf_encoded = spark.createdataframe(data)\n\ndf_decoded = df_encoded.select(mc.from_protobuf(df_encoded.value, examplemessage).alias(\"value\"))\n# rather than a struct the value of `nested` is a string\ndf_decoded.select(\"value.nested\").show()\n\n# +-----------+\n# |     nested|\n# +-----------+\n# |hello:world|\n# +-----------+\n```\n\n### how to write conversion functions\n\nmore generally, custom serde functions should be written in the following format.\n\n```python\n# encoding takes a message instance and returns the result\n# of the custom transformation.\ndef encode_nested(message: nestedmessage) -> str:\n    return message.key + \":\" + message.value\n\n# decoding takes the encoded value, a message instance, and path string\n# and populates the fields of the message instance. it returns `none`.\n# the path str is used in the protobuf parser to log parse error info.\n# note that the first argument type should match the return type of the\n# encoder if using both.\ndef decode_nested(s: str, message: nestedmessage, path: str):\n    key, value = s.split(\":\")\n    message.key = key\n    message.value = value\n```\n\n### avoiding picklingerrors\n\na seemingly common issue with protobuf and distributed processing is when a `picklingerror` is encountered when transmitting (pickling) protobuf message types from a main process to a fork. to avoid this, you need to ensure that the fully qualified module name in your protoc-generated python file is the same as the module path from which the message type is imported. in other words, for the example here, the descriptor module passed to the builder is `example.example_pb2`\n\n```python\n# from example/example_pb2.py\n_builder.buildtopdescriptorsandmessages(descriptor, \"example.example_pb2\", globals())\n                                                     ^^^^^^^^^^^^^^^^^^^\n```\n\nand to import the message type we would call the same module path:\n\n```python\nfrom example.example_pb2 import examplemessage\n     ^^^^^^^^^^^^^^^^^^^\n```\n\nnote that the import module is the same as the one passed to the builder from the protoc-generated python. if these do not match, then you will encounter a `picklingerror`. from the pickle documentation: *pickle can save and restore class instances transparently, however the class definition must be importable and live in the same module as when the object was stored.*\n\nto ensure that the module path is correct, you should run `protoc` from the relative root path of your proto files. for example, in this project, in the `makefile` under the `gen` command, we call `protoc` from the project root rather than from within the `example` directory.\n\n```makefile\nexport proto_path=.\n\ngen:\n\tpoetry run protoc -i $$proto_path --python_out=$$proto_path --mypy_out=$$proto_path --proto_path=$$proto_path $$proto_path/example/*.proto\n```\n\n### known issues\n\n`recursionerror` when using self-referencing protobuf messages. spark schemas do not allow for arbitrary depth, so protobuf messages which are circular- or self-referencing will result in infinite recursion errors when inferring the schema. if you have message structures like this you should resort to creating custom conversion functions, which forcibly limit the structural depth when converting these messages.\n\n## development\n\nensure that [asdf](https://asdf-vm.com/) is installed, then run `make setup`.\n\n* to format code `make fmt`\n* to test code `make test`\n* to run protoc `make gen`\n",
  "docs_url": null,
  "keywords": "spark,protobuf,pyspark",
  "license": "mit",
  "name": "pbspark",
  "package_url": "https://pypi.org/project/pbspark/",
  "project_url": "https://pypi.org/project/pbspark/",
  "project_urls": {
    "Documentation": "https://github.com/crflynn/pbspark",
    "Homepage": "https://github.com/crflynn/pbspark",
    "Repository": "https://github.com/crflynn/pbspark"
  },
  "release_url": "https://pypi.org/project/pbspark/0.9.0/",
  "requires_dist": [
    "pyspark (>=3.1.1)",
    "protobuf (>=3.20.0)"
  ],
  "requires_python": ">=3.7,<4.0",
  "summary": "convert between protobuf messages and pyspark dataframes",
  "version": "0.9.0",
  "releases": [],
  "developers": [
    "crf204@gmail.com",
    "flynn"
  ],
  "kwds": "df_to_protobuf df_from_protobuf from_protobuf to_protobuf pyspark",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pbspark",
  "homepage": "https://github.com/crflynn/pbspark",
  "release_count": 11,
  "dependency_ids": [
    "pypi_protobuf",
    "pypi_pyspark"
  ]
}