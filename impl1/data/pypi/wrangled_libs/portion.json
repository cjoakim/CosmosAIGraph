{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: information technology",
    "intended audience :: science/research",
    "license :: osi approved :: gnu lesser general public license v3 (lgplv3)",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering :: mathematics"
  ],
  "description": "# portion - data structure and operations for intervals\n\n[![tests](https://github.com/alexandredecan/portion/actions/workflows/test.yaml/badge.svg?branch=master)](https://github.com/alexandredecan/portion/actions/workflows/test.yaml)\n[![coverage status](https://coveralls.io/repos/github/alexandredecan/portion/badge.svg?branch=master)](https://coveralls.io/github/alexandredecan/portion?branch=master)\n[![license](https://badgen.net/pypi/license/portion)](https://github.com/alexandredecan/portion/blob/master/license.txt)\n[![pypi](https://badgen.net/pypi/v/portion)](https://pypi.org/project/portion)\n[![commits](https://badgen.net/github/last-commit/alexandredecan/portion)](https://github.com/alexandredecan/portion/commits/)\n\n\nthe `portion` library provides data structure and operations for intervals in python 3.7+.\n\n - support intervals of any (comparable) objects.\n - closed or open, finite or (semi-)infinite intervals.\n - interval sets (union of atomic intervals) are supported.\n - automatic simplification of intervals.\n - support comparison, transformation, intersection, union, complement, difference and containment.\n - provide test for emptiness, atomicity, overlap and adjacency.\n - discrete iterations on the values of an interval.\n - dict-like structure to map intervals to data.\n - import and export intervals to strings and to python built-in data types.\n - heavily tested with high code coverage.\n\n\n## table of contents\n\n  * [installation](#installation)\n  * [documentation & usage](#documentation--usage)\n      * [interval creation](#interval-creation)\n      * [interval bounds & attributes](#interval-bounds--attributes)\n      * [interval operations](#interval-operations)\n      * [comparison operators](#comparison-operators)\n      * [interval transformation](#interval-transformation)\n      * [discrete iteration](#discrete-iteration)\n      * [map intervals to data](#map-intervals-to-data)\n      * [import & export intervals to strings](#import--export-intervals-to-strings)\n      * [import & export intervals to python built-in data types](#import--export-intervals-to-python-built-in-data-types)\n      * [specialize & customize intervals](#specialize--customize-intervals)\n  * [changelog](#changelog)\n  * [contributions](#contributions)\n  * [license](#license)\n\n\n## installation\n\nyou can use `pip` to install it, as usual: `pip install portion`. this will install the latest available version from [pypi](https://pypi.org/project/portion).\npre-releases are available from the *master* branch on [github](https://github.com/alexandredecan/portion)\nand can be installed with `pip install git+https://github.com/alexandredecan/portion`.\nnote that `portion` is also available on [conda-forge](https://anaconda.org/conda-forge/portion).\n\nyou can install `portion` and its development environment using `pip install -e .[test]` at the root of this repository. this automatically installs [pytest](https://docs.pytest.org/en/latest/) (for the test suites) and [black](https://black.readthedocs.io/en/stable/) (for code formatting).\n\n\n## documentation & usage\n\n### interval creation\n\nassuming this library is imported using `import portion as p`, intervals can be easily\ncreated using one of the following helpers:\n\n```python\n>>> p.open(1, 2)\n(1,2)\n>>> p.closed(1, 2)\n[1,2]\n>>> p.openclosed(1, 2)\n(1,2]\n>>> p.closedopen(1, 2)\n[1,2)\n>>> p.singleton(1)\n[1]\n>>> p.empty()\n()\n\n```\n\nthe bounds of an interval can be any arbitrary values, as long as they are comparable:\n\n```python\n>>> p.closed(1.2, 2.4)\n[1.2,2.4]\n>>> p.closed('a', 'z')\n['a','z']\n>>> import datetime\n>>> p.closed(datetime.date(2011, 3, 15), datetime.date(2013, 10, 10))\n[datetime.date(2011, 3, 15),datetime.date(2013, 10, 10)]\n\n```\n\n\ninfinite and semi-infinite intervals are supported using `p.inf` and `-p.inf` as upper or lower bounds.\nthese two objects support comparison with any other object.\nwhen infinities are used as a lower or upper bound, the corresponding boundary is automatically converted to an open one.\n\n```python\n>>> p.inf > 'a', p.inf > 0, p.inf > true\n(true, true, true)\n>>> p.openclosed(-p.inf, 0)\n(-inf,0]\n>>> p.closed(-p.inf, p.inf)  # automatically converted to an open interval\n(-inf,+inf)\n\n```\n\nintervals created with this library are `interval` instances.\nan `interval` instance is a disjunction of atomic intervals each representing a single interval (e.g. `[1,2]`).\nintervals can be iterated to access the underlying atomic intervals, sorted by their lower and upper bounds.\n\n```python\n>>> list(p.open(10, 11) | p.closed(0, 1) | p.closed(20, 21))\n[[0,1], (10,11), [20,21]]\n>>> list(p.empty())\n[]\n\n```\n\nnested (sorted) intervals can also be retrieved with a position or a slice:\n\n```python\n>>> (p.open(10, 11) | p.closed(0, 1) | p.closed(20, 21))[0]\n[0,1]\n>>> (p.open(10, 11) | p.closed(0, 1) | p.closed(20, 21))[-2]\n(10,11)\n>>> (p.open(10, 11) | p.closed(0, 1) | p.closed(20, 21))[:2]\n[0,1] | (10,11)\n\n```\n\nfor convenience, intervals are automatically simplified:\n\n```python\n>>> p.closed(0, 2) | p.closed(2, 4)\n[0,4]\n>>> p.closed(1, 2) | p.closed(3, 4) | p.closed(2, 3)\n[1,4]\n>>> p.empty() | p.closed(0, 1)\n[0,1]\n>>> p.closed(1, 2) | p.closed(2, 3) | p.closed(4, 5)\n[1,3] | [4,5]\n\n```\n\nnote that, by default, simplification of discrete intervals is **not** supported by `portion` (but it can be simulated though, see [#24](https://github.com/alexandredecan/portion/issues/24#issuecomment-604456362)).\nfor example, combining `[0,1]` with `[2,3]` will **not** result in `[0,3]` even if there is\nno integer between `1` and `2`.\nrefer to [specialize & customize intervals](#specialize--customize-intervals) to see how to create and use specialized discrete intervals.\n\n\n\n[&uparrow; back to top](#table-of-contents)\n### interval bounds & attributes\n\n\nan `interval` defines the following properties:\n\n - `i.empty` is `true` if and only if the interval is empty.\n   ```python\n   >>> p.closed(0, 1).empty\n   false\n   >>> p.closed(0, 0).empty\n   false\n   >>> p.openclosed(0, 0).empty\n   true\n   >>> p.empty().empty\n   true\n\n   ```\n\n - `i.atomic` is `true` if and only if the interval is empty or is a disjunction of a single interval.\n   ```python\n   >>> p.empty().atomic\n   true\n   >>> p.closed(0, 2).atomic\n   true\n   >>> (p.closed(0, 1) | p.closed(1, 2)).atomic\n   true\n   >>> (p.closed(0, 1) | p.closed(2, 3)).atomic\n   false\n\n   ```\n\n - `i.enclosure` refers to the smallest atomic interval that includes the current one.\n   ```python\n   >>> (p.closed(0, 1) | p.open(2, 3)).enclosure\n   [0,3)\n\n   ```\n\nthe left and right boundaries, and the lower and upper bounds of an interval can be respectively accessed\nwith its `left`, `right`, `lower` and `upper` attributes.\nthe `left` and `right` bounds are either `p.closed` or `p.open`.\nby definition, `p.closed == ~p.open` and vice-versa.\n\n```python\n>> p.closed, p.open\nclosed, open\n>>> x = p.closedopen(0, 1)\n>>> x.left, x.lower, x.upper, x.right\n(closed, 0, 1, open)\n\n```\n\nby convention, empty intervals resolve to `(p.inf, -p.inf)`:\n\n```python\n>>> i = p.empty()\n>>> i.left, i.lower, i.upper, i.right\n(open, +inf, -inf, open)\n\n```\n\n\nif the interval is not atomic, then `left` and `lower` refer to the lower bound of its enclosure,\nwhile `right` and `upper` refer to the upper bound of its enclosure:\n\n```python\n>>> x = p.open(0, 1) | p.closed(3, 4)\n>>> x.left, x.lower, x.upper, x.right\n(open, 0, 4, closed)\n\n```\n\none can easily check for some interval properties based on the bounds of an interval:\n\n```python\n>>> x = p.openclosed(-p.inf, 0)\n>>> # check that interval is left/right closed\n>>> x.left == p.closed, x.right == p.closed\n(false, true)\n>>> # check that interval is left/right bounded\n>>> x.lower == -p.inf, x.upper == p.inf\n(true, false)\n>>> # check for singleton\n>>> x.lower == x.upper\nfalse\n\n```\n\n\n\n[&uparrow; back to top](#table-of-contents)\n### interval operations\n\n`interval` instances support the following operations:\n\n - `i.intersection(other)` and `i & other` return the intersection of two intervals.\n   ```python\n   >>> p.closed(0, 2) & p.closed(1, 3)\n   [1,2]\n   >>> p.closed(0, 4) & p.open(2, 3)\n   (2,3)\n   >>> p.closed(0, 2) & p.closed(2, 3)\n   [2]\n   >>> p.closed(0, 2) & p.closed(3, 4)\n   ()\n\n   ```\n\n - `i.union(other)` and `i | other` return the union of two intervals.\n   ```python\n   >>> p.closed(0, 1) | p.closed(1, 2)\n   [0,2]\n   >>> p.closed(0, 1) | p.closed(2, 3)\n   [0,1] | [2,3]\n\n   ```\n\n - `i.complement(other)` and `~i` return the complement of the interval.\n   ```python\n   >>> ~p.closed(0, 1)\n   (-inf,0) | (1,+inf)\n   >>> ~(p.open(-p.inf, 0) | p.open(1, p.inf))\n   [0,1]\n   >>> ~p.open(-p.inf, p.inf)\n   ()\n\n   ```\n\n - `i.difference(other)` and `i - other` return the difference between `i` and `other`.\n   ```python\n   >>> p.closed(0,2) - p.closed(1,2)\n   [0,1)\n   >>> p.closed(0, 4) - p.closed(1, 2)\n   [0,1) | (2,4]\n\n   ```\n\n - `i.contains(other)` and `other in i` hold if given item is contained in the interval.\n it supports intervals and arbitrary comparable values.\n   ```python\n   >>> 2 in p.closed(0, 2)\n   true\n   >>> 2 in p.open(0, 2)\n   false\n   >>> p.open(0, 1) in p.closed(0, 2)\n   true\n\n   ```\n\n - `i.adjacent(other)` tests if the two intervals are adjacent, i.e., if they do not overlap and their union form a single atomic interval.\n while this definition corresponds to the usual notion of adjacency for atomic\n intervals, it has stronger requirements for non-atomic ones since it requires\n all underlying atomic intervals to be adjacent (i.e. that one\n interval fills the gaps between the atomic intervals of the other one).\n   ```python\n   >>> p.closed(0, 1).adjacent(p.openclosed(1, 2))\n   true\n   >>> p.closed(0, 1).adjacent(p.closed(1, 2))\n   false\n   >>> (p.closed(0, 1) | p.closed(2, 3)).adjacent(p.open(1, 2) | p.open(3, 4))\n   true\n   >>> (p.closed(0, 1) | p.closed(2, 3)).adjacent(p.open(3, 4))\n   false\n   >>> p.closed(0, 1).adjacent(p.open(1, 2) | p.open(3, 4))\n   false\n\n   ```\n\n - `i.overlaps(other)` tests if there is an overlap between two intervals.\n   ```python\n   >>> p.closed(1, 2).overlaps(p.closed(2, 3))\n   true\n   >>> p.closed(1, 2).overlaps(p.open(2, 3))\n   false\n\n   ```\n\nfinally, intervals are hashable as long as their bounds are hashable (and we have defined a hash value for `p.inf` and `-p.inf`).\n\n\n[&uparrow; back to top](#table-of-contents)\n### comparison operators\n\nequality between intervals can be checked with the classical `==` operator:\n\n```python\n>>> p.closed(0, 2) == p.closed(0, 1) | p.closed(1, 2)\ntrue\n>>> p.closed(0, 2) == p.open(0, 2)\nfalse\n\n```\n\nmoreover, intervals are comparable using `>`, `>=`, `<` or `<=`.\nthese comparison operators have a different behaviour than the usual ones.\nfor instance, `a < b` holds if all values in `a` are lower than the minimal value of `b` (i.e., `a` is\nentirely on the left of the lower bound of `b`).\n\n```python\n>>> p.closed(0, 1) < p.closed(2, 3)\ntrue\n>>> p.closed(0, 1) < p.closed(1, 2)\nfalse\n\n```\n\nsimilarly, `a <= b` if all values in `a` are lower than the maximal value of `b` (i.e., `a` is\nentirely on the left of the upper bound of `b`).\n\n```python\n>>> p.closed(0, 1) <= p.closed(2, 3)\ntrue\n>>> p.closed(0, 2) <= p.closed(1, 3)\ntrue\n>>> p.closed(0, 3) <= p.closed(1, 2)\nfalse\n\n```\n\nif an interval needs to be compared against a single value, convert the value to a singleton interval first:\n\n```python\n>>> p.singleton(0) < p.closed(0, 10)\nfalse\n>>> p.singleton(0) <= p.closed(0, 10)\ntrue\n>>> p.singleton(5) <= p.closed(0, 10)\ntrue\n>>> p.closed(0, 1) < p.singleton(2)\ntrue\n\n```\n\nnote that all these semantics differ from classical comparison operators.\nas a consequence, the empty interval is never `<`, `<=`, `>` nor `>=` than any other interval, and\nno interval is `<`, `>`, `<=` or `>=` when compared to the empty interval.\n\n```python\n>>> e = p.empty()\n>>> e < e or e > e or e <= e or e >= e\nfalse\n>>> i = p.closed(0, 1)\n>>> e < i or e <= i or e > i or e >= i\nfalse\n\n```\n\nmoreover, some non-empty intervals are also not comparable in the classical sense, as illustrated hereafter:\n\n```python\n>>> a, b = p.closed(0, 4), p.closed(1, 2)\n>>> a < b or a > b\nfalse\n>>> a <= b or a >= b\nfalse\n>>> b <= a and b >= a\ntrue\n\n```\n\nas a general rule, if `a < b` holds, then `a <= b`, `b > a`, `b >= a`,\n`not (a > b)`, `not (b < a)`, `not (a >= b)`, and `not (b <= a)` hold.\n\n\n\n[&uparrow; back to top](#table-of-contents)\n### interval transformation\n\nintervals are immutable but provide a `replace` method to create a new interval based on the\ncurrent one. this method accepts four optional parameters `left`, `lower`, `upper`, and `right`:\n\n```python\n>>> i = p.closed(0, 2)\n>>> i.replace(p.open, -1, 3, p.closed)\n(-1,3]\n>>> i.replace(lower=1, right=p.open)\n[1,2)\n\n```\n\nfunctions can be passed instead of values. if a function is passed, it is called with the current corresponding\nvalue.\n\n```python\n>>> p.closed(0, 2).replace(upper=lambda x: 2 * x)\n[0,4]\n\n```\n\nthe provided function won't be called on infinities, unless `ignore_inf` is set to `false`.\n\n```python\n>>> i = p.closedopen(0, p.inf)\n>>> i.replace(upper=lambda x: 10)  # no change, infinity is ignored\n[0,+inf)\n>>> i.replace(upper=lambda x: 10, ignore_inf=false)  # infinity is not ignored\n[0,10)\n\n```\n\nwhen `replace` is applied on an interval that is not atomic, it is extended and/or restricted such that\nits enclosure satisfies the new bounds.\n\n```python\n>>> i = p.openclosed(0, 1) | p.closed(5, 10)\n>>> i.replace(p.closed, -1, 8, p.open)\n[-1,1] | [5,8)\n>>> i.replace(lower=4)\n(4,10]\n\n```\n\nto apply arbitrary transformations on the underlying atomic intervals, intervals expose an `apply` method that acts like `map`.\nthis method accepts a function that will be applied on each of the underlying atomic intervals to perform the desired transformation.\nthe provided function is expected to return either an `interval`, or a 4-uple `(left, lower, upper, right)`.\n\n```python\n>>> i = p.closed(2, 3) | p.open(4, 5)\n>>> # increment bound values\n>>> i.apply(lambda x: (x.left, x.lower + 1, x.upper + 1, x.right))\n[3,4] | (5,6)\n>>> # invert bounds\n>>> i.apply(lambda x: (~x.left, x.lower, x.upper, ~x.right))\n(2,3) | [4,5]\n\n```\n\nthe `apply` method is very powerful when used in combination with `replace`.\nbecause the latter allows functions to be passed as parameters and ignores infinities by default, it can be\nconveniently used to transform (disjunction of) intervals in presence of infinities.\n\n```python\n>>> i = p.openclosed(-p.inf, 0) | p.closed(3, 4) | p.closedopen(8, p.inf)\n>>> # increment bound values\n>>> i.apply(lambda x: x.replace(upper=lambda v: v + 1))\n(-inf,1] | [3,5] | [8,+inf)\n>>> # intervals are still automatically simplified\n>>> i.apply(lambda x: x.replace(lower=lambda v: v * 2))\n(-inf,0] | [16,+inf)\n>>> # invert bounds\n>>> i.apply(lambda x: x.replace(left=lambda v: ~v, right=lambda v: ~v))\n(-inf,0) | (3,4) | (8,+inf)\n>>> # replace infinities with -10 and 10\n>>> conv = lambda v: -10 if v == -p.inf else (10 if v == p.inf else v)\n>>> i.apply(lambda x: x.replace(lower=conv, upper=conv, ignore_inf=false))\n(-10,0] | [3,4] | [8,10)\n\n```\n\n\n[&uparrow; back to top](#table-of-contents)\n### discrete iteration\n\nthe `iterate` function takes an interval, and returns a generator to iterate over\nthe values of an interval. obviously, as intervals are continuous, it is required to specify the\n `step` between consecutive values. the iteration then starts from the lower bound and ends on the upper one. only values contained by the interval are returned this way.\n\n```python\n>>> list(p.iterate(p.closed(0, 3), step=1))\n[0, 1, 2, 3]\n>>> list(p.iterate(p.closed(0, 3), step=2))\n[0, 2]\n>>> list(p.iterate(p.open(0, 3), step=2))\n[2]\n\n```\n\nwhen an interval is not atomic, `iterate` consecutively iterates on all underlying atomic\nintervals, starting from each lower bound and ending on each upper one:\n\n```python\n>>> list(p.iterate(p.singleton(0) | p.singleton(3) | p.singleton(5), step=2))  # won't be [0]\n[0, 3, 5]\n>>> list(p.iterate(p.closed(0, 2) | p.closed(4, 6), step=3))  # won't be [0, 6]\n[0, 4]\n\n```\n\nby default, the iteration always starts on the lower bound of each underlying atomic interval.\nthe `base` parameter can be used to change this behaviour, by specifying how the initial value to start\nthe iteration from must be computed. this parameter accepts a callable that is called with the lower\nbound of each underlying atomic interval, and that returns the initial value to start the iteration from.\nit can be helpful to deal with (semi-)infinite intervals, or to *align* the generated values of the iterator:\n\n```python\n>>> # align on integers\n>>> list(p.iterate(p.closed(0.3, 4.9), step=1, base=int))\n[1, 2, 3, 4]\n>>> # restrict values of a (semi-)infinite interval\n>>> list(p.iterate(p.openclosed(-p.inf, 2), step=1, base=lambda x: max(0, x)))\n[0, 1, 2]\n\n```\n\nthe `base` parameter can be used to change how `iterate` applies on unions of atomic interval, by\nspecifying a function that returns a single value, as illustrated next:\n\n```python\n>>> base = lambda x: 0\n>>> list(p.iterate(p.singleton(0) | p.singleton(3) | p.singleton(5), step=2, base=base))\n[0]\n>>> list(p.iterate(p.closed(0, 2) | p.closed(4, 6), step=3, base=base))\n[0, 6]\n\n```\n\nnotice that defining `base` such that it returns a single value can be extremely inefficient in\nterms of performance when the intervals are \"far apart\" each other (i.e., when the *gaps* between\natomic intervals are large).\n\nfinally, iteration can be performed in reverse order by specifying `reverse=true`.\n\n```python\n>>> list(p.iterate(p.closed(0, 3), step=-1, reverse=true))  # mind step=-1\n[3, 2, 1, 0]\n>>> list(p.iterate(p.closed(0, 3), step=-2, reverse=true))  # mind step=-2\n[3, 1]\n\n```\n\nagain, this library does not make any assumption about the objects being used in an interval, as long as they\nare comparable. however, it is not always possible to provide a meaningful value for `step` (e.g., what would\nbe the step between two consecutive characters?). in these cases, a callable can be passed instead of a value.\nthis callable will be called with the current value, and is expected to return the next possible value.\n\n```python\n>>> list(p.iterate(p.closed('a', 'd'), step=lambda d: chr(ord(d) + 1)))\n['a', 'b', 'c', 'd']\n>>> # since we reversed the order, we changed \"+\" to \"-\" in the lambda.\n>>> list(p.iterate(p.closed('a', 'd'), step=lambda d: chr(ord(d) - 1), reverse=true))\n['d', 'c', 'b', 'a']\n\n```\n\n\n\n[&uparrow; back to top](#table-of-contents)\n### map intervals to data\n\nthe library provides an `intervaldict` class, a `dict`-like data structure to store and query data\nalong with intervals. any value can be stored in such data structure as long as it supports\nequality.\n\n\n```python\n>>> d = p.intervaldict()\n>>> d[p.closed(0, 3)] = 'banana'\n>>> d[4] = 'apple'\n>>> d\n{[0,3]: 'banana', [4]: 'apple'}\n\n```\n\nwhen a value is defined for an interval that overlaps an existing one, it is automatically updated\nto take the new value into account:\n\n```python\n>>> d[p.closed(2, 4)] = 'orange'\n>>> d\n{[0,2): 'banana', [2,4]: 'orange'}\n\n```\n\nan `intervaldict` can be queried using single values or intervals. if a single value is used as a\nkey, its behaviour corresponds to the one of a classical `dict`:\n\n```python\n>>> d[2]\n'orange'\n>>> d[5]  # key does not exist\ntraceback (most recent call last):\n ...\nkeyerror: 5\n>>> d.get(5, default=0)\n0\n\n```\n\nwhen the key is an interval, a new `intervaldict` containing the values\nfor the specified key is returned:\n\n```python\n>>> d[~p.empty()]  # get all values, similar to d.copy()\n{[0,2): 'banana', [2,4]: 'orange'}\n>>> d[p.closed(1, 3)]\n{[1,2): 'banana', [2,3]: 'orange'}\n>>> d[p.closed(-2, 1)]\n{[0,1]: 'banana'}\n>>> d[p.closed(-2, -1)]\n{}\n\n```\n\nby using `.get`, a default value (defaulting to `none`) can be specified.\nthis value is used to \"fill the gaps\" if the queried interval is not completely\ncovered by the `intervaldict`:\n\n```python\n>>> d.get(p.closed(-2, 1), default='peach')\n{[-2,0): 'peach', [0,1]: 'banana'}\n>>> d.get(p.closed(-2, -1), default='peach')\n{[-2,-1]: 'peach'}\n>>> d.get(p.singleton(1), default='peach')  # key is covered, default is not used\n{[1]: 'banana'}\n\n```\n\nfor convenience, an `intervaldict` provides a way to look for specific data values.\nthe `.find` method always returns a (possibly empty) `interval` instance for which given\nvalue is defined:\n\n```python\n>>> d.find('banana')\n[0,2)\n>>> d.find('orange')\n[2,4]\n>>> d.find('carrot')\n()\n\n```\n\nthe active domain of an `intervaldict` can be retrieved with its `.domain` method.\nthis method always returns a single `interval` instance, where `.keys` returns a sorted view of disjoint intervals.\n\n```python\n>>> d.domain()\n[0,4]\n>>> list(d.keys())\n[[0,2), [2,4]]\n>>> list(d.values())\n['banana', 'orange']\n>>> list(d.items())\n[([0,2), 'banana'), ([2,4], 'orange')]\n\n```\n\nthe `.keys`, `.values` and `.items` methods return exactly one element for each stored value (i.e., if two intervals share a value, they are merged into a disjunction), as illustrated next.\nsee [#44](https://github.com/alexandredecan/portion/issues/44#issuecomment-710199687) to know how to obtained a sorted list of atomic intervals instead.\n\n```python\n>>> d = p.intervaldict()\n>>> d[p.closed(0, 1)] = d[p.closed(2, 3)] = 'peach'\n>>> list(d.items())\n[([0,1] | [2,3], 'peach')]\n\n```\n\n\ntwo `intervaldict` instances can be combined together using the `.combine` method.\nthis method returns a new `intervaldict` whose keys and values are taken from the two\nsource `intervaldict`. values corresponding to non-intersecting keys are simply copied,\nwhile values corresponding to intersecting keys are combined together using the provided\nfunction, as illustrated hereafter:\n\n```python\n>>> d1 = p.intervaldict({p.closed(0, 2): 'banana'})\n>>> d2 = p.intervaldict({p.closed(1, 3): 'orange'})\n>>> concat = lambda x, y: x + '/' + y\n>>> d1.combine(d2, how=concat)\n{[0,1): 'banana', [1,2]: 'banana/orange', (2,3]: 'orange'}\n\n```\n\nresulting keys always correspond to an outer join. other joins can be easily simulated\nby querying the resulting `intervaldict` as follows:\n\n```python\n>>> d = d1.combine(d2, how=concat)\n>>> d[d1.domain()]  # left join\n{[0,1): 'banana', [1,2]: 'banana/orange'}\n>>> d[d2.domain()]  # right join\n{[1,2]: 'banana/orange', (2,3]: 'orange'}\n>>> d[d1.domain() & d2.domain()]  # inner join\n{[1,2]: 'banana/orange'}\n\n```\n\nfinally, similarly to a `dict`, an `intervaldict` also supports `len`, `in` and `del`, and defines\n`.clear`, `.copy`, `.update`, `.pop`, `.popitem`, and `.setdefault`.\nfor convenience, one can export the content of an `intervaldict` to a classical python `dict` using\nthe `as_dict` method. this method accepts an optional `atomic` parameter (whose default is `false`). when set to `true`, the keys of the resulting `dict` instance are atomic intervals.\n\n\n[&uparrow; back to top](#table-of-contents)\n### import & export intervals to strings\n\nintervals can be exported to string, either using `repr` (as illustrated above) or with the `to_string` function.\n\n```python\n>>> p.to_string(p.closedopen(0, 1))\n'[0,1)'\n\n```\n\nthe way string representations are built can be easily parametrized using the various parameters supported by\n`to_string`:\n\n```python\n>>> params = {\n...   'disj': ' or ',\n...   'sep': ' - ',\n...   'left_closed': '<',\n...   'right_closed': '>',\n...   'left_open': '..',\n...   'right_open': '..',\n...   'pinf': '+oo',\n...   'ninf': '-oo',\n...   'conv': lambda v: '\"{}\"'.format(v),\n... }\n>>> x = p.openclosed(0, 1) | p.closed(2, p.inf)\n>>> p.to_string(x, **params)\n'..\"0\" - \"1\"> or <\"2\" - +oo..'\n\n```\n\nsimilarly, intervals can be created from a string using the `from_string` function.\na conversion function (`conv` parameter) has to be provided to convert a bound (as string) to a value.\n\n```python\n>>> p.from_string('[0, 1]', conv=int) == p.closed(0, 1)\ntrue\n>>> p.from_string('[1.2]', conv=float) == p.singleton(1.2)\ntrue\n>>> converter = lambda s: datetime.datetime.strptime(s, '%y/%m/%d')\n>>> p.from_string('[2011/03/15, 2013/10/10]', conv=converter)\n[datetime.datetime(2011, 3, 15, 0, 0),datetime.datetime(2013, 10, 10, 0, 0)]\n\n```\n\nsimilarly to `to_string`, function `from_string` can be parametrized to deal with more elaborated inputs.\nnotice that as `from_string` expects regular expression patterns, we need to escape some characters.\n\n```python\n>>> s = '..\"0\" - \"1\"> or <\"2\" - +oo..'\n>>> params = {\n...   'disj': ' or ',\n...   'sep': ' - ',\n...   'left_closed': '<',\n...   'right_closed': '>',\n...   'left_open': r'\\.\\.',  # from_string expects regular expression patterns\n...   'right_open': r'\\.\\.',  # from_string expects regular expression patterns\n...   'pinf': r'\\+oo',  # from_string expects regular expression patterns\n...   'ninf': '-oo',\n...   'conv': lambda v: int(v[1:-1]),\n... }\n>>> p.from_string(s, **params)\n(0,1] | [2,+inf)\n\n```\n\nwhen a bound contains a comma or has a representation that cannot be automatically parsed with `from_string`,\nthe `bound` parameter can be used to specify the regular expression that should be used to match its representation.\n\n```python\n>>> s = '[(0, 1), (2, 3)]'  # bounds are expected to be tuples\n>>> p.from_string(s, conv=eval, bound=r'\\(.+?\\)')\n[(0, 1),(2, 3)]\n\n```\n\n\n[&uparrow; back to top](#table-of-contents)\n### import & export intervals to python built-in data types\n\nintervals can also be exported to a list of 4-uples with `to_data`, e.g., to support json serialization.\n`p.closed` and `p.open` are represented by boolean values `true` (inclusive) and `false` (exclusive).\n\n```python\n>>> p.to_data(p.openclosed(0, 2))\n[(false, 0, 2, true)]\n\n```\n\nthe values used to represent positive and negative infinities can be specified with\n`pinf` and `ninf`. they default to `float('inf')` and `float('-inf')` respectively.\n\n```python\n>>> x = p.openclosed(0, 1) | p.closedopen(2, p.inf)\n>>> p.to_data(x)\n[(false, 0, 1, true), (true, 2, inf, false)]\n\n```\n\nthe function to convert bounds can be specified with the `conv` parameter.\n\n```python\n>>> x = p.closedopen(datetime.date(2011, 3, 15), datetime.date(2013, 10, 10))\n>>> p.to_data(x, conv=lambda v: (v.year, v.month, v.day))\n[(true, (2011, 3, 15), (2013, 10, 10), false)]\n\n```\n\nintervals can be imported from such a list of 4-tuples with `from_data`.\nthe same set of parameters can be used to specify how bounds and infinities are converted.\n\n```python\n>>> x = [(true, (2011, 3, 15), (2013, 10, 10), false)]\n>>> p.from_data(x, conv=lambda v: datetime.date(*v))\n[datetime.date(2011, 3, 15),datetime.date(2013, 10, 10))\n\n```\n\n\n[&uparrow; back to top](#table-of-contents)\n### specialize & customize intervals\n\n**disclaimer**: the features explained in this section are still experimental and are subject to backward incompatible changes even in minor or patch updates of `portion`.\n\nthe intervals provided by `portion` already cover a wide range of use cases.\nhowever, in some situations, it might be interesting to specialize or customize these intervals.\none typical example would be to support discrete intervals such as intervals of integers.\n\nwhile it is definitely possible to rely on the default intervals provided by `portion` to encode discrete\nintervals, there are a few edge cases that lead some operations to return unexpected results:\n\n```python\n>>> p.singleton(0) | p.singleton(1)  # case 1: should be [0,1] for discrete numbers\n[0] | [1]\n>>> p.open(0, 1)  # case 2: should be empty\n(0,1)\n>>> p.closedopen(0, 1)  # case 3: should be singleton [0]\n[0,1)\n\n```\n\nthe `portion` library makes its best to ease defining and using subclasses of `interval` to address\nthese situations. in particular, `interval` instances always produce new intervals using `self.__class__`, and the class is written in a way that most of its methods can be easily extended.\n\nto implement a class for intervals of discrete numbers and to cover the three aforementioned cases, we need to change the behaviour of the `interval._mergeable` class method (to address first case) and of the `interval.from_atomic` class method (for cases 2 and 3).\nthe former is used to detect whether two atomic intervals can be merged into a single interval, while the latter is used to create atomic intervals.\n\nthankfully, since discrete intervals are expected to be a frequent use case, `portion` provides an `abstractdiscreteinterval` class that already makes the appropriate changes to these two methods.\nas indicated by its name, this class cannot be used directly and should be inherited.\nin particular, one has either to provide a `_step` class attribute to define the step between consecutive discrete values, or to define the `_incr` and `_decr` class methods:\n\n```python\n>>> class intinterval(p.abstractdiscreteinterval):\n...     _step = 1\n\n```\n\nthat's all!\nwe can now use this class to manipulate intervals of discrete numbers and see it covers the three problematic cases:\n\n```python\n>>> intinterval.from_atomic(p.closed, 0, 0, p.closed) | intinterval.from_atomic(p.closed, 1, 1, p.closed)\n[0,1]\n>>> intinterval.from_atomic(p.open, 0, 1, p.open)\n()\n>>> intinterval.from_atomic(p.closed, 0, 1, p.open)\n[0]\n\n```\n\nas an example of using `_incr` and `_decr`, consider the following `charinterval` subclass tailored to manipulate intervals of characters:\n\n```python\n>>> class charinterval(p.abstractdiscreteinterval):\n...     _incr = lambda v: chr(ord(v) + 1)\n...     _decr = lambda v: chr(ord(v) - 1)\n>>> charinterval.from_atomic(p.open, 'a', 'z', p.open)\n['b','y']\n\n```\n\nhaving to call `from_atomic` on the subclass to create intervals is quite verbose.\nfor convenience, all the functions that create interval instances accept an additional `klass` parameter to specify the class that creates intervals, circumventing the direct use of the class constructors.\nhowever, having to specify the `klass` parameter in each call to `p.closed` or other helpers that create intervals is still a bit too verbose to be convenient.\nconsequently, `portion` provides a `create_api` function that, given a subclass of `interval`, returns a dynamically generated module whose api is similar to the one of `portion` but configured to use the subclass instead:\n\n```python\n>>> d = p.create_api(intinterval)\n>>> d.singleton(0) | d.singleton(1)\n[0,1]\n>>> d.open(0, 1)\n()\n>>> d.closedopen(0, 1)\n[0]\n\n```\n\nthis makes it easy to use our newly defined `intinterval` subclass while still benefiting from `portion`'s api.\n\nlet's extend our example to support intervals of natural numbers.\nsuch intervals are quite similar to the above ones, except they cannot go over negative values.\nwe can prevent the bounds of an interval to be negative by slightly changing the `from_atomic` class method as follows:\n\n```python\n>>> class naturalinterval(intinterval):\n...    @classmethod\n...    def from_atomic(cls, left, lower, upper, right):\n...        return super().from_atomic(\n...            p.closed if lower < 0 else left,\n...            max(0, lower),\n...            upper,\n...            right,\n...        )\n\n```\n\nwe can now define and use the `n` module to check whether our newly defined `naturalinterval` does the job:\n\n```python\n>>> n = p.create_api(naturalinterval)\n>>> n.closed(-10, 2)\n[0,2]\n>>> n.open(-10, 2)\n[0,1]\n>>> ~n.empty()\n[0,+inf)\n\n```\n\nkeep in mind that just because `naturalinterval` has semantics associated with natural numbers does not mean that all possible operations on these intervals strictly comply the semantics. \nthe following examples illustrate some of the cases where additional checks should be implemented to strictly adhere to these semantics:\n\n```python\n>>> n.closed(1.5, 2.5)  # bounds are not natural numbers\n[1.5,2.5]\n>>> 0.5 in n.closed(0, 1)  # given value is not a natural number\ntrue\n>>> ~n.singleton(0.5)\n[1.5,+inf)\n\n```\n\n\n\n[&uparrow; back to top](#table-of-contents)\n## changelog\n\nthis library adheres to a [semantic versioning](https://semver.org) scheme.\nsee [changelog.md](https://github.com/alexandredecan/portion/blob/master/changelog.md) for the list of changes.\n\n\n\n## contributions\n\ncontributions are very welcome!\nfeel free to report bugs or suggest new features using github issues and/or pull requests.\n\n\n\n## license\n\ndistributed under [lgplv3 - gnu lesser general public license, version 3](https://github.com/alexandredecan/portion/blob/master/license.txt).\n\nyou can refer to this library using:\n\n```\n@software{portion,\n  author = {decan, alexandre},\n  title = {portion: python data structure and operations for intervals},\n  url = {https://github.com/alexandredecan/portion},\n}\n```\n\n\n",
  "docs_url": null,
  "keywords": "interval operation range math",
  "license": "lgplv3",
  "name": "portion",
  "package_url": "https://pypi.org/project/portion/",
  "project_url": "https://pypi.org/project/portion/",
  "project_urls": {
    "Homepage": "https://github.com/AlexandreDecan/portion"
  },
  "release_url": "https://pypi.org/project/portion/2.4.2/",
  "requires_dist": [
    "sortedcontainers ~=2.2",
    "pytest ~=7.0 ; extra == 'test'",
    "coverage ~=6.0 ; extra == 'test'",
    "black >=21.8b ; extra == 'test'"
  ],
  "requires_python": "~= 3.7",
  "summary": "python data structure and operations for intervals",
  "version": "2.4.2",
  "releases": [],
  "developers": [
    "alexandre_decan"
  ],
  "kwds": "workflows intervaldict commits branch coverage",
  "license_kwds": "lgplv3",
  "libtype": "pypi",
  "id": "pypi_portion",
  "homepage": "https://github.com/alexandredecan/portion",
  "release_count": 18,
  "dependency_ids": [
    "pypi_black",
    "pypi_coverage",
    "pypi_pytest",
    "pypi_sortedcontainers"
  ]
}