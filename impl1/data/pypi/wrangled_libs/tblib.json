{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: utilities"
  ],
  "description": "========\noverview\n========\n\n\n\nserialization library for exceptions and tracebacks.\n\n* free software: bsd license\n\nit allows you to:\n\n* `pickle <https://docs.python.org/3/library/pickle.html>`_ tracebacks and raise exceptions\n  with pickled tracebacks in different processes. this allows better error handling when running\n  code over multiple processes (imagine multiprocessing, billiard, futures, celery etc).\n* create traceback objects from strings (the ``from_string`` method). *no pickling is used*.\n* serialize tracebacks to/from plain dicts (the ``from_dict`` and ``to_dict`` methods). *no pickling is used*.\n* raise the tracebacks created from the aforementioned sources.\n* pickle an exception together with its traceback and exception chain\n  (``raise ... from ...``) *(python 3 only)*\n\n**again, note that using the pickle support is completely optional. you are solely responsible for\nsecurity problems should you decide to use the pickle support.**\n\ninstallation\n============\n\n::\n\n    pip install tblib\n\ndocumentation\n=============\n\n.. contents::\n   :local:\n\npickling tracebacks\n~~~~~~~~~~~~~~~~~~~\n\n**note**: the traceback objects that come out are stripped of some attributes (like variables). but you'll be able to raise exceptions with\nthose tracebacks or print them - that should cover 99% of the usecases.\n\n::\n\n    >>> from tblib import pickling_support\n    >>> pickling_support.install()\n    >>> import pickle, sys\n    >>> def inner_0():\n    ...     raise exception('fail')\n    ...\n    >>> def inner_1():\n    ...     inner_0()\n    ...\n    >>> def inner_2():\n    ...     inner_1()\n    ...\n    >>> try:\n    ...     inner_2()\n    ... except:\n    ...     s1 = pickle.dumps(sys.exc_info())\n    ...\n    >>> len(s1) > 1\n    true\n    >>> try:\n    ...     inner_2()\n    ... except:\n    ...     s2 = pickle.dumps(sys.exc_info(), protocol=pickle.highest_protocol)\n    ...\n    >>> len(s2) > 1\n    true\n\n    >>> try:\n    ...     import cpickle\n    ... except importerror:\n    ...     import pickle as cpickle\n    >>> try:\n    ...     inner_2()\n    ... except:\n    ...     s3 = cpickle.dumps(sys.exc_info(), protocol=pickle.highest_protocol)\n    ...\n    >>> len(s3) > 1\n    true\n\nunpickling tracebacks\n~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    >>> pickle.loads(s1)\n    (<...exception'>, exception('fail'...), <traceback object at ...>)\n\n    >>> pickle.loads(s2)\n    (<...exception'>, exception('fail'...), <traceback object at ...>)\n\n    >>> pickle.loads(s3)\n    (<...exception'>, exception('fail'...), <traceback object at ...>)\n\nraising\n~~~~~~~\n\n::\n\n    >>> from six import reraise\n    >>> reraise(*pickle.loads(s1))\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[14]>\", line 1, in <module>\n        reraise(*pickle.loads(s2))\n      file \"<doctest readme.rst[8]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n    >>> reraise(*pickle.loads(s2))\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[14]>\", line 1, in <module>\n        reraise(*pickle.loads(s2))\n      file \"<doctest readme.rst[8]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n    >>> reraise(*pickle.loads(s3))\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[14]>\", line 1, in <module>\n        reraise(*pickle.loads(s2))\n      file \"<doctest readme.rst[8]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n\npickling exceptions together with their traceback and chain (python 3 only)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    >>> try:  # doctest: +skip\n    ...     try:\n    ...         1 / 0\n    ...     except exception as e:\n    ...         raise exception(\"foo\") from e\n    ... except exception as e:\n    ...     s = pickle.dumps(e)\n    >>> raise pickle.loads(s)  # doctest: +skip\n    traceback (most recent call last):\n      file \"<doctest readme.rst[16]>\", line 3, in <module>\n        1 / 0\n    zerodivisionerror: division by zero\n\n    the above exception was the direct cause of the following exception:\n\n    traceback (most recent call last):\n      file \"<doctest readme.rst[17]>\", line 1, in <module>\n        raise pickle.loads(s)\n      file \"<doctest readme.rst[16]>\", line 5, in <module>\n        raise exception(\"foo\") from e\n    exception: foo\n\nbaseexception subclasses defined after calling ``pickling_support.install()`` will\n**not** retain their traceback and exception chain pickling.\nto cover custom exceptions, there are three options:\n\n1. use ``@pickling_support.install`` as a decorator for each custom exception\n\n    .. code-block:: python\n\n        >>> from tblib import pickling_support\n        >>> # declare all imports of your package's dependencies\n        >>> import numpy  # doctest: +skip\n\n        >>> pickling_support.install()  # install for all modules imported so far\n\n        >>> @pickling_support.install\n        ... class customerror(exception):\n        ...     pass\n\n   eventual subclasses of ``customerror`` will need to be decorated again.\n\n2. invoke ``pickling_support.install()`` after all modules have been imported and all\n   exception subclasses have been declared\n\n    .. code-block:: python\n\n        >>> # declare all imports of your package's dependencies\n        >>> import numpy  # doctest: +skip\n        >>> from tblib import pickling_support\n\n        >>> # declare your own custom exceptions\n        >>> class customerror(exception):\n        ...     pass\n\n        >>> # finally, install tblib\n        >>> pickling_support.install()\n\n3. selectively install tblib for exception instances just before they are pickled\n\n    .. code-block:: python\n\n       pickling_support.install(<exception instance>, [exception instance], ...)\n\n   the above will install tblib pickling for all listed exceptions as well as any other\n   exceptions in their exception chains.\n\n   for example, one could write a wrapper to be used with\n   `processpoolexecutor <https://docs.python.org/3/library/concurrent.futures.html>`_,\n   `dask.distributed <https://distributed.dask.org/>`_, or similar libraries:\n\n::\n\n    >>> from tblib import pickling_support\n    >>> def wrapper(func, *args, **kwargs):\n    ...     try:\n    ...         return func(*args, **kwargs)\n    ...     except exception as e:\n    ...         pickling_support.install(e)\n    ...         raise\n\nwhat if we have a local stack, does it show correctly ?\n-------------------------------------------------------\n\nyes it does::\n\n    >>> exc_info = pickle.loads(s3)\n    >>> def local_0():\n    ...     reraise(*exc_info)\n    ...\n    >>> def local_1():\n    ...     local_0()\n    ...\n    >>> def local_2():\n    ...     local_1()\n    ...\n    >>> local_2()\n    traceback (most recent call last):\n      file \"...doctest.py\", line ..., in __run\n        compileflags, 1) in test.globs\n      file \"<doctest readme.rst[24]>\", line 1, in <module>\n        local_2()\n      file \"<doctest readme.rst[23]>\", line 2, in local_2\n        local_1()\n      file \"<doctest readme.rst[22]>\", line 2, in local_1\n        local_0()\n      file \"<doctest readme.rst[21]>\", line 2, in local_0\n        reraise(*exc_info)\n      file \"<doctest readme.rst[11]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n\nit also supports more contrived scenarios\n-----------------------------------------\n\nlike tracebacks with syntax errors::\n\n    >>> from tblib import traceback\n    >>> from examples import bad_syntax\n    >>> try:\n    ...     bad_syntax()\n    ... except:\n    ...     et, ev, tb = sys.exc_info()\n    ...     tb = traceback(tb)\n    ...\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[58]>\", line 1, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"<doctest readme.rst[57]>\", line 2, in <module>\n        bad_syntax()\n      file \"...tests...examples.py\", line 18, in bad_syntax\n        import badsyntax\n      file \"...tests...badsyntax.py\", line 5\n        is very bad\n         ^\n    syntaxerror: invalid syntax\n\nor other import failures::\n\n    >>> from examples import bad_module\n    >>> try:\n    ...     bad_module()\n    ... except:\n    ...     et, ev, tb = sys.exc_info()\n    ...     tb = traceback(tb)\n    ...\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[61]>\", line 1, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"<doctest readme.rst[60]>\", line 2, in <module>\n        bad_module()\n      file \"...tests...examples.py\", line 23, in bad_module\n        import badmodule\n      file \"...tests...badmodule.py\", line 3, in <module>\n        raise exception(\"boom!\")\n    exception: boom!\n\nor a traceback that's caused by exceeding the recursion limit (here we're\nforcing the type and value to have consistency across platforms)::\n\n    >>> def f(): f()\n    >>> try:\n    ...    f()\n    ... except runtimeerror:\n    ...    et, ev, tb = sys.exc_info()\n    ...    tb = traceback(tb)\n    ...\n    >>> reraise(runtimeerror, runtimeerror(\"maximum recursion depth exceeded\"), tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[32]>\", line 1, in f\n        def f(): f()\n      file \"<doctest readme.rst[32]>\", line 1, in f\n        def f(): f()\n      file \"<doctest readme.rst[32]>\", line 1, in f\n        def f(): f()\n      ...\n    runtimeerror: maximum recursion depth exceeded\n\nreference\n~~~~~~~~~\n\ntblib.traceback\n---------------\n\nit is used by the ``pickling_support``. you can use it too if you want more flexibility::\n\n    >>> from tblib import traceback\n    >>> try:\n    ...     inner_2()\n    ... except:\n    ...     et, ev, tb = sys.exc_info()\n    ...     tb = traceback(tb)\n    ...\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[21]>\", line 6, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"<doctest readme.rst[21]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n\ntblib.traceback.to_dict\n```````````````````````\n\nyou can use the ``to_dict`` method and the ``from_dict`` classmethod to\nconvert a traceback into and from a dictionary serializable by the stdlib\njson.jsondecoder::\n\n    >>> import json\n    >>> from pprint import pprint\n    >>> try:\n    ...     inner_2()\n    ... except:\n    ...     et, ev, tb = sys.exc_info()\n    ...     tb = traceback(tb)\n    ...     tb_dict = tb.to_dict()\n    ...     pprint(tb_dict)\n    {'tb_frame': {'f_code': {'co_filename': '<doctest readme.rst[...]>',\n                             'co_name': '<module>'},\n                  'f_globals': {'__name__': '__main__'},\n                  'f_lineno': 5},\n     'tb_lineno': 2,\n     'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,\n                                         'co_name': 'inner_2'},\n                              'f_globals': {'__name__': '__main__'},\n                              'f_lineno': 2},\n                 'tb_lineno': 2,\n                 'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,\n                                                     'co_name': 'inner_1'},\n                                          'f_globals': {'__name__': '__main__'},\n                                          'f_lineno': 2},\n                             'tb_lineno': 2,\n                             'tb_next': {'tb_frame': {'f_code': {'co_filename': ...,\n                                                                 'co_name': 'inner_0'},\n                                                      'f_globals': {'__name__': '__main__'},\n                                                      'f_lineno': 2},\n                                         'tb_lineno': 2,\n                                         'tb_next': none}}}}\n\ntblib.traceback.from_dict\n`````````````````````````\n\nbuilding on the previous example::\n\n    >>> tb_json = json.dumps(tb_dict)\n    >>> tb = traceback.from_dict(json.loads(tb_json))\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[21]>\", line 6, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"<doctest readme.rst[21]>\", line 2, in <module>\n        inner_2()\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n\ntblib.traceback.from_string\n```````````````````````````\n\n::\n\n    >>> tb = traceback.from_string(\"\"\"\n    ... file \"skipped.py\", line 123, in func_123\n    ... traceback (most recent call last):\n    ...   file \"tests/examples.py\", line 2, in func_a\n    ...     func_b()\n    ...   file \"tests/examples.py\", line 6, in func_b\n    ...     func_c()\n    ...   file \"tests/examples.py\", line 10, in func_c\n    ...     func_d()\n    ...   file \"tests/examples.py\", line 14, in func_d\n    ... doesn't: matter\n    ... \"\"\")\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[42]>\", line 6, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"...examples.py\", line 2, in func_a\n        func_b()\n      file \"...examples.py\", line 6, in func_b\n        func_c()\n      file \"...examples.py\", line 10, in func_c\n        func_d()\n      file \"...examples.py\", line 14, in func_d\n        raise exception(\"guessing time !\")\n    exception: fail\n\n\nif you use the ``strict=false`` option then parsing is a bit more lax::\n\n    >>> tb = traceback.from_string(\"\"\"\n    ... file \"bogus.py\", line 123, in bogus\n    ... traceback (most recent call last):\n    ...  file \"tests/examples.py\", line 2, in func_a\n    ...   func_b()\n    ...    file \"tests/examples.py\", line 6, in func_b\n    ...     func_c()\n    ...    file \"tests/examples.py\", line 10, in func_c\n    ...   func_d()\n    ...  file \"tests/examples.py\", line 14, in func_d\n    ... doesn't: matter\n    ... \"\"\", strict=false)\n    >>> reraise(et, ev, tb.as_traceback())\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[42]>\", line 6, in <module>\n        reraise(et, ev, tb.as_traceback())\n      file \"bogus.py\", line 123, in bogus\n      file \"...examples.py\", line 2, in func_a\n        func_b()\n      file \"...examples.py\", line 6, in func_b\n        func_c()\n      file \"...examples.py\", line 10, in func_c\n        func_d()\n      file \"...examples.py\", line 14, in func_d\n        raise exception(\"guessing time !\")\n    exception: fail\n\ntblib.decorators.return_error\n-----------------------------\n\n::\n\n    >>> from tblib.decorators import return_error\n    >>> inner_2r = return_error(inner_2)\n    >>> e = inner_2r()\n    >>> e\n    <tblib.decorators.error object at ...>\n    >>> e.reraise()\n    traceback (most recent call last):\n      ...\n      file \"<doctest readme.rst[26]>\", line 1, in <module>\n        e.reraise()\n      file \"...tblib...decorators.py\", line 19, in reraise\n        reraise(self.exc_type, self.exc_value, self.traceback)\n      file \"...tblib...decorators.py\", line 25, in return_exceptions_wrapper\n        return func(*args, **kwargs)\n      file \"<doctest readme.rst[5]>\", line 2, in inner_2\n        inner_1()\n      file \"<doctest readme.rst[4]>\", line 2, in inner_1\n        inner_0()\n      file \"<doctest readme.rst[3]>\", line 2, in inner_0\n        raise exception('fail')\n    exception: fail\n\nhow's this useful? imagine you're using multiprocessing like this::\n\n    # note that python 3.4 and later will show the remote traceback (but as a string sadly) so we skip testing this.\n    >>> import traceback\n    >>> from multiprocessing import pool\n    >>> from examples import func_a\n    >>> pool = pool()  # doctest: +skip\n    >>> try:  # doctest: +skip\n    ...     for i in pool.map(func_a, range(5)):\n    ...         print(i)\n    ... except:\n    ...     print(traceback.format_exc())\n    ...\n    traceback (most recent call last):\n      file \"<doctest readme.rst[...]>\", line 2, in <module>\n        for i in pool.map(func_a, range(5)):\n      file \"...multiprocessing...pool.py\", line ..., in map\n        ...\n      file \"...multiprocessing...pool.py\", line ..., in get\n        ...\n    exception: guessing time !\n    <blankline>\n    >>> pool.terminate()  # doctest: +skip\n\nnot very useful is it? let's sort this out::\n\n    >>> from tblib.decorators import apply_with_return_error, error\n    >>> from itertools import repeat\n    >>> pool = pool()\n    >>> try:\n    ...     for i in pool.map(apply_with_return_error, zip(repeat(func_a), range(5))):\n    ...         if isinstance(i, error):\n    ...             i.reraise()\n    ...         else:\n    ...             print(i)\n    ... except:\n    ...     print(traceback.format_exc())\n    ...\n    traceback (most recent call last):\n      file \"<doctest readme.rst[...]>\", line 4, in <module>\n        i.reraise()\n      file \"...tblib...decorators.py\", line ..., in reraise\n        reraise(self.exc_type, self.exc_value, self.traceback)\n      file \"...tblib...decorators.py\", line ..., in return_exceptions_wrapper\n        return func(*args, **kwargs)\n      file \"...tblib...decorators.py\", line ..., in apply_with_return_error\n        return args[0](*args[1:])\n      file \"...examples.py\", line 2, in func_a\n        func_b()\n      file \"...examples.py\", line 6, in func_b\n        func_c()\n      file \"...examples.py\", line 10, in func_c\n        func_d()\n      file \"...examples.py\", line 14, in func_d\n        raise exception(\"guessing time !\")\n    exception: guessing time !\n    <blankline>\n    >>> pool.terminate()\n\nmuch better !\n\nwhat if we have a local call stack ?\n````````````````````````````````````\n\n::\n\n    >>> def local_0():\n    ...     pool = pool()\n    ...     try:\n    ...         for i in pool.map(apply_with_return_error, zip(repeat(func_a), range(5))):\n    ...             if isinstance(i, error):\n    ...                 i.reraise()\n    ...             else:\n    ...                 print(i)\n    ...     finally:\n    ...         pool.close()\n    ...\n    >>> def local_1():\n    ...     local_0()\n    ...\n    >>> def local_2():\n    ...     local_1()\n    ...\n    >>> try:\n    ...     local_2()\n    ... except:\n    ...     print(traceback.format_exc())\n    traceback (most recent call last):\n      file \"<doctest readme.rst[...]>\", line 2, in <module>\n        local_2()\n      file \"<doctest readme.rst[...]>\", line 2, in local_2\n        local_1()\n      file \"<doctest readme.rst[...]>\", line 2, in local_1\n        local_0()\n      file \"<doctest readme.rst[...]>\", line 6, in local_0\n        i.reraise()\n      file \"...tblib...decorators.py\", line 20, in reraise\n        reraise(self.exc_type, self.exc_value, self.traceback)\n      file \"...tblib...decorators.py\", line 27, in return_exceptions_wrapper\n        return func(*args, **kwargs)\n      file \"...tblib...decorators.py\", line 47, in apply_with_return_error\n        return args[0](*args[1:])\n      file \"...tests...examples.py\", line 2, in func_a\n        func_b()\n      file \"...tests...examples.py\", line 6, in func_b\n        func_c()\n      file \"...tests...examples.py\", line 10, in func_c\n        func_d()\n      file \"...tests...examples.py\", line 14, in func_d\n        raise exception(\"guessing time !\")\n    exception: guessing time !\n    <blankline>\n\nother weird stuff\n`````````````````\n\nclearing traceback works (python 3.4 and up)::\n\n    >>> tb = traceback.from_string(\"\"\"\n    ... file \"skipped.py\", line 123, in func_123\n    ... traceback (most recent call last):\n    ...   file \"tests/examples.py\", line 2, in func_a\n    ...     func_b()\n    ...   file \"tests/examples.py\", line 6, in func_b\n    ...     func_c()\n    ...   file \"tests/examples.py\", line 10, in func_c\n    ...     func_d()\n    ...   file \"tests/examples.py\", line 14, in func_d\n    ... doesn't: matter\n    ... \"\"\")\n    >>> import traceback, sys\n    >>> if sys.version_info > (3, 4):\n    ...     traceback.clear_frames(tb)\n\ncredits\n=======\n\n* `mitsuhiko/jinja2 <https://github.com/mitsuhiko/jinja2>`_ for figuring a way to create traceback objects.\n\n\nchangelog\n=========\n\n3.0.0 (2023-10-22)\n~~~~~~~~~~~~~~~~~~\n\n* added support for  ``__context__``, ``__suppress_context__`` and ``__notes__``.\n  contributed by tim maxwell in `#72 <https://github.com/ionelmc/python-tblib/pull/72>`_.\n* added the ``get_locals`` argument to ``tblib.pickling_support.install()``, ``tblib.traceback`` and ``tblib.frame``.\n  fixes `#41 <https://github.com/ionelmc/python-tblib/issues/41>`_.\n* dropped support for now-eol python 3.7 and added 3.12 in the test grid.\n\n2.0.0 (2023-06-22)\n~~~~~~~~~~~~~~~~~~\n\n* removed support for legacy pythons (2.7 and 3.6) and added python 3.11 in the test grid.\n* some cleanups and refactors (mostly from ruff).\n\n1.7.0 (2020-07-24)\n~~~~~~~~~~~~~~~~~~\n\n* add more attributes to ``frame`` and ``code`` objects for pytest compatibility. contributed by ivanq in\n  `#58 <https://github.com/ionelmc/python-tblib/pull/58>`_.\n\n1.6.0 (2019-12-07)\n~~~~~~~~~~~~~~~~~~\n\n* when pickling an exception, also pickle its traceback and the exception chain\n  (``raise ... from ...``). contributed by guido imperiale in\n  `#53 <https://github.com/ionelmc/python-tblib/issues/53>`_.\n\n1.5.0 (2019-10-23)\n~~~~~~~~~~~~~~~~~~\n\n* added support for python 3.8. contributed by victor stinner in\n  `#42 <https://github.com/ionelmc/python-tblib/issues/42>`_.\n* removed support for end of life python 3.4.\n* few ci improvements and fixes.\n\n1.4.0 (2019-05-02)\n~~~~~~~~~~~~~~~~~~\n\n* removed support for end of life python 3.3.\n* fixed tests for python 3.7. contributed by elliott sales de andrade in\n  `#36 <https://github.com/ionelmc/python-tblib/issues/36>`_.\n* fixed compatibility issue with twised (``twisted.python.failure.failure`` expected a ``co_code`` attribute).\n\n1.3.2 (2017-04-09)\n~~~~~~~~~~~~~~~~~~\n\n* add support for pypy3.5-5.7.1-beta. previously ``attributeerror:\n  'frame' object has no attribute 'clear'``  could be raised. see pypy\n  issue `#2532 <https://foss.heptapod.net/pypy/pypy/-/issues/2532>`_.\n\n1.3.1 (2017-03-27)\n~~~~~~~~~~~~~~~~~~\n\n* fixed handling for tracebacks due to exceeding the recursion limit.\n  fixes `#15 <https://github.com/ionelmc/python-tblib/issues/15>`_.\n\n1.3.0 (2016-03-08)\n~~~~~~~~~~~~~~~~~~\n\n* added ``traceback.from_string``.\n\n1.2.0 (2015-12-18)\n~~~~~~~~~~~~~~~~~~\n\n* fixed handling for tracebacks from generators and other internal improvements\n  and optimizations. contributed by drayx in `#10 <https://github.com/ionelmc/python-tblib/issues/10>`_\n  and `#11 <https://github.com/ionelmc/python-tblib/pull/11>`_.\n\n1.1.0 (2015-07-27)\n~~~~~~~~~~~~~~~~~~\n\n* added support for python 2.6. contributed by arcadiy ivanov in\n  `#8 <https://github.com/ionelmc/python-tblib/pull/8>`_.\n\n1.0.0 (2015-03-30)\n~~~~~~~~~~~~~~~~~~\n\n* added ``to_dict`` method and ``from_dict`` classmethod on tracebacks.\n  contributed by beckjake in `#5 <https://github.com/ionelmc/python-tblib/pull/5>`_.\n",
  "docs_url": null,
  "keywords": "traceback,debugging,exceptions",
  "license": "bsd-2-clause",
  "name": "tblib",
  "package_url": "https://pypi.org/project/tblib/",
  "project_url": "https://pypi.org/project/tblib/",
  "project_urls": {
    "Changelog": "https://python-tblib.readthedocs.io/en/latest/changelog.html",
    "Documentation": "https://python-tblib.readthedocs.io/",
    "Homepage": "https://github.com/ionelmc/python-tblib",
    "Issue Tracker": "https://github.com/ionelmc/python-tblib/issues"
  },
  "release_url": "https://pypi.org/project/tblib/3.0.0/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "traceback serialization library.",
  "version": "3.0.0",
  "releases": [],
  "developers": [
    "contact@ionelmc.ro"
  ],
  "kwds": "tracebacks traceback pickling_support return_exceptions_wrapper pythons",
  "license_kwds": "bsd-2-clause",
  "libtype": "pypi",
  "id": "pypi_tblib",
  "homepage": "https://github.com/ionelmc/python-tblib",
  "release_count": 17,
  "dependency_ids": []
}