{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# thread-pool controls [![build status](https://dev.azure.com/joblib/threadpoolctl/_apis/build/status/joblib.threadpoolctl?branchname=master)](https://dev.azure.com/joblib/threadpoolctl/_build/latest?definitionid=1&branchname=master) [![codecov](https://codecov.io/gh/joblib/threadpoolctl/branch/master/graph/badge.svg)](https://codecov.io/gh/joblib/threadpoolctl)\n\npython helpers to limit the number of threads used in the\nthreadpool-backed of common native libraries used for scientific\ncomputing and data science (e.g. blas and openmp).\n\nfine control of the underlying thread-pool size can be useful in\nworkloads that involve nested parallelism so as to mitigate\noversubscription issues.\n\n## installation\n\n- for users, install the last published version from pypi:\n\n  ```bash\n  pip install threadpoolctl\n  ```\n\n- for contributors, install from the source repository in developer\n  mode:\n\n  ```bash\n  pip install -r dev-requirements.txt\n  flit install --symlink\n  ```\n\n  then you run the tests with pytest:\n\n  ```bash\n  pytest\n  ```\n\n## usage\n\n### command line interface\n\nget a json description of thread-pools initialized when importing python\npackages such as numpy or scipy for instance:\n\n```\npython -m threadpoolctl -i numpy scipy.linalg\n[\n  {\n    \"filepath\": \"/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so\",\n    \"prefix\": \"libmkl_rt\",\n    \"user_api\": \"blas\",\n    \"internal_api\": \"mkl\",\n    \"version\": \"2019.0.4\",\n    \"num_threads\": 2,\n    \"threading_layer\": \"intel\"\n  },\n  {\n    \"filepath\": \"/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so\",\n    \"prefix\": \"libiomp\",\n    \"user_api\": \"openmp\",\n    \"internal_api\": \"openmp\",\n    \"version\": null,\n    \"num_threads\": 4\n  }\n]\n```\n\nthe json information is written on stdout. if some of the packages are missing,\na warning message is displayed on stderr.\n\n### python runtime programmatic introspection\n\nintrospect the current state of the threadpool-enabled runtime libraries\nthat are loaded when importing python packages:\n\n```python\n>>> from threadpoolctl import threadpool_info\n>>> from pprint import pprint\n>>> pprint(threadpool_info())\n[]\n\n>>> import numpy\n>>> pprint(threadpool_info())\n[{'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so',\n  'internal_api': 'mkl',\n  'num_threads': 2,\n  'prefix': 'libmkl_rt',\n  'threading_layer': 'intel',\n  'user_api': 'blas',\n  'version': '2019.0.4'},\n {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so',\n  'internal_api': 'openmp',\n  'num_threads': 4,\n  'prefix': 'libiomp',\n  'user_api': 'openmp',\n  'version': none}]\n\n>>> import xgboost\n>>> pprint(threadpool_info())\n[{'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libmkl_rt.so',\n  'internal_api': 'mkl',\n  'num_threads': 2,\n  'prefix': 'libmkl_rt',\n  'threading_layer': 'intel',\n  'user_api': 'blas',\n  'version': '2019.0.4'},\n {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libiomp5.so',\n  'internal_api': 'openmp',\n  'num_threads': 4,\n  'prefix': 'libiomp',\n  'user_api': 'openmp',\n  'version': none},\n {'filepath': '/home/ogrisel/miniconda3/envs/tmp/lib/libgomp.so.1.0.0',\n  'internal_api': 'openmp',\n  'num_threads': 4,\n  'prefix': 'libgomp',\n  'user_api': 'openmp',\n  'version': none}]\n```\n\nin the above example, `numpy` was installed from the default anaconda channel and comes\nwith mkl and its intel openmp (`libiomp5`) implementation while `xgboost` was installed\nfrom pypi.org and links against gnu openmp (`libgomp`) so both openmp runtimes are\nloaded in the same python program.\n\nthe state of these libraries is also accessible through the object oriented api:\n\n```python\n>>> from threadpoolctl import threadpoolcontroller, threadpool_info\n>>> from pprint import pprint\n>>> import numpy\n>>> controller = threadpoolcontroller()\n>>> pprint(controller.info())\n[{'architecture': 'haswell',\n  'filepath': '/home/jeremie/miniconda/envs/dev/lib/libopenblasp-r0.3.17.so',\n  'internal_api': 'openblas',\n  'num_threads': 4,\n  'prefix': 'libopenblas',\n  'threading_layer': 'pthreads',\n  'user_api': 'blas',\n  'version': '0.3.17'}]\n\n>>> controller.info() == threadpool_info()\ntrue\n```\n\n### setting the maximum size of thread-pools\n\ncontrol the number of threads used by the underlying runtime libraries\nin specific sections of your python program:\n\n```python\n>>> from threadpoolctl import threadpool_limits\n>>> import numpy as np\n\n>>> with threadpool_limits(limits=1, user_api='blas'):\n...     # in this block, calls to blas implementation (like openblas or mkl)\n...     # will be limited to use only one thread. they can thus be used jointly\n...     # with thread-parallelism.\n...     a = np.random.randn(1000, 1000)\n...     a_squared = a @ a\n```\n\nthe threadpools can also be controlled via the object oriented api, which is especially\nuseful to avoid searching through all the loaded shared libraries each time. it will\nhowever not act on libraries loaded after the instantiation of the\n`threadpoolcontroller`:\n\n```python\n>>> from threadpoolctl import threadpoolcontroller\n>>> import numpy as np\n>>> controller = threadpoolcontroller()\n\n>>> with controller.limit(limits=1, user_api='blas'):\n...     a = np.random.randn(1000, 1000)\n...     a_squared = a @ a\n```\n\n### restricting the limits to the scope of a function\n\n`threadpool_limits` and `threadpoolcontroller` can also be used as decorators to set\nthe maximum number of threads used by the supported libraries at a function level. the\ndecorators are accessible through their `wrap` method:\n\n```python\n>>> from threadpoolctl import threadpoolcontroller, threadpool_limits\n>>> import numpy as np\n>>> controller = threadpoolcontroller()\n\n>>> @controller.wrap(limits=1, user_api='blas')\n... # or @threadpool_limits.wrap(limits=1, user_api='blas')\n... def my_func():\n...     # inside this function, calls to blas implementation (like openblas or mkl)\n...     # will be limited to use only one thread.\n...     a = np.random.randn(1000, 1000)\n...     a_squared = a @ a\n...\n```\n\n### writing a custom library controller\n\ncurrently, `threadpoolctl` has support for `openmp` and the main `blas` libraries.\nhowever it can also be used to control the threadpool of other native libraries,\nprovided that they expose an api to get and set the limit on the number of threads.\nfor that, one must implement a controller for this library and register it to\n`threadpoolctl`.\n\na custom controller must be a subclass of the `libcontroller` class and implement\nthe attributes and methods described in the docstring of `libcontroller`. then this\nnew controller class must be registered using the `threadpoolctl.register` function.\nan complete example can be found [here](\n  https://github.com/joblib/threadpoolctl/blob/master/tests/_pymylib/__init__.py).\n\n### sequential blas within openmp parallel region\n\nwhen one wants to have sequential blas calls within an openmp parallel region, it's\nsafer to set `limits=\"sequential_blas_under_openmp\"` since setting `limits=1` and\n`user_api=\"blas\"` might not lead to the expected behavior in some configurations\n(e.g. openblas with the openmp threading layer\nhttps://github.com/xianyi/openblas/issues/2985).\n\n### known limitations\n\n- `threadpool_limits` can fail to limit the number of inner threads when nesting\n  parallel loops managed by distinct openmp runtime implementations (for instance\n  libgomp from gcc and libomp from clang/llvm or libiomp from icc).\n\n  see the `test_openmp_nesting` function in [tests/test_threadpoolctl.py](\n  https://github.com/joblib/threadpoolctl/blob/master/tests/test_threadpoolctl.py)\n  for an example. more information can be found at:\n  https://github.com/jeremiedbb/nested_openmp\n\n  note however that this problem does not happen when `threadpool_limits` is\n  used to limit the number of threads used internally by blas calls that are\n  themselves nested under openmp parallel loops. `threadpool_limits` works as\n  expected, even if the inner blas implementation relies on a distinct openmp\n  implementation.\n\n- using intel openmp (icc) and llvm openmp (clang) in the same python program\n  under linux is known to cause problems. see the following guide for more details\n  and workarounds:\n  https://github.com/joblib/threadpoolctl/blob/master/multiple_openmp.md\n\n- setting the maximum number of threads of the openmp and blas libraries has a global\n  effect and impacts the whole python process. there is no thread level isolation as\n  these libraries do not offer thread-local apis to configure the number of threads to\n  use in nested parallel calls.\n\n\n## maintainers\n\nto make a release:\n\nbump the version number (`__version__`) in `threadpoolctl.py`.\n\nbuild the distribution archives:\n\n```bash\npip install flit\nflit build\n```\n\ncheck the contents of `dist/`.\n\nif everything is fine, make a commit for the release, tag it, push the\ntag to github and then:\n\n```bash\nflit publish\n```\n\n### credits\n\nthe initial dynamic library introspection code was written by @anton-malakhov\nfor the smp package available at https://github.com/intelpython/smp .\n\nthreadpoolctl extends this for other operating systems. contrary to smp,\nthreadpoolctl does not attempt to limit the size of python multiprocessing\npools (threads or processes) or set operating system-level cpu affinity\nconstraints: threadpoolctl only interacts with native libraries via their\npublic runtime apis.\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-3-clause",
  "name": "threadpoolctl",
  "package_url": "https://pypi.org/project/threadpoolctl/",
  "project_url": "https://pypi.org/project/threadpoolctl/",
  "project_urls": {
    "Homepage": "https://github.com/joblib/threadpoolctl"
  },
  "release_url": "https://pypi.org/project/threadpoolctl/3.2.0/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "threadpoolctl",
  "version": "3.2.0",
  "releases": [],
  "developers": [
    "thomas.moreau.2010@gmail.com",
    "thomas_moreau"
  ],
  "kwds": "threadpool_limits threadpoolctl test_threadpoolctl threadpool threadpool_info",
  "license_kwds": "bsd-3-clause",
  "libtype": "pypi",
  "id": "pypi_threadpoolctl",
  "homepage": "https://github.com/joblib/threadpoolctl",
  "release_count": 8,
  "dependency_ids": []
}