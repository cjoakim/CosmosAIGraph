{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "wrapt_timeout_decorator\n=======================\n\n\nversion v1.4.0 as of 2023-07-14 see `changelog`_\n\n|build_badge| |codeql| |license| |jupyter| |pypi|\n|pypi-downloads| |black| |codecov| |cc_maintain| |cc_issues| |cc_coverage| |snyk|\n\n\n\n.. |build_badge| image:: https://github.com/bitranox/wrapt_timeout_decorator/actions/workflows/python-package.yml/badge.svg\n   :target: https://github.com/bitranox/wrapt_timeout_decorator/actions/workflows/python-package.yml\n\n\n.. |codeql| image:: https://github.com/bitranox/wrapt_timeout_decorator/actions/workflows/codeql-analysis.yml/badge.svg?event=push\n   :target: https://github.com//bitranox/wrapt_timeout_decorator/actions/workflows/codeql-analysis.yml\n\n.. |license| image:: https://img.shields.io/github/license/webcomics/pywine.svg\n   :target: http://en.wikipedia.org/wiki/mit_license\n\n.. |jupyter| image:: https://mybinder.org/badge_logo.svg\n   :target: https://mybinder.org/v2/gh/bitranox/wrapt_timeout_decorator/master?filepath=wrapt_timeout_decorator.ipynb\n\n.. for the pypi status link note the dashes, not the underscore !\n.. |pypi| image:: https://img.shields.io/pypi/status/wrapt-timeout-decorator?label=pypi%20package\n   :target: https://badge.fury.io/py/wrapt_timeout_decorator\n\n.. |codecov| image:: https://img.shields.io/codecov/c/github/bitranox/wrapt_timeout_decorator\n   :target: https://codecov.io/gh/bitranox/wrapt_timeout_decorator\n\n.. |cc_maintain| image:: https://img.shields.io/codeclimate/maintainability-percentage/bitranox/wrapt_timeout_decorator?label=cc%20maintainability\n   :target: https://codeclimate.com/github/bitranox/wrapt_timeout_decorator/maintainability\n   :alt: maintainability\n\n.. |cc_issues| image:: https://img.shields.io/codeclimate/issues/bitranox/wrapt_timeout_decorator?label=cc%20issues\n   :target: https://codeclimate.com/github/bitranox/wrapt_timeout_decorator/maintainability\n   :alt: maintainability\n\n.. |cc_coverage| image:: https://img.shields.io/codeclimate/coverage/bitranox/wrapt_timeout_decorator?label=cc%20coverage\n   :target: https://codeclimate.com/github/bitranox/wrapt_timeout_decorator/test_coverage\n   :alt: code coverage\n\n.. |snyk| image:: https://snyk.io/test/github/bitranox/wrapt_timeout_decorator/badge.svg\n   :target: https://snyk.io/test/github/bitranox/wrapt_timeout_decorator\n\n.. |black| image:: https://img.shields.io/badge/code%20style-black-000000.svg\n   :target: https://github.com/psf/black\n\n.. |pypi-downloads| image:: https://img.shields.io/pypi/dm/wrapt-timeout-decorator\n   :target: https://pypi.org/project/wrapt-timeout-decorator/\n   :alt: pypi - downloads\n\nthere are several timeout decorators available, but the one mentioned here\nfocuses on ensuring correctness when used with classes, methods, class methods,\nstatic methods, etc. it also preserves traceback information for pycharm debugging.\n\nadditionally, there is a powerful eval function that allows reading\nthe desired timeout value even from class attributes.\n\ntwo timeout strategies have been implemented:\none using \"signals\" and the other using \"multiprocessing\".\n\nsignals\n-------\n\nthe \"signals\" strategy (for posix systems) is elegant and efficient,\nbut it has some important caveats which should be reviewed\nin the `caveats using signals`_ section.\n\n\nmultiprocessing\n---------------\n\nthe default strategy is to use multiprocessing\n\n- on windows, due to the lack of signals, this is only available choice, which is enforced automatically\n- signals (on posix) can not be used in a subthread, therefore multiprocessing is enforced in such cases\n\nwhen using a subprocess many types from multiprocessing need to be pickable so that child processes can use them.\ntherefore we use \"dill\" instead of \"pickle\" and \"multiprocess\" instead of \"multiprocessing\".\n\ndill extends python\u2019s pickle module for serializing and de-serializing python objects to the majority of the built-in python types\n\ncommunication with the subprocess is done via \"multiprocess.pipe\" instead of \"queue\",\nwhich offers improved speed and may also work on amazon aws.\n\n----\n\nautomated tests, github actions, documentation, badges, etc. are managed with `pizzacutter <https://github\n.com/bitranox/pizzacutter>`_ (cookiecutter on steroids)\n\npython version required: 3.8.0 or newer\n\ntested on recent linux with python 3.8, 3.9, 3.10, 3.11, 3.12-dev, pypy-3.9, pypy-3.10 - architectures: amd64\n\n`100% code coverage <https://codeclimate.com/github/bitranox/wrapt_timeout_decorator/test_coverage>`_, flake8 style checking ,mypy static type checking ,tested under `linux, macos, windows <https://github.com/bitranox/wrapt_timeout_decorator/actions/workflows/python-package.yml>`_, automatic daily builds and monitoring\n\n----\n\n- `try it online`_\n- `usage`_\n- `usage from commandline`_\n- `installation and upgrade`_\n- `requirements`_\n- `acknowledgements`_\n- `contribute`_\n- `report issues <https://github.com/bitranox/wrapt_timeout_decorator/blob/master/issue_template.md>`_\n- `pull request <https://github.com/bitranox/wrapt_timeout_decorator/blob/master/pull_request_template.md>`_\n- `code of conduct <https://github.com/bitranox/wrapt_timeout_decorator/blob/master/code_of_conduct.md>`_\n- `license`_\n- `changelog`_\n\n----\n\ntry it online\n-------------\n\nyou might try it right away in jupyter notebook by using the \"launch binder\" badge, or click `here <https://mybinder.org/v2/gh/{{rst_include.\nrepository_slug}}/master?filepath=wrapt_timeout_decorator.ipynb>`_\n\nusage\n-----------\n\n.. code-block:: py\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    @timeout(5)\n    def mytest(message):\n        # this example does not work on windows, please check the section\n        # \"use with windows\" in the readme.rst\n        print(message)\n        for i in range(1,10):\n            time.sleep(1)\n            print('{} seconds have passed'.format(i))\n\n    if __name__ == '__main__':\n        mytest('starting')\n\ngeneral recommendations\n-----------------------\nminimize the excessive use of timeouts in your code and reserve their usage for essential cases.\n\nimplement timeouts at the lowest possible abstraction level to prevent unintended\nconsequences such as exceptions being caught by unrelated code or non-pickable\nfunctions and arguments.\n\navoid incorporating the timeout decorator within a loop that iterates multiple times,\nas this can result in considerable time overhead,\nespecially on windows systems, when utilizing multiprocessing.\n\nwhenever feasible, leverage the existing built-in timeouts already provided by the functions\nand libraries you utilize. these built-in timeouts can handle most situations effectively.\nonly resort to use this timeout decorator as a last resort when all other alternatives have been exhausted.\n\n\n    bad example (pseudocode) - lets assume the write to the database fails sometimes for unknown reasons, and \"hangs\"\n\n    .. code-block:: py\n\n        # module file_analyzer\n        import time\n        from wrapt_timeout_decorator import *\n\n        def read_the_file(filename):\n            ...\n\n        def analyze_the_file(filename):\n            ...\n\n        def write_to_database(file_content):\n            ...\n\n\n        @timeout(5)  # try to minimize the scope of the timeout\n        def import_file(filename):\n            file_content = read_the_file(filename)\n            structured_data = analyze_the_file(file_content)\n            write_to_database(structured_data)\n\n\n    better example (pseudocode)\n\n    .. code-block:: py\n\n        # module file_analyzer\n        import time\n        from wrapt_timeout_decorator import *\n\n        def read_the_file(filename):\n            ...\n\n        def analyze_the_file(filename):\n            ...\n\n        @timeout(5)     # better, because smaller scope\n        def write_to_database(file_content):\n            ...\n\n        def import_file(filename):\n            file_content = read_the_file(filename)\n            structured_data = analyze_the_file(file_content)\n            write_to_database(structured_data)\n\nuse with windows\n----------------\n\nfor the impatient:\n\nall you need to do is to put the decorated function into another module, not in the main program.\n\nfor those who want to dive deeper :\n\n\non windows the main module is imported again (but with a name != 'main') because python is trying to simulate\na forking-like behavior on a system that doesn't support forking. multiprocessing tries to create an environment\nsimilar to your main process by importing the main module again with a different name. thats why you need to shield\nthe entry point of your program with the famous \" if __name__ == '__main__': \"\n\n.. code-block:: py\n\n    import lib_foo\n\n    def some_module():\n        lib_foo.function_foo()\n\n    def main():\n        some_module()\n\n\n    # here the subprocess stops loading, because __name__ is not '__main__'\n    if __name__ = '__main__':\n        main()\n\nthis is a problem of windows os, because the windows operating system does not support \"fork\"\n\nyou can find more information on that here:\n\nhttps://stackoverflow.com/questions/45110287/workaround-for-using-name-main-in-python-multiprocessing\n\nhttps://docs.python.org/2/library/multiprocessing.html#windows\n\nsince main.py is loaded again with a different name but \"__main__\", the decorated function now points to objects that do not exist anymore, therefore you need to put the decorated classes and functions into another module.\nin general (especially on windows) , the main() program should not have anything but the main function, the real thing should happen in the modules.\ni am also used to put all settings or configurations in a different file - so all processes or threads can access them (and also to keep them in one place together, not to forget typing hints and name completion in your favorite editor)\n\nthe \"dill\" serializer is able to serialize also the __main__ context, that means the objects in our example are pickled to \"__main__.lib_foo\", \"__main__.some_module\",\"__main__.main\" etc.\nwe would not have this limitation when using \"pickle\" with the downside that \"pickle\" can not serialize following types:\n\nfunctions with yields, nested functions, lambdas, cell, method, unboundmethod, module, code, methodwrapper,\ndictproxy, methoddescriptor, getsetdescriptor, memberdescriptor, wrapperdescriptor, xrange, slice,\nnotimplemented, ellipsis, quit\n\nadditional dill supports:\n\nsave and load python interpreter sessions, save and extract the source code from functions and classes, interactively diagnose pickling errors\n\nto support more types with the decorator, we selected dill as serializer, with the small downside that methods and classes can not be decorated in the __main__ context, but need to reside in a module.\n\nyou can find more information on that here:\nhttps://stackoverflow.com/questions/45616584/serializing-an-object-in-main-with-pickle-or-dill\n\n**timing :** since spawning takes some unknown timespan (all imports needs to be done again !), you can specify when the timeout should start, please read the section `hard timeout`_\n\nhere an example that will work on linux but wont work on windows (the variable \"name\" and the function \"sleep\" wont be found in the spawned process :\n\n\n.. code-block:: py\n\n    main.py:\n\n    from time import sleep\n    from wrapt_timeout_decorator import *\n\n    name=\"my_var_name\"\n\n    @timeout(5, use_signals=false)\n    def mytest():\n        # this example does not work on windows, please check the example below !\n        # you need to move this function into a module to be able to run it on windows.\n        print(\"start \", name)\n        for i in range(1,10):\n            sleep(1)\n            print(\"{} seconds have passed\".format(i))\n        return i\n\n\n    if __name__ == '__main__':\n        mytest()\n\n\nhere the same example, which will work on windows:\n\n\n.. code-block:: py\n\n\n    # my_program_main.py:\n\n    import lib_test\n\n    def main():\n        lib_test.mytest()\n\n    if __name__ == '__main__':\n        main()\n\n\n.. code-block:: py\n\n\n        # conf_my_program.py:\n\n        class confmyprogram(object):\n            def __init__(self):\n                self.name:str = 'my_var_name'\n\n        conf_my_program = confmyprogram()\n\n\n.. code-block:: py\n\n    # lib_test.py:\n\n    from wrapt_timeout_decorator import *\n    from time import sleep\n    from conf_my_program import conf_my_program\n\n    # use_signals = false is not really necessary here, it is set automatically under windows\n    # but you can force not to use signals under linux\n    @timeout(5, use_signals=false)\n    def mytest():\n        print(\"start \", conf_my_program.name)\n        for i in range(1,10):\n            sleep(1)\n            print(\"{} seconds have passed\".format(i))\n        return i\n\ncaveats using signals\n---------------------\n\nas abadger1999 `points out in his blog <https://anonbadger.wordpress.com/2018/12/15/python-signal-handlers-and-exceptions/>`_\nusing signals and the timeoutexception is probably not the best idea - because it can be catched in the decorated function.\n\nof course you can use your own exception, derived from the base exception class, but the code might still not work as expected -\nsee the next example - you may try it out in `jupyter <https://mybinder.org/v2/gh/bitranox/wrapt_timeout_decorator/master?filepath=jupyter_test_{repository}.ipynb>`_:\n\n.. code-block:: py\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    # caveats when using signals - the timeouterror raised by the signal may be catched\n    # inside the decorated function.\n    # so you might use your own exception, derived from the base exception class.\n    # in python-3.7.1 stdlib there are over 300 pieces of code that will catch your timeout\n    # if you were to base an exception on exception. if you base your exception on baseexception,\n    # there are still 231 places that can potentially catch your exception.\n    # you should use use_signals=false if you want to make sure that the timeout is handled correctly !\n    # therefore the default value for use_signals = false on this decorator !\n\n    @timeout(5, use_signals=true)\n    def mytest(message):\n        try:\n            print(message)\n            for i in range(1,10):\n                time.sleep(1)\n                print('{} seconds have passed - lets assume we read a big file here'.format(i))\n        # timeouterror is a subclass of oserror - therefore it is catched here !\n        except oserror:\n            for i in range(1,10):\n                time.sleep(1)\n                print('whats going on here ? - ooops the timeout exception is catched by the oserror ! {}'.format(i))\n        except exception:\n            # even worse !\n            pass\n        except:\n            # the worst - and exists more then 300x in actual python 3.7 stdlib code !\n            # so you never really can rely that you catch the timeouterror when using signals !\n            pass\n\n\n    if __name__ == '__main__':\n        try:\n            mytest('starting')\n            print('no timeout occured')\n        except timeouterror():\n            # this will never be printed because the decorated function catches implicitly the timeouterror !\n            print('timeout occured')\n\ncaveats using multiprocessing\n-----------------------------\n\nby default we use multiprocessing to archive the timeout function.\n\nbasically this is done like that :\n\n- the program is forked\n    - on windows hat might take a long time\n    - the __main__ context needs to be guarded (see section usage with windows)\n    - on windows the function code itself and all arguments need to be pickable (we use dill to offer more types here)\n    - function parameters and function results needs to be pickable\n    - bear in mind that if code run in a child process tries to access a global variable,\n      then the value it sees (if any) may not be the same as the value in\n      the parent process at the time that process was called.\n      however, global variables which are just module level constants cause no problems.\n\n- the forked function is run in a subprocess\n- parameters and results are passed via pipe (pickled, we use dill here)\n- if there is no result within the timeout period, the forked process will be terminated with sigterm\n    - the subprocess needs to be able to terminate, so you must not disable the sigterm handler\n\nnested timeouts\n----------------\n\nsince there is only one alarm signal on unix per process, you need to use use_signals = false for nested timeouts.\nthe outmost decorator might use signals, all nested decorators needs to use use_signals=false (the default)\nyou may try it out in `jupyter <https://mybinder.org/v2/gh/bitranox/wrapt_timeout_decorator/master?filepath=jupyter_test_{repository}.ipynb>`_:\n\n.. code-block:: py\n\n    # main.py\n    import mylib\n\n    # this example will work on windows and linux\n    # since the decorated function is not in the __main__ scope but in another module !\n\n    if __name__ == '__main__':\n    mylib.outer()\n\n\n.. code-block:: py\n\n    # mylib.py\n    from wrapt_timeout_decorator import *\n    import time\n\n    # this example will work on windows and linux\n    # since the decorated function is not in the __main__ scope but in another module !\n\n    @timeout(1, use_signals=true)\n    def outer():\n        inner()\n\n    @timeout(5)\n    def inner():\n        time.sleep(3)\n        print(\"should never be printed if you call outer()\")\n\nalternative exception\n---------------------\n\nspecify an alternate exception to raise on timeout:\n\n.. code-block:: py\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    @timeout(5, timeout_exception=stopiteration)\n    def mytest(message):\n        # this example does not work on windows, please check the section\n        # \"use with windows\" in the readme.rst\n        print(message)\n        for i in range(1,10):\n            time.sleep(1)\n            print('{} seconds have passed'.format(i))\n\n    if __name__ == '__main__':\n        mytest('starting')\n\nparameters\n----------\n\n.. code-block:: py\n\n    @timeout(dec_timeout, use_signals, timeout_exception, exception_message, dec_allow_eval, dec_hard_timeout)\n    def decorated_function(*args, **kwargs):\n        # interesting things happens here ...\n        ...\n\n    \"\"\"\n    dec_timeout         the timeout period in seconds, or a string that can be evaluated when dec_allow_eval = true\n                        type: float, integer or string\n                        default: none (no timeout set)\n                        can be overridden by passing the kwarg dec_timeout to the decorated function*\n\n    use_signals         if to use signals (linux, osx) to realize the timeout. the most accurate method but with caveats.\n                        by default the wrapt timeout decorator does not use signals !\n                        please note that signals can only be used in the main thread and only on linux. in all other cases\n                        (not the main thread, or under windows) signals cant be used anyway and will be disabled automatically.\n                        in general you dont need to set use_signals yourself.\n                        please read the sections - `caveats using signals` and `caveats using multiprocessing`\n                        type: boolean\n                        default: false\n                        can be overridden by passing the kwarg use_signals to the decorated function*\n\n    timeout_exception   the exception that will be raised if a timeout occurs.\n                        type: exception\n                        default: timeouterror, on python < 3.3: assertion error (since timeouterror does not exist on that python versions)\n\n    exception_message   custom exception message.\n                        type: str\n                        default : 'function {function_name} timed out after {dec_timeout} seconds' (will be formatted)\n\n    dec_allow_eval      will allow to evaluate the parameter dec_timeout.\n                        if enabled, the parameter of the function dec_timeout, or the parameter passed\n                        by kwarg dec_timeout will be evaluated if its type is string. you can access :\n                        wrapped (the decorated function object and all the exposed objects below)\n                        instance    example: 'instance.x' - see example above or doku\n                        args        example: 'args[0]' - the timeout is the first argument in args\n                        kwargs      example: 'kwargs[\"max_time\"] * 2'\n                        type: bool\n                        default: false\n                        can be overridden by passing the kwarg dec_allow_eval to the decorated function*\n\n    dec_hard_timeout    only relevant when signals can not be used. in that case a new process needs to be created.\n                        the creation of the process on windows might take 0.5 seconds and more, depending on the size\n                        of the main module and modules to be imported. especially useful for small timeout periods.\n\n                        dec_hard_timeout = true : the decorated function will time out after dec_timeout, no matter what -\n                        that means if you set 0.1 seconds here, the subprocess can not be created in that time and the\n                        function will always time out and never run.\n\n                        dec_hard_timeout = false : the decorated function will time out after the called function\n                        is allowed to run for dec_timeout seconds. the time needed to create that process is not considered.\n                        that means if you set 0.1 seconds here, and the time to create the subprocess is 0.5 seconds,\n                        the decorated function will time out after 0.6 seconds in total, allowing the decorated function to run\n                        for 0.1 seconds.\n\n                        type: bool\n                        default: false\n                        can be overridden by passing the kwarg dec_hard_timeout to the decorated function*\n\n    * that means the decorated_function must not use that kwarg itself, since this kwarg will be popped from the kwargs\n    \"\"\"\n\noverride parameters\n-------------------\n\ndecorator parameters starting with \\dec_* and use_signals can be overridden by kwargs with the same name :\n\n.. code-block:: py\n\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    @timeout(dec_timeout=5, use_signals=false)\n    def mytest(message):\n        # this example does not work on windows, please check the section\n        # \"use with windows\" in the readme.rst\n        print(message)\n        for i in range(1,10):\n            time.sleep(1)\n            print('{} seconds have passed'.format(i))\n\n    if __name__ == '__main__':\n        mytest('starting',dec_timeout=12)   # override the decorators setting. the kwarg dec_timeout will be not\n                                            # passed to the decorated function.\n\nmultithreading\n--------------\n\nby default, timeout-decorator uses signals to limit the execution time\nof the given function. this approach does not work if your function is\nexecuted not in the main thread (for example if it's a worker thread of\nthe web application) or when the operating system does not support signals (aka windows).\nthere is an alternative timeout strategy for this case - by using multiprocessing.\nthis is done automatically, so you dont need to set ``use_signals=false``.\nyou can force not to use signals on linux by passing the parameter ``use_signals=false`` to the timeout\ndecorator function for testing. if your program should (also) run on windows, i recommend to test under\nwindows, since windows does not support forking (read more under section ``use with windows``).\nthe following code will run on linux but not on windows :\n\n.. code-block:: py\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    @timeout(5, use_signals=false)\n    def mytest(message):\n        # this example does not work on windows, please check the section\n        # \"use with windows\" in the readme.rst\n        print(message)\n        for i in range(1,10):\n            time.sleep(1)\n            print('{} seconds have passed'.format(i))\n\n    if __name__ == '__main__':\n        mytest('starting')\n\n.. warning::\n    make sure that in case of multiprocessing strategy for timeout, your function does not return objects which cannot\n    be pickled, otherwise it will fail at marshalling it between master and child processes. to cover more cases,\n    we use multiprocess and dill instead of multiprocessing and pickle.\n\n    since signals will not work on windows, it is disabled by default, whatever you set.\n\n\nsubprocess monitoring\n---------------------\n\nwhen using multiprocessing, the subprocess is monitored if it is still alive.\nif the subprocess was terminated or killed (for instance by oomkiller),\n``multiprocessing.context.processerror`` will be raised.\nby default the subprocess is monitored every 5 seconds, but can be set with parameter\n``dec_poll_subprocess``. polling can be turned off by setting to 0.0 seconds\n\n.. code-block:: python\n\n    from wrapt_timeout_decorator import timeout\n\n\n    @timeout(10, use_signals=false, timeout_exception=timeouterror, dec_poll_subprocess=1)\n    def slow_process() -> none:\n        # should have enough time to finish\n        # but instead it gets terminated, and the\n        # poll the subprocess every second\n        logger.error(f\"slow process started at {get_str_time()}\")\n        time.sleep(5)\n        logger.error(f\"slow process done at {get_str_time()}\")\n\n\n    def fake_oom_killer() -> none:\n        logger.error(f\"fake oomkiller started at {get_str_time()}\")\n        time.sleep(2)\n        # kill sibling slow_process\n        # hacky way to find it\n        target = psutil.process().parent().children(recursive=true)[-1]\n        target.kill()\n        logger.error(f\"killed {target.pid} at {get_str_time()}\")\n\n\n    def start_processes() -> none:\n        \"\"\"\n        starts the 'fake_oom_killer' and 'slow_process' process -\n        and kill 'slow_process' after two seconds\n\n        >>> start_processes()\n        traceback (most recent call last):\n            ...\n        multiprocessing.context.processerror: function slow_process was terminated or killed after ... seconds\n        \"\"\"\n        process_oom_killer = multiprocessing.process(target=fake_oom_killer, args=())\n        process_oom_killer.start()\n        slow_process()\n        process_oom_killer.join()\n\n\n    def get_str_time() -> str:\n        t = time.localtime()\n        current_time = time.strftime(\"%h:%m:%s\", t)\n        return current_time\n\n\n    if __name__ == '__main__':\n        start_processes()\n\nuse as function not as decorator\n--------------------------------\n\nyou can use the timout also as function, without using as decorator:\n\n.. code-block:: py\n\n    import time\n    from wrapt_timeout_decorator import *\n\n    def mytest(message):\n        print(message)\n        for i in range(1,10):\n            time.sleep(1)\n            print('{} seconds have passed'.format(i))\n\n    if __name__ == '__main__':\n        timeout(dec_timeout=5)(mytest)('starting')\n\nuse powerful eval function\n--------------------------\n\nthis is very powerful, but can be also very dangerous if you accept strings to evaluate from untrusted input.\n\nread: https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html\n\nif enabled, the parameter of the function dec_timeout, or the parameter passed by kwarg dec_timeout will\nbe evaluated if its type is string.\n\nyou can access :\n\n- \"wrapped\"\n   (the decorated function and its attributes)\n\n- \"instance\"\n   example: 'instance.x' - an attribute of the instance of the class instance\n\n- \"args\"\n   example: 'args[0]' - the timeout is the first argument in args\n\n- \"kwargs\"\n   example: 'kwargs[\"max_time\"] * 2'\n\n- and of course all attributes you can think of - that makes it powerful but dangerous.\n   by default allow_eval is disabled - but you can enable it in order to cover some edge cases without\n   modifying the timeout decorator.\n\n\n.. code-block:: py\n\n    # this example does not work on windows, please check the section\n    # \"use with windows\" in the readme.rst\n    def class funnymemes(object):\n        def __init__(self,x):\n            self.x=x\n\n        @timeout('instance.x', dec_allow_eval=true)\n        def swallow(self):\n            while true:\n                time.sleep(0.5)\n                print('swallow')\n\n        @timeout(1)\n        def parrot(self):\n            while true:\n                time.sleep(0.5)\n                print('parrot')\n\n        @timeout(dec_timeout='args[0] + kwargs.pop(\"more_time\",0)', dec_allow_eval=true)\n        def knight(self,base_delay):\n            while true:\n                time.sleep(base_delay)\n                print('knight')\n\n\n    def main():\n        my_memes = funnymemes(2)\n        my_memes.swallow()                                                      # this will time out after 2 seconds\n        my_memes.swallow(dec_timeout='instance.x * 2 + 1')                      # this will time out after 5 seconds\n        my_memes.parrot(dec_timeout='instance.x * 2 + 1', dec_allow_eval=true)  # this will time out after 5 seconds\n        my_memes.knight(1,more_time=4)                                          # this will time out after 5 seconds\n\n    if __name__ == '__main__':\n        main()\n\ndetect pickle errors\n--------------------\n\nremember that decorated functions (and their results !) needs to be pickable under windows. in order to detect pickle problems you can use :\n\n.. code-block:: py\n\n    from wrapt_timeout_decorator import *\n    # always remember that the \"object_to_pickle\" should not be defined within the main context\n    detect_unpickable_objects(object_to_pickle, dill_trace=true)  # type: (any, bool) -> dict\n\nlogging in decorated functions\n------------------------------\n\nwhen signals=false (on windows), logging in the wrapped function can be tricky. since a new process is\ncreated, we can not use the logger object of the main process. further development is needed to\nconnect to the main process logger via a socket or queue.\n\nwhen the wrapped function is using logger=logging.getlogger(), a new logger object is created.\nsetting up that logger can be tricky (file logging from two processes is not supported ...)\ni think i will use a socket to implement that (sockethandler and some receiver thread)\n\nuntil then, you need to set up your own new logger in the decorated function, if logging is needed.\nagain - keep in mind that you can not write to the same logfile from different processes !\n(although there are logging modules which can do that)\n\nhard timeout\n------------\n\nwhen use_signals = false (this is the only method available on windows), the timeout function is realized by starting\nanother process and terminate that process after the given timeout.\nunder linux fork() of a new process is very fast, under windows it might take some considerable time,\nbecause the main context needs to be reloaded on spawn().\nspawning of a small module might take something like 0.5 seconds and more.\n\nby default, when using signals=false, the timeout begins after the new process is created.\n\nthis means that the timeout given, is the time the decorated process is allowed to run, not included the time excluding the time to setup the process itself.\nthis is especially important if you use small timeout periods :\n\nfor instance:\n\n\n.. code-block:: py\n\n    @timeout(0.1)\n    def test():\n        time.sleep(0.2)\n\n\nthe total time to timeout on linux with use_signals = false will be around 0.1 seconds, but on windows this can take\nabout 0.6 seconds: 0.5 seconds to spawn the new process, and giving the function test() 0.1 seconds to run !\n\nif you need that a decorated function should timeout exactly** after the given timeout period, you can pass\nthe parameter dec_hard_timeout=true. in this case the called function will timeout exactly** after the given time,\nno matter how long it took to spawn the process itself. in that case, if you set up the timeout too short,\nthe process might never run and will always timeout during spawning.\n\n** well, more or less exactly - it still takes some short time to return from the spawned process - so be extra cautious on very short timeouts !\n\nmypy testing\n------------\nfor local mypy testing please make sure that the stub file \"wrapt.pyi\" is in in the mypy path (once!), in order to preserve the decorated function signature.\n\nusage from commandline\n------------------------\n\n.. code-block::\n\n   usage: wrapt_timeout_decorator [options] command [args]...\n\n     the better timout decorator\n\n   options:\n     --version                     show the version and exit.\n     --traceback / --no-traceback  return traceback information on cli\n     -h, --help                    show this message and exit.\n\n   commands:\n     info  get program informations\n\ninstallation and upgrade\n------------------------\n\n- before you start, its highly recommended to update pip and setup tools:\n\n\n.. code-block::\n\n    python -m pip --upgrade pip\n    python -m pip --upgrade setuptools\n\n- to install the latest release from pypi via pip (recommended):\n\n.. code-block::\n\n    python -m pip install --upgrade wrapt_timeout_decorator\n\n\n- to install the latest release from pypi via pip, including test dependencies:\n\n.. code-block::\n\n    python -m pip install --upgrade wrapt_timeout_decorator[test]\n\n- to install the latest version from github via pip:\n\n\n.. code-block::\n\n    python -m pip install --upgrade git+https://github.com/bitranox/wrapt_timeout_decorator.git\n\n\n- include it into your requirements.txt:\n\n.. code-block::\n\n    # insert following line in your requirements.txt:\n    # for the latest release on pypi:\n    wrapt_timeout_decorator\n\n    # for the latest development version :\n    wrapt_timeout_decorator @ git+https://github.com/bitranox/wrapt_timeout_decorator.git\n\n    # to install and upgrade all modules mentioned in requirements.txt:\n    python -m pip install --upgrade -r /<path>/requirements.txt\n\n\n- to install the latest development version, including test dependencies from source code:\n\n.. code-block::\n\n    # cd ~\n    $ git clone https://github.com/bitranox/wrapt_timeout_decorator.git\n    $ cd wrapt_timeout_decorator\n    python -m pip install -e .[test]\n\n- via makefile:\n  makefiles are a very convenient way to install. here we can do much more,\n  like installing virtual environments, clean caches and so on.\n\n.. code-block:: shell\n\n    # from your shell's homedirectory:\n    $ git clone https://github.com/bitranox/wrapt_timeout_decorator.git\n    $ cd wrapt_timeout_decorator\n\n    # to run the tests:\n    $ make test\n\n    # to install the package\n    $ make install\n\n    # to clean the package\n    $ make clean\n\n    # uninstall the package\n    $ make uninstall\n\nrequirements\n------------\nfollowing modules will be automatically installed :\n\n.. code-block:: bash\n\n    ## project requirements\n    cli_exit_tools\n    lib_detect_testenv\n\n    # class decorators are failing on windows with dill 0.3.5, 0.3.5.1\n    dill>0.3.0,!=0.3.5,!=0.3.5.1;sys_platform==\"win32\"\n    dill;sys_platform!=\"win32\"\n    multiprocess\n    psutil\n    wrapt\n\nacknowledgements\n----------------\n\n- special thanks to \"uncle bob\" robert c. martin, especially for his books on \"clean code\" and \"clean architecture\"\n\ncontribute\n----------\n\ni would love for you to fork and send me pull request for this project.\n- `please contribute <https://github.com/bitranox/wrapt_timeout_decorator/blob/master/contributing.md>`_\n\nlicense\n-------\n\nthis software is licensed under the `mit license <http://en.wikipedia.org/wiki/mit_license>`_\n\n---\n\nchangelog\n=========\n\nv1.4.0\n---------\n2023-07-13:\n    - check for killed child processes (for instance by oomkiller)\n    - change dill requirements for windows\n    - require minimum python 3.8\n    - remove python 3.7 tests\n    - introduce pep517 packaging standard\n    - introduce pyproject.toml build-system\n    - remove mypy.ini\n    - remove pytest.ini\n    - remove setup.cfg\n    - remove setup.py\n    - remove .bettercodehub.yml\n    - remove .travis.yml\n    - update black config\n    - clean ./tests/test_cli.py\n    - add codeql badge\n    - move 3rd_party_stubs outside the src directory to ``./.3rd_party_stubs``\n    - add pypy 3.10 tests\n    - add python 3.12-dev tests\n\nv1.3.12.2\n---------\n2022-06-01: update to github actions checkout@v3 and setup-python@v3\n\nv1.3.12\n--------\n2022-05-23: update requirements.txt\n\nv1.3.11\n--------\n2022-05-23:\n    - set dill version < 0.3.5 on windows, because decorating class methods fails with dill 0.3.5 upwards\n    - update tests to the latest python versions\n\nv1.3.10\n--------\n2022-04-26: add tests for thread lock\n\nv1.3.9\n--------\n2022-04-26: preserve signature of the decorator\n\nv1.3.8\n--------\n2022-03-29: remedy mypy untyped decorator makes function \"cli_info\" untyped\n\nv1.3.7\n--------\n2022-03-28: extend time on test_timeout_decorator_arg - github macos seems to be slow, so sometimes that test fails\n\nv1.3.6\n--------\n2022-03-25: fix github actions windows test\n\nv1.3.4\n-------\n2022-03-23: extend time on test_timeout_ok_timeout_as_kwarg - github macos seems to be slow, so sometimes that test fails\n\nv1.3.3\n-------\n2022-03-10: extend time on test_timeout_alternate_exception - github macos seems to be slow, so sometimes that test fails\n\nv1.3.2\n-------\n2022-03-01: github actions pipeline, codestyle black, fix requirements\n\nv1.3.1\n-------\n2019-09-02: strict mypy static type checking, housekeeping\n\nv1.3.0\n-------\n2019-05-03: pointing out caveats when using signals, the decorator defaults now to not using signals !\n\nv1.2.9\n-------\n2019-05-03: support nested decorators, mypy static type checking\n\nv1.2.8\n-------\n2019-04-23: import multiprocess as multiprocess, not as multiprocessing - that might brake other packages\n\nv1.2.0\n------\n2019-04-09: initial pypi release\n\nv1.1.0\n-------\n2019-04-03: added pickle analyze convenience function\n\nv1.0.9\n-------\n2019-03-27: added osx and windows tests, added parameter dec_hard_timeout for windows, 100% code coverage\n\nv1.0.8\n-------\n2019-02-26: complete refractoring and code cleaning\n\nv1.0.7\n-------\n2019-02-25:  fix pickle detection, added some tests, codecov now correctly combining the coverage of all tests\n\nv1.0.6\n-------\n2019-02-24: fix pickle detection when use_signals = false, drop python2.6 support since wrapt dropped it.\n\nv1.0.5\n-------\n2018-09-13: use multiprocessing.pipe instead of queue\nif we are not able to use signals, we need to spawn a new process.\nthis was done in the past by pickling the target function and put it on a queue -\nnow this is done with a half-duplex pipe.\n\n- it is faster\n- it probably can work on amazon aws, since there you must not use queues\n\nv1.0.4\n-------\n2017-12-02: automatic detection if we are in the main thread. signals can only be used in the main thread. if the decorator is running in a subthread, we automatically disable signals.\n\nv1.0.3\n-------\n2017-11-30: using dill and multiprocess to enhance windows functionality\n\nv1.0.0\n-------\n2017-11-10: initial public release\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "wrapt-timeout-decorator",
  "package_url": "https://pypi.org/project/wrapt-timeout-decorator/",
  "project_url": "https://pypi.org/project/wrapt-timeout-decorator/",
  "project_urls": {
    "Changelog": "https://github.com/bitranox/wrapt_timeout_decorator/blob/master/CHANGES.rst",
    "Documentation": "https://github.com/bitranox/wrapt_timeout_decorator/blob/master/README.rst",
    "Homepage": "https://github.com/bitranox/wrapt_timeout_decorator",
    "Repository": "https://github.com/bitranox/wrapt_timeout_decorator.git"
  },
  "release_url": "https://pypi.org/project/wrapt-timeout-decorator/1.4.0/",
  "requires_dist": [
    "cli-exit-tools",
    "lib-detect-testenv",
    "multiprocess",
    "psutil",
    "wrapt",
    "dill ; sys_platform != \"win32\"",
    "dill (!=0.3.5,!=0.3.5.1,>0.3.0) ; sys_platform == \"win32\"",
    "black ; extra == 'test'",
    "codecov ; extra == 'test'",
    "coloredlogs ; extra == 'test'",
    "coverage ; extra == 'test'",
    "flake8 ; extra == 'test'",
    "pytest ; extra == 'test'",
    "pytest-cov ; extra == 'test'",
    "pytest-runner ; extra == 'test'",
    "readme-renderer ; extra == 'test'",
    "mypy ; (platform_python_implementation != \"PyPy\") and extra == 'test'"
  ],
  "requires_python": ">=3.8.0",
  "summary": "the better timout decorator",
  "version": "1.4.0",
  "releases": [],
  "developers": [
    "bitranox@gmail.com"
  ],
  "kwds": "wrapt_timeout_decorator test_timeout_decorator_arg build_badge test_timeout_ok_timeout_as_kwarg timeouterror",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_wrapt_timeout_decorator",
  "homepage": "",
  "release_count": 16,
  "dependency_ids": [
    "pypi_black",
    "pypi_cli_exit_tools",
    "pypi_codecov",
    "pypi_coloredlogs",
    "pypi_coverage",
    "pypi_dill",
    "pypi_flake8",
    "pypi_lib_detect_testenv",
    "pypi_multiprocess",
    "pypi_mypy",
    "pypi_psutil",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_runner",
    "pypi_readme_renderer",
    "pypi_wrapt"
  ]
}