{
  "classifiers": [],
  "description": "\n=====\nedlib\n=====\n\nlightweight, super fast library for sequence alignment using edit (levenshtein) distance.\n\npopular use cases: aligning dna sequences, calculating word/text similarity.\n\n\n.. code:: python\n\n    edlib.align(\"elephant\", \"telephone\")\n    # {'locations': [(none, 8)], 'cigar': none, 'alphabetlength': 8, 'editdistance': 3}\n\n    # works with unicode characters (or any other iterable of hashable objects)!\n    edlib.align(\"\u0442\u044b \u043c\u0438\u043b\u0430\u044f\", \"\u0442\u044b \u0433\u0435\u043d\u0438\u0439\")\n    # {'locations': [(none, 7)], 'cigar': none, 'alphabetlength': 12, 'editdistance': 5}\n\n    edlib.align(\"aacg\", \"tcaacctg\", mode = \"hw\", task = \"path\")\n    # {'locations': [(2, 4), (2, 5)], 'cigar': '3=1i', 'alphabetlength': 4, 'editdistance': 1}\n\n    query = \"elephant\"; target = \"telephone\"\n    # note: `task` has to be \"path\" in order to get nice alignment.\n    result = edlib.align(query, target, task = \"path\")\n    nice = edlib.getnicealignment(result, query, target)\n    print(\"\\n\".join(nice.values()))\n    # -|||||.|.\n    # telephone\n    # -elephant\n\n\nedlib is actually a c/c++ library, and this package is it's wrapper for python.\npython edlib has mostly the same api as c/c++ edlib, so feel free to check out `c/c++ edlib docs <http://github.com/martinsos/edlib>`_ for more code examples, details on api and how edlib works.\n\n--------\nfeatures\n--------\n\n* calculates **edit distance**.\n* it can find **optimal alignment path** (instructions how to transform first sequence into the second sequence).\n* it can find just the **start and/or end locations of alignment path** - can be useful when speed is more important than having exact alignment path.\n* supports **multiple alignment methods**: global(**nw**), prefix(**shw**) and infix(**hw**), each of them useful for different scenarios.\n* you can **extend character equality definition**, enabling you to e.g. have wildcard characters, to have case insensitive alignment or to work with degenerate nucleotides.\n* it can easily handle small or **very large** sequences, even when finding alignment path.\n* **super fast** thanks to myers's bit-vector algorithm.\n\n**note**: **alphabet length has to be <= 256** (meaning that query and target together must have <= 256 unique values).\n\n------------\ninstallation\n------------\n::\n\n    pip install edlib\n\n---\napi\n---\n\nedlib has two functions, ``align()`` and ``getnicealignment()``:\n\nalign()\n-------\n\n.. code:: python\n\n    align(query, target, [mode], [task], [k], [additionalequalities])\n\naligns ``query`` against ``target`` with edit distance.\n\n``query`` and ``target`` can be strings, bytes, or any iterables of hashable objects, as long as all together they don't have more than 256 unique values.\n\n\noutput of ``help(edlib.align)``:\n\n.. code::\n\n    built-in function align in module edlib\n\n    align(...)\n        align query with target using edit distance.\n        @param {str or bytes or iterable of hashable objects} query, combined with target must have no more\n               than 256 unique values\n        @param {str or bytes or iterable of hashable objects} target, combined with query must have no more\n               than 256 unique values\n        @param {string} mode  optional. alignment method do be used. possible values are:\n                - 'nw' for global (default)\n                - 'hw' for infix\n                - 'shw' for prefix.\n        @param {string} task  optional. tells edlib what to calculate. the less there is to calculate,\n                the faster it is. possible value are (from fastest to slowest):\n                - 'distance' - find edit distance and end locations in target. default.\n                - 'locations' - find edit distance, end locations and start locations.\n                - 'path' - find edit distance, start and end locations and alignment path.\n        @param {int} k  optional. max edit distance to search for - the lower this value,\n                the faster is calculation. set to -1 (default) to have no limit on edit distance.\n        @param {list} additionalequalities  optional.\n                list of pairs of characters or hashable objects, where each pair defines two values as equal.\n                this way you can extend edlib's definition of equality (which is that each character is equal only\n                to itself).\n                this can be useful e.g. when you want edlib to be case insensitive, or if you want certain\n                characters to act as a wildcards.\n                set to none (default) if you do not want to extend edlib's default equality definition.\n        @return dictionary with following fields:\n                {int} editdistance  integer, -1 if it is larger than k.\n                {int} alphabetlength integer, length of unique characters in 'query' and 'target'\n                {[(int, int)]} locations  list of locations, in format [(start, end)].\n                {string} cigar  cigar is a standard format for alignment path.\n                    here we are using extended cigar format, which uses following symbols:\n                    match: '=', insertion to target: 'i', deletion from target: 'd', mismatch: 'x'.\n                    e.g. cigar of \"5=1x1=1i\" means \"5 matches, 1 mismatch, 1 match, 1 insertion (to target)\".\n\n\ngetnicealignment()\n------------------\n\n.. code:: python\n\n    getnicealignment(alignresult, query, target)\n\nrepresents alignment from ``align()`` in a visually attractive format.\n\n\noutput of ``help(edlib.getnicealignment)``:\n\n.. code::\n\n    built-in function getnicealignment in module edlib\n\n    getnicealignment(...)\n        output alignments from align() in nice format\n        @param {dictionary} alignresult, output of the method align() \n            note: the method align() requires the argument task=\"path\"\n        @param {string} query, the exact query used for alignresult\n        @param {string} target, the exact target used for alignresult\n        @param {string} gapsymbol, default \"-\"\n            string used to represent gaps in the alignment between query and target\n        @return alignment in nice format, which is human-readable visual representation of how the query and target align to each other. \n            e.g., for \"telephone\" and \"elephant\", it would look like:\n               telephone\n                |||||.|.\n               -elephant\n            it is represented as dictionary with following fields:\n              - {string} query_aligned\n              - {string} matched_aligned ('|' for match, '.' for mismatch, ' ' for insertion/deletion)\n              - {string} target_aligned\n            normally you will want to print these three in order above joined with newline character.\n\n\n\n-----\nusage\n-----\n\n\n.. code:: python\n\n    import edlib\n\n    edlib.align(\"actg\", \"cactrt\", mode=\"hw\", task=\"path\")\n    # {'locations': [(1, 3), (1, 4)], 'cigar': '3=1i', 'alphabetlength': 5, 'editdistance': 1}\n\n    # you can provide additional equalities.\n    edlib.align(\"actg\", \"cactrt\", mode=\"hw\", task=\"path\", additionalequalities=[(\"r\", \"a\"), (\"r\", \"g\")])\n    # {'locations': [(1, 4)], 'cigar': '4=', 'alphabetlength': 5, 'editdistance': 0}\n\n\n\n---------\nbenchmark\n---------\n\ni run a simple benchmark on 7 feb 2017 (using timeit, on python3) to get a feeling of how edlib compares to other python libraries: `editdistance <https://pypi.python.org/pypi/editdistance>`_ and `python-levenshtein <https://pypi.python.org/pypi/python-levenshtein>`_.\n\nas input data i used pairs of dna sequences of different lengths, where each pair has about 90% similarity.\n\n::\n\n   #1: query length: 30, target length: 30\n   edlib.align(query, target): 1.88\u00b5s\n   editdistance.eval(query, target): 1.26\u00b5s\n   levenshtein.distance(query, target): 0.43\u00b5s\n\n   #2: query length: 100, target length: 100\n   edlib.align(query, target): 3.64\u00b5s\n   editdistance.eval(query, target): 3.86\u00b5s\n   levenshtein.distance(query, target): 14.1\u00b5s\n\n   #3: query length: 1000, target length: 1000\n   edlib.align(query, target): 0.047ms\n   editdistance.eval(query, target): 5.4ms\n   levenshtein.distance(query, target): 1.9ms\n\n   #4: query length: 10000, target length: 10000\n   edlib.align(query, target): 0.0021s\n   editdistance.eval(query, target): 0.56s\n   levenshtein.distance(query, target): 0.2s\n\n   #5: query length: 50000, target length: 50000\n   edlib.align(query, target): 0.031s\n   editdistance.eval(query, target): 13.8s\n   levenshtein.distance(query, target): 5.0s\n\n----\nmore\n----\n\ncheck out `c/c++ edlib docs <http://github.com/martinsos/edlib>`_ for more information about edlib!\n\n-----------\ndevelopment\n-----------\n\ncheck out `edlib python package on github <https://github.com/martinsos/edlib/tree/master/bindings/python>`_.\n\n\n\n",
  "docs_url": null,
  "keywords": "edit distance levenshtein align sequence bioinformatics",
  "license": "mit",
  "name": "edlib",
  "package_url": "https://pypi.org/project/edlib/",
  "project_url": "https://pypi.org/project/edlib/",
  "project_urls": {
    "Homepage": "https://github.com/Martinsos/edlib"
  },
  "release_url": "https://pypi.org/project/edlib/1.3.9/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "lightweight, super fast library for sequence alignment using edit (levenshtein) distance.",
  "version": "1.3.9",
  "releases": [],
  "developers": [
    "martin_sosic",
    "sosic.martin@gmail.com"
  ],
  "kwds": "matched_aligned alignments bioinformatics alignment similarity",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_edlib",
  "homepage": "https://github.com/martinsos/edlib",
  "release_count": 18,
  "dependency_ids": []
}