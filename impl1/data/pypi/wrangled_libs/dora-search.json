{
  "classifiers": [
    "license :: osi approved :: mit license",
    "topic :: scientific/engineering :: artificial intelligence"
  ],
  "description": "# dora the explorer, a friendly experiment manager\n\n![tests badge](https://github.com/facebookresearch/dora/workflows/tests/badge.svg)\n![linter badge](https://github.com/facebookresearch/dora/workflows/linter/badge.svg)\n\n\n<p align=\"center\">\n<img src=\"./dora.png\" alt=\"dora logo, picturing a schematic dora in front of a computer.\"\nwidth=\"300px\"></p>\n\n<p align=\"center\">\n<img src=\"./demo.png\" alt=\"a demo of a dora grid search\"\nwidth=\"1000px\"></p>\n\n## table of content\n\n- [installation](#installation)\n- [introduction](#introduction)\n- [making your code compatible with dora](#making-your-code-compatible-with-dora)\n- [the `dora` command](#the-dora-command)\n- [`dora run`: running xp locally](#dora-run-running-xp-locally)\n- [`dora launch`: launching xp remotely](#dora-launch-launching-xp-remotely)\n- [`dora info`: inspecting an xp](#dora-info-inspecting-an-xp)\n- [`dora grid`: managing a grid search](#dora-grid-managing-a-grid-search)\n- [the dora api](#the-dora-api)\n- [sharing xps](#sharing-xps)\n- [advanced configuration](#advanced-configuration)\n- [contributing](#contributing)\n\n## installation\n\n```bash\n# for bleeding edge\npip install -u git+https://github.com/facebookincubator/submitit@main#egg=submitit\npip install -u git+https://git@github.com/facebookresearch/dora#egg=dora-search\n\n# for stable release\npip install -u dora-search\n```\n\n## what's up?\n\nsee [the changelog](changelog.md) for details on releases.\n\n- 2022-06-09: version 0.1.10: adding hiplot support ! updated pl support, many small fixes.\n- 2022-02-28: version 0.1.9\n- 2021-12-10: version 0.1.8: see changelog, many of small changes.\n- 2021-11-08: version 0.1.7: support for job arrays added.\n- 2021-10-20: version 0.1.6 released, bug fixes.\n- 2021-09-29: version 0.1.5 released.\n- 2021-09-07: added support for a `git_save` option. this will ensure that the project git is clean\n    and make a clone from which the experiment will run. this does not apply to `dora run` for easier\n    debugging (but you can force it with `--git_save`).\n- 2021-06-21: added support for hydra 1.1. be very careful if you update to hydra 1.1, there are some non backward compatible changes in the way group config are parsed, see [the hydra release notes](https://hydra.cc/docs/upgrades/1.0_to_1.1/default_composition_order) for more information.\n\n(fb only) if you are using dora and want to receive updates on bug fixes and new versions, ping me (@defossez) on workchat.\n\n\n## introduction\n\ndora is an experiment launching tool which provides the following features:\n\n- **grid search management:** automatic scheduling and canceling of the jobs\n    to match what is specified in the grid search files. grid search files\n    are pure python, and can contain arbitrary loops, conditions etc.\n- **deduplication:** experiments are assigned a signature based on their arguments.\n    if you ask twice for the same experiment to be ran, it won't be scheduled twice,\n    but merged to the same run. if your code handles checkpointing properly,\n    any previous run will be automatically resumed.\n- **monitoring:** dora supports basic monitoring from inside the terminal.\n    you can customize the metrics to display in the monitoring table,\n    and easily track progress, and compare runs in a grid search.\n\nsome dora concepts:\n\n- a *grid* is a python file with an `explorer` function, wrapped in a `dora.explorer`.\n    the explorer function takes a `dora.launcher` as argument. call repeatidly\n    the `dora.launcher` with a set of\n    hyper-parameters to schedule different experiments.\n- an *xp* is a specific experiment. each experiment is defined by the arguments\n    passed to the underlying experimental code, and is assigned a signature\n    based on those arguments, for easy deduplication.\n- a *signature* is the unique xp identifier, derived from its arguments.\n    you can use the signature to uniquely identity the xp across runs, and easily\n    access logs, checkpoints etc.\n- a *sheep* is the association of a slurm/submitit job, and an xp. given an xp,\n    it is always possible to retrieve the last slurm job that was associated with it.\n\n\n## making your code compatible with dora\n\nin order to derive the xp signature, dora must know about the configuration schema your project is following, as well as\nthe parsed arguments for a run.\ndora supports two backends for that : `argparse`, and `hydra`. on top of that, dora provides a smooth integration\nwith pytorch lightning for projects that uses it.\n\nin all cases, you must have a specific python package (which we will call here `myproj`),\nwith a `train` module in it, (i.e. `myproj.train` module, stored in the `myproj/train.py` file.)\n\nthe `train.py` file must contain a `main` function that is properly decorated, as explained hereafter.\n\n### argparse support\n\nhere is a template for the `train.py` file:\n\n```python\nimport argparse\nfrom dora import argparse_main, get_xp\n\nparser = argparse.argumentparser(\"mycode.train\")\n...\n\n\n@argparse_main(\n    dir=\"./where_to_store_logs_and_checkpoints\",\n    parser=parser,\n    exclude=[\"list_of_args_to_ignore_in_signature, e.g.\", \"num_workers\",\n             \"can_be_pattern_*\", \"log_*\"],\n    use_underscore=true,  # flags are --batch_size vs. --batch-size\n    git_save=false,  # if true, scheduled experiments will run from a separate clone of the repo.\n)\ndef main():\n    # no need to reparse args, you can directly access them from the current xp\n    # object.\n    xp = get_xp()\n    xp.cfg # parsed arguments\n    xp.sig  # signature for the current run\n    xp.folder  # folder for the current run, please put your checkpoint relative\n               # to this folder, so that it is automatically resumed!\n    xp.link  # link object, can send back metrics to dora\n\n    # if you load a previous checkpoint, you should always make sure\n    # that the dora link is consistent with what is in the checkpoint with\n    # history = checkpoint['history']\n    # xp.link.update_history(history)\n\n    for t in range(10):\n        xp.link.push_metrics({\"loss\": 1/(t + 1)})\n    ...\n```\n\n\n### hydra support\n\nthe template for `train.py`:\n```python\nfrom dora import hydra_main, get_xp\n\n\n@hydra_main(\n    config_path=\"./conf\",  # path where the config is stored, relative to the parent of `mycode`.\n    config_name=\"config\"  # a file `config.yaml` should exist there.\n)\ndef main(cfg):\n    xp = get_xp()\n    xp.cfg # parsed configuration\n    xp.sig  # signature for the current run\n    # hydra run folder will automatically be set to xp.folder!\n\n    xp.link  # link object, can send back metrics to dora\n    # if you load a previous checkpoint, you should always make sure\n    # that the dora link is consistent with what is in the checkpoint with\n    # history = checkpoint['history']\n    # xp.link.update_history(history)\n\n    for t in range(10):\n        xp.link.push_metrics({\"loss\": 1/(t + 1)})\n    ...\n```\n\nyou can customize `dora` behavior from the `config.yaml` file, e.g.\n\n```yaml\nmy_config: plop\nnum_workers: 40\nlogs:\n    interval: 10\n    level: info\n\ndora:\n    exclude: [\"num_workers\", \"logs.*\"]\n    dir: \"./outputs\"\n    git_save: true  # set git_save option for the project.\n```\n\n### pytorch lightning support\n\ndora supports pytorch lightning (pl) out of the box. dora will automatically\ncapture logged metrics (make sure to use `per_epoch=true`), and handles distribution\n(you should not pass `gpus=...` or `num_nodes=...` to pl).\n\n```python\nimport dora.lightning\n\n\n@dora.argparse_main(...)\ndef main():\n    xp = dora.get_xp()\n    args = xp.cfg\n    # replace pytorch lightning `trainer(...)` with the following:\n    trainer = dora.lightning.get_trainer(...)\n    # or when using argparse parsing:\n    trainer = dora.lightning.trainer_from_argparse_args(args)\n```\n\nsee [examples/pl/train.py](examples/pl/train.py) for a full example including\nautomatic reloading of the last checkpoint, logging etc.\n\n\n**important:** dora deactivates the default pl behavior of dumping a mid-epoch\ncheckpoint upon preemption, as this lead to non deterministic behavior\n(as pl would skip this epoch upon restart). dora assumes you save checkpoints\nfrom time to time (e.g. every epoch). to get back the old behavior,\npass `no_unfinished_epochs=false` to `get_trainer`. see [examples/pl/train.py](examples/pl/train.py)\nfor an example of how to implement checkpointing in a reliable manner.\n\n\n### distributed training support (non pytorch lightning)\n\ndora supports distributed training, and makes a few assumptions for you.  you should initialize distributed training through dora, by calling in your `main` function:\n\n```python\nimport dora.distrib\ndora.distrib.init()\n```\n\n**note:** this is not required for pytorch lightning users, see the pl section hereafter, everything will be setup automatically for you :)\n\n\n### git save\n\nyou can set the `git_save` option on your project, see hereafter on how to do it for either argparse or hydra\nbased projects.\nwhen this option is set, dora makes individual clones of your project repository for each experiment that is scheduled.\nthe job will then run from that clean clone. this allows both to keep track of the exact\ncode that was used for an experiment, as well as preventing code changes to impact pending, or requeued\njobs.\nif you reschedule a failed or cancelled job, the clone will however be updated with the current code.\n\nin order to use this option, your code should be able to run from a fresh clone of the repository.\nif you need to access to resources that are specified with a path relative to the original\nrepo, use `dora.to_absolute_path()`. note that this is similar to `hydra.utils.to_absolute_path()`. in fact, you can safely replace the hydra version with this one,\nas even when `git_save` is not set, the dora one automatically falls back to the hydra one (if hydra is used).\n\n**the repository must be completely clean** before scheduling remote jobs, and all files should be either\ntracked or git ignored. this is very restricive, but this makes implementing this feature\nmuch simpler and safe. also this forces good practice :)\nonly the `dora run` command can be used on a dirty repository, to allow\nfor easy debugging. for the `dora launch` and `dora grid` command, you can also use the `--no_git_save`\noption to temporarily deactivate this feature.\n\nthe clone for each experiment is located inside the `code/` subfolder inside the xp folder (which you can get with the `dora info` command for instance).\n\n\n\n## the `dora` command\n\ndora will install a `dora` command that is the main way to interact with it.\nthe `dora` command defines 4 sub-commands, detailed in the following sections:\n- `dora run`: run training code locally (e.g. for debugging).\n- `dora launch`: launch remote jobs, useful for one-off experiments.\n- `dora info`: get information on a specific job/xp, logs etc.\n- `dora grid`: launch an entire grid search defined in a grid file. only missing xp will be scheduled.\n    will also reports status and latest metrics.\n\nin order for dora to find your code, you must pass your training package\n(i.e. `mycode`) as `dora -p mycode [run|launch|grid|info]`.\nthis flag can be skipped if `mycode` is in the current working directory and is the only folder with a `train.py` file in it, in which\ncase dora will find it automatically.\nyou can also export `dora_package=mycode` to avoid having to give the `-p` flag explicitely.\n\nyou can use a different script name than `train.py` with `-m, --main_module`,\nor setting the `dora_main_module` env variable.\n\n**attention:** those flags should be specified before the `run | launch |info |grid` part: `dora -p mycode run`, not `dora run -p mycode`.\n\n### examples\n\nsee the [examples](examples/) folder for a few examples using argparse, hydra\nand pytorch lightning, in order to test the commands described here.\nto play with them, first install dora (`pip install .` from the top-level of the repo), then `cd examples`, and use `dora -p example_name ...`\nto let dora know which example to use!\n\n\n\n## `dora run`: running xp locally\n\nyou can run an xp locally with\n\n```bash\ndora run [training_args ...]\n```\n\n**warning**: for the `argparse` backend, you must insert `--` between the dora args and your own training args, i.e.:\n\n```bash\ndora run -- [training_args ...]\n```\n\n`dora run` supports two flags:\n- `-d`: distributed training using all available gpus. the master worker output will be to the shell, and other workers will be redirected to a log file in the xp folder.\n- `-f sig`: this will inject the hyper-parameters from the xp with the given sig on top of the one provided on the command line. useful to resume locally a remote job that failed.\n- `--git_save`: clone the repo inside the xp folder and execute from there. this is mostly for debugging,\n    and in general is not needed.\n\n## `dora launch`: launching xp remotely\n\ndora supports scheduling experiments on slurm. if you need to schedule many of them, then a grid file is properly better.\n\n```dora\ndora launch [--dev] [-g number_of_gpus] [training_args ...]\n```\n\ndora will automatically select the appropriate number of nodes and tasks per nodes based on the number of gpus required, as well as scale required memory.\nfor instance, if `-g 16`, dora will schedule on 2 nodes with 8 gpus each.\n\nthis command will launch the command, and immediately tail its log and monitor its progress, just like if it were running in locally.\nif you want to kill the command if you kill the local process, you can add the `-a`, `--attach` flag.\nto avoid tailing the log, just pass `--no_tail`.\n\n\nif a job already exist for the given xp, dora will not schedule a second one, but reuse the existing job.\n\nif a previous run has failed or was canceled, dora will not automatically start a new one, to give you a chance to inspect the logs.\nif you want to reschedule a run, use the `-r, --retry` flag.\n\nother flags:\n\n- `-f sig`: injects the arguments from the xp matching this signature, on top of the one provided on the command line.\n- `-r, --replace`: replace any running job (i.e. cancels, and schedules a new one).\n- `-d, --replace_done`: also reschedule a job even if a previous one completed successfully.\n- `-p, --partition partition`: partition to use.\n- `-c, --comment comment`: comment for the job (e.g. if priority is used).\n- `--clear`: cancel any previous job, clear the xp folder (i.e. delete checkpoints) and reschedule.\n\n\n## `dora info`: inspecting an xp\n\nyou can get information on an xp with the `dora info` command:\n\n```bash\ndora info [training_args ...]\ndora info -f signature\ndora info -j slurm_id\n```\n\nyou can either specify the xp by listing all of its training arguments, by passing its signature, or even the latest slurm id associated with it.\nthe info command supports a number of flags:\n- `-l`: print the entire log for the main task (this only work for remote jobs, not xp ran locally with `dora run`)\n- `-t`: tail the log for the main task.\n\n\n## `dora grid`: managing a grid search\n\nthe main benefit from dora is the ability to handle arbitarily complex grid searches.\neach *grid* is defined by a grid file, inside a `grids` package (i.e. `mycode.grids.my_grid`).\nthe grid file defines an `explorer` function, decorated by an `explorer` class.\nthe `explorer` class defines various metadata, in particular on which metrics\nto display when calling the grid command.\nthe `explorer` function takes a `dora.launcher` as an argument, and\nshould repeatidly call it to schedule experiments.\n\nhere is an example of grid search file, for instance `mycode.grids.mygrid`.\n\n```python\nfrom itertools import product\nfrom dora import explorer, launcher\n\n@explorer\ndef explorer(launcher: launcher):\n    launcher(batch_size=128)  # schedule an experiments with the given batch size.\n    # for an argparse based project, this will get converted to the `--batch_size=128` flag\n    # you can pass `use_underscore=false` to `argparse_main` to get instead `--batch-size=128`.\n\n    sub = launcher.bind(lr=0.01)  # bind some parameter value, in a new launcher\n    sub.slurm_(gpus=8)  # all jobs scheduled with `sub` will use 8 gpus.\n\n    sub()  # job with lr=0.01 and 8 gpus.\n    sub.bind_(epochs=40)  # in-place version of bind()\n    sub.slurm(partition=\"dev\")(batch_size=64)  # lr=0.01, 8 gpus, dev, bs=64 and epochs=40.\n\n    launcher.slurm_(gpus=16)  # now using 16 gpus per job, i.e. 2 full nodes.\n    # nice thing of native python, you can define arbitrary set of xp!\n    for lr, bs in product([0.1, 0.01, 0.001], [16, 32, 64]):\n        if bs > 32 and lr < 0.01:\n            # this is just too extreme, let's skip\n            continue\n        launcher(lr=lr, batch_size=bs)\n\n    # job arrays are also supported.\n    # the only limitation is that all jobs in an array must use exactly\n    # the same slurm config.\n    with launcher.job_array():\n        for seed in range(1, 100):\n            launcher(seed=seed)\n\n```\n\nyou can then call\n\n```bash\ndora grid mygrid\n```\n\nthis will do 3 thing:\n\n- any xp defined in the `explorer` function will be scheduled, if not already running\n    or completed.\n- any xp that was previously defined in the grid file, but is no longer referenced\n    will be cancelled.\n    **if you just comment one line in the grid file, the corresponding job will automatically be killed.**\n- a table containing job status and metadata as well as the latest metrics will\n    be printed every 5 minutes.\n\n### the launcher api\n\nhere is a more comprehensive description of what `launcher` object can do.\n\n- `launcher.bind_(...)`: remember the given parameters (command line option for argparse based\nproject, or overrides for hydra based ones) for future scheduling, i.e. all experiments\nlater scheduled with that launcher will have those parameters set.\n- `sub = launcher.bind(...)`: same as bind, but returns a new \"sub\" launcher, i.e. the object\n`launcher` is not changed, only experiments scheduled with `sub` will use the given params.\n`sub` also inherits from all the params already bound to its parent launcher (i.e. previous call to `launcher.bind_`).\ncreating a sub-launcher is especially recommended inside loops, to avoid leaking params to the next loop iteration.\n- `launcher(...)`: schedules an experiment with the given params, plus all the ones that have\nbeen aggregated through the various calls to `bind_` and to `bind`. this is equivalent to\n`launcher.bind(...)()`.\n- `launcher.slurm_(key=value, ...)` and `launcher.slurm(key=value, ...)`: same as `bind_` and `bind`\nbut for the slurm config (nb of gpus etc). for a list of possible options, checkout\n[slurmconf](https://facebookresearch.github.io/dora/dora/conf.html#dora.conf.slurmconfig).\n\n\nnow let us describe the format for passing parameters overrides or command line flags to\n`launcher.bind_()`, `launcher.bind()` or `launcher()`:\n\n- simple parameters (i.e. not nested) can be passed as kwargs, for instance if you have a `--batch_size` flag, you can\ndo `launcher.bind(batch_size=64)`.\n- command line flags can be explicitely passed as a list of strings, for instance `launcher.bind(['--lr=1e-4'])`.\n- a dictionary of overrides can be passed, for instance `launcher.bind({'batch_size': 64})`. note that this\nalso allows for nested keys in hydra: `launcher.bind({'model.channels': 256})`. with hydra, you can\nalso define new keys with `{'+model.activation': 'relu'}`. you must not remove keys though.\n- finally you can combine all of those (for a hydra project here):\n\n```python\nlauncher.bind(['optim.lr=1e-4'], {'model.channels': 256, 'seed': 42}, {'+model.activation': 'relu'}, batch_size=64)\n```\n\n\n### flags\n\nthe `dora grid` command supports the following flags:\n\n- `-r, --retry`: failed or cancelled xp within one grid file will\n    be rescheduled.\n- `-r, --replace`: any running xp will be replaced by a new job.\n- `-d, --replace_done`: any xp in the grid that previously completed will be rescheduled.\n- `-c, --cancel`: cancel all xps in a grid.\n- `--clear`: cancel any previous jobs, clear all xp folders (i.e. delete checkpoints) and reschedule. this will ask confirmation first, because this is quite dangerous.\n\n- `-i, --interval interval`: the table monitoring all jobs will be updated every `interval`\n    minutes, until all jobs are finished or failed.\n- `-t, --trim idx`: trim all the metrics to the number of epochs of the xp\n    with the given index inside the grid, i.e. pretend that all xps have at most\n    as many epochs as the xp with the given index.\n- `-l, --trim_last`: trim all xps to the least advanced xp i.e. if the least\n    advanced xp has only 3 epochs, show the metrics at epoch 3 for all xps.\n- `-f, --folder idx`: only print the folder of the xp with the given idnex.\n- `-l, --log idx`: print the full log of the xp with the given index.\n- `-t, --tail idx`: tail the log of the xp with the given index.\n- `--no_monitoring`: only show the table once and return.\n- `--dry_run`: only simulate actions.\n\n### patterns\n\nyou can also pass patterns to the `grid` command, for instance\n\n```\ndora grid mygrid bs=64\n```\nwill only show xps which have `bs=64` in their name. you can see the name by launching\nthe grid normally. names are heavily shorten to avoid running out of space, in particular\nnested structure will have all their components but the leaf be shorten. you\ncan negate a query with `!`, for instance `dora grid mygrid '!bs=64'` (use quotes\nbecause `!` will be interpreted by the shell otherwise).\nmultiple patterns are interpreted as logical and between them.\n\n\nnote that with the latest version (be sure to update), the `--clear`, or `-c, --cancel` flags\nwill only apply to the xp matching the pattern. similarly, only xp matching those patterns\nwill be scheduled.\n\n### explorer class\n\nthe `explorer` class allows to customize which metric to report, and with what precision. it also gives you a chance to reorganize metrics or further post process them (for instance, extracting max, min etc.).\nsee [customize metrics displayed](#customize-metrics-displayed-in-explorer) hereafter for more explanation.\n\nby convention, files starting with `_` inside the `grids` folder are ignored by dora, and are a good place to put utility code such as your custom `explorer` classes.\nfor an example with detailed comments, go checkout [the explorer classes for brainmagick](https://github.com/fairinternal/brainmagick/blob/main/bm/grids/_explorers.py#l7).\n\n### hiplot support\n\ndora supports hiplot out of the box. make sure it is installed (`pip install hiplot`), then\nyou can run\n```bash\npython -m hiplot dora.hiplot.load --port=xxxx\n```\nin the prompt, you can type any number of grid names or xp sig, separated by spaces.\nyou can customize the metrics displayed by inheriting [dora.hiplot.hiplotexplorer](https://facebookresearch.github.io/dora/dora/hiplot.html#dora.hiplot.hiplotexplorer)\nin a class inside `yourproject.grids._hiplot`. then, select your explorer with\nthe command `explorer=myexplorer` inside the hiplot prompt (along the grid names and xp\nsigs, in any order).\n\n## the dora api\n\ndora provides some api, including the possibility to run grid searches\ndirectly from an ipython notebook. see the\n[dora api](https://facebookresearch.github.io/dora/dora).\n\n### decoratedmain\n\nthe most useful class is the\n[decoratedmain](https://facebookresearch.github.io/dora/dora/main.html#dora.main.decoratedmain), which is the decorated main function in your project. you can use it\nto retrieve an [xp object](https://facebookresearch.github.io/dora/dora/xp.html#dora.xp.xp)\nfrom a list of argv, or a signature:\n\n```python\n\nfrom myproj.train import main\n\nxp = main.get_xp_from_sig('ae43f645')\nxp2 = main.get_xp_from_argv(xp.argv + ['batch_size=32'])\nxp2_name = main.get_name(xp2)  # see api in dora.names.namemixin\nwith xp2.enter():\n    # you can pretend to be in an xp with this.\n    ...\n```\n\n#### advanced customization\n\nif you want to do some advance customization of the behavior of `decoratedmain`\n(e.g. custom naming for xp, or weird parsing of flags), feel free\nto inherit `dora.main.argparsemain` or `dora.hydra.hydramain` and use your\ncustom class instead.\n\n### grid api\n\nyou can schedule and manage grids from the dora api rather than the command-line.\nthis is useful to manage xps from a notebook for instance!\nsee the [dora.grid.run_grid](https://facebookresearch.github.io/dora/dora/grid.html#dora.grid.run_grid).\nflags are passed with as an instance of  [dora.grid.rungridargs](https://facebookresearch.github.io/dora/dora/grid.html#dora.grid.rungridargs).\nsubmission rules (e.g. cancel, retry etc.) are passed as a [dora.conf.submitrules](https://facebookresearch.github.io/dora/dora/conf.html#dora.conf.submitrules).\n\n```python\nimport dora\nimport dora.grid\n\nfrom myproj.train import main\n\n\n@dora.explorer\ndef explorer(launcher):\n    launcher.slurm_(gpus=2, partition='learnlab')\n    launcher.bind_({\n        'epochs': 200,\n        'model.depth': 10,\n        'batch_size': 128\n    })\n    launcher()\n    for p in [0.005, 0.01, 0.05, 0.1]:\n        sub = launcher.bind({'task.penalty': p})\n        sub()\n        sub(lr=1e-4)\n\n\nargs = dora.grid.rungridargs(jupyter=true, monitor=false, interval=1)\nrules = dora.conf.submitrules(retry=true)  # should we reschedule failed jobs?\n# the run_grid function returns a list of sheeps\n# each sheep as 2 attributues: sheep.xp and sheep.job_id.\nsheeps = dora.grid.run_grid(main, explorer, grid_name='jupy', rules=rules, args=args)\nargs.monitor = true\nargs.jupyter = true\n# the jupyter flag will make the grid api use the display api to clear the cell\n# output and update it regularly. this one will not return until all jobs\n# are done or failed.\n# in the following, `grid_name` should be unique. it will be used\n# to determine which experiments were previously scheduled with that grid\n# and should potentially be cancelled if no longer needed.\ndora.grid.run_grid(main, explorer, grid_name='jupy', rules=rules, args=args)\n# you can retrieve the short names by using `main.get_names()`\nshort_names, ref_name = main.get_names([sheep.xp for sheep in sheeps])\n```\n\n## sharing xps\n\nat the moment, checkpoints and metrics cannot be directly shared (you can always copy\nmanually an xp folder in someone else xps folder). however, there are now two ways to share easily an xp hyper-params\nusing its signature. this is useful if you want someone else to quickly reproduce your xp!\n\n### dora `import`/`export` command\n\ngiven a list of signatures, you can export its hyper-params to a compact textual format with `dora export`:\n\n```bash\ndora export sig1 [other_sig ...]\n```\ncopy paste the given string and your teammate can import it with\n\n```bash\ndora import\n# now paste to stdin\n```\nthe command will show you the list of imported xps. once an xp is imported, you can simply run it or query hyper params\nwith `dora run -f sig`, `dora info -f sig` etc. from a grid file, you can programmatically retrieve the hyper-params from that xp, e.g.\n\n```python\nfrom myproject.train import main\n\nxp = main.get_xp_from_sig(sig)\nlauncher.bind_(xp.argv)\n```\n\n### secondary shared xps repository\n\nyou can now configure a secondary shared xps repository where only mappings from sig -> hyper params are stored. with hydra you can add\n```yaml\ndora:\n    dir: outputs\n    shared: /shared_folder/shared_xps\n```\nthen other teammates can reference any sig from an xp launched by other team members within the dora commands.\n\n\n## advanced configuration\n\n\n### setting slurm default parameters\n\nslurm configuration is detailed in [dora/conf.py](./dora/conf.py#l37).\nit is a bit different from the usual slurm config, as it tries to make it as easy as possible to change the number of gpus without requiring to manually compute the number of nodes, tasks per nodes etc.\n\n\n#### slurm config flags\n\n- `gpus (int)`: number of gpus to schedule. number of nodes\n        and tasks per nodes will be automatically inferred.\n- `mem_per_gpu (float)`: amount of memory in gb to schedule per gpus.\n- `time (int)`: maximum duration for the job in minutes.\n- `cpus_per_gpu (int)`: number of cpus per gpu, this will set\n        the `cpus_per_task` automatically, based on the\n        number of gpus and `one_task_per_node`, unless `cpus_per_task`\n        is explicitely provided.\n- `cpus_per_task (int or none)`: number of cpus per task.\n- `partition (str)`: partition name.\n- `comment (str)`: comment for the job.\n- `setup (list[str])`: list of shell commands to execute\n    before the actual command. use it for `module load`.\n- `max_num_timeout (int)`: maximum number of requeue.\n- `one_task_per_node (bool)`: if true, schedules a single task\n    per node, otherwise, will schedule one task per gpu (default is false).\n\n#### default slurm config\n\nyou can pass an instance of `slurmconfig` to `argparse_main` that will be used as the default\nconfig for all `dora launch` commands and grid files.\ngrid files can override any field defined on `slurmconfig` with the `launcher.slurm` (return new launcher) and\n`launcher.slurm_` (in-place) methods.\n\nfor hydra, the default slurm configuration is taken from the `slurm` entry in the yaml file, for instance, you can\nhave their:\n\n```yaml\nmy_param: whatever\nbatch_size: 42\n\ndora:\n    dir: outputs\n\nslurm:\n    partition: devlab\n    mem_per_gpu: 30  # this is in gb\n```\n\n### customize metrics displayed in explorer\n\nmetrics are formatted with the [treetable](https://github.com/adefossez/treetable),\nwhich is not heavily documented, but it should be easy enough to get how it works\nwith this example:\n```python\nfrom dora import explorer\nimport treetable as tt\n\n\nclass myexplorer(explorer):\n    test_metrics = ['sisnr', 'pesq']\n\n    def get_grid_metrics(self):\n        \"\"\"return the structure of the metrics that should be displayed in the tracking table.\n        \"\"\"\n        # this will return a list of `tt.group`, each group will\n        # be in separate parts of the table.\n        return [\n            tt.group(\"train\", [\n                tt.leaf(\"epoch\"),\n                tt.leaf(\"loss\", \".3f\"),  # the second argument of tt.leaf is a formatting string.\n             ], align=\">\"),  # align can be left (<) or right (>) and will apply on all\n                             # leaves inside the group.\n            tt.group(\"valid\", [\n                tt.leaf(\"best\", \".3f\"),\n                tt.leaf(\"loss\", \".3f\"),\n             ], align=\">\"),\n            tt.group(\"test\", [\n                tt.leaf(name, \".3f\")\n                for name in self.test_metrics\n             ], align=\">\")\n        ]\n        # in practice you can even have deeply nested groups etc. but honestly\n        # you probably don't need that.\n\n    def process_history(self, history):\n        \"\"\"this process the history obtained from the dora link\n        into the right format for the `get_grid_metrics()` layout.\n        this should return a dictionary, with one key per group, each\n        being a sub-dict with one key per metric.\n\n        it is fine for a key to be absent, things won't crash, and it will\n        just not show anything there in the table.\n        \"\"\"\n        train = {\n            'epoch': len(history),\n        }\n        valid = {}\n        test = {}\n        best = float('inf')\n        for metrics in history:\n            train.update(metrics['train'])\n            valid.update(metrics['valid'])\n            # let say you forgot to compute best valid loss, you can\n            # fill in it here on the fly.\n            best = min(valid['loss'], best)\n            valid['best'] = best\n\n            # the reason for having this for loop is also if some metrics\n            # are not defined with every epoch. let say you compute test metrics\n            # only every 10 epochs, then this will automatically fill the\n            # test metrics of the last epoch which evaluated them.\n            if 'test' in metrics:\n                test.update(metrics['test'])\n        return {\"train\": train, \"valid\": valid, \"test\": test}\n```\n\n## license\n\ndora is released under the mit license as found in the [license](license) file.\n\n## contributing\n\nbefore submitting any change, please run `make` to run unit tests and code linting.",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "dora-search",
  "package_url": "https://pypi.org/project/dora-search/",
  "project_url": "https://pypi.org/project/dora-search/",
  "project_urls": {
    "Homepage": "https://github.com/facebookresearch/dora"
  },
  "release_url": "https://pypi.org/project/dora-search/0.1.12/",
  "requires_dist": [],
  "requires_python": ">=3.7.0",
  "summary": "easy grid searches for ml.",
  "version": "0.1.12",
  "releases": [],
  "developers": [
    "defossez@fb.com"
  ],
  "kwds": "dora_package dora dora_main_module svg html",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_dora_search",
  "homepage": "https://github.com/facebookresearch/dora",
  "release_count": 9,
  "dependency_ids": []
}