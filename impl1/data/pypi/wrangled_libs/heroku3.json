{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6"
  ],
  "description": "heroku3.py\n==========\n\n.. image:: https://img.shields.io/pypi/v/heroku3.svg\n   :target: https://pypi.org/project/heroku3\n\n.. image:: https://circleci.com/gh/martyzz1/heroku3.py.svg?style=svg\n   :target: https://circleci.com/gh/martyzz1/heroku3.py\n\n.. image:: https://coveralls.io/repos/github/martyzz1/heroku3.py/badge.svg?branch=master\n   :target: https://coveralls.io/github/martyzz1/heroku3.py?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/setuptools.svg\n\nthis is the updated python wrapper for the heroku `api v3. <https://devcenter.heroku.com/articles/platform-api-reference>`_\nthe heroku rest api allows heroku users to manage their accounts, applications, addons, and\nother aspects related to heroku. it allows you to easily utilize the heroku\nplatform from your applications.\n\nintroduction\n============\n\nfirst instantiate a heroku_conn as above::\n\n    import heroku3\n    heroku_conn = heroku3.from_key('your_api_key')\n\ninteract with your applications::\n\n    >>> heroku_conn.apps()\n    [<app 'sharp-night-7758'>, <app 'empty-spring-4049'>, ...]\n\n    >>> app = heroku_conn.apps()['sharp-night-7758']\n\ngeneral notes on debugging\n--------------------------\n\nheroku provides some useful debugging information. this code exposes the following\n\nratelimit remaining\n~~~~~~~~~~~~~~~~~~~\n\nget the current ratelimit remaining::\n\n    num = heroku_conn.ratelimit_remaining()\n\nlast request id\n~~~~~~~~~~~~~~~\n\nget the unique id of the last request sent to heroku to give them for debugging::\n\n    id = heroku_conn.last_request_id\n\ngeneral notes about list objects\n--------------------------------\n\nthe new heroku3 api gives greater control over the interaction of the returned data. primarily this\ncentres around calls to the api which result in list objects being returned.\ne.g. multiple objects like apps, addons, releases etc.\n\nthroughout the docs you'll see references to using limit & order_by. wherever you see these, you *should* be able to use *limit*, *order_by*, *sort* and *valrange*.\n\nyou can control ordering, limits and pagination by supplying the following keywords::\n\n    order_by=<'id'|'version'>\n    limit=<num>\n    valrange=<string> - see api docs for this, this value is passed straight through to the api call *as is*.\n    sort=<'asc'|'desc'>\n\n**you'll have to investigate the api for each object's *accept-ranges* header to work out which fields can be ordered by**\n\nexamples\n~~~~~~~~\n\nlist all apps in name order::\n\n    heroku_conn.apps(order_by='name')\n\nlist the last 10 releases::\n\n    app.releases(order_by='version', limit=10, sort='desc')\n    heroku_conn.apps()['empty-spring-4049'].releases(order_by='version', limit=10, sort='desc')\n\nlist objects can be referred to directly by *any* of their primary keys too::\n\n    app = heroku_conn.apps()['myapp']\n    dyno = heroku_conn.apps()['myapp_id'].dynos()['web.1']\n    proc = heroku_conn.apps()['my_app'].process_formation()['web']\n\n**be careful if you use *limit* in a list call *and* refer directly to an primary key**\ne.g.probably stupid...::\n\n    dyno = heroku_conn.apps()['myapp'].dynos(limit=1)['web.1']\n\ngeneral notes on objects\n------------------------\n\nto find out the attributes available for a given object, look at the corresponding documentation for that object.\ne.g.\n\n`formation <https://devcenter.heroku.com/articles/platform-api-reference#formation>`_ object::\n\n    >>>print(feature.command)\n    bundle exec rails server -p $port\n\n    >>>print(feature.created_at)\n    2012-01-01t12:00:00z\n\n    >>>print(feature.id)\n    01234567-89ab-cdef-0123-456789abcdef\n\n    >>>print(feature.quantity)\n    1\n    >>>print(feature.size)\n    1\n    >>>print(feature.type)\n    web\n\n    >>>print(feature.updated_at)\n    2012-01-01t12:00:00z\n\nswitching accounts mid flow\n---------------------------\n\nit is also possible to change the underlying heroku_connection at any point on any object or listobject by creating a new heroku_conn and calling change_connection::\n\n    heroku_conn1 = heroku3.from_key('your_api_key')\n    heroku_conn2 = heroku3.from_key('another_api_key')\n    app = heroku_conn1.apps()['myapp']\n    app.change_connection(heroku_conn2)\n    app.config() # this call will use heroku_conn2\n    ## or on list objects\n    apps = heroku_conn1.apps()\n    apps.change_connection(heroku_conn2)\n    for app in apps:\n        config = app.config()\n\nlegacy api calls\n================\n\nthe api has been built with an internal legacy=true ability, so any functionlity not implemented in the new api can be called via the previous `legacy api <https://legacy-api-docs.herokuapp.com/>`_. this is currently only used for *rollbacks*.\n\nobject api\n==========\n\naccount\n-------\n\nget account::\n\n    account = heroku_conn.account()\n\nchange password::\n\n    account.change_password(\"<current_password>\", \"<new_password>\")\n\nssh keys\n~~~~~~~~\n\nlist all configured keys::\n\n    keylist = account.keys(order_by='id')\n\nadd key::\n\n    account.add_key(<public_key_string>)\n\nremove key::\n\n    account.remove_key(<public_key_string - or fingerprint>)\n\naccount features (heroku labs)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nlist all configured account \"features\"::\n\n    featurelist = account.features()\n\ndisable a feature::\n\n    feature = account.disable_feature(id_or_name)\n    feature.disable()\n\nenable a feature::\n\n    feature = account.enable_feature(id_or_name)\n    feature.enable()\n\nplans - or addon services\n-------------------------\n\nlist all available addon services::\n\n    addonlist = heroku_conn.addon_services(order_by='id')\n    addonlist = heroku_conn.addon_services()\n\nget specific available addon service::\n\n    addonservice = heroku_conn.addon_services(<id_or_name>)\n\napp\n--------\n\nthe app class is the starting point for most of the api functionlity.\n\nlist all apps::\n\n    applist = heroku_conn.apps(order_by='id')\n    applist = heroku_conn.apps()\n\nget specific app::\n\n    app = heroku_conn.app(<id_or_name>)\n    app = heroku_conn.apps()[id_or_name]\n\ncreate an app::\n\n    app = heroku_conn.create_app(name=none, stack_id_or_name='cedar', region_id_or_name=<region_id>)\n\ndestroy an app (**warning this is irreversible**)::\n\n    app.delete()\n\naddons\n~~~~~~\n\nlist all addons::\n\n    addonlist = app.addons(order_by='id')\n    addonlist = applist[<id_or_name>].addons(limit=10)\n    addonlist = heroku_conn.addons(<app_id_or_name>)\n\ninstall an addon::\n\n    addon = app.install_addon(plan_id_or_name='<id>', config={})\n    addon = app.install_addon(plan_id_or_name='<name>', config={})\n    addon = app.install_addon(plan_id_or_name=addonservice.id, config={})\n    addon = app.install_addon(plan_id_or_name=addonservice.id, config={}, attachment_name='addon_attachment_custom_name')\n\nremove an addon::\n\n    addon = app.remove_addon(<id>)\n    addon = app.remove_addon(addonservice.id)\n    addon.delete()\n\nupdate/upgrade an addon::\n\n    addon = addon.upgrade(plan_id_or_name='<name>')\n    addon = addon.upgrade(plan_id_or_name='<id>')\n\nbuildpacks\n~~~~~~~~~~~~~\n\nupdate all buildpacks::\n\n    buildpack_urls = ['https://github.com/some/buildpack', 'https://github.com/another/buildpack']\n    app.update_buildpacks(buildpack_urls)\n\n*n.b. buildpack_urls can also be empty. this clears all buildpacks.*\n\napp labs/features\n~~~~~~~~~~~~~~~~~\n\nlist all features::\n\n    appfeaturelist = app.features()\n    appfeaturelist = app.labs() #nicename for features()\n    appfeaturelist = app.features(order_by='id', limit=10)\n\nadd a feature::\n\n    appfeature = app.enable_feature(<feature_id_or_name>)\n\nremove a feature::\n\n    appfeature = app.disable_feature(<feature_id_or_name>)\n\napp transfers\n~~~~~~~~~~~~~\n\nlist all transfers::\n\n    transferlist = app.transfers()\n    transferlist = app.transfers(order_by='id', limit=10)\n\ncreate a transfer::\n\n    transfer = app.create_transfer(recipient_id_or_name=<user_id>)\n    transfer = app.create_transfer(recipient_id_or_name=<valid_email>)\n\ndelete a transfer::\n\n    deletedtransfer = app.delete_transfer(<transfer_id>)\n    deletedtransfer = transfer.delete()\n\nupdate a transfer's state::\n\n    transfer.update(state)\n    transfer.update(\"pending\")\n    transfer.update(\"declined\")\n    transfer.update(\"accepted\")\n\ncollaborators\n~~~~~~~~~~~~~\n\nlist all collaborators::\n\n    collaboratorlist = app.collaborators()\n    collaboratorlist = app.collaborators(order_by='id')\n\nadd a collaborator::\n\n    collaborator = app.add_collaborator(user_id_or_email=<valid_email>, silent=0)\n    collaborator = app.add_collaborator(user_id_or_email=user_id, silent=0)\n    collaborator = app.add_collaborator(user_id_or_email=user_id, silent=1) #don't send invitation email\n\nremove a collaborator::\n\n    collaborator = app.remove_collaborator(userid_or_email)\n\nconfigvars\n~~~~~~~~~~\n\nget an apps config::\n\n    config = app.config()\n\nadd a config variable::\n\n    config['new_var'] = 'new_val'\n\nupdate a config variable::\n\n    config['existing_var'] = 'new_val'\n\nremove a config variable::\n\n    del config['existing_var']\n    config['existing_var'] = none\n\nupdate multiple config variables::\n\n    # newconfig will always be a new configvars object representing all config values for an app\n    # i.e. there won't be partial configs\n    newconfig = config.update({u'test1': u'a1', u'test2': u'a2', u'test3': u'a3'})\n    newconfig = heroku_conn.update_appconfig(<app_id_or_name>, {u'test1': u'a1', u'test2': u'a2', u'test3': u'a3'})\n    newconfig = app.update_config({u'test1': u'a1', u'test2': u'a2', u'test3': u'a3'})\n\ncheck if a var exists::\n\n    if 'key' in config:\n        print(\"key = {0}\".format(config[key]))\n\nget dict of config vars::\n\n    my_dict = config.to_dict()\n\ndomains\n~~~~~~~\n\nget a list of domains configured for this app::\n\n    domainlist = app.domains(order_by='id')\n\nadd a domain to this app::\n\n    domain = app.add_domain('domain_hostname', 'sni_endpoint_id_or_name')\n    domain = app.add_domain('domain_hostname', none)  # domain will not be associated with an sni endpoint\n\nexample of finding a matching sni, given a domain::\n\n    domain = 'subdomain.domain.com'\n    sni_endpoint_id = none\n    for sni_endpoint in app.sni_endpoints():\n        for cert_domain in sni_endpoint.ssl_cert.cert_domains:\n            # check root or wildcard\n            if cert_domain in domain or cert_domain[1:] in domain:\n                sni_endpoint_id_or_name = sni_endpoint.id\n    domain = app.add_domain(domain, sni_endpoint_id)\n\nremove a domain from this app::\n\n    domain = app.remove_domain('domain_hostname')\n\nsni endpoints\n~~~~~~~~~~~~~\n\nget a list of sni endpoints for this app::\n\n    sni_endpoints = app.sni_endpoints()\n\nadd an sni endpoint to this app::\n\n    sni_endpoint = app.add_sni_endpoint(\n        '-----begin certificate----- ...',\n        '-----begin rsa private key----- ...'\n    )\n\nupdate an sni endpoint for this app::\n\n    sni_endpoint = app.update_sni_endpoint(\n        'sni_endpoint_id_or_name',\n        '-----begin certificate----- ...',\n        '-----begin rsa private key----- ...'\n    )\n\ndelete an sni endpoint for this app::\n\n    app.remove_sni_endpoint('sni_endpoint_id_or_name')\n\ndynos & process formations\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndynos\n_____\n\ndynos represent all your running dyno processes. use dynos to investigate whats running on your app.\nuse dynos to create one off processes/run commands.\n\n**you don't \"scale\" dyno processes. you \"scale\" formation processes. see formations section below**\n\nget a list of running dynos::\n\n    dynolist = app.dynos()\n    dynolist = app.dynos(order_by='id')\n\nkill a dyno::\n\n    app.kill_dyno(<dyno_id_or_name>)\n    app.dynos['run.1'].kill()\n    dyno.kill()\n\n**restarting your dynos is achieved by killing existing dynos, and allowing heroku to auto start them. a handy wrapper for this proceses has been provided below.**\n\n*n.b. this will only restart formation processes, it will not kill off other processes.*\n\nrestart a dyno::\n\n    #a simple wrapper around dyno.kill() with run protection so won't kill any proc of type='run' e.g. 'run.1'\n    dyno.restart()\n\nrestart all your app's formation configured dyno's::\n\n    app.restart()\n\nrun a command without attaching to it. e.g. start a command and return the dyno object representing the command::\n\n    dyno = app.run_command_detached('fab -l', size=1, env={'key': 'val'})\n    dyno = heroku_conn.run_command_on_app(<appname>, <command>, size=1, attach=false, printout=true, env={'key': 'val'})\n\nrun a command and attach to it, returning the commands output as a string::\n\n    #printout  is used to control if the task should also print to stdout - useful for long running processes\n    #size = is the processes dyno size 1x(default), 2x, 3x etc...\n    #env = envrionment variables for the dyno\n    output, dyno = heroku_conn.run_command_on_app(<appname>, <command>, size=1, attach=true, printout=true, env={'key': 'val'})\n    output = app.run_command('fab -l', size=1, printout=true, env={'key': 'val'})\n    print output\n\nformations\n__________\n\nformations represent the dynos that you have configured in your procfile - whether they are running or not.\nuse formations to scale dynos up and down\n\nget a list of your configured processes::\n\n    proclist = app.process_formation()\n    proclist = app.process_formation(order_by='id')\n    proc = app.process_formation()['web']\n    proc = heroku_conn.apps()['myapp'].process_formation()['web']\n\nscale your procfile processes::\n\n    app.process_formation()['web'].scale(2) # run 2 dynos\n    app.process_formation()['web'].scale(0) # don't run any dynos\n    proc = app.scale_formation_process(<formation_id_or_name>, <quantity>)\n\nresize your procfile processes::\n\n    app.process_formation()['web'].resize(2) # for 2x\n    app.process_formation()['web'].resize(1) # for 1x\n    proc = app.resize_formation_process(<formation_id_or_name>, <size>)\n\nlog drains\n~~~~~~~~~~\n\nlist all active logdrains::\n\n    logdrainlist = app.logdrains()\n    logdrainlist = app.logdrains(order_by='id')\n\ncreate a logdrain::\n\n    loggdrain = app.create_logdrain(<url>)\n\nremove a logdrain::\n\n    delete_logdrain - app.remove_logdrain(<id_or_url>)\n\nlog sessions\n~~~~~~~~~~~~\n\naccess the logs::\n\n    log = heroku_conn.get_app_log(<app_id_or_name>, dyno='web.1', lines=2, source='app', timeout=false)\n    log = app.get_log()\n    log = app.get_log(lines=100)\n    print(app.get_log(dyno='web.1', lines=2, source='app'))\n    2011-12-21t22:53:47+00:00 heroku[web.1]: state changed from down to created\n    2011-12-21t22:53:47+00:00 heroku[web.1]: state changed from created to starting\n\nyou can even stream the tail::\n\n    #accepts the same params as above - lines|dyno|source|timeout (passed to requests)\n    log = heroku_conn.stream_app_log(<app_id_or_name>, lines=1, timeout=100)\n    #or\n    for line in app.stream_log(lines=1):\n         print(line)\n\n    2011-12-21t22:53:47+00:00 heroku[web.1]: state changed from down to created\n    2011-12-21t22:53:47+00:00 heroku[web.1]: state changed from created to starting\n\nmaintenance mode\n~~~~~~~~~~~~~~~~\n\nenable maintenance mode::\n\n    app.enable_maintenance_mode()\n\ndisable maintenance mode::\n\n    app.disable_maintenance_mode()\n\noauth\n~~~~~\noauthauthorizations\n___________________\n\nlist all oauthauthorizations::\n\n    authorizations = heroku_conn.oauthauthorizations(order_by=id)\n\nget a specific oauthauthorization::\n\n    authorization = authorizations[<oauthauthorization_id>]\n    authorization = heroku_conn.oauthauthorization(oauthauthorization_id)\n\ncreate an oauthauthorization::\n\n    authorization = heroku_conn.oauthauthorization_create(scope, oauthclient_id=none, description=none)\n\ndelete an oauthauthorization::\n\n    authorization.delete()\n    heroku_conn.oauthauthorization_delete(oauthauthorization_id)\n\noauthclient\n___________\n\nlist all oauthclients::\n\n    clients = heroku_conn.oauthclients(order_by=id)\n\nget a specific oauthclient::\n\n    client = clients[<oauthclient_id>]\n    client = heroku_conn.oauthclient(oauthclient_id)\n\ncreate an oauthclient::\n\n    client = heroku_conn.oauthclient_create(name, redirect_uri)\n\nupdate an existing oauthclient::\n\n    client = client.update(name=none, redirect_uri=none)\n\ndelete an oauthclient::\n\n    client.delete()\n    heroku_conn.oauthclient_delete(oauthclient_id)\n\noauthtoken\n__________\n\ncreate an oauthtoken::\n\n    heroku_conn.oauthtoken_create(client_secret=none, grant_code=none, grant_type=none, refresh_token=none)\n\nrelease\n~~~~~~~\n\nlist all releases::\n\n    releaselist = app.releases()\n    releaselist = app.releases(order_by='version')\n\nrelease information::\n\n    for release in app.releases():\n        print(\"{0}-{1} released by {2} on {3}\".format(release.id, release.description, release.user.name, release.created_at))\n\nrollback to a release::\n\n    app.rollback(release.id)\n    app.rollback(\"489d7ce8-1cc3-4429-bb79-7907371d4c0e\")\n\nrename app\n~~~~~~~~~~\n\nrename app::\n\n    app.rename('carrot-kettle-teapot-1898')\n\ncustomized sessions\n-------------------\n\nheroku.py is powered by `requests <http://python-requests.org>`_ and supports all `customized sessions <http://www.python-requests.org/en/latest/user/advanced/#session-objects>`_:\n\nlogging\n-------\n\nnote: logging is now achieved by the following method::\n\n    import httplib\n    httplib.httpconnection.debuglevel = 1\n\n    logging.basicconfig() # you need to initialize logging, otherwise you will not see anything from requests\n    logging.getlogger().setlevel(logging.info)\n    requests_log = logging.getlogger(\"requests.packages.urllib3\")\n    requests_log.setlevel(logging.info)\n    requests_log.propagate = true\n\n    heroku_conn.ratelimit_remaining()\n\n    >>>info:requests.packages.urllib3.connectionpool:starting new https connection (1): api.heroku.com\n    >>>send: 'get /account/rate-limits http/1.1\\r\\nhost: api.heroku.com\\r\\nauthorization: basic zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz=\\r\\ncontent-type: application/json\\r\\naccept-encoding: gzip, deflate, compress\\r\\naccept: application/vnd.heroku+json; version=3\\r\\nuser-agent: python-requests/1.2.3 cpython/2.7.2 darwin/12.4.0\\r\\n\\r\\n'\n    >>>reply: 'http/1.1 200 ok\\r\\n'\n    >>>header: content-encoding: gzip\n    >>>header: content-type: application/json;charset=utf-8\n    >>>header: date: thu, 05 sep 2013 11:13:03 gmt\n    >>>header: oauth-scope: global\n    >>>header: oauth-scope-accepted: global identity\n    >>>header: ratelimit-remaining: 2400\n    >>>header: request-id: zzzzzz2a-b704-4bbc-bdf1-e4bc263586cb\n    >>>header: server: nginx/1.2.8\n    >>>header: status: 200 ok\n    >>>header: strict-transport-security: max-age=31536000\n    >>>header: vary: accept-encoding\n    >>>header: x-content-type-options: nosniff\n    >>>header: x-runtime: 0.032193391\n    >>>header: content-length: 44\n    >>>header: connection: keep-alive\n\ninstallation\n------------\n\nto install ``heroku3.py``, simply::\n\n    $ pip install heroku3\n\nor, if you absolutely must::\n\n    $ easy_install heroku3\n\nbut, you `really shouldn't do that <http://www.pip-installer.org/en/latest/other-tools.html#pip-compared-to-easy-install>`_.\n\nlicense\n-------\n\noriginal heroku license left intact, the code in this repository is mostly my own, but credit where credit is due and all that :)\n\ncopyright (c) 2013 heroku, inc.\n\npermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:\n\nthe above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.\n\nthe software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.\n\n\nhistory\n=======\n\n3.4.0\n-----\n* support for python 2.6 dropped\n* add tests\n* get project building on circleci/travis-ci & coveralls\n* adding slug to release models\n* bugfixes\n\n3.2.0-2\n-------\n* various fixes for python3\n* add newer features from heroku api, support for organisations\n\n3.1.4\n-----\n* bugfixes\n\n3.1.3 (2015-03-12)\n------------------\n* removed debug\n\n3.1.0 (2014-11-24)\n------------------\n* moved to heroku3 for pypi release\n* updated heroku/data/cacert.pem\n\n3.0.0 - 3.1.0\n-------------\n* add support for all of heroku's api\n* various bugfixes and enhancements\n* add documentation\n* add examples.py\n* used in production on https://www.migreat.com & https://www.migreat.co.uk since 2013-10-01\n\n3.0.0 (2013-08-28)\n------------------\n* rewrite to support v3 api\n\n* initial release.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "heroku3",
  "package_url": "https://pypi.org/project/heroku3/",
  "project_url": "https://pypi.org/project/heroku3/",
  "project_urls": {
    "Download": "https://github.com/martyzz1/heroku3.py/tarball/v5.2.1",
    "Homepage": "https://github.com/martyzz1/heroku3.py"
  },
  "release_url": "https://pypi.org/project/heroku3/5.2.1/",
  "requires_dist": [
    "requests (>=1.2.3)",
    "python-dateutil (>=2.6.0)"
  ],
  "requires_python": "",
  "summary": "heroku api wrapper.",
  "version": "5.2.1",
  "releases": [],
  "developers": [
    "martin_moss",
    "martin_moss@btinternet.com"
  ],
  "kwds": "heroku3 heroku_connection heroku herokuapp heroku_conn2",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_heroku3",
  "homepage": "https://github.com/martyzz1/heroku3.py",
  "release_count": 18,
  "dependency_ids": [
    "pypi_python_dateutil",
    "pypi_requests"
  ]
}