{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v3 (lgplv3)",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows :: windows nt/2000",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: system :: monitoring"
  ],
  "description": "pynput\n======\n\nthis library allows you to control and monitor input devices.\n\ncurrently, mouse and keyboard input and monitoring are supported.\n\nsee `here <https://pynput.readthedocs.io/en/latest/>`_ for the full\ndocumentation.\n\n\ncontrolling the mouse\n---------------------\n\nuse ``pynput.mouse.controller`` like this::\n\n    from pynput.mouse import button, controller\n\n    mouse = controller()\n\n    # read pointer position\n    print('the current pointer position is {0}'.format(\n        mouse.position))\n\n    # set pointer position\n    mouse.position = (10, 20)\n    print('now we have moved it to {0}'.format(\n        mouse.position))\n\n    # move pointer relative to current position\n    mouse.move(5, -5)\n\n    # press and release\n    mouse.press(button.left)\n    mouse.release(button.left)\n\n    # double click; this is different from pressing and releasing\n    # twice on macos\n    mouse.click(button.left, 2)\n\n    # scroll two steps down\n    mouse.scroll(0, 2)\n\n\nmonitoring the mouse\n--------------------\n\nuse ``pynput.mouse.listener`` like this::\n\n    from pynput import mouse\n\n    def on_move(x, y):\n        print('pointer moved to {0}'.format(\n            (x, y)))\n\n    def on_click(x, y, button, pressed):\n        print('{0} at {1}'.format(\n            'pressed' if pressed else 'released',\n            (x, y)))\n        if not pressed:\n            # stop listener\n            return false\n\n    def on_scroll(x, y, dx, dy):\n        print('scrolled {0} at {1}'.format(\n            'down' if dy < 0 else 'up',\n            (x, y)))\n\n    # collect events until released\n    with mouse.listener(\n            on_move=on_move,\n            on_click=on_click,\n            on_scroll=on_scroll) as listener:\n        listener.join()\n\n    # ...or, in a non-blocking fashion:\n    listener = mouse.listener(\n        on_move=on_move,\n        on_click=on_click,\n        on_scroll=on_scroll)\n    listener.start()\n\na mouse listener is a ``threading.thread``, and all callbacks will be invoked\nfrom the thread.\n\ncall ``pynput.mouse.listener.stop`` from anywhere, raise ``stopexception`` or\nreturn ``false`` from a callback to stop the listener.\n\nwhen using the non-blocking version above, the current thread will continue\nexecuting. this might be necessary when integrating with other gui frameworks\nthat incorporate a main-loop, but when run from a script, this will cause the\nprogram to terminate immediately.\n\n\nthe mouse listener thread\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe listener callbacks are invoked directly from an operating thread on some\nplatforms, notably *windows*.\n\nthis means that long running procedures and blocking operations should not be\ninvoked from the callback, as this risks freezing input for all processes.\n\na possible workaround is to just dispatch incoming messages to a queue, and let\na separate thread handle them.\n\n\nhandling mouse listener errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif a callback handler raises an exception, the listener will be stopped. since\ncallbacks run in a dedicated thread, the exceptions will not automatically be\nreraised.\n\nto be notified about callback errors, call ``thread.join`` on the listener\ninstance::\n\n    from pynput import mouse\n\n    class myexception(exception): pass\n\n    def on_click(x, y, button, pressed):\n        if button == mouse.button.left:\n            raise myexception(button)\n\n    # collect events until released\n    with mouse.listener(\n            on_click=on_click) as listener:\n        try:\n            listener.join()\n        except myexception as e:\n            print('{0} was clicked'.format(e.args[0]))\n\n\ntoggling event listening for the mouse listener\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nonce ``pynput.mouse.listener.stop`` has been called, the listener cannot be\nrestarted, since listeners are instances of ``threading.thread``.\n\nif your application requires toggling listening events, you must either add an\ninternal flag to ignore events when not required, or create a new listener when\nresuming listening.\n\n\nsynchronous event listening for the mouse listener\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nto simplify scripting, synchronous event listening is supported through the\nutility class ``pynput.mouse.events``. this class supports reading single\nevents in a non-blocking fashion, as well as iterating over all events.\n\nto read a single event, use the following code::\n\n    from pynput import mouse\n\n    # the event listener will be running in this block\n    with mouse.events() as events:\n        # block at most one second\n        event = events.get(1.0)\n        if event is none:\n            print('you did not interact with the mouse within one second')\n        else:\n            print('received event {}'.format(event))\n\nto iterate over mouse events, use the following code::\n\n    from pynput import mouse\n\n    # the event listener will be running in this block\n    with mouse.events() as events:\n        for event in events:\n            if event.button == mouse.button.right:\n                break\n            else:\n                print('received event {}'.format(event))\n\nplease note that the iterator method does not support non-blocking operation,\nso it will wait for at least one mouse event.\n\nthe events will be instances of the inner classes found in\n``pynput.mouse.events``.\n\n\nensuring consistent coordinates between listener and controller on windows\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nrecent versions of _windows_ support running legacy applications scaled when\nthe system scaling has been increased beyond 100%. this allows old applications\nto scale, albeit with a blurry look, and avoids tiny, unusable user interfaces.\n\nthis scaling is unfortunately inconsistently applied to a mouse listener and a\ncontroller: the listener will receive physical coordinates, but the controller\nhas to work with scaled coordinates.\n\nthis can be worked around by telling windows that your application is dpi\naware. this is a process global setting, so _pynput_ cannot do it\nautomatically. do enable dpi awareness, run the following code::\n\n   import ctypes\n\n\n   process_per_monitor_dpi_aware = 2\n\n   ctypes.windll.shcore.setprocessdpiawareness(process_per_monitor_dpi_aware)\n\n\ncontrolling the keyboard\n------------------------\n\nuse ``pynput.keyboard.controller`` like this::\n\n    from pynput.keyboard import key, controller\n\n    keyboard = controller()\n\n    # press and release space\n    keyboard.press(key.space)\n    keyboard.release(key.space)\n\n    # type a lower case a; this will work even if no key on the\n    # physical keyboard is labelled 'a'\n    keyboard.press('a')\n    keyboard.release('a')\n\n    # type two upper case as\n    keyboard.press('a')\n    keyboard.release('a')\n    with keyboard.pressed(key.shift):\n        keyboard.press('a')\n        keyboard.release('a')\n\n    # type 'hello world' using the shortcut type method\n    keyboard.type('hello world')\n\n\nmonitoring the keyboard\n-----------------------\n\nuse ``pynput.keyboard.listener`` like this::\n\n    from pynput import keyboard\n\n    def on_press(key):\n        try:\n            print('alphanumeric key {0} pressed'.format(\n                key.char))\n        except attributeerror:\n            print('special key {0} pressed'.format(\n                key))\n\n    def on_release(key):\n        print('{0} released'.format(\n            key))\n        if key == keyboard.key.esc:\n            # stop listener\n            return false\n\n    # collect events until released\n    with keyboard.listener(\n            on_press=on_press,\n            on_release=on_release) as listener:\n        listener.join()\n\n    # ...or, in a non-blocking fashion:\n    listener = keyboard.listener(\n        on_press=on_press,\n        on_release=on_release)\n    listener.start()\n\na keyboard listener is a ``threading.thread``, and all callbacks will be\ninvoked from the thread.\n\ncall ``pynput.keyboard.listener.stop`` from anywhere, raise ``stopexception``\nor return ``false`` from a callback to stop the listener.\n\nthe ``key`` parameter passed to callbacks is a ``pynput.keyboard.key``, for\nspecial keys, a ``pynput.keyboard.keycode`` for normal alphanumeric keys, or\njust ``none`` for unknown keys.\n\nwhen using the non-blocking version above, the current thread will continue\nexecuting. this might be necessary when integrating with other gui frameworks\nthat incorporate a main-loop, but when run from a script, this will cause the\nprogram to terminate immediately.\n\n\nthe keyboard listener thread\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe listener callbacks are invoked directly from an operating thread on some\nplatforms, notably *windows*.\n\nthis means that long running procedures and blocking operations should not be\ninvoked from the callback, as this risks freezing input for all processes.\n\na possible workaround is to just dispatch incoming messages to a queue, and let\na separate thread handle them.\n\n\nhandling keyboard listener errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif a callback handler raises an exception, the listener will be stopped. since\ncallbacks run in a dedicated thread, the exceptions will not automatically be\nreraised.\n\nto be notified about callback errors, call ``thread.join`` on the listener\ninstance::\n\n    from pynput import keyboard\n\n    class myexception(exception): pass\n\n    def on_press(key):\n        if key == keyboard.key.esc:\n            raise myexception(key)\n\n    # collect events until released\n    with keyboard.listener(\n            on_press=on_press) as listener:\n        try:\n            listener.join()\n        except myexception as e:\n            print('{0} was pressed'.format(e.args[0]))\n\n\ntoggling event listening for the keyboard listener\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nonce ``pynput.keyboard.listener.stop`` has been called, the listener cannot be\nrestarted, since listeners are instances of ``threading.thread``.\n\nif your application requires toggling listening events, you must either add an\ninternal flag to ignore events when not required, or create a new listener when\nresuming listening.\n\n\nsynchronous event listening for the keyboard listener\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nto simplify scripting, synchronous event listening is supported through the\nutility class ``pynput.keyboard.events``. this class supports reading single\nevents in a non-blocking fashion, as well as iterating over all events.\n\nto read a single event, use the following code::\n\n    from pynput import keyboard\n\n    # the event listener will be running in this block\n    with keyboard.events() as events:\n        # block at most one second\n        event = events.get(1.0)\n        if event is none:\n            print('you did not press a key within one second')\n        else:\n            print('received event {}'.format(event))\n\nto iterate over keyboard events, use the following code::\n\n    from pynput import keyboard\n\n    # the event listener will be running in this block\n    with keyboard.events() as events:\n        for event in events:\n            if event.key == keyboard.key.esc:\n                break\n            else:\n                print('received event {}'.format(event))\n\nplease note that the iterator method does not support non-blocking operation,\nso it will wait for at least one keyboard event.\n\nthe events will be instances of the inner classes found in\n``pynput.keyboard.events``.\n\n\nglobal hotkeys\n~~~~~~~~~~~~~~\n\na common use case for keyboard monitors is reacting to global hotkeys. since a\nlistener does not maintain any state, hotkeys involving multiple keys must\nstore this state somewhere.\n\n*pynput* provides the class ``pynput.keyboard.hotkey`` for this purpose. it\ncontains two methods to update the state, designed to be easily interoperable\nwith a keyboard listener: ``pynput.keyboard.hotkey.press`` and\n``pynput.keyboard.hotkey.release`` which can be directly passed as listener\ncallbacks.\n\nthe intended usage is as follows::\n\n    from pynput import keyboard\n\n    def on_activate():\n        print('global hotkey activated!')\n\n    def for_canonical(f):\n        return lambda k: f(l.canonical(k))\n\n    hotkey = keyboard.hotkey(\n        keyboard.hotkey.parse('<ctrl>+<alt>+h'),\n        on_activate)\n    with keyboard.listener(\n            on_press=for_canonical(hotkey.press),\n            on_release=for_canonical(hotkey.release)) as l:\n        l.join()\n\nthis will create a hotkey, and then use a listener to update its state. once\nall the specified keys are pressed simultaneously, ``on_activate`` will be\ninvoked.\n\nnote that keys are passed through ``pynput.keyboard.listener.canonical`` before\nbeing passed to the ``hotkey`` instance. this is to remove any modifier state\nfrom the key events, and to normalise modifiers with more than one physical\nbutton.\n\nthe method ``pynput.keyboard.hotkey.parse`` is a convenience function to\ntransform shortcut strings to key collections. please see its documentation for\nmore information.\n\nto register a number of global hotkeys, use the convenience class\n``pynput.keyboard.globalhotkeys``::\n\n    from pynput import keyboard\n\n    def on_activate_h():\n        print('<ctrl>+<alt>+h pressed')\n\n    def on_activate_i():\n        print('<ctrl>+<alt>+i pressed')\n\n    with keyboard.globalhotkeys({\n            '<ctrl>+<alt>+h': on_activate_h,\n            '<ctrl>+<alt>+i': on_activate_i}) as h:\n        h.join()\n\n\nrelease notes\n=============\n\nv1.7.6 (2022-01-01) - various fixes\n-----------------------------------\n*  allow passing virtual key codes to the parser for global hot keys.\n*  stop the recording context asynchronously on *xorg*.\n*  do not pass ``none`` to ``objc.objc_object``. thanks to *yejunxi*!\n*  do not crash when pressing the *alt* key on *uinput*. thanks to *caldas\n   lopes*!\n*  use the correct option prefix for listeners derived from the backend\n   implementations. thanks to *yu wang*!\n\n\nv1.7.5 (2021-11-19) - various fixes\n-----------------------------------\n*  corrected crashes on *xorg* when a listener was configured to suppress\n   system events. thanks to *jpramosi*!\n*  improved handling of keyboard controller on *windows*. the controller now\n   has a greater change of working with applications using lower level events.\n   thanks to *bhudax*!\n*  updated *macos* implementation to use new version of *pyobjc*.\n\n\nv1.7.4 (2021-10-10) - various fixes\n-----------------------------------\n*  detect whether permissions are lacking on *macos*. thanks to *dane finlay*!\n*  eagerly import symbols from ``corefoundation`` and ``quartz``. thanks to\n   *ronald oussoren*!\n*  improved handling of ``dumpkeys`` utility. thanks to *markus niedermann*!\n*  removed ambiguous license file.\n\n\nv1.7.3 (2021-02-10) - various fixes\n-----------------------------------\n*  corrected *keysym* handling on *xorg*; not all groups were loaded, and the\n   fallback to our internal tables was never triggered. thanks to *philipp\n   klaus*!\n*  updated the version of *quartz* used for the *macos* backend to allow\n   *pynput* to be installed on *big sur*. thanks to *michael madden*!\n*  added missing function keys on *windows*. thanks to *dave atkinson*!\n*  corrected scroll speed for mouse controller on *macos*. thanks to *albert\n   zeyer*!\n*  corrected media keys for *xorg*. thanks to *gabriele n. tornetta*!\n*  corrected parameter name in documentation. thanks to *jinesi yelizati*!\n\n\nv1.7.2 (2020-12-21) - corrected uinput key mapping\n--------------------------------------------------\n*  corrected mapping of virtual key codes to characters for the *uinput*\n   backend.\n*  corrected spelling errors. thanks to *martin michlmayr*!\n*  corrected and improved documentation.\n\n\nv1.7.1 (2020-08-30) - corrected release notes\n---------------------------------------------\n*  corrected thanks for arbitrary unicode character support for *xorg*.\n\n\nv1.7.0 (2020-08-30) - a new backend and many new features and bug fixes\n-----------------------------------------------------------------------\n*  added a new *uinput* based keyboard backend for *linux*, when no *x* server\n   is available.\n*  allow typing arbitrary unicode characters on *xorg* backend. thanks to\n   *gdishun*!\n*  allow overriding the automatically selected backend with an environment\n   variable, and added a dummy backend.\n*  added support for mouse side button on *windows*. thanks to *danielkovarik*!\n*  added convenience method to tap keys.\n*  allow specifying raw virtual key codes in hotkeys.\n*  improved error messages when a backend cannot be loaded.\n*  include more information in stringification of events.\n*  corrected return value of ``events.get`` to that specified by the\n   documentation.\n*  corrected keyboard listener not to type random characters on certain\n   keyboard layouts.\n*  corrected errors when pressing certain keys on *windows*, where the\n   operating system reports that they are dead but no combining version exists.\n*  improved documentation.\n\n\nv1.6.8 (2020-02-28) - various fixes\n-----------------------------------\n*  updated documentation.\n*  corrected lint warnings and tests.\n*  do not use internal types in ``argtypes`` for ``win32`` functions; this\n   renders them uncallable for other code running in the same runtime.\n*  include scan codes in events on *windows*. thanks to *bhudax*!\n*  correctly apply transformation to scroll event values on *windows*. thanks\n   to *docca0*!\n\n\nv1.6.7 (2020-02-17) - various fixes\n-----------------------------------\n*  corrected infinite scrolling on *macos* when providing non-integer deltas.\n   thanks to *iva\u0301n munsuri iba\u0301n\u0303ez*!\n*  corrected controller and listener handling of media keys on *macos*. thanks\n   to *iva\u0301n munsuri iba\u0301n\u0303ez*!\n\n\nv1.6.6 (2020-01-23) - corrected hot key documentation\n-----------------------------------------------------\n*  the code examples for the simple ``pynput.keyboard.hotkey`` now work. thanks\n   to *jfongattw*!\n\n\nv1.6.5 (2020-01-08) - corrected media key mappings\n--------------------------------------------------\n*  corrected media key mappings on *macos*. thanks to *luis nachtigall*!\n\n\nv1.6.4 (2020-01-03) - corrected imports yet again\n-------------------------------------------------\n*  corrected imports for keyboard controller. thanks to *rhystedstone*!\n\n\nv1.6.3 (2019-12-28) - corrected imports again\n---------------------------------------------\n*  corrected imports for keyboard controller. thanks to *matt iversen*!\n\n\nv1.6.2 (2019-12-28) - corrected imports\n---------------------------------------\n*  corrected imports for keyboard controller. thanks to *matt iversen*!\n\n\nv1.6.1 (2019-12-27) - corrections for *windows*\n-----------------------------------------------\n*  corrected global hotkeys on *windows*.\n*  corrected pressed / released state for keyboard listener on *windows*.\n   thanks to *segalion*!\n\nv1.6.0 (2019-12-11) - global hotkeys\n------------------------------------\n*  added support for global hotkeys.\n*  added support for streaming listener events synchronously.\n\n\nv1.5.2 (2019-12-06) - corrected media key names for *xorg*\n----------------------------------------------------------\n*  removed media flag from *xorg* keys.\n\n\nv1.5.1 (2019-12-06) - corrected media key names for *macos*\n-----------------------------------------------------------\n*  corrected attribute names for media keys on *macos*. thanks to *ah3243*!\n\n\nv1.5.0 (2019-12-04) - various improvements\n------------------------------------------\n*  corrected keyboard listener on *windows*. thanks to *akiratakasaki*,\n   *segalion*, *specialcharacter*!\n*  corrected handling of some special keys, including arrow keys, when combined\n   with modifiers on *windows*. thanks to *tuessetr*!\n*  updated documentation to include information about dpi scaling on *windows*.\n   thanks to *david-szarka*!\n*  added experimental support for media keys. thanks to *shivamjoker*,\n   *stormtersteeg*!\n\n\nv1.4.5 (2019-11-05) - corrected errors on *python 3.8*\n------------------------------------------------------\n*  corrected errors about using `in` operator for enums on *python 3.8* on\n   *macos*.\n\n\nv1.4.4 (2019-09-24) - actually corrected keyboard listener on macos\n-------------------------------------------------------------------\n*  included commit to correctly fall back on\n   ``cgeventkeyboardgetunicodestring``.\n*  corrected deprecation warnings about ``enum`` usage on *python 3.8*.\n\n\nv1.4.3 (2019-09-24) - corrected keyboard listener on macos again\n----------------------------------------------------------------\n*  correctly fall back on ``cgeventkeyboardgetunicodestring``.\n*  updated documentation.\n\n\nv1.4.2 (2019-03-22) - corrected keyboard listener on macos\n----------------------------------------------------------\n*  use ``cgeventkeyboardgetunicodestring`` in *macos* keyboard listener to send\n   correct characters.\n*  include keysym instead of key code in *xorg* keyboard listener.\n*  corrected logging to not include expected ``stopexception``.\n*  updated and corrected documentation.\n\n\nv1.4.1 (2018-09-07) - logging\n-----------------------------\n*  log unhandled exceptions raised by listener callbacks.\n\n\nv1.4 (2018-07-03) - event suppression\n-------------------------------------\n*  added possibility to fully suppress events when listening.\n*  added support for typing some control characters.\n*  added support for mouse drag events on *osx*. thanks to *jungledrum*!\n*  include the key code in keyboard listener events.\n*  correctly handle the numeric key pad on *xorg* with *num lock* active.\n   thanks to *theoret*!\n*  corrected handling of current thread keyboard layout on *windows*. thanks to\n   *schmettaling*!\n*  corrected stopping of listeners on *xorg*.\n*  corrected import of ``xlib.keysymdef.xkb`` on *xorg*. thanks to *glandos*!\n\n\nv1.3.10 (2018-02-05) - do not crash under *xephyr*\n--------------------------------------------------\n*  do not crash when ``xlib.display.display.get_input_focus`` returns an\n   integer, as it may when running under *xephyr*. thanks to *eli skeggs*!\n\n\nv1.3.9 (2018-01-12) - correctly handle the letter *a* on *osx*\n--------------------------------------------------------------\n*  corrected check for virtual key code when generating keyboard events on\n   *osx*. this fixes an issue where pressing *a* with *shift* explicitly pressed\n   would still type a minuscule letter.\n\n\nv1.3.8 (2017-12-08) - do not crash on some keyboard layouts on *osx*\n--------------------------------------------------------------------\n*  fall back on a different method to retrieve the keyboard layout on *osx*.\n   this helps for some keyboard layouts, such as *chinese*. thanks to\n   *haoflynet*!\n\n\nv1.3.7 (2017-08-23) - *xorg* corrections\n----------------------------------------\n*  include mouse buttons up to *30* for *xorg*.\n\n\nv1.3.6 (2017-08-13) - *win32* corrections\n-----------------------------------------\n*  corrected double delivery of fake keyboard events on *windows*.\n*  corrected handling of synthetic unicode keys on *windows*.\n\n\nv1.3.5 (2017-06-07) - corrected dependencies again\n--------------------------------------------------\n*  reverted changes in *1.3.3*.\n*  corrected platform specifier for *python 2* on *linux*.\n\n\nv1.3.4 (2017-06-05) - *xorg* corrections\n----------------------------------------\n*  corrected bounds check for values on *xorg*.\n\n\nv1.3.3 (2017-06-05) - make dependencies non-optional\n----------------------------------------------------\n*  made platform dependencies non-optional.\n\n\nv1.3.2 (2017-05-15) - fix for button click on mac\n-------------------------------------------------\n*  corrected regression from previous release where button clicks would\n   crash the *mac* mouse listener.\n\n\nv1.3.1 (2017-05-12) - fixes for unknown buttons on linux\n--------------------------------------------------------\n*  fall back on `button.unknown` for unknown mouse buttons in *xorg* mouse\n   listener.\n\n\nv1.3 (2017-04-10) - platform specific features\n----------------------------------------------\n*  added ability to stop event propagation on *windows*. this will prevent\n   events from reaching other applications.\n*  added ability to ignore events on *windows*. this is a workaround for systems\n   where the keyboard monitor interferes with normal keyboard events.\n*  added ability to modify events on *osx*. this allows intercepting and\n   altering input events before they reach other applications.\n*  corrected crash on *osx* when some types of third party input sources are\n   installed.\n\n\nv1.2 (2017-01-06) - improved error handling\n-------------------------------------------\n*  allow catching exceptions thrown from listener callbacks. this changes the\n   api, as joining a listener now potentially raises unhandled exceptions,\n   and unhandled exceptions will stop listeners.\n*  added support for the numeric keypad on *linux*.\n*  improved documentation.\n*  thanks to *jollysean* and *gilleswijnker* for their input!\n\n\nv1.1.7 (2017-01-02) - handle middle button on windows\n-----------------------------------------------------\n*  listen for and dispatch middle button mouse clicks on *windows*.\n\n\nv1.1.6 (2016-11-24) - corrected context manager for pressing keys\n-----------------------------------------------------------------\n*  corrected bug in ``pynput.keyboard.controller.pressed`` which caused it to\n   never release the key. many thanks to toby southwell!\n\n\nv1.1.5 (2016-11-17) - corrected modifier key combinations on linux\n------------------------------------------------------------------\n*  corrected handling of modifier keys to allow them to be composable on\n   *linux*.\n\n\nv1.1.4 (2016-10-30) - small bugfixes\n------------------------------------\n*  corrected error generation when ``getkeyboardstate`` fails.\n*  make sure to apply shift state to borrowed keys on *x*.\n*  use *pylint*.\n\n\nv1.1.3 (2016-09-27) - changed xlib backend library\n--------------------------------------------------\n*  changed *xlib* library.\n\n\nv1.1.2 (2016-09-26) - added missing type for python 2\n-----------------------------------------------------\n*  added missing ``lpdword`` for *python 2* on *windows*.\n\n\nv1.1.1 (2016-09-26) - fixes for listeners and controllers on windows\n--------------------------------------------------------------------\n*  corrected keyboard listener on *windows*. modifier keys and other keys\n   changing the state of the keyboard are now handled correctly.\n*  corrected mouse click and release on *windows*.\n*  corrected code samples.\n\n\nv1.1 (2016-06-22) - simplified usage on linux\n---------------------------------------------\n*  propagate import errors raised on linux to help troubleshoot missing\n   ``xlib`` module.\n*  declare ``python3-xlib`` as dependency on *linux* for *python 3*.\n\n\nv1.0.6 (2016-04-19) - universal wheel\n-------------------------------------\n*  make sure to build a universal wheel for all python versions.\n\n\nv1.0.5 (2016-04-11) - fixes for dragging on osx\n-----------------------------------------------\n*  corrected dragging on *osx*.\n*  added scroll speed constant for *osx* to correct slow scroll speed.\n\n\nv1.0.4 (2016-04-11) - fixes for clicking and scrolling on windows\n-----------------------------------------------------------------\n*  corrected name of mouse input field when sending click and scroll events.\n\n\nv1.0.3 (2016-04-05) - fixes for python 3 on windows\n---------------------------------------------------\n*  corrected use of ``ctypes`` on windows.\n\n\nv1.0.2 (2016-04-03) - fixes for thread identifiers\n--------------------------------------------------\n*  use thread identifiers to identify threads, not thread instances.\n\n\nv1.0.1 (2016-04-03) - fixes for python 3\n----------------------------------------\n*  corrected bugs which prevented the library from being used on *python 3*.\n\n\nv1.0 (2016-02-28) - stable release\n----------------------------------\n*  changed license to *lgpl*.\n*  corrected minor bugs and inconsistencies.\n*  corrected and extended documentation.\n\n\nv0.6 (2016-02-08) - keyboard monitor\n------------------------------------\n*  added support for monitoring the keyboard.\n*  corrected wheel packaging.\n*  corrected deadlock when stopping a listener in some cases on *x*.\n*  corrected key code constants on *mac osx*.\n*  do not intercept events on *mac osx*.\n\n\nv0.5.1 (2016-01-26) - do not die on dead keys\n---------------------------------------------\n*  corrected handling of dead keys.\n*  corrected documentation.\n\n\nv0.5 (2016-01-18) - keyboard modifiers\n--------------------------------------\n*  added support for modifiers.\n\n\nv0.4 (2015-12-22) - keyboard controller\n---------------------------------------\n*  added keyboard controller.\n\n\nv0.3 (2015-12-22) - cleanup\n---------------------------\n*  moved ``pynput.mouse.controller.button`` to top-level.\n\n\nv0.2 (2015-10-28) - initial release\n-----------------------------------\n*  support for controlling the mouse on *linux*, *mac osx* and *windows*.\n*  support for monitoring the mouse on *linux*, *mac osx* and *windows*.\n\n\n",
  "docs_url": "https://pythonhosted.org/pynput/",
  "keywords": "control mouse,mouse input,control keyboard,keyboard input",
  "license": "lgplv3",
  "name": "pynput",
  "package_url": "https://pypi.org/project/pynput/",
  "project_url": "https://pypi.org/project/pynput/",
  "project_urls": {
    "Homepage": "https://github.com/moses-palmer/pynput"
  },
  "release_url": "https://pypi.org/project/pynput/1.7.6/",
  "requires_dist": [
    "six",
    "evdev (>=1.3) ; \"linux\" in sys_platform",
    "python-xlib (>=0.17) ; \"linux\" in sys_platform",
    "enum34 ; python_version == \"2.7\"",
    "pyobjc-framework-ApplicationServices (>=8.0) ; sys_platform == \"darwin\"",
    "pyobjc-framework-Quartz (>=8.0) ; sys_platform == \"darwin\""
  ],
  "requires_python": "",
  "summary": "monitor and control user input devices",
  "version": "1.7.6",
  "releases": [],
  "developers": [
    "moses.palmer@gmail.com"
  ],
  "kwds": "mouse _pynput_ pynput keypad get_input_focus",
  "license_kwds": "lgplv3",
  "libtype": "pypi",
  "id": "pypi_pynput",
  "homepage": "https://github.com/moses-palmer/pynput",
  "release_count": 58,
  "dependency_ids": [
    "pypi_enum34",
    "pypi_evdev",
    "pypi_pyobjc_framework_applicationservices",
    "pypi_pyobjc_framework_quartz",
    "pypi_python_xlib",
    "pypi_six"
  ]
}