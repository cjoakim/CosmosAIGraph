{
  "classifiers": [
    "environment :: web environment",
    "framework :: flask",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "topic :: internet :: www/http :: dynamic content",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# flask-pydantic\n\n[![actions status](https://github.com/bauerji/flask_pydantic/workflows/tests/badge.svg?branch=master)](https://github.com/bauerji/flask_pydantic/actions/workflows/tests.yml)\n[![pypi](https://img.shields.io/pypi/v/flask-pydantic?color=g)](https://pypi.org/project/flask-pydantic/)\n[![language grade: python](https://img.shields.io/lgtm/grade/python/g/bauerji/flask_pydantic.svg?logo=lgtm&logowidth=18)](https://lgtm.com/projects/g/bauerji/flask_pydantic/context:python)\n[![license](https://img.shields.io/badge/license-mit-purple)](https://github.com/bauerji/flask_pydantic/blob/master/license)\n[![code style](https://img.shields.io/badge/code%20style-black-black)](https://github.com/psf/black)\n\nflask extension for integration of the awesome [pydantic package](https://github.com/samuelcolvin/pydantic) with [flask](https://palletsprojects.com/p/flask/).\n\n## installation\n\n`python3 -m pip install flask-pydantic`\n\n## basics\n### url query and body parameters\n\n`validate` decorator validates query, body and form-data request parameters and makes them accessible two ways:\n\n1. [using `validate` arguments, via flask's `request` variable](#basic-example)\n\n| **parameter type** | **`request` attribute name** |\n|:------------------:|:----------------------------:|\n|       query        |        `query_params`        |\n|        body        |        `body_params`         |\n|        form        |        `form_params`         |\n\n2. [using the decorated function argument parameters type hints](#using-the-decorated-function-kwargs)\n\n### url path parameter\n\nif you use annotated path url path parameters as follows\n```python\n\n@app.route(\"/users/<user_id>\", methods=[\"get\"])\n@validate()\ndef get_user(user_id: str):\n    pass\n```\nflask_pydantic will parse and validate `user_id` variable in the same manner as for body and query parameters.\n\n---\n\n### additional `validate` arguments\n\n- success response status code can be modified via `on_success_status` parameter of `validate` decorator.\n- `response_many` parameter set to `true` enables serialization of multiple models (route function should therefore return iterable of models).\n- `request_body_many` parameter set to `false` analogically enables serialization of multiple models inside of the root level of request body. if the request body doesn't contain an array of objects `400` response is returned,\n- `get_json_params` - parameters to be passed to [`flask.request.get_json`](https://tedboy.github.io/flask/generated/generated/flask.request.get_json.html) function\n- if validation fails, `400` response is returned with failure explanation.\n\nfor more details see in-code docstring or example app.\n\n## usage\n\n### example 1: query parameters only\n\nsimply use `validate` decorator on route function.\n\n:exclamation: be aware that `@app.route` decorator must precede `@validate` (i. e. `@validate` must be closer to the function declaration).\n\n```python\nfrom typing import optional\nfrom flask import flask, request\nfrom pydantic import basemodel\n\nfrom flask_pydantic import validate\n\napp = flask(\"flask_pydantic_app\")\n\nclass querymodel(basemodel):\n  age: int\n\nclass responsemodel(basemodel):\n  id: int\n  age: int\n  name: str\n  nickname: optional[str]\n\n# example 1: query parameters only\n@app.route(\"/\", methods=[\"get\"])\n@validate()\ndef get(query: querymodel):\n  age = query.age\n  return responsemodel(\n    age=age,\n    id=0, name=\"abc\", nickname=\"123\"\n    )\n```\n\n<a href=\"blob/master/example_app/example.py\">\n  see the full example app here\n</a>\n\n\n- `age` query parameter is a required `int`\n  - `curl --location --request get 'http://127.0.0.1:5000/'`\n  - if none is provided the response contains:\n    ```json\n    {\n      \"validation_error\": {\n        \"query_params\": [\n          {\n            \"loc\": [\"age\"],\n            \"msg\": \"field required\",\n            \"type\": \"value_error.missing\"\n          }\n        ]\n      }\n    }\n    ```\n  - for incompatible type (e. g. string `/?age=not_a_number`)\n  - `curl --location --request get 'http://127.0.0.1:5000/?age=abc'`\n    ```json\n    {\n      \"validation_error\": {\n        \"query_params\": [\n          {\n            \"loc\": [\"age\"],\n            \"msg\": \"value is not a valid integer\",\n            \"type\": \"type_error.integer\"\n          }\n        ]\n      }\n    }\n    ```\n- likewise for body parameters\n- example call with valid parameters:\n  `curl --location --request get 'http://127.0.0.1:5000/?age=20'`  \n\n-> `{\"id\": 0, \"age\": 20, \"name\": \"abc\", \"nickname\": \"123\"}`\n\n\n### example 2: url path parameter\n\n```python\n@app.route(\"/character/<character_id>/\", methods=[\"get\"])\n@validate()\ndef get_character(character_id: int):\n    characters = [\n        responsemodel(id=1, age=95, name=\"geralt\", nickname=\"white wolf\"),\n        responsemodel(id=2, age=45, name=\"triss merigold\", nickname=\"sorceress\"),\n        responsemodel(id=3, age=42, name=\"julian alfred pankratz\", nickname=\"jaskier\"),\n        responsemodel(id=4, age=101, name=\"yennefer\", nickname=\"yenn\"),\n    ]\n    try:\n        return characters[character_id]\n    except indexerror:\n        return {\"error\": \"not found\"}, 400\n```\n\n\n### example 3: request body only\n\n```python\nclass requestbodymodel(basemodel):\n  name: str\n  nickname: optional[str]\n\n# example2: request body only\n@app.route(\"/\", methods=[\"post\"])\n@validate()\ndef post(body: requestbodymodel): \n  name = body.name\n  nickname = body.nickname\n  return responsemodel(\n    name=name, nickname=nickname,id=0, age=1000\n    )\n```\n\n<a href=\"blob/master/example_app/example.py\">\n  see the full example app here\n</a>\n\n### example 4: both query paramaters and request body\n\n```python\n# example 3: both query paramters and request body\n@app.route(\"/both\", methods=[\"post\"])\n@validate()\ndef get_and_post(body: requestbodymodel,query: querymodel):\n  name = body.name # from request body\n  nickname = body.nickname # from request body\n  age = query.age # from query parameters\n  return responsemodel(\n    age=age, name=name, nickname=nickname,\n    id=0\n  )\n```\n\n<a href=\"blob/master/example_app/example.py\">\n  see the full example app here\n</a>\n\n\n### example 5: request form-data only\n\n```python\nclass requestformdatamodel(basemodel):\n  name: str\n  nickname: optional[str]\n\n# example2: request body only\n@app.route(\"/\", methods=[\"post\"])\n@validate()\ndef post(form: requestformdatamodel): \n  name = form.name\n  nickname = form.nickname\n  return responsemodel(\n    name=name, nickname=nickname,id=0, age=1000\n    )\n```\n\n<a href=\"blob/master/example_app/example.py\">\n  see the full example app here\n</a>\n\n### modify response status code\n\nthe default success status code is `200`. it can be modified in two ways\n\n- in return statement\n\n```python\n# necessary imports, app and models definition\n...\n\n@app.route(\"/\", methods=[\"post\"])\n@validate(body=bodymodel, query=querymodel)\ndef post():\n    return responsemodel(\n            id=id_,\n            age=request.query_params.age,\n            name=request.body_params.name,\n            nickname=request.body_params.nickname,\n        ), 201\n```\n\n- in `validate` decorator\n\n```python\n@app.route(\"/\", methods=[\"post\"])\n@validate(body=bodymodel, query=querymodel, on_success_status=201)\ndef post():\n    ...\n```\n\nstatus code in case of validation error can be modified using `flask_pydantic_validation_error_status_code` flask configuration variable.\n\n### using the decorated function `kwargs`\n\ninstead of passing `body` and `query` to `validate`, it is possible to directly\ndefined them by using type hinting in the decorated function.\n\n```python\n# necessary imports, app and models definition\n...\n\n@app.route(\"/\", methods=[\"post\"])\n@validate()\ndef post(body: bodymodel, query: querymodel):\n    return responsemodel(\n            id=id_,\n            age=query.age,\n            name=body.name,\n            nickname=body.nickname,\n        )\n```\n\nthis way, the parsed data will be directly available in `body` and `query`.\nfurthermore, your ide will be able to correctly type them.\n\n### model aliases\n\npydantic's [alias feature](https://pydantic-docs.helpmanual.io/usage/model_config/#alias-generator) is natively supported for query and body models.\nto use aliases in response modify response model\n```python\ndef modify_key(text: str) -> str:\n    # do whatever you want with model keys\n    return text\n\n\nclass mymodel(basemodel):\n    ...\n    class config:\n        alias_generator = modify_key\n        allow_population_by_field_name = true\n\n```\n\nand set `response_by_alias=true` in `validate` decorator\n```\n@app.route(...)\n@validate(response_by_alias=true)\ndef my_route():\n    ...\n    return mymodel(...)\n```\n\n### example app\n\nfor more complete examples see [example application](https://github.com/bauerji/flask_pydantic/tree/master/example_app).\n\n### configuration\n\nthe behaviour can be configured using flask's application config\n`flask_pydantic_validation_error_status_code` - response status code after validation error (defaults to `400`)\n\nadditionally, you can set `flask_pydantic_validation_error_raise` to `true` to cause\n`flask_pydantic.validationerror` to be raised with either `body_params`,\n`form_params`, `path_params`, or `query_params` set as a list of error\ndictionaries. you can use `flask.flask.register_error_handler` to catch that\nexception and fully customize the output response for a validation error.\n\n## contributing\n\nfeature requests and pull requests are welcome. for major changes, please open an issue first to discuss what you would like to change.\n\n- clone repository\n  ```bash\n  git clone https://github.com/bauerji/flask_pydantic.git\n  cd flask_pydantic\n  ```\n- create virtual environment and activate it\n  ```bash\n  python3 -m venv venv\n  source venv/bin/activate\n  ```\n- install development requirements\n  ```bash\n  python3 -m pip install -r requirements/test.pip\n  ```\n- checkout new branch and make your desired changes (don't forget to update tests)\n  ```bash\n  git checkout -b <your_branch_name>\n  ```\n- run tests\n  ```bash\n  python3 -m pytest\n  ```\n- if tests fails on black tests, make sure you have your code compliant with style of [black formatter](https://github.com/psf/black)\n- push your changes and create a pull request to master branch\n\n## todos:\n\n- header request parameters\n- cookie request parameters\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "flask-pydantic",
  "package_url": "https://pypi.org/project/Flask-Pydantic/",
  "project_url": "https://pypi.org/project/Flask-Pydantic/",
  "project_urls": {
    "Homepage": "https://github.com/bauerji/flask_pydantic.git"
  },
  "release_url": "https://pypi.org/project/Flask-Pydantic/0.11.0/",
  "requires_dist": [
    "Flask",
    "pydantic (>=1.7)"
  ],
  "requires_python": ">=3.6",
  "summary": "flask extension for integration with pydantic library",
  "version": "0.11.0",
  "releases": [],
  "developers": [
    "baueji@gmail.com",
    "jiri_bauer"
  ],
  "kwds": "flask_pydantic flask_pydantic_app flask_pydantic_validation_error_status_code flask flask_pydantic_validation_error_raise",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_flask_pydantic",
  "homepage": "https://github.com/bauerji/flask_pydantic.git",
  "release_count": 23,
  "dependency_ids": [
    "pypi_flask",
    "pypi_pydantic"
  ]
}