{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http",
    "topic :: software development :: build tools",
    "typing :: typed"
  ],
  "description": "<h2 align=\"center\">send responses to httpx using pytest</h2>\n\n<p align=\"center\">\n<a href=\"https://pypi.org/project/pytest-httpx/\"><img alt=\"pypi version\" src=\"https://img.shields.io/pypi/v/pytest_httpx\"></a>\n<a href=\"https://github.com/colin-b/pytest_httpx/actions\"><img alt=\"build status\" src=\"https://github.com/colin-b/pytest_httpx/workflows/release/badge.svg\"></a>\n<a href=\"https://github.com/colin-b/pytest_httpx/actions\"><img alt=\"coverage\" src=\"https://img.shields.io/badge/coverage-100%25-brightgreen\"></a>\n<a href=\"https://github.com/psf/black\"><img alt=\"code style: black\" src=\"https://img.shields.io/badge/code%20style-black-000000.svg\"></a>\n<a href=\"https://github.com/colin-b/pytest_httpx/actions\"><img alt=\"number of tests\" src=\"https://img.shields.io/badge/tests-208 passed-blue\"></a>\n<a href=\"https://pypi.org/project/pytest-httpx/\"><img alt=\"number of downloads\" src=\"https://img.shields.io/pypi/dm/pytest_httpx\"></a>\n</p>\n\n> version 1.0.0 will be released once httpx is considered as stable (release of 1.0.0).\n>\n> however, current state can be considered as stable.\n\nonce installed, `httpx_mock` [`pytest`](https://docs.pytest.org/en/latest/) fixture will make sure every [`httpx`](https://www.python-httpx.org) request will be replied to with user provided responses.\n\n- [add responses](#add-responses)\n  - [json body](#add-json-response)\n  - [custom body](#reply-with-custom-body)\n  - [multipart body (files, ...)](#add-multipart-response)\n  - [http status code](#add-non-200-response)\n  - [http headers](#reply-with-custom-headers)\n  - [http/2.0](#add-http/2.0-response)\n- [add dynamic responses](#dynamic-responses)\n- [raising exceptions](#raising-exceptions)\n- [check requests](#check-sent-requests)\n- [do not mock some requests](#do-not-mock-some-requests)\n- [migrating](#migrating-to-pytest-httpx)\n  - [responses](#from-responses)\n  - [aioresponses](#from-aioresponses)\n\n## add responses\n\nyou can register responses for both sync and async [`httpx`](https://www.python-httpx.org) requests.\n\n```python\nimport pytest\nimport httpx\n\n\ndef test_something(httpx_mock):\n    httpx_mock.add_response()\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n\n\n@pytest.mark.asyncio\nasync def test_something_async(httpx_mock):\n    httpx_mock.add_response()\n\n    async with httpx.asyncclient() as client:\n        response = await client.get(\"https://test_url\")\n```\n\nif all registered responses are not sent back during test execution, the test case will fail at teardown.\n\nthis behavior can be disabled thanks to the `assert_all_responses_were_requested` fixture:\n\n```python\nimport pytest\n\n@pytest.fixture\ndef assert_all_responses_were_requested() -> bool:\n    return false\n```\n\ndefault response is a http/1.1 200 (ok) without any body.\n\n### how response is selected\n\nin case more than one response match request, the first one not yet sent (according to the registration order) will be sent.\n\nin case all matching responses have been sent, the last one (according to the registration order) will be sent.\n\nyou can add criteria so that response will be sent only in case of a more specific matching.\n\n#### matching on url\n\n`url` parameter can either be a string, a python [re.pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.url](https://www.python-httpx.org/api/#url) instance.\n\nmatching is performed on the full url, query parameters included.\n\norder of parameters in the query string does not matter, however order of values do matter if the same parameter is provided more than once.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_url(httpx_mock: httpxmock):\n    httpx_mock.add_response(url=\"https://test_url?a=1&b=2\")\n\n    with httpx.client() as client:\n        response1 = client.delete(\"https://test_url?a=1&b=2\")\n        response2 = client.get(\"https://test_url?b=2&a=1\")\n```\n\n#### matching on http method\n\nuse `method` parameter to specify the http method (post, put, delete, patch, head) to reply to.\n\n`method` parameter must be a string. it will be upper-cased, so it can be provided lower cased.\n\nmatching is performed on equality.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_post(httpx_mock: httpxmock):\n    httpx_mock.add_response(method=\"post\")\n\n    with httpx.client() as client:\n        response = client.post(\"https://test_url\")\n\n\ndef test_put(httpx_mock: httpxmock):\n    httpx_mock.add_response(method=\"put\")\n\n    with httpx.client() as client:\n        response = client.put(\"https://test_url\")\n\n\ndef test_delete(httpx_mock: httpxmock):\n    httpx_mock.add_response(method=\"delete\")\n\n    with httpx.client() as client:\n        response = client.delete(\"https://test_url\")\n\n\ndef test_patch(httpx_mock: httpxmock):\n    httpx_mock.add_response(method=\"patch\")\n\n    with httpx.client() as client:\n        response = client.patch(\"https://test_url\")\n\n\ndef test_head(httpx_mock: httpxmock):\n    httpx_mock.add_response(method=\"head\")\n\n    with httpx.client() as client:\n        response = client.head(\"https://test_url\")\n    \n```\n\n#### matching on proxy url\n\n`proxy_url` parameter can either be a string, a python [re.pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.url](https://www.python-httpx.org/api/#url) instance.\n\nmatching is performed on the full proxy url, query parameters included.\n\norder of parameters in the query string does not matter, however order of values do matter if the same parameter is provided more than once.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_proxy_url(httpx_mock: httpxmock):\n    httpx_mock.add_response(proxy_url=\"http://test_proxy_url?b=1&a=2\")\n\n    with httpx.client(proxy=\"http://test_proxy_url?a=2&b=1\") as client:\n        response = client.get(\"https://test_url\")\n```\n\n#### matching on http headers\n\nuse `match_headers` parameter to specify the http headers to reply to.\n\nmatching is performed on equality for each provided header.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_headers_matching(httpx_mock: httpxmock):\n    httpx_mock.add_response(match_headers={'user-agent': 'python-httpx/0.25.0'})\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n```\n\n#### matching on http body\n\nuse `match_content` parameter to specify the full http body to reply to.\n\nmatching is performed on equality.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_content_matching(httpx_mock: httpxmock):\n    httpx_mock.add_response(match_content=b\"this is the body\")\n\n    with httpx.client() as client:\n        response = client.post(\"https://test_url\", content=b\"this is the body\")\n```\n\n##### matching on http json body\n\nuse `match_json` parameter to specify the json decoded http body to reply to.\n\nmatching is performed on equality. you can however use `unittest.mock.any` to do partial matching.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\nfrom unittest.mock import any\n\ndef test_json_matching(httpx_mock: httpxmock):\n    httpx_mock.add_response(match_json={\"a\": \"json\", \"b\": 2})\n\n    with httpx.client() as client:\n        response = client.post(\"https://test_url\", json={\"a\": \"json\", \"b\": 2})\n\n        \ndef test_partial_json_matching(httpx_mock: httpxmock):\n    httpx_mock.add_response(match_json={\"a\": \"json\", \"b\": any})\n\n    with httpx.client() as client:\n        response = client.post(\"https://test_url\", json={\"a\": \"json\", \"b\": 2})\n```\n        \nnote that `match_content` cannot be provided if `match_json` is also provided.\n\n### add json response\n\nuse `json` parameter to add a json response using python values.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_json(httpx_mock: httpxmock):\n    httpx_mock.add_response(json=[{\"key1\": \"value1\", \"key2\": \"value2\"}])\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").json() == [{\"key1\": \"value1\", \"key2\": \"value2\"}]\n    \n```\n\nnote that the `content-type` header will be set to `application/json` by default in the response.\n\n### reply with custom body\n\nuse `text` parameter to reply with a custom body by providing utf-8 encoded string.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_str_body(httpx_mock: httpxmock):\n    httpx_mock.add_response(text=\"this is my utf-8 content\")\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").text == \"this is my utf-8 content\"\n\n```\n\nuse `content` parameter to reply with a custom body by providing bytes.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_bytes_body(httpx_mock: httpxmock):\n    httpx_mock.add_response(content=b\"this is my bytes content\")\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").content == b\"this is my bytes content\"\n    \n```\n\nuse `html` parameter to reply with a custom body by providing utf-8 encoded string.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_html_body(httpx_mock: httpxmock):\n    httpx_mock.add_response(html=\"<body>this is <p> html content</body>\")\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").text == \"<body>this is <p> html content</body>\"\n\n```\n\n### reply by streaming chunks\n\nuse `stream` parameter to stream chunks that you specify.\n\n```python\nimport httpx\nimport pytest\nfrom pytest_httpx import httpxmock, iteratorstream\n\ndef test_sync_streaming(httpx_mock: httpxmock):\n    httpx_mock.add_response(stream=iteratorstream([b\"part 1\", b\"part 2\"]))\n\n    with httpx.client() as client:\n        with client.stream(method=\"get\", url=\"https://test_url\") as response:\n            assert list(response.iter_raw()) == [b\"part 1\", b\"part 2\"]\n\n\n@pytest.mark.asyncio\nasync def test_async_streaming(httpx_mock: httpxmock):\n    httpx_mock.add_response(stream=iteratorstream([b\"part 1\", b\"part 2\"]))\n\n    async with httpx.asyncclient() as client:\n        async with client.stream(method=\"get\", url=\"https://test_url\") as response:\n            assert [part async for part in response.aiter_raw()] == [b\"part 1\", b\"part 2\"]\n    \n```\n\n### add multipart response\n\nuse the httpx `multipartstream` via the `stream` parameter to send a multipart response.\n\nreach out to `httpx` developers if you need this publicly exposed as [this is not a standard use case](https://github.com/encode/httpx/issues/872#issuecomment-633584819).\n\n```python\nimport httpx\nfrom httpx._multipart import multipartstream\nfrom pytest_httpx import httpxmock\n\n\ndef test_multipart_body(httpx_mock: httpxmock):\n    httpx_mock.add_response(stream=multipartstream(data={\"key1\": \"value1\"}, files={\"file1\": b\"content of file 1\"}, boundary=b\"2256d3a36d2a61a1eba35a22bee5c74a\"))\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").text == '''--2256d3a36d2a61a1eba35a22bee5c74a\\r\ncontent-disposition: form-data; name=\"key1\"\\r\n\\r\nvalue1\\r\n--2256d3a36d2a61a1eba35a22bee5c74a\\r\ncontent-disposition: form-data; name=\"file1\"; filename=\"upload\"\\r\ncontent-type: application/octet-stream\\r\n\\r\ncontent of file 1\\r\n--2256d3a36d2a61a1eba35a22bee5c74a--\\r\n'''\n    \n```\n\n### add non 200 response\n\nuse `status_code` parameter to specify the http status code of the response.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_status_code(httpx_mock: httpxmock):\n    httpx_mock.add_response(status_code=404)\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").status_code == 404\n\n```\n\n### reply with custom headers\n\nuse `headers` parameter to specify the extra headers of the response.\n\nany valid httpx headers type is supported, you can submit headers as a dict (str or bytes), a list of 2-tuples (str or bytes) or a `httpx.header` instance.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_headers_as_str_dict(httpx_mock: httpxmock):\n    httpx_mock.add_response(headers={\"x-header1\": \"test value\"})\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").headers[\"x-header1\"] == \"test value\"\n\n\ndef test_headers_as_str_tuple_list(httpx_mock: httpxmock):\n    httpx_mock.add_response(headers=[(\"x-header1\", \"test value\")])\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").headers[\"x-header1\"] == \"test value\"\n\n\ndef test_headers_as_httpx_headers(httpx_mock: httpxmock):\n    httpx_mock.add_response(headers=httpx.headers({b\"x-header1\": b\"test value\"}))\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").headers[\"x-header1\"] == \"test value\"\n\n```\n\n#### reply with cookies\n\ncookies are sent in the `set-cookie` http header.\n\nyou can then send cookies in the response by setting the `set-cookie` header with [the value following key=value format]((https://developer.mozilla.org/en-us/docs/web/http/headers/set-cookie)).\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_cookie(httpx_mock: httpxmock):\n    httpx_mock.add_response(headers={\"set-cookie\": \"key=value\"})\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n    assert dict(response.cookies) == {\"key\": \"value\"}\n\n\ndef test_cookies(httpx_mock: httpxmock):\n    httpx_mock.add_response(headers=[(\"set-cookie\", \"key=value\"), (\"set-cookie\", \"key2=value2\")])\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n    assert dict(response.cookies) == {\"key\": \"value\", \"key2\": \"value2\"}\n\n```\n\n\n### add http/2.0 response\n\nuse `http_version` parameter to specify the http protocol version of the response.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_http_version(httpx_mock: httpxmock):\n    httpx_mock.add_response(http_version=\"http/2.0\")\n\n    with httpx.client() as client:\n        assert client.get(\"https://test_url\").http_version == \"http/2.0\"\n\n```\n\n## add callbacks\n\nyou can perform custom manipulation upon request reception by registering callbacks.\n\ncallback should expect one parameter, the received [`httpx.request`](https://www.python-httpx.org/api/#request).\n\nif all callbacks are not executed during test execution, the test case will fail at teardown.\n\nthis behavior can be disabled thanks to the `assert_all_responses_were_requested` fixture:\n\n```python\nimport pytest\n\n@pytest.fixture\ndef assert_all_responses_were_requested() -> bool:\n    return false\n```\n\nnote that callbacks are considered as responses, and thus are [selected the same way](#how-response-is-selected).\n\n### dynamic responses\n\ncallback should return a `httpx.response`.\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_dynamic_response(httpx_mock: httpxmock):\n    def custom_response(request: httpx.request):\n        return httpx.response(\n            status_code=200, json={\"url\": str(request.url)},\n        )\n\n    httpx_mock.add_callback(custom_response)\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n        assert response.json() == {\"url\": \"https://test_url\"}\n\n```\n\nalternatively, callbacks can also be asynchronous.\n\nas in the following sample simulating network latency on some responses only.\n\n```python\nimport asyncio\nimport httpx\nimport pytest\nfrom pytest_httpx import httpxmock\n\n\n@pytest.mark.asyncio\nasync def test_dynamic_async_response(httpx_mock: httpxmock):\n    async def simulate_network_latency(request: httpx.request):\n        await asyncio.sleep(1)\n        return httpx.response(\n            status_code=200, json={\"url\": str(request.url)},\n        )\n\n    httpx_mock.add_callback(simulate_network_latency)\n    httpx_mock.add_response()\n\n    async with httpx.asyncclient() as client:\n        responses = await asyncio.gather(\n            # response will be received after one second\n            client.get(\"https://test_url\"),\n            # response will instantly be received (1 second before the first request)\n            client.get(\"https://test_url\")\n        )\n\n```\n\n### raising exceptions\n\nyou can simulate httpx exception throwing by raising an exception in your callback or use `httpx_mock.add_exception` with the exception instance.\n\nthis can be useful if you want to assert that your code handles httpx exceptions properly.\n\n```python\nimport httpx\nimport pytest\nfrom pytest_httpx import httpxmock\n\n\ndef test_exception_raising(httpx_mock: httpxmock):\n    httpx_mock.add_exception(httpx.readtimeout(\"unable to read within timeout\"))\n    \n    with httpx.client() as client:\n        with pytest.raises(httpx.readtimeout):\n            client.get(\"https://test_url\")\n\n```\n\nnote that default behavior is to send an `httpx.timeoutexception` in case no response can be found. you can then test this kind of exception this way:\n\n```python\nimport httpx\nimport pytest\nfrom pytest_httpx import httpxmock\n\n\ndef test_timeout(httpx_mock: httpxmock):\n    with httpx.client() as client:\n        with pytest.raises(httpx.timeoutexception):\n            client.get(\"https://test_url\")\n\n```\n\n## check sent requests\n\nthe best way to ensure the content of your requests is still to use the `match_headers` and / or `match_content` parameters when adding a response.\nin the same spirit, ensuring that no request was issued does not necessarily require any code.\n\nin any case, you always have the ability to retrieve the requests that were issued.\n\nas in the following samples:\n\n```python\nimport httpx\nfrom pytest_httpx import httpxmock\n\n\ndef test_many_requests(httpx_mock: httpxmock):\n    httpx_mock.add_response()\n\n    with httpx.client() as client:\n        response1 = client.get(\"https://test_url\")\n        response2 = client.get(\"https://test_url\")\n\n    requests = httpx_mock.get_requests()\n\n\ndef test_single_request(httpx_mock: httpxmock):\n    httpx_mock.add_response()\n\n    with httpx.client() as client:\n        response = client.get(\"https://test_url\")\n\n    request = httpx_mock.get_request()\n\n\ndef test_no_request(httpx_mock: httpxmock):\n    assert not httpx_mock.get_request()\n```\n\n### how requests are selected\n\nyou can add criteria so that requests will be returned only in case of a more specific matching.\n\n#### matching on url\n\n`url` parameter can either be a string, a python [re.pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.url](https://www.python-httpx.org/api/#url) instance.\n\nmatching is performed on the full url, query parameters included.\n\norder of parameters in the query string does not matter, however order of values do matter if the same parameter is provided more than once.\n\n#### matching on http method\n\nuse `method` parameter to specify the http method (post, put, delete, patch, head) of the requests to retrieve.\n\n`method` parameter must be a string. it will be upper-cased, so it can be provided lower cased.\n\nmatching is performed on equality.\n\n#### matching on proxy url\n\n`proxy_url` parameter can either be a string, a python [re.pattern](https://docs.python.org/3/library/re.html) instance or a [httpx.url](https://www.python-httpx.org/api/#url) instance.\n\nmatching is performed on the full proxy url, query parameters included.\n\norder of parameters in the query string does not matter, however order of values do matter if the same parameter is provided more than once.\n\n#### matching on http headers\n\nuse `match_headers` parameter to specify the http headers executing the callback.\n\nmatching is performed on equality for each provided header.\n\n#### matching on http body\n\nuse `match_content` parameter to specify the full http body executing the callback.\n\nmatching is performed on equality.\n\n##### matching on http json body\n\nuse `match_json` parameter to specify the json decoded http body executing the callback.\n\nmatching is performed on equality. you can however use `unittest.mock.any` to do partial matching.\n\nnote that `match_content` cannot be provided if `match_json` is also provided.\n\n## do not mock some requests\n\nby default, `pytest-httpx` will mock every request.\n\nbut, for instance, in case you want to write integration tests with other servers, you might want to let some requests go through.\n\nto do so, you can use the `non_mocked_hosts` fixture:\n\n```python\nimport pytest\n\n@pytest.fixture\ndef non_mocked_hosts() -> list:\n    return [\"my_local_test_host\", \"my_other_test_host\"]\n```\n\nevery other requested hosts will be mocked as in the following example\n\n```python\nimport pytest\nimport httpx\n\n@pytest.fixture\ndef non_mocked_hosts() -> list:\n    return [\"my_local_test_host\"]\n\n\ndef test_partial_mock(httpx_mock):\n    httpx_mock.add_response()\n\n    with httpx.client() as client:\n        # this request will not be mocked\n        response1 = client.get(\"https://www.my_local_test_host/sub?param=value\")\n        # this request will be mocked\n        response2 = client.get(\"https://test_url\")\n```\n\n## migrating to pytest-httpx\n\nhere is how to migrate from well-known testing libraries to `pytest-httpx`.\n\n### from responses\n\n| feature           | responses                  | pytest-httpx                |\n|:------------------|:---------------------------|:----------------------------|\n| add a response    | `responses.add()`          | `httpx_mock.add_response()` |\n| add a callback    | `responses.add_callback()` | `httpx_mock.add_callback()` |\n| retrieve requests | `responses.calls`          | `httpx_mock.get_requests()` |\n\n#### add a response or a callback\n\nundocumented parameters means that they are unchanged between `responses` and `pytest-httpx`.\nbelow is a list of parameters that will require a change in your code.\n\n| parameter            | responses                           | pytest-httpx                                                         |\n|:---------------------|:------------------------------------|:---------------------------------------------------------------------|\n| method               | `method=responses.get`              | `method=\"get\"`                                                       |\n| body (as bytes)      | `body=b\"sample\"`                    | `content=b\"sample\"`                                                  |\n| body (as str)        | `body=\"sample\"`                     | `text=\"sample\"`                                                      |\n| status code          | `status=201`                        | `status_code=201`                                                    |\n| headers              | `adding_headers={\"name\": \"value\"}`  | `headers={\"name\": \"value\"}`                                          |\n| content-type header  | `content_type=\"application/custom\"` | `headers={\"content-type\": \"application/custom\"}`                     |\n| match the full query | `match_querystring=true`            | the full query is always matched when providing the `url` parameter. |\n\nsample adding a response with `responses`:\n```python\nfrom responses import requestsmock\n\ndef test_response(responses: requestsmock):\n    responses.add(\n        method=responses.get,\n        url=\"https://test_url\",\n        body=b\"this is the response content\",\n        status=400,\n    )\n\n```\n\nsample adding the same response with `pytest-httpx`:\n```python\nfrom pytest_httpx import httpxmock\n\ndef test_response(httpx_mock: httpxmock):\n    httpx_mock.add_response(\n        method=\"get\",\n        url=\"https://test_url\",\n        content=b\"this is the response content\",\n        status_code=400,\n    )\n\n```\n\n### from aioresponses\n\n| feature        | aioresponses            | pytest-httpx                               |\n|:---------------|:------------------------|:-------------------------------------------|\n| add a response | `aioresponses.method()` | `httpx_mock.add_response(method=\"method\")` |\n| add a callback | `aioresponses.method()` | `httpx_mock.add_callback(method=\"method\")` |\n\n#### add a response or a callback\n\nundocumented parameters means that they are unchanged between `responses` and `pytest-httpx`.\nbelow is a list of parameters that will require a change in your code.\n\n| parameter       | responses            | pytest-httpx        |\n|:----------------|:---------------------|:--------------------|\n| body (as bytes) | `body=b\"sample\"`     | `content=b\"sample\"` |\n| body (as str)   | `body=\"sample\"`      | `text=\"sample\"`     |\n| body (as json)  | `payload=[\"sample\"]` | `json=[\"sample\"]`   |\n| status code     | `status=201`         | `status_code=201`   |\n\nsample adding a response with `aioresponses`:\n```python\nimport pytest\nfrom aioresponses import aioresponses\n\n\n@pytest.fixture\ndef mock_aioresponse():\n    with aioresponses() as m:\n        yield m\n\n\ndef test_response(mock_aioresponse):\n    mock_aioresponse.get(\n        url=\"https://test_url\",\n        body=b\"this is the response content\",\n        status=400,\n    )\n\n```\n\nsample adding the same response with `pytest-httpx`:\n```python\ndef test_response(httpx_mock):\n    httpx_mock.add_response(\n        method=\"get\",\n        url=\"https://test_url\",\n        content=b\"this is the response content\",\n        status_code=400,\n    )\n\n```\n",
  "docs_url": null,
  "keywords": "pytest,testing,mock,httpx",
  "license": "mit",
  "name": "pytest-httpx",
  "package_url": "https://pypi.org/project/pytest-httpx/",
  "project_url": "https://pypi.org/project/pytest-httpx/",
  "project_urls": {
    "Changelog": "https://github.com/Colin-b/pytest_httpx/blob/master/CHANGELOG.md",
    "Download": "https://pypi.org/project/pytest-httpx/",
    "GitHub": "https://github.com/Colin-b/pytest_httpx",
    "Homepage": "https://colin-b.github.io/pytest_httpx/",
    "Issues": "https://github.com/Colin-b/pytest_httpx/issues"
  },
  "release_url": "https://pypi.org/project/pytest-httpx/0.28.0/",
  "requires_dist": [
    "httpx ==0.26.*",
    "pytest ==7.*",
    "pytest-asyncio ==0.23.* ; extra == 'testing'",
    "pytest-cov ==4.* ; extra == 'testing'"
  ],
  "requires_python": ">=3.9",
  "summary": "send responses to httpx.",
  "version": "0.28.0",
  "releases": [],
  "developers": [
    "colin.bounouar.dev@gmail.com",
    "colin_bounouar"
  ],
  "kwds": "pytest_httpx pytest httpx_mock test_headers_as_httpx_headers pypi",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytest_httpx",
  "homepage": "https://colin-b.github.io/pytest_httpx/",
  "release_count": 43,
  "dependency_ids": [
    "pypi_httpx",
    "pypi_pytest",
    "pypi_pytest_asyncio",
    "pypi_pytest_cov"
  ]
}