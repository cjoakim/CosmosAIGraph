{
  "classifiers": [
    "development status :: 7 - inactive",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "========\nattrdict\n========\n.. image:: https://travis-ci.org/bcj/attrdict.svg?branch=master\n  :target: https://travis-ci.org/bcj/attrdict?branch=master\n.. image:: https://coveralls.io/repos/bcj/attrdict/badge.png?branch=master\n  :target: https://coveralls.io/r/bcj/attrdict?branch=master\n\nattrdict is an mit-licensed library that provides mapping objects that allow\ntheir elements to be accessed both as keys and as attributes::\n\n    > from attrdict import attrdict\n    > a = attrdict({'foo': 'bar'})\n    > a.foo\n    'bar'\n    > a['foo']\n    'bar'\n\nattribute access makes it easy to create convenient, hierarchical settings\nobjects::\n\n    with open('settings.yaml') as fileobj:\n        settings = attrdict(yaml.safe_load(fileobj))\n\n    cursor = connect(**settings.db.credentials).cursor()\n\n    cursor.execute(\"select column from table;\")\n\ninstallation\n============\nattrdict is in pypi, so it can be installed directly using::\n\n    $ pip install attrdict\n\nor from github::\n\n    $ git clone https://github.com/bcj/attrdict\n    $ cd attrdict\n    $ python setup.py install\n\nbasic usage\n===========\nattrdict comes with three different classes, `attrmap`, `attrdict`, and\n`attrdefault`. they are all fairly similar, as they all are mutablemappings (\nread: dictionaries) that allow creating, accessing, and deleting key-value\npairs as attributes.\n\nvalid names\n-----------\nany key can be used as an attribute as long as:\n\n#. the key represents a valid attribute (i.e., it is a string comprised only of\n   alphanumeric characters and underscores that doesn't start with a number)\n#. the key represents a public attribute (i.e., it doesn't start with an\n   underscore). this is done (in part) so that implementation changes between\n   minor and micro versions don't force major version changes.\n#. the key does not shadow a class attribute (e.g., get).\n\nattributes vs. keys\n-------------------\nthere is a minor difference between accessing a value as an attribute vs.\naccessing it as a key, is that when a dict is accessed as an attribute, it will\nautomatically be converted to an attr object. this allows you to recursively\naccess keys::\n\n    > attr = attrdict({'foo': {'bar': 'baz'}})\n    > attr.foo.bar\n    'baz'\n\nrelatedly, by default, sequence types that aren't `bytes`, `str`, or `unicode`\n(e.g., lists, tuples) will automatically be converted to tuples, with any\nmappings converted to attrs::\n\n    > attr = attrdict({'foo': [{'bar': 'baz'}, {'bar': 'qux'}]})\n    > for sub_attr in attr.foo:\n    >     print(sub_attr.foo)\n    'baz'\n    'qux'\n\nto get this recursive functionality for keys that cannot be used as attributes,\nyou can replicate the behavior by calling the attr object::\n\n    > attr = attrdict({1: {'two': 3}})\n    > attr(1).two\n    3\n\nclasses\n-------\nattrdict comes with three different objects, `attrmap`, `attrdict`, and\n`attrdefault`.\n\nattrmap\n^^^^^^^\nthe most basic implementation. use this if you want to limit the number of\ninvalid keys, or otherwise cannot use `attrdict`\n\nattrdict\n^^^^^^^^\nan attr object that subclasses `dict`. you should be able to use this\nabsolutely anywhere you can use a `dict`. while this is probably the class you\nwant to use, there are a few caveats that follow from this being a `dict` under\nthe hood.\n\nthe `copy` method (which returns a shallow copy of the mapping) returns a\n`dict` instead of an `attrdict`.\n\nrecursive attribute access results in a shallow copy, so recursive assignment\nwill fail (as you will be writing to a copy of that dictionary)::\n\n    > attr = attrdict('foo': {})\n    > attr.foo.bar = 'baz'\n    > attr.foo\n    {}\n\nassignment as keys will still work::\n\n    > attr = attrdict('foo': {})\n    > attr['foo']['bar'] = 'baz'\n    > attr.foo\n    {'bar': 'baz'}\n\nif either of these caveats are deal-breakers, or you don't need your object to\nbe a `dict`, consider using `attrmap` instead.\n\nattrdefault\n^^^^^^^^^^^\nat attr object that behaves like a `defaultdict`. this allows on-the-fly,\nautomatic key creation::\n\n    > attr = attrdefault(int, {})\n    > attr.foo += 1\n    > attr.foo\n    1\n\nattrdefault also has a `pass_key` option that passes the supplied key to the\n`default_factory`::\n\n    > attr = attrdefault(sorted, {}, pass_key=true)\n    > attr.banana\n    ['a', 'a', 'a', 'b', 'n', 'n']\n\nmerging\n-------\nall three attr classes can be merged with eachother or other mappings using the\n``+`` operator. for conflicting keys, the right dict's value will be\npreferred, but in the case of two dictionary values, they will be\nrecursively merged::\n\n    > a = {'foo': 'bar', 'alpha': {'beta': 'a', 'a': 'a'}}\n    > b = {'lorem': 'ipsum', 'alpha': {'bravo': 'b', 'a': 'b'}}\n    > attrdict(a) + b\n    {'foo': 'bar', 'lorem': 'ipsum', 'alpha': {'beta': 'a', 'bravo': 'b', 'a': 'b'}}\n\nnote: attrdict's add is not commutative, ``a + b != b + a``::\n\n    > a = {'foo': 'bar', 'alpha': {'beta': 'b', 'a': 0}}\n    > b = {'lorem': 'ipsum', 'alpha': {'bravo': 'b', 'a': 1}}\n    > b + attrdict(a)\n    {'foo': 'bar', 'lorem': 'ipsum', 'alpha': {'beta': 'a', 'bravo': 'b', 'a': }}\n\nsequences\n---------\nby default, items in non-string sequences (e.g. lists, tuples) will be\nconverted to attrdicts::\n\n    > adict = attrdict({'list': [{'value': 1}, {'value': 2}]})\n    > for element in adict.list:\n    >     element.value\n    1\n    2\n\nthis will not occur if you access the attrdict as a dictionary::\n\n    > adict = attrdict({'list': [{'value': 1}, {'value': 2}]})\n    > for element in adict['list']:\n    >     isinstance(element, attrdict)\n    false\n    false\n\nto disable this behavior globally, pass the attribute ``recursive=false`` to\nthe constructor::\n\n    > adict = attrdict({'list': [{'value': 1}, {'value': 2}]}, recursive=false)\n    > for element in adict.list:\n    >     isinstance(element, attrdict)\n    false\n    false\n\nwhen merging an attrdict with another mapping, this behavior will be disabled\nif at least one of the merged items is an attrdict that has set ``recursive``\nto ``false``.\n\nlicense\n=======\nattrdict is released under a mit license.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "attrdict",
  "package_url": "https://pypi.org/project/attrdict/",
  "project_url": "https://pypi.org/project/attrdict/",
  "project_urls": {
    "Homepage": "https://github.com/bcj/AttrDict"
  },
  "release_url": "https://pypi.org/project/attrdict/2.0.1/",
  "requires_dist": [
    "six"
  ],
  "requires_python": "",
  "summary": "a dict with attribute-style access",
  "version": "2.0.1",
  "releases": [],
  "developers": [
    "brendan@bcjbcj.ca",
    "brendan_curran"
  ],
  "kwds": "attrdicts attrdict defaultdict attributes sub_attr",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_attrdict",
  "homepage": "https://github.com/bcj/attrdict",
  "release_count": 14,
  "dependency_ids": [
    "pypi_six"
  ]
}