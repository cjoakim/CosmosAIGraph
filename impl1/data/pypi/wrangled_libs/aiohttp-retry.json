{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# simple aiohttp retry client\n\n[![codecov](https://codecov.io/gh/inyutin/aiohttp_retry/branch/master/graph/badge.svg?token=zwgaxsf1sp)](https://codecov.io/gh/inyutin/aiohttp_retry)\n\npython 3.7 or higher.\n\n**install**: `pip install aiohttp-retry`.\n\n[![\"buy me a coffee\"](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/inyutin)\n\n\n### breaking api changes\n- everything between [2.7.0 - 2.8.3) is yanked.  \nthere is a bug with evaluate_response_callback, it led to infinite retries\n\n- 2.8.0 is incorrect and yanked.\nhttps://github.com/inyutin/aiohttp_retry/issues/79\n\n- since 2.5.6 this is a new parameter in ```get_timeout``` func called \"response\".  \nif you have defined your own ```retryoptions```, you should add this param into it.\nissue about this: https://github.com/inyutin/aiohttp_retry/issues/59\n\n### examples of usage:\n```python\nfrom aiohttp_retry import retryclient, exponentialretry\n\nasync def main():\n    retry_options = exponentialretry(attempts=1)\n    retry_client = retryclient(raise_for_status=false, retry_options=retry_options)\n    async with retry_client.get('https://ya.ru') as response:\n        print(response.status)\n        \n    await retry_client.close()\n```\n\n```python\nfrom aiohttp import clientsession\nfrom aiohttp_retry import retryclient \n\nasync def main():\n    client_session = clientsession()\n    retry_client = retryclient(client_session=client_session)\n    async with retry_client.get('https://ya.ru') as response:\n        print(response.status)\n\n    await client_session.close()\n```\n\n```python\nfrom aiohttp_retry import retryclient, randomretry\n\nasync def main():\n    retry_options = randomretry(attempts=1)\n    retry_client = retryclient(raise_for_status=false, retry_options=retry_options)\n\n    response = await retry_client.get('/ping')\n    print(response.status)\n        \n    await retry_client.close()\n```\n\n```python\nfrom aiohttp_retry import retryclient\n\nasync def main():\n    async with retryclient() as client:\n        async with client.get('https://ya.ru') as response:\n            print(response.status)\n```\n\nyou can change parameters between attempts by passing multiple requests params:\n```python\nfrom aiohttp_retry import retryclient, requestparams, exponentialretry\n\nasync def main():\n    retry_client = retryclient(raise_for_status=false)\n\n    async with retry_client.requests(\n        params_list=[\n            requestparams(\n                method='get',\n                url='https://ya.ru',\n            ),\n            requestparams(\n                method='get',\n                url='https://ya.ru',\n                headers={'some_header': 'some_value'},\n            ),\n        ]\n    ) as response:\n        print(response.status)\n        \n    await retry_client.close()\n```\n\nyou can also add some logic, f.e. logging, on failures by using trace mechanic.\n```python\nimport logging\nimport sys\nfrom types import simplenamespace\n\nfrom aiohttp import clientsession, traceconfig, tracerequeststartparams\n\nfrom aiohttp_retry import retryclient, exponentialretry\n\n\nhandler = logging.streamhandler(sys.stdout)\nlogging.basicconfig(handlers=[handler])\nlogger = logging.getlogger(__name__)\nretry_options = exponentialretry(attempts=2)\n\n\nasync def on_request_start(\n    session: clientsession,\n    trace_config_ctx: simplenamespace,\n    params: tracerequeststartparams,\n) -> none:\n    current_attempt = trace_config_ctx.trace_request_ctx['current_attempt']\n    if retry_options.attempts <= current_attempt:\n        logger.warning('wow! we are in last attempt')\n\n\nasync def main():\n    trace_config = traceconfig()\n    trace_config.on_request_start.append(on_request_start)\n    retry_client = retryclient(retry_options=retry_options, trace_configs=[trace_config])\n\n    response = await retry_client.get('https://httpstat.us/503', ssl=false)\n    print(response.status)\n\n    await retry_client.close()\n```\nlook tests for more examples. \\\n**be aware: last request returns as it is.**  \n**if the last request ended with exception, that this exception will be raised from retryclient request**\n\n### documentation\n`retryclient` takes the same arguments as clientsession[[docs](https://docs.aiohttp.org/en/stable/client_reference.html)] \\\n`retryclient` has methods:\n- request\n- get\n- options\n- head\n- post\n- put\n- patch\n- put\n- delete\n\nthey are same as for `clientsession`, but take one possible additional argument: \n```python\nclass retryoptionsbase:\n    def __init__(\n        self,\n        attempts: int = 3,  # how many times we should retry\n        statuses: optional[iterable[int]] = none,  # on which statuses we should retry\n        exceptions: optional[iterable[type[exception]]] = none,  # on which exceptions we should retry\n        retry_all_server_errors: bool = true,  # if should retry all 500 errors or not\n        # a callback that will run on response to decide if retry\n        evaluate_response_callback: optional[evaluateresponsecallbacktype] = none,\n    ):\n        ...\n\n    @abc.abstractmethod\n    def get_timeout(self, attempt: int, response: optional[response] = none) -> float:\n        raise notimplementederror\n\n```\nyou can specify `retryoptions` both for `retryclient` and it's methods. \n`retryoptions` in methods override `retryoptions` defined in `retryclient` constructor.\n\n**important**: by default all 5xx responses are retried + statuses you specified as ```statuses``` param\nif you will pass ```retry_all_server_errors=false``` than you can manually set what 5xx errors to retry.\n\nyou can define your own timeouts logic or use: \n- ```exponentialretry``` with exponential backoff\n- ```randomretry``` for random backoff\n- ```listretry``` with backoff you predefine by list\n- ```fibonacciretry``` with backoff that looks like fibonacci sequence\n- ```jitterretry``` exponential retry with a bit of randomness\n\n**important**: you can proceed server response as an parameter for calculating next timeout.  \nhowever this response can be none, server didn't make a response or you have set up ```raise_for_status=true```\nlook here for an example: https://github.com/inyutin/aiohttp_retry/issues/59\n\nadditionally, you can specify ```evaluate_response_callback```. it receive a ```clientresponse``` and decide to retry or not by returning a bool.\nit can be useful, if server api sometimes response with malformed data.\n\n#### request trace context\n`retryclient` add *current attempt number* to `request_trace_ctx` (see examples, \nfor more info see [aiohttp doc](https://docs.aiohttp.org/en/stable/client_advanced.html#aiohttp-client-tracing)).\n\n### change parameters between retries\n`retryclient` also has a method called `requests`. this method should be used if you want to make requests with different params.\n```python\n@dataclass\nclass requestparams:\n    method: str\n    url: _raw_url_type\n    trace_request_ctx: optional[dict[str, any]] = none\n    kwargs: optional[dict[str, any]] = none\n```\n\n```python\ndef requests(\n    self,\n    params_list: list[requestparams],\n    retry_options: optional[retryoptionsbase] = none,\n    raise_for_status: optional[bool] = none,\n) -> _requestcontext:\n```\n\nyou can find an example of usage above or in tests.  \nbut basically `requestparams` is a structure to define params for `clientsession.request` func.  \n`method`, `url`, `headers` `trace_request_ctx` defined outside kwargs, because they are popular.  \n\nthere is also an old way to change url between retries by specifying ```url``` as list of urls. example:\n```python\nfrom aiohttp_retry import retryclient\n\nretry_client = retryclient()\nasync with retry_client.get(url=['/internal_error', '/ping']) as response:\n    text = await response.text()\n    assert response.status == 200\n    assert text == 'ok!'\n\nawait retry_client.close()\n```\n\nin this example we request ```/interval_error```, fail and then successfully request ```/ping```.\nif you specify less urls than ```attempts``` number in ```retryoptions```, ```retryclient``` will request last url at last attempts.\nthis means that in example above we would request ```/ping``` once again in case of failure.\n\n### types\n\n`aiohttp_retry` is a typed project. it should be fully compatablie with mypy.\n\nit also introduce one special type:\n```\nclienttype = union[clientsession, retryclient]\n```\n\nthis type can be imported by ```from aiohttp_retry.types import clienttype```\n",
  "docs_url": null,
  "keywords": "aiohttp retry client",
  "license": "mit",
  "name": "aiohttp-retry",
  "package_url": "https://pypi.org/project/aiohttp-retry/",
  "project_url": "https://pypi.org/project/aiohttp-retry/",
  "project_urls": {
    "Homepage": "https://github.com/inyutin/aiohttp_retry"
  },
  "release_url": "https://pypi.org/project/aiohttp-retry/2.8.3/",
  "requires_dist": [
    "aiohttp"
  ],
  "requires_python": ">=3.7",
  "summary": "simple retry client for aiohttp",
  "version": "2.8.3",
  "releases": [],
  "developers": [
    "dmitry_inyutin",
    "inyutin.da@gmail.com"
  ],
  "kwds": "aiohttp_retry retryclient retry_client retry_options retryoptions",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_aiohttp_retry",
  "homepage": "https://github.com/inyutin/aiohttp_retry",
  "release_count": 33,
  "dependency_ids": [
    "pypi_aiohttp"
  ]
}