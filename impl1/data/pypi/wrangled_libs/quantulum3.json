{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering",
    "topic :: text processing :: linguistic"
  ],
  "description": "# quantulum3\n\n [![travis master build state](https://app.travis-ci.com/nielstron/quantulum3.svg?branch=master \"travis master build state\")](https://app.travis-ci.com/nielstron/quantulum3)\n [![coverage status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=master)](https://coveralls.io/github/nielstron/quantulum3?branch=master)\n [![pypi version](https://badge.fury.io/py/quantulum3.svg)](https://pypi.org/project/quantulum3/)\n ![pypi - python version](https://img.shields.io/pypi/pyversions/quantulum3.svg)\n [![pypi - status](https://img.shields.io/pypi/status/quantulum3.svg)](https://pypi.org/project/quantulum3/)\n\npython library for information extraction of quantities, measurements\nand their units from unstructured text. it is able to disambiguate between similar\nlooking units based on their *k-nearest neighbours* in their [glove](https://nlp.stanford.edu/projects/glove/) vector representation\nand their [wikipedia](https://en.wikipedia.org/) page.\n\nthis is the python 3 compatible fork of [recastrodiaz\\'\nfork](https://github.com/recastrodiaz/quantulum) of [grhawks\\'\nfork](https://github.com/grhawk/quantulum) of [the original by marco\nlagi](https://github.com/marcolagi/quantulum).\nthe compatibility with the newest version of sklearn is based on\nthe fork of [sohrabtowfighi](https://github.com/sohrabtowfighi/quantulum).\n\n## user guide\n\n### installation\n\n```bash\npip install quantulum3\n```\n\nto install dependencies for using or training the disambiguation classifier, use\n\n```bash\npip install quantulum3[classifier]\n```\n\nthe disambiguation classifier is used when the parser find two or more units that are a match for the text.\n\n### usage\n\n```pycon\n>>> from quantulum3 import parser\n>>> quants = parser.parse('i want 2 liters of wine')\n>>> quants\n[quantity(2, 'litre')]\n```\n\nthe *quantity* class stores the surface of the original text it was\nextracted from, as well as the (start, end) positions of the match:\n\n```pycon\n>>> quants[0].surface\nu'2 liters'\n>>> quants[0].span\n(7, 15)\n```\n\nthe *value* attribute provides the parsed numeric value and the *unit.name*\nattribute provides the name of the parsed unit:\n\n```pycon\n>>> quants[0].value\n2.0\n>>> quants[0].unit.name\n'litre'\n```\n\nan inline parser that embeds the parsed quantities in the text is also\navailable (especially useful for debugging):\n\n```pycon\n>>> print parser.inline_parse('i want 2 liters of wine')\ni want 2 liters {quantity(2, \"litre\")} of wine\n```\n\nas the parser is also able to parse dimensionless numbers,\nthis library can also be used for simple number extraction.\n\n```pycon\n>>> print parser.parse('i want two')\n[quantity(2, 'dimensionless')]\n```\n\n### units and entities\n\nall units (e.g. *litre*) and the entities they are associated to (e.g.\n*volume*) are reconciled against wikipedia:\n\n```pycon\n>>> quants[0].unit\nunit(name=\"litre\", entity=entity(\"volume\"), uri=https://en.wikipedia.org/wiki/litre)\n\n>>> quants[0].unit.entity\nentity(name=\"volume\", uri=https://en.wikipedia.org/wiki/volume)\n```\n\nthis library includes more than 290 units and 75 entities. it also\nparses spelled-out numbers, ranges and uncertainties:\n\n```pycon\n>>> parser.parse('i want a gallon of beer')\n[quantity(1, 'gallon')]\n\n>>> parser.parse('the lhc smashes proton beams at 12.8\u201313.0 tev')\n[quantity(12.8, \"teraelectronvolt\"), quantity(13, \"teraelectronvolt\")]\n\n>>> quant = parser.parse('the lhc smashes proton beams at 12.9\u00b10.1 tev')\n>>> quant[0].uncertainty\n0.1\n```\n\nnon-standard units usually don\\'t have a wikipedia page. the parser will\nstill try to guess their underlying entity based on their\ndimensionality:\n\n```pycon\n>>> parser.parse('sound travels at 0.34 km/s')[0].unit\nunit(name=\"kilometre per second\", entity=entity(\"speed\"), uri=none)\n```\n\n### disambiguation\n\nif the parser detects an ambiguity, a classifier based on the wikipedia\npages of the ambiguous units or entities tries to guess the right one:\n\n```pycon\n>>> parser.parse('i spent 20 pounds on this!')\n[quantity(20, \"pound sterling\")]\n\n>>> parser.parse('it weighs no more than 20 pounds')\n[quantity(20, \"pound-mass\")]\n```\n\nor:\n\n```pycon\n>>> text = 'the average density of the earth is about 5.5x10-3 kg/cm\u00b3'\n>>> parser.parse(text)[0].unit.entity\nentity(name=\"density\", uri=https://en.wikipedia.org/wiki/density)\n\n>>> text = 'the amount of o\u2082 is 2.98e-4 kg per liter of atmosphere'\n>>> parser.parse(text)[0].unit.entity\nentity(name=\"concentration\", uri=https://en.wikipedia.org/wiki/concentration)\n```\n\nin addition to that, the classifier is trained on the most similar words to\nall of the units surfaces, according to their distance in [glove](https://nlp.stanford.edu/projects/glove/)\nvector representation.\n\n## spoken version\n\nquantulum classes include methods to convert them to a speakable unit.\n\n```pycon\n>>> parser.parse(\"gimme 10e9 gw now!\")[0].to_spoken()\nten billion gigawatts\n>>> parser.inline_parse_and_expand(\"gimme $1e10 now and also 1 tw and 0.5 j!\")\ngimme ten billion dollars now and also one terawatt and zero point five joules!\n```\n\n### manipulation\n\nwhile quantities cannot be manipulated within this library, there are\nmany great options out there:\n\n- [pint](https://pint.readthedocs.org/en/latest/)\n- [natu](http://kdavies4.github.io/natu/)\n- [quantities](http://python-quantities.readthedocs.org/en/latest/)\n\n## extension\n\n### training the classifier\n\nif you want to train the classifier yourself, you will need the dependencies for the classifier (see installation).\n\nuse `quantulum3-training` on the command line, the script `quantulum3/scripts/train.py` or the method `train_classifier` in `quantulum3.classifier` to train the classifier.\n\n``` bash\nquantulum3-training --lang <language> --data <path/to/training/file.json> --output <path/to/output/file.joblib>\n```\n\nyou can pass multiple training files in to the training command. the output is in joblib format.\n\nto use your custom model, pass the path to the trained model file to the\nparser:\n\n```pyton\nparser = parser.parse(<text>, classifier_path=\"path/to/model.joblib\")\n```\n\nexample training files can be found in `quantulum3/_lang/<language>/train`.\n\nif you want to create a new or different `similars.json`, install `pymagnitude`.\n\nfor the extraction of nearest neighbours from a vector word representation file, \nuse `scripts/extract_vere.py`. it automatically extracts the `k` nearest neighbours\nin vector space of the vector representation for each of the possible surfaces\nof the ambiguous units. the resulting neighbours are stored in `quantulum3/similars.json`\nand automatically included for training.\n\nthe file provided should be in `.magnitude` format as other formats are first\nconverted to a `.magnitude` file on-the-run. check out\n[pre-formatted magnitude formatted word-embeddings](https://github.com/plasticityai/magnitude#pre-converted-magnitude-formats-of-popular-embeddings-models)\nand [magnitude](https://github.com/plasticityai/magnitude) for more information.\n\n### additional units\n\nit is possible to add additional entities and units to be parsed by quantulum. these will be added to the default units and entities. see below code for an example invocation:\n\n```pycon\n>>> from quantulum3.load import add_custom_unit, remove_custom_unit\n>>> add_custom_unit(name=\"schlurp\", surfaces=[\"slp\"], entity=\"dimensionless\")\n>>> parser.parse(\"this extremely sharp tool is precise up to 0.5 slp\")\n[quantity(0.5, \"unit(name=\"schlurp\", entity=entity(\"dimensionless\"), uri=none)\")]\n```\n\nthe keyword arguments to the function `add_custom_unit` are directly translated\nto the properties of the unit to be created.\n\n### custom units and entities\n\nit is possible to load a completely custom set of units and entities. this can be done by passing a list of file paths to the load_custom_units and load_custom_entities functions. loading custom untis and entities will replace the default units and entities that are normally loaded.\n\nthe recomended way to load quantities is via a context manager:\n\n```pycon\n>>> from quantulum3 import load, parser\n>>> with load.customquantities([\"path/to/units.json\"], [\"path/to/entities.json\"]):\n>>>     parser.parse(\"this extremely sharp tool is precise up to 0.5 slp\")\n\n[quantity(0.5, \"unit(name=\"schlurp\", entity=entity(\"dimensionless\"), uri=none)\")]\n\n>>> # default units and entities are loaded again\n```\n\nbut it is also possible to load custom units and entities manually:\n\n```pycon\n>>> from quantulum3 import load, parser\n\n>>> load.load_custom_units([\"path/to/units.json\"])\n>>> load.load_custom_entities([\"path/to/entities.json\"])\n>>> parser.parse(\"this extremely sharp tool is precise up to 0.5 slp\")\n\n[quantity(0.5, \"unit(name=\"schlurp\", entity=entity(\"dimensionless\"), uri=none)\")]\n\n>>> # remove custom units and entities and load default units and entities\n>>> load.reset_quantities()\n```\n\nsee the developer guide below for more information about the format of units and entities files.\n\n## developer guide\n\n### adding units and entities\n\nsee *units.json* for the complete list of units and *entities.json* for\nthe complete list of entities. the criteria for adding units have been:\n\n- the unit has (or is redirected to) a wikipedia page\n- the unit is in common use (e.g. not the [premetric swedish units of\n    measurement](https://en.wikipedia.org/wiki/swedish_units_of_measurement#length)).\n\nit\\'s easy to extend these two files to the units/entities of interest.\nhere is an example of an entry in *entities.json*:\n\n```json\n\"speed\": {\n    \"dimensions\": [{\"base\": \"length\", \"power\": 1}, {\"base\": \"time\", \"power\": -1}],\n    \"uri\": \"https://en.wikipedia.org/wiki/speed\"\n}\n```\n\n- the *name* of an entity is its key. names are required to be unique.\n- *uri* is the name of the wikipedia page of the entity. (i.e. `https://en.wikipedia.org/wiki/speed` => `speed`)\n- *dimensions* is the dimensionality, a list of dictionaries each\n    having a *base* (the name of another entity) and a *power* (an\n    integer, can be negative).\n\nhere is an example of an entry in *units.json*:\n\n```json\n\"metre per second\": {\n    \"surfaces\": [\"metre per second\", \"meter per second\"],\n    \"entity\": \"speed\",\n    \"uri\": \"metre_per_second\",\n    \"dimensions\": [{\"base\": \"metre\", \"power\": 1}, {\"base\": \"second\", \"power\": -1}],\n    \"symbols\": [\"mps\"]\n},\n\"year\": {\n    \"surfaces\": [ \"year\", \"annum\" ],\n    \"entity\": \"time\",\n    \"uri\": \"year\",\n    \"dimensions\": [],\n    \"symbols\": [ \"a\", \"y\", \"yr\" ],\n    \"prefixes\": [ \"k\", \"m\", \"g\", \"t\", \"p\", \"e\" ]\n}\n```\n\n- the *name* of a unit is its key. names are required to be unique.\n- *uri* follows the same scheme as in the *entities.json*\n- *surfaces* is a list of strings that refer to that unit. the library\n    takes care of plurals, no need to specify them.\n- *entity* is the name of an entity in *entities.json*\n- *dimensions* follows the same schema as in *entities.json*, but the\n    *base* is the name of another unit, not of another entity.\n- *symbols* is a list of possible symbols and abbreviations for that\n    unit.\n- *prefixes* is an optional list. it can contain [metric](https://en.wikipedia.org/wiki/metric_prefix) and [binary prefixes](https://en.wikipedia.org/wiki/binary_prefix) and\n    automatically generates according units. if you want to\n    add specifics (like different surfaces) you need to create an entry for that\n    prefixes version on its own.\n\nall fields are case sensitive.\n\n### contributing\n\n`dev` build: \n\n[![travis dev build state](https://travis-ci.com/nielstron/quantulum3.svg?branch=dev \"travis dev build state\")](https://travis-ci.com/nielstron/quantulum3)\n[![coverage status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=dev)](https://coveralls.io/github/nielstron/quantulum3?branch=dev)\n\nif you'd like to contribute follow these steps:\n1. clone a fork of this project into your workspace\n2. run `pip install -e .` at the root of your development folder.\n3. `pip install pipenv` and `pipenv shell`\n4. inside the project folder run `pipenv install --dev`\n5. make your changes\n6. run `scripts/format.sh` and `scripts/build.py` from the package root directory.\n7. test your changes with `python3 setup.py test` \n(optional, will be done automatically after pushing)\n8. create a pull request when having commited and pushed your changes\n\n### language support\n\n[![travis dev build state](https://travis-ci.com/nielstron/quantulum3.svg?branch=language_support \"travis dev build state\")](https://travis-ci.com/nielstron/quantulum3)\n[![coverage status](https://coveralls.io/repos/github/nielstron/quantulum3/badge.svg?branch=language_support)](https://coveralls.io/github/nielstron/quantulum3?branch=dev)\n\nthere is a branch for language support, namely `language_support`.\nfrom inspecting the `readme` file in the `_lang` subdirectory and\nthe functions and values given in the new `_lang.en_us` submodule,\none should be able to create own language submodules.\nthe new language modules should automatically be invoked and be available,\nboth through the `lang=` keyword argument in the parser functions as well\nas in the automatic unittests.\n\nno changes outside the own language submodule folder (i.e. `_lang.de_de`) should\nbe necessary. if there are problems implementing a new language, don't hesitate to open an issue.\n",
  "docs_url": null,
  "keywords": "information extraction,quantities,units,measurements,nlp,natural language processing,text mining,text processing",
  "license": "mit",
  "name": "quantulum3",
  "package_url": "https://pypi.org/project/quantulum3/",
  "project_url": "https://pypi.org/project/quantulum3/",
  "project_urls": {
    "Download": "https://github.com/nielstron/quantulum3/tarball/master",
    "Homepage": "https://github.com/nielstron/quantulum3"
  },
  "release_url": "https://pypi.org/project/quantulum3/0.9.0/",
  "requires_dist": [
    "inflect",
    "num2words",
    "numpy ; extra == 'classifier'",
    "scipy ; extra == 'classifier'",
    "scikit-learn ; extra == 'classifier'",
    "joblib ; extra == 'classifier'",
    "wikipedia ; extra == 'classifier'",
    "stemming ; extra == 'classifier'"
  ],
  "requires_python": "",
  "summary": "extract quantities from unstructured text.",
  "version": "0.9.0",
  "releases": [],
  "developers": [
    "marco_lagi",
    "n.muendler@web.de"
  ],
  "kwds": "quantulum3 quantulum python3 python quants",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_quantulum3",
  "homepage": "https://github.com/nielstron/quantulum3",
  "release_count": 39,
  "dependency_ids": [
    "pypi_inflect",
    "pypi_joblib",
    "pypi_num2words",
    "pypi_numpy",
    "pypi_scikit_learn",
    "pypi_scipy",
    "pypi_stemming",
    "pypi_wikipedia"
  ]
}