{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "# sqllineage\nsql lineage analysis tool powered by python\n\n[![image](https://img.shields.io/pypi/v/sqllineage.svg)](https://pypi.org/project/sqllineage/)\n[![image](https://img.shields.io/pypi/status/sqllineage.svg)](https://pypi.org/project/sqllineage/)\n[![image](https://img.shields.io/pypi/pyversions/sqllineage.svg)](https://pypi.org/project/sqllineage/)\n[![image](https://img.shields.io/pypi/l/sqllineage.svg)](https://pypi.org/project/sqllineage/)\n[![build status](https://github.com/reata/sqllineage/workflows/build/badge.svg)](https://github.com/reata/sqllineage/actions)\n[![documentation status](https://readthedocs.org/projects/sqllineage/badge/?version=latest)](https://sqllineage.readthedocs.io/en/latest/?badge=latest)\n[![codecov](https://codecov.io/gh/reata/sqllineage/branch/master/graph/badge.svg)](https://codecov.io/gh/reata/sqllineage)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![security: bandit](https://img.shields.io/badge/security-bandit-yellow.svg)](https://github.com/pycqa/bandit)\n\nnever get the hang of a sql parser? sqllineage comes to the rescue. given a sql command, sqllineage will tell you its\nsource and target tables, without worrying about tokens, keyword, identifier and all the jagons used by sql parsers.\n\nbehind the scene, sqllineage pluggable leverages parser library ([`sqlfluff`](https://github.com/sqlfluff/sqlfluff) \nand [`sqlparse`](https://github.com/andialbrecht/sqlparse)) to parse the sql command, analyze the ast, stores the lineage\ninformation in a graph (using graph library [`networkx`](https://github.com/networkx/networkx)), and brings you all the \nhuman-readable result with ease.\n\n## demo & documentation\ntalk is cheap, show me a [demo](https://reata.github.io/sqllineage/).\n\n[documentation](https://sqllineage.readthedocs.io) is online hosted by readthedocs, and you can check the \n[release note](https://sqllineage.readthedocs.io/en/latest/release_note/changelog.html) there.\n\n\n## quick start\ninstall sqllineage via pypi:\n```bash\n$ pip install sqllineage\n```\n\nusing sqllineage command to parse a quoted-query-string:\n```\n$ sqllineage -e \"insert into db1.table1 select * from db2.table2\"\nstatements(#): 1\nsource tables:\n    db2.table2\ntarget tables:\n    db1.table1\n```\n\nor you can parse a sql file with -f option:\n```\n$ sqllineage -f foo.sql\nstatements(#): 1\nsource tables:\n    db1.table_foo\n    db1.table_bar\ntarget tables:\n    db2.table_baz\n```\n\n## advanced usage\n\n### multiple sql statements\nlineage result combined for multiple sql statements, with intermediate tables identified:\n```\n$ sqllineage -e \"insert into db1.table1 select * from db2.table2; insert into db3.table3 select * from db1.table1;\"\nstatements(#): 2\nsource tables:\n    db2.table2\ntarget tables:\n    db3.table3\nintermediate tables:\n    db1.table1\n```\n\n### verbose lineage result\nand if you want to see lineage result for every sql statement, just toggle verbose option\n```\n$ sqllineage -v -e \"insert into db1.table1 select * from db2.table2; insert into db3.table3 select * from db1.table1;\"\nstatement #1: insert into db1.table1 select * from db2.table2;\n    table read: [table: db2.table2]\n    table write: [table: db1.table1]\n    table cte: []\n    table rename: []\n    table drop: []\nstatement #2: insert into db3.table3 select * from db1.table1;\n    table read: [table: db1.table1]\n    table write: [table: db3.table3]\n    table cte: []\n    table rename: []\n    table drop: []\n==========\nsummary:\nstatements(#): 2\nsource tables:\n    db2.table2\ntarget tables:\n    db3.table3\nintermediate tables:\n    db1.table1\n```\n\n### dialect-awareness lineage\nby default, sqllineage doesn't validate your sql and could give confusing result in case of invalid sql syntax.\nin addition, different sql dialect has different set of keywords, further weakening sqllineage's capabilities when \nkeyword used as table name or column name. to reduce the impact, user are strongly encouraged to pass the dialect to \nassist the lineage analyzing. \n\ntake below example, `analyze` is a reserved keyword in postgresql. default non-validating dialect gives incomplete result,\nwhile ansi dialect gives the correct one and postgres dialect tells you this causes syntax error:\n```\n$ sqllineage -e \"insert into analyze select * from foo;\"\nstatements(#): 1\nsource tables:\n    <default>.foo\ntarget tables:\n    \n$ sqllineage -e \"insert into analyze select * from foo;\" --dialect=ansi\nstatements(#): 1\nsource tables:\n    <default>.foo\ntarget tables:\n    <default>.analyze\n\n$ sqllineage -e \"insert into analyze select * from foo;\" --dialect=postgres\n...\nsqllineage.exceptions.invalidsyntaxexception: this sql statement is unparsable, please check potential syntax error for sql\n```\n\nuse `sqllineage --dialects` to see all available dialects.\n\n### column-level lineage\nwe also support column level lineage in command line interface, set level option to column, all column lineage path will \nbe printed.\n\n```sql\ninsert overwrite table foo\nselect a.col1,\n       b.col1     as col2,\n       c.col3_sum as col3,\n       col4,\n       d.*\nfrom bar a\n         join baz b\n              on a.id = b.bar_id\n         left join (select bar_id, sum(col3) as col3_sum\n                    from qux\n                    group by bar_id) c\n                   on a.id = sq.bar_id\n         cross join quux d;\n\ninsert overwrite table corge\nselect a.col1,\n       a.col2 + b.col2 as col2\nfrom foo a\n         left join grault b\n              on a.col1 = b.col1;\n```\n\nsuppose this sql is stored in a file called foo.sql\n\n```\n$ sqllineage -f foo.sql -l column\n<default>.corge.col1 <- <default>.foo.col1 <- <default>.bar.col1\n<default>.corge.col2 <- <default>.foo.col2 <- <default>.baz.col1\n<default>.corge.col2 <- <default>.grault.col2\n<default>.foo.* <- <default>.quux.*\n<default>.foo.col3 <- c.col3_sum <- <default>.qux.col3\n<default>.foo.col4 <- col4\n```\n\n### lineage visualization\none more cool feature, if you want a graph visualization for the lineage result, toggle graph-visualization option\n\nstill using the above sql file\n```\nsqllineage -g -f foo.sql\n```\na webserver will be started, showing dag representation of the lineage result in browser:\n\n- table-level lineage\n\n<img src=\"https://raw.githubusercontent.com/reata/sqllineage/master/docs/_static/table.jpg\" alt=\"table-level lineage\">\n\n- column-level lineage\n\n<img src=\"https://raw.githubusercontent.com/reata/sqllineage/master/docs/_static/column.jpg\" alt=\"column-level lineage\">\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "sqllineage",
  "package_url": "https://pypi.org/project/sqllineage/",
  "project_url": "https://pypi.org/project/sqllineage/",
  "project_urls": {
    "Homepage": "https://github.com/reata/sqllineage"
  },
  "release_url": "https://pypi.org/project/sqllineage/1.4.9/",
  "requires_dist": [
    "sqlparse ==0.4.4",
    "networkx >=2.4",
    "sqlfluff ==2.3.5",
    "bandit ; extra == 'ci'",
    "black ; extra == 'ci'",
    "flake8 ; extra == 'ci'",
    "flake8-blind-except ; extra == 'ci'",
    "flake8-builtins ; extra == 'ci'",
    "flake8-import-order ; extra == 'ci'",
    "flake8-logging-format ; extra == 'ci'",
    "mypy ; extra == 'ci'",
    "pytest ; extra == 'ci'",
    "pytest-cov ; extra == 'ci'",
    "tox ; extra == 'ci'",
    "twine ; extra == 'ci'",
    "wheel ; extra == 'ci'",
    "Sphinx >=3.2.0 ; extra == 'docs'",
    "sphinx-rtd-theme >=0.5.0 ; extra == 'docs'"
  ],
  "requires_python": ">=3.8",
  "summary": "sql lineage analysis tool powered by python",
  "version": "1.4.9",
  "releases": [],
  "developers": [
    "reata",
    "reddevil.hjw@gmail.com"
  ],
  "kwds": "sqllineage sqlparse lineage pyversions db3",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_sqllineage",
  "homepage": "https://github.com/reata/sqllineage",
  "release_count": 37,
  "dependency_ids": [
    "pypi_bandit",
    "pypi_black",
    "pypi_flake8",
    "pypi_flake8_blind_except",
    "pypi_flake8_builtins",
    "pypi_flake8_import_order",
    "pypi_flake8_logging_format",
    "pypi_mypy",
    "pypi_networkx",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme",
    "pypi_sqlfluff",
    "pypi_sqlparse",
    "pypi_tox",
    "pypi_twine",
    "pypi_wheel"
  ]
}