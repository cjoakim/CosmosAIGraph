{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "[<img align=\"right\" src=\"https://cdn.buymeacoffee.com/buttons/default-orange.png\" width=\"217px\" height=\"51x\">](https://www.buymeacoffee.com/rsalmei)\n[<img align=\"right\" alt=\"donate with paypal button\" src=\"https://www.paypalobjects.com/en_us/i/btn/btn_donate_lg.gif\">](https://www.paypal.com/donate?business=6swsheb5zns5n&no_recurring=0&item_name=i%27m+the+author+of+alive-progress%2c+clearly+and+about-time.+thank+you+for+appreciating+my+work%21&currency_code=usd)\n\n# about-time\n### a cool helper for tracking time and throughput of code blocks, with beautiful human friendly renditions.\n\n[![coverage](https://img.shields.io/badge/coverage-100%25-green.svg)]()\n[![maintenance](https://img.shields.io/badge/maintained%3f-yes-green.svg)](https://github.com/rsalmei/about-time/graphs/commit-activity)\n[![pypi version](https://img.shields.io/pypi/v/about-time.svg)](https://pypi.python.org/pypi/about-time/)\n[![pypi pyversions](https://img.shields.io/pypi/pyversions/about-time.svg)](https://pypi.python.org/pypi/about-time/)\n[![pypi status](https://img.shields.io/pypi/status/about-time.svg)](https://pypi.python.org/pypi/about-time/)\n[![pypi downloads](https://pepy.tech/badge/about-time)](https://pepy.tech/project/about-time)\n\n## what does it do?\n\ndid you ever need to measure the duration of an operation? yeah, this is easy.\n\nbut how to:\n- measure the duration of two or more blocks at the same time, including the whole duration?\n- instrument a code to cleanly retrieve durations in one line, to log or send to time series databases?\n- easily see human friendly durations in *s* (seconds), *ms* (milliseconds), *\u00b5s* (microseconds) and even *ns* (nanoseconds)?\n- easily see human friendly counts with si prefixes like *k*, *m*, *g*, *t*, etc?\n- measure the actual throughput of a block? (this is way harder, since it needs to measure both duration and number of iterations)\n- easily see human friendly throughputs in \"/second\", \"/minute\", \"/hour\" or even \"/day\", including si prefixes?\n\nyes, it can get tricky! more interesting details about [duration](https://github.com/rsalmei/about-time#the-human-duration-magic) and [throughput](https://github.com/rsalmei/about-time#the-human-throughput-magic).\n<br>if you'd tried to do it without these magic, it would probably get messy and immensely pollute the code being instrumented.\n\ni have the solution, behold!\n\n```python\nfrom about_time import about_time\n\n\ndef some_func():\n    import time\n    time.sleep(85e-3)\n    return true\n\n\ndef main():\n    with about_time() as t1:  # <-- use it like a context manager!\n\n        t2 = about_time(some_func)  # <-- use it with any callable!!\n\n        t3 = about_time(x * 2 for x in range(56789))  # <-- use it with any iterable or generator!!!\n        data = [x for x in t3]  # then just iterate!\n\n    print(f'total: {t1.duration_human}')\n    print(f'  some_func: {t2.duration_human} -> result: {t2.result}')\n    print(f'  generator: {t3.duration_human} -> {t3.count_human} elements, throughput: {t3.throughput_human}')\n```\n\nthis `main()` function prints:\n```\ntotal: 95.6ms\n  some_func: 89.7ms -> result: true\n  generator: 5.79ms -> 56.8k elements, throughput: 9.81m/s\n```\n\nhow cool is that? \ud83d\ude32\ud83d\udc4f\n\nyou can also get the duration in seconds if needed:\n```\nin [7]: t1.duration\nout[7]: 0.09556673200064251\n```\nbut `95.6ms` is way better, isn't it? the same with `count` and `throughput`!\n\nso, `about_time` measures code blocks, both time and throughput, and converts them to beautiful human friendly representations! \ud83d\udc4f\n\n\n## get it\n\njust install with pip:\n\n```bash\n\u276f pip install about-time\n```\n\n\n## use it\n\nthere are three modes of operation: context manager, callable and throughput. let's dive in.\n\n\n### 1. use it like a context manager:\n\n```python\nfrom about_time import about_time\n\nwith about_time() as t:\n    # the code to be measured...\n    # any lenghty block.\n\nprint(f'the whole block took: {t.duration_human}')\n```\n\nthis way you can nicely wrap any amount of code.\n\n> in this mode, there are the basic fields `duration` and `duration_human`.\n\n\n### 2. use it with any callable:\n\n```python\nfrom about_time import about_time\n\nt = about_time(some_func)\n\nprint(f'the whole block took: {t.duration_human}')\nprint(f'and the result was: {t.result}')\n\n```\n\nthis way you have a nice one liner, and do not need to increase the indent of your code.\n\n> in this mode, there is an additional field `result`, with the return of the callable.\n\nif the callable have params, you can use a `lambda` or (\ud83d\udccc new) simply send them:\n\n```python\ndef add(n, m):\n    return n + m\n\nt = about_time(add, 1, 41)\n# or:\nt = about_time(add, n=1, m=41)\n# or even:\nt = about_time(lambda: add(1, 41))\n\n```\n\n\n### 3. use it with any iterable or generator:\n\n```python\nfrom about_time import about_time\n\nt = about_time(iterable)\nfor item in t:\n    # process item.\n\nprint(f'the whole block took: {t.duration_human}')\nprint(f'it was detected {t.count_human} elements')\nprint(f'the throughput was: {t.throughput_human}')\n```\n\nthis way `about_time` also extracts the number of iterations, and with the measured duration it calculates the throughput of the whole loop! it's especially useful with generators, which do not have length.\n\n> in this mode, there are the additional fields `count`, `count_human`, `throughput` and `throughput_human`.\n\ncool tricks under the hood:\n- you can use it even with generator expressions, anything that is iterable to python!\n- you can consume it not only in a `for` loop, but also in { list | dict | set } comprehensions, `map()`s, `filter()`s, `sum()`s, `max()`s, `list()`s, etc, thus any function that expects an iterator! \ud83d\udc4f\n- the timer only starts when the first element is queried, so you can initialize whatever you need before entering the loop! \ud83d\udc4f\n- the `count`/`count_human` and `throughput`/`throughput_human` fields are updated in **real time**, so you can use them even inside the loop!\n\n\n## features:\n\naccording to the si standard, there are 1000 bytes in a `kilobyte`.\n<br>there is another standard called iec that has 1024 bytes in a `kibibyte`, but this is only useful when measuring things that are naturally a power of two, e.g. a stick of ram.\n\nbe careful to not render iec quantities with si scaling, which would be incorrect. but i still support it, if you really want to ;)\n\nby default, this will use si, `1000` divisor, and `no space` between values and scales/units. si uses prefixes: `k`, `m`, `g`, `t`, `p`, `e`, `z`, and `y`.\n\nthese are the optional features:\n- `iec` => use iec instead of si: `ki`, `mi`, `gi`, `ti`, `pi`, `ei`, `zi`, `yi` (implies `1024`);\n- `1024` => use `1024` divisor \u2014 if `iec` is not enabled, use prefixes: `k`, `m`, `g`, `t`, `p`, `e`, `z`, and `y` (note the upper 'k');\n- `space` => include a space between values and scales/units everywhere: `48 b` instead of `48b`, `15.6 \u00b5s` instead of `15.6\u00b5s`, and `12.4 kb/s` instead of `12.4kb/s`.\n\nto change them, just use the properties:\n\n```python\nfrom about_time import features\n\nfeatures.feature_1024\nfeatures.feature_iec\nfeatures.feature_space\n```\n\nfor example, to enable spaces between scales/units:\n```python\nfrom about_time import features\nfeatures.feature_space = true\n```\n\n## the human duration magic\n\ni've used just one key concept in designing the human duration features: cleanliness.\n> `3.44s` is more meaningful than `3.43584783784s`, and `14.1us` is much nicer than `.0000141233333s`.\n\nso what i do is: round values to at most two decimal places (three significant digits), and find the best scale unit to represent them, minimizing resulting values smaller than `1`. the search for the best unit considers even the rounding been applied!\n> `0.000999999` does not end up as `999.99us` (truncate) nor `1000.0us` (bad unit), but is auto-upgraded to the next unit `1.0ms`!\n\nthe `duration_human` units change seamlessly from nanoseconds to hours.\n  - values smaller than 60 seconds are always rendered as \"num.d[d]unit\", with one or two decimals;\n  - from 1 minute onward it changes to \"h:mm:ss\".\n\nit feels much more humane, humm? ;)\n\nsome examples:\n\n| duration (float seconds) | duration_human |\n|:------------------------:|:--------------:|\n|       .00000000185       |    '1.85ns'    |\n|      .000000999996       |    '1.00\u00b5s'    |\n|          .00001          |    '10.0\u00b5s'    |\n|         .0000156         |    '15.6\u00b5s'    |\n|           .01            |    '10.0ms'    |\n|      .0141233333333      |    '14.1ms'    |\n|         .1099999         |    '110ms'     |\n|         .1599999         |    '160ms'     |\n|          .8015           |    '802ms'     |\n|         3.434999         |    '3.43s'     |\n|          59.999          |   '0:01:00'    |\n|           68.5           |   '0:01:08'    |\n|         125.825          |   '0:02:05'    |\n|         4488.395         |   '1:14:48'    |\n\n\n## the human throughput magic\n\ni've made the `throughput_human` with a similar logic. it is funny how much trickier \"throughput\" is to the human brain!\n> if something took `1165263 seconds` to handle `123 items`, how fast did it go? it's not obvious...\n\nit doesn't help even if we divide the duration by the number of items, `9473 seconds/item`, which still does not mean much. how fast was that? we can't say.\n<br>how many items did we do per time unit?\n> oh, we just need to invert it, so `0,000105555569858 items/second`, there it is! \ud83d\ude02\n\nto make some sense of it we need to multiply that by 3600 (seconds in an hour) to get `0.38/h`, which is much better, and again by 24 (hours in a day) to finally get `9.12/d`!! now we know how fast that process was! \\o/ as you see, it's not easy at all.\n\nthe `throughput_human` unit changes seamlessly from per-second, per-minute, per-hour, and per-day.\n<br>it also automatically inserts si-prefixes, like k, m, and g. \ud83d\udc4d\n\n| duration (float seconds) | number of elements | throughput_human |\n|:------------------------:|:------------------:|:----------------:|\n|           1\\.            |         10         |     '10.0/s'     |\n|           1\\.            |        2500        |    '2.50k/s'     |\n|           1\\.            |      1825000       |    '1.82m/s'     |\n|           2\\.            |         1          |     '30.0/m'     |\n|           2\\.            |         10         |     '5.00/s'     |\n|    1.981981981981982     |         11         |     '5.55/s'     |\n|          100\\.           |         10         |     '6.00/m'     |\n|          1600\\.          |         3          |     '6.75/h'     |\n|           .99            |         1          |     '1.01/s'     |\n|        1165263\\.         |        123         |     '9.12/d'     |\n\n\n## accuracy\n\n`about_time` supports all versions of python, but in pythons >= `3.3` it performs even better, with much higher resolution and smaller propagation of errors, thanks to the new `time.perf_counter`. in older versions, it uses `time.time` as usual.\n\n\n## changelog highlights:\n- 4.2.1: makes fixed precision actually gain more resolution, when going from a default 1 to 2 decimals\n- 4.2.0: support for fixed precision, useful when one needs output without varying lengths; official python 3.11 support\n- 4.1.0: enable to cache features within closures, to improve performance for https://github.com/rsalmei/alive-progress\n- 4.0.0: new version, modeled after my rust implementation in https://crates.io/crates/human-repr; includes new global features, new objects for each operation, and especially, new simpler human friendly representations; supports python 3.7+\n- 3.3.0: new interfaces for count_human and throughput_human; support more common kbyte for base 2 (1024), leaving iec one as an alternate\n- 3.2.2: support iec kibibyte standard for base 2 (1024)\n- 3.2.1: support divisor in throughput_human\n- 3.2.0: both durations and throughputs now use 3 significant digits; throughputs now include si-prefixes\n- 3.1.1: make `duration_human()` and `throughput_human()` available for external use\n- 3.1.0: include support for parameters in callable mode; official support for python 3.8, 3.9 and 3.10\n- 3.0.0: greatly improved the counter/throughput mode, with a single argument and working in real time\n- 2.0.0: feature complete, addition of callable and throughput modes\n- 1.0.0: first public release, context manager mode\n\n\n## license\nthis software is licensed under the mit license. see the license file in the top distribution directory for the full license text.\n\n\n---\nmaintaining an open source project is hard and time-consuming, and i've put much \u2764\ufe0f and effort into this.\n\nif you've appreciated my work, you can back me up with a donation! thank you \ud83d\ude0a\n\n[<img align=\"right\" src=\"https://cdn.buymeacoffee.com/buttons/default-orange.png\" width=\"217px\" height=\"51x\">](https://www.buymeacoffee.com/rsalmei)\n[<img align=\"right\" alt=\"donate with paypal button\" src=\"https://www.paypalobjects.com/en_us/i/btn/btn_donate_lg.gif\">](https://www.paypal.com/donate?business=6swsheb5zns5n&no_recurring=0&item_name=i%27m+the+author+of+alive-progress%2c+clearly+and+about-time.+thank+you+for+appreciating+my+work%21&currency_code=usd)\n\n---\n\n\n",
  "docs_url": null,
  "keywords": "python,track,tracker,time,code,blocks,monitor,statistics,analytics",
  "license": "mit",
  "name": "about-time",
  "package_url": "https://pypi.org/project/about-time/",
  "project_url": "https://pypi.org/project/about-time/",
  "project_urls": {
    "Homepage": "https://github.com/rsalmei/about-time"
  },
  "release_url": "https://pypi.org/project/about-time/4.2.1/",
  "requires_dist": [],
  "requires_python": ">=3.7, <4",
  "summary": "easily measure timing and throughput of code blocks, with beautiful human friendly representations.",
  "version": "4.2.1",
  "releases": [],
  "developers": [
    "rsalmei@gmail.com"
  ],
  "kwds": "btn_donate_lg donation tracker tracking currency_code",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_about_time",
  "homepage": "https://github.com/rsalmei/about-time",
  "release_count": 18,
  "dependency_ids": []
}