{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "programming language :: python :: 3",
    "programming language :: python :: 3.7"
  ],
  "description": "# multichannel time series lossless compression in python\n\n[![build status](https://travis-ci.org/int-brain-lab/mtscomp.svg?branch=master)](https://travis-ci.org/int-brain-lab/mtscomp)\n[![coverage status](https://codecov.io/gh/int-brain-lab/mtscomp/branch/master/graph/badge.svg)](https://codecov.io/gh/int-brain-lab/mtscomp)\n\nthis library implements a simple lossless compression scheme adapted to time-dependent high-frequency, high-dimensional signals. it is being developed within the [international brain laboratory](https://www.internationalbrainlab.com/) with the aim of being the compression library used for all large-scale electrophysiological recordings based on neuropixels. the signals are typically recorded at 30 khz and 10 bit depth, and contain several hundreds of channels.\n\n\n## compression scheme\n\nthe requested features for the compression scheme were as follows:\n\n* lossless compression only (one should retrieve byte-to-byte exact decompressed data).\n* written in pure python (no c extensions) with minimal dependencies so as to simplify distribution.\n* scalable to large sample rates, large number of channels, long recording time.\n* faster than real time (i.e. it should take less time to compress than to record).\n* multithreaded so as to leverage multiple cpu cores.\n* on-the-fly decompression and random read accesses.\n* as simple as possible.\n\nthe compression scheme is the following:\n\n* the data is split into chunks along the time axis.\n* the time differences are computed for all channels.\n* these time differences are compressed with zlib.\n* the compressed chunks (and initial values of each chunk) are appended in a binary file.\n* metadata about the compression, including the chunk offsets within the compressed binary file, are saved in a secondary json file.\n\nsaving the offsets allows for on-the-fly decompression and random data access: one simply has to determine which chunks should be loaded, and load them directly from the compressed binary file. the compressed chunks are decompressed with zlib, and the original data is recovered with a cumulative sum (the inverse of the time difference operation).\n\nwith large-scale neurophysiological recordings, we achieved a compression ratio of 3x.\n\nas a consistency check, the compressed file is by default automatically and transparently decompressed and compared to the original file on a byte-per-byte basis.\n\n\n## dependencies\n\n* python 3.7+\n* numpy\n* tqdm [for the progress bar]\n\nfor development only:\n\n* flake8\n* pytest\n* pytest-cov\n* coverage\n\n\n## installation\n\n```\npip install mtscomp\n```\n\n\n## command-line interface\n\nexample:\n\n```bash\n# compression: specify the number of channels, sample rate, dtype, optionally save the parameters\n# as default in ~/.mtscomp with --set-default\nmtscomp data.bin -n 385 -s 30000 -d int16 [--set-default]\n# decompression\nmtsdecomp data.cbin -o data.decomp.bin\n```\n\nusage:\n\n```\nusage: mtscomp [-h] [-d dtype] [-s sample_rate] [-n n_channels] [-p cpus]\n               [-c chunk] [-nc] [-v] [--set-default]\n               path [out] [outmeta]\n\ncompress a raw binary file.\n\npositional arguments:\n  path                  input path of a raw binary file\n  out                   output path of the compressed binary file (.cbin)\n  outmeta               output path of the compression metadata json file\n                        (.ch)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -d dtype, --dtype dtype\n                        data type\n  -s sample_rate, --sample-rate sample_rate\n                        sample rate\n  -n n_channels, --n-channels n_channels\n                        number of channels\n  -p cpus, --cpus cpus  number of cpus to use\n  -c chunk, --chunk chunk\n                        chunk duration\n  -nc, --no-check       no check\n  -v, --debug           verbose\n  --set-default         set the specified parameters as the default\n\n\n\nusage: mtsdecomp [-h] [-o [out]] [--overwrite] [-nc] [-v] cdata [cmeta]\n\ndecompress a raw binary file.\n\npositional arguments:\n  cdata                 path to the input compressed binary file (.cbin)\n  cmeta                 path to the input compression metadata json file (.ch)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o [out], --out [out]\n                        path to the output decompressed file (.bin)\n  --overwrite, -f       overwrite existing output\n  -nc, --no-check       no check\n  -v, --debug           verbose\n```\n\n\n## high-level api\n\nexample:\n\n```python\nimport numpy as np\nfrom mtscomp.mtscomp import compress, decompress\n\n# compress a .bin file into a pair .cbin (compressed binary file) and .ch (json file).\ncompress('data.bin', 'data.cbin', 'data.ch', sample_rate=20000., n_channels=256, dtype=np.int16)\n# decompress a pair (.cbin, .ch) and return an object that can be sliced like a numpy array.\narr = decompress('data.cbin', 'data.ch')\nx = arr[start:end, :]  # decompress the data on the fly directly from the file on disk\narr.close()  # close the file when done\n```\n\n\n## low-level api\n\nexample:\n\n```python\nimport numpy as np\nfrom mtscomp import writer, reader\n\n# define a writer to compress a flat raw binary file.\nw = writer(chunk_duration=1.)\n# open the file to compress.\nw.open('data.bin', sample_rate=20000., n_channels=256, dtype=np.int16)\n# compress it into a compressed binary file, and a json header file.\nw.write('data.cbin', 'data.ch')\nw.close()\n\n# define a reader to decompress a compressed array.\nr = reader()\n# open the compressed dataset.\nr.open('data.cbin', 'data.ch')\n# the reader can be sliced as a numpy array: decompression happens on the fly. only chunks\n# that need to be loaded are loaded and decompressed.\n# here, we load everything in memory.\narray = r[:]\n# or we can decompress into a new raw binary file on disk.\nr.tofile('data_dec.bin')\nr.close()\n```\n\n\n## implementation details\n\n* **multithreading**: since python's zlib releases the gil, the library uses multiple threads when compressing a file. the chunks are grouped in batches containing as many chunks as threads. after each batch, the chunks are written in the binary file in the right order (since the threads of the batch have no reason to finish in order).\n\n\n## performance\n\nperformance on an neuropixels dataset (30 khz, 385 channels) and intel 10-core i9-9820x cpu @ 3.3ghz:\n\n* compression ratio: -63% (compressed files are nearly 3x smaller)\n* compression time (20 threads): 88 mb/s, **4x faster than real time**\n* decompression time (single-threaded at the moment): 22 mb/s, **3x faster than real time**\n\n\n",
  "docs_url": null,
  "keywords": "lossless,compresssion,electrophysiology,neuroscience",
  "license": "bsd",
  "name": "mtscomp",
  "package_url": "https://pypi.org/project/mtscomp/",
  "project_url": "https://pypi.org/project/mtscomp/",
  "project_urls": {
    "Homepage": "https://github.com/int-brain-lab/mtscomp"
  },
  "release_url": "https://pypi.org/project/mtscomp/1.0.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "lossless compression for electrophysiology time-series",
  "version": "1.0.2",
  "releases": [],
  "developers": [
    "cyrille.rossant@gmail.com",
    "cyrille_rossant"
  ],
  "kwds": "compression electrophysiological electrophysiology compressed neurophysiological",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_mtscomp",
  "homepage": "https://github.com/int-brain-lab/mtscomp",
  "release_count": 5,
  "dependency_ids": []
}