{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# pygltflib\n\nthis is a library for reading, writing and handling gltf files. it works for python3.6 and above.\n\nit supports the entire specification, including materials and animations. main features are:\n* glb and gltf support\n* buffer data conversion\n* extensions\n* all attributes are type-hinted\n\n# table of contents\n\n* [quickstart](#quickstart)\n  * [install](#install)\n  * [how do i...](#how-do-i)\n    * [create an empty gltf2 object?](#create-an-empty-gltf2-object)\n    * [add a scene?](#add-a-scene)\n    * [load a file?](#load-a-file)\n    * [load a binary glb file?](#load-a-binary-glb-file)\n    * [load a binary file with an unusual extension?](#load-a-binary-file-with-an-unusual-extension)\n    * [access the first node (the objects comprising the scene) of a scene?](#access-the-first-node-the-objects-comprising-the-scene-of-a-scene)\n    * [create a mesh?](#create-a-mesh)\n    * [convert buffers to glb binary buffers?](#convert-buffers-to-glb-binary-buffers)\n    * [convert buffer to data uri (embedded) buffer?](#convert-buffer-to-data-uri-embedded-buffer)\n    * [convert buffers to binary file (external) buffers?](#convert-buffers-to-binary-file-external-buffers)\n    * [convert a glb to a gltf file?](#convert-a-glb-to-a-gltf-file)\n    * [access an extension?](#access-an-extension)\n    * [add a custom attribute to attributes?](#add-a-custom-attribute-to-attributes)\n    * [remove a bufferview?](#remove-a-bufferview)\n    * [validate a gltf object?](#validate-a-gltf-object)\n    * [convert texture images inside a gltf file to their own png files?](#convert-texture-images-inside-a-gltf-file-to-their-own-png-files)\n    * [convert texture images from a gltf file to their own png files using custom file names?](#convert-texture-images-from-a-gltf-file-to-their-own-png-files-using-custom-file-names)\n    * [specify a path to my images when converting to files?](#specify-a-path-to-my-images-when-converting-to-files)\n    * [export images from the gltf file to any location (ie outside the gltf file)?](#export-images-from-the-gltf-file-to-any-location-ie-outside-the-gltf-file)\n    * [import png files as textures into a gltf?](#import-png-files-as-textures-into-a-gltf)\n* [about](#about)\n  * [contributors](#contributors)\n  * [thanks](#thanks)\n  * [changelog](#changelog)\n  * [installing](#installing)\n  * [source](#source)\n* [more detailed usage](#more-detailed-usage)\n  * [a simple mesh](#a-simple-mesh)\n  * [reading vertex data from a primitive and/or getting bounding sphere](#reading-vertex-data-from-a-primitive-andor-getting-bounding-sphere)\n  * [create a mesh, convert to bytes, convert back to mesh](#create-a-mesh-convert-to-bytes-convert-back-to-mesh)\n  * [loading and saving](#loading-and-saving)\n  * [converting files](#converting-files)\n  * [converting buffers](#converting-buffers)\n  * [converting texture images](#converting-texture-images)\n* [extensions](#extensions)\n  * [ext_structural_metadata](#ext_structural_metadata)\n* [running the tests](#running-the-tests)\n\n## quickstart\n\n### install\n\n```\npip install pygltflib\n```\n\n\n### how do i...\n\n\n#### create an empty gltf2 object?\n\n```python\nfrom pygltflib import gltf2\n\ngltf = gltf2()\n```\n\n#### add a scene?\n\n```python\nfrom pygltflib import gltf2, scene\n\ngltf = gltf2()\nscene = scene()\ngltf.scenes.append(scene)  # scene available at gltf.scenes[0]\n```\n\n#### load a file?\n\n```python\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\n```\n\n#### load a binary glb file?\n\n```python\nglb_filename = \"gltf-sample-models/2.0/box/gltf-binary/box.glb\"\nglb = gltf2().load(glb_filename)  # load method auto detects based on extension\n```\n\n#### load a binary file with an unusual extension?\n\n```python\nglb = gltf2().load_binary(\"binarygltf.glk\")   # load_json and load_binary helper methods\n```\n\n\n#### access the first node (the objects comprising the scene) of a scene?\n\n```python\ngltf = gltf2().load(\"gltf-sample-models/2.0/box/gltf/box.gltf\")\ncurrent_scene = gltf.scenes[gltf.scene]\nnode_index = current_scene.nodes[0]  # scene.nodes is the indices, not the objects \nbox = gltf.nodes[node_index]\nbox.matrix  # will output vertices for the box object\n```\n\n\n#### create a mesh?\nconsult the longer examples in the second half of this document\n  * [a simple mesh](#a-simple-mesh)\n  * [reading vertex data from a primitive and/or getting bounding sphere](#reading-vertex-data-from-a-primitive-andor-getting-bounding-sphere)\n  * [create a mesh, convert to bytes, convert back to mesh](#create-a-mesh-convert-to-bytes-convert-back-to-mesh)\n\n\n#### convert buffers to glb binary buffers?\n\n```python\nfrom pygltflib import gltf2, bufferformat\n\ngltf = gltf2().load(\"gltf-sample-models/2.0/box/gltf/box.gltf\")\ngltf.convert_buffers(bufferformat.binaryblob)   # convert buffers to glb blob\n```\n\n#### convert buffer to data uri (embedded) buffer?\n```python\ngltf.convert_buffers(bufferformat.datauri)  # convert buffer uris to data.\n```\n\n#### convert buffers to binary file (external) buffers?\n```python\ngltf.convert_buffers(bufferformat.binfile)   # convert buffers to files\ngltf.save(\"test.gltf\")  # all the buffers are saved in 0.bin, 1.bin, 2.bin.\n```\n\n\n#### convert a glb to a gltf file?\n```python\nfrom pygltflib.utils import glb2gltf, gltf2glb\n\n# convert glb to gltf\nglb2gltf(\"gltf-sample-models/2.0/box/gltf-binary/box.glb\")\n```\n\n#### access an extension?\n```python\n# on a primitve\ngltf.meshes[0].primitives[0].extensions['khr_draco_mesh_compression']\n\n# on a material\ngltf.materials[0].extensions['adobe_materials_thin_transparency']\n\n```\n\n#### add a custom attribute to attributes?\n```python\n# application-specific semantics must start with an underscore, e.g., _temperature.\na = attributes()\na._mycustomattribute = 123\n\ngltf.meshes[0].primitives[0].attributes._myotherattribute = 456\n```\n\n#### remove a bufferview?\n```python\ngltf.remove_bufferview(0)  # this will update all accessors, images and sparse accessors to remove the first bufferview\n```\n\n#### validate a gltf object?\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.validator import validate, summary\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\nvalidate(gltf)  # will throw an error depending on the problem\nsummary(gltf)  # will pretty print human readable summary of errors\n# note: currently this experimental validator only validates a few rules about gltf2 objects\n```\n\n#### convert texture images inside a gltf file to their own png files?\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import imageformat\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\ngltf.convert_images(imageformat.file)\ngltf.images[0].uri  # will now be 0.png and the texture image will be saved in 0.png\n```\n\n#### convert texture images from a gltf file to their own png files using custom file names?\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import imageformat\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\ngltf.images[0].name = \"cube.png\"  # will save the data uri to this file (regardless of data format)\ngltf.convert_images(imageformat.file)\ngltf.images[0].uri  # will now be cube.png and the texture image will be saved in cube.png\n```\n\n#### specify a path to my images when converting to files?\nby default pygltflib will load images from the same location as the gltf file.\n\nit will also try and save image files to the that location when converting image buffers or data uris.\n\nyou can override the load/save location using the 'path' argument to `convert_images`\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import imageformat\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\ngltf.images[0].name = \"cube.png\"  # will save the data uri to this file (regardless of data format)\ngltf.convert_images(imageformat.file, path='/destination/') \ngltf.images[0].uri  # will now be cube.png and the texture image will be saved in /destination/cube.png\n```\n\n\n#### export images from the gltf file to any location (ie outside the gltf file)?\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import imageformat\nfilename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\ngltf = gltf2().load(filename)\ngltf.export_image(0, \"output/cube.png\", override=true)  # there is now an image file at output/cube.png\n```\n\n\n#### import png files as textures into a gltf?\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import imageformat, image\ngltf = gltf2()\nimage = image()\nimage.uri = \"myfile.png\"\ngltf.images.append(image)\ngltf.convert_images(imageformat.datauri)\ngltf.images[0].uri  # will now be something like \"data:image/png;base64,ivborw0kgg...\"\ngltf.images[0].name  # will be myfile.png\n```\n\n\n### more detailed usage below\n\n## about\nthis is an unofficial library that tracks the [official file format](https://github.com/khronosgroup/gltf/blob/master/specification/2.0/readme.md) for gltf2. \n\nthe library was initially built to load and save simple meshes but support for the entire spec, including materials \nand animations is pretty good. supports both json (.gltf) and binary (.glb) file formats, although .glb support \nis missing some features at the moment. \n\nit requires python 3.6 and above because it uses dataclasses and all attributes are type hinted. and f-strings, plenty of f-strings.\n\ncheck the table below for an idea of which sample models validate.\n\nquestions? contributions? bug reports? open an issue on the [gitlab page for the project](https://gitlab.com/dodgyville/pygltflib).\nwe are very interested in hearing your use cases for `pygltflib` to help drive the roadmap.\n\n### contributors\n* luke miller\n* sebastian h\u00f6ffner\n* arthur van hoff\n* arifullah jan\n* daniel haehn\n* jon time\n* laurie o\n* peter suter\n* fr\u00e9d\u00e9ric devernay\n* julian stirling\n* johannes deml\n* margarida silva \n* patiphan wongklaew\n* alexander druz\n* adriano martins\n* dzmitry stabrouski\n* irtimir\n* florian bruggisser\n* kevin kreiser\n* neui\n* bernhard rainer\n* philip holzmann\n* gabriel unm\u00fc\u00dfig\n* benjamin renz\n\n\n#### thanks\n`pygltflib` made for 'the beat: a glam noir game' supported by film victoria / vicscreen. \n\n### changelog\n* 1.16.1:\n  * remove buffer data when converting images (gabriel unm\u00fc\u00dfig)\n  * make validator accept animation channel sampler = 0  (benjamin renz)\n\n* 1.16.0:\n  * fix compile error by removing dead extension code\n  * fix type hint in gltf2.from_json() (philip holzmann)\n  * add support for larger alignment for bin-chunk (for ext_structural_metadata) (philip holzmann)\n\n\n* 1.15.6:\n  * fix buffer.uri and .bin file name mismatch when a glb is loaded from a path that contains additional period characters (bernhard rainer)  \n\n* 1.15.4:\n  * fix buffer alignment by adding padding bytes in glb export (neui)\n\n* 1.15.3:\n  * use sort_keys by default for deterministic output (kevin kreise)\n\n* 1.15.2:\n  * buffer.uri defaults to none (kevin kreise)\n\n* 1.15.1:\n  * dataclasses install only required on python 3.6.x (cherry-pick from saeid akbari branch)\n  * removed deprecated `alphamode` after two years (use the `pygltflib.blend`, `pygltflib.mask`, `pygltflib.opaque` constants directly)\n  * removed deprecated `sparseaccessor` after two years (use `accessorsparseindices` and `accessorsparsevalues` instead)\n  * removed deprecated `materialtexture` after two years (use `textureinfo` instead)\n  * removed `deprecated` requirement from project\n\n* 1.15.0: \n  * significantly improved `save_to_bytes` performance (20x faster) (florian bruggisser)\n    * note: underlying binary blob is now mutable instead of immutable. \n\nsee [changelog.md] (https://gitlab.com/dodgyville/pygltflib/-/blob/master/changelog.md) for older versions\n\n## installing\n```\npip install pygltflib\n```\nor\n```\npy -m pip install pygltflib\n```\n\n\n## source\n\n```\ngit clone https://gitlab.com/dodgyville/pygltflib\n```\n\n\n## more detailed usage\nnote: these examples use the official [sample models](https://github.com/khronosgroup/gltf-sample-models) provided by khronos at:\n\nhttps://github.com/khronosgroup/gltf-sample-models\n\n### a simple mesh\n```python\nfrom pygltflib import *\n\n# create gltf objects for a scene with a primitive triangle with indexed geometry\ngltf = gltf2()\nscene = scene()\nmesh = mesh()\nprimitive = primitive()\nnode = node()\nbuffer = buffer()\nbufferview1 = bufferview()\nbufferview2 = bufferview()\naccessor1 = accessor()\naccessor2 = accessor()\n\n# add data\nbuffer.uri = \"data:application/octet-stream;base64,aaabaaiaaaaaaaaaaaaaaaaaaaaaaia/aaaaaaaaaaaaaaaaaacapwaaaaa=\"\nbuffer.bytelength = 44\n\nbufferview1.buffer = 0\nbufferview1.byteoffset = 0\nbufferview1.bytelength = 6\nbufferview1.target = element_array_buffer\n\nbufferview2.buffer = 0\nbufferview2.byteoffset = 8\nbufferview2.bytelength = 36\nbufferview2.target = array_buffer\n\naccessor1.bufferview = 0\naccessor1.byteoffset = 0\naccessor1.componenttype = unsigned_short\naccessor1.count = 3\naccessor1.type = scalar\naccessor1.max = [2]\naccessor1.min = [0]\n\naccessor2.bufferview = 1\naccessor2.byteoffset = 0\naccessor2.componenttype = float\naccessor2.count = 3\naccessor2.type = vec3\naccessor2.max = [1.0, 1.0, 0.0]\naccessor2.min = [0.0, 0.0, 0.0]\n\nprimitive.attributes.position = 1\nnode.mesh = 0\nscene.nodes = [0]\n\n# assemble into a gltf structure\ngltf.scenes.append(scene)\ngltf.meshes.append(mesh)\ngltf.meshes[0].primitives.append(primitive)\ngltf.nodes.append(node)\ngltf.buffers.append(buffer)\ngltf.bufferviews.append(bufferview1)\ngltf.bufferviews.append(bufferview2)\ngltf.accessors.append(accessor1)\ngltf.accessors.append(accessor2)\n\n# save to file\ngltf.save(\"triangle.gltf\")\n```\n\n\n### reading vertex data from a primitive and/or getting bounding sphere\n```python\nimport pathlib\nimport struct\n\nimport miniball\nimport numpy\nfrom pygltflib import gltf2\n\n# load an example gltf file from the khronos collection\nfname = pathlib.path(\"gltf-sample-models/2.0/box/gltf-embedded/box.gltf\")\ngltf = gltf2().load(fname)\n\n# get the first mesh in the current scene (in this example there is only one scene and one mesh)\nmesh = gltf.meshes[gltf.scenes[gltf.scene].nodes[0]]\n\n# get the vertices for each primitive in the mesh (in this example there is only one)\nfor primitive in mesh.primitives:\n\n    # get the binary data for this mesh primitive from the buffer\n    accessor = gltf.accessors[primitive.attributes.position]\n    bufferview = gltf.bufferviews[accessor.bufferview]\n    buffer = gltf.buffers[bufferview.buffer]\n    data = gltf.get_data_from_buffer_uri(buffer.uri)\n\n    # pull each vertex from the binary buffer and convert it into a tuple of python floats\n    vertices = []\n    for i in range(accessor.count):\n        index = bufferview.byteoffset + accessor.byteoffset + i*12  # the location in the buffer of this vertex\n        d = data[index:index+12]  # the vertex data\n        v = struct.unpack(\"<fff\", d)   # convert from base64 to three floats\n        vertices.append(v)\n        print(i, v)\n\n# convert a numpy array for some manipulation\ns = numpy.array(vertices)\n\n# use a third party library to perform ritter's algorithm for finding smallest bounding sphere\nc, radius_squared = miniball.get_bounding_ball(s)\n\n# output the results\nprint(f\"center of bounding sphere: {c}\\nradius squared of bounding sphere: {radius_squared}\")\n```\n\n\n### create a mesh, convert to bytes, convert back to mesh\nthe geometry is derived from [gltf 2.0 box sample](https://github.com/khronosgroup/gltf-sample-models/tree/master/2.0/box), but point normals were removed and points were reused where it was possible in order to reduce the size of the example. be aware that some parts are hard-coded (types and shapes for en- and decoding of arrays, no bytes padding).\n```python\nimport numpy as np\nimport pygltflib\n```\ndefine mesh using `numpy`:\n```python\npoints = np.array(\n    [\n        [-0.5, -0.5, 0.5],\n        [0.5, -0.5, 0.5],\n        [-0.5, 0.5, 0.5],\n        [0.5, 0.5, 0.5],\n        [0.5, -0.5, -0.5],\n        [-0.5, -0.5, -0.5],\n        [0.5, 0.5, -0.5],\n        [-0.5, 0.5, -0.5],\n    ],\n    dtype=\"float32\",\n)\ntriangles = np.array(\n    [\n        [0, 1, 2],\n        [3, 2, 1],\n        [1, 0, 4],\n        [5, 4, 0],\n        [3, 1, 6],\n        [4, 6, 1],\n        [2, 3, 7],\n        [6, 7, 3],\n        [0, 2, 5],\n        [7, 5, 2],\n        [5, 7, 4],\n        [6, 4, 7],\n    ],\n    dtype=\"uint8\",\n)\n```\ncreate glb-style `gltf2` with single scene, single node and single mesh from arrays of points and triangles:\n```python\ntriangles_binary_blob = triangles.flatten().tobytes()\npoints_binary_blob = points.tobytes()\ngltf = pygltflib.gltf2(\n    scene=0,\n    scenes=[pygltflib.scene(nodes=[0])],\n    nodes=[pygltflib.node(mesh=0)],\n    meshes=[\n        pygltflib.mesh(\n            primitives=[\n                pygltflib.primitive(\n                    attributes=pygltflib.attributes(position=1), indices=0\n                )\n            ]\n        )\n    ],\n    accessors=[\n        pygltflib.accessor(\n            bufferview=0,\n            componenttype=pygltflib.unsigned_byte,\n            count=triangles.size,\n            type=pygltflib.scalar,\n            max=[int(triangles.max())],\n            min=[int(triangles.min())],\n        ),\n        pygltflib.accessor(\n            bufferview=1,\n            componenttype=pygltflib.float,\n            count=len(points),\n            type=pygltflib.vec3,\n            max=points.max(axis=0).tolist(),\n            min=points.min(axis=0).tolist(),\n        ),\n    ],\n    bufferviews=[\n        pygltflib.bufferview(\n            buffer=0,\n            bytelength=len(triangles_binary_blob),\n            target=pygltflib.element_array_buffer,\n        ),\n        pygltflib.bufferview(\n            buffer=0,\n            byteoffset=len(triangles_binary_blob),\n            bytelength=len(points_binary_blob),\n            target=pygltflib.array_buffer,\n        ),\n    ],\n    buffers=[\n        pygltflib.buffer(\n            bytelength=len(triangles_binary_blob) + len(points_binary_blob)\n        )\n    ],\n)\ngltf.set_binary_blob(triangles_binary_blob + points_binary_blob)\n```\nwrite `gltf2` to bytes:\n```python\nglb = b\"\".join(gltf.save_to_bytes())  # save_to_bytes returns an array of the components of a glb\n```\nload `gltf2` from bytes:\n```python\ngltf = pygltflib.gltf2.load_from_bytes(glb)\n```\ndecode `numpy` arrays from `gltf2`:\n```python\nbinary_blob = gltf.binary_blob()\n\ntriangles_accessor = gltf.accessors[gltf.meshes[0].primitives[0].indices]\ntriangles_buffer_view = gltf.bufferviews[triangles_accessor.bufferview]\ntriangles = np.frombuffer(\n    binary_blob[\n        triangles_buffer_view.byteoffset\n        + triangles_accessor.byteoffset : triangles_buffer_view.byteoffset\n        + triangles_buffer_view.bytelength\n    ],\n    dtype=\"uint8\",\n    count=triangles_accessor.count,\n).reshape((-1, 3))\n\npoints_accessor = gltf.accessors[gltf.meshes[0].primitives[0].attributes.position]\npoints_buffer_view = gltf.bufferviews[points_accessor.bufferview]\npoints = np.frombuffer(\n    binary_blob[\n        points_buffer_view.byteoffset\n        + points_accessor.byteoffset : points_buffer_view.byteoffset\n        + points_buffer_view.bytelength\n    ],\n    dtype=\"float32\",\n    count=points_accessor.count * 3,\n).reshape((-1, 3))\n```\n**p.s.**: if you'd like to use \"compiled\" version of mesh writing:\n```python\ngltf = pygltflib.gltf2(\n    scene=0,\n    scenes=[pygltflib.scene(nodes=[0])],\n    nodes=[pygltflib.node(mesh=0)],\n    meshes=[\n        pygltflib.mesh(\n            primitives=[\n                pygltflib.primitive(\n                    attributes=pygltflib.attributes(position=1), indices=0\n                )\n            ]\n        )\n    ],\n    accessors=[\n        pygltflib.accessor(\n            bufferview=0,\n            componenttype=pygltflib.unsigned_byte,\n            count=36,\n            type=pygltflib.scalar,\n            max=[7],\n            min=[0],\n        ),\n        pygltflib.accessor(\n            bufferview=1,\n            componenttype=pygltflib.float,\n            count=8,\n            type=pygltflib.vec3,\n            max=[0.5, 0.5, 0.5],\n            min=[-0.5, -0.5, -0.5],\n        ),\n    ],\n    bufferviews=[\n        pygltflib.bufferview(\n            buffer=0, bytelength=36, target=pygltflib.element_array_buffer\n        ),\n        pygltflib.bufferview(\n            buffer=0, byteoffset=36, bytelength=96, target=pygltflib.array_buffer\n        ),\n    ],\n    buffers=[pygltflib.buffer(bytelength=132)],\n)\ngltf.set_binary_blob(\n    b\"\\x00\\x01\\x02\\x03\\x02\\x01\\x01\\x00\\x04\\x05\\x04\\x00\\x03\\x01\\x06\\x04\\x06\\x01\"\n    b\"\\x02\\x03\\x07\\x06\\x07\\x03\\x00\\x02\\x05\\x07\\x05\\x02\\x05\\x07\\x04\\x06\\x04\\x07\"\n    b\"\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xbf\\x00\\x00\\x00?\\x00\\x00\\x00?\\x00\\x00\\x00\"\n    b\"\\xbf\\x00\\x00\\x00?\\x00\\x00\\x00\\xbf\\x00\\x00\\x00?\\x00\\x00\\x00?\\x00\\x00\\x00?\"\n    b\"\\x00\\x00\\x00?\\x00\\x00\\x00?\\x00\\x00\\x00?\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xbf\"\n    b\"\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xbf\\x00\\x00\\x00?\\x00\\x00\"\n    b\"\\x00?\\x00\\x00\\x00\\xbf\\x00\\x00\\x00\\xbf\\x00\\x00\\x00?\\x00\\x00\\x00\\xbf\"\n)\n```\n\n### loading and saving\n\n`pygltflib` can load json-based .gltf files and binary .glb files, based on the file extension. \n\n#### gltf files\n\n```\n>>> from pygltflib import gltf2\n>>> filename = \"gltf-sample-models/2.0/animatedcube/gltf/animatedcube.gltf\"\n>>> gltf = gltf2().load(filename)\n>>> gltf.scene\n0\n\n>>> gltf.scenes\n[scene(name='', nodes=[0])]\n\n>>> gltf.nodes[0]\nnode(mesh=0, skin=none, rotation=[0.0, -1.0, 0.0, 0.0], translation=[], scale=[], children=[], matrix=[], camera=none, name='animatedcube')\n>>> gltf.nodes[0].name\n'animatedcube'\n\n>>> gltf.meshes[0].primitives[0].attributes\nattributes(normal=4, position=none, tangent=5, texcoord_0=6)\n\n>>> filename2 = \"test.gltf\"\n>>> gltf.save(filename2)\n```\n\n#### glb files \n\n```\n>>> from pygltflib import gltf2\n>>> glb_filename = \"gltf-sample-models/2.0/box/gltf-binary/box.glb\"\n>>> glb = gltf2().load(glb_filename)\n>>> glb.scene\n0\n\n>>> glb.scenes\n[scene(name='', nodes=[0])]\n\n>>> glb.nodes[0]\nnode(mesh=none, skin=none, rotation=[], translation=[], scale=[], children=[1], matrix=[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0], camera=none, name=none)\n\n>>> glb.meshes[0].primitives[0].attributes\nattributes(position=2, normal=1, tangent=none, texcoord_0=none, texcoord_1=none, color_0=none, joints_0=none, weights_0=none)\n\n>>> glb.save(\"test.glb\")\n\n>>> glb.binary_blob()  # read the binary blob used by the buffer in a glb\n<a bunch of binary data>\n```\n\n### converting files\n\n#### first method\n\n```python\nfrom pygltflib import gltf2\n\n# convert glb to gltf\nglb = gltf2().load(\"gltf-sample-models/2.0/box/gltf-binary/box.glb\")\nglb.save(\"test.gltf\")\n\n# convert gltf to glb\ngltf = gltf2().load(\"gltf-sample-models/2.0/box/gltf/box.gltf\")\ngltf.save(\"test.glb\")\n```\n\n#### second method using utils\n\n```python\nfrom pygltflib import gltf2\nfrom pygltflib.utils import glb2gltf, gltf2glb\n\n# convert glb to gltf\nglb2gltf(\"gltf-sample-models/2.0/box/gltf-binary/box.glb\")\n\n# convert gltf to glb\ngltf2glb(\"gltf-sample-models/2.0/box/gltf/box.gltf\", \"test.glb\", override=true)\n\n```\n\n### converting buffers \nthe data for a buffer in a gltf2 files can be stored in the buffer object's uri string \nor in a binary file pointed to by the buffer objects' uri string or as a binary blob\ninside a glb file.\n\nwhile saving and loading gltf2 files is mostly handled transparently by the library, \nthere may be some situations where you want a specific type of buffer storage.\n\nfor example, if you have a gltf file that stores all the associated data in .bin files\nbut you want to create a single file, you need to convert the buffers from binary files\nto data uris or glb binary data.\n\nthere is a convenience method named `convert_buffers` that can help.\n\n```python\nfrom pygltflib import gltf2, bufferformat\n\ngltf = gltf2().load(\"gltf-sample-models/2.0/box/gltf/box.gltf\")\ngltf.convert_buffers(bufferformat.datauri)  # convert buffer uris to data.\ngltf.save_binary(\"test.glb\")  # try and save, will get warning.\n# will receive: warning: unable to save data uri to glb format.\n\ngltf.convert_buffers(bufferformat.binaryblob)   # convert buffers to glb blob\ngltf.save_binary(\"test.glb\")\n\ngltf.convert_buffers(bufferformat.binfile)   # convert buffers to files\ngltf.save(\"test.gltf\")  # all the buffers are saved in 0.bin, 1.bin, 2.bin.\n```\n\n### converting texture images\nthe image data for textures in gltf2 files can be stored in the image objects uri string\nor in an image file pointed to by the image objects' uri string or as part of the buffer.\n\nwhile saving and loading gltf2 files is mostly handled transparently by the library,\nthere may be some situations where you want a specific type of image storage.\n\nfor example, if you have a glb file that stores all its image files in .png files \nbut you want to create a single gltf file, you need to convert the images from files\nto data uris.\n\ncurrently converting images to and from the buffer is not supported. only image\nfiles and data uris are supported.\n\nthere is a convenience method named `convert_images` that can help.  \n\n```python\n\n# embed an image file to your gltf.\n\nfrom pygltflib.utils import imageformat, image\ngltf = gltf2()\nimage = image()\nimage.uri = \"myfile.png\"\ngltf.images.append(image)\n\ngltf.convert_images(imageformat.datauri)  # image file will be imported into the gltf\ngltf.images[0].uri  # will now be something like \"data:image/png;base64,ivborw0kgg...\"\ngltf.images[0].name  # will be myfile.png\n\n```\n\n```python\n# create an image file from gltf data uris\n\nfrom pathlib import path\nfrom pygltflib.utils import imageformat, image\ngltf = gltf2()\nimage = image()\nimage.uri = \"data:image/png;base64,ivborw0kgg...\"\nimage.name = \"myfile.png\"  # optional file name, if not provided, the image files will be called \"0.png\", \"1.png\"\ngltf.images.append(image)\n\ngltf.convert_images(imageformat.file)  # image file will be imported into the gltf\ngltf.images[0].uri  # will be myfile.png\n\nassert path(\"myfile.png\").exists() is true\n```\n\n\n## extensions\nthe gltf2 spec allows for extensions to added to any component of a gltf file.\n\nas of writing (august 2019) there are [about a dozen extensions from khronos and other vendors](https://github.com/khronosgroup/gltf/tree/master/extensions/2.0/)\n\nin pygltflib, extensions are loaded as ordinary `dict` objects and so should be accessed like regular key,value pairs.\n\nfor example `extensions[\"khr_draco_mesh_compression\"][\"bufferview\"]` instead of `extensions[\"khr_draco_mesh_compression\"].bufferview`.\n\nthis allows future extensions to be automatically supported by pygltflib.\n\n*extras* should work the same way.\n\n\n### ext_structural_metadata\n\nthe [ext_structural_metadata](https://github.com/cesiumgs/gltf/tree/3d-tiles-next/extensions/2.0/vendor/ext_structural_metadata) \nis a draft (august 2023) extension \nthat defines a means of storing structured metadata within a gltf 2.0 asset. \n\n\n`ext_structural_metadata` imposes 8-byte binary data alignment requirements on an asset, \nallowing support for 64-bit data types while remaining compatible with the 4-byte alignments in the core gltf specification.\n\nto support this meta extension, when `pygltflib` detects the presence of this extension in a gltf2 object (for example, if\next_structural_metadata is in `self.extensionsused`, `self.extensionsrequired`, or `self.extensions`) will pad chunks using 8-bytes instead of 4.\n\nthis alignment value (4 or 8 or indeed any power-of-two value) can be set manually using the `set_min_alignment` method.\n\n\n## running the tests\n\n### status of gltf-validator\nusing sample models loaded and then saved using this library, here are validator reports (blank is untested). \nif available, the result of a visual inspection is in brackets next to the validator result. \n\n\n#### validator status\n| model | gltf to gltf | gltf to glb | glb to gltf | glb to glb | \n| ------| ------- | ------- | ------- | ------ |\n| 2cylinderengine | passes | passes | passes | passes\n| alphablendmodetest | passes | passes | passes | passes\n| animatedcube | passes | passes | no glb available | no glb available|\n| animatedmorphcube | passes |  passes | passes | passes\n| animatedmorphsphere | passes |  passes | passes | passes\n| animatedtriangle | passes |  passes | no glb available | no glb available|\n| avocado | passes |  passes | passes | passes\n| barramundifish | passes | passes | passes | passes\n| boombox | passes | passes | passes | passes\n| boomboxwithaxes | passes | passes | no glb available | no glb available|\n| box | passes | passes | passes | passes\n| boxanimated | passes | passes | passes\n| boxinterleaved | passes | passes | | passes\n| boxtextured | passes | passes\n| boxtexturednonpoweroftwo | passes | passes\n| boxvertexcolors | passes | passes \n| brainstem | passes | passes | passes\n| buggy | passes | passes | passes\n| cameras | passes | passes | no glb available | no glb available|\n| cesiumman | passes | passes\n| cesiummilktruck | passes | passes\n| corset | passes | passes | passes | passes |\n| cube | passes | passes | no glb available | no glb available|\n| damagedhelmet | passes | passes | passes | passes\n| duck | passes | passes | passes | passes\n| flighthelmet | passes | passes | no glb available | no glb available|\n| gearboxassy | passes | passes\n| lantern | passes | passes |\n| metalroughspheres | passes | passes | \n| monster | passes | passes\n| multiuvtest | passes | passes\n| normaltangentmirrortest | passes | passes | \n| normaltangenttest | passes | passes | | passes\n| orientationtest | passes | passes |\n| reciprocatingsaw | passes | passes |\n| riggedfigure | passes |  passes |\n| riggedsimple | passes |  passes |\n| scifihelmet | passes |  passes | no glb available | no glb available|\n| simplemeshes | passes | passes | no glb available | no glb available|\n| simplemorph | passes | passes | no glb available | no glb available|\n| simplesparseaccessor | passes | passes | no glb available | no glb available \n| specglossvsmetalrough | passes | passes | passes | passes\n| sponza | passes | passes | no glb available | no glb available|\n| suzanne | passes | passes | no glb available | no glb available|\n| texturecoordinatetest | passes | passes | passes | passes\n| texturesettingstest | passes | passes | passes | passes\n| texturetransformtest | passes | passes | no glb available | no glb available| \n| triangle | passes | passes | no glb available | no glb available|\n| trianglewithoutindices | passes | passes | no glb available | no glb available|\n| twosidedplane | passes | passes | no glb available | no glb available|\n| vc | passes | *fails* | passes | passes\n| vertexcolortest | passes | passes | passes  | passes\n| waterbottle | passes | passes | passes | passes\n\n\n### utils.validator status\nwhat does pygltflib.utils.validator test?\nnote: at the moment the validator raises an exception when an rule is broken. if you have ideas of the best way to \nreturn information on validation warnings/errors please open a ticket on our gitlab.\n\n| rule | validator tests | exception raised\n| ------| ------- | ----- \n| accessor.componenttype must be valid |  yes | invalidacccessorcomponenttypeexception\n| accessor min and max arrays must be valid length | yes | invalidarraylengthexception\n| accessor min and max arrays must be same length | yes | mismatchedarraylengthexception\n| mesh.primitive.mode must be valid | yes | invalidmeshprimitivemode \n| accessor.sparse.indices.componenttype must be valid |  yes | invalidaccessorsparseindicescomponenttypeexception\n| bufferview byteoffset and bytestrides must be valid | yes | invalidvalueerror\n| bufferview targets must be valid | yes | invalidbufferviewtarget\n| all other tests | no  \n\n\n\n### unittests\n```\ngit clone https://github.com/khronosgroup/gltf-sample-models\npytest test_pygltflib.py\n```\n\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "pygltflib",
  "package_url": "https://pypi.org/project/pygltflib/",
  "project_url": "https://pypi.org/project/pygltflib/",
  "project_urls": {
    "Homepage": "https://gitlab.com/dodgyville/pygltflib"
  },
  "release_url": "https://pypi.org/project/pygltflib/1.16.1/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "python library for reading, writing and managing 3d objects in the khronos group gltf and gltf2 formats.",
  "version": "1.16.1",
  "releases": [],
  "developers": [
    "dodgyville@gmail.com",
    "luke_miller"
  ],
  "kwds": "gltf2glb pygltflib test_pygltflib glb_filename gltf2",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pygltflib",
  "homepage": "https://gitlab.com/dodgyville/pygltflib",
  "release_count": 51,
  "dependency_ids": []
}