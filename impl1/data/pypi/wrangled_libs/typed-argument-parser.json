{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "<p align=\"center\">\n   <img src=\"images/logo.png\" width=\"40%\" align=\"middle\">\n</p>\n\n# typed argument parser (tap)\n\n[![pypi - python version](https://img.shields.io/pypi/pyversions/typed-argument-parser)](https://badge.fury.io/py/typed-argument-parser)\n[![pypi version](https://badge.fury.io/py/typed-argument-parser.svg)](https://badge.fury.io/py/typed-argument-parser)\n[![downloads](https://pepy.tech/badge/typed-argument-parser)](https://pepy.tech/project/typed-argument-parser)\n[![build status](https://github.com/swansonk14/typed-argument-parser/workflows/tests/badge.svg)](https://github.com/swansonk14/typed-argument-parser)\n[![codecov](https://codecov.io/gh/swansonk14/typed-argument-parser/branch/main/graph/badge.svg)](https://codecov.io/gh/swansonk14/typed-argument-parser)\n[![license](https://img.shields.io/github/license/swansonk14/typed-argument-parser.svg)](https://github.com/swansonk14/typed-argument-parser/blob/main/license.txt)\n\ntap is a typed modernization of python's [argparse](https://docs.python.org/3/library/argparse.html) library.\n\ntap provides the following benefits:\n- static type checking\n- code completion\n- source code navigation (e.g. go to definition and go to implementation)\n\n![tap](https://github.com/swansonk14/typed-argument-parser/raw/main/images/tap.png)\n\nsee [this poster](https://docs.google.com/presentation/d/1airn6gpiq4p1l8k003esxmobvxp3a4aveir2koeqn7y/edit?usp=sharing), which we presented at [pycon 2020](https://us.pycon.org/2020/), for a presentation of some of the relevant concepts we used to guide the development of tap. \n\nas of version 1.8.0, tap includes `tapify`, which runs functions or initializes classes with arguments parsed from the command line. we show an example below.\n\n```python\n# square.py\nfrom tap import tapify\n\ndef square(num: float) -> float:\n    return num ** 2\n\nif __name__ == '__main__':\n    print(f'the square of your number is {tapify(square)}.')\n```\n\nrunning `python square.py --num 2` will print `the square of your number is 4.0.`. please see [tapify](#tapify) for more details.\n\n## installation\n\ntap requires python 3.8+\n\nto install tap from pypi run: \n```\npip install typed-argument-parser\n```\n\nto install tap from source, run the following commands:\n\n```\ngit clone https://github.com/swansonk14/typed-argument-parser.git\ncd typed-argument-parser\npip install -e .\n```\n\n## table of contents\n\n* [installation](#installation)\n* [table of contents](#table-of-contents)\n* [tap is python-native](#tap-is-python-native)\n* [tap features](#tap-features)\n  + [arguments](#arguments)\n  + [tap help](#tap-help)\n  + [configuring arguments](#configuring-arguments)\n    - [adding special argument behavior](#adding-special-argument-behavior)\n    - [adding subparsers](#adding-subparsers)\n  + [types](#types)\n  + [argument processing](#argument-processing)\n  + [processing known args](#processing-known-args)\n  + [subclassing](#subclassing)\n  + [printing](#printing)\n  + [reproducibility](#reproducibility)\n  + [saving and loading arguments](#saving-and-loading-arguments)\n  + [loading from configuration files](#loading-from-configuration-files)\n* [tapify](#tapify)\n  + [examples](#examples)\n    - [function](#function)\n    - [class](#class)\n    - [dataclass](#dataclass)\n  + [tapify help](#tapify-help)\n  + [command line vs explicit arguments](#command-line-vs-explicit-arguments)\n  + [known args](#known-args)\n\n## tap is python-native\n\nto see this, let's look at an example:\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\n\nclass simpleargumentparser(tap):\n    name: str  # your name\n    language: str = 'python'  # programming language\n    package: str = 'tap'  # package name\n    stars: int  # number of stars\n    max_stars: int = 5  # maximum stars\n\nargs = simpleargumentparser().parse_args()\n\nprint(f'my name is {args.name} and i give the {args.language} package '\n      f'{args.package} {args.stars}/{args.max_stars} stars!')\n```\n\nyou use tap the same way you use standard argparse.\n\n```\n>>> python main.py --name jesse --stars 5\nmy name is jesse and i give the python package tap 5/5 stars!\n```\n\nthe equivalent argparse code is:\n```python\n\"\"\"main.py\"\"\"\n\nfrom argparse import argumentparser\n\nparser = argumentparser()\nparser.add_argument('--name', type=str, required=true,\n                    help='your name')\nparser.add_argument('--language', type=str, default='python',\n                    help='programming language')\nparser.add_argument('--package', type=str, default='tap',\n                    help='package name')\nparser.add_argument('--stars', type=int, required=true,\n                    help='number of stars')\nparser.add_argument('--max_stars', type=int, default=5,\n                    help='maximum stars')\nargs = parser.parse_args()\n\nprint(f'my name is {args.name} and i give the {args.language} package '\n      f'{args.package} {args.stars}/{args.max_stars} stars!')\n```\n\nthe advantages of being python-native include being able to:\n- overwrite convenient built-in methods (e.g. `process_args` ensures consistency among arguments)\n- add custom methods\n- inherit from your own template classes\n\n## tap features\n\nnow we are going to highlight some of our favorite features and give examples of how they work in practice.\n\n### arguments\n\narguments are specified as class variables defined in a subclass of `tap`. variables defined as `name: type` are required arguments while variables defined as `name: type = value` are not required and default to the provided value.\n\n```python\nclass mytap(tap):\n    required_arg: str\n    default_arg: str = 'default value'\n```\n\n### tap help\n\nsingle line and/or multiline comments which appear after the argument are automatically parsed into the help string provided when running `python main.py -h`. the type and default values of arguments are also provided in the help string.\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\n\nclass mytap(tap):\n    x: float  # what am i?\n    pi: float = 3.14  # i'm pi!\n    \"\"\"pi is my favorite number!\"\"\"\n\nargs = mytap().parse_args()\n```\n\nrunning `python main.py -h` results in the following:\n\n```\n>>> python main.py -h\nusage: demo.py --x x [--pi pi] [-h]\n\noptional arguments:\n  --x x       (float, required) what am i?\n  --pi pi     (float, default=3.14) i'm pi! pi is my favorite number.\n  -h, --help  show this help message and exit\n```\n\n### configuring arguments\nto specify behavior beyond what can be specified using arguments as class variables, override the `configure` method.\n`configure` provides access to advanced argument parsing features such as `add_argument` and `add_subparser`.\nsince tap is a wrapper around argparse, tap provides all of the same functionality.\nwe detail these two functions below.\n\n#### adding special argument behavior\nin the `configure` method, call `self.add_argument` just as you would use argparse's `add_argument`. for example,\n\n```python\nfrom tap import tap\n\nclass mytap(tap):\n    positional_argument: str\n    list_of_three_things: list[str]\n    argument_with_really_long_name: int\n\n    def configure(self):\n        self.add_argument('positional_argument')\n        self.add_argument('--list_of_three_things', nargs=3)\n        self.add_argument('-arg', '--argument_with_really_long_name')\n```\n\n#### adding subparsers\nto add a subparser, override the `configure` method and call `self.add_subparser`. optionally, to specify keyword arguments (e.g., `help`) to the subparser collection, call `self.add_subparsers`. for example,\n\n```python\nclass subparsera(tap):\n    bar: int  # bar help\n\nclass subparserb(tap):\n    baz: literal['x', 'y', 'z']  # baz help\n\nclass args(tap):\n    foo: bool = false  # foo help\n\n    def configure(self):\n        self.add_subparsers(help='sub-command help')\n        self.add_subparser('a', subparsera, help='a help')\n        self.add_subparser('b', subparserb, help='b help')\n```\n\n### types\n\ntap automatically handles all the following types:\n\n```python\nstr, int, float, bool\noptional, optional[str], optional[int], optional[float], optional[bool]\nlist, list[str], list[int], list[float], list[bool]\nset, set[str], set[int], set[float], set[bool]\ntuple, tuple[type1, type2, etc.], tuple[type, ...]  \nliteral\n```\n\nif you're using python 3.9+, then you can replace `list` with `list`, `set` with `set`, and `tuple` with `tuple`.\n\ntap also supports `union`, but this requires additional specification (see [union](#-union-) section below).\n\nadditionally, any type that can be instantiated with a string argument can be used. for example, in\n```python\nfrom pathlib import path\nfrom tap import tap\n\nclass args(tap):\n   path: path\n\nargs = args().parse_args()\n```\n`args.path` is a `path` instance containing the string passed in through the command line.\n\n#### `str`, `int`, and `float`\n\neach is automatically parsed to their respective types, just like argparse.\n\n#### `bool`\n\nif an argument `arg` is specified as `arg: bool` or `arg: bool = false`, then adding the `--arg` flag to the command line will set `arg` to `true`. if `arg` is specified as `arg: bool = true`, then adding `--arg` sets `arg` to `false`.\n\nnote that if the `tap` instance is created with `explicit_bool=true`, then booleans can be specified on the command line as `--arg true` or `--arg false` rather than `--arg`. additionally, booleans can be specified by prefixes of `true` and `false` with any capitalization as well as `1` or `0` (e.g. for true, `--arg tru`, `--arg t`, `--arg 1` all suffice). \n\n#### `optional`\n\nthese arguments are parsed in exactly the same way as `str`, `int`, `float`, and `bool`. note bools can be specified using the same rules as above and that `optional` is equivalent to `optional[str]`.\n\n#### `list`\n\nif an argument `arg` is a `list`, simply specify the values separated by spaces just as you would with regular argparse. for example, `--arg 1 2 3` parses to `arg = [1, 2, 3]`.\n\n#### `set`\n\nidentical to `list` but parsed into a set rather than a list.\n\n#### `tuple`\n\ntuples can be used to specify a fixed number of arguments with specified types using the syntax `tuple[type1, type2, etc.]` (e.g. `tuple[str, int, bool, str]`). tuples with a variable number of arguments are specified by `tuple[type, ...]` (e.g. `tuple[int, ...]`). note `tuple` defaults to `tuple[str, ...]`.\n\n#### `literal`\n\nliteral is analagous to argparse's [choices](https://docs.python.org/3/library/argparse.html#choices), which specifies the values that an argument can take. for example, if arg can only be one of 'h', 1, false, or 1.0078 then you would specify that `arg: literal['h', 1, false, 1.0078]`. for instance, `--arg false` assigns arg to false and `--arg true` throws error.\n\n#### `union`\n\nunion types must include the `type` keyword argument in `add_argument` in order to specify which type to use, as in the example below.\n\n```python\ndef to_number(string: str) -> union[float, int]:\n    return float(string) if '.' in string else int(string)\n\nclass mytap(tap):\n    number: union[float, int]\n\n    def configure(self):\n        self.add_argument('--number', type=to_number)\n```\n\nin python 3.10+, `union[type1, type2, etc.]` can be replaced with `type1 | type2 | etc.`, but the `type` keyword argument must still be provided in `add_argument`.\n\n#### complex types\n\ntap can also support more complex types than the ones specified above. if the desired type is constructed with a single string as input, then the type can be specified directly without additional modifications. for example,\n\n```python\nclass person:\n    def __init__(self, name: str) -> none:\n        self.name = name\n\nclass args(tap):\n    person: person\n\nargs = args().parse_args('--person tapper'.split())\nprint(args.person.name)  # tapper\n```\n\nif the desired type has a more complex constructor, then the `type` keyword argument must be provided in `add_argument`. for example,\n\n```python\nclass agedperson:\n    def __init__(self, name: str, age: int) -> none:\n        self.name = name\n        self.age = age\n\ndef to_aged_person(string: str) -> agedperson:\n    name, age = string.split(',')\n    return agedperson(name=name, age=int(age))\n\nclass args(tap):\n    aged_person: agedperson\n\n    def configure(self) -> none:\n        self.add_argument('--aged_person', type=to_aged_person)\n\nargs = args().parse_args('--aged_person tapper,27'.split())\nprint(f'{args.aged_person.name} is {args.aged_person.age}')  # tapper is 27\n```\n\n\n### argument processing\n\nwith complex argument parsing, arguments often end up having interdependencies. this means that it may be necessary to disallow certain combinations of arguments or to modify some arguments based on other arguments.\n\nto handle such cases, simply override `process_args` and add the required logic. `process_args` is automatically called when `parse_args` is called.\n\n```python\nclass mytap(tap):\n    package: str\n    is_cool: bool\n    stars: int\n\n    def process_args(self):\n        # validate arguments\n        if self.is_cool and self.stars < 4:\n            raise valueerror('cool packages cannot have fewer than 4 stars')\n\n        # modify arguments\n        if self.package == 'tap':\n            self.is_cool = true\n            self.stars = 5\n```\n\n### processing known args\n\nsimilar to argparse's `parse_known_args`, tap is capable of parsing only arguments that it is aware of without raising an error due to additional arguments. this can be done by calling `parse_args` with `known_only=true`. the remaining un-parsed arguments are then available by accessing the `extra_args` field of the tap object.\n\n```python\nclass mytap(tap):\n    package: str\n\nargs = mytap().parse_args(['--package', 'tap', '--other_arg', 'value'], known_only=true)\nprint(args.extra_args)  # ['--other_arg', 'value']\n```\n\n### subclassing\n\nit is sometimes useful to define a template tap and then subclass it for different use cases. since tap is a native python class, inheritance is built-in, making it easy to customize from a template tap.\n\nin the example below, `starstap` and `awardstap` inherit the arguments (`package` and `is_cool`) and the methods (`process_args`) from `basetap`.\n\n```python\nclass basetap(tap):\n    package: str\n    is_cool: bool\n\n    def process_args(self):\n        if self.package == 'tap':\n            self.is_cool = true\n\n\nclass starstap(basetap):\n    stars: int\n\n\nclass awardstap(basetap):\n    awards: list[str]\n```\n\n### printing\n\ntap uses python's [pretty printer](https://docs.python.org/3/library/pprint.html) to print out arguments in an easy-to-read format.\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\nfrom typing import list\n\nclass mytap(tap):\n    package: str\n    is_cool: bool = true\n    awards: list[str] = ['amazing', 'wow', 'incredible', 'awesome']\n\nargs = mytap().parse_args()\nprint(args)\n```\n\nrunning `python main.py --package tap` results in:\n\n```\n>>> python main.py\n{'awards': ['amazing', 'wow', 'incredible', 'awesome'],\n 'is_cool': true,\n 'package': 'tap'}\n```\n\n### reproducibility\n\ntap makes reproducibility easy, especially when running code in a git repo.\n\n#### reproducibility info\n\nspecifically, tap has a method called `get_reproducibility_info` that returns a dictionary containing all the information necessary to replicate the settings under which the code was run. this dictionary includes:\n- python command\n    - the python command that was used to run the program\n    - ex. `python main.py --package tap`\n- time\n    - the time when the command was run\n    - ex. `thu aug 15 00:09:13 2019`\n- git root\n    - the root of the git repo containing the code that was run\n    - ex. `/users/swansonk14/typed-argument-parser`\n- git url\n    - the url to the git repo, specifically pointing to the current git hash (i.e. the hash of head in the local repo)\n    - ex. [https://github.com/swansonk14/typed-argument-parser/tree/446cf046631d6bdf7cab6daec93bf7a02ac00998](https://github.com/swansonk14/typed-argument-parser/tree/446cf046631d6bdf7cab6daec93bf7a02ac00998)\n- uncommitted changes\n    - whether there are any uncommitted changes in the git repo (i.e. whether the code is different from the code at the above git hash)\n    - ex. `true` or `false`\n\n### saving and loading arguments\n\n#### save\n\ntap has a method called `save` which saves all arguments, along with the reproducibility info, to a json file.\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\n\nclass mytap(tap):\n    package: str\n    is_cool: bool = true\n    stars: int = 5\n\nargs = mytap().parse_args()\nargs.save('args.json')\n```\n\nafter running `python main.py --package tap`, the file `args.json` will contain:\n\n```\n{\n    \"is_cool\": true,\n    \"package\": \"tap\",\n    \"reproducibility\": {\n        \"command_line\": \"python main.py --package tap\",\n        \"git_has_uncommitted_changes\": false,\n        \"git_root\": \"/users/swansonk14/typed-argument-parser\",\n        \"git_url\": \"https://github.com/swansonk14/typed-argument-parser/tree/446cf046631d6bdf7cab6daec93bf7a02ac00998\",\n        \"time\": \"thu aug 15 00:18:31 2019\"\n    },\n    \"stars\": 5\n}\n```\n\nnote: more complex types will be encoded in json as a pickle string.\n\n#### load\n> :exclamation: :warning:<br/>\n> never call `args.load('args.json')` on untrusted files. argument loading uses the `pickle` module to decode complex types automatically. unpickling of untrusted data is a security risk and can lead to arbitrary code execution. see [the warning in the pickle docs](https://docs.python.org/3/library/pickle.html).<br/>\n> :exclamation: :warning:\n\narguments can be loaded from a json file rather than parsed from the command line.\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\n\nclass mytap(tap):\n    package: str\n    is_cool: bool = true\n    stars: int = 5\n\nargs = mytap()\nargs.load('args.json')\n```\n\nnote: all required arguments (in this case `package`) must be present in the json file if not already set in the tap object.\n\n#### load from dict\n\narguments can be loaded from a python dictionary rather than parsed from the command line.\n\n```python\n\"\"\"main.py\"\"\"\n\nfrom tap import tap\n\nclass mytap(tap):\n    package: str\n    is_cool: bool = true\n    stars: int = 5\n\nargs = mytap()\nargs.from_dict({\n    'package': 'tap',\n    'stars': 20\n})\n```\n\nnote: as with `load`, all required arguments must be present in the dictionary if not already set in the tap object. all values in the provided dictionary will overwrite values currently in the tap object.\n\n### loading from configuration files\nconfiguration files can be loaded along with arguments with the optional flag `config_files: list[str]`. arguments passed in from the command line overwrite arguments from the configuration files. arguments in configuration files that appear later in the list overwrite the arguments in previous configuration files.\n\nfor example, if you have the config file `my_config.txt`\n```\n--arg1 1\n--arg2 two\n```\nthen you can write\n```python\nfrom tap import tap\n\nclass args(tap):\n    arg1: int\n    arg2: str\n\nargs = args(config_files=['my_config.txt']).parse_args()\n```\n\nconfig files are parsed using `shlex.split` from the python standard library, which supports shell-style string quoting, as well as line-end comments starting with `#`.\n\nfor example, if you have the config file `my_config_shlex.txt`\n```\n--arg1 21 # important arg value\n\n# multi-word quoted string\n--arg2 \"two three four\"\n```\nthen you can write\n```python\nfrom tap import tap\n\nclass args(tap):\n    arg1: int\n    arg2: str\n\nargs = args(config_files=['my_config_shlex.txt']).parse_args()\n```\nto get the resulting `args = {'arg1': 21, 'arg2': 'two three four'}`\n\nthe legacy parsing behavior of using standard string split can be re-enabled by passing `legacy_config_parsing=true` to `parse_args`.\n\n## tapify\n\n`tapify` makes it possible to run functions or initialize objects via command line arguments. this is inspired by google's [python fire](https://github.com/google/python-fire), but `tapify` also automatically casts command line arguments to the appropriate types based on the type hints. under the hood, `tapify` implicitly creates a tap object and uses it to parse the command line arguments, which it then uses to run the function or initialize the class. we show a few examples below.\n\n### examples\n\n#### function\n\n```python\n# square_function.py\nfrom tap import tapify\n\ndef square(num: float) -> float:\n    \"\"\"square a number.\n\n    :param num: the number to square.\n    \"\"\"\n    return num ** 2\n\nif __name__ == '__main__':\n    squared = tapify(square)\n    print(f'the square of your number is {squared}.')\n```\n\nrunning `python square_function.py --num 5` prints `the square of your number is 25.0.`.\n\n#### class\n\n```python\n# square_class.py\nfrom tap import tapify\n\nclass squarer:\n    def __init__(self, num: float) -> none:\n        \"\"\"initialize the squarer with a number to square.\n\n        :param  num: the number to square.\n        \"\"\"\n        self.num = num\n\n    def get_square(self) -> float:\n        \"\"\"get the square of the number.\"\"\"\n        return self.num ** 2\n\nif __name__ == '__main__':\n    squarer = tapify(squarer)\n    print(f'the square of your number is {squarer.get_square()}.')\n```\n\nrunning `python square_class.py --num 2` prints `the square of your number is 4.0.`.\n\n#### dataclass\n\n```python\n# square_dataclass.py\nfrom dataclasses import dataclass\n\nfrom tap import tapify\n\n@dataclass\nclass squarer:\n    \"\"\"squarer with a number to square.\n\n     :param  num: the number to square.\n    \"\"\"\n    num: float\n\n    def get_square(self) -> float:\n        \"\"\"get the square of the number.\"\"\"\n        return self.num ** 2\n\nif __name__ == '__main__':\n    squarer = tapify(squarer)\n    print(f'the square of your number is {squarer.get_square()}.')\n```\n\nrunning `python square_dataclass.py --num -1` prints `the square of your number is 1.0.`.\n\n### tapify help\n\nthe help string on the command line is set based on the docstring for the function or class. for example, running `python square_function.py -h` will print:\n\n```\nusage: square_function.py [-h] --num num\n\nsquare a number.\n\noptions:\n  -h, --help  show this help message and exit\n  --num num   (float, required) the number to square.\n```\n\nnote that for classes, if there is a docstring in the `__init__` method, then `tapify` sets the help string description to that docstring. otherwise, it uses the docstring from the top of the class.\n\n### command line vs explicit arguments\n\n`tapify` can simultaneously use both arguments passed from the command line and arguments passed in explicitly in the `tapify` call. arguments provided in the `tapify` call override function defaults, and arguments provided via the command line override both arguments provided in the `tapify` call and function defaults. we show an example below.\n\n```python\n# add.py\nfrom tap import tapify\n\ndef add(num_1: float, num_2: float = 0.0, num_3: float = 0.0) -> float:\n    \"\"\"add numbers.\n\n    :param num_1: the first number.\n    :param num_2: the second number.\n    :param num_3: the third number.\n    \"\"\"\n    return num_1 + num_2 + num_3\n\nif __name__ == '__main__':\n    added = tapify(add, num_2=2.2, num_3=4.1)\n    print(f'the sum of your numbers is {added}.')\n```\n\nrunning `python add.py --num_1 1.0 --num_2 0.9` prints `the sum of your numbers is 6.0.`. (note that `add` took `num_1 = 1.0` and `num_2 = 0.9` from the command line and `num_3=4.1` from the `tapify` call due to the order of precedence.)\n\n### known args\n\ncalling `tapify` with `known_only=true` allows `tapify` to ignore additional arguments from the command line that are not needed for the function or class. if `known_only=false` (the default), then `tapify` will raise an error when additional arguments are provided. we show an example below where `known_only=true` might be useful for running multiple `tapify` calls.\n\n```python\n# person.py\nfrom tap import tapify\n\ndef print_name(name: str) -> none:\n    \"\"\"print a person's name.\n\n    :param name: a person's name.\n    \"\"\"\n    print(f'my name is {name}.')\n\ndef print_age(age: int) -> none:\n    \"\"\"print a person's age.\n\n    :param name: a person's age.\n    \"\"\"\n    print(f'my age is {age}.')\n\nif __name__ == '__main__':\n    tapify(print_name, known_only=true)\n    tapify(print_age, known_only=true)\n```\n\nrunning `python person.py --name jesse --age 1` prints `my name is jesse.` followed by `my age is 1.`. without `known_only=true`, the `tapify` calls would raise an error due to the extra argument.\n",
  "docs_url": null,
  "keywords": "typing,argument parser,python",
  "license": "mit",
  "name": "typed-argument-parser",
  "package_url": "https://pypi.org/project/typed-argument-parser/",
  "project_url": "https://pypi.org/project/typed-argument-parser/",
  "project_urls": {
    "Download": "https://github.com/swansonk14/typed-argument-parser/archive/refs/tags/v_1.9.0.tar.gz",
    "Homepage": "https://github.com/swansonk14/typed-argument-parser"
  },
  "release_url": "https://pypi.org/project/typed-argument-parser/1.9.0/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "typed argument parser",
  "version": "1.9.0",
  "releases": [],
  "developers": [
    "jesse_michel_and_kyle_swanson",
    "jessem.michel@gmail.com",
    "swansonk.14@gmail.com"
  ],
  "kwds": "argumentparser parse_known_args parse_args arguments argparse",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_typed_argument_parser",
  "homepage": "https://github.com/swansonk14/typed-argument-parser",
  "release_count": 21,
  "dependency_ids": []
}