{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# pipe \u2014 infix programming toolkit\n\n[![pypi](https://img.shields.io/pypi/v/pipe)\n ![monthly downloads](https://img.shields.io/pypi/dm/pipe)\n ![supported python version](https://img.shields.io/pypi/pyversions/pipe.svg)\n](https://pypi.org/project/pipe)\n[![github workflow status](https://img.shields.io/github/workflow/status/julienpalard/pipe/tests.yml?branch=main)](https://github.com/julienpalard/pipe/actions)\n\nmodule enabling a sh like infix syntax (using pipes).\n\n\n# introduction\n\nas an example, here is the solution for the [2nd euler project\nproblem](https://projecteuler.net/problem=2):\n\n> find the sum of all the even-valued terms in fibonacci which do not\n  exceed four million.\n\ngiven `fib` a generator of fibonacci numbers:\n\n```python\nsum(fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x < 4000000))\n```\n\neach pipes is lazy evalatated, can be aliased, and partially\ninitialized, so it could be rewritten as:\n\n```python\nis_even = where(lambda x: x % 2 == 0)\nsum(fib() | is_even | take_while(lambda x: x < 4000000)\n```\n\n\n# installing\n\nto install the library, you can just run the following command:\n\n```shell\n# linux/macos\npython3 -m pip install pipe\n\n# windows\npy -3 -m pip install pipe\n```\n\n\n# using\n\nthe basic syntax is to use a `|` like in a shell:\n\n```python\n>>> from itertools import count\n>>> from pipe import select, take\n>>> sum(count() | select(lambda x: x ** 2) | take(10))\n285\n>>>\n```\n\nsome pipes take an argument:\n\n```python\n>>> from pipe import where\n>>> sum([1, 2, 3, 4] | where(lambda x: x % 2 == 0))\n6\n>>>\n```\n\nsome do not need one:\n\n```python\n>>> from pipe import traverse\n>>> for i in [1, [2, 3], 4] | traverse:\n...     print(i)\n1\n2\n3\n4\n>>>\n```\n\nin which case it's allowed to use the calling parenthesis:\n\n```python\n>>> from pipe import traverse\n>>> for i in [1, [2, 3], 4] | traverse():\n...     print(i)\n1\n2\n3\n4\n>>>\n```\n\n\n## existing pipes in this module\n\nalphabetical list of available pipes; when several names are listed\nfor a given pipe, these are aliases.\n\n### `batched`\n\nlike python 3.12 `itertool.batched`:\n\n```python\n>>> from pipe import batched\n>>> list(\"abcdefg\" | batched(3))\n[('a', 'b', 'c'), ('d', 'e', 'f'), ('g',)]\n>>>\n```\n\n### `chain`\n\nchain a sequence of iterables:\n\n```python\n>>> from pipe import chain\n>>> list([[1, 2], [3, 4], [5]] | chain)\n[1, 2, 3, 4, 5]\n>>>\n```\n\nwarning : chain only unfold iterable containing only iterables:\n\n```python\n[1, 2, [3]] | chain\n```\ngives a `typeerror: chain argument #1 must support iteration`\nconsider using traverse.\n\n\n### `chain_with(other)`\n\nlike itertools.chain, yields elements of the given iterable,\nthen yields elements of its parameters\n\n```python\n>>> from pipe import chain_with\n>>> list((1, 2, 3) | chain_with([4, 5], [6]))\n[1, 2, 3, 4, 5, 6]\n>>>\n```\n\n### `dedup(key=none)`\n\ndeduplicate values, using the given `key` function if provided.\n\n```python\n>>> from pipe import dedup\n>>> list([-1, 0, 0, 0, 1, 2, 3] | dedup)\n[-1, 0, 1, 2, 3]\n>>> list([-1, 0, 0, 0, 1, 2, 3] | dedup(key=abs))\n[-1, 0, 2, 3]\n>>>\n```\n\n\n### `enumerate(start=0)`\n\nthe builtin `enumerate()` as a pipe:\n\n```python\n>>> from pipe import enumerate\n>>> list(['apple', 'banana', 'citron'] | enumerate)\n[(0, 'apple'), (1, 'banana'), (2, 'citron')]\n>>> list(['car', 'truck', 'motorcycle', 'bus', 'train'] | enumerate(start=6))\n[(6, 'car'), (7, 'truck'), (8, 'motorcycle'), (9, 'bus'), (10, 'train')]\n>>>\n```\n\n\n### `filter(predicate)`\n\nalias for `where(predicate)`, see `where(predicate)`.\n\n\n### `groupby(key=none)`\n\nlike `itertools.groupby(sorted(iterable, key = keyfunc), keyfunc)`\n\n```python\n>>> from pipe import groupby, map\n>>> items = range(10)\n>>> ' / '.join(items | groupby(lambda x: \"odd\" if x % 2 else \"even\")\n...                  | select(lambda x: \"{}: {}\".format(x[0], ', '.join(x[1] | map(str)))))\n'even: 0, 2, 4, 6, 8 / odd: 1, 3, 5, 7, 9'\n>>>\n```\n\n\n### `islice()`\n\njust the `itertools.islice` function as a pipe:\n\n```python\n>>> from pipe import islice\n>>> list((1, 2, 3, 4, 5, 6, 7, 8, 9) | islice(2, 8, 2))\n[3, 5, 7]\n>>>\n```\n\n### `izip()`\n\njust the `itertools.izip` function as a pipe:\n\n```python\n>>> from pipe import izip\n>>> list(range(0, 10) | izip(range(1, 11)))\n[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n>>>\n```\n\n### `map()`, `select()`\n\napply a conversion expression given as parameter\nto each element of the given iterable\n\n```python\n>>> list([1, 2, 3] | map(lambda x: x * x))\n[1, 4, 9]\n\n>>> list([1, 2, 3] | select(lambda x: x * x))\n[1, 4, 9]\n>>>\n```\n\n### `netcat`\n\nthe netcat pipe sends and receive bytes over tcp:\n\n```python\ndata = [\n    b\"head / http/1.0\\r\\n\",\n    b\"host: python.org\\r\\n\",\n    b\"\\r\\n\",\n]\nfor packet in data | netcat(\"python.org\", 80):\n    print(packet.decode(\"utf-8\"))\n```\n\ngives:\n\n```\nhttp/1.1 301 moved permanently\ncontent-length: 0\nlocation: https://python.org/\nconnection: close\n```\n\n### ```permutations(r=none)```\n\nreturns all possible permutations:\n\n```python\n>>> from pipe import permutations\n>>> for item in 'abc' | permutations(2):\n...     print(item)\n('a', 'b')\n('a', 'c')\n('b', 'a')\n('b', 'c')\n('c', 'a')\n('c', 'b')\n>>>\n```\n\n```python\n>>> for item in range(3) | permutations:\n...     print(item)\n(0, 1, 2)\n(0, 2, 1)\n(1, 0, 2)\n(1, 2, 0)\n(2, 0, 1)\n(2, 1, 0)\n>>>\n```\n\n### `reverse`\n\nlike python's built-in `reversed` function.\n\n```python\n>>> from pipe import reverse\n>>> list([1, 2, 3] | reverse)\n[3, 2, 1]\n>>>\n```\n\n### `select(fct)`\n\nalias for `map(fct)`, see `map(fct)`.\n\n\n### `skip()`\n\nskips the given quantity of elements from the given iterable, then yields\n\n```python\n>>> from pipe import skip\n>>> list((1, 2, 3, 4, 5) | skip(2))\n[3, 4, 5]\n>>>\n```\n\n\n### `skip_while(predicate)`\n\nlike itertools.dropwhile, skips elements of the given iterable\nwhile the predicate is true, then yields others:\n\n```python\n>>> from pipe import skip_while\n>>> list([1, 2, 3, 4] | skip_while(lambda x: x < 3))\n[3, 4]\n>>>\n```\n\n### `sort(key=none, reverse=false)`\n\nlike python's built-in \"sorted\" primitive.\n\n```python\n>>> from pipe import sort\n>>> ''.join(\"python\" | sort)\n'hnopty'\n>>> [5, -4, 3, -2, 1] | sort(key=abs)\n[1, -2, 3, -4, 5]\n>>>\n```\n\n### `t`\n\nlike haskell's operator \":\":\n\n```python\n>>> from pipe import t\n>>> for i in 0 | t(1) | t(2):\n...     print(i)\n0\n1\n2\n>>>\n```\n\n### `tail(n)`\n\nyields the given quantity of the last elements of the given iterable.\n\n```python\n>>> from pipe import tail\n>>> for i in (1, 2, 3, 4, 5) | tail(3):\n...     print(i)\n3\n4\n5\n>>>\n```\n\n### `take(n)`\n\nyields the given quantity of elements from the given iterable, like `head`\nin shell script.\n\n```python\n>>> from pipe import take\n>>> for i in count() | take(5):\n...     print(i)\n0\n1\n2\n3\n4\n>>>\n```\n\n### `take_while(predicate)`\n\nlike `itertools.takewhile`, yields elements of the\ngiven iterable while the predicate is true:\n\n```python\n>>> from pipe import take_while\n>>> for i in count() | take_while(lambda x: x ** 2 < 100):\n...     print(i)\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n>>>\n```\n\n### `tee`\n\ntee outputs to the standard output and yield unchanged items, useful for\ndebugging a pipe stage by stage:\n\n```python\n>>> from pipe import tee\n>>> sum([\"1\", \"2\", \"3\", \"4\", \"5\"] | tee | map(int) | tee)\n'1'\n1\n'2'\n2\n'3'\n3\n'4'\n4\n'5'\n5\n15\n>>>\n```\n\nthe `15` at the end is the `sum` returning.\n\n\n### `transpose()`\n\ntransposes the rows and columns of a matrix.\n\n```python\n>>> from pipe import transpose\n>>> [[1, 2, 3], [4, 5, 6], [7, 8, 9]] | transpose\n[(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n>>>\n```\n\n### `traverse`\n\nrecursively unfold iterables:\n\n```python\n>>> list([[1, 2], [[[3], [[4]]], [5]]] | traverse)\n[1, 2, 3, 4, 5]\n>>> squares = (i * i for i in range(3))\n>>> list([[0, 1, 2], squares] | traverse)\n[0, 1, 2, 0, 1, 4]\n>>>\n```\n\n### `uniq(key=none)`\n\n\nlike dedup() but only deduplicate consecutive values, using the given\n`key` function if provided (or else the identity).\n\n```python\n>>> from pipe import uniq\n>>> list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq)\n[1, 2, 3, 1, 2, 3]\n>>> list([1, -1, 1, 2, -2, 2, 3, 3, 1, 2, 3] | uniq(key=abs))\n[1, 2, 3, 1, 2, 3]\n>>>\n```\n\n### `where(predicate)`, `filter(predicate)`\n\nonly yields the matching items of the given iterable:\n\n```python\n>>> list([1, 2, 3] | where(lambda x: x % 2 == 0))\n[2]\n>>>\n```\n\ndon't forget they can be aliased:\n\n```python\n>>> positive = where(lambda x: x > 0)\n>>> negative = where(lambda x: x < 0)\n>>> sum([-10, -5, 0, 5, 10] | positive)\n15\n>>> sum([-10, -5, 0, 5, 10] | negative)\n-15\n>>>\n```\n\n## constructing your own\n\nyou can construct your pipes using the `pipe` class like:\n\n```python\nfrom pipe import pipe\nsquare = pipe(lambda iterable: (x ** 2 for x in iterable))\nmap = pipe(lambda iterable, fct: builtins.map(fct, iterable)\n>>>\n```\n\nas you can see it's often very short to write, and with a bit of luck\nthe function you're wrapping already takes an iterable as the first\nargument, making the wrapping straight forward:\n\n```python\n>>> from collections import deque\n>>> from pipe import pipe\n>>> end = pipe(deque)\n>>>\n```\n\nand that's it `itrable | end(3)` is `deque(iterable, 3)`:\n\n```python\n>>> list(range(100) | end(3))\n[97, 98, 99]\n>>>\n```\n\nin case it gets more complicated one can use `pipe` as a decorator to\na function taking an iterable as the first argument, and any other\noptional arguments after:\n\n```python\n>>> from statistics import mean\n\n>>> @pipe\n... def running_average(iterable, width):\n...     items = deque(maxlen=width)\n...     for item in iterable:\n...         items.append(item)\n...         yield mean(items)\n\n>>> list(range(20) | running_average(width=2))\n[0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5]\n>>> list(range(20) | running_average(width=10))\n[0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5]\n>>>\n```\n\n\n## euler project samples\n\n> find the sum of all the multiples of 3 or 5 below 1000.\n\n```python\n>>> sum(count() | where(lambda x: x % 3 == 0 or x % 5 == 0) | take_while(lambda x: x < 1000))\n233168\n>>>\n```\n\n> find the sum of all the even-valued terms in fibonacci which do not\n> exceed four million.\n\n```python\nsum(fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x < 4000000))\n```\n\n> find the difference between the sum of the squares of the first one\n> hundred natural numbers and the square of the sum.\n\n```python\n>>> square = map(lambda x: x ** 2)\n>>> sum(range(101)) ** 2 - sum(range(101) | square)\n25164150\n>>>\n```\n\n\n# going deeper\n## partial pipes\n\na `pipe` can be parametrized without being evaluated:\n\n```python\n>>> running_average_of_two = running_average(2)\n>>> list(range(20) | running_average_of_two)\n[0, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5]\n>>>\n```\n\nfor multi-argument pipes then can be partially initialized, you can think of curying:\n\n```python\nsome_iterable | some_pipe(1, 2, 3)\n```\n\nis strictly equivalent to:\n\n```python\nsome_iterable | some_pipe(1)(2)(3)\n```\n\nso it can be used to specialize pipes, first a dummy example:\n\n```python\n>>> @pipe\n... def addmul(iterable, to_add, to_mul):\n...     \"\"\"computes (x + to_add) * to_mul to every items of the input.\"\"\"\n...     for i in iterable:\n...         yield (i + to_add) * to_mul\n\n>>> mul = addmul(0)  # this partially initialize addmul with to_add=0\n>>> list(range(10) | mul(10))\n[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]\n\n```\n\nwhich also works with keyword arguments:\n\n```python\n>>> add = addmul(to_mul=1)  # this partially initialize addmul with `to_mul=1`\n>>> list(range(10) | add(10))\n[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n>>>\n```\n\n\nbut now for something interesting:\n\n```python\n>>> import re\n>>> @pipe\n... def grep(iterable, pattern, flags=0):\n...     for line in iterable:\n...         if re.match(pattern, line, flags=flags):\n...             yield line\n...\n>>> lines = [\"hello\", \"hello\", \"world\", \"world\"]\n>>> for line in lines | grep(\"h\"):\n...     print(line)\nhello\n>>>\n```\n\nnow let's reuse it in two ways, first with a pattern:\n\n```python\n>>> lowercase_only = grep(\"[a-z]+$\")\n>>> for line in lines | lowercase_only:\n...     print(line)\nhello\nworld\n>>>\n```\n\nor now with a flag:\n\n```python\n>>> igrep = grep(flags=re.ignorecase)\n>>> for line in lines | igrep(\"hello\"):\n...    print(line)\n...\nhello\nhello\n>>>\n```\n\n\n## lazy evaluation\n\npipe uses generators all the way down, so it is naturally lazy.\n\nin the following examples we'll use\n[itertools.count](https://docs.python.org/fr/3/library/itertools.html#itertools.count):\nan infinite generator of integers.\n\nwe'll make use of the `tee` pipe too, which prints every values that\npasse through it.\n\nthe following example does nothing, nothing is printed by `tee` so no\nvalue passed through it. it's nice because generating an infinite\nsequence of squares is \"slow\".\n\n```python\n>>> result = count() | tee | select(lambda x: x ** 2)\n>>>\n```\n\nchaining more pipes still won't make previous ones start generating\nvalues, in the following example not a single value is pulled out of\n`count`:\n\n```python\n>>> result = count() | tee | select(lambda x: x ** 2)\n>>> first_results = result | take(10)\n>>> only_odd_ones = first_results | where(lambda x: x % 2)\n>>>\n```\n\nsame without variables:\n\n```python\n>>> result = (count() | tee\n...                   | select(lambda x: x ** 2)\n...                   | take(10)\n...                   | where(lambda x: x % 2))\n>>>\n```\n\n\nonly when values are actually needed, the generators starts to work.\n\nin the following example only two values will be extracted out of `count`:\n- `0` which is squared (to `0`), passes the `take(10)` eaily,\n  but is dropped by `where`\n- `1` which is squared (to `1`), also easily passes the `take(10)`,\n  passes the `where`, and passes the `take(1)`.\n\nat this point `take(1)` is satisfied so no other computations need to\nbe done. notice `tee` printing `0` and `1` passing through it:\n\n```python\n>>> result = (count() | tee\n...                   | select(lambda x: x ** 2)\n...                   | take(10)\n...                   | where(lambda x: x % 2))\n>>> print(list(result | take(1)))\n0\n1\n[1]\n>>>\n```\n\n## deprecations\n\nin pipe 1.x a lot of functions were returning iterables and a lot\nother functions were returning non-iterables, causing confusion. the\none returning non-iterables could only be used as the last function of\na pipe expression, so they are in fact useless:\n\n```python\nrange(100) | where(lambda x: x % 2 == 0) | add\n```\n\ncan be rewritten with no less readability as:\n\n```python\nsum(range(100) | where(lambda x: x % 2 == 0))\n```\n\nso all pipes returning non-iterables were deprecated (raising\nwarnings), and finally removed in pipe 2.0.\n\n\n## what should i do?\n\noh, you just upgraded pipe, got an exception, and landed here? you\nhave three solutions:\n\n\n1) stop using closing-pipes, replace `...|...|...|...|as_list` to\n   `list(...|...|...|)`, that's it, it's even shorter.\n\n2) if \"closing pipes\" are not an issue for you, and you really like\n   them, just reimplement the few you really need, it often take a very\n   few lines of code, or copy them from\n   [here](https://github.com/julienpalard/pipe/blob/dd179c8ff0aa28ee0524f3247e5cb1c51347cba6/pipe.py).\n\n3) if you still rely on a lot of them and are in a hurry, just `pip install pipe<2`.\n\n\nand start testing your project using the [python development\nmode](https://docs.python.org/3/library/devmode.html) so you catch\nthose warnings before they bite you.\n\n\n## but i like them, pleassssse, reintroduce them!\n\nthis has already been discussed in [#74](https://github.com/julienpalard/pipe/issues/74).\n\nan `@pipe` is often easily implemented in a 1 to 3 lines of code\nfunction, and the `pipe` module does not aim at giving all\npossibilities, it aims at giving the `pipe` decorator.\n\nso if you need more pipes, closing pipes, weird pipes, you-name-it,\nfeel free to implement them on your project, and consider the\nalready-implemented ones as examples on how to do it.\n\nsee the `constructing your own` paragraph below.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "pipe",
  "package_url": "https://pypi.org/project/pipe/",
  "project_url": "https://pypi.org/project/pipe/",
  "project_urls": {
    "repository": "https://github.com/JulienPalard/Pipe"
  },
  "release_url": "https://pypi.org/project/pipe/2.1/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "module enabling a sh like infix syntax (using pipes)",
  "version": "2.1",
  "releases": [],
  "developers": [
    "julien@palard.fr"
  ],
  "kwds": "pipe pipes some_pipe pip fibonacci",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_pipe",
  "homepage": "",
  "release_count": 8,
  "dependency_ids": []
}