{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "programming language :: python",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: artificial intelligence",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# ml collections\n\nml collections is a library of python collections designed for ml use cases.\n\n[![documentation status](https://readthedocs.org/projects/ml-collections/badge/?version=latest)](https://ml-collections.readthedocs.io/en/latest/?badge=latest)\n[![pypi version](https://badge.fury.io/py/ml-collections.svg)](https://badge.fury.io/py/ml-collections)\n[![build status](https://github.com/google/ml_collections/workflows/python%20package/badge.svg)](https://github.com/google/ml_collections/actions?query=workflow%3a%22python+package%22)\n\n## configdict\n\nthe two classes called `configdict` and `frozenconfigdict` are \"dict-like\" data\nstructures with dot access to nested elements. together, they are supposed to be\nused as a main way of expressing configurations of experiments and models.\n\nthis document describes example usage of `configdict`, `frozenconfigdict`,\n`fieldreference`.\n\n### features\n\n*   dot-based access to fields.\n*   locking mechanism to prevent spelling mistakes.\n*   lazy computation.\n*   frozenconfigdict() class which is immutable and hashable.\n*   type safety.\n*   \"did you mean\" functionality.\n*   human readable printing (with valid references and cycles), using valid yaml\n    format.\n*   fields can be passed as keyword arguments using the `**` operator.\n*   there are two exceptions to the strong type-safety of the configdict. `int`\n    values can be passed in to fields of type `float`. in such a case, the value\n    is type-converted to a `float` before being stored. similarly, all string\n    types (including unicode strings) can be stored in fields of type `str` or\n    `unicode`.\n\n### basic usage\n\n```python\nimport ml_collections\n\ncfg = ml_collections.configdict()\ncfg.float_field = 12.6\ncfg.integer_field = 123\ncfg.another_integer_field = 234\ncfg.nested = ml_collections.configdict()\ncfg.nested.string_field = 'tom'\n\nprint(cfg.integer_field)  # prints 123.\nprint(cfg['integer_field'])  # prints 123 as well.\n\ntry:\n  cfg.integer_field = 'tom'  # raises typeerror as this field is an integer.\nexcept typeerror as e:\n  print(e)\n\ncfg.float_field = 12  # works: `int` types can be assigned to `float`.\ncfg.nested.string_field = u'bob'  # `string` fields can store unicode strings.\n\nprint(cfg)\n```\n\n### frozenconfigdict\n\na `frozenconfigdict`is an immutable, hashable type of `configdict`:\n\n```python\nimport ml_collections\n\ninitial_dictionary = {\n    'int': 1,\n    'list': [1, 2],\n    'tuple': (1, 2, 3),\n    'set': {1, 2, 3, 4},\n    'dict_tuple_list': {'tuple_list': ([1, 2], 3)}\n}\n\ncfg = ml_collections.configdict(initial_dictionary)\nfrozen_dict = ml_collections.frozenconfigdict(initial_dictionary)\n\nprint(frozen_dict.tuple)  # prints tuple (1, 2, 3)\nprint(frozen_dict.list)  # prints tuple (1, 2)\nprint(frozen_dict.set)  # prints frozenset {1, 2, 3, 4}\nprint(frozen_dict.dict_tuple_list.tuple_list[0])  # prints tuple (1, 2)\n\nfrozen_cfg = ml_collections.frozenconfigdict(cfg)\nprint(frozen_cfg == frozen_dict)  # true\nprint(hash(frozen_cfg) == hash(frozen_dict))  # true\n\ntry:\n  frozen_dict.int = 2 # raises typeerror as frozenconfigdict is immutable.\nexcept attributeerror as e:\n  print(e)\n\n# converting between `frozenconfigdict` and `configdict`:\nthawed_frozen_cfg = ml_collections.configdict(frozen_dict)\nprint(thawed_frozen_cfg == cfg)  # true\nfrozen_cfg_to_cfg = frozen_dict.as_configdict()\nprint(frozen_cfg_to_cfg == cfg)  # true\n```\n\n### fieldreferences and placeholders\n\na `fieldreference` is useful for having multiple fields use the same value. it\ncan also be used for [lazy computation](#lazy-computation).\n\nyou can use `placeholder()` as a shortcut to create a `fieldreference` (field)\nwith a `none` default value. this is useful if a program uses optional\nconfiguration fields.\n\n```python\nimport ml_collections\nfrom ml_collections.config_dict import config_dict\n\nplaceholder = ml_collections.fieldreference(0)\ncfg = ml_collections.configdict()\ncfg.placeholder = placeholder\ncfg.optional = config_dict.placeholder(int)\ncfg.nested = ml_collections.configdict()\ncfg.nested.placeholder = placeholder\n\ntry:\n  cfg.optional = 'tom'  # raises type error as this field is an integer.\nexcept typeerror as e:\n  print(e)\n\ncfg.optional = 1555  # works fine.\ncfg.placeholder = 1  # changes the value of both placeholder and\n                     # nested.placeholder fields.\n\nprint(cfg)\n```\n\nnote that the indirection provided by `fieldreference`s will be lost if accessed\nthrough a `configdict`.\n\n```python\nimport ml_collections\n\nplaceholder = ml_collections.fieldreference(0)\ncfg.field1 = placeholder\ncfg.field2 = placeholder  # this field will be tied to cfg.field1.\ncfg.field3 = cfg.field1  # this will just be an int field initialized to 0.\n```\n\n### lazy computation\n\nusing a `fieldreference` in a standard operation (addition, subtraction,\nmultiplication, etc...) will return another `fieldreference` that points to the\noriginal's value. you can use `fieldreference.get()` to execute the operations\nand get the reference's computed value, and `fieldreference.set()` to change the\noriginal reference's value.\n\n```python\nimport ml_collections\n\nref = ml_collections.fieldreference(1)\nprint(ref.get())  # prints 1\n\nadd_ten = ref.get() + 10  # ref.get() is an integer and so is add_ten\nadd_ten_lazy = ref + 10  # add_ten_lazy is a fieldreference - not an integer\n\nprint(add_ten)  # prints 11\nprint(add_ten_lazy.get())  # prints 11 because ref's value is 1\n\n# addition is lazily computed for fieldreferences so changing ref will change\n# the value that is used to compute add_ten.\nref.set(5)\nprint(add_ten)  # prints 11\nprint(add_ten_lazy.get())  # prints 15 because ref's value is 5\n```\n\nif a `fieldreference` has `none` as its original value, or any operation has an\nargument of `none`, then the lazy computation will evaluate to `none`.\n\nwe can also use fields in a `configdict` in lazy computation. in this case a\nfield will only be lazily evaluated if `configdict.get_ref()` is used to get it.\n\n```python\nimport ml_collections\n\nconfig = ml_collections.configdict()\nconfig.reference_field = ml_collections.fieldreference(1)\nconfig.integer_field = 2\nconfig.float_field = 2.5\n\n# no lazy evaluatuations because we didn't use get_ref()\nconfig.no_lazy = config.integer_field * config.float_field\n\n# this will lazily evaluate only config.integer_field\nconfig.lazy_integer = config.get_ref('integer_field') * config.float_field\n\n# this will lazily evaluate only config.float_field\nconfig.lazy_float = config.integer_field * config.get_ref('float_field')\n\n# this will lazily evaluate both config.integer_field and config.float_field\nconfig.lazy_both = (config.get_ref('integer_field') *\n                    config.get_ref('float_field'))\n\nconfig.integer_field = 3\nprint(config.no_lazy)  # prints 5.0 - it uses integer_field's original value\n\nprint(config.lazy_integer)  # prints 7.5\n\nconfig.float_field = 3.5\nprint(config.lazy_float)  # prints 7.0\nprint(config.lazy_both)  # prints 10.5\n```\n\n#### changing lazily computed values\n\nlazily computed values in a configdict can be overridden in the same way as\nregular values. the reference to the `fieldreference` used for the lazy\ncomputation will be lost and all computations downstream in the reference graph\nwill use the new value.\n\n```python\nimport ml_collections\n\nconfig = ml_collections.configdict()\nconfig.reference = 1\nconfig.reference_0 = config.get_ref('reference') + 10\nconfig.reference_1 = config.get_ref('reference') + 20\nconfig.reference_1_0 = config.get_ref('reference_1') + 100\n\nprint(config.reference)  # prints 1.\nprint(config.reference_0)  # prints 11.\nprint(config.reference_1)  # prints 21.\nprint(config.reference_1_0)  # prints 121.\n\nconfig.reference_1 = 30\n\nprint(config.reference)  # prints 1 (unchanged).\nprint(config.reference_0)  # prints 11 (unchanged).\nprint(config.reference_1)  # prints 30.\nprint(config.reference_1_0)  # prints 130.\n```\n\n#### cycles\n\nyou cannot create cycles using references. fortunately\n[the only way](#changing-lazily-computed-values) to create a cycle is by\nassigning a computed field to one that *is not* the result of computation. this\nis forbidden:\n\n```python\nimport ml_collections\nfrom ml_collections.config_dict import config_dict\n\nconfig = ml_collections.configdict()\nconfig.integer_field = 1\nconfig.bigger_integer_field = config.get_ref('integer_field') + 10\n\ntry:\n  # raises a mutabilityerror because setting config.integer_field would\n  # cause a cycle.\n  config.integer_field = config.get_ref('bigger_integer_field') + 2\nexcept config_dict.mutabilityerror as e:\n  print(e)\n```\n\n### advanced usage\n\nhere are some more advanced examples showing lazy computation with different\noperators and data types.\n\n```python\nimport ml_collections\n\nconfig = ml_collections.configdict()\nconfig.float_field = 12.6\nconfig.integer_field = 123\nconfig.list_field = [0, 1, 2]\n\nconfig.float_multiply_field = config.get_ref('float_field') * 3\nprint(config.float_multiply_field)  # prints 37.8\n\nconfig.float_field = 10.0\nprint(config.float_multiply_field)  # prints 30.0\n\nconfig.longer_list_field = config.get_ref('list_field') + [3, 4, 5]\nprint(config.longer_list_field)  # prints [0, 1, 2, 3, 4, 5]\n\nconfig.list_field = [-1]\nprint(config.longer_list_field)  # prints [-1, 3, 4, 5]\n\n# both operands can be references\nconfig.ref_subtraction = (\n    config.get_ref('float_field') - config.get_ref('integer_field'))\nprint(config.ref_subtraction)  # prints -113.0\n\nconfig.integer_field = 10\nprint(config.ref_subtraction)  # prints 0.0\n```\n\n### equality checking\n\nyou can use `==` and `.eq_as_configdict()` to check equality among `configdict`\nand `frozenconfigdict` objects.\n\n```python\nimport ml_collections\n\ndict_1 = {'list': [1, 2]}\ndict_2 = {'list': (1, 2)}\ncfg_1 = ml_collections.configdict(dict_1)\nfrozen_cfg_1 = ml_collections.frozenconfigdict(dict_1)\nfrozen_cfg_2 = ml_collections.frozenconfigdict(dict_2)\n\n# true because frozenconfigdict converts lists to tuples\nprint(frozen_cfg_1.items() == frozen_cfg_2.items())\n# false because == distinguishes the underlying difference\nprint(frozen_cfg_1 == frozen_cfg_2)\n\n# false because == distinguishes these types\nprint(frozen_cfg_1 == cfg_1)\n# but eq_as_configdict() treats both as configdict, so these are true:\nprint(frozen_cfg_1.eq_as_configdict(cfg_1))\nprint(cfg_1.eq_as_configdict(frozen_cfg_1))\n```\n\n### equality checking with lazy computation\n\nequality checks see if the computed values are the same. equality is satisfied\nif two sets of computations are different as long as they result in the same\nvalue.\n\n```python\nimport ml_collections\n\ncfg_1 = ml_collections.configdict()\ncfg_1.a = 1\ncfg_1.b = cfg_1.get_ref('a') + 2\n\ncfg_2 = ml_collections.configdict()\ncfg_2.a = 1\ncfg_2.b = cfg_2.get_ref('a') * 3\n\n# true because all computed values are the same\nprint(cfg_1 == cfg_2)\n```\n\n### locking and copying\n\nhere is an example with `lock()` and `deepcopy()`:\n\n```python\nimport copy\nimport ml_collections\n\ncfg = ml_collections.configdict()\ncfg.integer_field = 123\n\n# locking prohibits the addition and deletion of new fields but allows\n# modification of existing values.\ncfg.lock()\ntry:\n  cfg.integer_field = 124  # raises attributeerror and suggests valid field.\nexcept attributeerror as e:\n  print(e)\nwith cfg.unlocked():\n  cfg.integer_field = 1555  # works fine too.\n\n# get a copy of the config dict.\nnew_cfg = copy.deepcopy(cfg)\nnew_cfg.integer_field = -123  # works fine.\n\nprint(cfg)\n```\n\n### dictionary attributes and initialization\n\n```python\nimport ml_collections\n\nreferenced_dict = {'inner_float': 3.14}\nd = {\n    'referenced_dict_1': referenced_dict,\n    'referenced_dict_2': referenced_dict,\n    'list_containing_dict': [{'key': 'value'}],\n}\n\n# we can initialize on a dictionary\ncfg = ml_collections.configdict(d)\n\n# reference structure is preserved\nprint(id(cfg.referenced_dict_1) == id(cfg.referenced_dict_2))  # true\n\n# and the dict attributes have been converted to configdict\nprint(type(cfg.referenced_dict_1))  # configdict\n\n# however, the initialization does not look inside of lists, so dicts inside\n# lists are not converted to configdict\nprint(type(cfg.list_containing_dict[0]))  # dict\n```\n\n### more examples\n\nfor more examples, take a look at\n[`ml_collections/config_dict/examples/`](https://github.com/google/ml_collections/tree/master/ml_collections/config_dict/examples)\n\nfor examples and gotchas specifically about initializing a configdict, see\n[`ml_collections/config_dict/examples/config_dict_initialization.py`](https://github.com/google/ml_collections/blob/master/ml_collections/config_dict/examples/config_dict_initialization.py).\n\n## config flags\n\nthis library adds flag definitions to `absl.flags` to handle config files. it\ndoes not wrap `absl.flags` so if using any standard flag definitions alongside\nconfig file flags, users must also import `absl.flags`.\n\ncurrently, this module adds two new flag types, namely `define_config_file`\nwhich accepts a path to a python file that generates a configuration, and\n`define_config_dict` which accepts a configuration directly. configurations are\ndict-like structures (see [configdict](#configdict)) whose nested elements\ncan be overridden using special command-line flags. see the examples below\nfor more details.\n\n### usage\n\nuse `ml_collections.config_flags` alongside `absl.flags`. for\nexample:\n\n`script.py`:\n\n```python\nfrom absl import app\nfrom absl import flags\n\nfrom ml_collections.config_flags import config_flags\n\nflags = flags.flags\nconfig_flags.define_config_file('my_config')\n\ndef main(_):\n  print(flags.my_config)\n\nif __name__ == '__main__':\n  app.run(main)\n```\n\n`config.py`:\n\n```python\n# note that this is a valid python script.\n# get_config() can return an arbitrary dict-like object. however, it is advised\n# to use ml_collections.configdict.\n# see ml_collections/config_dict/examples/config_dict_basic.py\n\nimport ml_collections\n\ndef get_config():\n  config = ml_collections.configdict()\n  config.field1 = 1\n  config.field2 = 'tom'\n  config.nested = ml_collections.configdict()\n  config.nested.field = 2.23\n  config.tuple = (1, 2, 3)\n  return config\n```\n\nnow, after running:\n\n```bash\npython script.py --my_config=config.py \\\n                 --my_config.field1=8 \\\n                 --my_config.nested.field=2.1 \\\n                 --my_config.tuple='(1, 2, (1, 2))'\n```\n\nwe get:\n\n```\nfield1: 8\nfield2: tom\nnested:\n  field: 2.1\ntuple: !!python/tuple\n- 1\n- 2\n- !!python/tuple\n  - 1\n  - 2\n```\n\nusage of `define_config_dict` is similar to `define_config_file`, the main\ndifference is the configuration is defined in `script.py` instead of in a\nseparate file.\n\n`script.py`:\n\n```python\nfrom absl import app\nfrom absl import flags\n\nimport ml_collections\nfrom ml_collections.config_flags import config_flags\n\nconfig = ml_collections.configdict()\nconfig.field1 = 1\nconfig.field2 = 'tom'\nconfig.nested = ml_collections.configdict()\nconfig.nested.field = 2.23\nconfig.tuple = (1, 2, 3)\n\nflags = flags.flags\nconfig_flags.define_config_dict('my_config', config)\n\ndef main(_):\n  print(flags.my_config)\n\nif __name__ == '__main__':\n  app.run()\n```\n\n`config_file` flags are compatible with the command-line flag syntax. all the\nfollowing options are supported for non-boolean values in configurations:\n\n*   `-(-)config.field=value`\n*   `-(-)config.field value`\n\noptions for boolean values are slightly different:\n\n*   `-(-)config.boolean_field`: set boolean value to true.\n*   `-(-)noconfig.boolean_field`: set boolean value to false.\n*   `-(-)config.boolean_field=value`: `value` is `true`, `false`, `true` or\n    `false`.\n\nnote that `-(-)config.boolean_field value` is not supported.\n\n### parameterising the get_config() function\n\nit's sometimes useful to be able to pass parameters into `get_config`, and\nchange what is returned based on this configuration. one example is if you are\ngrid searching over parameters which have a different hierarchical structure -\nthe flag needs to be present in the resulting configdict. it would be possible\nto include the union of all possible leaf values in your configdict,\nbut this produces a confusing config result as you have to remember which\nparameters will actually have an effect and which won't.\n\na better system is to pass some configuration, indicating which structure of\nconfigdict should be returned. an example is the following config file:\n\n```python\nimport ml_collections\n\ndef get_config(config_string):\n  possible_structures = {\n      'linear': ml_collections.configdict({\n          'model_constructor': 'snt.linear',\n          'model_config': ml_collections.configdict({\n              'output_size': 42,\n          }),\n      'lstm': ml_collections.configdict({\n          'model_constructor': 'snt.lstm',\n          'model_config': ml_collections.configdict({\n              'hidden_size': 108,\n          })\n      })\n  }\n\n  return possible_structures[config_string]\n```\n\nthe value of `config_string` will be anything that is to the right of the first\ncolon in the config file path, if one exists. if no colon exists, no value is\npassed to `get_config` (producing a typeerror if `get_config` expects a value.)\n\nthe above example can be run like:\n\n```bash\npython script.py -- --config=path_to_config.py:linear \\\n                    --config.model_config.output_size=256\n```\n\nor like:\n\n```bash\npython script.py -- --config=path_to_config.py:lstm \\\n                    --config.model_config.hidden_size=512\n```\n\n### additional features\n\n*   loads any valid python script which defines `get_config()` function\n    returning any python object.\n*   automatic locking of the loaded object, if the loaded object defines a\n    callable `.lock()` method.\n*   supports command-line overriding of arbitrarily nested values in dict-like\n    objects (with key/attribute based getters/setters) of the following types:\n    *   `types.inttype` (integer)\n    *   `types.floattype` (float)\n    *   `types.booleantype` (bool)\n    *   `types.stringtype` (string)\n    *   `types.tupletype` (tuple)\n*   overriding is type safe.\n*   overriding of `tupletype` can be done by passing in the `tuple` as a string\n    (see the example in the [usage](#usage) section).\n*   the overriding `tuple` object can be of a different size and have different\n    types than the original. nested tuples are also supported.\n\n## authors\n*   sergio g\u00f3mez colmenarejo - sergomez@google.com\n*   wojciech marian czarnecki - lejlot@google.com\n*   nicholas watters\n*   mohit reddy - mohitreddy@google.com\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "ml-collections",
  "package_url": "https://pypi.org/project/ml-collections/",
  "project_url": "https://pypi.org/project/ml-collections/",
  "project_urls": {
    "Homepage": "https://github.com/google/ml_collections"
  },
  "release_url": "https://pypi.org/project/ml-collections/0.1.1/",
  "requires_dist": [],
  "requires_python": ">=2.6",
  "summary": "ml collections is a library of python collections designed for ml usecases.",
  "version": "0.1.1",
  "releases": [],
  "developers": [
    "ml-collections@google.com",
    "ml_collections_authors"
  ],
  "kwds": "ml_collections configdict frozenconfigdict frozen_dict collections",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_ml_collections",
  "homepage": "https://github.com/google/ml_collections",
  "release_count": 2,
  "dependency_ids": []
}