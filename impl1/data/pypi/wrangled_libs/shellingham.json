{
  "classifiers": [
    "development status :: 3 - alpha",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: isc license (iscl)",
    "operating system :: os independent",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "=============================================\nshellingham: tool to detect surrounding shell\n=============================================\n\n.. image:: https://img.shields.io/pypi/v/shellingham.svg\n    :target: https://pypi.org/project/shellingham/\n\nshellingham detects what shell the current python executable is running in.\n\n\nusage\n=====\n\n.. code-block:: python\n\n    >>> import shellingham\n    >>> shellingham.detect_shell()\n    ('bash', '/bin/bash')\n\n``detect_shell`` pokes around the process's running environment to determine\nwhat shell it is run in. it returns a 2-tuple:\n\n* the shell name, always lowercased.\n* the command used to run the shell.\n\n``shelldetectionfailure`` is raised if ``detect_shell`` fails to detect the\nsurrounding shell.\n\n\nnotes\n=====\n\n* the shell name is always lowercased.\n* on windows, the shell name is the name of the executable, minus the file\n  extension.\n\n\nnotes for application developers\n================================\n\nremember, your application's user is not necessarily using a shell.\nshellingham raises ``shelldetectionfailure`` if there is no shell to detect,\nbut *your application should almost never do this to your user*.\n\na practical approach to this is to wrap ``detect_shell`` in a try block, and\nprovide a sane default on failure\n\n.. code-block:: python\n\n    try:\n        shell = shellingham.detect_shell()\n    except shellingham.shelldetectionfailure:\n        shell = provide_default()\n\n\nthere are a few choices for you to choose from.\n\n* the posix standard mandates the environment variable ``shell`` to refer to\n  \"the user's preferred command language interpreter\". this is always available\n  (even if the user is not in an interactive session), and likely the correct\n  choice to launch an interactive sub-shell with.\n* a command ``sh`` is almost guaranteed to exist, likely at ``/bin/sh``, since\n  several posix tools rely on it. this should be suitable if you want to run a\n  (possibly non-interactive) script.\n* all versions of dos and windows have an environment variable ``comspec``.\n  this can always be used to launch a usable command prompt (e.g. `cmd.exe` on\n  windows).\n\nhere's a simple implementation to provide a default shell\n\n.. code-block:: python\n\n    import os\n\n    def provide_default():\n        if os.name == 'posix':\n            return os.environ['shell']\n        elif os.name == 'nt':\n            return os.environ['comspec']\n        raise notimplementederror(f'os {os.name!r} support not available')\n",
  "docs_url": null,
  "keywords": "shell",
  "license": "isc license",
  "name": "shellingham",
  "package_url": "https://pypi.org/project/shellingham/",
  "project_url": "https://pypi.org/project/shellingham/",
  "project_urls": {
    "Homepage": "https://github.com/sarugaku/shellingham"
  },
  "release_url": "https://pypi.org/project/shellingham/1.5.4/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "tool to detect surrounding shell",
  "version": "1.5.4",
  "releases": [],
  "developers": [
    "tzu",
    "uranusjr@gmail.com"
  ],
  "kwds": "detect_shell shelldetectionfailure shell shellingham python",
  "license_kwds": "isc license",
  "libtype": "pypi",
  "id": "pypi_shellingham",
  "homepage": "https://github.com/sarugaku/shellingham",
  "release_count": 23,
  "dependency_ids": []
}