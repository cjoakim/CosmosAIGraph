{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python",
    "programming language :: python :: 3"
  ],
  "description": "# \ud83d\udc69\u200d\u2708\ufe0f coqpit\n\n[![ci](https://github.com/coqui-ai/coqpit/actions/workflows/main.yml/badge.svg?branch=main)](https://github.com/coqui-ai/coqpit/actions/workflows/main.yml)\n\nsimple, light-weight and no dependency config handling through python data classes with to/from json serialization/deserialization.\n\ncurrently it is being used by [\ud83d\udc38tts](https://github.com/coqui-ai/tts).\n## \u2754 why i need this\nwhat i need from a ml configuration library...\n\n1. fixing a general config schema in python to guide users about expected values.\n\n    python is good but not universal. sometimes you train a ml model and use it on a different platform. so, you\n    need your model configuration file importable by other programming languages.\n\n2. simple dynamic value and type checking with default values.\n\n    if you are a beginner in a ml project, it is hard to guess the right values for your ml experiment. therefore it is important\n    to have some default values and know what range and type of input are expected for each field.\n\n4. ability to decompose large configs.\n\n    as you define more fields for the training dataset, data preprocessing, model parameters, etc., your config file tends\n    to get quite large but in most cases, they can be decomposed, enabling flexibility and readability.\n\n5. inheritance and nested configurations.\n\n    simply helps to keep configurations consistent and easier to maintain.\n\n6. ability to override values from the command line when necessary.\n\n    for instance, you might need to define a path for your dataset, and this changes for almost every run. then the user\n    should be able to override this value easily over the command line.\n\n    it also allows easy hyper-parameter search without changing your original code. basically, you can run different models\n    with different parameters just using command line arguments.\n\n7. defining dynamic or conditional config values.\n\n    sometimes you need to define certain values depending on the other values. using python helps to define the underlying\n    logic for such config values.\n\n8. no dependencies\n\n    you don't want to install a ton of libraries for just configuration management. if you install one, then it\n    is better to be just native python.\n\n## \ud83d\udeab limitations\n- `union` type dataclass fields cannot be parsed from console arguments due to the type ambiguity.\n- `json` is the only supported serialization format, although the others can be easily integrated.\n- `list`type with multiple item type annotations are not supported. (e.g. `list[int, str]`).\n- `dict` fields are parsed from console arguments as json str without type checking. (e.g `--val_dict '{\"a\":10, \"b\":100}'`).\n- `missing` fields cannot be avoided when parsing console arguments.\n\n## \ud83d\udd0d examples\n\n### \ud83d\udc49 simple coqpit\n```python\nimport os\nfrom dataclasses import asdict, dataclass, field\nfrom typing import list, union\nfrom coqpit import missing, coqpit, check_argument\n\n\n@dataclass\nclass simpleconfig(coqpit):\n    val_a: int = 10\n    val_b: int = none\n    val_d: float = 10.21\n    val_c: str = \"coqpit is great!\"\n    # mandatory field\n    # raise an error when accessing the value if it is not changed. it is a way to define\n    val_k: int = missing\n    # optional field\n    val_dict: dict = field(default_factory=lambda: {\"val_aa\": 10, \"val_ss\": \"this is in a dict.\"})\n    # list of list\n    val_listoflist: list[list] = field(default_factory=lambda: [[1, 2], [3, 4]])\n    val_listofunion: list[list[union[str,int]]] = field(default_factory=lambda: [[1, 3], [1, \"hi!\"]])\n\n    def check_values(\n        self,\n    ):  # you can define explicit constraints on the fields using `check_argument()`\n        \"\"\"check config fields\"\"\"\n        c = asdict(self)\n        check_argument(\"val_a\", c, restricted=true, min_val=10, max_val=2056)\n        check_argument(\"val_b\", c, restricted=true, min_val=128, max_val=4058, allow_none=true)\n        check_argument(\"val_c\", c, restricted=true)\n\n\nif __name__ == \"__main__\":\n    file_path = os.path.dirname(os.path.abspath(__file__))\n    config = simpleconfig()\n\n    # try missing class argument\n    try:\n        k = config.val_k\n    except attributeerror:\n        print(\" val_k needs a different value before accessing it.\")\n    config.val_k = 1000\n\n    # try serialization and deserialization\n    print(config.serialize())\n    print(config.to_json())\n    config.save_json(os.path.join(file_path, \"example_config.json\"))\n    config.load_json(os.path.join(file_path, \"example_config.json\"))\n    print(config.pprint())\n\n    # try `dict` interface\n    print(*config)\n    print(dict(**config))\n\n    # value assignment by mapping\n    config[\"val_a\"] = -999\n    print(config[\"val_a\"])\n    assert config.val_a == -999\n```\n### \ud83d\udc49 serialization\n```python\nimport os\nfrom dataclasses import asdict, dataclass, field\nfrom coqpit import coqpit, check_argument\nfrom typing import list, union\n\n\n@dataclass\nclass simpleconfig(coqpit):\n    val_a: int = 10\n    val_b: int = none\n    val_c: str = \"coqpit is great!\"\n\n    def check_values(self,):\n        '''check config fields'''\n        c = asdict(self)\n        check_argument('val_a', c, restricted=true, min_val=10, max_val=2056)\n        check_argument('val_b', c, restricted=true, min_val=128, max_val=4058, allow_none=true)\n        check_argument('val_c', c, restricted=true)\n\n\n@dataclass\nclass nestedconfig(coqpit):\n    val_d: int = 10\n    val_e: int = none\n    val_f: str = \"coqpit is great!\"\n    sc_list: list[simpleconfig] = none\n    sc: simpleconfig = simpleconfig()\n    union_var: union[list[simpleconfig], simpleconfig] = field(default_factory=lambda: [simpleconfig(),simpleconfig()])\n\n    def check_values(self,):\n        '''check config fields'''\n        c = asdict(self)\n        check_argument('val_d', c, restricted=true, min_val=10, max_val=2056)\n        check_argument('val_e', c, restricted=true, min_val=128, max_val=4058, allow_none=true)\n        check_argument('val_f', c, restricted=true)\n        check_argument('sc_list', c, restricted=true, allow_none=true)\n        check_argument('sc', c, restricted=true, allow_none=true)\n\n\nif __name__ == '__main__':\n    file_path = os.path.dirname(os.path.abspath(__file__))\n    # init \ud83d\udc38 dataclass\n    config = nestedconfig()\n\n    # save to a json file\n    config.save_json(os.path.join(file_path, 'example_config.json'))\n    # load a json file\n    config2 = nestedconfig(val_d=none, val_e=500, val_f=none, sc_list=none, sc=none, union_var=none)\n    # update the config with the json file.\n    config2.load_json(os.path.join(file_path, 'example_config.json'))\n    # now they should be having the same values.\n    assert config == config2\n\n    # pretty print the dataclass\n    print(config.pprint())\n\n    # export values to a dict\n    config_dict = config.to_dict()\n    # crate a new config with different values than the defaults\n    config2 = nestedconfig(val_d=none, val_e=500, val_f=none, sc_list=none, sc=none, union_var=none)\n    # update the config with the exported valuess from the previous config.\n    config2.from_dict(config_dict)\n    # now they should be having the same values.\n    assert config == config2\n```\n\n\n### \ud83d\udc49 ```argparse``` handling and parsing.\n```python\nimport argparse\nimport os\nfrom dataclasses import asdict, dataclass, field\nfrom typing import list\n\nfrom coqpit import coqpit, check_argument\nimport sys\n\n\n@dataclass\nclass simplerconfig(coqpit):\n    val_a: int = field(default=none, metadata={'help': 'this is val_a'})\n\n\n@dataclass\nclass simpleconfig(coqpit):\n    val_req: str # required field\n    val_a: int = field(default=10,\n                       metadata={'help': 'this is val_a of simpleconfig'})\n    val_b: int = field(default=none, metadata={'help': 'this is val_b'})\n    nested_config: simplerconfig = simplerconfig()\n    mylist_with_default: list[simplerconfig] = field(\n        default_factory=lambda:\n        [simplerconfig(val_a=100),\n         simplerconfig(val_a=999)],\n        metadata={'help': 'list of simplerconfig'})\n\n    # mylist_without_default: list[simplerconfig] = field(default=none, metadata={'help': 'list of simplerconfig'})  # not supported yet!\n\n    def check_values(self, ):\n        '''check config fields'''\n        c = asdict(self)\n        check_argument('val_a', c, restricted=true, min_val=10, max_val=2056)\n        check_argument('val_b',\n                       c,\n                       restricted=true,\n                       min_val=128,\n                       max_val=4058,\n                       allow_none=true)\n        check_argument('val_req', c, restricted=true)\n\n\ndef main():\n    # reference config that we like to match with the one parsed from argparse\n    config_ref = simpleconfig(val_req='this is different',\n                              val_a=222,\n                              val_b=999,\n                              nested_config=simplerconfig(val_a=333),\n                              mylist_with_default=[\n                                  simplerconfig(val_a=222),\n                                  simplerconfig(val_a=111)\n                              ])\n\n    # create new config object from cli inputs\n    parsed = simpleconfig.init_from_argparse()\n    parsed.pprint()\n\n    # check the parsed config with the reference config\n    assert parsed == config_ref\n\n\nif __name__ == '__main__':\n    sys.argv.extend(['--coqpit.val_req', 'this is different'])\n    sys.argv.extend(['--coqpit.val_a', '222'])\n    sys.argv.extend(['--coqpit.val_b', '999'])\n    sys.argv.extend(['--coqpit.nested_config.val_a', '333'])\n    sys.argv.extend(['--coqpit.mylist_with_default.0.val_a', '222'])\n    sys.argv.extend(['--coqpit.mylist_with_default.1.val_a', '111'])\n    main()\n```\n\n### \ud83e\udd38\u200d\u2640\ufe0f merging coqpits\n```python\nimport os\nfrom dataclasses import dataclass\nfrom coqpit import coqpit, check_argument\n\n\n@dataclass\nclass coqpita(coqpit):\n    val_a: int = 10\n    val_b: int = none\n    val_d: float = 10.21\n    val_c: str = \"coqpit is great!\"\n\n\n@dataclass\nclass coqpitb(coqpit):\n    val_d: int = 25\n    val_e: int = 257\n    val_f: float = -10.21\n    val_g: str = \"coqpit is really great!\"\n\n\nif __name__ == '__main__':\n    file_path = os.path.dirname(os.path.abspath(__file__))\n    coqpita = coqpita()\n    coqpitb = coqpitb()\n    coqpitb.merge(coqpita)\n    print(coqpitb.val_a)\n    print(coqpitb.pprint())\n```\n\n## development\n\ninstall the pre-commit hook to automatically check your commits for style and hinting issues:\n\n```bash\n$ python .pre-commit-2.12.1.pyz install\n```\n\n<img src=\"https://static.scarf.sh/a.png?x-pxid=cd0232a8-ead2-4f1f-87f5-0dd8ec33ee51\" />\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "coqpit",
  "package_url": "https://pypi.org/project/coqpit/",
  "project_url": "https://pypi.org/project/coqpit/",
  "project_urls": {
    "Discussions": "https://github.com/coqui-ai/coqpit/discussions",
    "Homepage": "https://github.com/erogol/coqpit",
    "Repository": "https://github.com/coqui-ai/coqpit",
    "Tracker": "https://github.com/coqui-ai/coqpit/issues"
  },
  "release_url": "https://pypi.org/project/coqpit/0.0.17/",
  "requires_dist": [
    "dataclasses ; python_version == \"3.6\""
  ],
  "requires_python": ">=3.7.0",
  "summary": "simple (maybe too simple), light-weight config management through python data-classes.",
  "version": "0.0.17",
  "releases": [],
  "developers": [
    "egolge@coqui.ai"
  ],
  "kwds": "coqui coqpits coqpit config_dict coqpita",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_coqpit",
  "homepage": "https://github.com/erogol/coqpit",
  "release_count": 18,
  "dependency_ids": [
    "pypi_dataclasses"
  ]
}