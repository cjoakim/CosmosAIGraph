{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "===========\nnamedlist\n===========\n\nwarning\n=======\n\nthis package is no longer maintained, except for exceptional cases.\nplease use the built-in dataclasses module instead.\n\noverview\n========\n\nnamedlist provides 2 factory functions, namedlist.namedlist and\nnamedlist.namedtuple. namedlist.namedtuple is similar to\ncollections.namedtuple, with the following differences:\n\n* namedlist.namedtuple supports per-field default values.\n\n* namedlist.namedtuple supports an optional default value, to be used\n  by all fields that do not have an explicit default value.\n\n\nnamedlist.namedlist is similar, with this additional difference:\n\n* namedlist.namedlist instances are mutable.\n\ntypical usage\n=============\n\nyou can use namedlist like a mutable namedtuple::\n\n    >>> from namedlist import namedlist\n\n    >>> point = namedlist('point', 'x y')\n    >>> p = point(1, 3)\n    >>> p.x = 2\n    >>> assert p.x == 2\n    >>> assert p.y == 3\n\nor, you can specify a default value for all fields::\n\n    >>> point = namedlist('point', 'x y', default=3)\n    >>> p = point(y=2)\n    >>> assert p.x == 3\n    >>> assert p.y == 2\n\nor, you can specify per-field default values::\n\n    >>> point = namedlist('point', [('x', 0), ('y', 100)])\n    >>> p = point()\n    >>> assert p.x == 0\n    >>> assert p.y == 100\n\nyou can also specify the per-field defaults with a mapping, instead\nof an iterable. note that this is only useful with an ordered\nmapping, such as an ordereddict::\n\n    >>> from collections import ordereddict\n    >>> point = namedlist('point', ordereddict((('y', 0),\n    ...                                         ('x', 100))))\n    >>> p = point()\n    >>> p\n    point(y=0, x=100)\n\nthe default value will only be used if it is provided and a per-field\ndefault is not used::\n\n    >>> point = namedlist('point', ['x', ('y', 100)], default=10)\n    >>> p = point()\n    >>> assert p.x == 10\n    >>> assert p.y == 100\n\nif you use a mapping, the value no_default is convenient to specify\nthat a field uses the default value::\n\n    >>> from namedlist import no_default\n    >>> point = namedlist('point', ordereddict((('y', no_default),\n    ...                                         ('x', 100))),\n    ...                            default=5)\n    >>> p = point()\n    >>> assert p.x == 100\n    >>> assert p.y == 5\n\nnamedtuple is similar, except the instances are immutable::\n\n    >>> from namedlist import namedtuple\n    >>> point = namedtuple('point', 'x y', default=3)\n    >>> p = point(y=2)\n    >>> assert p.x == 3\n    >>> assert p.y == 2\n    >>> p.x = 10\n    traceback (most recent call last):\n    ...\n    attributeerror: can't set attribute\n\nall of the documentation below in the specifying fields and specifying\ndefaults sections applies to namedlist.namedlist and\nnamedlist.namedtuple.\n\ncreating types\n==============\n\nspecifying fields\n-----------------\n\nfields in namedlist.namedlist or namedlist.namedtuple can be specified\nas in collections.namedtuple: as either a string specifing the field\nnames, or as a iterable of field names. these two uses are\nequivalent::\n\n    >>> point = namedlist('point', 'x y')\n    >>> point = namedlist('point', ['x', 'y'])\n\nas are these::\n\n    >>> point = namedtuple('point', 'x y')\n    >>> point = namedtuple('point', ['x', 'y'])\n\nif using a string, commas are first converted to spaces. so these are\nequivalent::\n\n    >>> point = namedlist('point', 'x y')\n    >>> point = namedlist('point', 'x,y')\n\n\nspecifying defaults\n-------------------\n\nper-field defaults can be specified by supplying a 2-tuple (name,\ndefault_value) instead of just a string for the field name. this is\nonly supported when you specify a list of field names::\n\n    >>> point = namedlist('point', [('x', 0), ('y', 0)])\n    >>> p = point(3)\n    >>> assert p.x == 3\n    >>> assert p.y == 0\n\nor, using namedtuple::\n\n    >>> point = namedtuple('point', [('x', 0), ('y', 0)])\n    >>> p = point(3)\n    >>> assert p.x == 3\n    >>> assert p.y == 0\n\n\nin addition to, or instead of, these per-field defaults, you can also\nspecify a default value which is used when no per-field default value\nis specified::\n\n    >>> point = namedlist('point', 'x y z', default=0)\n    >>> p = point(y=3)\n    >>> assert p.x == 0\n    >>> assert p.y == 3\n    >>> assert p.z == 0\n\n    >>> point = namedlist('point', [('x', 0), 'y', ('z', 0)], default=4)\n    >>> p = point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nin addition to supplying the field names as an iterable of 2-tuples,\nyou can also specify a mapping. the keys will be the field names, and\nthe values will be the per-field default values. this is most useful\nwith an ordereddict, as the order of the fields will then be\ndeterministic.  the module variable no_default can be specified if you\nwant a field to use the per-type default value instead of specifying\nit with a field::\n\n    >>> point = namedlist('point', ordereddict((('x', 0),\n    ...                                         ('y', no_default),\n    ...                                         ('z', 0),\n    ...                                         )),\n    ...                            default=4)\n    >>> p = point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nwriting to values\n-----------------\n\ninstances of the classes generated by namedlist.namedlist are fully\nwritable, unlike the tuple-derived classes returned by\ncollections.namedtuple or namedlist.namedtuple::\n\n    >>> point = namedlist('point', 'x y')\n    >>> p = point(1, 2)\n    >>> p.y = 4\n    >>> assert p.x == 1\n    >>> assert p.y == 4\n\n\nspecifying __slots__\n--------------------\n\nfor namedlist.namedlist, by default, the returned class sets __slots__\nwhich is initialized to the field names. while this decreases memory\nusage by eliminating the instance dict, it also means that you cannot\ncreate new instance members.\n\nto change this behavior, specify use_slots=false when creating the\nnamedlist::\n\n    >>> point = namedlist('point', 'x y', use_slots=false)\n    >>> p = point(0, 1)\n    >>> p.z = 2\n    >>> assert p.x == 0\n    >>> assert p.y == 1\n    >>> assert p.z == 2\n\nhowever, note that this method does not add the new variable to\n_fields, so it is not recognized when iterating over the instance::\n\n    >>> list(p)\n    [0, 1]\n    >>> sorted(p._asdict().items())\n    [('x', 0), ('y', 1)]\n\n\nadditional class members\n------------------------\n\nnamedlist.namedlist and namedlist.namedtuple classes contain these members:\n\n* _asdict(): returns a dict which maps field names to their\n  corresponding values.\n\n* _fields: tuple of strings listing the field names. useful for introspection.\n\n\nrenaming invalid field names\n----------------------------\n\nthis functionality is identical to collections.namedtuple. if you\nspecify rename=true, then any invalid field names are changed to _0,\n_1, etc. reasons for a field name to be invalid are:\n\n* zero length strings.\n\n* containing characters other than alphanumerics and underscores.\n\n* a conflict with a python reserved identifier.\n\n* beginning with a digit.\n\n* beginning with an underscore.\n\n* using the same field name more than once.\n\nfor example::\n\n    >>> point = namedlist('point', 'x x for', rename=true)\n    >>> assert point._fields == ('x', '_1', '_2')\n\n\nmutable default values\n----------------------\n\nfor namedlist.namelist, be aware of specifying mutable default\nvalues. due to the way python handles default values, each instance of\na namedlist will share the default. this is especially problematic\nwith default values that are lists. for example::\n\n    >>> a = namedlist('a', [('x', [])])\n    >>> a = a()\n    >>> a.x.append(4)\n    >>> b = a()\n    >>> assert b.x == [4]\n\nthis is probably not the desired behavior, so see the next section.\n\n\nspecifying a factory function for default values\n------------------------------------------------\n\nfor namedlist.namedlist, you can supply a zero-argument callable for a\ndefault, by wrapping it in a factory call. the only change in this\nexample is to change the default from `[]` to `factory(list)`. but\nnote that `b.x` is a new list object, not shared with `a.x`::\n\n    >>> from namedlist import factory\n    >>> a = namedlist('a', [('x', factory(list))])\n    >>> a = a()\n    >>> a.x.append(4)\n    >>> b = a()\n    >>> assert b.x == []\n\nevery time a new instance is created, your callable (in this case,\n`list`), will be called to produce a new instance for the default\nvalue.\n\niterating over instances\n------------------------\n\nbecause instances are iterable (like lists or tuples), iteration works\nthe same way. values are returned in definition order::\n\n    >>> point = namedlist('point', 'x y z t')\n    >>> p = point(1.0, 42.0, 3.14, 2.71828)\n    >>> for value in p:\n    ...    print(value)\n    1.0\n    42.0\n    3.14\n    2.71828\n\n\nnamedlist specific functions\n============================\n\n_update\n-------\n\n`namedlist._update()` is similar to `dict.update()`. it is used to\nmutate a namedlist.namedlist instance with new values::\n\n    >>> point = namedlist('point', 'x y z')\n    >>> p = point(1, 2, 3)\n    >>> p.z = 4\n    >>> p._update(y=5, x=6)\n    >>> p\n    point(x=6, y=5, z=4)\n\n    >>> p._update({'x': 7, 'z': 8})\n    >>> p\n    point(x=7, y=5, z=8)\n\n    >>> p._update([('z', 9), ('y', 10)])\n    >>> p\n    point(x=7, y=10, z=9)\n\n\ncreating and using instances\n============================\n\nbecause the type returned by namedlist or namedtuple is a normal\npython class, you create instances as you would with any python class.\n\nbitbucket vs. gitlab\n====================\n\nthe repository used to be on bitbucket in mercurial format.  but\nbitbucket dropped mercurial support and did not provide any way to\nmigrate issues to a git repository, even one hosted on bitbucket.  so,\ni abandoned bitbucket and moved the code to gitlab.  thus, all of the\nissue were lost, and new issues started again with #1.  i'm naming the\ngitlab issues as #gh-xx, and the old bitbucket issues as #bb-xx.  i'm\nstill angry at bitbucket for forcing this change.\n\nchange log\n==========\n\n1.8 2020-08-29 eric v. smith\n----------------------------\n\n* add python 3.8 compatibility (#gl-1).\n\n* moved to gitlab.\n\n* require setuptools, and specify universal wheels (issue #bb-30).\n\n* drop code for bdist_rpm that tried to change the rpm name to\n  python-namedlist (issue #bb-31).\n\n1.7 2015-05-15 eric v. smith\n----------------------------\n\n* changed rpm name to python3-namedlist if running with python 3.\n\n* no code changes.\n\n1.6 2014-12-23 eric v. smith\n----------------------------\n\n* add namedlist._update(), similar to dict.update(). thanks to arthur\n  skowronek (issue #bb-23).\n\n* add namedlist._replace(), similar to namedtuple._replace (issue\n  #bb-24).\n\n1.5 2014-05-20 eric v. smith\n----------------------------\n\n* support slices in namedlist.__getattr__ (issue #bb-22).\n\n1.4 2014-03-14 eric v. smith\n----------------------------\n\n* add manifest.in to manifest.in, so it will be included in sdists\n  (issue #bb-21).\n\n1.3 2014-03-12 eric v. smith\n----------------------------\n\n* support unicode type and field names in python 2.x (issue #bb-19). the\n  identifiers still must be ascii only, but you can pass them as\n  unicode. this is useful for code that needs to run under both python\n  2 and python 3.\n\n1.2 2014-02-13 eric v. smith\n----------------------------\n\n* produce an rpm named python-namedlist (issue #bb-17).\n\n* add namedtuple (issue #bb-10). passes all of the collections.namedtuple\n  tests, except those related to _source. those tests don't apply\n  given our different approach to dynamic class creation. all other\n  collections.namedtuple tests have been copied to our test suite.\n\n1.1 2014-02-07 eric v. smith\n----------------------------\n\n* added __dict__ so vars() will be supported.\n\n* fixed pickling from another module (issue #bb-14).\n\n* moved tests to a separate file (issue #bb-15).\n\n1.0 2014-02-04 eric v. smith\n----------------------------\n\n* declare the api stable and release version 1.0.\n\n* support python 2.6 (issue #bb-8). the doctests don't pass because\n  ordereddict isn't available until 2.7.\n\n0.4 2014-02-04 eric v. smith\n----------------------------\n\n* add docstring (issue #bb-7).\n\n* fixed readme.txt typos (thanks pombredanne on bitbucket).\n\n0.3 2014-01-29 eric v. smith\n----------------------------\n\n* removed documentation left over from recordtype.\n\n* make instances unhashable (issue #bb-2).\n\n* for python3, use str.isidentifier (issue #bb-1).\n\n* reorganize code for name checking. no functional changes.\n\n* make instances iterable (issue #bb-3).\n\n* add collections.sequence abc (issue #bb-4).\n\n* have \"python setup.py test\" also run doctests (issue #bb-5).\n\n0.2 2014-01-28 eric v. smith\n----------------------------\n\n* added manifest.in.\n\n* hopefully fixed a problem with .rst formatting in changes.txt.\n\n0.1 2014-01-28 eric v. smith\n----------------------------\n\n* initial release.\n\n* based off my recordtype project, but uses ast generation instead of\n  building up a string and exec-ing it. this has a number of advantages:\n\n  - supporting both python2 and python3 is easier. exec has the\n    anti-feature of having different syntax in the two languages.\n\n  - adding additional features is easier, because i can write in real\n    python instead of having to write the string version, and deal\n    with all of the escaping and syntax errors.\n\n* added factory, to allow namedlist to work even with mutable defaults.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license version 2.0",
  "name": "namedlist",
  "package_url": "https://pypi.org/project/namedlist/",
  "project_url": "https://pypi.org/project/namedlist/",
  "project_urls": {
    "Homepage": "https://gitlab.com/ericvsmith/namedlist"
  },
  "release_url": "https://pypi.org/project/namedlist/1.8/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "similar to namedtuple, but instances are mutable.",
  "version": "1.8",
  "releases": [],
  "developers": [
    "eric@trueblade.com",
    "eric_v"
  ],
  "kwds": "namedlist namedtuple default_value namelist lists",
  "license_kwds": "apache license version 2.0",
  "libtype": "pypi",
  "id": "pypi_namedlist",
  "homepage": "https://gitlab.com/ericvsmith/namedlist",
  "release_count": 14,
  "dependency_ids": []
}