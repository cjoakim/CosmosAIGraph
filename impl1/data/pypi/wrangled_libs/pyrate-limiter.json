{
  "classifiers": [
    "development status :: 5 - production/stable",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: documentation",
    "topic :: software development :: libraries :: python modules",
    "typing :: typed"
  ],
  "description": "<img align=\"left\" width=\"95\" height=\"120\" src=\"https://raw.githubusercontent.com/vutran1710/pyratelimiter/master/docs/_static/logo.png\">\n\n# pyratelimiter\nthe request rate limiter using leaky-bucket algorithm.\n\nfull project documentation can be found at [pyratelimiter.readthedocs.io](https://pyratelimiter.readthedocs.io).\n\n[![pypi version](https://badge.fury.io/py/pyrate-limiter.svg)](https://badge.fury.io/py/pyrate-limiter)\n[![pypi - python versions](https://img.shields.io/pypi/pyversions/pyrate-limiter)](https://pypi.org/project/pyrate-limiter)\n[![codecov](https://codecov.io/gh/vutran1710/pyratelimiter/branch/master/graph/badge.svg?token=e0q0ybsins)](https://codecov.io/gh/vutran1710/pyratelimiter)\n[![maintenance](https://img.shields.io/badge/maintained%3f-yes-green.svg)](https://github.com/vutran1710/pyratelimiter/graphs/commit-activity)\n[![pypi license](https://img.shields.io/pypi/l/ansicolortags.svg)](https://pypi.python.org/pypi/pyrate-limiter/)\n\n<br>\n\n## contents\n- [pyratelimiter](#pyratelimiter)\n  - [contents](#contents)\n  - [features](#features)\n  - [installation](#installation)\n  - [quickstart](#quickstart)\n  - [basic usage](#basic-usage)\n    - [key concepts](#key-concepts)\n    - [defining rate limits & buckets](#defining-rate-limits-and-buckets)\n    - [defining clock & routing logic](#defining-clock--routing-logic-with-bucketfactory)\n    - [wrapping all up with limiter](#wrapping-all-up-with-limiter)\n    - [weight](#weight)\n    - [handling exceeded limits](#handling-exceeded-limits)\n      - [bucket analogy](#bucket-analogy)\n      - [rate limit exceptions](#rate-limit-exceptions)\n       - [rate limit delays](#rate-limit-delays)\n    - [backends](#backends)\n      - [inmemorybucket](#inmemorybucket)\n      - [sqlitebucket](#sqlitebucket)\n      - [redisbucket](#redisbucket)\n    - [decorator](#decorator)\n  - [advance usage](#advance-usage)\n    - [component-level diagram](#component-level-diagram)\n    - [time sources](#time-sources)\n    - [leaking](#leaking)\n    - [concurrency](#concurrency)\n    - [custom backend](#custom-backend)\n\n\n## features\n* tracks any number of rate limits and intervals you want to define\n* independently tracks rate limits for multiple services or resources\n* handles exceeded rate limits by either raising errors or adding delays\n* several usage options including a normal function call, a decorator\n* out-of-the-box workable with both sync & async\n* includes optional sqlite and redis backends, which can be used to persist limit tracking across\n  multiple threads, or application restarts\n\n## installation\n**pyratelimiter** supports **python ^3.8**\n\ninstall using pip:\n```\npip install pyrate-limiter\n```\n\nor using conda:\n```\nconda install --channel conda-forge pyrate-limiter\n```\n\n## quickstart\nlet's say you want to limit 5 requests over 2 seconds, and raise an exception if the limit is exceeded:\n``` python\nfrom pyrate_limiter import duration, rate, inmemorybucket, limiter, bucketfullexception\n\nrate = rate(5, duration.second * 2)\nlimiter = limiter(rate)\n\n# or you can pass multiple rates\n# rates = [rate(5, duration.second * 2), rate(10, duration.minute)]\n# limiter = limiter(rates)\n\nfor request in range(6):\n    try:\n        limiter.try_acquire(request)\n    except bucketfullexception as err:\n        print(err)\n        print(err.meta_info)\n# bucket for item=5 with rate limit=5/2.0s is already full\n# {'error': 'bucket for item=5 with rate limit=5/2.0s is already full', 'name': 5, 'weight': 1, 'rate': 'limit=5/2.0s'}\n```\n\n## basic usage\n### key concepts\n\n#### clock\n-  timestamp items\n\n#### bucket\n- hold items with timestamps.\n- behave like a fifo queue\n- it can `leak` - popping items that are no longer relevant out of the queue\n\n#### bucketfactory\n- bucketfactory keeps references to buckets & clocks: determine the exact time that items arrive then route them to their corresponding buckets\n- help schedule background tasks to run buckets' `leak` periodically to make sure buckets will not explode from containing too many items\n- where user define his own logic: routing, condition-checking, timing etc...\n\n#### limiter\nthe limiter's most important responsibility is to make user's life as easiest as possible:\n- sums up all the underlying logic to a simple, intuitive api to work with\n- handles async/sync context seamlessly (everything just `works` by adding/removing `async/await` keyword to the user's code)\n- provides different ways of interacting with the underlying **bucketfactory** *(plain method call, decorator, context-manager (tba))*\n- provides thread-safety using rlock\n\n\n### defining rate limits and buckets\nconsider some public api (like linkedin, github, etc.) that has rate limits like the following:\n```\n- 500 requests per hour\n- 1000 requests per day\n- 10000 requests per month\n```\n\nyou can define these rates using the `rate` class. `rate` class has 2 properties only: **limit** and **interval**\n``` python\nfrom pyrate_limiter import duration, rate\n\nhourly_rate = rate(500, duration.hour) # 500 requests per hour\ndaily_rate = rate(1000, duration.day) # 1000 requests per day\nmonthly_rate = rate(10000, duration.week * 4) # 10000 requests per month\n\nrates = [hourly_rate, daily_rate, monthly_rate]\n```\n\nrates must be properly ordered:\n- rates' intervals & limits must be ordered from least to greatest\n- rates' ratio of **limit/interval** must be ordered from greatest to least\n\nexisting implementations of bucket come with rate-validation when init. if you are to use your own implementation, use the validator provided by the lib\n\n```python\nfrom pyrate_limiter import validate_rate_list\n\nassert validate_rate_list(my_rates)\n```\n\nthen, add the rates to the bucket of your choices\n\n```python\nfrom pyrate_limiter import inmemorybucket, redisbucket\n\nbasic_bucket = inmemorybucket(rates)\n\n# or, using redis\nfrom redis import redis\n\nredis_connection = redis(host='localhost')\nredis_bucket = redisbucket.init(rates, redis_connection, \"my-bucket-name\")\n\n# async redis would work too!\nfrom redis.asyncio import redis\n\nredis_connection = redis(host='localhost')\nredis_bucket = await redisbucket.init(rates, redis_connection, \"my-bucket-name\")\n```\n\nif you only need a single bucket for everything, and python's built-in `time()` is enough for you, then pass the bucket to limiter then ready to roll!\n\n```python\nfrom pyrate_limiter import limiter\n\n# limiter constructor accepts single bucket as the only parameter,\n# the rest are 3 optional parameters with default values as following\n# limiter(bucket, clock=timeclock(), raise_when_fail=true, max_delay=none)\nlimiter = limiter(bucket)\n\n# limiter is now ready to work!\nlimiter.try_acquire(\"hello world\")\n```\n\nif you want to have finer grain control with routing & clocks etc, then you should use `bucketfactory`.\n\n### defining clock & routing logic with bucketfactory\n\nif you need more than one type of bucket, and be able to route items to different buckets based on some condition, you can use bucketfactory to do that.\n\nfrom the above steps, you already have your buckets. now it's time to define what `time` is (funny?!). most of the time (again!?), you can use the existing clock backend provided by **pyrate_limiter**.\n\n```python\nfrom pyrate_limiter.clock import timeclock, monotonicclock, sqliteclock\n\nbase_clock = timeclock()\n```\n\n\n**pyratelimiter** makes no assumption about users logic, so to map coming items to their correct buckets, implement your own **bucketfactory** class! at minimum, there are only 2 methods require implementing\n\n```python\nfrom pyrate_limiter import bucketfactory\nfrom pyrate_limiter import abstractbucket\n\n\nclass mybucketfactory(bucketfactory):\n    # you can use constructor here,\n    # nor it requires to make bucket-factory work!\n\n    def wrap_item(self, name: str, weight: int = 1) -> rateitem:\n        \"\"\"time-stamping item, return a rateitem\"\"\"\n        now = clock.now()\n        return rateitem(name, now, weight=weight)\n\n    def get(self, _item: rateitem) -> abstractbucket:\n        \"\"\"for simplicity's sake, all items route to the same, single bucket\"\"\"\n        return bucket\n```\n\n### wrapping all up with limiter\n\npass your bucket-factory to limiter, and ready to roll!\n```python\nfrom pyrate_limiter import limiter\n\nlimiter = limiter(\n    bucket_factory,\n    raise_when_fail=false,  # default = true\n    max_delay=1000,     # default = none\n)\n\nitem = \"the-earth\"\nlimiter.try_acquire(item)\n\nheavy_item = \"the-sun\"\nlimiter.try_acquire(heavy_item, weight=10000)\n```\n\nif your bucket's backend is `async`, well, we got you covered! passing `await` to the limiter is enought to make it scream!\n\n```python\nawait limiter.try_acquire(item)\n```\n\nalternatively, you can use `limiter.try_acquire` as a function decorator. but you have to provide a `mapping` function that map the wrapped function's arguments to a proper `limiter.try_acquire` argument - which is a tuple of `(str, int)` or just `str`\n```python\nmy_beautiful_decorator = limiter.as_decorator()\n\ndef mapping(some_number: int):\n    return str(some_number)\n\n@my_beautiful_decorator(mapping)\ndef request_function(some_number: int):\n    requests.get('https://example.com')\n\n# async would work too!\n@my_beautiful_decorator(mapping)\nasync def async_request_function(some_number: int):\n    requests.get('https://example.com')\n```\n\n### weight\n\nitem can have weight. by default item's weight = 1, but you can modify the weight before passing to `limiter.try_acquire`.\n\nitem with weight w > 1 when consumed will be multiplied to (w) items with the same timestamp and weight = 1. example with a big item with weight w=5, when put to bucket, it will be divided to 5 items with weight=1 + following names\n\n```\nbigitem(weight=5, name=\"item\", timestamp=100) => [\n    item(weight=1, name=\"item\", timestamp=100),\n    item(weight=1, name=\"item\", timestamp=100),\n    item(weight=1, name=\"item\", timestamp=100),\n    item(weight=1, name=\"item\", timestamp=100),\n    item(weight=1, name=\"item\", timestamp=100),\n]\n```\n\nyet, putting this big, heavy item into bucket is expected to be transactional & atomic - meaning either all 5 items will be consumed or none of them will. this is made possible as bucket `put(item)` always check for available space before ingesting. all of the bucket's implementations provided by **pyratelimiter** follows this rule.\n\nany additional, custom implementation of bucket are expected to behave alike - as we have unit tests to cover the case.\n\nsee [additional usage options](#additional-usage-options) below for more details.\n\n### handling exceeded limits\nwhen a rate limit is exceeded, you have two options: raise an exception, or add delays.\n\n#### bucket analogy\n<img height=\"300\" align=\"right\" src=\"https://upload.wikimedia.org/wikipedia/commons/c/c4/leaky_bucket_analogy.jpg\">\n\nat this point it's useful to introduce the analogy of \"buckets\" used for rate-limiting. here is a\nquick summary:\n\n* this library implements the [leaky bucket algorithm](https://en.wikipedia.org/wiki/leaky_bucket).\n* it is named after the idea of representing some kind of fixed capacity -- like a network or service -- as a bucket.\n* the bucket \"leaks\" at a constant rate. for web services, this represents the **ideal or permitted request rate**.\n* the bucket is \"filled\" at an intermittent, unpredicatble rate, representing the **actual rate of requests**.\n* when the bucket is \"full\", it will overflow, representing **canceled or delayed requests**.\n* item can have weight. consuming a single item with weight w > 1 is the same as consuming w smaller, unit items - each with weight=1, with the same timestamp and maybe same name (depending on however user choose to implement it)\n\n#### rate limit exceptions\nby default, a `bucketfullexception` will be raised when a rate limit is exceeded.\nthe error contains a `meta_info` attribute with the following information:\n* `name`: the name of item it received\n* `weight`: the weight of item it received\n* `rate`: the specific rate that has been exceeded\n\nhere's an example that will raise an exception on the 4th request:\n```python\nrate = rate(3, duration.second)\nbucket = inmemorybucket([rate])\nclock = timeclock()\n\n\nclass mybucketfactory(bucketfactory):\n\n    def wrap_item(self, name: str, weight: int = 1) -> rateitem:\n        \"\"\"time-stamping item, return a rateitem\"\"\"\n        now = clock.now()\n        return rateitem(name, now, weight=weight)\n\n    def get(self, _item: rateitem) -> abstractbucket:\n        \"\"\"for simplicity's sake, all items route to the same, single bucket\"\"\"\n        return bucket\n\n\nlimiter = limiter(mybucketfactory())\n\nfor _ in range(4):\n    try:\n        limiter.try_acquire('item', weight=2)\n    except bucketfullexception as err:\n        print(err)\n        # output: bucket with rate 3/1.0s is already full\n        print(err.meta_info)\n        # output: {'name': 'item', 'weight': 2, 'rate': '3/1.0s', 'error': 'bucket with rate 3/1.0s is already full'}\n```\n\nthe rate part of the output is constructed as: `limit / interval`. on the above example, the limit\nis 3 and the interval is 1, hence the `rate 3/1`.\n\n#### rate limit delays\nyou may want to simply slow down your requests to stay within the rate limits instead of canceling\nthem. in that case you pass the `max_delay` argument the maximum value of delay (typically in *ms* when use human-clock).\n\n```python\nlimiter = limiter(factory, max_delay=500) # allow to delay up to 500ms\n```\n\nas `max_delay` has been passed as a numeric value, when ingesting item, limiter will:\n- first, try to ingest such item using the routed bucket\n- if it fails to put item into the bucket, it will call `wait(item)` on the bucket to see how much time remains until the bucket can consume the item again?\n- comparing the `wait` value to the `max_delay`.\n- if `max_delay` >= `wait`: delay (wait + 50ms as latency-tolerance) using either `asyncio.sleep` or `time.sleep` until the bucket can consume again\n- if `max_delay` < `wait`: it raises `limiterdelayexception` if limiter's `raise_when_fail=true`, otherwise silently fail and return false\n\nexample:\n```python\nfrom pyrate_limiter import limiterdelayexception\n\nfor _ in range(4):\n    try:\n        limiter.try_acquire('item', weight=2, max_delay=200)\n    except limiterdelayexception as err:\n        print(err)\n        # output:\n        # actual delay exceeded allowance: actual=500, allowed=200\n        # bucket for 'item' with rate 3/1.0s is already full\n        print(err.meta_info)\n        # output: {'name': 'item', 'weight': 2, 'rate': '3/1.0s', 'max_delay': 200, 'actual_delay': 500}\n```\n\n### backends\na few different bucket backends are available:\n- inmemorybucket using python built-in list as bucket\n- redisbucket, using err... redis, with both async/sync support\n- sqlite, using sqlite3\n\n#### inmemorybucket\nthe default bucket is stored in memory, using python `list`\n\n```python\nfrom pyrate_limiter import inmemorybucket, rate, duration\n\nrates = [rate(5, duration.minute * 2)]\nbucket = inmemorybucket(rates)\n```\n\nthis bucket only availabe in `sync` mode. the only constructor argument is `list[rate]`.\n\n#### redisbucket\nredisbucket uses `sorted-set` to store items with key being item's name and score item's timestamp\nbecause it is intended to work with both async & sync, we provide a classmethod `init` for it\n\n```python\nfrom pyrate_limiter import redisbucket, rate, duration\n\n# using synchronous redis\nfrom redis import connectionpool\nfrom redis import redis\n\nrates = [rate(5, duration.minute * 2)]\npool = connectionpool.from_url(\"redis://localhost:6379\")\nredis_db = redis(connection_pool=pool)\nbucket_key = \"bucket-key\"\nbucket = redisbucket.init(rates, redis_db, bucket_key)\n\n# using asynchronous redis\nfrom redis.asyncio import connectionpool as asyncconnectionpool\nfrom redis.asyncio import redis as asyncredis\n\npool = asyncconnectionpool.from_url(\"redis://localhost:6379\")\nredis_db = asyncredis(connection_pool=pool)\nbucket_key = \"bucket-key\"\nbucket = await redisbucket.init(rates, redis_db, bucket_key)\n```\n\nthe api are the same, regardless of sync/async. if asyncredis is being used, calling `await bucket.method_name(args)` would just work!\n\n#### sqlitebucket\nif you need to persist the bucket state, a sqlite backend is available.\n\nmanully create a connection to sqlite and pass it along with the table name to the bucket class:\n\n```python\nfrom pyrate_limiter import sqlitebucket, rate, duration\nimport sqlite3\n\nrates = [rate(5, duration.minute * 2)]\nconn = sqlite3.connect(\n    \"/var/mydb.sqlite\",\n    isolation_level=\"exclusive\",\n    check_same_thread=false,\n)\ntable = \"my-bucket-table\"\nbucket = sqlitebucket(rates, conn, table)\n```\n\n### decorator\n\nlimiter can be used as decorator, but you have to provide a `mapping` function that maps the wrapped function's arguments to `limiter.try_acquire` function arguments. the mapping function must return either a tuple of `(str, int)` or just a `str`\n\nthe decorator can work with both sync & async function\n\n```python\ndecorator = limiter.as_decorator()\n\ndef mapping(*args, **kwargs):\n    return \"demo\", 1\n\n@decorator(mapping)\ndef handle_something(*args, **kwargs):\n    \"\"\"function logic\"\"\"\n\n@decorator(mapping)\nasync def handle_something_async(*args, **kwargs):\n    \"\"\"function logic\"\"\"\n```\n\n## advance usage\n\n### component level diagram\n![](https://raw.githubusercontent.com/vutran1710/pyratelimiter/master/docs/_static/components.jpg)\n\n### time sources\ntime source can be anything from anywhere: be it python's built-in time, or monotonic clock, sqliteclock, or crawling from world time server(well we don't have that, but you can!).\n\n```python\nfrom pyrate_limiter import timeclock      # use python' time.time()\nfrom pyrate_limiter import monotonicclock # use python time.monotonic()\n```\n\nclock's abstract interface only requires implementing a method `now() -> int`. and it can be both sync or async.\n\n\n### leaking\ntypically bucket should not hold items forever. bucket's abstract interface requires its implementation must be provided with `leak(current_timestamp: optional[int] = none)`.\n\nthe `leak` method when called is expected to remove any items considered outdated  at that moment. during limiter lifetime, all the buckets' `leak` should be called periodically.\n\n**bucketfactory** provide a method called `schedule_leak` to help deal with this matter. basically, it will run **1(one)** background task for a specific bucket, where interval between `leak` call by default is the bucket's longest rate's interval * 2.\n\n```python\n# runnning a background task (whether it is sync/async - doesnt matter)\n# calling the bucket's leak, using the clock as `bucket.leak(clock.now())`\n# interval between call = bucket.rates[-1].interval * 2 (ms)\nfactory.schedule_leak(bucket, clock)\n```\n\nyou can change this calling interval by overriding bucketfactory's `leak_interval`. for example, use the first rate's interval or a fixed value\n\n```python\nclass mybucketfactory(bucketfactory):\n    ... other implementations\n\n    def leak_interval(self, bucket):\n        if isinstance(bucket, inmemorybucket):\n            return bucket.rates[0].interval\n\n        if isinstance(bucket, redisbucket):\n            return 10_000\n\n        return super().leak_interval()\n```\n\nwhen dealing with leak using bucketfactory, the author's suggestion is, we can be pythonic about this by implementing a constructor\n\n```python\nclass mybucketfactory(bucketfactory):\n\n    def constructor(self, clock, buckets):\n        self.clock = clock\n        self.buckets = buckets\n\n        for bucket in buckets:\n            self.schedule_leak(bucket, clock)\n\n```\n\n### concurrency\ngenerally, lock is provided at limiter's level, except sqlitebucket case.\n\n### custom backends\nif these don't suit your needs, you can also create your own bucket backend by implementing `pyrate_limiter.abstractbucket` class.\n\none of **pyratelimiter** design goals is powerful extensibility and maximum ease of development.\n\nit must be not only be a ready-to-use tool, but also a guide-line, or a framework that help implementing new features/bucket free of the most hassles.\n\ndue to the composition nature of the library, it is possbile to write minimum code and validate the result:\n\n- fork the repo\n- implement your bucket with `pyrate_limiter.abstractbucket`\n- add your own `create_bucket` method in `tests/conftest.py` and pass it to the `create_bucket` fixture\n- run the test suite to validate the result\n\nif the tests pass through, then you are just good to go with your new, fancy bucket!\n",
  "docs_url": null,
  "keywords": "rate,rate-limiter,rate_limiter,ratelimiter,leaky-bucket,ratelimit,ratelimiting",
  "license": "mit",
  "name": "pyrate-limiter",
  "package_url": "https://pypi.org/project/pyrate-limiter/",
  "project_url": "https://pypi.org/project/pyrate-limiter/",
  "project_urls": {
    "Documentation": "https://pyrate-limiter.readthedocs.io",
    "Homepage": "https://github.com/vutran1710/PyrateLimiter",
    "Repository": "https://github.com/vutran1710/PyrateLimiter"
  },
  "release_url": "https://pypi.org/project/pyrate-limiter/3.1.0/",
  "requires_dist": [
    "filelock (>=3.0) ; extra == \"all\"",
    "redis (>=4.0.0,<5.0.0) ; extra == \"all\"",
    "furo (>=2022.3.4,<2023.0.0) ; extra == \"docs\"",
    "myst-parser (>=0.17) ; extra == \"docs\"",
    "sphinx (>=4.3.0,<5.0.0) ; extra == \"docs\"",
    "sphinx-autodoc-typehints (>=1.17,<2.0) ; extra == \"docs\"",
    "sphinx-copybutton (>=0.5) ; extra == \"docs\"",
    "sphinxcontrib-apidoc (>=0.3,<0.4) ; extra == \"docs\""
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "python rate-limiter using leaky-bucket algorithm",
  "version": "3.1.0",
  "releases": [],
  "developers": [
    "me@vutr.io",
    "vutr"
  ],
  "kwds": "pyrate_limiter pyratelimiter rate_limiter ratelimiter pyrate",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pyrate_limiter",
  "homepage": "https://github.com/vutran1710/pyratelimiter",
  "release_count": 40,
  "dependency_ids": [
    "pypi_filelock",
    "pypi_furo",
    "pypi_myst_parser",
    "pypi_redis",
    "pypi_sphinx",
    "pypi_sphinx_autodoc_typehints",
    "pypi_sphinx_copybutton",
    "pypi_sphinxcontrib_apidoc"
  ]
}