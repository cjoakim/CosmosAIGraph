{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: macos :: macos x",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "watchtower: python cloudwatch logging\n=====================================\nwatchtower is a log handler for `amazon web services cloudwatch logs\n<https://aws.amazon.com/blogs/aws/cloudwatch-log-service/>`_.\n\ncloudwatch logs is a log management service built into aws. it is conceptually similar to services like splunk, datadog,\nand loggly, but is more lightweight, cheaper, and tightly integrated with the rest of aws.\n\nwatchtower, in turn, is a lightweight adapter between the `python logging system\n<https://docs.python.org/library/logging.html>`_ and cloudwatch logs. it uses the `boto3 aws sdk\n<https://github.com/boto/boto3>`_, and lets you plug your application logging directly into cloudwatch without the need\nto install a system-wide log collector like `awscli-cwlogs <https://pypi.python.org/pypi/awscli-cwlogs>`_ and round-trip\nyour logs through the instance's syslog. it aggregates logs into batches to avoid sending an api request per each log\nmessage, while guaranteeing a delivery deadline (60 seconds by default).\n\ninstallation\n~~~~~~~~~~~~\n::\n\n    pip install watchtower\n\nsynopsis\n~~~~~~~~\ninstall `awscli <https://pypi.python.org/pypi/awscli>`_ and set your aws credentials (run ``aws configure``).\n\n.. code-block:: python\n\n    import watchtower, logging\n    logging.basicconfig(level=logging.info)\n    logger = logging.getlogger(__name__)\n    logger.addhandler(watchtower.cloudwatchloghandler())\n    logger.info(\"hi\")\n    logger.info(dict(foo=\"bar\", details={}))\n\nafter running the example, you can see the log output in your `aws console\n<https://console.aws.amazon.com/cloudwatch/home>`_ under the **watchtower** log group.\n\niam permissions\n~~~~~~~~~~~~~~~\nthe process running watchtower needs to have access to iam credentials to call the cloudwatch logs api. the standard\nprocedure for loading and configuring credentials is described in the\n`boto3 credentials documentation <https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html>`_.\nwhen running watchtower on an ec2 instance or other aws compute resource, boto3 automatically loads credentials from\n`instance metadata <https://docs.aws.amazon.com/awsec2/latest/userguide/ec2-instance-metadata.html>`_ (imds) or\ncontainer credentials provider (aws_web_identity_token_file or aws_container_credentials_full_uri). the easiest way to\ngrant the right permissions to the iam role associated with these credentials is by attaching an aws\n`managed iam policy <https://docs.aws.amazon.com/iam/latest/userguide/access_policies_managed-vs-inline.html>`_ to the\nrole. while aws provides no generic managed cloudwatch logs writer policy, we recommend that you use the\n``arn:aws:iam::aws:policy/awsopsworkscloudwatchlogs`` managed policy, which has just the right permissions without being\noverly broad.\n\nexample: flask logging with watchtower\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nuse the following configuration to send flask logs to a cloudwatch logs stream called \"loggable\":\n\n.. code-block:: python\n\n    import watchtower, flask, logging\n\n    logging.basicconfig(level=logging.info)\n    app = flask.flask(\"loggable\")\n    handler = watchtower.cloudwatchloghandler(log_group_name=app.name)\n    app.logger.addhandler(handler)\n    logging.getlogger(\"werkzeug\").addhandler(handler)\n\n    @app.route('/')\n    def hello_world():\n        return 'hello world!'\n\n    if __name__ == '__main__':\n        app.run()\n\n(see also `http://flask.pocoo.org/docs/errorhandling/ <http://flask.pocoo.org/docs/errorhandling/>`_.)\n\nexample: django logging with watchtower\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nthis is an example of watchtower integration with django. in your django project, add the following to ``settings.py``:\n\n.. code-block:: python\n\n    import boto3\n\n    aws_region_name = \"us-west-2\"\n\n    boto3_logs_client = boto3.client(\"logs\", region_name=aws_region_name)\n\n    logging = {\n        'version': 1,\n        'disable_existing_loggers': false,\n        'root': {\n            'level': 'debug',\n            # adding the watchtower handler here causes all loggers in the project that\n            # have propagate=true (the default) to send messages to watchtower. if you\n            # wish to send only from specific loggers instead, remove \"watchtower\" here\n            # and configure individual loggers below.\n            'handlers': ['watchtower', 'console'],\n        },\n        'handlers': {\n            'console': {\n                'class': 'logging.streamhandler',\n            },\n            'watchtower': {\n                'class': 'watchtower.cloudwatchloghandler',\n                'boto3_client': boto3_logs_client,\n                'log_group_name': 'your_django_project_name',\n                # decrease the verbosity level here to send only those logs to watchtower,\n                # but still see more verbose logs in the console. see the watchtower\n                # documentation for other parameters that can be set here.\n                'level': 'debug'\n            }\n        },\n        'loggers': {\n            # in the debug server (`manage.py runserver`), several django system loggers cause\n            # deadlocks when using threading in the logging handler, and are not supported by\n            # watchtower. this limitation does not apply when running on production wsgi servers\n            # (gunicorn, uwsgi, etc.), so we recommend that you set `propagate=true` below in your\n            # production-specific django settings file to receive django system logs in cloudwatch.\n            'django': {\n                'level': 'debug',\n                'handlers': ['console'],\n                'propagate': false\n            }\n            # add any other logger-specific configuration here.\n        }\n    }\n\nusing this configuration, logs from django will be sent to cloudwatch in the log group ``your_django_project_name``.\nto supply aws credentials to this configuration in development, set your \n`aws cli profile settings <https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html>`_ with\n``aws configure``. to supply credentials in production or when running on an ec2 instance,\nassign an iam role to your instance, which will cause boto3 to automatically ingest iam role credentials from\n`instance metadata <https://docs.aws.amazon.com/awsec2/latest/userguide/ec2-instance-metadata.html>`_.\n\n(see also the `django logging documentation <https://docs.djangoproject.com/en/dev/topics/logging/>`_.)\n\nexamples: querying cloudwatch logs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nthis section is not specific to watchtower. it demonstrates the use of awscli and jq to read and search cloudwatch logs\non the command line.\n\nfor the flask example above, you can retrieve your application logs with the following two commands::\n\n    aws logs get-log-events --log-group-name watchtower --log-stream-name loggable | jq '.events[].message'\n    aws logs get-log-events --log-group-name watchtower --log-stream-name werkzeug | jq '.events[].message'\n\nin addition to the raw get-log-events api, cloudwatch logs supports\n`extraction of your logs into an s3 bucket <https://docs.aws.amazon.com/amazoncloudwatch/latest/logs/s3export.html>`_,\n`log analysis with a query language <https://docs.aws.amazon.com/amazoncloudwatch/latest/logs/analyzinglogdata.html>`_,\nand alerting and dashboards based on `metric filters\n<http://docs.aws.amazon.com/amazoncloudwatch/latest/developerguide/filterandpatternsyntax.html>`_, which are pattern\nrules that extract information from your logs and feed it to alarms and dashboard graphs. if you want to make use of\nthese features on the command line, the author of watchtower has published an open source cli toolkit called\n`aegea <https://github.com/kislyuk/aegea>`_ that includes the commands ``aegea logs`` and ``aegea grep`` to easily\naccess the s3 export and insights features.\n\nexamples: python logging config\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nthe python ``logging.config`` module has the ability to provide a configuration file that can be loaded in order to\nseparate the logging configuration from the code.\n\nthe following are two example yaml configuration files that can be loaded using pyyaml. the resulting ``dict`` object\ncan then be loaded into ``logging.config.dictconfig``. the first example is a basic example that relies on the default\nconfiguration provided by ``boto3``:\n\n.. code-block:: yaml\n\n    # default aws config\n    version: 1\n    disable_existing_loggers: false\n    formatters:\n      json:\n        format: \"[%(asctime)s] %(process)d %(levelname)s %(name)s:%(funcname)s:%(lineno)s - %(message)s\"\n      plaintext:\n        format: \"[%(asctime)s] %(process)d %(levelname)s %(name)s:%(funcname)s:%(lineno)s - %(message)s\"\n    handlers:\n      console:\n        class: logging.streamhandler\n        formatter: plaintext\n        level: debug\n        stream: ext://sys.stdout\n      logfile:\n        class: logging.handlers.rotatingfilehandler\n        formatter: plaintext\n        level: debug\n        filename: watchtower.log\n        maxbytes: 1000000\n        backupcount: 3\n      watchtower:\n        class: watchtower.cloudwatchloghandler\n        formatter: json\n        level: debug\n        log_group_name: watchtower\n        log_stream_name: \"{logger_name}-{strftime:%y-%m-%d}\"\n        send_interval: 10\n        create_log_group: false\n    root:\n      level: debug\n      propagate: true\n      handlers: [console, logfile, watchtower]\n    loggers:\n      botocore:\n        level: info\n      urllib3:\n        level: info\n\nthe above works well if you can use the default boto3 credential configuration, or rely on environment variables.\nhowever, sometimes one may want to use different credentials for logging than used for other functionality;\nin this case the ``boto3_profile_name`` option to watchtower can be used to provide a boto3 profile name:\n\n.. code-block:: yaml\n\n    # aws config profile\n    version: 1\n    ...\n    handlers:\n      ...\n      watchtower:\n        boto3_profile_name: watchtowerlogger\n        ...\n\nfinally, the following shows how to load the configuration into the working application:\n\n.. code-block:: python\n\n    import logging.config\n\n    import flask\n    import yaml\n\n    app = flask.flask(\"loggable\")\n\n    @app.route('/')\n    def hello_world():\n        return 'hello world!'\n\n    if __name__ == '__main__':\n        with open('logging.yml') as log_config:\n            config_yml = log_config.read()\n            config_dict = yaml.safe_load(config_yml)\n            logging.config.dictconfig(config_dict)\n            app.run()\n\nlog stream naming\n~~~~~~~~~~~~~~~~~\nfor high volume logging applications that utilize process pools, it is recommended that you keep the default log stream\nname (``{machine_name}/{program_name}/{logger_name}/{process_id}``) or otherwise make it unique per source using a\ncombination of these template variables. because logs must be submitted sequentially to each log stream, independent\nprocesses sending logs to the same log stream will encounter sequence token synchronization errors and spend extra resources\nautomatically recovering from them. as the number of processes increases, this overhead will grow until logs fail to\ndeliver and get dropped (causing a warning on stderr). partitioning logs into streams by source avoids this contention.\n\nboto3/botocore/urllib3 logs\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbecause watchtower uses boto3 to send logs, the act of sending them generates a number of debug level log messages\nfrom boto3's dependencies, botocore and urllib3. to avoid generating a self-perpetuating stream of log messages,\n``watchtower.cloudwatchloghandler`` attaches a\n`filter <https://docs.python.org/3/library/logging.html#logging.handler.addfilter>`_ to itself which drops all debug\nlevel messages from these libraries, and drops all messages at all levels from them when shutting down (specifically,\nin ``watchtower.cloudwatchloghandler.flush()`` and ``watchtower.cloudwatchloghandler.close()``). the filter does not\napply to any other handlers you may have processing your messages, so the following basic configuration will cause\nbotocore debug logs to print to stderr but not to cloudwatch:\n\n.. code-block:: python\n\n    import watchtower, logging\n    logging.basicconfig(level=logging.debug)\n    logger = logging.getlogger()\n    logger.addhandler(watchtower.cloudwatchloghandler())\n\naws lambda\n~~~~~~~~~~\nwatchtower is not suitable or necessary for applications running on aws lambda. all aws lambda logs (i.e. all lines\nprinted to stderr by the runtime in the lambda) are automatically sent to cloudwatch logs, into\n`log groups under the /aws/lambda/ prefix <https://console.aws.amazon.com/cloudwatch/home?#logsv2:log-groups$3floggroupnamefilter$3d$252faws$252flambda>`_.\n\naws lambda `suspends (freezes) all processes in its execution environment <https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html>`_\nonce the invocation is complete and until the next invocation, if any. this means any asynchronous background\nprocesses and threads, including watchtower, will be suspended and inoperable, so watchtower cannot function\ncorrectly in this execution model.\n\nauthors\n~~~~~~~\n* andrey kislyuk\n\nlinks\n~~~~~\n* `project home page (github) <https://github.com/kislyuk/watchtower>`_\n* `documentation <https://kislyuk.github.io/watchtower/>`_\n* `package distribution (pypi) <https://pypi.python.org/pypi/watchtower>`_\n* `aws cli cloudwatch logs plugin <https://pypi.python.org/pypi/awscli-cwlogs>`_\n* `docker awslogs adapter <https://github.com/docker/docker/blob/master/daemon/logger/awslogs/cloudwatchlogs.go>`_\n\nbugs\n~~~~\nplease report bugs, issues, feature requests, etc. on `github <https://github.com/kislyuk/watchtower/issues>`_.\n\nlicense\n~~~~~~~\nlicensed under the terms of the `apache license, version 2.0 <http://www.apache.org/licenses/license-2.0>`_.\n\n.. image:: https://github.com/kislyuk/watchtower/workflows/python%20package/badge.svg\n        :target: https://github.com/kislyuk/watchtower/actions\n.. image:: https://codecov.io/github/kislyuk/watchtower/coverage.svg?branch=master\n        :target: https://codecov.io/github/kislyuk/watchtower?branch=master\n.. image:: https://img.shields.io/pypi/v/watchtower.svg\n        :target: https://pypi.python.org/pypi/watchtower\n.. image:: https://img.shields.io/pypi/l/watchtower.svg\n        :target: https://pypi.python.org/pypi/watchtower\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache software license",
  "name": "watchtower",
  "package_url": "https://pypi.org/project/watchtower/",
  "project_url": "https://pypi.org/project/watchtower/",
  "project_urls": {
    "Homepage": "https://github.com/kislyuk/watchtower"
  },
  "release_url": "https://pypi.org/project/watchtower/3.0.1/",
  "requires_dist": [
    "boto3 (<2,>=1.9.253)",
    "pyyaml ; extra == 'tests'",
    "flake8 ; extra == 'tests'",
    "coverage ; extra == 'tests'",
    "build ; extra == 'tests'",
    "wheel ; extra == 'tests'",
    "mypy ; extra == 'tests'"
  ],
  "requires_python": ">=3.7",
  "summary": "python cloudwatch logging",
  "version": "3.0.1",
  "releases": [],
  "developers": [
    "andrey_kislyuk",
    "kislyuk@gmail.com"
  ],
  "kwds": "cloudwatchloghandler cloudwatchlogs awsopsworkscloudwatchlogs cloudwatch watchtowerlogger",
  "license_kwds": "apache software license",
  "libtype": "pypi",
  "id": "pypi_watchtower",
  "homepage": "https://github.com/kislyuk/watchtower",
  "release_count": 37,
  "dependency_ids": [
    "pypi_boto3",
    "pypi_build",
    "pypi_coverage",
    "pypi_flake8",
    "pypi_mypy",
    "pypi_pyyaml",
    "pypi_wheel"
  ]
}