{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3.0",
    "topic :: software development",
    "topic :: utilities"
  ],
  "description": "|test status| |analyze status| |codeql status| |coverage| |pypi version| |commits since last| |downloads| |cii best practices|\n\n.. |pypi version| image:: https://badge.fury.io/py/vermin.svg\n   :target: https://pypi.python.org/pypi/vermin/\n\n.. |test status| image:: https://github.com/netromdk/vermin/workflows/test/badge.svg?branch=master\n   :target: https://github.com/netromdk/vermin/actions\n\n.. |analyze status| image:: https://github.com/netromdk/vermin/workflows/analyze/badge.svg?branch=master\n   :target: https://github.com/netromdk/vermin/actions\n\n.. |codeql status| image:: https://github.com/netromdk/vermin/workflows/codeql/badge.svg?branch=master\n   :target: https://github.com/netromdk/vermin/security/code-scanning\n\n.. |snyk status| image:: https://github.com/netromdk/vermin/workflows/snyk%20schedule/badge.svg?branch=master\n   :target: https://github.com/netromdk/vermin/actions\n\n.. |coverage| image:: https://coveralls.io/repos/github/netromdk/vermin/badge.svg?branch=master\n   :target: https://coveralls.io/github/netromdk/vermin?branch=master\n\n.. |commits since last| image:: https://img.shields.io/github/commits-since/netromdk/vermin/latest.svg\n\n.. |downloads| image:: https://static.pepy.tech/personalized-badge/vermin?period=total&units=international_system&left_color=gray&right_color=blue&left_text=downloads\n   :target: https://pepy.tech/project/vermin\n\n.. |cii best practices| image:: https://bestpractices.coreinfrastructure.org/projects/6451/badge\n   :target: https://bestpractices.coreinfrastructure.org/projects/6451\n\nvermin\n******\n\nconcurrently detect the minimum python versions needed to run code. additionally, since the code is\nvanilla python, and it doesn't have any external dependencies, it can be run with v3+ but still\nincludes detection of v2.x functionality.\n\nit functions by parsing python code into an abstract syntax tree (ast), which it traverses and\nmatches against internal dictionaries with **3796** rules, covering v2.0-2.7 and v3.0-3.12, divided\ninto **178** modules, **2614** classes/functions/constants members of modules, **875** kwargs of\nfunctions, **4** strftime directives, **3** bytes format directives, **2** array typecodes, **3**\ncodecs error handler names, **20** codecs encodings, **78** builtin generic annotation types, **9**\nbuiltin dict union (``|``) types, **8** builtin dict union merge (``|=``) types, and **2** user\nfunction decorators.\n\nbackports of the standard library, like ``typing``, can be enabled for better results. get full list\nof backports via ``--help``.\n\nthe project is fairly well-tested with **4008** unit and integration tests that are executed on\nlinux, macos, and windows.\n\nit is recommended to use the most recent python version to run vermin on projects since python's own\nlanguage parser is used to detect language features, like f-strings since python 3.6 etc.\n\n\ntable of contents\n=================\n\n* `usage <#usage>`__\n* `features <#features>`__\n* `caveats <#caveats>`__\n* `configuration file <#configuration-file>`__\n* `examples <#examples>`__\n* `linting (showing only target versions violations) <#linting-showing-only-target-versions-violations>`__\n* `api (experimental) <#api-experimental>`__\n* `analysis exclusions <#analysis-exclusions>`__\n* `parsable output <#parsable-output>`__\n* `contributing <#contributing>`__\n\nusage\n=====\n\nit is fairly straightforward to use vermin.\n\nrunning it from the repository either directly or through specific interpreter::\n\n  % ./vermin.py /path/to/your/project        # (1) executing via `/usr/bin/env python`\n  % python3 vermin.py /path/to/your/project  # (2) specifically `python3`\n\nor if installed via `pypi <https://pypi.python.org/pypi/vermin/>`__::\n\n  % pip install vermin\n  % vermin /path/to/your/project\n\n`homebrew <https://brew.sh>`__ (`pkg <https://formulae.brew.sh/formula/vermin#default>`__)::\n\n  % brew install vermin\n\n`spack <https://spack.io>`__ (`pkg <https://github.com/spack/spack/blob/develop/var/spack/repos/builtin/packages/py-vermin/package.py>`__)::\n\n  % git clone https://github.com/spack/spack.git\n  % . spack/share/spack/setup-env.sh  # depending on shell\n  % spack install py-vermin\n  % spack load py-vermin\n\n`arch linux (aur) <https://aur.archlinux.org/packages/python-vermin/>`__::\n\n  % yay -s python-vermin\n\nwhen using continuous integration (ci) tools, like `travis ci <https://travis-ci.org/>`_, vermin can\nbe used to check that the minimum required versions didn't change. the following is an excerpt::\n\n  install:\n  - ./setup_virtual_env.sh\n  - pip install vermin\n  script:\n  - vermin -t=2.7 -t=3 project_package otherfile.py\n\nvermin can also be used as a `pre-commit <https://pre-commit.com/>`__ hook:\n\n.. code-block:: yaml\n\n  repos:\n    - repo: https://github.com/netromdk/vermin\n      rev: git_sha_or_tag  # ex: 'e88bda9' or 'v1.3.4'\n      hooks:\n        - id: vermin\n          # specify your target version here, or in a vermin config file as usual:\n          args: ['-t=3.8-', '--violations']\n          # (if your target is specified in a vermin config, you may omit the 'args' entry entirely)\n\nwhen using the hook, a target version must be specified via a vermin config file in your package,\nor via the ``args`` option in your ``.pre-commit-config.yaml`` config. if you're passing the target\nvia ``args``, it's recommended to also include ``--violations`` (shown above).\n\nif you're using the ``vermin-all`` hook, you can specify any target as you usually would. however,\nif you're using the ``vermin`` hook, your target must be in the form of ``x.y-`` (as opposed to\n``x.y``), otherwise you will run into issues when your staged changes meet a minimum version that\nis lower than your target.\n\nsee the `pre-commit docs <https://pre-commit.com/#quick-start>`__ for further general information\non how to get hooks set up on your project.\n\nfeatures\n========\n\nfeatures detected include v2/v3 ``print expr`` and ``print(expr)``, ``long``, f-strings, coroutines\n(``async`` and ``await``), asynchronous generators (``await`` and ``yield`` in same function),\nasynchronous comprehensions, ``await`` in comprehensions, asynchronous ``for``-loops, boolean\nconstants, named expressions, keyword-only parameters, positional-only parameters, ``nonlocal``,\n``yield from``, exception context cause (``raise .. from ..``), ``except*``, ``set`` literals,\n``set`` comprehensions, ``dict`` comprehensions, infix matrix multiplication, ``\"..\".format(..)``,\nimports (``import x``, ``from x import y``, ``from x import *``), function calls wrt. name and\nkwargs, ``strftime`` + ``strptime`` directives used, function and variable annotations (also\n``final`` and ``literal``), ``continue`` in ``finally`` block, modular inverse ``pow()``, array\ntypecodes, codecs error handler names, encodings, ``%`` formatting and directives for bytes and\nbytearray, ``with`` statement, asynchronous ``with`` statement, multiple context expressions in a\n``with`` statement, multiple context expressions in a ``with`` statement grouped with parenthesis,\nunpacking assignment, generalized unpacking, ellipsis literal (``...``) out of slices, dictionary\nunion (``{..}  | {..}``), dictionary union merge (``a = {..}; a |= {..}``), builtin generic type\nannotations (``list[str]``), function decorators, class decorators, relaxed decorators,\n``metaclass`` class keyword, pattern matching with ``match``, union types written as ``x | y``, and\ntype alias statements (``type x = sometype``). it tries to detect and ignore user-defined functions,\nclasses, arguments, and variables with names that clash with library-defined symbols.\n\ncaveats\n=======\n\nfor frequently asked questions, check out the `faq discussions\n<https://github.com/netromdk/vermin/discussions/categories/faq>`__.\n\nself-documenting fstrings detection has been disabled by default because the built-in ast cannot\ndistinguish ``f'{a=}'`` from ``f'a={a}'``, for instance, since it optimizes some information away\n(`#39 <https://github.com/netromdk/vermin/issues/39>`__). and this incorrectly marks some source\ncode as using fstring self-doc when only using general fstring. to enable (unstable) fstring\nself-doc detection, use ``--feature fstring-self-doc``.\n\ndetecting union types (``x | y`` `pep 604 <https://www.python.org/dev/peps/pep-0604/>`__) can be\ntricky because vermin doesn't know all underlying details of constants and types since it parses and\ntraverses the ast. for this reason, heuristics are employed and this can sometimes yield incorrect\nresults (`#103 <https://github.com/netromdk/vermin/issues/103>`__). to enable (unstable) union types\ndetection, use ``--feature union-types``.\n\nfunction and variable annotations aren't evaluated at definition time when ``from __future__ import\nannotations`` is used (`pep 563 <https://www.python.org/dev/peps/pep-0563/>`__). this is why\n``--no-eval-annotations`` is on by default (since v1.1.1, `#66\n<https://github.com/netromdk/vermin/issues/66>`__). if annotations are being evaluated at runtime,\nlike using ``typing.get_type_hints`` or evaluating ``__annotations__`` of an object,\n``--eval-annotations`` should be used for best results.\n\nconfiguration file\n==================\n\nvermin automatically tries to detect a config file, starting in the current working directory where\nit is run, following parent folders until either the root or project boundary files/folders are\nreached. however, if ``--config-file`` is specified, no config is auto-detected and loaded.\n\nconfig file names being looked for: ``vermin.ini``, ``vermin.conf``, ``.vermin``, ``setup.cfg``\n\nproject boundary files/folders: ``.git``, ``.svn``, ``.hg``, ``.bzr``, ``_darcs``, ``.fslckout``,\n``.p4root``, ``.pijul``\n\na sample config file can be found `here <sample.vermin.ini>`__.\n\nnote that vermin config can be in the same ini file as other configs, like the commonly used\n``setup.cfg``:\n\n.. code-block:: ini\n\n  [vermin]\n  verbose = 1\n  processes = 4\n\n  [flake8]\n  ignore = e111,f821\n\nexamples\n========\n\n.. code-block:: console\n\n  % ./vermin.py vermin\n  minimum required versions: 3.0\n  incompatible versions:     2\n\n  % ./vermin.py -t=3.3 vermin\n  minimum required versions: 3.0\n  incompatible versions:     2\n  target versions not met:   3.3\n  % echo $?\n  1\n\n  % ./vermin.py --versions vermin\n  minimum required versions: 3.0\n  incompatible versions:     2\n  version range:             2.0, 2.6, 2.7, 3.0\n\n  % ./vermin.py -v examples\n  detecting python files..\n  analyzing 6 files using 8 processes..\n               /path/to/examples/formatv2.py\n  2.7, 3.2     /path/to/examples/argparse.py\n  2.7, 3.0     /path/to/examples/formatv3.py\n  2.0, 3.0     /path/to/examples/printv3.py\n  !2, 3.4      /path/to/examples/abc.py\n               /path/to/examples/unknown.py\n  minimum required versions:   3.4\n  incompatible versions:         2\n\n  % ./vermin.py -vv /path/to/examples/abc.py\n  detecting python files..\n  analyzing using 8 processes..\n  !2, 3.4      /path/to/examples/abc.py\n    'abc' requires 2.6, 3.0\n    'abc.abc' requires !2, 3.4\n\n  minimum required versions: 3.4\n  incompatible versions:     2\n\n  % ./vermin.py -vvv /path/to/examples/abc.py\n  detecting python files..\n  analyzing using 8 processes..\n  !2, 3.4      /path/to/examples/abc.py\n    l1 c7: 'abc' requires 2.6, 3.0\n    l2: 'abc.abc' requires !2, 3.4\n\n  minimum required versions: 3.4\n  incompatible versions:     2\n\n  % ./vermin.py -f parsable /path/to/examples/abc.py\n  /path/to/examples/abc.py:1:7:2.6:3.0:'abc' module\n  /path/to/examples/abc.py:2::!2:3.4:'abc.abc' member\n  /path/to/examples/abc.py:::!2:3.4:\n  :::!2:3.4:\n\nsee `parsable output <#parsable-output>`__ for more information about parsable output format.\n\nlinting: showing only target versions violations\n================================================\n\nvermin shows lots of useful minimum version results when run normally, but it can also be used as a\nlinter to show only rules violating specified target versions by using ``--violations`` (or\n``--lint``) and one or two ``--target`` values. verbosity level 2 is automatically set when showing\nonly violations, but can be increased if necessary. the final versions verdict is still calculated\nand printed at the end and the program exit code signifies whether the specified targets were met\n(``0``) or violated (``1``). however, if no rules are triggered the exit code will be ``0`` due to\ninconclusivity.\n\n.. code-block:: console\n\n  % cat test.py\n  import argparse  # 2.7, 3.2\n  all()            # 2.5, 3.0\n  enumerate()      # 2.3, 3.0\n\n  % ./vermin.py -t=2.4- -t=3 --violations test.py ; echo $?\n  detecting python files..\n  analyzing using 8 processes..\n  2.7, 3.2     test.py\n    'all' member requires 2.5, 3.0\n    'argparse' module requires 2.7, 3.2\n\n  minimum required versions: 2.7, 3.2\n  target versions not met:   2.4-, 3.0\n  1\n\nthe two first lines violate the targets but the third line matches and is therefore not shown.\n\napi (experimental)\n==================\n\ninformation such as minimum versions, used functionality constructs etc. can also be accessed\nprogrammatically via the ``vermin`` python module, though it's an experimental feature. it is still\nrecommended to use the command-line interface.\n\n.. code-block:: python\n\n  >>> import vermin as v\n  >>> v.version_strings(v.detect(\"a = long(1)\"))\n  '2.0, !3'\n\n  >>> config = v.config()\n  >>> config.add_exclusion(\"long\")\n  >>> v.version_strings(v.detect(\"a = long(1)\", config))\n  '~2, ~3'\n\n  >>> config.set_verbose(3)\n  >>> v = v.visit(\"\"\"from argparse import argumentparser\n  ... ap = argumentparser(allow_abbrev=true)\n  ... \"\"\", config)\n  >>> print(v.output_text(), end=\"\")\n  l1 c5: 'argparse' module requires 2.7, 3.2\n  l2: 'argparse.argumentparser(allow_abbrev)' requires !2, 3.5\n  >>> v.version_strings(v.minimum_versions())\n  '!2, 3.5'\n\nanalysis exclusions\n===================\n\nanalysis exclusion can be necessary in certain cases. the argument ``--exclude <name>`` (multiple\ncan be specified) can be used to exclude modules, members, kwargs, codecs error handler names, or\ncodecs encodings by name from being analysed via . consider the following code block that checks if\n``protocol_tls`` is an attribute of ``ssl``:\n\n.. code-block:: python\n\n  import ssl\n  tls_version = ssl.protocol_tlsv1\n  if hasattr(ssl, \"protocol_tls\"):\n    tls_version = ssl.protocol_tls\n\nit will state that \"'ssl.protocol_tls' requires 2.7, 3.6\" but to exclude that from the results, use\n``--exclude 'ssl.protocol_tls'``. afterwards, only \"'ssl' requires 2.6, 3.0\" will be shown and the\nfinal minimum required versions are v2.6 and v3.0 instead of v2.7 and v3.6.\n\ncode can even be excluded on a more fine grained level using the ``# novermin`` or ``# novm``\ncomments at line level. the following yields the same behavior as the previous code block, but only\nfor that particular ``if`` and its body:\n\n.. code-block:: python\n\n  import ssl\n  tls_version = ssl.protocol_tlsv1\n  if hasattr(ssl, \"protocol_tls\"):  # novermin\n    tls_version = ssl.protocol_tls\n\nin scenarios where multiple tools are employed that use comments for various features, exclusions\ncan be defined by having ``#`` for each comment \"segment\":\n\n.. code-block:: python\n\n  if hasattr(ssl, \"protocol_tls\"):  # noqa # novermin # pylint: disable=no-member\n    tls_version = ssl.protocol_tls\n\nnote that if a code base does not have any occurrences of ``# novermin`` or ``# novm``, speedups up\nto 30-40%+ can be achieved by using the ``--no-parse-comments`` argument or ``parse_comments = no``\nconfig setting.\n\nparsable output\n===============\n\nfor scenarios where the results of vermin output is required, it is recommended to use the parsable\noutput format (``--format parsable``) instead of the default output. with this format enabled, each\nline will be on the form:\n\n.. code-block::\n\n  <file>:<line>:<column>:<py2>:<py3>:<feature>\n\nthe ``<line>`` and ``<column>`` are only shown when the verbosity level is high enough, otherwise\nthey are empty.\n\neach feature detected per processed file will have the ``<feature>`` defined on an individual\nline. the last line of the processed file will have a special line with the corresponding ``<file>``\nand no ``<feature>``, constituting the minimum versions of that file:\n\n.. code-block::\n\n   <file>:::<py2>:<py3>:\n\nthe very last line is the final minimum versions results of the entire scan and therefore has no\n``<file>`` and ``<feature>``:\n\n.. code-block::\n\n   :::<py2>:<py3>:\n\ninspection of example output\n----------------------------\n\n.. code-block:: console\n\n  % ./vermin.py -f parsable /path/to/project\n  /path/to/project/abc.py:1:7:2.6:3.0:'abc' module\n  /path/to/project/abc.py:2::!2:3.4:'abc.abc' member\n  /path/to/project/abc.py:::!2:3.4:\n  /path/to/project/except_star.py:::~2:~3:\n  /path/to/project/annotations.py:::2.0:3.0:print(expr)\n  /path/to/project/annotations.py:1::!2:3.0:annotations\n  /path/to/project/annotations.py:::!2:3.0:\n  :::!2:3.4:\n\n``abc.py`` requires ``!2`` and ``3.4`` via:\n\n.. code-block::\n\n  /path/to/project/abc.py:::!2:3.4:\n\n``except_star.py`` requires ``~2`` and ``~3`` via:\n\n.. code-block::\n\n  /path/to/project/except_star.py:::~2:~3:\n\nand ``annotations.py`` requires ``!2`` and ``3.0`` via:\n\n.. code-block::\n\n  /path/to/project/annotations.py:::!2:3.0:\n\nthat means that the final result is ``!2`` and ``3.4``, which is shown by the last line:\n\n.. code-block::\n\n  :::!2:3.4:\n\ncontributing\n============\n\ncontributions are very welcome, especially adding and updating detection rules of modules,\nfunctions, classes etc. to cover as many python versions as possible. see `contributing.md\n<contributing.md>`__ for more information.\n",
  "docs_url": null,
  "keywords": "version detection analysis ast development",
  "license": "mit",
  "name": "vermin",
  "package_url": "https://pypi.org/project/vermin/",
  "project_url": "https://pypi.org/project/vermin/",
  "project_urls": {
    "Bug Reports": "https://github.com/netromdk/vermin/issues",
    "Homepage": "https://github.com/netromdk/vermin",
    "Source": "https://github.com/netromdk/vermin/"
  },
  "release_url": "https://pypi.org/project/vermin/1.6.0/",
  "requires_dist": [],
  "requires_python": ">=3.0",
  "summary": "concurrently detect the minimum python versions needed to run code",
  "version": "1.6.0",
  "releases": [],
  "developers": [
    "me@mortens.dev",
    "morten_kristensen"
  ],
  "kwds": "commits vermin git version_strings github",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_vermin",
  "homepage": "https://github.com/netromdk/vermin",
  "release_count": 55,
  "dependency_ids": []
}