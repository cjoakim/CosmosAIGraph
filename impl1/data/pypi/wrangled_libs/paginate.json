{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: django",
    "framework :: flask",
    "framework :: pylons",
    "framework :: pyramid",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "what is pagination?\n---------------------\nthis module helps dividing large lists of items into pages. the user is shown one page at a time and\ncan navigate to other pages. imagine you are offering a company phonebook and let the user search\nthe entries. if the search result contains 23 entries but you may want to display no more than 10\nentries at once. the first page contains entries 1-10, the second 11-20 and the third 21-23. see the\ndocumentation of the \"page\" class for more information.\n\nhow do i use this module?\n---------------------------\nthe paginate module contains extensive in-line documentation with examples.\n\nconcerning webhelpers\n-----------------------\nthis is a standalone module. former versions were included in the webhelpers python module as\nwebhelpers.paginate and were tightly coupled with the webhelpers and the pylons web framework. this\nversion aims to be useful independent of any web framework.\n\nsubclassing page()\n------------------\nthis module supports pagination through list-like objects. to paginate though other types of objects\nyou can subclass the paginate.page() class and provide a wrapper class that defines how to access\nelements of that special collection.\n\nyou can find examples in other paginate_* modules like paginate_sqlalchemy. basically you would have\nto provide a class that implements the __init__, __getitem__ and __len__ methods.\n\nit is trivial to make pagination for other datastores like elasticsearch/solr extending the base class.\n\nexample::\n\n    class sqlalchemyormwrapper(object):\n        \"\"\"wrapper class to access elements of a collection.\"\"\"\n        def __init__(self, obj):\n            self.obj = obj\n\n        def __getitem__(self, range):\n            # return a range of objects of an sqlalchemy.orm.query.query object\n            return self.obj[range]\n\n        def __len__(self):\n            # count the number of objects in an sqlalchemy.orm.query.query object\n            return self.obj.count()\n\nthen you can create your own page class that uses the above wrapper class::\n\n    class sqlalchemyormpage(paginate.page):\n        \"\"\"a pagination page that deals with sqlalchemy orm objects.\"\"\"\n        def __init__(self, *args, **kwargs):\n            super(sqlalchemyormpage, self).__init__(*args, wrapper_class=sqlalchemyormwrapper, **kwargs)\n\nas you can see it does not do much. it basically calls paginate.page.__init__ and adds\nwrapper_class=sqlalchemyormwrapper as an argument. the paginate.page instance will use that wrapper\nclass to access the elements.\n\n\ngenerating html come for current page\n-------------------------------------\n\nexample::\n\n    p = paginate.page([], page=15, items_per_page=15, item_count=1010)\n    # item_count is optional, but we pass a dummy empty resultset for this example\n    pattern = '$link_first $link_previous ~4~ $link_next $link_last (page $page our of $page_count - total $item_count)'\n    p.pager(pattern, url='http://foo.com?x=$page', dotdot_attr={'x':5}, link_attr={'y':6}, curpage_attr={'z':77})\n    # *_attr arguments are optional and can be used to attach additional classes/attrs to tags\n\n\nresults in::\n\n    '<a class=\"l\" href=\"url?x=1\">&lt;&lt;</a> <a class=\"l\" href=\"url?x=14\">&lt;</a> <a class=\"l\" href=\"url?x=1\">1</a> <span class=\"d\">..</span> <a class=\"l\" href=\"url?x=11\">11</a> <a class=\"l\" href=\"url?x=12\">12</a> <a class=\"l\" href=\"url?x=13\">13</a> <a class=\"l\" href=\"url?x=14\">14</a> <span class=\"c\">15</span> <a class=\"l\" href=\"url?x=16\">16</a> <a class=\"l\" href=\"url?x=17\">17</a> <a class=\"l\" href=\"url?x=18\">18</a> <a class=\"l\" href=\"url?x=19\">19</a> <span class=\"d\">..</span> <a class=\"l\" href=\"url?x=68\">68</a> <a class=\"l\" href=\"url?x=16\">&gt;</a> <a class=\"l\" href=\"url?x=68\">&gt;&gt;</a> (page 15 our of 68 - total items 1010)'\n\nusing url maker to generate links to specific result ranges\n-----------------------------------------------------------\n\nyou can pass `url_maker` callback to generate the url of other pages, given its numbers.\nmust accept one int parameter and return a uri string.\n\nexample::\n\n    def url_maker(page_number):\n        return str('foo/%s' % page_number)\n    page = paginate.page(range(100), page=1, url_maker=url_maker)\n    eq_(page.pager(), '1 <a href=\"foo/2\">2</a> <a href=\"foo/3\">3</a> .. <a href=\"foo/5\">5</a>')\n\n\n\nalternatively if you will not pass the link builder function, the pager() method can also accept `url` argument that contains url that page links will point to.\nmake sure it contains the string $page which will be replaced by the actual page number.\nmust be given unless a url_maker is specified to __init__, in which case this parameter is ignored.\n\nusing link information for custom paginator templates\n-----------------------------------------------------\n\nif you do not like the default html format produced by paginator you can use link_map() function to generate\na dictionary of links you can use in your own template.\n\nexample::\n\n    p.link_map('$link_first $link_previous ~4~ $link_next $link_last (page $page our of $page_count - total items $item_count)',url='url?x=$page',dotdot_attr={'class':'d'}, link_attr={'class':\"l\"}, curpage_attr={'class':\"c\"})\n\nreturns something like::\n\n    {'current_page': {'attrs': {'class': 'c'}, 'href': 'url?x=15', 'value': 15},\n     'first_page': {'attrs': {'class': 'l'}, 'href': 'url?x=1', 'type': 'first_page', 'value': 1},\n     'last_page': {'attrs': {'class': 'l'}, 'href': 'url?x=68', 'type': 'last_page', 'value': 68},\n     'next_page': {'attrs': {'class': 'l'}, 'href': 'url?x=16', 'type': 'next_page', 'value': 16},\n     'previous_page': {'attrs': {'class': 'l'}, 'href': 'url?x=14', 'type': 'previous_page', 'value': 14},\n     'range_pages': [{'attrs': {'class': 'd'}, 'href': '', 'type': 'span', 'value': '..'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=11', 'type': 'page', 'value': '11'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=12', 'type': 'page', 'value': '12'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=13', 'type': 'page', 'value': '13'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=14', 'type': 'page', 'value': '14'},\n      {'attrs': {'class': 'c'}, 'href': 'url?x=15', 'type': 'current_page', 'value': 15},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=16', 'type': 'page', 'value': '16'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=17', 'type': 'page', 'value': '17'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=18', 'type': 'page', 'value': '18'},\n      {'attrs': {'class': 'l'}, 'href': 'url?x=19', 'type': 'page', 'value': '19'},\n      {'attrs': {'class': 'd'}, 'href': '', 'type': 'span', 'value': '..'}],\n      'radius': 4}\n\n\nusing link_tag callable to generate custom link markup\n------------------------------------------------------\n\nin case you want to generate custom link markup for your project - for example for use with bootstrap,\n`pager()` accepts `link_tag` argument that expects a callable that can be used to easly override the way links are\ngenerated.\n\n\nexample::\n\n    from paginate import page, make_html_tag\n\n    def paginate_link_tag(item):\n        \"\"\"\n        create an a-href tag that points to another page usable in paginate.\n        \"\"\"\n        a_tag = page.default_link_tag(item)\n        if item['type'] == 'current_page':\n            return make_html_tag('li', a_tag, **{'class':'active'})\n        return make_html_tag('li', a_tag)\n\n    paginator.pager(\n    curpage_attr={'class':'current_page'},\n    dotdot_attr={'class':'spacer'},\n    symbol_first='<i class=\"fa fa-chevron-circle-left\"></i>',\n    symbol_last='<i class=\"fa fa-chevron-circle-right\"></i>',\n    symbol_previous='<i class=\"fa fa-chevron-left\"></i>',\n    symbol_next='<i class=\"fa fa-chevron-right\"></i>',\n    link_tag=paginate_link_tag)\n\n\n\nversion 0.5.5 - 2016-11-22\n--------------------------\nchanges:\n- python 2.7/3.4+ compatibility improvements\n\nversion 0.5.4 - 2016-04-25\n--------------------------\nchanges:\n- added radius size config option\n\n\nversion 0.5.3 - 2016-03-09\n--------------------------\nchanges:\n- unocode related fixes\n\nversion 0.5.2 - 2015-08-29\n--------------------------\nchanges:\n- handle the slice prior to handling the length - for better experience with\n  various databases that include item count in results\n- bugfixes\n\nversion 0.5.1 - 2015-10-22\n--------------------------\nchanges:\n- bugfixes\n\n\nversion 0.5.0 - 2015-08-29\n--------------------------\nchanges:\n- link_tag callable can now be passed to generate custom link markup\n- page object now has link_map() method that returns a mapping of information useful for generating\n  custom markup based on paginator data\n\nversion 0.4.0 - 2012-12-06\n--------------------------\npaginate has prior been maintained as webhelpers.paginate in the _webhelpers_ packages.\nthis version is a standalone version that should be useful outside of the webhelpers'\ncontext.\n\nchanges:\n- python 3 compatibility.\n- sqlalchemyobject and sqlalchemyquery collections are not automatically detected any more.\n  instead you can use the respective page class from the paginate_sqlalchemy module also\n  available on pypi.\n- presliced_list parameter no longer supported\n- 'page_nr' and 'current_page' had been deprecated already and are now removed. please use 'page'\n  instead.\n- no automatic url generation. you need to pass a 'url' argument to the page.pager() method\n  containing a $page placeholder where you want the page number to be put in. beware that the url\n  is not quote-escaped any further.\n- the page.pager() does not automatically add css classes any more. if you want the old\n  behavior you need to pass these parameters explicitly:\n  link_attr={'class':'pager_link'}\n  curpage_attr={'class':'pager_curpage'}\n  dotdot_attr={'class':'pager_dotdot'}\n- the partial_param parameter from page.pager() is gone. you should use your own urls for\n  ajax/partial updates in the 'url' parameter.\n- the page_param parameter from page.pager() is also gone as url generation has been severely\n  simplified.\n- the string returned from page.pager() consists of escaped html already. so you need to tell\n  your web framework to use the string verbatim and without further escaping.\n  the parameters symbol_first, symbol_last, symbol_previous and symbol_next use\n  &lt; and &gt; instead of \"<\" and \">\" now.\n- page.__repr__ now returns a brief representation. e.g. <paginate.page: 1 of 1>\n  page.__str__ returns the verbose view you may be used to.\n\nversion 0.3.2 - 2008-01-31\n--------------------------\npublic release on pypi",
  "docs_url": null,
  "keywords": "pagination paginate pages",
  "license": "mit",
  "name": "paginate",
  "package_url": "https://pypi.org/project/paginate/",
  "project_url": "https://pypi.org/project/paginate/",
  "project_urls": {
    "Homepage": "https://github.com/Signum/paginate"
  },
  "release_url": "https://pypi.org/project/paginate/0.5.6/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "divides large result sets into pages for easier browsing",
  "version": "0.5.6",
  "releases": [],
  "developers": [
    "christoph_haas",
    "email@christoph-haas.de"
  ],
  "kwds": "paginator pagination paginate paginate_sqlalchemy paginate_",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_paginate",
  "homepage": "https://github.com/signum/paginate",
  "release_count": 12,
  "dependency_ids": []
}