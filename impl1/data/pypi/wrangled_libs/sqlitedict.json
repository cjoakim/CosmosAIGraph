{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: database :: front-ends"
  ],
  "description": "===================================================\nsqlitedict -- persistent ``dict``, backed by sqlite\n===================================================\n\n|githubactions|_\n|license|_\n\n.. |githubactions| image:: https://github.com/rare-technologies/sqlitedict/actions/workflows/python-package.yml/badge.svg\n.. |downloads| image:: https://img.shields.io/pypi/dm/sqlitedict.svg\n.. |license| image:: https://img.shields.io/pypi/l/sqlitedict.svg\n.. _githubactions: https://github.com/rare-technologies/sqlitedict/actions/workflows/python-package.yml\n.. _downloads: https://pypi.python.org/pypi/sqlitedict\n.. _license: https://pypi.python.org/pypi/sqlitedict\n\na lightweight wrapper around python's sqlite3 database with a simple, pythonic\ndict-like interface and support for multi-thread access:\n\nusage\n=====\n\nwrite\n-----\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>> db = sqlitedict(\"example.sqlite\")\n    >>>\n    >>> db[\"1\"] = {\"name\": \"first item\"}\n    >>> db[\"2\"] = {\"name\": \"second item\"}\n    >>> db[\"3\"] = {\"name\": \"yet another item\"}\n    >>>\n    >>> # commit to save the objects.\n    >>> db.commit()\n    >>>\n    >>> db[\"4\"] = {\"name\": \"yet another item\"}\n    >>> # oops, forgot to commit here, that object will never be saved.\n    >>> # always remember to commit, or enable autocommit with sqlitedict(\"example.sqlite\", autocommit=true)\n    >>> # autocommit is off by default for performance.\n    >>>\n    >>> db.close()\n\nread\n----\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>> db = sqlitedict(\"example.sqlite\")\n    >>>\n    >>> print(\"there are %d items in the database\" % len(db))\n    there are 3 items in the database\n    >>>\n    >>> # standard dict interface. items() values() keys() etc...\n    >>> for key, item in db.items():\n    ...     print(\"%s=%s\" % (key, item))\n    1={'name': 'first item'}\n    2={'name': 'second item'}\n    3={'name': 'yet another item'}\n    >>>\n    >>> db.close()\n\nefficiency\n----------\n\nby default, sqlitedict's exception handling favors verbosity over efficiency.\nit extracts and outputs the outer exception stack to the error logs.\nif you favor efficiency, then initialize the db with outer_stack=false.\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>> db = sqlitedict(\"example.sqlite\", outer_stack=false)  # true is the default\n    >>> db[1]\n    {'name': 'first item'}\n\ncontext manager\n---------------\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>>\n    >>> # the database is automatically closed when leaving the with section.\n    >>> # uncommitted objects are not saved on close. remember to commit!\n    >>>\n    >>> with sqlitedict(\"example.sqlite\") as db:\n    ...     print(\"there are %d items in the database\" % len(db))\n    there are 3 items in the database\n\ntables\n------\n\na database file can store multiple tables.\na default table is used when no table name is specified.\n\nnote: writes are serialized, having multiple tables does not improve performance.\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>>\n    >>> products = sqlitedict(\"example.sqlite\", tablename=\"product\", autocommit=true)\n    >>> manufacturers = sqlitedict(\"example.sqlite\", tablename=\"manufacturer\", autocommit=true)\n    >>>\n    >>> products[\"1\"] = {\"name\": \"first item\",  \"manufacturer_id\": \"1\"}\n    >>> products[\"2\"] = {\"name\": \"second item\", \"manufacturer_id\": \"1\"}\n    >>>\n    >>> manufacturers[\"1\"] = {\"manufacturer_name\": \"afactory\", \"location\": \"us\"}\n    >>> manufacturers[\"2\"] = {\"manufacturer_name\": \"anotherfactory\", \"location\": \"uk\"}\n    >>>\n    >>> tables = products.get_tablenames('example.sqlite')\n    >>> print(tables)\n    ['unnamed', 'product', 'manufacturer']\n    >>>\n    >>> products.close()\n    >>> manufacturers.close()\n\nin case you're wondering, the unnamed table comes from the previous examples,\nwhere we did not specify a table name.\n\nserialization\n-------------\n\nkeys are strings. values are any serializeable object.\n\nby default pickle is used internally to (de)serialize the values.\n\nit's possible to use a custom (de)serializer, notably for json and for compression.\n\n.. code-block:: python\n\n    >>> # use json instead of pickle\n    >>> import json\n    >>> with sqlitedict(\"example.sqlite\", encode=json.dumps, decode=json.loads) as mydict:\n    ...     pass\n    >>>\n    >>> # apply zlib compression after pickling\n    >>> import zlib, pickle, sqlite3\n    >>>\n    >>> def my_encode(obj):\n    ...     return sqlite3.binary(zlib.compress(pickle.dumps(obj, pickle.highest_protocol)))\n    >>>\n    >>> def my_decode(obj):\n    ...     return pickle.loads(zlib.decompress(bytes(obj)))\n    >>>\n    >>> with sqlitedict(\"example.sqlite\", encode=my_encode, decode=my_decode) as mydict:\n    ...     pass\n\nit's also possible to use a custom (de)serializer for keys to allow non-string keys.\n\n.. code-block:: python\n\n    >>> # use key encoding instead of default string keys only\n    >>> from sqlitedict import encode_key, decode_key\n    >>> with sqlitedict(\"example.sqlite\", encode_key=encode_key, decode_key=decode_key) as mydict:\n    ...     pass\n\nmore\n----\n\nfunctions are well documented, see docstrings directly in ``sqlitedict.py`` or call ``help(sqlitedict)``.\n\n**beware**: because of python semantics, ``sqlitedict`` cannot know when a mutable\nsqlitedict-backed entry was modified in ram. you'll need to\nexplicitly assign the mutated object back to sqlitedict:\n\n.. code-block:: python\n\n    >>> from sqlitedict import sqlitedict\n    >>> db = sqlitedict(\"example.sqlite\")\n    >>> db[\"colors\"] = {\"red\": (255, 0, 0)}\n    >>> db.commit()\n    >>>\n    >>> colors = db[\"colors\"]\n    >>> colors[\"blue\"] = (0, 0, 255) # sqlite db not updated here!\n    >>> db[\"colors\"] = colors  # now updated\n    >>>\n    >>> db.commit() # remember to commit (or set autocommit)\n    >>> db.close()\n\nfeatures\n========\n\n* values can be **any picklable objects** (uses ``pickle`` with the highest protocol).\n* support for **multiple tables** (=dicts) living in the same database file.\n* support for **access from multiple threads** to the same connection (needed by e.g. pyro).\n  vanilla sqlite3 gives you ``programmingerror: sqlite objects created in a thread can\n  only be used in that same thread.``\n\n  concurrent requests are still serialized internally, so this \"multithreaded support\"\n  **doesn't** give you any performance benefits. it is a work-around for sqlite limitations in python.\n\n* support for **custom serialization or compression**:\n\n.. code-block:: python\n\n  # use json instead of pickle\n  >>> import json\n  >>> mydict = sqlitedict('./my_db.sqlite', encode=json.dumps, decode=json.loads)\n\n  # apply zlib compression after pickling\n  >>> import zlib, pickle, sqlite3\n  >>> def my_encode(obj):\n  ...     return sqlite3.binary(zlib.compress(pickle.dumps(obj, pickle.highest_protocol)))\n  >>> def my_decode(obj):\n  ...     return pickle.loads(zlib.decompress(bytes(obj)))\n  >>> mydict = sqlitedict('./my_db.sqlite', encode=my_encode, decode=my_decode)\n\n* sqlite is efficient and can work effectively with large databases (multi gigabytes), not limited by memory.\n* sqlitedict is mostly a thin wrapper around sqlite.\n* ``items()`` ``keys()`` ``values()`` are iterating one by one, the rows are loaded in a worker thread and queued in memory.\n* ``len()`` is calling sqlite to count rows, that is scanning the whole table.\n* for better performance, write objects in batch and ``commit()`` once.\n\ninstallation\n============\n\nthe module has no dependencies beyond python itself.\nthe minimum supported python version is 3.7, continuously tested on python 3.7, 3.8, 3.9, and 3.10 `on travis <https://travis-ci.org/rare-technologies/sqlitedict>`_.\n\ninstall or upgrade with::\n\n    pip install -u sqlitedict\n\nor from the `source tar.gz <http://pypi.python.org/pypi/sqlitedict>`_::\n\n    python setup.py install\n\ncontributions\n=============\n\ntesting\n-------\n\ninstall::\n\n    $ pip install pytest coverage pytest-coverage\n\nto perform all tests::\n\n    $ mkdir -p tests/db\n    $ pytest tests\n    $ python -m doctest readme.rst\n\nto perform all tests with coverage::\n\n    $ pytest tests --cov=sqlitedict\n\ncomments, bug reports\n---------------------\n\n``sqlitedict`` resides on `github <https://github.com/rare-technologies/sqlitedict>`_. you can file\nissues or pull requests there.\n\nlicense\n=======\n\n``sqlitedict`` is open source software released under the `apache 2.0 license <http://opensource.org/licenses/apache2.0.php>`_.\ncopyright (c) 2011-now `radim \u0159eh\u016f\u0159ek <http://radimrehurek.com>`_ and contributors.\n\nhousekeeping\n============\n\nclean up the test database to keep each doctest run idempotent:\n\n.. code-block:: python\n\n   >>> import os\n   >>> if __name__ == '__main__':\n   ...     os.unlink('example.sqlite')",
  "docs_url": null,
  "keywords": "sqlite,persistent dict,multithreaded",
  "license": "apache 2.0",
  "name": "sqlitedict",
  "package_url": "https://pypi.org/project/sqlitedict/",
  "project_url": "https://pypi.org/project/sqlitedict/",
  "project_urls": {
    "Download": "http://pypi.python.org/pypi/sqlitedict",
    "Homepage": "https://github.com/piskvorky/sqlitedict"
  },
  "release_url": "https://pypi.org/project/sqlitedict/2.1.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "persistent dict in python, backed up by sqlite3 and pickle, multithread-safe.",
  "version": "2.1.0",
  "releases": [],
  "developers": [
    "me@radimrehurek.com",
    "radim_rehurek"
  ],
  "kwds": "sqlitedict sqlite sqlite3 dicts dict",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_sqlitedict",
  "homepage": "https://github.com/piskvorky/sqlitedict",
  "release_count": 21,
  "dependency_ids": []
}