{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "topic :: software development",
    "topic :: utilities"
  ],
  "description": "pip-requirements-parser - a mostly correct pip requirements parsing library\n================================================================================\n\ncopyright (c) nexb inc. and others.\ncopyright (c) the pip developers (see authors.rst file)\nspdx-license-identifier: mit\nhomepage: https://github.com/nexb/pip-requirements and https://www.aboutcode.org/\n\n\n``pip-requirements-parser`` is a mostly correct pip requirements parsing\nlibrary ... because it uses pip's own code!\n\npip is the ``package installer`` for python that is using \"requirements\" text\nfiles listing the packages to install.\n\nper https://pip.pypa.io/en/stable/reference/requirements-file-format/ :\n\n    \"the requirements file format is closely tied to a number of internal\n    details of pip (e.g., pip\u2019s command line options). the basic format is\n    relatively stable and portable but the full syntax, as described here,\n    is only intended for consumption by pip, and other tools should take\n    that into account before using it for their own purposes.\"\n\nand per https://pip.pypa.io/en/stable/user_guide/#using-pip-from-your-program :\n\n    \"[..] pip is a command line program. while it is implemented in python, and\n    so is available from your python code via import pip, you must not use pip\u2019s\n    internal apis in this way.\"\n    \n    \"what this means in practice is that everything inside of pip is considered\n    an implementation detail. even the fact that the import name is pip is\n    subject to change without notice. while we do try not to break things as\n    much as possible, all the internal apis can change at any time, for any\n    reason. it also means that we generally won\u2019t fix issues that are a result\n    of using pip in an unsupported way.\"\n\n\nbecause of all this, pip requirements are notoriously difficult to parse right\nin all their diversity because:\n\n- pip does not have a public api and therefore cannot be reliably used as a\n  stable library. some libraries attempt to do this though. (see alternative)\n\n- the pip requirements file syntax is closely aligned with pip's command line\n  interface and command line options. in some ways a pip requirements file is a\n  list of pip command line options and arguments. therefore, it is hard to parse\n  these short of reproducing the pip command line options parsing. at least one\n  other library is using a command line option parser to parse options correctly.\n\n\nthis ``pip-requirements-parser`` python library is yet another pip requirements\nfiles parser, but this time doing it hopefully correctly and doing as well as\npip does it, because this is using pip's own code.\n\n\nthe ``pip-requirements-parser`` library offers these key advantages:\n\n- other requirements parsers typically do not work in all the cases that ``pip``\n  supports: parsing any requirement as seen in the wild will fail parsing some\n  valid pip requirements. since the ``pip-requirements-parser`` library is based\n  on pip's own code, it works **exactly** like pip and will parse all the\n  requirements files that pip can parse.\n\n- the ``pip-requirements-parser`` library offers a simple and stable code api\n  that will not change without notice.\n\n- the ``pip-requirements-parser`` library is designed to work offline without\n  making any external network call, while the original pip code needs network\n  access.\n\n- the ``pip-requirements-parser`` library is a single file that can easily be\n  copied around as needed for easy vendoring. this is useful as requirements\n  parsing is often needed to bootstrap in a constrained environment.\n\n- the ``pip-requirements-parser`` library has only one external dependency on\n  the common \"packaging\" package. otherwise it uses only the standard library.\n  the benefits are the same as being a single file: fewer moving parts helps with\n  using it in more cases.\n\n- the ``pip-requirements-parser`` library reuses and passes the full subset of\n  the pip test suite that deals with requirements. this is a not really\n  surprising since this is pip's own code. the suite suite has been carefully\n  ported and adjusted to work with the updated code subset.\n\n- the standard pip requirements parser depends on the ``requests`` http library\n  and makes network connection to pypi and other referenced repositories when\n  parsing. the ``pip-requirements-parser`` library works entirely offline and the\n  requests dependency and calling has been entirely removed.\n\n- the ``pip-requirements-parser`` library has preserved the complete pip git\n  history for the subset of the code we kept. the original pip code was merged\n  from multiple modules keeping all the git history at the line/blame level using\n  some git fu and git filter repo. the benefit is that we will be able to more\n  easily track and merge future pip updates.\n\n- the ``pip-requirements-parser`` library has an extensive test suite  made of:\n\n  - pip's own tests\n  - new unit tests\n  - new requirements test files (over 40 new test files)\n  - the tests suite of some of the main other requirement parsers including:\n\n     - http://github.com/di/pip-api\n     - https://github.com/pyupio/dparse\n     - https://github.com/landscapeio/requirements-detector\n     - https://github.com/madpah/requirements-parser\n\nas a result, it has likely the most comprehensive requiremente parsing test\nsuite around.\n\n\nusage\n~~~~~~~~~~\n\nthe entry point is the ``requirementsfile`` object::\n\n    >>> from pip_requirements_parser import requirementsfile\n    >>> rf = requirementsfile.from_file(\"requirements.txt\")\n\nfrom there, you can dump to a dict::\n    >>> rf.to_dict()\n\nor access the requirements (either installrequirement or editablerequirement\nobjects)::\n\n    >>> for req in rf.requirements:\n    ...    print(req.to_dict())\n    ...    print(req.dumps())\n\nand the various other parsed elements such as options, commenst and invalid lines\nthat have a parsing error::\n\n    >>> rf.options\n    >>> rf.comment_lines\n    >>> rf.invalid_lines\n\neach of these and the ``requirements`` hahve a \"requirement_line\" attribute\nwith the original text.\n\nfinally you can get a requirements file back as a string::\n\n    >>> rf.dumps()\n\n\nalternative\n------------------\n\nthere are several other parsers that either:\n\n- implement their own parsing and can therefore miss some subtle differences\n- or wrap and import pip as a library, working around the lack of pip api\n\nnone of these use the approach of reusing and forking the subset of pip that is\nneeded to parse requirements.  the ones that wrap pip require network access\nlike pip does. they potentially need updating each time there is a new pip\nrelease. the ones that reimplement pip parsing may not support all pip\nspecifics.\n\n\nimplement a new pip parser\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- pip-api https://github.com/di/pip-api does not support hashes and certain pip options.\n  it does however use argparse for parsing options and is therefore correctly\n  handling most options. the parser is a single script that only depends on\n  packaging (that is vendored). it is not designed to be used as a single script\n  though and ``pip`` is a dependency.\n\n- requirements-parser https://github.com/madpah/requirements-parse does not\n  support hashes and certain pip options\n\n- dparse https://github.com/pyupio/dparse\n\n- https://github.com/googlecloudplatform/django-cloud-deploy/blob/d316b1e45357761e2b124143e6e12ce34ef6f975/django_cloud_deploy/skeleton/requirements_parser.py\n\n\nreuse and wrap pip's own parser\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n- requirementslib https://github.com/sarugaku/requirementslib uses pip-shim\n  https://github.com/sarugaku/pip-shims which is a set of \"shims\" around each\n  pip versions in an attempt to offer an api to pip. comes with 20+ dependencies,\n\n- micropipenv https://github.com/thoth-station/micropipenv/blob/d0c37c1bf0aadf5149aebe2df0bf1cb12ded4c40/micropipenv.py#l53\n\n- pip-tools https://github.com/jazzband/pip-tools/blob/9e1be05375104c56e07cdb0904e1b50b86f8b550/piptools/_compat/pip_compat.py\n",
  "docs_url": null,
  "keywords": "utilities pip requirements parser dependencies pypi",
  "license": "mit",
  "name": "pip-requirements-parser",
  "package_url": "https://pypi.org/project/pip-requirements-parser/",
  "project_url": "https://pypi.org/project/pip-requirements-parser/",
  "project_urls": {
    "Homepage": "https://github.com/nexB/pip-requirements-parser"
  },
  "release_url": "https://pypi.org/project/pip-requirements-parser/32.0.1/",
  "requires_dist": [
    "packaging",
    "pyparsing",
    "Sphinx (>=3.3.1) ; extra == 'docs'",
    "sphinx-rtd-theme (>=0.5.0) ; extra == 'docs'",
    "doc8 (>=0.8.1) ; extra == 'docs'",
    "pytest (!=7.0.0,>=6) ; extra == 'testing'",
    "pytest-xdist (>=2) ; extra == 'testing'",
    "aboutcode-toolkit (>=6.0.0) ; extra == 'testing'",
    "black ; extra == 'testing'"
  ],
  "requires_python": ">=3.6.0",
  "summary": "pip requirements parser - a mostly correct pip requirements parsing library because it uses pip's own code.",
  "version": "32.0.1",
  "releases": [],
  "developers": [
    "info@aboutcode.org",
    "the_pip_authors"
  ],
  "kwds": "pip_requirements_parser requirements_parser requirementslib pip_compat pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pip_requirements_parser",
  "homepage": "https://github.com/nexb/pip-requirements-parser",
  "release_count": 6,
  "dependency_ids": [
    "pypi_aboutcode_toolkit",
    "pypi_black",
    "pypi_doc8",
    "pypi_packaging",
    "pypi_pyparsing",
    "pypi_pytest",
    "pypi_pytest_xdist",
    "pypi_sphinx",
    "pypi_sphinx_rtd_theme"
  ]
}