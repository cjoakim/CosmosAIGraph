{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon api gateway construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\namazon api gateway is a fully managed service that makes it easy for developers\nto publish, maintain, monitor, and secure apis at any scale. create an api to\naccess data, business logic, or functionality from your back-end services, such\nas applications running on amazon elastic compute cloud (amazon ec2), code\nrunning on aws lambda, or any web application.\n\n## table of contents\n\n* [defining apis](#defining-apis)\n\n  * [breaking up methods and resources across stacks](#breaking-up-methods-and-resources-across-stacks)\n* [aws lambda-backed apis](#aws-lambda-backed-apis)\n* [aws stepfunctions backed apis](#aws-stepfunctions-backed-apis)\n* [integration targets](#integration-targets)\n* [usage plan & api keys](#usage-plan--api-keys)\n* [working with models](#working-with-models)\n* [default integration and method options](#default-integration-and-method-options)\n* [proxy routes](#proxy-routes)\n* [authorizers](#authorizers)\n\n  * [iam-based authorizer](#iam-based-authorizer)\n  * [lambda-based token authorizer](#lambda-based-token-authorizer)\n  * [lambda-based request authorizer](#lambda-based-request-authorizer)\n  * [cognito user pools authorizer](#cognito-user-pools-authorizer)\n* [mutual tls](#mutal-tls-mtls)\n* [deployments](#deployments)\n\n  * [deep dive: invalidation of deployments](#deep-dive-invalidation-of-deployments)\n* [custom domains](#custom-domains)\n* [access logging](#access-logging)\n* [cross origin resource sharing (cors)](#cross-origin-resource-sharing-cors)\n* [endpoint configuration](#endpoint-configuration)\n* [private integrations](#private-integrations)\n* [gateway response](#gateway-response)\n* [openapi definition](#openapi-definition)\n\n  * [endpoint configuration](#endpoint-configuration)\n* [metrics](#metrics)\n* [apigateway v2](#apigateway-v2)\n\n## defining apis\n\napis are defined as a hierarchy of resources and methods. `addresource` and\n`addmethod` can be used to build this hierarchy. the root resource is\n`api.root`.\n\nfor example, the following code defines an api that includes the following http\nendpoints: `any /`, `get /books`, `post /books`, `get /books/{book_id}`, `delete /books/{book_id}`.\n\n```python\napi = apigateway.restapi(self, \"books-api\")\n\napi.root.add_method(\"any\")\n\nbooks = api.root.add_resource(\"books\")\nbooks.add_method(\"get\")\nbooks.add_method(\"post\")\n\nbook = books.add_resource(\"{book_id}\")\nbook.add_method(\"get\")\nbook.add_method(\"delete\")\n```\n\n## aws lambda-backed apis\n\na very common practice is to use amazon api gateway with aws lambda as the\nbackend integration. the `lambdarestapi` construct makes it easy:\n\nthe following code defines a rest api that routes all requests to the\nspecified aws lambda function:\n\n```python\n# backend: lambda.function\n\napigateway.lambdarestapi(self, \"myapi\",\n    handler=backend\n)\n```\n\nyou can also supply `proxy: false`, in which case you will have to explicitly\ndefine the api model:\n\n```python\n# backend: lambda.function\n\napi = apigateway.lambdarestapi(self, \"myapi\",\n    handler=backend,\n    proxy=false\n)\n\nitems = api.root.add_resource(\"items\")\nitems.add_method(\"get\") # get /items\nitems.add_method(\"post\") # post /items\n\nitem = items.add_resource(\"{item}\")\nitem.add_method(\"get\") # get /items/{item}\n\n# the default integration for methods is \"handler\", but one can\n# customize this behavior per method or even a sub path.\nitem.add_method(\"delete\", apigateway.httpintegration(\"http://amazon.com\"))\n```\n\n## aws stepfunctions backed apis\n\nyou can use amazon api gateway with aws step functions as the backend integration, specifically synchronous express workflows.\n\nthe `stepfunctionsrestapi` only supports integration with synchronous express state machine. the `stepfunctionsrestapi` construct makes this easy by setting up input, output and error mapping.\n\nthe construct sets up an api endpoint and maps the `any` http method and any calls to the api endpoint starts an express workflow execution for the underlying state machine.\n\ninvoking the endpoint with any http method (`get`, `post`, `put`, `delete`, ...) in the example below will send the request to the state machine as a new execution. on success, an http code `200` is returned with the execution output as the response body.\n\nif the execution fails, an http `500` response is returned with the `error` and `cause` from the execution output as the response body. if the request is invalid (ex. bad execution input) http code `400` is returned.\n\nthe response from the invocation contains only the `output` field from the\n[startsyncexecution](https://docs.aws.amazon.com/step-functions/latest/apireference/api_startsyncexecution.html#api_startsyncexecution_responsesyntax) api.\nin case of failures, the fields `error` and `cause` are returned as part of the response.\nother metadata such as billing details, aws account id and resource arns are not returned in the api response.\n\nby default, a `prod` stage is provisioned.\n\nin order to reduce the payload size sent to aws step functions, `headers` are not forwarded to the step functions execution input. it is possible to choose whether `headers`,  `requestcontext`, `path`, `querystring`, and `authorizer` are included or not. by default, `headers` are excluded in all requests.\n\nmore details about aws step functions payload limit can be found at https://docs.aws.amazon.com/step-functions/latest/dg/limits-overview.html#service-limits-task-executions.\n\nthe following code defines a rest api that routes all requests to the specified aws stepfunctions state machine:\n\n```python\nstate_machine_definition = stepfunctions.pass(self, \"passstate\")\n\nstate_machine = stepfunctions.statemachine(self, \"statemachine\",\n    definition=state_machine_definition,\n    state_machine_type=stepfunctions.statemachinetype.express\n)\n\napigateway.stepfunctionsrestapi(self, \"stepfunctionsrestapi\",\n    deploy=true,\n    state_machine=state_machine\n)\n```\n\nwhen the rest api endpoint configuration above is invoked using post, as follows -\n\n```bash\ncurl -x post -d '{ \"customerid\": 1 }' https://example.com/\n```\n\naws step functions will receive the request body in its input as follows:\n\n```json\n{\n  \"body\": {\n    \"customerid\": 1\n  },\n  \"path\": \"/\",\n  \"querystring\": {}\n}\n```\n\nwhen the endpoint is invoked at path '/users/5' using the http get method as below:\n\n```bash\ncurl -x get https://example.com/users/5?foo=bar\n```\n\naws step functions will receive the following execution input:\n\n```json\n{\n  \"body\": {},\n  \"path\": {\n     \"users\": \"5\"\n  },\n  \"querystring\": {\n    \"foo\": \"bar\"\n  }\n}\n```\n\nadditional information around the request such as the request context, authorizer context, and headers can be included as part of the input\nforwarded to the state machine. the following example enables headers to be included in the input but not query string.\n\n```python\napigateway.stepfunctionsrestapi(self, \"stepfunctionsrestapi\",\n    state_machine=machine,\n    headers=true,\n    path=false,\n    querystring=false,\n    authorizer=false,\n    request_context=apigateway.requestcontext(\n        caller=true,\n        user=true\n    )\n)\n```\n\nin such a case, when the endpoint is invoked as below:\n\n```bash\ncurl -x get https://example.com/\n```\n\naws step functions will receive the following execution input:\n\n```json\n{\n  \"headers\": {\n    \"accept\": \"...\",\n    \"cloudfront-forwarded-proto\": \"...\",\n  },\n  \"requestcontext\": {\n     \"accountid\": \"...\",\n     \"apikey\": \"...\",\n  },\n  \"body\": {}\n}\n```\n\n### breaking up methods and resources across stacks\n\nit is fairly common for rest apis with a large number of resources and methods to hit the [cloudformation\nlimit](https://docs.aws.amazon.com/awscloudformation/latest/userguide/cloudformation-limits.html) of 500 resources per\nstack.\n\nto help with this, resources and methods for the same rest api can be re-organized across multiple stacks. a common\nway to do this is to have a stack per resource or groups of resources, but this is not the only possible way.\nthe following example uses sets up two resources '/pets' and '/books' in separate stacks using nested stacks:\n\n```python\nfrom aws_cdk.aws_apigateway import integrationresponse, methodresponse, integrationresponse, methodresponse\nfrom aws_cdk.core import app, cfnoutput, nestedstack, nestedstackprops, stack\nfrom constructs import construct\nfrom aws_cdk.aws_apigateway import deployment, method, mockintegration, passthroughbehavior, restapi, stage\n\n#\n# this file showcases how to split up a restapi's resources and methods across nested stacks.\n#\n# the root stack 'rootstack' first defines a restapi.\n# two nested stacks booksstack and petsstack, create corresponding resources '/books' and '/pets'.\n# they are then deployed to a 'prod' stage via a third nested stack - deploystack.\n#\n# to verify this worked, go to the apigateway\n#\n\nclass rootstack(stack):\n    def __init__(self, scope):\n        super().__init__(scope, \"integ-restapi-import-rootstack\")\n\n        rest_api = restapi(self, \"restapi\",\n            deploy=false\n        )\n        rest_api.root.add_method(\"any\")\n\n        pets_stack = petsstack(self,\n            rest_api_id=rest_api.rest_api_id,\n            root_resource_id=rest_api.rest_api_root_resource_id\n        )\n        books_stack = booksstack(self,\n            rest_api_id=rest_api.rest_api_id,\n            root_resource_id=rest_api.rest_api_root_resource_id\n        )\n        deploystack(self,\n            rest_api_id=rest_api.rest_api_id,\n            methods=pets_stack.methods.concat(books_stack.methods)\n        )\n\n        cfnoutput(self, \"petsurl\",\n            value=f\"https://{restapi.restapiid}.execute-api.{this.region}.amazonaws.com/prod/pets\"\n        )\n\n        cfnoutput(self, \"booksurl\",\n            value=f\"https://{restapi.restapiid}.execute-api.{this.region}.amazonaws.com/prod/books\"\n        )\n\nclass petsstack(nestedstack):\n\n    def __init__(self, scope, *, restapiid, rootresourceid, parameters=none, timeout=none, notificationarns=none, removalpolicy=none):\n        super().__init__(scope, \"integ-restapi-import-petsstack\", restapiid=restapiid, rootresourceid=rootresourceid, parameters=parameters, timeout=timeout, notificationarns=notificationarns, removalpolicy=removalpolicy)\n\n        api = restapi.from_rest_api_attributes(self, \"restapi\",\n            rest_api_id=rest_api_id,\n            root_resource_id=root_resource_id\n        )\n\n        method = api.root.add_resource(\"pets\").add_method(\"get\", mockintegration(\n            integration_responses=[integrationresponse(\n                status_code=\"200\"\n            )],\n            passthrough_behavior=passthroughbehavior.never,\n            request_templates={\n                \"application/json\": \"{ \\\"statuscode\\\": 200 }\"\n            }\n        ),\n            method_responses=[methodresponse(status_code=\"200\")]\n        )\n\n        self.methods.push(method)\n\nclass booksstack(nestedstack):\n\n    def __init__(self, scope, *, restapiid, rootresourceid, parameters=none, timeout=none, notificationarns=none, removalpolicy=none):\n        super().__init__(scope, \"integ-restapi-import-booksstack\", restapiid=restapiid, rootresourceid=rootresourceid, parameters=parameters, timeout=timeout, notificationarns=notificationarns, removalpolicy=removalpolicy)\n\n        api = restapi.from_rest_api_attributes(self, \"restapi\",\n            rest_api_id=rest_api_id,\n            root_resource_id=root_resource_id\n        )\n\n        method = api.root.add_resource(\"books\").add_method(\"get\", mockintegration(\n            integration_responses=[integrationresponse(\n                status_code=\"200\"\n            )],\n            passthrough_behavior=passthroughbehavior.never,\n            request_templates={\n                \"application/json\": \"{ \\\"statuscode\\\": 200 }\"\n            }\n        ),\n            method_responses=[methodresponse(status_code=\"200\")]\n        )\n\n        self.methods.push(method)\n\nclass deploystack(nestedstack):\n    def __init__(self, scope, *, restapiid, methods=none, parameters=none, timeout=none, notificationarns=none, removalpolicy=none):\n        super().__init__(scope, \"integ-restapi-import-deploystack\", restapiid=restapiid, methods=methods, parameters=parameters, timeout=timeout, notificationarns=notificationarns, removalpolicy=removalpolicy)\n\n        deployment = deployment(self, \"deployment\",\n            api=restapi.from_rest_api_id(self, \"restapi\", rest_api_id)\n        )\n        if methods:\n            for method in methods:\n                deployment.node.add_dependency(method)\n        stage(self, \"stage\", deployment=deployment)\n\nrootstack(app())\n```\n\n## integration targets\n\nmethods are associated with backend integrations, which are invoked when this\nmethod is called. api gateway supports the following integrations:\n\n* `mockintegration` - can be used to test apis. this is the default\n  integration if one is not specified.\n* `lambdaintegration` - can be used to invoke an aws lambda function.\n* `awsintegration` - can be used to invoke arbitrary aws service apis.\n* `httpintegration` - can be used to invoke http endpoints.\n\nthe following example shows how to integrate the `get /book/{book_id}` method to\nan aws lambda function:\n\n```python\n# get_book_handler: lambda.function\n# book: apigateway.resource\n\n\nget_book_integration = apigateway.lambdaintegration(get_book_handler)\nbook.add_method(\"get\", get_book_integration)\n```\n\nintegration options can be optionally be specified:\n\n```python\n# get_book_handler: lambda.function\n# get_book_integration: apigateway.lambdaintegration\n\n\nget_book_integration = apigateway.lambdaintegration(get_book_handler,\n    content_handling=apigateway.contenthandling.convert_to_text,  # convert to base64\n    credentials_passthrough=true\n)\n```\n\nmethod options can optionally be specified when adding methods:\n\n```python\n# book: apigateway.resource\n# get_book_integration: apigateway.lambdaintegration\n\n\nbook.add_method(\"get\", get_book_integration,\n    authorization_type=apigateway.authorizationtype.iam,\n    api_key_required=true\n)\n```\n\nit is possible to also integrate with aws services in a different region. the following code integrates with amazon sqs in the\n`eu-west-1` region.\n\n```python\nget_message_integration = apigateway.awsintegration(\n    service=\"sqs\",\n    path=\"queuename\",\n    region=\"eu-west-1\"\n)\n```\n\n## usage plan & api keys\n\na usage plan specifies who can access one or more deployed api stages and methods, and the rate at which they can be\naccessed. the plan uses api keys to identify api clients and meters access to the associated api stages for each key.\nusage plans also allow configuring throttling limits and quota limits that are enforced on individual client api keys.\n\nthe following example shows how to create and asscociate a usage plan and an api key:\n\n```python\n# integration: apigateway.lambdaintegration\n\n\napi = apigateway.restapi(self, \"hello-api\")\n\nv1 = api.root.add_resource(\"v1\")\necho = v1.add_resource(\"echo\")\necho_method = echo.add_method(\"get\", integration, api_key_required=true)\n\nplan = api.add_usage_plan(\"usageplan\",\n    name=\"easy\",\n    throttle=apigateway.throttlesettings(\n        rate_limit=10,\n        burst_limit=2\n    )\n)\n\nkey = api.add_api_key(\"apikey\")\nplan.add_api_key(key)\n```\n\nto associate a plan to a given restapi stage:\n\n```python\n# plan: apigateway.usageplan\n# api: apigateway.restapi\n# echo_method: apigateway.method\n\n\nplan.add_api_stage(\n    stage=api.deployment_stage,\n    throttle=[apigateway.throttlingpermethod(\n        method=echo_method,\n        throttle=apigateway.throttlesettings(\n            rate_limit=10,\n            burst_limit=2\n        )\n    )\n    ]\n)\n```\n\nexisting usage plans can be imported into a cdk app using its id.\n\n```python\nimported_usage_plan = apigateway.usageplan.from_usage_plan_id(self, \"imported-usage-plan\", \"<usage-plan-key-id>\")\n```\n\nthe name and value of the api key can be specified at creation; if not\nprovided, a name and value will be automatically generated by api gateway.\n\n```python\n# api: apigateway.restapi\n\nkey = api.add_api_key(\"apikey\",\n    api_key_name=\"myapikey1\",\n    value=\"myapikeythatisatleast20characters\"\n)\n```\n\nexisting api keys can also be imported into a cdk app using its id.\n\n```python\nimported_key = apigateway.apikey.from_api_key_id(self, \"imported-key\", \"<api-key-id>\")\n```\n\nthe \"grant\" methods can be used to give prepackaged sets of permissions to other resources. the\nfollowing code provides read permission to an api key.\n\n```python\n# imported_key: apigateway.apikey\n# lambda_fn: lambda.function\n\nimported_key.grant_read(lambda_fn)\n```\n\n### \u26a0\ufe0f multiple api keys\n\nit is possible to specify multiple api keys for a given usage plan, by calling `usageplan.addapikey()`.\n\nwhen using multiple api keys, a past bug of the cdk prevents api key associations to a usage plan to be deleted.\nif the cdk app had the [feature flag](https://docs.aws.amazon.com/cdk/latest/guide/featureflags.html) - `@aws-cdk/aws-apigateway:usageplankeyorderinsensitiveid` - enabled when the api\nkeys were created, then the app will not be affected by this bug.\n\nif this is not the case, you will need to ensure that the cloudformation [logical ids](https://docs.aws.amazon.com/awscloudformation/latest/userguide/resources-section-structure.html) of the api keys that are not\nbeing deleted remain unchanged.\nmake note of the logical ids of these api keys before removing any, and set it as part of the `addapikey()` method:\n\n```python\n# usageplan: apigateway.usageplan\n# api_key: apigateway.apikey\n\n\nusageplan.add_api_key(api_key,\n    override_logical_id=\"...\"\n)\n```\n\n### rate limited api key\n\nin scenarios where you need to create a single api key and configure rate limiting for it, you can use `ratelimitedapikey`.\nthis construct lets you specify rate limiting properties which should be applied only to the api key being created.\nthe api key created has the specified rate limits, such as quota and throttles, applied.\n\nthe following example shows how to use a rate limited api key :\n\n```python\n# api: apigateway.restapi\n\n\nkey = apigateway.ratelimitedapikey(self, \"rate-limited-api-key\",\n    customer_id=\"hello-customer\",\n    resources=[api],\n    quota=apigateway.quotasettings(\n        limit=10000,\n        period=apigateway.period.month\n    )\n)\n```\n\n## working with models\n\nwhen you work with lambda integrations that are not proxy integrations, you\nhave to define your models and mappings for the request, response, and integration.\n\n```python\nhello = lambda_.function(self, \"hello\",\n    runtime=lambda_.runtime.nodejs_14_x,\n    handler=\"hello.handler\",\n    code=lambda_.code.from_asset(\"lambda\")\n)\n\napi = apigateway.restapi(self, \"hello-api\")\nresource = api.root.add_resource(\"v1\")\n```\n\nyou can define more parameters on the integration to tune the behavior of api gateway\n\n```python\n# hello: lambda.function\n\n\nintegration = apigateway.lambdaintegration(hello,\n    proxy=false,\n    request_parameters={\n        # you can define mapping parameters from your method to your integration\n        # - destination parameters (the key) are the integration parameters (used in mappings)\n        # - source parameters (the value) are the source request parameters or expressions\n        # @see: https://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html\n        \"integration.request.querystring.who\": \"method.request.querystring.who\"\n    },\n    allow_test_invoke=true,\n    request_templates={\n        # you can define a mapping that will build a payload for your integration, based\n        #  on the integration parameters that you have specified\n        # check: https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html\n        \"application/json\": json.stringify({\"action\": \"sayhello\", \"poll_id\": \"$util.escapejavascript($input.params('who'))\"})\n    },\n    # this parameter defines the behavior of the engine is no suitable response template is found\n    passthrough_behavior=apigateway.passthroughbehavior.never,\n    integration_responses=[apigateway.integrationresponse(\n        # successful response from the lambda function, no filter defined\n        #  - the selectionpattern filter only tests the error message\n        # we will set the response status code to 200\n        status_code=\"200\",\n        response_templates={\n            # this template takes the \"message\" result from the lambda function, and embeds it in a json response\n            # check https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html\n            \"application/json\": json.stringify({\"state\": \"ok\", \"greeting\": \"$util.escapejavascript($input.body)\"})\n        },\n        response_parameters={\n            # we can map response parameters\n            # - destination parameters (the key) are the response parameters (used in mappings)\n            # - source parameters (the value) are the integration response parameters or expressions\n            \"method.response.header.content-type\": \"'application/json'\",\n            \"method.response.header.access-control-allow-origin\": \"'*'\",\n            \"method.response.header.access-control-allow-credentials\": \"'true'\"\n        }\n    ), apigateway.integrationresponse(\n        # for errors, we check if the error message is not empty, get the error data\n        selection_pattern=\"(\\n|.)+\",\n        # we will set the response status code to 200\n        status_code=\"400\",\n        response_templates={\n            \"application/json\": json.stringify({\"state\": \"error\", \"message\": \"$util.escapejavascript($input.path('$.errormessage'))\"})\n        },\n        response_parameters={\n            \"method.response.header.content-type\": \"'application/json'\",\n            \"method.response.header.access-control-allow-origin\": \"'*'\",\n            \"method.response.header.access-control-allow-credentials\": \"'true'\"\n        }\n    )\n    ]\n)\n```\n\nyou can define models for your responses (and requests)\n\n```python\n# api: apigateway.restapi\n\n\n# we define the json schema for the transformed valid response\nresponse_model = api.add_model(\"responsemodel\",\n    content_type=\"application/json\",\n    model_name=\"responsemodel\",\n    schema=apigateway.jsonschema(\n        schema=apigateway.jsonschemaversion.draft4,\n        title=\"pollresponse\",\n        type=apigateway.jsonschematype.object,\n        properties={\n            \"state\": apigateway.jsonschema(type=apigateway.jsonschematype.string),\n            \"greeting\": apigateway.jsonschema(type=apigateway.jsonschematype.string)\n        }\n    )\n)\n\n# we define the json schema for the transformed error response\nerror_response_model = api.add_model(\"errorresponsemodel\",\n    content_type=\"application/json\",\n    model_name=\"errorresponsemodel\",\n    schema=apigateway.jsonschema(\n        schema=apigateway.jsonschemaversion.draft4,\n        title=\"errorresponse\",\n        type=apigateway.jsonschematype.object,\n        properties={\n            \"state\": apigateway.jsonschema(type=apigateway.jsonschematype.string),\n            \"message\": apigateway.jsonschema(type=apigateway.jsonschematype.string)\n        }\n    )\n)\n```\n\nand reference all on your method definition.\n\n```python\n# integration: apigateway.lambdaintegration\n# resource: apigateway.resource\n# response_model: apigateway.model\n# error_response_model: apigateway.model\n\n\nresource.add_method(\"get\", integration,\n    # we can mark the parameters as required\n    request_parameters={\n        \"method.request.querystring.who\": true\n    },\n    # we can set request validator options like below\n    request_validator_options=apigateway.requestvalidatoroptions(\n        request_validator_name=\"test-validator\",\n        validate_request_body=true,\n        validate_request_parameters=false\n    ),\n    method_responses=[apigateway.methodresponse(\n        # successful response from the integration\n        status_code=\"200\",\n        # define what parameters are allowed or not\n        response_parameters={\n            \"method.response.header.content-type\": true,\n            \"method.response.header.access-control-allow-origin\": true,\n            \"method.response.header.access-control-allow-credentials\": true\n        },\n        # validate the schema on the response\n        response_models={\n            \"application/json\": response_model\n        }\n    ), apigateway.methodresponse(\n        # same thing for the error responses\n        status_code=\"400\",\n        response_parameters={\n            \"method.response.header.content-type\": true,\n            \"method.response.header.access-control-allow-origin\": true,\n            \"method.response.header.access-control-allow-credentials\": true\n        },\n        response_models={\n            \"application/json\": error_response_model\n        }\n    )\n    ]\n)\n```\n\nspecifying `requestvalidatoroptions` automatically creates the requestvalidator construct with the given options.\nhowever, if you have your requestvalidator already initialized or imported, use the `requestvalidator` option instead.\n\n## default integration and method options\n\nthe `defaultintegration` and `defaultmethodoptions` properties can be used to\nconfigure a default integration at any resource level. these options will be\nused when defining method under this resource (recursively) with undefined\nintegration or options.\n\n> if not defined, the default integration is `mockintegration`. see reference\n> documentation for default method options.\n\nthe following example defines the `booksbackend` integration as a default\nintegration. this means that all api methods that do not explicitly define an\nintegration will be routed to this aws lambda function.\n\n```python\n# books_backend: apigateway.lambdaintegration\n\napi = apigateway.restapi(self, \"books\",\n    default_integration=books_backend\n)\n\nbooks = api.root.add_resource(\"books\")\nbooks.add_method(\"get\") # integrated with `booksbackend`\nbooks.add_method(\"post\") # integrated with `booksbackend`\n\nbook = books.add_resource(\"{book_id}\")\nbook.add_method(\"get\")\n```\n\na method can be configured with authorization scopes. authorization scopes are\nused in conjunction with an [authorizer that uses amazon cognito user\npools](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html#apigateway-enable-cognito-user-pool).\nread more about authorization scopes\n[here](https://docs.aws.amazon.com/awscloudformation/latest/userguide/aws-resource-apigateway-method.html#cfn-apigateway-method-authorizationscopes).\n\nauthorization scopes for a method can be configured using the `authorizationscopes` property as shown below -\n\n```python\n# books: apigateway.resource\n\n\nbooks.add_method(\"get\", apigateway.httpintegration(\"http://amazon.com\"),\n    authorization_type=apigateway.authorizationtype.cognito,\n    authorization_scopes=[\"scope1\", \"scope2\"]\n)\n```\n\n## proxy routes\n\nthe `addproxy` method can be used to install a greedy `{proxy+}` resource\non a path. by default, this also installs an `\"any\"` method:\n\n```python\n# resource: apigateway.resource\n# handler: lambda.function\n\nproxy = resource.add_proxy(\n    default_integration=apigateway.lambdaintegration(handler),\n\n    # \"false\" will require explicitly adding methods on the `proxy` resource\n    any_method=true\n)\n```\n\n## authorizers\n\napi gateway [supports several different authorization types](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-to-api.html)\nthat can be used for controlling access to your rest apis.\n\n### iam-based authorizer\n\nthe following cdk code provides 'execute-api' permission to an iam user, via iam policies, for the 'get' method on the `books` resource:\n\n```python\n# books: apigateway.resource\n# iam_user: iam.user\n\n\nget_books = books.add_method(\"get\", apigateway.httpintegration(\"http://amazon.com\"),\n    authorization_type=apigateway.authorizationtype.iam\n)\n\niam_user.attach_inline_policy(iam.policy(self, \"allowbooks\",\n    statements=[\n        iam.policystatement(\n            actions=[\"execute-api:invoke\"],\n            effect=iam.effect.allow,\n            resources=[get_books.method_arn]\n        )\n    ]\n))\n```\n\n### lambda-based token authorizer\n\napi gateway also allows [lambda functions to be used as authorizers](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html).\n\nthis module provides support for token-based lambda authorizers. when a client makes a request to an api's methods configured with such\nan authorizer, api gateway calls the lambda authorizer, which takes the caller's identity as input and returns an iam policy as output.\na token-based lambda authorizer (also called a token authorizer) receives the caller's identity in a bearer token, such as\na json web token (jwt) or an oauth token.\n\napi gateway interacts with the authorizer lambda function handler by passing input and expecting the output in a specific format.\nthe event object that the handler is called with contains the `authorizationtoken` and the `methodarn` from the request to the\napi gateway endpoint. the handler is expected to return the `principalid` (i.e. the client identifier) and a `policydocument` stating\nwhat the client is authorizer to perform.\nsee [here](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html) for a detailed specification on\ninputs and outputs of the lambda handler.\n\nthe following code attaches a token-based lambda authorizer to the 'get' method of the book resource:\n\n```python\n# auth_fn: lambda.function\n# books: apigateway.resource\n\n\nauth = apigateway.tokenauthorizer(self, \"booksauthorizer\",\n    handler=auth_fn\n)\n\nbooks.add_method(\"get\", apigateway.httpintegration(\"http://amazon.com\"),\n    authorizer=auth\n)\n```\n\na full working example is shown below.\n\n!cdk-integ pragma:ignore-assets\n\n```python\nfrom aws_cdk.aws_apigateway import integrationresponse, methodresponse\nimport path as path\nimport aws_cdk.aws_lambda as lambda_\nfrom aws_cdk.core import app, stack\nfrom aws_cdk.aws_apigateway import mockintegration, passthroughbehavior, restapi, tokenauthorizer\n\n#\n# stack verification steps:\n# * `curl -s -o /dev/null -w \"%{http_code}\" <url>` should return 401\n# * `curl -s -o /dev/null -w \"%{http_code}\" -h 'authorization: deny' <url>` should return 403\n# * `curl -s -o /dev/null -w \"%{http_code}\" -h 'authorization: allow' <url>` should return 200\n#\n\napp = app()\nstack = stack(app, \"tokenauthorizerinteg\")\n\nauthorizer_fn = lambda_.function(stack, \"myauthorizerfunction\",\n    runtime=lambda_.runtime.nodejs_14_x,\n    handler=\"index.handler\",\n    code=lambda_.assetcode.from_asset(path.join(__dirname, \"integ.token-authorizer.handler\"))\n)\n\nrestapi = restapi(stack, \"myrestapi\")\n\nauthorizer = tokenauthorizer(stack, \"myauthorizer\",\n    handler=authorizer_fn\n)\n\nrestapi.root.add_method(\"any\", mockintegration(\n    integration_responses=[integrationresponse(status_code=\"200\")\n    ],\n    passthrough_behavior=passthroughbehavior.never,\n    request_templates={\n        \"application/json\": \"{ \\\"statuscode\\\": 200 }\"\n    }\n),\n    method_responses=[methodresponse(status_code=\"200\")\n    ],\n    authorizer=authorizer\n)\n```\n\nby default, the `tokenauthorizer` looks for the authorization token in the request header with the key 'authorization'. this can,\nhowever, be modified by changing the `identitysource` property.\n\nauthorizers can also be passed via the `defaultmethodoptions` property within the `restapi` construct or the `method` construct. unless\nexplicitly overridden, the specified defaults will be applied across all `method`s across the `restapi` or across all `resource`s,\ndepending on where the defaults were specified.\n\n### lambda-based request authorizer\n\nthis module provides support for request-based lambda authorizers. when a client makes a request to an api's methods configured with such\nan authorizer, api gateway calls the lambda authorizer, which takes specified parts of the request, known as identity sources,\nas input and returns an iam policy as output. a request-based lambda authorizer (also called a request authorizer) receives\nthe identity sources in a series of values pulled from the request, from the headers, stage variables, query strings, and the context.\n\napi gateway interacts with the authorizer lambda function handler by passing input and expecting the output in a specific format.\nthe event object that the handler is called with contains the body of the request and the `methodarn` from the request to the\napi gateway endpoint. the handler is expected to return the `principalid` (i.e. the client identifier) and a `policydocument` stating\nwhat the client is authorizer to perform.\nsee [here](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html) for a detailed specification on\ninputs and outputs of the lambda handler.\n\nthe following code attaches a request-based lambda authorizer to the 'get' method of the book resource:\n\n```python\n# auth_fn: lambda.function\n# books: apigateway.resource\n\n\nauth = apigateway.requestauthorizer(self, \"booksauthorizer\",\n    handler=auth_fn,\n    identity_sources=[apigateway.identitysource.header(\"authorization\")]\n)\n\nbooks.add_method(\"get\", apigateway.httpintegration(\"http://amazon.com\"),\n    authorizer=auth\n)\n```\n\na full working example is shown below.\n\n!cdk-integ pragma:ignore-assets\n\n```python\nfrom aws_cdk.aws_apigateway import integrationresponse, methodresponse\nimport path as path\nimport aws_cdk.aws_lambda as lambda_\nfrom aws_cdk.core import app, stack\nfrom aws_cdk.aws_apigateway import mockintegration, passthroughbehavior, restapi\nfrom aws_cdk.aws_apigateway import requestauthorizer\nfrom aws_cdk.aws_apigateway import identitysource\n\n# against the restapi endpoint from the stack output, run\n# `curl -s -o /dev/null -w \"%{http_code}\" <url>` should return 401\n# `curl -s -o /dev/null -w \"%{http_code}\" -h 'authorization: deny' <url>?allow=yes` should return 403\n# `curl -s -o /dev/null -w \"%{http_code}\" -h 'authorization: allow' <url>?allow=yes` should return 200\n\napp = app()\nstack = stack(app, \"requestauthorizerinteg\")\n\nauthorizer_fn = lambda_.function(stack, \"myauthorizerfunction\",\n    runtime=lambda_.runtime.nodejs_14_x,\n    handler=\"index.handler\",\n    code=lambda_.assetcode.from_asset(path.join(__dirname, \"integ.request-authorizer.handler\"))\n)\n\nrestapi = restapi(stack, \"myrestapi\")\n\nauthorizer = requestauthorizer(stack, \"myauthorizer\",\n    handler=authorizer_fn,\n    identity_sources=[identitysource.header(\"authorization\"), identitysource.query_string(\"allow\")]\n)\n\nrestapi.root.add_method(\"any\", mockintegration(\n    integration_responses=[integrationresponse(status_code=\"200\")\n    ],\n    passthrough_behavior=passthroughbehavior.never,\n    request_templates={\n        \"application/json\": \"{ \\\"statuscode\\\": 200 }\"\n    }\n),\n    method_responses=[methodresponse(status_code=\"200\")\n    ],\n    authorizer=authorizer\n)\n```\n\nby default, the `requestauthorizer` does not pass any kind of information from the request. this can,\nhowever, be modified by changing the `identitysource` property, and is required when specifying a value for caching.\n\nauthorizers can also be passed via the `defaultmethodoptions` property within the `restapi` construct or the `method` construct. unless\nexplicitly overridden, the specified defaults will be applied across all `method`s across the `restapi` or across all `resource`s,\ndepending on where the defaults were specified.\n\n### cognito user pools authorizer\n\napi gateway also allows [amazon cognito user pools as authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)\n\nthe following snippet configures a cognito user pool as an authorizer:\n\n```python\n# books: apigateway.resource\nuser_pool = cognito.userpool(self, \"userpool\")\n\nauth = apigateway.cognitouserpoolsauthorizer(self, \"booksauthorizer\",\n    cognito_user_pools=[user_pool]\n)\nbooks.add_method(\"get\", apigateway.httpintegration(\"http://amazon.com\"),\n    authorizer=auth,\n    authorization_type=apigateway.authorizationtype.cognito\n)\n```\n\n## mutual tls (mtls)\n\nmutual tls can be configured to limit access to your api based by using client certificates instead of (or as an extension of) using authorization headers.\n\n```python\n# acm: any\n\n\napigateway.domainname(self, \"domain-name\",\n    domain_name=\"example.com\",\n    certificate=acm.certificate.from_certificate_arn(self, \"cert\", \"arn:aws:acm:us-east-1:1111111:certificate/11-3336f1-44483d-adc7-9cd375c5169d\"),\n    mtls=apigateway.mtlsconfig(\n        bucket=s3.bucket(self, \"bucket\"),\n        key=\"truststore.pem\",\n        version=\"version\"\n    )\n)\n```\n\ninstructions for configuring your trust store can be found [here](https://aws.amazon.com/blogs/compute/introducing-mutual-tls-authentication-for-amazon-api-gateway/).\n\n## deployments\n\nby default, the `restapi` construct will automatically create an api gateway\n[deployment](https://docs.aws.amazon.com/apigateway/api-reference/resource/deployment/) and a \"prod\" [stage](https://docs.aws.amazon.com/apigateway/api-reference/resource/stage/) which represent the api configuration you\ndefined in your cdk app. this means that when you deploy your app, your api will\nbe have open access from the internet via the stage url.\n\nthe url of your api can be obtained from the attribute `restapi.url`, and is\nalso exported as an `output` from your stack, so it's printed when you `cdk deploy` your app:\n\n```console\n$ cdk deploy\n...\nbooks.booksapiendpointe230e8d5 = https://6lyktd4lpk.execute-api.us-east-1.amazonaws.com/prod/\n```\n\nto disable this behavior, you can set `{ deploy: false }` when creating your\napi. this means that the api will not be deployed and a stage will not be\ncreated for it. you will need to manually define a `apigateway.deployment` and\n`apigateway.stage` resources.\n\nuse the `deployoptions` property to customize the deployment options of your\napi.\n\nthe following example will configure api gateway to emit logs and data traces to\naws cloudwatch for all api calls:\n\n> by default, an iam role will be created and associated with api gateway to\n> allow it to write logs and metrics to aws cloudwatch unless `cloudwatchrole` is\n> set to `false`.\n\n```python\napi = apigateway.restapi(self, \"books\",\n    deploy_options=apigateway.stageoptions(\n        logging_level=apigateway.methodlogginglevel.info,\n        data_trace_enabled=true\n    )\n)\n```\n\n### deep dive: invalidation of deployments\n\napi gateway deployments are an immutable snapshot of the api. this means that we\nwant to automatically create a new deployment resource every time the api model\ndefined in our cdk app changes.\n\nin order to achieve that, the aws cloudformation logical id of the\n`aws::apigateway::deployment` resource is dynamically calculated by hashing the\napi configuration (resources, methods). this means that when the configuration\nchanges (i.e. a resource or method are added, configuration is changed), a new\nlogical id will be assigned to the deployment resource. this will cause\ncloudformation to create a new deployment resource.\n\nby default, old deployments are *deleted*. you can set `retaindeployments: true`\nto allow users revert the stage to an old deployment manually.\n\n## custom domains\n\nto associate an api with a custom domain, use the `domainname` configuration when\nyou define your api:\n\n```python\n# acm_certificate_for_example_com: any\n\n\napi = apigateway.restapi(self, \"mydomain\",\n    domain_name=apigateway.domainnameoptions(\n        domain_name=\"example.com\",\n        certificate=acm_certificate_for_example_com\n    )\n)\n```\n\nthis will define a `domainname` resource for you, along with a `basepathmapping`\nfrom the root of the domain to the deployment stage of the api. this is a common\nset up.\n\nto route domain traffic to an api gateway api, use amazon route 53 to create an\nalias record. an alias record is a route 53 extension to dns. it's similar to a\ncname record, but you can create an alias record both for the root domain, such\nas `example.com`, and for subdomains, such as `www.example.com`. (you can create\ncname records only for subdomains.)\n\n```python\nimport aws_cdk.aws_route53 as route53\nimport aws_cdk.aws_route53_targets as targets\n\n# api: apigateway.restapi\n# hosted_zone_for_example_com: any\n\n\nroute53.arecord(self, \"customdomainaliasrecord\",\n    zone=hosted_zone_for_example_com,\n    target=route53.recordtarget.from_alias(targets.apigateway(api))\n)\n```\n\nyou can also define a `domainname` resource directly in order to customize the default behavior:\n\n```python\n# acm_certificate_for_example_com: any\n\n\napigateway.domainname(self, \"custom-domain\",\n    domain_name=\"example.com\",\n    certificate=acm_certificate_for_example_com,\n    endpoint_type=apigateway.endpointtype.edge,  # default is regional\n    security_policy=apigateway.securitypolicy.tls_1_2\n)\n```\n\nonce you have a domain, you can map base paths of the domain to apis.\nthe following example will map the url [https://example.com/go-to-api1](https://example.com/go-to-api1)\nto the `api1` api and [https://example.com/boom](https://example.com/boom) to the `api2` api.\n\n```python\n# domain: apigateway.domainname\n# api1: apigateway.restapi\n# api2: apigateway.restapi\n\n\ndomain.add_base_path_mapping(api1, base_path=\"go-to-api1\")\ndomain.add_base_path_mapping(api2, base_path=\"boom\")\n```\n\nyou can specify the api `stage` to which this base path url will map to. by default, this will be the\n`deploymentstage` of the `restapi`.\n\n```python\n# domain: apigateway.domainname\n# restapi: apigateway.restapi\n\n\nbeta_deploy = apigateway.deployment(self, \"beta-deployment\",\n    api=restapi\n)\nbeta_stage = apigateway.stage(self, \"beta-stage\",\n    deployment=beta_deploy\n)\ndomain.add_base_path_mapping(restapi, base_path=\"api/beta\", stage=beta_stage)\n```\n\nif you don't specify `basepath`, all urls under this domain will be mapped\nto the api, and you won't be able to map another api to the same domain:\n\n```python\n# domain: apigateway.domainname\n# api: apigateway.restapi\n\ndomain.add_base_path_mapping(api)\n```\n\nthis can also be achieved through the `mapping` configuration when defining the\ndomain as demonstrated above.\n\nif you wish to setup this domain with an amazon route53 alias, use the `targets.apigatewaydomain`:\n\n```python\n# hosted_zone_for_example_com: any\n# domain_name: apigateway.domainname\n\nimport aws_cdk.aws_route53 as route53\nimport aws_cdk.aws_route53_targets as targets\n\n\nroute53.arecord(self, \"customdomainaliasrecord\",\n    zone=hosted_zone_for_example_com,\n    target=route53.recordtarget.from_alias(targets.apigatewaydomain(domain_name))\n)\n```\n\n## access logging\n\naccess logging creates logs every time an api method is accessed. access logs can have information on\nwho has accessed the api, how the caller accessed the api and what responses were generated.\naccess logs are configured on a stage of the restapi.\naccess logs can be expressed in a format of your choosing, and can contain any access details, with a\nminimum that it must include the 'requestid'. the list of  variables that can be expressed in the access\nlog can be found\n[here](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference).\nread more at [setting up cloudwatch api logging in api\ngateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html)\n\n```python\n# production stage\nprd_log_group = logs.loggroup(self, \"prdlogs\")\napi = apigateway.restapi(self, \"books\",\n    deploy_options=apigateway.stageoptions(\n        access_log_destination=apigateway.loggrouplogdestination(prd_log_group),\n        access_log_format=apigateway.accesslogformat.json_with_standard_fields()\n    )\n)\ndeployment = apigateway.deployment(self, \"deployment\", api=api)\n\n# development stage\ndev_log_group = logs.loggroup(self, \"devlogs\")\napigateway.stage(self, \"dev\",\n    deployment=deployment,\n    access_log_destination=apigateway.loggrouplogdestination(dev_log_group),\n    access_log_format=apigateway.accesslogformat.json_with_standard_fields(\n        caller=false,\n        http_method=true,\n        ip=true,\n        protocol=true,\n        request_time=true,\n        resource_path=true,\n        response_length=true,\n        status=true,\n        user=true\n    )\n)\n```\n\nthe following code will generate the access log in the [clf format](https://en.wikipedia.org/wiki/common_log_format).\n\n```python\nlog_group = logs.loggroup(self, \"apigatewayaccesslogs\")\napi = apigateway.restapi(self, \"books\",\n    deploy_options=apigateway.stageoptions(\n        access_log_destination=apigateway.loggrouplogdestination(log_group),\n        access_log_format=apigateway.accesslogformat.clf()\n    )\n)\n```\n\nyou can also configure your own access log format by using the `accesslogformat.custom()` api.\n`accesslogfield` provides commonly used fields. the following code configures access log to contain.\n\n```python\nlog_group = logs.loggroup(self, \"apigatewayaccesslogs\")\napigateway.restapi(self, \"books\",\n    deploy_options=apigateway.stageoptions(\n        access_log_destination=apigateway.loggrouplogdestination(log_group),\n        access_log_format=apigateway.accesslogformat.custom(f\"{apigateway.accesslogfield.contextrequestid()} {apigateway.accesslogfield.contexterrormessage()} {apigateway.accesslogfield.contexterrormessagestring()}\")\n    )\n)\n```\n\nyou can use the `methodoptions` property to configure\n[default method throttling](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html#apigateway-api-level-throttling-in-usage-plan)\nfor a stage. the following snippet configures the a stage that accepts\n100 requests per minute, allowing burst up to 200 requests per minute.\n\n```python\napi = apigateway.restapi(self, \"books\")\ndeployment = apigateway.deployment(self, \"my-deployment\", api=api)\nstage = apigateway.stage(self, \"my-stage\",\n    deployment=deployment,\n    method_options={\n        \"/*/*\": apigateway.methoddeploymentoptions( # this special path applies to all resource paths and all http methods\n            throttling_rate_limit=100,\n            throttling_burst_limit=200)\n    }\n)\n```\n\nconfiguring `methodoptions` on the `deployoptions` of `restapi` will set the\nthrottling behaviors on the default stage that is automatically created.\n\n```python\napi = apigateway.restapi(self, \"books\",\n    deploy_options=apigateway.stageoptions(\n        method_options={\n            \"/*/*\": apigateway.methoddeploymentoptions( # this special path applies to all resource paths and all http methods\n                throttling_rate_limit=100,\n                throttling_burst_limit=1000)\n        }\n    )\n)\n```\n\n## cross origin resource sharing (cors)\n\n[cross-origin resource sharing (cors)](https://developer.mozilla.org/en-us/docs/web/http/cors) is a mechanism\nthat uses additional http headers to tell browsers to give a web application\nrunning at one origin, access to selected resources from a different origin. a\nweb application executes a cross-origin http request when it requests a resource\nthat has a different origin (domain, protocol, or port) from its own.\n\nyou can add the cors [preflight](https://developer.mozilla.org/en-us/docs/web/http/cors#preflighted_requests) options\nhttp method to any api resource via the `defaultcorspreflightoptions` option or by calling the `addcorspreflight` on a specific resource.\n\nthe following example will enable cors for all methods and all origins on all resources of the api:\n\n```python\napigateway.restapi(self, \"api\",\n    default_cors_preflight_options=apigateway.corsoptions(\n        allow_origins=apigateway.cors.all_origins,\n        allow_methods=apigateway.cors.all_methods\n    )\n)\n```\n\nthe following example will add an options method to the `myresource` api resource, which\nonly allows get and put http requests from the origin [https://amazon.com.](https://amazon.com.)\n\n```python\n# my_resource: apigateway.resource\n\n\nmy_resource.add_cors_preflight(\n    allow_origins=[\"https://amazon.com\"],\n    allow_methods=[\"get\", \"put\"]\n)\n```\n\nsee the\n[`corsoptions`](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-apigateway.corsoptions.html)\napi reference for a detailed list of supported configuration options.\n\nyou can specify defaults this at the resource level, in which case they will be applied to the entire resource sub-tree:\n\n```python\n# resource: apigateway.resource\n\n\nsubtree = resource.add_resource(\"subtree\",\n    default_cors_preflight_options=apigateway.corsoptions(\n        allow_origins=[\"https://amazon.com\"]\n    )\n)\n```\n\nthis means that all resources under `subtree` (inclusive) will have a preflight\noptions added to them.\n\nsee [#906](https://github.com/aws/aws-cdk/issues/906) for a list of cors\nfeatures which are not yet supported.\n\n## endpoint configuration\n\napi gateway allows you to specify an\n[api endpoint type](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-endpoint-types.html).\nto define an endpoint type for the api gateway, use `endpointconfiguration` property:\n\n```python\napi = apigateway.restapi(self, \"api\",\n    endpoint_configuration=apigateway.endpointconfiguration(\n        types=[apigateway.endpointtype.edge]\n    )\n)\n```\n\nyou can also create an association between your rest api and a vpc endpoint. by doing so,\napi gateway will generate a new\nroute53 alias dns record which you can use to invoke your private apis. more info can be found\n[here](https://docs.aws.amazon.com/apigateway/latest/developerguide/associate-private-api-with-vpc-endpoint.html).\n\nhere is an example:\n\n```python\n# some_endpoint: ec2.ivpcendpoint\n\n\napi = apigateway.restapi(self, \"api\",\n    endpoint_configuration=apigateway.endpointconfiguration(\n        types=[apigateway.endpointtype.private],\n        vpc_endpoints=[some_endpoint]\n    )\n)\n```\n\nby performing this association, we can invoke the api gateway using the following format:\n\n```plaintext\nhttps://{rest-api-id}-{vpce-id}.execute-api.{region}.amazonaws.com/{stage}\n```\n\n## private integrations\n\na private integration makes it simple to expose http/https resources behind an\namazon vpc for access by clients outside of the vpc. the private integration uses\nan api gateway resource of `vpclink` to encapsulate connections between api\ngateway and targeted vpc resources.\nthe `vpclink` is then attached to the `integration` of a specific api gateway\nmethod. the following code sets up a private integration with a network load\nbalancer -\n\n```python\nimport aws_cdk.aws_elasticloadbalancingv2 as elbv2\n\n\nvpc = ec2.vpc(self, \"vpc\")\nnlb = elbv2.networkloadbalancer(self, \"nlb\",\n    vpc=vpc\n)\nlink = apigateway.vpclink(self, \"link\",\n    targets=[nlb]\n)\n\nintegration = apigateway.integration(\n    type=apigateway.integrationtype.http_proxy,\n    options=apigateway.integrationoptions(\n        connection_type=apigateway.connectiontype.vpc_link,\n        vpc_link=link\n    )\n)\n```\n\nthe uri for the private integration, in the case of a vpclink, will be set to the dns name of\nthe vpc link's nlb. if the vpc link has multiple nlbs or the vpc link is imported or the dns\nname cannot be determined for any other reason, the user is expected to specify the `uri`\nproperty.\n\nany existing `vpclink` resource can be imported into the cdk app via the `vpclink.fromvpclinkid()`.\n\n```python\nawesome_link = apigateway.vpclink.from_vpc_link_id(self, \"awesome-vpc-link\", \"us-east-1_oiur12abd\")\n```\n\n## gateway response\n\nif the rest api fails to process an incoming request, it returns to the client an error response without forwarding the\nrequest to the integration backend. api gateway has a set of standard response messages that are sent to the client for\neach type of error. these error responses can be configured on the rest api. the list of gateway responses that can be\nconfigured can be found [here](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html).\nlearn more about [gateway\nresponses](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-gatewayresponse-definition.html).\n\nthe following code configures a gateway response when the response is 'access denied':\n\n```python\napi = apigateway.restapi(self, \"books-api\")\napi.add_gateway_response(\"test-response\",\n    type=apigateway.responsetype.access_denied,\n    status_code=\"500\",\n    response_headers={\n        \"access-control-allow-origin\": \"test.com\",\n        \"test-key\": \"test-value\"\n    },\n    templates={\n        \"application/json\": \"{ \\\"message\\\": $context.error.messagestring, \\\"statuscode\\\": \\\"488\\\", \\\"type\\\": \\\"$context.error.responsetype\\\" }\"\n    }\n)\n```\n\n## openapi definition\n\ncdk supports creating a rest api by importing an openapi definition file. it currently supports openapi v2.0 and openapi\nv3.0 definition files. read more about [configuring a rest api using\nopenapi](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-import-api.html).\n\nthe following code creates a rest api using an external openapi definition json file -\n\n```python\n# integration: apigateway.integration\n\n\napi = apigateway.specrestapi(self, \"books-api\",\n    api_definition=apigateway.apidefinition.from_asset(\"path-to-file.json\")\n)\n\nbooks_resource = api.root.add_resource(\"books\")\nbooks_resource.add_method(\"get\", integration)\n```\n\nit is possible to use the `addresource()` api to define additional api gateway resources.\n\n**note:** deployment will fail if a resource of the same name is already defined in the open api specification.\n\n**note:** any default properties configured, such as `defaultintegration`, `defaultmethodoptions`, etc. will only be\napplied to resources and methods defined in the cdk, and not the ones defined in the spec. use the [api gateway\nextensions to openapi](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html)\nto configure these.\n\nthere are a number of limitations in using openapi definitions in api gateway. read the [amazon api gateway important\nnotes for rest apis](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-known-issues.html#api-gateway-known-issues-rest-apis)\nfor more details.\n\n**note:** when starting off with an openapi definition using `specrestapi`, it is not possible to configure some\nproperties that can be configured directly in the openapi specification file. this is to prevent people duplication\nof these properties and potential confusion.\n\n### endpoint configuration\n\nby default, `specrestapi` will create an edge optimized endpoint.\n\nthis can be modified as shown below:\n\n```python\n# api_definition: apigateway.apidefinition\n\n\napi = apigateway.specrestapi(self, \"examplerestapi\",\n    api_definition=api_definition,\n    endpoint_types=[apigateway.endpointtype.private]\n)\n```\n\n**note:** for private endpoints you will still need to provide the\n[`x-amazon-apigateway-policy`](https://docs.aws.amazon.com/apigateway/latest/developerguide/openapi-extensions-policy.html) and\n[`x-amazon-apigateway-endpoint-configuration`](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions-endpoint-configuration.html)\nin your openapi file.\n\n## metrics\n\nthe api gateway service sends metrics around the performance of rest apis to amazon cloudwatch.\nthese metrics can be referred to using the metric apis available on the `restapi` construct.\nthe apis with the `metric` prefix can be used to get reference to specific metrics for this api. for example,\nthe method below refers to the client side errors metric for this api.\n\n```python\napi = apigateway.restapi(self, \"my-api\")\nclient_error_metric = api.metric_client_error()\n```\n\n## apigateway v2\n\napigateway v2 apis are now moved to its own package named `aws-apigatewayv2`. for backwards compatibility, existing\napigateway v2 \"cfn resources\" (such as `cfnapi`) that were previously exported as part of this package, are still\nexported from here and have been marked deprecated. however, updates to these cloudformation resources, such as new\nproperties and new resource types will not be available.\n\nmove to using `aws-apigatewayv2` to get the latest apis and updates.\n\n---\n\n\nthis module is part of the [aws cloud development kit](https://github.com/aws/aws-cdk) project.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-apigateway",
  "package_url": "https://pypi.org/project/aws-cdk.aws-apigateway/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-apigateway/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-apigateway/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-certificatemanager (==1.204.0)",
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-cognito (==1.204.0)",
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-elasticloadbalancingv2 (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-lambda (==1.204.0)",
    "aws-cdk.aws-logs (==1.204.0)",
    "aws-cdk.aws-s3-assets (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.aws-stepfunctions (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.cx-api (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::apigateway",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk cdk_aws aws_apigateway aws_lambda aws",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_apigateway",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_certificatemanager",
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_cognito",
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_elasticloadbalancingv2",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_lambda",
    "pypi_aws_cdk.aws_logs",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.aws_s3_assets",
    "pypi_aws_cdk.aws_stepfunctions",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.cx_api",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}