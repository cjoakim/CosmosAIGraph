{
  "classifiers": [
    "development status :: 6 - mature",
    "environment :: web environment",
    "framework :: zope :: 2",
    "framework :: zope :: 4",
    "framework :: zope :: 5",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "environmental acquisiton\n========================\n\nthis package implements \"environmental acquisiton\" for python, as\nproposed in the oopsla96_ paper by joseph gil and david h. lorenz:\n\n    we propose a new programming paradigm, environmental acquisition in\n    the context of object aggregation, in which objects acquire\n    behaviour from their current containers at runtime. the key idea is\n    that the behaviour of a component may depend upon its enclosing\n    composite(s). in particular, we propose a form of feature sharing in\n    which an object \"inherits\" features from the classes of objects in\n    its environment.  by examining the declaration of classes, it is\n    possible to determine which kinds of classes may contain a\n    component, and which components must be contained in a given kind of\n    composite. these relationships are the basis for language constructs\n    that supports acquisition.\n\n.. _oopsla96: http://www.cs.virginia.edu/~lorenz/papers/oopsla96/>`_:\n\n.. contents::\n\nintroductory example\n--------------------\n\nzope implements acquisition with \"extension class\" mix-in classes. to\nuse acquisition your classes must inherit from an acquisition base\nclass. for example::\n\n  >>> import extensionclass, acquisition\n\n  >>> class c(extensionclass.base):\n  ...     color = 'red'\n\n  >>> class a(acquisition.implicit):\n  ...     def report(self):\n  ...         print(self.color)\n  ...\n  >>> a = a()\n  >>> c = c()\n  >>> c.a = a\n\n  >>> c.a.report()\n  red\n\n  >>> d = c()\n  >>> d.color = 'green'\n  >>> d.a = a\n\n  >>> d.a.report()\n  green\n\n  >>> try:\n  ...     a.report()\n  ... except attributeerror:\n  ...     pass\n  ... else:\n  ...     raise assertionerror('attributeerror not raised.')\n\nthe class ``a`` inherits acquisition behavior from\n``acquisition.implicit``. the object, ``a``, \"has\" the color of\nobjects ``c`` and d when it is accessed through them, but it has no\ncolor by itself. the object ``a`` obtains attributes from its\nenvironment, where its environment is defined by the access path used\nto reach ``a``.\n\nacquisition wrappers\n--------------------\n\nwhen an object that supports acquisition is accessed through an\nextension class instance, a special object, called an acquisition\nwrapper, is returned. in the example above, the expression ``c.a``\nreturns an acquisition wrapper that contains references to both ``c``\nand ``a``. it is this wrapper that performs attribute lookup in ``c``\nwhen an attribute cannot be found in ``a``.\n\nacquisition wrappers provide access to the wrapped objects through the\nattributes ``aq_parent``, ``aq_self``, ``aq_base``.  continue the\nexample from above::\n\n  >>> c.a.aq_parent is c\n  true\n  >>> c.a.aq_self is a\n  true\n\nexplicit and implicit acquisition\n---------------------------------\n\ntwo styles of acquisition are supported: implicit and explicit\nacquisition.\n\nimplicit acquisition\n--------------------\n\nimplicit acquisition is so named because it searches for attributes\nfrom the environment automatically whenever an attribute cannot be\nobtained directly from an object or through inheritance.\n\nan attribute can be implicitly acquired if its name does not begin\nwith an underscore.\n\nto support implicit acquisition, your class should inherit from the\nmix-in class ``acquisition.implicit``.\n\nexplicit acquisition\n--------------------\n\nwhen explicit acquisition is used, attributes are not automatically\nobtained from the environment. instead, the method aq_acquire must be\nused. for example::\n\n  >>> print(c.a.aq_acquire('color'))\n  red\n\nto support explicit acquisition, your class should inherit from the\nmix-in class ``acquisition.explicit``.\n\ncontrolling acquisition\n-----------------------\n\na class (or instance) can provide attribute by attribute control over\nacquisition. you should subclass from ``acquisition.explicit``, and set\nall attributes that should be acquired to the special value\n``acquisition.acquired``. setting an attribute to this value also allows\ninherited attributes to be overridden with acquired ones. for example::\n\n  >>> class c(acquisition.explicit):\n  ...     id = 1\n  ...     secret = 2\n  ...     color = acquisition.acquired\n  ...     __roles__ = acquisition.acquired\n\nthe only attributes that are automatically acquired from containing\nobjects are color, and ``__roles__``. note that the ``__roles__``\nattribute is acquired even though its name begins with an\nunderscore. in fact, the special ``acquisition.acquired`` value can be\nused in ``acquisition.implicit`` objects to implicitly acquire\nselected objects that smell like private objects.\n\nsometimes, you want to dynamically make an implicitly acquiring object\nacquire explicitly. you can do this by getting the object's\naq_explicit attribute. this attribute provides the object with an\nexplicit wrapper that replaces the original implicit wrapper.\n\nfiltered acquisition\n--------------------\n\nthe acquisition method, ``aq_acquire``, accepts two optional\narguments. the first of the additional arguments is a \"filtering\"\nfunction that is used when considering whether to acquire an\nobject. the second of the additional arguments is an object that is\npassed as extra data when calling the filtering function and which\ndefaults to ``none``. the filter function is called with five\narguments:\n\n* the object that the aq_acquire method was called on,\n\n* the object where an object was found,\n\n* the name of the object, as passed to aq_acquire,\n\n* the object found, and\n\n* the extra data passed to aq_acquire.\n\nif the filter returns a true object that the object found is returned,\notherwise, the acquisition search continues.\n\nhere's an example::\n\n  >>> from acquisition import explicit\n\n  >>> class handyfortesting(object):\n  ...     def __init__(self, name):\n  ...         self.name = name\n  ...     def __str__(self):\n  ...         return \"%s(%s)\" % (self.name, self.__class__.__name__)\n  ...     __repr__=__str__\n  ...\n  >>> class e(explicit, handyfortesting): pass\n  ...\n  >>> class nice(handyfortesting):\n  ...     isnice = 1\n  ...     def __str__(self):\n  ...         return handyfortesting.__str__(self)+' and i am nice!'\n  ...     __repr__ = __str__\n  ...\n  >>> a = e('a')\n  >>> a.b = e('b')\n  >>> a.b.c = e('c')\n  >>> a.p = nice('spam')\n  >>> a.b.p = e('p')\n\n  >>> def find_nice(self, ancestor, name, object, extra):\n  ...     return hasattr(object,'isnice') and object.isnice\n\n  >>> print(a.b.c.aq_acquire('p', find_nice))\n  spam(nice) and i am nice!\n\nthe filtered acquisition in the last line skips over the first\nattribute it finds with the name ``p``, because the attribute doesn't\nsatisfy the condition given in the filter.\n\nfiltered acquisition is rarely used in zope.\n\nacquiring from context\n----------------------\n\nnormally acquisition allows objects to acquire data from their\ncontainers. however an object can acquire from objects that aren't its\ncontainers.\n\nmost of the examples we've seen so far show establishing of an\nacquisition context using getattr semantics. for example, ``a.b`` is a\nreference to ``b`` in the context of ``a``.\n\nyou can also manually set acquisition context using the ``__of__``\nmethod. for example::\n\n  >>> from acquisition import implicit\n  >>> class c(implicit): pass\n  ...\n  >>> a = c()\n  >>> b = c()\n  >>> a.color = \"red\"\n  >>> print(b.__of__(a).color)\n  red\n\nin this case, ``a`` does not contain ``b``, but it is put in ``b``'s\ncontext using the ``__of__`` method.\n\nhere's another subtler example that shows how you can construct an\nacquisition context that includes non-container objects::\n\n  >>> from acquisition import implicit\n\n  >>> class c(implicit):\n  ...     def __init__(self, name):\n  ...         self.name = name\n\n  >>> a = c(\"a\")\n  >>> a.b = c(\"b\")\n  >>> a.b.color = \"red\"\n  >>> a.x = c(\"x\")\n\n  >>> print(a.b.x.color)\n  red\n\neven though ``b`` does not contain ``x``, ``x`` can acquire the color\nattribute from ``b``. this works because in this case, ``x`` is accessed\nin the context of ``b`` even though it is not contained by ``b``.\n\nhere acquisition context is defined by the objects used to access\nanother object.\n\ncontainment before context\n--------------------------\n\nif in the example above suppose both a and b have an color attribute::\n\n  >>> a = c(\"a\")\n  >>> a.color = \"green\"\n  >>> a.b = c(\"b\")\n  >>> a.b.color = \"red\"\n  >>> a.x = c(\"x\")\n\n  >>> print(a.b.x.color)\n  green\n\nwhy does ``a.b.x.color`` acquire color from ``a`` and not from ``b``?\nthe answer is that an object acquires from its containers before\nnon-containers in its context.\n\nto see why consider this example in terms of expressions using the\n``__of__`` method::\n\n  a.x -> x.__of__(a)\n\n  a.b -> b.__of__(a)\n\n  a.b.x -> x.__of__(a).__of__(b.__of__(a))\n\nkeep in mind that attribute lookup in a wrapper is done by trying to\nlook up the attribute in the wrapped object first and then in the\nparent object. so in the expressions above proceeds from left to\nright.\n\nthe upshot of these rules is that attributes are looked up by\ncontainment before context.\n\nthis rule holds true also for more complex examples. for example,\n``a.b.c.d.e.f.g.attribute`` would search for attribute in ``g`` and\nall its containers first. (containers are searched in order from the\ninnermost parent to the outermost container.) if the attribute is not\nfound in ``g`` or any of its containers, then the search moves to\n``f`` and all its containers, and so on.\n\nadditional attributes and methods\n---------------------------------\n\nyou can use the special method ``aq_inner`` to access an object\nwrapped only by containment. so in the example above,\n``a.b.x.aq_inner`` is equivalent to ``a.x``.\n\nyou can find out the acquisition context of an object using the\naq_chain method like so:\n\n  >>> [obj.name for obj in a.b.x.aq_chain]\n  ['x', 'b', 'a']\n\nyou can find out if an object is in the containment context of another\nobject using the ``aq_incontextof`` method. for example:\n\n  >>> a.b.aq_incontextof(a)\n  true\n\n.. note: as of this writing the aq_incontextof examples don't work the\n   way they should be working. according to jim, this is because\n   aq_incontextof works by comparing object pointer addresses, which\n   (because they are actually different wrapper objects) doesn't give\n   you the expected results. he acknowledges that this behavior is\n   controversial, and says that there is a collector entry to change\n   it so that you would get the answer you expect in the above. (we\n   just need to get to it).\n\nacquisition module functions\n----------------------------\n\nin addition to using acquisition attributes and methods directly on\nobjects you can use similar functions defined in the ``acquisition``\nmodule. these functions have the advantage that you don't need to\ncheck to make sure that the object has the method or attribute before\ncalling it.\n\n``aq_acquire(object, name [, filter, extra, explicit, default, containment])``\n    acquires an object with the given name.\n\n    this function can be used to explictly acquire when using explicit\n    acquisition and to acquire names that wouldn't normally be\n    acquired.\n\n    the function accepts a number of optional arguments:\n\n    ``filter``\n        a callable filter object that is used to decide if an object\n        should be acquired.\n\n        the filter is called with five arguments:\n\n        * the object that the aq_acquire method was called on,\n\n        * the object where an object was found,\n\n        * the name of the object, as passed to aq_acquire,\n\n        * the object found, and\n\n        * the extra argument passed to aq_acquire.\n\n        if the filter returns a true object that the object found is\n        returned, otherwise, the acquisition search continues.\n\n    ``extra``\n        extra data to be passed as the last argument to the filter.\n\n    ``explicit``\n        a flag (boolean value) indicating whether explicit acquisition\n        should be used. the default value is true. if the flag is\n        true, then acquisition will proceed regardless of whether\n        wrappers encountered in the search of the acquisition\n        hierarchy are explicit or implicit wrappers. if the flag is\n        false, then parents of explicit wrappers are not searched.\n\n        this argument is useful if you want to apply a filter without\n        overriding explicit wrappers.\n\n    ``default``\n        a default value to return if no value can be acquired.\n\n    ``containment``\n        a flag indicating whether the search should be limited to the\n        containment hierarchy.\n\n    in addition, arguments can be provided as keywords.\n\n``aq_base(object)``\n    return the object with all wrapping removed.\n\n``aq_chain(object [, containment])``\n    return a list containing the object and it's acquisition\n    parents. the optional argument, containment, controls whether the\n    containment or access hierarchy is used.\n\n``aq_get(object, name [, default, containment])``\n    acquire an attribute, name. a default value can be provided, as\n    can a flag that limits search to the containment hierarchy.\n\n``aq_inner(object)``\n    return the object with all but the innermost layer of wrapping\n    removed.\n\n``aq_parent(object)``\n    return the acquisition parent of the object or none if the object\n    is unwrapped.\n\n``aq_self(object)``\n    return the object with one layer of wrapping removed, unless the\n    object is unwrapped, in which case the object is returned.\n\nin most cases it is more convenient to use these module functions\ninstead of the acquisition attributes and methods directly.\n\nacquisition and methods\n-----------------------\n\npython methods of objects that support acquisition can use acquired\nattributes. when a python method is called on an object that is\nwrapped by an acquisition wrapper, the wrapper is passed to the method\nas the first argument. this rule also applies to user-defined method\ntypes and to c methods defined in pure mix-in classes.\n\nunfortunately, c methods defined in extension base classes that define\ntheir own data structures, cannot use aquired attributes at this\ntime. this is because wrapper objects do not conform to the data\nstructures expected by these methods. in practice, you will seldom\nfind this a problem.\n\nconclusion\n----------\n\nacquisition provides a powerful way to dynamically share information\nbetween objects. zope uses acquisition for a number of its key\nfeatures including security, object publishing, and dtml variable\nlookup. acquisition also provides an elegant solution to the problem\nof circular references for many classes of problems. while acquisition\nis powerful, you should take care when using acquisition in your\napplications. the details can get complex, especially with the\ndifferences between acquiring from context and acquiring from\ncontainment.\n\n\nchangelog\n=========\n\n5.1 (2023-10-05)\n----------------\n\n- add support for python 3.12.\n\n\n5.0 (2023-03-24)\n----------------\n\n- build linux binary wheels for python 3.11.\n\n- drop support for python 2.7, 3.5, 3.6.\n\n- add preliminary support for python 3.12a5.\n\n\n4.13 (2022-11-17)\n-----------------\n\n- add support for building arm64 wheels on macos.\n\n\n4.12 (2022-11-03)\n-----------------\n\n- add support for final python 3.11 release.\n\n\n4.11 (2022-09-16)\n-----------------\n\n- add support for python 3.11 (as of 3.11.0rc1).\n\n- switch from ``-ofast`` to ``-o3`` when compiling code for linux wheels.\n  (`#64 <https://github.com/zopefoundation/acquisition/pull/64>`_)\n\n\n4.10 (2021-12-07)\n-----------------\n\n- fix bug in the ``pure_python`` version affecting ``aq_acquire`` applied\n  to a class with a filter.\n\n- improve interface documentation.\n\n- add support for python 3.10.\n\n\n4.9 (2021-08-19)\n----------------\n\n- on cpython no longer omit compiling the c code when ``pure_python`` is\n  required. just evaluate it at runtime.\n  (`#53 <https://github.com/zopefoundation/acquisition/issues/53>`_)\n\n\n4.8 (2021-07-20)\n----------------\n\n- various fixes for the ``pure_python`` version, e.g.\n  make ``acquired`` an ``str`` (as required by ``zope``),\n  avoid infinite ``__cmp__`` loop.\n  (`#51 <https://github.com/zopefoundation/acquisition/issues/51>`_,\n  `#48 <https://github.com/zopefoundation/acquisition/issues/48>`_)\n\n- create aarch64 wheels.\n\n\n4.7 (2020-10-07)\n----------------\n\n- add support for python 3.8 and 3.9.\n\n\n4.6 (2019-04-24)\n----------------\n\n- drop support for python 3.4.\n\n- add support for python 3.8a3.\n\n- add support to call ``bytes()`` on an object wrapped by an\n  ``implicitacquisitionwrapper``.\n  (`#38 <https://github.com/zopefoundation/acquisition/issues/38>`_)\n\n\n4.5 (2018-10-05)\n----------------\n\n- avoid deprecation warnings by using current api.\n\n- add support for python 3.7.\n\n4.4.4 (2017-11-24)\n------------------\n\n- add appveyor configuration to automate building windows eggs.\n\n4.4.3 (2017-11-23)\n------------------\n\n- fix the extremely rare potential for a crash when the c extensions\n  are in use. see `issue 21 <https://github.com/zopefoundation/acquisition/issues/21>`_.\n\n4.4.2 (2017-05-12)\n------------------\n\n- fix c capsule name to fix import errors.\n\n- ensure our dependencies match our expactations about c extensions.\n\n4.4.1 (2017-05-04)\n------------------\n\n- fix c code under python 3.4, with missing py_xsetref.\n\n4.4.0 (2017-05-04)\n------------------\n\n- enable the c extension under python 3.\n\n- drop support for python 3.3.\n\n4.3.0 (2017-01-20)\n------------------\n\n- make tests compatible with extensionclass 4.2.0.\n\n- drop support for python 2.6 and 3.2.\n\n- add support for python 3.5 and 3.6.\n\n4.2.2 (2015-05-19)\n------------------\n\n- make the pure-python acquirer objects cooperatively use the\n  superclass ``__getattribute__`` method, like the c implementation.\n  see https://github.com/zopefoundation/acquisition/issues/7.\n\n- the pure-python implicit acquisition wrapper allows wrapped objects\n  to use ``object.__getattribute__(self, name)``. this differs from\n  the c implementation, but is important for compatibility with the\n  pure-python versions of libraries like ``persistent``. see\n  https://github.com/zopefoundation/acquisition/issues/9.\n\n4.2.1 (2015-04-23)\n------------------\n\n- correct several dangling pointer uses in the c extension,\n  potentially fixing a few interpreter crashes. see\n  https://github.com/zopefoundation/acquisition/issues/5.\n\n4.2 (2015-04-04)\n----------------\n\n- add support for pypy, pypy3, and python 3.2, 3.3, and 3.4.\n\n4.1 (2014-12-18)\n----------------\n\n- bump dependency on ``extensionclass`` to match current release.\n\n4.0.3 (2014-11-02)\n------------------\n\n- skip readme.rst tests when tests are run outside a source checkout.\n\n4.0.2 (2014-11-02)\n------------------\n\n- include ``*.rst`` files in the release.\n\n4.0.1 (2014-10-30)\n------------------\n\n- tolerate unicode attribute names (ascii only).  lp #143358.\n\n- make module-level ``aq_acquire`` api respect the ``default`` parameter.\n  lp #1387363.\n\n- don't raise an attribute error for ``__iter__`` if the fallback to\n  ``__getitem__`` succeeds.  lp #1155760.\n\n\n4.0 (2013-02-24)\n----------------\n\n- added trove classifiers to project metadata.\n\n4.0a1 (2011-12-13)\n------------------\n\n- raise `runtimeerror: recursion detected in acquisition wrapper` if an object\n  with a `__parent__` pointer points to a wrapper that in turn points to the\n  original object.\n\n- prevent wrappers to be created while accessing `__parent__` on types derived\n  from explicit or implicit base classes.\n\n2.13.9 (2015-02-17)\n-------------------\n\n- tolerate unicode attribute names (ascii only).  lp #143358.\n\n- make module-level ``aq_acquire`` api respect the ``default`` parameter.\n  lp #1387363.\n\n- don't raise an attribute error for ``__iter__`` if the fallback to\n  ``__getitem__`` succeeds.  lp #1155760.\n\n2.13.8 (2011-06-11)\n-------------------\n\n- fixed a segfault on 64bit platforms when providing the `explicit` argument to\n  the aq_acquire method of an acquisition wrapper. thx to lp #675064 for the\n  hint to the solution. the code passed an int instead of a pointer into a\n  function.\n\n2.13.7 (2011-03-02)\n-------------------\n\n- fixed bug: when an object did not implement ``__unicode__``, calling\n  ``unicode(wrapped)`` was calling ``__str__`` with an unwrapped ``self``.\n\n2.13.6 (2011-02-19)\n-------------------\n\n- add ``aq_explicit`` to ``iacquisitionwrapper``.\n\n- fixed bug: ``unicode(wrapped)`` was not calling a ``__unicode__``\n  method on wrapped objects.\n\n2.13.5 (2010-09-29)\n-------------------\n\n- fixed unit tests that failed on 64bit python on windows machines.\n\n2.13.4 (2010-08-31)\n-------------------\n\n- lp 623665: fixed typo in acquisition.h.\n\n2.13.3 (2010-04-19)\n-------------------\n\n- use the doctest module from the standard library and no longer depend on\n  zope.testing.\n\n2.13.2 (2010-04-04)\n-------------------\n\n- give both wrapper classes a ``__getnewargs__`` method, which causes the zodb\n  optimization to fail and create persistent references using the ``_p_oid``\n  alone. this happens to be the persistent oid of the wrapped object. this lets\n  these objects to be persisted correctly, even though they are passed to the\n  zodb in a wrapped state.\n\n- added failing tests for http://dev.plone.org/plone/ticket/10318. this shows\n  an edge-case where aq wrappers can be pickled using the specific combination\n  of cpickle, pickle protocol one and a custom pickler class with an\n  ``inst_persistent_id`` hook. unfortunately this is the exact combination used\n  by zodb3.\n\n2.13.1 (2010-02-23)\n-------------------\n\n- update to include extensionclass 2.13.0.\n\n- fix the ``tp_name`` of the implicitacquisitionwrapper and\n  explicitacquisitionwrapper to match their python visible names and thus have\n  a correct ``__name__``.\n\n- expand the ``tp_name`` of our extension types to hold the fully qualified\n  name. this ensures classes have their ``__module__`` set correctly.\n\n2.13.0 (2010-02-14)\n-------------------\n\n- added support for method cache in acquisition. patch contributed by\n  yoshinori k. okuji. see https://bugs.launchpad.net/zope2/+bug/486182.\n\n2.12.4 (2009-10-29)\n-------------------\n\n- fix iteration proxying to pass `self` acquisition-wrapped into both\n  `__iter__` as well as `__getitem__` (this fixes\n  https://bugs.launchpad.net/zope2/+bug/360761).\n\n- add tests for the __getslice__ proxying, including open-ended slicing.\n\n2.12.3 (2009-08-08)\n-------------------\n\n- more 64-bit fixes in py_buildvalue calls.\n\n- more 64-bit issues fixed: use correct integer size for slice operations.\n\n2.12.2 (2009-08-02)\n-------------------\n\n- fixed 64-bit compatibility issues for python 2.5.x / 2.6.x.  see\n  http://www.python.org/dev/peps/pep-0353/ for details.\n\n2.12.1 (2009-04-15)\n-------------------\n\n- update for iteration proxying: the proxy for `__iter__` must not rely on the\n  object to have an `__iter__` itself, but also support fall-back iteration via\n  `__getitem__` (this fixes https://bugs.launchpad.net/zope2/+bug/360761).\n\n2.12 (2009-01-25)\n-----------------\n\n- release as separate package.\n",
  "docs_url": null,
  "keywords": "",
  "license": "zpl 2.1",
  "name": "acquisition",
  "package_url": "https://pypi.org/project/Acquisition/",
  "project_url": "https://pypi.org/project/Acquisition/",
  "project_urls": {
    "Homepage": "https://github.com/zopefoundation/Acquisition"
  },
  "release_url": "https://pypi.org/project/Acquisition/5.1/",
  "requires_dist": [
    "ExtensionClass>=4.2.0",
    "zope.interface",
    "zope.testrunner; extra == \"test\""
  ],
  "requires_python": ">=3.7",
  "summary": "acquisition is a mechanism that allows objects to obtain attributes from the containment hierarchy they're in.",
  "version": "5.1",
  "releases": [],
  "developers": [
    "zope-dev@zope.org",
    "zope_foundation_and_contributors"
  ],
  "kwds": "objects semantics constructs aggregation python",
  "license_kwds": "zpl 2.1",
  "libtype": "pypi",
  "id": "pypi_acquisition",
  "homepage": "https://github.com/zopefoundation/acquisition",
  "release_count": 49,
  "dependency_ids": [
    "pypi_extensionclass",
    "pypi_zope.interface",
    "pypi_zope.testrunner"
  ]
}