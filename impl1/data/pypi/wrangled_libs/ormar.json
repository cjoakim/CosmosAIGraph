{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "framework :: asyncio",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http"
  ],
  "description": "# ormar\n<p>\n<a href=\"https://pypi.org/project/ormar\">\n    <img src=\"https://img.shields.io/pypi/v/ormar.svg\" alt=\"pypi version\">\n</a>\n<a href=\"https://pypi.org/project/ormar\">\n    <img src=\"https://img.shields.io/pypi/pyversions/ormar.svg\" alt=\"pypi version\">\n</a>\n<img src=\"https://github.com/collerek/ormar/workflows/build/badge.svg\" alt=\"build status\">\n<a href=\"https://codecov.io/gh/collerek/ormar\">\n    <img src=\"https://codecov.io/gh/collerek/ormar/branch/master/graph/badge.svg\" alt=\"coverage\">\n</a>\n<a href=\"https://www.codefactor.io/repository/github/collerek/ormar\">\n<img src=\"https://www.codefactor.io/repository/github/collerek/ormar/badge\" alt=\"codefactor\" />\n</a>\n<a href=\"https://codeclimate.com/github/collerek/ormar/maintainability\">\n<img src=\"https://api.codeclimate.com/v1/badges/186bc79245724864a7aa/maintainability\" /></a>\n<a href=\"https://pepy.tech/project/ormar\">\n<img src=\"https://pepy.tech/badge/ormar\"></a>\n</p>\n\n### overview\n\nthe `ormar` package is an async mini orm for python, with support for **postgres,\nmysql**, and **sqlite**.\n\nthe main benefits of using `ormar` are:\n\n*  getting an **async orm that can be used with async frameworks** (fastapi, starlette etc.)\n*  getting just **one model to maintain** - you don't have to maintain pydantic and other orm models (sqlalchemy, peewee, gino etc.)\n\nthe goal was to create a simple orm that can be **used directly (as request and response models) with [`fastapi`][fastapi]** that bases it's data validation on pydantic.\n\normar - apart from the obvious \"orm\" in name - gets its name from _ormar_ in swedish which means _snakes_, and _ormar_ in croatian which means _cabinet_.\n\nand what's a better name for python orm than snakes cabinet :)\n\n**if you like ormar remember to star the repository in [github](https://github.com/collerek/ormar)!**\n\nthe bigger community we build, the easier it will be to catch bugs and attract contributors ;)\n\n### documentation\n\ncheck out the [documentation][documentation] for details.\n\n**note that for brevity most of the documentation snippets omit the creation of the database\nand scheduling the execution of functions for asynchronous run.**\n\nif you want more real life examples than in the documentation you can see the [tests][tests] folder,\nsince they actually have to create and connect to a database in most of the tests.\n\nyet remember that those are - well - tests and not all solutions are suitable to be used in real life applications.\n\n### part of the `fastapi` ecosystem\n\nas part of the fastapi ecosystem `ormar` is supported in libraries that somehow work with databases.\n\nas of now `ormar` is supported by:\n\n*  [`fastapi-users`](https://github.com/frankie567/fastapi-users)\n*  [`fastapi-crudrouter`](https://github.com/awtkns/fastapi-crudrouter)\n*  [`fastapi-pagination`](https://github.com/uriyyo/fastapi-pagination)\n\nif you maintain or use a different library and would like it to support `ormar` let us know how we can help.\n\n### dependencies\n\normar is built with:\n\n* [`sqlalchemy core`][sqlalchemy-core] for query building.\n* [`databases`][databases] for cross-database async support.\n* [`pydantic`][pydantic] for data validation.\n* `typing_extensions` for python 3.6 - 3.7\n\n### license\n\n`ormar` is built as open-sorce software and will remain completely free (mit license).\n\nas i write open-source code to solve everyday problems in my work or to promote and build strong python\ncommunity you can say thank you and buy me a coffee or sponsor me with a monthly amount to help ensure my work remains free and maintained.\n\n<a aria-label=\"sponsor collerek\" href=\"https://github.com/sponsors/collerek\" style=\"text-decoration: none; color: #c9d1d9 !important;\">\n<div style=\"\n    background-color: #21262d;\n    border-color: #30363d;\n    box-shadow:  0 0 transparent, 0 0 transparent;\n    color: #c9d1d9 !important;\n    border: 1px solid;\n    border-radius: 6px;\n    cursor: pointer;\n    display: inline-block;\n    font-size: 14px;\n    padding: 10px;\n    line-height: 0px;\n    height: 40px;\n\">\n<span style=\"color: #c9d1d9 !important;\">sponsor - github sponsors</span>\n</div>\n</a>\n\n### migrating from `sqlalchemy` and existing databases\n\nif you currently use `sqlalchemy` and would like to switch to `ormar` check out the auto-translation\ntool that can help you with translating existing sqlalchemy orm models so you do not have to do it manually.\n\n**beta** versions available at github: [`sqlalchemy-to-ormar`](https://github.com/collerek/sqlalchemy-to-ormar)\nor simply `pip install sqlalchemy-to-ormar`\n\n`sqlalchemy-to-ormar` can be used in pair with `sqlacodegen` to auto-map/ generate `ormar` models from existing database, even if you don't use `sqlalchemy` for your project.\n\n### migrations & database creation\n\nbecause ormar is built on sqlalchemy core, you can use [`alembic`][alembic] to provide\ndatabase migrations (and you really should for production code).\n\nfor tests and basic applications the `sqlalchemy` is more than enough:\n```python\n# note this is just a partial snippet full working example below\n# 1. imports\nimport sqlalchemy\nimport databases\n\n# 2. initialization\ndatabase_url = \"sqlite:///db.sqlite\"\ndatabase = databases.database(database_url)\nmetadata = sqlalchemy.metadata()\n\n# define models here\n\n# 3. database creation and tables creation\nengine = sqlalchemy.create_engine(database_url)\nmetadata.create_all(engine)\n```\n\nfor a sample configuration of alembic and more information regarding migrations and\ndatabase creation visit [migrations][migrations] documentation section.\n\n### package versions\n**ormar is still under development:**\nwe recommend pinning any dependencies (with i.e. `ormar~=0.9.1`)\n\n`ormar` also follows the release numeration that breaking changes bump the major number,\nwhile other changes and fixes bump minor number, so with the latter you should be safe to\nupdate, yet always read the [releases][releases] docs before.\n`example: (0.5.2 -> 0.6.0 - breaking, 0.5.2 -> 0.5.3 - non breaking)`.\n\n### asynchronous python\n\nnote that `ormar` is an asynchronous orm, which means that you have to `await` the calls to\nthe methods, that are scheduled for execution in an event loop. python has a builtin module\n[`asyncio`][asyncio] that allows you to do just that.\n\nnote that most \"normal\" python interpreters do not allow execution of `await`\noutside of a function (because you actually schedule this function for delayed execution\nand don't get the result immediately).\n\nin a modern web framework (like `fastapi`), the framework will handle this for you, but if\nyou plan to do this on your own you need to perform this manually like described in the\nquick start below.\n\n### quick start\n\nnote that you can find the same script in examples folder on github.\n\n```python\nfrom typing import optional\n\nimport databases\nimport pydantic\n\nimport ormar\nimport sqlalchemy\n\ndatabase_url = \"sqlite:///db.sqlite\"\ndatabase = databases.database(database_url)\nmetadata = sqlalchemy.metadata()\n\n\n# note that this step is optional -> all ormar cares is a internal\n# class with name meta and proper parameters, but this way you do not\n# have to repeat the same parameters if you use only one database\nclass basemeta(ormar.modelmeta):\n    metadata = metadata\n    database = database\n\n\n# note that all type hints are optional\n# below is a perfectly valid model declaration\n# class author(ormar.model):\n#     class meta(basemeta):\n#         tablename = \"authors\"\n#\n#     id = ormar.integer(primary_key=true) # <= notice no field types\n#     name = ormar.string(max_length=100)\n\n\nclass author(ormar.model):\n    class meta(basemeta):\n        tablename = \"authors\"\n\n    id: int = ormar.integer(primary_key=true)\n    name: str = ormar.string(max_length=100)\n\n\nclass book(ormar.model):\n    class meta(basemeta):\n        tablename = \"books\"\n\n    id: int = ormar.integer(primary_key=true)\n    author: optional[author] = ormar.foreignkey(author)\n    title: str = ormar.string(max_length=100)\n    year: int = ormar.integer(nullable=true)\n\n\n# create the database\n# note that in production you should use migrations\n# note that this is not required if you connect to existing database\nengine = sqlalchemy.create_engine(database_url)\n# just to be sure we clear the db before\nmetadata.drop_all(engine)\nmetadata.create_all(engine)\n\n\n# all functions below are divided into functionality categories\n# note how all functions are defined with async - hence can use await and needs to\n# be awaited on their own\nasync def create():\n    # create some records to work with through queryset.create method.\n    # note that queryset is exposed on each model's class as objects\n    tolkien = await author.objects.create(name=\"j.r.r. tolkien\")\n    await book.objects.create(author=tolkien, title=\"the hobbit\", year=1937)\n    await book.objects.create(author=tolkien, title=\"the lord of the rings\", year=1955)\n    await book.objects.create(author=tolkien, title=\"the silmarillion\", year=1977)\n\n    # alternative creation of object divided into 2 steps\n    sapkowski = author(name=\"andrzej sapkowski\")\n    # do some stuff\n    await sapkowski.save()\n\n    # or save() after initialization\n    await book(author=sapkowski, title=\"the witcher\", year=1990).save()\n    await book(author=sapkowski, title=\"the tower of fools\", year=2002).save()\n\n    # to read more about inserting data into the database\n    # visit: https://collerek.github.io/ormar/queries/create/\n\n\nasync def read():\n    # fetch an instance, without loading a foreign key relationship on it.\n    # django style\n    book = await book.objects.get(title=\"the hobbit\")\n    # or python style\n    book = await book.objects.get(book.title == \"the hobbit\")\n    book2 = await book.objects.first()\n\n    # first() fetch the instance with lower primary key value\n    assert book == book2\n\n    # you can access all fields on loaded model\n    assert book.title == \"the hobbit\"\n    assert book.year == 1937\n\n    # when no condition is passed to get()\n    # it behaves as last() based on primary key column\n    book3 = await book.objects.get()\n    assert book3.title == \"the tower of fools\"\n\n    # when you have a relation, ormar always defines a related model for you\n    # even when all you loaded is a foreign key value like in this example\n    assert isinstance(book.author, author)\n    # primary key is populated from foreign key stored in books table\n    assert book.author.pk == 1\n    # since the related model was not loaded all other fields are none\n    assert book.author.name is none\n\n    # load the relationship from the database when you already have the related model\n    # alternatively see joins section below\n    await book.author.load()\n    assert book.author.name == \"j.r.r. tolkien\"\n\n    # get all rows for given model\n    authors = await author.objects.all()\n    assert len(authors) == 2\n\n    # to read more about reading data from the database\n    # visit: https://collerek.github.io/ormar/queries/read/\n\n\nasync def update():\n    # read existing row from db\n    tolkien = await author.objects.get(name=\"j.r.r. tolkien\")\n    assert tolkien.name == \"j.r.r. tolkien\"\n    tolkien_id = tolkien.id\n\n    # change the selected property\n    tolkien.name = \"john ronald reuel tolkien\"\n    # call update on a model instance\n    await tolkien.update()\n\n    # confirm that object was updated\n    tolkien = await author.objects.get(name=\"john ronald reuel tolkien\")\n    assert tolkien.name == \"john ronald reuel tolkien\"\n    assert tolkien.id == tolkien_id\n\n    # alternatively update data without loading\n    await author.objects.filter(name__contains=\"tolkien\").update(name=\"j.r.r. tolkien\")\n\n    # to read more about updating data in the database\n    # visit: https://collerek.github.io/ormar/queries/update/\n\n\nasync def delete():\n    silmarillion = await book.objects.get(year=1977)\n    # call delete() on instance\n    await silmarillion.delete()\n\n    # alternatively delete without loading\n    await book.objects.delete(title=\"the tower of fools\")\n\n    # note that when there is no record ormar raises nomatch exception\n    try:\n        await book.objects.get(year=1977)\n    except ormar.nomatch:\n        print(\"no book from 1977!\")\n\n    # to read more about deleting data from the database\n    # visit: https://collerek.github.io/ormar/queries/delete/\n\n    # note that despite the fact that record no longer exists in database\n    # the object above is still accessible and you can use it (and i.e. save()) again.\n    tolkien = silmarillion.author\n    await book.objects.create(author=tolkien, title=\"the silmarillion\", year=1977)\n\n\nasync def joins():\n    # tho join two models use select_related\n\n    # django style\n    book = await book.objects.select_related(\"author\").get(title=\"the hobbit\")\n    # python style\n    book = await book.objects.select_related(book.author).get(\n        book.title == \"the hobbit\"\n    )\n\n    # now the author is already prefetched\n    assert book.author.name == \"j.r.r. tolkien\"\n\n    # by default you also get a second side of the relation\n    # constructed as lowercase source model name +'s' (books in this case)\n    # you can also provide custom name with parameter related_name\n\n    # django style\n    author = await author.objects.select_related(\"books\").all(name=\"j.r.r. tolkien\")\n    # python style\n    author = await author.objects.select_related(author.books).all(\n        author.name == \"j.r.r. tolkien\"\n    )\n    assert len(author[0].books) == 3\n\n    # for reverse and many to many relations you can also prefetch_related\n    # that executes a separate query for each of related models\n\n    # django style\n    author = await author.objects.prefetch_related(\"books\").get(name=\"j.r.r. tolkien\")\n    # python style\n    author = await author.objects.prefetch_related(author.books).get(\n        author.name == \"j.r.r. tolkien\"\n    )\n    assert len(author.books) == 3\n\n    # to read more about relations\n    # visit: https://collerek.github.io/ormar/relations/\n\n    # to read more about joins and subqueries\n    # visit: https://collerek.github.io/ormar/queries/joins-and-subqueries/\n\n\nasync def filter_and_sort():\n    # to filter the query you can use filter() or pass key-value pars to\n    # get(), all() etc.\n    # to use special methods or access related model fields use double\n    # underscore like to filter by the name of the author use author__name\n    # django style\n    books = await book.objects.all(author__name=\"j.r.r. tolkien\")\n    # python style\n    books = await book.objects.all(book.author.name == \"j.r.r. tolkien\")\n    assert len(books) == 3\n\n    # filter can accept special methods also separated with double underscore\n    # to issue sql query ` where authors.name like \"%tolkien%\"` that is not\n    # case sensitive (hence small t in tolkien)\n    # django style\n    books = await book.objects.filter(author__name__icontains=\"tolkien\").all()\n    # python style\n    books = await book.objects.filter(book.author.name.icontains(\"tolkien\")).all()\n    assert len(books) == 3\n\n    # to sort use order_by() function of queryset\n    # to sort decreasing use hyphen before the field name\n    # same as with filter you can use double underscores to access related fields\n    # django style\n    books = (\n        await book.objects.filter(author__name__icontains=\"tolkien\")\n        .order_by(\"-year\")\n        .all()\n    )\n    # python style\n    books = (\n        await book.objects.filter(book.author.name.icontains(\"tolkien\"))\n        .order_by(book.year.desc())\n        .all()\n    )\n    assert len(books) == 3\n    assert books[0].title == \"the silmarillion\"\n    assert books[2].title == \"the hobbit\"\n\n    # to read more about filtering and ordering\n    # visit: https://collerek.github.io/ormar/queries/filter-and-sort/\n\n\nasync def subset_of_columns():\n    # to exclude some columns from loading when querying the database\n    # you can use fileds() method\n    hobbit = await book.objects.fields([\"title\"]).get(title=\"the hobbit\")\n    # note that fields not included in fields are empty (set to none)\n    assert hobbit.year is none\n    assert hobbit.author is none\n\n    # selected field is there\n    assert hobbit.title == \"the hobbit\"\n\n    # alternatively you can provide columns you want to exclude\n    hobbit = await book.objects.exclude_fields([\"year\"]).get(title=\"the hobbit\")\n    # year is still not set\n    assert hobbit.year is none\n    # but author is back\n    assert hobbit.author is not none\n\n    # also you cannot exclude primary key column - it's always there\n    # even if you explicitly exclude it it will be there\n\n    # note that each model have a shortcut for primary_key column which is pk\n    # and you can filter/access/set the values by this alias like below\n    assert hobbit.pk is not none\n\n    # note that you cannot exclude fields that are not nullable\n    # (required) in model definition\n    try:\n        await book.objects.exclude_fields([\"title\"]).get(title=\"the hobbit\")\n    except pydantic.validationerror:\n        print(\"cannot exclude non nullable field title\")\n\n    # to read more about selecting subset of columns\n    # visit: https://collerek.github.io/ormar/queries/select-columns/\n\n\nasync def pagination():\n    # to limit number of returned rows use limit()\n    books = await book.objects.limit(1).all()\n    assert len(books) == 1\n    assert books[0].title == \"the hobbit\"\n\n    # to offset number of returned rows use offset()\n    books = await book.objects.limit(1).offset(1).all()\n    assert len(books) == 1\n    assert books[0].title == \"the lord of the rings\"\n\n    # alternatively use paginate that combines both\n    books = await book.objects.paginate(page=2, page_size=2).all()\n    assert len(books) == 2\n    # note that we removed one book of sapkowski in delete()\n    # and recreated the silmarillion - by default when no order_by is set\n    # ordering sorts by primary_key column\n    assert books[0].title == \"the witcher\"\n    assert books[1].title == \"the silmarillion\"\n\n    # to read more about pagination and number of rows\n    # visit: https://collerek.github.io/ormar/queries/pagination-and-rows-number/\n\n\nasync def aggregations():\n    # count:\n    assert 2 == await author.objects.count()\n\n    # exists\n    assert await book.objects.filter(title=\"the hobbit\").exists()\n\n    # maximum\n    assert 1990 == await book.objects.max(columns=[\"year\"])\n\n    # minimum\n    assert 1937 == await book.objects.min(columns=[\"year\"])\n\n    # average\n    assert 1964.75 == await book.objects.avg(columns=[\"year\"])\n\n    # sum\n    assert 7859 == await book.objects.sum(columns=[\"year\"])\n\n    # to read more about aggregated functions\n    # visit: https://collerek.github.io/ormar/queries/aggregations/\n\n\nasync def raw_data():\n    # extract raw data in a form of dicts or tuples\n    # note that this skips the validation(!) as models are\n    # not created from parsed data\n\n    # get list of objects as dicts\n    assert await book.objects.values() == [\n        {\"id\": 1, \"author\": 1, \"title\": \"the hobbit\", \"year\": 1937},\n        {\"id\": 2, \"author\": 1, \"title\": \"the lord of the rings\", \"year\": 1955},\n        {\"id\": 4, \"author\": 2, \"title\": \"the witcher\", \"year\": 1990},\n        {\"id\": 5, \"author\": 1, \"title\": \"the silmarillion\", \"year\": 1977},\n    ]\n\n    # get list of objects as tuples\n    assert await book.objects.values_list() == [\n        (1, 1, \"the hobbit\", 1937),\n        (2, 1, \"the lord of the rings\", 1955),\n        (4, 2, \"the witcher\", 1990),\n        (5, 1, \"the silmarillion\", 1977),\n    ]\n\n    # filter data - note how you always get a list\n    assert await book.objects.filter(title=\"the hobbit\").values() == [\n        {\"id\": 1, \"author\": 1, \"title\": \"the hobbit\", \"year\": 1937}\n    ]\n\n    # select only wanted fields\n    assert await book.objects.filter(title=\"the hobbit\").values([\"id\", \"title\"]) == [\n        {\"id\": 1, \"title\": \"the hobbit\"}\n    ]\n\n    # if you select only one column you could flatten it with values_list\n    assert await book.objects.values_list(\"title\", flatten=true) == [\n        \"the hobbit\",\n        \"the lord of the rings\",\n        \"the witcher\",\n        \"the silmarillion\",\n    ]\n\n    # to read more about extracting raw values\n    # visit: https://collerek.github.io/ormar/queries/aggregations/\n\n\nasync def with_connect(function):\n    # note that for any other backend than sqlite you actually need to\n    # connect to the database to perform db operations\n    async with database:\n        await function()\n\n    # note that if you use framework like `fastapi` you shouldn't connect\n    # in your endpoints but have a global connection pool\n    # check https://collerek.github.io/ormar/fastapi/ and section with db connection\n\n\n# gather and execute all functions\n# note - normally import should be at the beginning of the file\nimport asyncio\n\n# note that normally you use gather() function to run several functions\n# concurrently but we actually modify the data and we rely on the order of functions\nfor func in [\n    create,\n    read,\n    update,\n    delete,\n    joins,\n    filter_and_sort,\n    subset_of_columns,\n    pagination,\n    aggregations,\n    raw_data,\n]:\n    print(f\"executing: {func.__name__}\")\n    asyncio.run(with_connect(func))\n\n# drop the database tables\nmetadata.drop_all(engine)\n```\n\n## ormar specification\n\n### queryset methods\n\n*  `create(**kwargs): -> model`\n*  `get(*args, **kwargs): -> model`\n*  `get_or_none(*args, **kwargs): -> optional[model]`\n*  `get_or_create(_defaults: optional[dict[str, any]] = none, *args, **kwargs) -> tuple[model, bool]`\n*  `first(*args, **kwargs): -> model`\n*  `update(each: bool = false, **kwargs) -> int`\n*  `update_or_create(**kwargs) -> model`\n*  `bulk_create(objects: list[model]) -> none`\n*  `bulk_update(objects: list[model], columns: list[str] = none) -> none`\n*  `delete(*args, each: bool = false, **kwargs) -> int`\n*  `all(*args, **kwargs) -> list[optional[model]]`\n*  `iterate(*args, **kwargs) -> asyncgenerator[model]`\n*  `filter(*args, **kwargs) -> queryset`\n*  `exclude(*args, **kwargs) -> queryset`\n*  `select_related(related: union[list, str]) -> queryset`\n*  `prefetch_related(related: union[list, str]) -> queryset`\n*  `limit(limit_count: int) -> queryset`\n*  `offset(offset: int) -> queryset`\n*  `count(distinct: bool = true) -> int`\n*  `exists() -> bool`\n*  `max(columns: list[str]) -> any`\n*  `min(columns: list[str]) -> any`\n*  `avg(columns: list[str]) -> any`\n*  `sum(columns: list[str]) -> any`\n*  `fields(columns: union[list, str, set, dict]) -> queryset`\n*  `exclude_fields(columns: union[list, str, set, dict]) -> queryset`\n*  `order_by(columns:union[list, str]) -> queryset`\n*  `values(fields: union[list, str, set, dict])`\n*  `values_list(fields: union[list, str, set, dict])`\n\n\n#### relation types\n\n*  one to many  - with `foreignkey(to: model)`\n*  many to many - with `manytomany(to: model, optional[through]: model)`\n\n#### model fields types\n\navailable model fields (with required args - optional ones in docs):\n\n* `string(max_length)`\n* `text()`\n* `boolean()`\n* `integer()`\n* `float()`\n* `date()`\n* `time()`\n* `datetime()`\n* `json()`\n* `biginteger()`\n* `smallinteger()`\n* `decimal(scale, precision)`\n* `uuid()`\n* `largebinary(max_length)`\n* `enum(enum_class)`\n* `enum` like field - by passing `choices` to any other field type\n* `encryptedstring` - by passing `encrypt_secret` and `encrypt_backend`\n* `foreignkey(to)`\n* `manytomany(to)`\n\n### available fields options\nthe following keyword arguments are supported on all field types.\n\n* `primary_key: bool`\n* `nullable: bool`\n* `default: any`\n* `server_default: any`\n* `index: bool`\n* `unique: bool`\n* `choices: typing.sequence`\n* `name: str`\n* `pydantic_only: bool`\n\nall fields are required unless one of the following is set:\n\n* `nullable` - creates a nullable column. sets the default to `false`. read the fields common parameters for details.\n* `sql_nullable` - used to set different setting for pydantic and the database. sets the default to `nullable` value. read the fields common parameters for details.\n* `default` - set a default value for the field. **not available for relation fields**\n* `server_default` - set a default value for the field on server side (like sqlalchemy's `func.now()`). **not available for relation fields**\n* `primary key` with `autoincrement` - when a column is set to primary key and autoincrement is set on this column.\n  autoincrement is set by default on int primary keys.\n* `pydantic_only` - field is available only as normal pydantic field, not stored in the database.\n\n### available signals\n\nsignals allow to trigger your function for a given event on a given model.\n\n* `pre_save`\n* `post_save`\n* `pre_update`\n* `post_update`\n* `pre_delete`\n* `post_delete`\n* `pre_relation_add`\n* `post_relation_add`\n* `pre_relation_remove`\n* `post_relation_remove`\n* `post_bulk_update`\n\n\n[sqlalchemy-core]: https://docs.sqlalchemy.org/en/latest/core/\n[databases]: https://github.com/encode/databases\n[pydantic]: https://pydantic-docs.helpmanual.io/\n[encode/orm]: https://github.com/encode/orm/\n[alembic]: https://alembic.sqlalchemy.org/en/latest/\n[fastapi]: https://fastapi.tiangolo.com/\n[documentation]: https://collerek.github.io/ormar/\n[migrations]: https://collerek.github.io/ormar/models/migrations/\n[asyncio]: https://docs.python.org/3/library/asyncio.html\n[releases]: https://collerek.github.io/ormar/releases/\n[tests]: https://github.com/collerek/ormar/tree/master/tests\n",
  "docs_url": null,
  "keywords": "orm,sqlalchemy,fastapi,pydantic,databases,async,alembic",
  "license": "mit",
  "name": "ormar",
  "package_url": "https://pypi.org/project/ormar/",
  "project_url": "https://pypi.org/project/ormar/",
  "project_urls": {
    "Documentation": "https://collerek.github.io/ormar/",
    "Homepage": "https://github.com/collerek/ormar",
    "Repository": "https://github.com/collerek/ormar"
  },
  "release_url": "https://pypi.org/project/ormar/0.12.2/",
  "requires_dist": [
    "databases (>=0.3.2,!=0.5.0,!=0.5.1,!=0.5.2,!=0.5.3,<0.6.3)",
    "pydantic (>=1.6.1,!=1.7,!=1.7.1,!=1.7.2,!=1.7.3,!=1.8,!=1.8.1,<1.10.9)",
    "SQLAlchemy (>=1.3.18,<1.4.42)",
    "cryptography (>=35,<41) ; extra == \"crypto\" or extra == \"all\"",
    "aiosqlite (>=0.17,<0.20) ; extra == \"sqlite\" or extra == \"all\"",
    "aiomysql (>=0.1.0) ; extra == \"mysql\" or extra == \"all\"",
    "aiopg (>=1.3.3,<2.0.0) ; extra == \"aiopg\" or extra == \"all\"",
    "asyncpg (>=0.24,<0.28) ; extra == \"postgresql\" or extra == \"postgres\" or extra == \"all\"",
    "psycopg2-binary (>=2.9.1,<3.0.0) ; extra == \"postgresql\" or extra == \"postgres\" or extra == \"aiopg\" or extra == \"all\"",
    "mysqlclient (>=2.1.0,<3.0.0) ; extra == \"all\"",
    "PyMySQL (>=0.9) ; extra == \"mysql\" or extra == \"all\"",
    "orjson (>=3.6.4) ; extra == \"orjson\" or extra == \"all\"",
    "typing-extensions (>=3.7,<=5.0) ; python_version < \"3.8\"",
    "importlib-metadata (>=3.1) ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.7.0,<4.0.0",
  "summary": "an async orm with fastapi in mind and pydantic validation.",
  "version": "0.12.2",
  "releases": [],
  "developers": [
    "collerek@gmail.com"
  ],
  "kwds": "sqlalchemy pyversions _ormar_ ormar pydantic_only",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_ormar",
  "homepage": "https://github.com/collerek/ormar",
  "release_count": 83,
  "dependency_ids": [
    "pypi_aiomysql",
    "pypi_aiopg",
    "pypi_aiosqlite",
    "pypi_asyncpg",
    "pypi_cryptography",
    "pypi_databases",
    "pypi_importlib_metadata",
    "pypi_mysqlclient",
    "pypi_orjson",
    "pypi_psycopg2_binary",
    "pypi_pydantic",
    "pypi_pymysql",
    "pypi_sqlalchemy",
    "pypi_typing_extensions"
  ]
}