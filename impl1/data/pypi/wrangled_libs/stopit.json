{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: implementation :: cpython",
    "topic :: utilities"
  ],
  "description": "======\nstopit\n======\n\nraise asynchronous exceptions in other threads, control the timeout of\nblocks or callables with two context managers and two decorators.\n\n.. attention:: api changes\n\n   users of 1.0.0 should upgrade their source code:\n\n   - ``stopit.timeout`` is renamed ``stopit.threadingtimeout``\n   - ``stopit.timeoutable`` is renamed ``stopit.threading_timeoutable``\n\n   explications follow below...\n\n.. contents::\n\noverview\n========\n\nthis module provides:\n\n- a function that raises an exception in another thread, including the main\n  thread.\n\n- two context managers that may stop its inner block activity on timeout.\n\n- two decorators that may stop its decorated callables on timeout.\n\ndeveloped and tested with cpython 2.6, 2.7, 3.3 and 3.4 on macosx. should work\non any os (xbsd, linux, windows) except when explicitly mentioned.\n\n.. note::\n\n   signal based timeout controls, namely ``signaltimeout`` context manager and\n   ``signal_timeoutable`` decorator won't work in windows that has no support\n   for ``signal.sigalrm``. any help to work around this is welcome.\n\ninstallation\n============\n\nusing ``stopit`` in your application\n------------------------------------\n\nboth work identically:\n\n.. code:: bash\n\n  easy_install stopit\n  pip install stopit\n\ndeveloping ``stopit``\n---------------------\n\n.. code:: bash\n\n  # you should prefer forking if you have a github account\n  git clone https://github.com/glenfant/stopit.git\n  cd stopit\n  python setup.py develop\n\n  # does it work for you ?\n  python setup.py test\n\npublic api\n==========\n\nexception\n---------\n\n``stopit.timeoutexception``\n...........................\n\na ``stopit.timeoutexception`` may be raised in a timeout context manager\ncontrolled block.\n\nthis exception may be propagated in your application at the end of execution\nof the context manager controlled block, see the ``swallow_ex`` parameter of\nthe context managers.\n\nnote that the ``stopit.timeoutexception`` is always swallowed after the\nexecution of functions decorated with ``xxx_timeoutable(...)``. anyway, you\nmay catch this exception **within** the decorated function.\n\nthreading based resources\n-------------------------\n\n.. warning::\n\n   threading based resources will only work with cpython implementations\n   since we use cpython specific low level api. this excludes iron python,\n   jython, pypy, ...\n\n   will not stop the execution of blocking python atomic instructions that\n   acquire the gil. in example, if the destination thread is actually\n   executing a ``time.sleep(20)``, the asynchronous exception is effective\n   **after** its execution.\n\n``stopit.async_raise``\n......................\n\na function that raises an arbitrary exception in another thread\n\n``async_raise(tid, exception)``\n\n- ``tid`` is the thread identifier as provided by the ``ident`` attribute of a\n  thread object. see the documentation of the ``threading`` module for further\n  information.\n\n- ``exception`` is the exception class or object to raise in the thread.\n\n``stopit.threadingtimeout``\n...........................\n\na context manager that \"kills\" its inner block execution that exceeds the\nprovided time.\n\n``threadingtimeout(seconds, swallow_exc=true)``\n\n- ``seconds`` is the number of seconds allowed to the execution of the context\n  managed block.\n\n- ``swallow_exc`` : if ``false``, the possible ``stopit.timeoutexception`` will\n  be re-raised when quitting the context managed block. **attention**: a\n  ``true`` value does not swallow other potential exceptions.\n\n**methods and attributes**\n\nof a ``stopit.threadingtimeout`` context manager.\n\n.. list-table::\n   :header-rows: 1\n\n   * - method / attribute\n     - description\n\n   * - ``.cancel()``\n     - cancels the timeout control. this method is intended for use within the\n       block that's under timeout control, specifically to cancel the timeout\n       control. means that all code executed after this call may be executed\n       till the end.\n\n   * - ``.state``\n     - this attribute indicated the actual status of the timeout control. it\n       may take the value of the ``executed``, ``executing``, ``timed_out``,\n       ``interrupted`` or ``canceled`` attributes. see below.\n\n   * - ``.executing``\n     - the timeout control is under execution. we are typically executing\n       within the code under control of the context manager.\n\n   * - ``.executed``\n     - good news: the code under timeout control completed normally within the\n       assigned time frame.\n\n   * - ``.timed_out``\n     - bad news: the code under timeout control has been sleeping too long.\n       the objects supposed to be created or changed within the timeout\n       controlled block should be considered as non existing or corrupted.\n       don't play with them otherwise informed.\n\n   * - ``.interrupted``\n     - the code under timeout control may itself raise explicit\n       ``stopit.timeoutexception`` for any application logic reason that may\n       occur. this intentional exit can be spotted from outside the timeout\n       controlled block with this state value.\n\n   * - ``.canceled``\n     - the timeout control has been intentionally canceled and the code\n       running under timeout control did complete normally. but perhaps after\n       the assigned time frame.\n\n\na typical usage:\n\n.. code:: python\n\n   import stopit\n   # ...\n   with stopit.threadingtimeout(10) as to_ctx_mgr:\n       assert to_ctx_mgr.state == to_ctx_mgr.executing\n       # something potentially very long but which\n       # ...\n\n   # ok, let's check what happened\n   if to_ctx_mgr.state == to_ctx_mgr.executed:\n       # all's fine, everything was executed within 10 seconds\n   elif to_ctx_mgr.state == to_ctx_mgr.executing:\n       # hmm, that's not possible outside the block\n   elif to_ctx_mgr.state == to_ctx_mgr.timed_out:\n       # eeek the 10 seconds timeout occurred while executing the block\n   elif to_ctx_mgr.state == to_ctx_mgr.interrupted:\n       # oh you raised specifically the timeoutexception in the block\n   elif to_ctx_mgr.state == to_ctx_mgr.canceled:\n       # oh you called to_ctx_mgr.cancel() method within the block but it\n       # executed till the end\n   else:\n       # that's not possible\n\nnotice that the context manager object may be considered as a boolean\nindicating (if ``true``) that the block executed normally:\n\n.. code:: python\n\n   if to_ctx_mgr:\n       # yes, the code under timeout control completed\n       # objects it created or changed may be considered consistent\n\n``stopit.threading_timeoutable``\n................................\n\na decorator that kills the function or method it decorates, if it does not\nreturn within a given time frame.\n\n``stopit.threading_timeoutable([default [, timeout_param]])``\n\n- ``default`` is the value to be returned by the decorated function or method of\n  when its execution timed out, to notify the caller code that the function\n  did not complete within the assigned time frame.\n\n  if this parameter is not provided, the decorated function or method will\n  return a ``none`` value when its execution times out.\n\n  .. code:: python\n\n     @stopit.threading_timeoutable(default='not finished')\n     def infinite_loop():\n         # as its name says...\n\n     result = infinite_loop(timeout=5)\n     assert result == 'not finished'\n\n- ``timeout_param``: the function or method you have decorated may require a\n  ``timeout`` named parameter for whatever reason. this empowers you to change\n  the name of the ``timeout`` parameter in the decorated function signature to\n  whatever suits, and prevent a potential naming conflict.\n\n  .. code:: python\n\n     @stopit.threading_timeoutable(timeout_param='my_timeout')\n     def some_slow_function(a, b, timeout='whatever'):\n         # as its name says...\n\n     result = some_slow_function(1, 2, timeout=\"something\", my_timeout=2)\n\n\nabout the decorated function\n............................\n\nor method...\n\nas you noticed above, you just need to add the ``timeout`` parameter when\ncalling the function or method. or whatever other name for this you chose with\nthe ``timeout_param`` of the decorator. when calling the real inner function\nor method, this parameter is removed.\n\n\nsignaling based resources\n-------------------------\n\n.. warning::\n\n   using signaling based resources will **not** work under windows or any os\n   that's not based on unix.\n\n``stopit.signaltimeout`` and ``stopit.signal_timeoutable`` have exactly the\nsame api as their respective threading based resources, namely\n`stopit.threadingtimeout`_ and `stopit.threading_timeoutable`_.\n\nsee the `comparison chart`_ that warns on the more or less subtle differences\nbetween the `threading based resources`_ and the `signaling based resources`_.\n\nlogging\n-------\n\nthe ``stopit`` named logger emits a warning each time a block of code\nexecution exceeds the associated timeout. to turn logging off, just:\n\n.. code:: python\n\n   import logging\n   stopit_logger = logging.getlogger('stopit')\n   stopit_logger.selevel(logging.error)\n\n.. _comparison chart:\n\ncomparing thread based and signal based timeout control\n-------------------------------------------------------\n\n.. list-table::\n   :header-rows: 1\n\n   * - feature\n     - threading based resources\n     - signaling based resources\n\n   * - gil\n     - can't interrupt a long python atomic instruction. e.g. if\n       ``time.sleep(20.0)`` is actually executing, the timeout will take\n       effect at the end of the execution of this line.\n     - don't care of it\n\n   * - thread safety\n     - **yes** : thread safe as long as each thread uses its own ``threadingtimeout``\n       context manager or ``threading_timeoutable`` decorator.\n     - **not** thread safe. could yield unpredictable results in a\n       multithreads application.\n\n   * - nestable context managers\n     - **yes** : you can nest threading based context managers\n     - **no** : never nest a signaling based context manager in another one.\n       the innermost context manager will automatically cancel the timeout\n       control of outer ones.\n\n   * - accuracy\n     - any positive floating value is accepted as timeout value. the accuracy\n       depends on the gil interval checking of your platform. see the doc on\n       ``sys.getcheckinterval`` and ``sys.setcheckinterval`` for your python\n       version.\n     - due to the use of ``signal.sigalrm``, we need provide an integer number\n       of seconds. so a timeout of ``0.6`` seconds will ve automatically\n       converted into a timeout of zero second!\n\n   * - supported platforms\n     - any cpython 2.6, 2.7 or 3.3 on any os with threading support.\n     - any python 2.6, 2.7 or 3.3 with ``signal.sigalrm`` support. this\n       excludes windows boxes\n\nknown issues\n============\n\ntimeout accuracy\n----------------\n\n**important**: the way cpython supports threading and asynchronous features has\nimpacts on the accuracy of the timeout. in other words, if you assign a 2.0\nseconds timeout to a context managed block or a decorated callable, the\neffective code block / callable execution interruption may occur some\nfractions of seconds after this assigned timeout.\n\nfor more background about this issue - that cannot be fixed - please read\npython gurus thoughts about python threading, the gil and context switching\nlike these ones:\n\n- http://pymotw.com/2/threading/\n- https://wiki.python.org/moin/globalinterpreterlock\n\nthis is the reason why i am more \"tolerant\" on timeout accuracy in the tests\nyou can read thereafter than i should be for a critical real-time application\n(that's not in the scope of python).\n\nit is anyway possible to improve this accuracy at the expense of the global\nperformances decreasing the check interval which defaults to 100. see:\n\n- https://docs.python.org/2.7/library/sys.html#sys.getcheckinterval\n- https://docs.python.org/2.7/library/sys.html#sys.getcheckinterval\n\nif this is a real issue for users (want a precise timeout and not an\napproximative one), a future release will add the optional ``check_interval``\nparameter to the context managers and decorators. this parameter will enable\nto lower temporarily the threads switching check interval, having a more\naccurate timeout at the expense of the overall performances while the context\nmanaged block or decorated functions are executing.\n\n``gevent`` support\n------------------\n\nthreading timeout control as mentioned in `threading based resources`_ does not work as expected\nwhen used in the context of a gevent worker.\n\nsee the discussion in `issue 13 <https://github.com/glenfant/stopit/issues/13>`_ for more details.\n\ntests and demos\n===============\n\n.. code:: pycon\n\n   >>> import threading\n   >>> from stopit import async_raise, timeoutexception\n\nin a real application, you should either use threading based timeout resources:\n\n.. code:: pycon\n\n   >>> from stopit import threadingtimeout as timeout, threading_timeoutable as timeoutable  #doctest: +skip\n\nor the posix signal based resources:\n\n.. code:: pycon\n\n   >>> from stopit import signaltimeout as timeout, signal_timeoutable as timeoutable  #doctest: +skip\n\nlet's define some utilities:\n\n.. code:: pycon\n\n   >>> import time\n   >>> def fast_func():\n   ...     return 0\n   >>> def variable_duration_func(duration):\n   ...     t0 = time.time()\n   ...     while true:\n   ...         dummy = 0\n   ...         if time.time() - t0 > duration:\n   ...             break\n   >>> exc_traces = []\n   >>> def variable_duration_func_handling_exc(duration, exc_traces):\n   ...     try:\n   ...         t0 = time.time()\n   ...         while true:\n   ...             dummy = 0\n   ...             if time.time() - t0 > duration:\n   ...                 break\n   ...     except exception as exc:\n   ...         exc_traces.append(exc)\n   >>> def func_with_exception():\n   ...     raise lookuperror()\n\n``async_raise`` function raises an exception in another thread\n--------------------------------------------------------------\n\ntesting ``async_raise()`` with a thread of 5 seconds:\n\n.. code:: pycon\n\n   >>> five_seconds_threads = threading.thread(\n   ...     target=variable_duration_func_handling_exc, args=(5.0, exc_traces))\n   >>> start_time = time.time()\n   >>> five_seconds_threads.start()\n   >>> thread_ident = five_seconds_threads.ident\n   >>> five_seconds_threads.is_alive()\n   true\n\nwe raise a lookuperror in that thread:\n\n.. code:: pycon\n\n   >>> async_raise(thread_ident, lookuperror)\n\nokay but we must wait few milliseconds the thread death since the exception is\nasynchronous:\n\n.. code:: pycon\n\n   >>> while five_seconds_threads.is_alive():\n   ...     pass\n\nand we can notice that we stopped the thread before it stopped by itself:\n\n.. code:: pycon\n\n   >>> time.time() - start_time < 0.5\n   true\n   >>> len(exc_traces)\n   1\n   >>> exc_traces[-1].__class__.__name__\n   'lookuperror'\n\n``timeout`` context manager\n---------------------------\n\nthe context manager stops the execution of its inner block after a given time.\nyou may manage the way the timeout occurs using a ``try: ... except: ...``\nconstruct or by inspecting the context manager ``state`` attribute after the\nblock.\n\nswallowing timeout exceptions\n.............................\n\nwe check that the fast functions return as outside our context manager:\n\n.. code:: pycon\n\n   >>> with timeout(5.0) as timeout_ctx:\n   ...     result = fast_func()\n   >>> result\n   0\n   >>> timeout_ctx.state == timeout_ctx.executed\n   true\n\nand the context manager is considered as ``true`` (the block executed its last\nline):\n\n.. code:: pycon\n\n   >>> bool(timeout_ctx)\n   true\n\nwe check that slow functions are interrupted:\n\n.. code:: pycon\n\n   >>> start_time = time.time()\n   >>> with timeout(2.0) as timeout_ctx:\n   ...     variable_duration_func(5.0)\n   >>> time.time() - start_time < 2.2\n   true\n   >>> timeout_ctx.state == timeout_ctx.timed_out\n   true\n\nand the context manager is considered as ``false`` since the block did timeout.\n\n.. code:: pycon\n\n   >>> bool(timeout_ctx)\n   false\n\nother exceptions are propagated and must be treated as usual:\n\n.. code:: pycon\n\n   >>> try:\n   ...     with timeout(5.0) as timeout_ctx:\n   ...         result = func_with_exception()\n   ... except lookuperror:\n   ...     result = 'exception_seen'\n   >>> timeout_ctx.state == timeout_ctx.executing\n   true\n   >>> result\n   'exception_seen'\n\npropagating ``timeoutexception``\n................................\n\nwe can choose to propagate the ``timeoutexception`` too. potential exceptions\nhave to be handled:\n\n.. code:: pycon\n\n   >>> result = none\n   >>> start_time = time.time()\n   >>> try:\n   ...     with timeout(2.0, swallow_exc=false) as timeout_ctx:\n   ...         variable_duration_func(5.0)\n   ... except timeoutexception:\n   ...     result = 'exception_seen'\n   >>> time.time() - start_time < 2.2\n   true\n   >>> result\n   'exception_seen'\n   >>> timeout_ctx.state == timeout_ctx.timed_out\n   true\n\nother exceptions must be handled too:\n\n.. code:: pycon\n\n   >>> result = none\n   >>> start_time = time.time()\n   >>> try:\n   ...     with timeout(2.0, swallow_exc=false) as timeout_ctx:\n   ...         func_with_exception()\n   ... except exception:\n   ...     result = 'exception_seen'\n   >>> time.time() - start_time < 0.1\n   true\n   >>> result\n   'exception_seen'\n   >>> timeout_ctx.state == timeout_ctx.executing\n   true\n\n``timeoutable`` callable decorator\n----------------------------------\n\nthis decorator stops the execution of any callable that should not last a\ncertain amount of time.\n\nyou may use a decorated callable without timeout control if you don't provide\nthe ``timeout`` optional argument:\n\n.. code:: pycon\n\n   >>> @timeoutable()\n   ... def fast_double(value):\n   ...     return value * 2\n   >>> fast_double(3)\n   6\n\nyou may specify that timeout with the ``timeout`` optional argument.\ninterrupted callables return none:\n\n.. code:: pycon\n\n   >>> @timeoutable()\n   ... def infinite():\n   ...     while true:\n   ...         pass\n   ...     return 'whatever'\n   >>> infinite(timeout=1) is none\n   true\n\nor any other value provided to the ``timeoutable`` decorator parameter:\n\n.. code:: pycon\n\n   >>> @timeoutable('unexpected')\n   ... def infinite():\n   ...     while true:\n   ...         pass\n   ...     return 'whatever'\n   >>> infinite(timeout=1)\n   'unexpected'\n\nif the ``timeout`` parameter name may clash with your callable signature, you\nmay change it using ``timeout_param``:\n\n.. code:: pycon\n\n   >>> @timeoutable('unexpected', timeout_param='my_timeout')\n   ... def infinite():\n   ...     while true:\n   ...         pass\n   ...     return 'whatever'\n   >>> infinite(my_timeout=1)\n   'unexpected'\n\nit works on instance methods too:\n\n.. code:: pycon\n\n   >>> class anything(object):\n   ...     @timeoutable('unexpected')\n   ...     def infinite(self, value):\n   ...         assert type(value) is int\n   ...         while true:\n   ...             pass\n   >>> obj = anything()\n   >>> obj.infinite(2, timeout=1)\n   'unexpected'\n\nlinks\n=====\n\nsource code (clone, fork, ...)\n  https://github.com/glenfant/stopit\n\nissues tracker\n  https://github.com/glenfant/stopit/issues\n\npypi\n  https://pypi.python.org/pypi/stopit\n\ncredits\n=======\n\n- this is a nih package which is mainly a theft of `gabriel ahtune's recipe\n  <http://gahtune.blogspot.fr/2013/08/a-timeout-context-manager.html>`_ with\n  tests, minor improvements and refactorings, documentation and setuptools\n  awareness i made since i'm somehow tired to copy/paste this recipe among\n  projects that need timeout control.\n\n- `gilles lenfant <gilles.lenfant@gmail.com>`_: package creator and\n  maintainer.\n\nlicense\n=======\n\nthis software is open source delivered under the terms of the mit license. see the ``license`` file of this repository.\n\nchanges log\n===========\n\n1.1.2 - 2018-02-09\n------------------\n\n* changed license to mit\n* tested with python 3.5 and 3.6\n\n1.1.1 - 2015-03-22\n------------------\n\n* fixed bug of timeout context manager as bool under python 2.x\n* tested with python 3.4\n\n1.1.0 - 2014-05-02\n------------------\n\n* added support for timer signal based timeout control (posix os only)\n* api changes due to new timeout controls\n* an exhaustive documentation.\n\n1.0.0 - 2014-02-09\n------------------\n\ninitial version",
  "docs_url": null,
  "keywords": "threads timeout",
  "license": "gplv3",
  "name": "stopit",
  "package_url": "https://pypi.org/project/stopit/",
  "project_url": "https://pypi.org/project/stopit/",
  "project_urls": {
    "Homepage": "http://pypi.python.org/pypi/stopit"
  },
  "release_url": "https://pypi.org/project/stopit/1.1.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "timeout control decorator and context managers, raise any exception in another thread",
  "version": "1.1.2",
  "releases": [],
  "developers": [
    "gilles.lenfant@gmail.com",
    "gilles_lenfant"
  ],
  "kwds": "threading_timeoutable threadingtimeout signal_timeoutable timeout_param signaltimeout",
  "license_kwds": "gplv3",
  "libtype": "pypi",
  "id": "pypi_stopit",
  "homepage": "http://pypi.python.org/pypi/stopit",
  "release_count": 4,
  "dependency_ids": []
}