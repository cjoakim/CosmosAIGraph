{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "topic :: software development :: testing :: traffic generation"
  ],
  "description": "# snappi-trex\n\n[![license](https://img.shields.io/badge/license-mit-green.svg)](https://en.wikipedia.org/wiki/mit_license)\n[![project status: active \u2013 the project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)\n[![build](https://github.com/open-traffic-generator/snappi-trex/workflows/build/badge.svg)](https://github.com/open-traffic-generator/snappi-trex/actions)\n[![total alerts](https://img.shields.io/lgtm/alerts/g/open-traffic-generator/snappi-trex.svg?logo=lgtm&logowidth=18)](https://lgtm.com/projects/g/open-traffic-generator/snappi-trex/alerts/)\n[![language grade: python](https://img.shields.io/lgtm/grade/python/g/open-traffic-generator/snappi-trex.svg?logo=lgtm&logowidth=18)](https://lgtm.com/projects/g/open-traffic-generator/snappi-trex/context:python)\n[![pypi](https://img.shields.io/pypi/v/snappi-trex.svg)](https://pypi.org/project/snappi-trex)\n[![python](https://img.shields.io/pypi/pyversions/snappi-trex.svg)](https://pypi.python.org/pypi/snappi-trex)\n\nsnappi-trex is a snappi plugin that allows executing scripts written using \n[snappi](https://github.com/open-traffic-generator/snappi) with cisco's [trex traffic generator](https://trex-tgn.cisco.com).\n\nsnappi-trex is currently compatible with snappi v0.6.4 and open traffic generator v0.6.4\n\n## design\nsnappi-trex converts snappi open traffic generator api configuration into the equivalent trex stl client configuration. this allows users to use the trex traffic generator and its useful features without having to write complex trex scripts. \n\n![diagram](docs/res/snappi-trex-design.svg)\n\nthe above diagram outlines the overall process of how the snappi open traffic generator api is able to interface with trex and generate traffic over its network interfaces. snappi-trex is essential to convert snappi scripts into the equivalent trex stl client instructions.\n\n<br>\n\nsnappi-trex usage follows the standard usage of snappi with a few modifications outlined in the [usage](docs/usage.md) document.\n\n\n## demos\n\n### [click here for the quickstart guide video tutorial](https://youtube.com/watch?v=ti8lwkhwcle)\n* this goes over the installation and setup for snappi-trex, and how to run a basic snappi script using snappi-trex\n\n### [click here for the snappi-trex p4 ptf demo](https://youtube.com/watch?v=apncb2lg6vy)\n* this demonstrates snappi-trex being used with the p4 packet testing framework in a 4 port mesh configuration\n\n<br>\n\n# table of contents\n* [quickstart](docs/quickstart.md)\n* [trex installation and setup](docs/trex-tutorial.md)\n* [snappi-trex usage](docs/usage.md)\n* [snappi-trex full features and limitations](docs/features.md)\n* [testing](docs/testing.md)\n* [contribute](docs/contribute.md)\n* [demos](docs/demos.md)\n\n<br>\n\n# quickstart\nsnappi-trex is a snappi plugin that allows executing scripts written using \n[snappi](https://github.com/open-traffic-generator/snappi) with cisco's [trex traffic generator](https://trex-tgn.cisco.com)\n\n<br>\n\n## [--> click here for the quickstart guide video tutorial](https://youtube.com/watch?v=ti8lwkhwcle)\n<br>\n\n## installing and running trex\n### [trex must be installed and running before proceeding](docs/trex-tutorial.md)\ntrex must be installed and configured in order to use snappi-trex. for a quick tutorial on trex installation, running, and basic usage, check out my [trex tutorial](docs/trex-tutorial.md)\n\n<br>\n\n## installing snappi-trex\nmake sure python-pip3 is installed\n```sh\nsudo apt-get install python3-pip\n```\ninstall snappi and the snappi-trex extension\n```sh\npip3 install snappi==0.6.1 snappi[trex]\n```\n\n## start scripting\nlet's run our first script called `hello_snappi_trex.py`: a basic snappi script that transmits 1000 udp packets bidirectionally between two ports and verifies that they are received. this file can be found at `examples/hello_snappi_trex.py` in the snappi-trex github repo.\n```sh\ngit clone https://github.com/open-traffic-generator/snappi-trex\npython3 snappi-trex/examples/hello_snappi_trex.py\n```\n\n<br>\n\nyou may also just paste the script in from below.\n<details>\n<summary>hello_snappi_trex.py</summary>\n\n```\nimport snappi\nimport sys, os\n\n# replace v2.90 with the installed version of trex. \n# change '/opt/trex' if you installed trex in another location\ntrex_path = '/opt/trex/v2.90/automation/trex_control_plane/interactive'\nsys.path.insert(0, os.path.abspath(trex_path))\n\n\ndef hello_snappi_trex():\n    \"\"\"\n    this script does following:\n    - send 1000 packets back and forth between the two ports at a rate of\n      1000 packets per second.\n    - validate that total packets sent and received on both interfaces is as\n      expected using port metrics.\n    - validate that captured udp packets on both the ports are as expected.\n    \"\"\"\n    # create a new api instance where host points to controller\n    api = snappi.api(ext='trex')\n    # and an empty traffic configuration to be pushed to controller later on\n    cfg = api.config()\n\n    # add two ports where location points to traffic-engine (aka ports)\n    p1, p2 = (\n        cfg.ports\n        .port(name='p1')\n        .port(name='p2')\n    )\n\n    # add layer 1 property to configure same speed on both ports\n    ly = cfg.layer1.layer1(name='ly')[-1]\n    ly.port_names = [p1.name, p2.name]\n    ly.speed = ly.speed_1_gbps\n\n    # enable packet capture on both ports\n    cp = cfg.captures.capture(name='cp')[-1]\n    cp.port_names = [p1.name, p2.name]\n\n    # add two traffic flows\n    f1, f2 = cfg.flows.flow(name='flow p1->p2').flow(name='flow p2->p1')\n    # and assign source and destination ports for each\n    f1.tx_rx.port.tx_name, f1.tx_rx.port.rx_name = p1.name, p2.name\n    f2.tx_rx.port.tx_name, f2.tx_rx.port.rx_name = p2.name, p1.name\n\n    # configure packet size, rate and duration for both flows\n    f1.size.fixed, f2.size.fixed = 128, 256\n    for f in cfg.flows:\n        # send 1000 packets and stop\n        f.duration.fixed_packets.packets = 1000\n        # send 1000 packets per second\n        f.rate.pps = 1000\n\n    # configure packet with ethernet, ipv4 and udp headers for both flows\n    eth1, ip1, udp1 = f1.packet.ethernet().ipv4().udp()\n    eth2, ip2, udp2 = f2.packet.ethernet().ipv4().udp()\n\n    # set source and destination mac addresses\n    eth1.src.value, eth1.dst.value = '00:aa:00:00:04:00', '00:aa:00:00:00:aa'\n    eth2.src.value, eth2.dst.value = '00:aa:00:00:00:aa', '00:aa:00:00:04:00'\n\n    # set source and destination ipv4 addresses\n    ip1.src.value, ip1.dst.value = '10.0.0.1', '10.0.0.2'\n    ip2.src.value, ip2.dst.value = '10.0.0.2', '10.0.0.1'\n\n    # set incrementing port numbers as source udp ports\n    udp1.src_port.increment.start = 5000\n    udp1.src_port.increment.step = 2\n    udp1.src_port.increment.count = 10\n\n    udp2.src_port.increment.start = 6000\n    udp2.src_port.increment.step = 4\n    udp2.src_port.increment.count = 10\n\n    # assign list of port numbers as destination udp ports\n    udp1.dst_port.values = [4000, 4044, 4060, 4074]\n    udp2.dst_port.values = [8000, 8044, 8060, 8074, 8082, 8084]\n\n    print('pushing traffic configuration ...')\n    api.set_config(cfg)\n\n    print('starting packet capture on all configured ports ...')\n    cs = api.capture_state()\n    cs.state = cs.start\n    api.set_capture_state(cs)\n\n    print('starting transmit on all configured flows ...')\n    ts = api.transmit_state()\n    ts.state = ts.start\n    api.set_transmit_state(ts)\n\n    print('checking metrics on all configured ports ...')\n    print('expected\\ttotal tx\\ttotal rx')\n    assert wait_for(lambda: metrics_ok(api, cfg)), 'metrics validation failed!'\n\n    assert captures_ok(api, cfg), 'capture validation failed!'\n\n    print('test passed !')\n\n\ndef metrics_ok(api, cfg):\n    # create a port metrics request and filter based on port names\n    req = api.metrics_request()\n    req.port.port_names = [p.name for p in cfg.ports]\n    # include only sent and received packet counts\n    req.port.column_names = [req.port.frames_tx, req.port.frames_rx]\n\n    # fetch port metrics\n    res = api.get_metrics(req)\n    # calculate total frames sent and received across all configured ports\n    total_tx = sum([m.frames_tx for m in res.port_metrics])\n    total_rx = sum([m.frames_rx for m in res.port_metrics])\n    expected = sum([f.duration.fixed_packets.packets for f in cfg.flows])\n\n    print('%d\\t\\t%d\\t\\t%d' % (expected, total_tx, total_rx))\n\n    return expected == total_tx and total_rx >= expected\n\n\ndef captures_ok(api, cfg):\n    import dpkt\n    print('checking captured packets on all configured ports ...')\n    print('port name\\texpected\\tudp packets')\n\n    result = []\n    for p in cfg.ports:\n        exp, act = 1000, 0\n        # create capture request and filter based on port name\n        req = api.capture_request()\n        req.port_name = p.name\n        # fetch captured pcap bytes and feed it to pcap parser dpkt\n        pcap = dpkt.pcap.reader(api.get_capture(req))\n        for _, buf in pcap:\n            # check if current packet is a valid udp packet\n            eth = dpkt.ethernet.ethernet(buf)\n            if isinstance(eth.data.data, dpkt.udp.udp):\n                act += 1\n\n        print('%s\\t\\t%d\\t\\t%d' % (p.name, exp, act))\n        result.append(exp == act)\n\n    return all(result)\n\n\ndef wait_for(func, timeout=10, interval=0.2):\n    \"\"\"\n    keeps calling the `func` until it returns true or `timeout` occurs\n    every `interval` seconds.\n    \"\"\"\n    import time\n    start = time.time()\n\n    while time.time() - start <= timeout:\n        if func():\n            return true\n        time.sleep(interval)\n\n    print('timeout occurred !')\n    return false\n\n\nif __name__ == '__main__':\n    hello_snappi_trex()\n\n```\n</details>\n\n<br>\n\n### output\n\nif everything is working correctly, you should see a similar output as this.\n```\npushing traffic configuration ...\nstarting packet capture on all configured ports ...\nstarting transmit on all configured flows ...\nchecking metrics on all configured ports ...\nexpected        total tx        total rx\n2000            19              17\n2000            445             437\n2000            881             881\n2000            1325            1325\n2000            1761            1761\n2000           2000            2000\nchecking captured packets on all configured ports ...\nport name       expected        udp packets\np1              1000            1000\np2              1000            1000\ntest passed !\n```\n\n\n",
  "docs_url": null,
  "keywords": "trex testing open traffic generator automation",
  "license": "mit",
  "name": "snappi-trex",
  "package_url": "https://pypi.org/project/snappi-trex/",
  "project_url": "https://pypi.org/project/snappi-trex/",
  "project_urls": {
    "Homepage": "https://github.com/open-traffic-generator"
  },
  "release_url": "https://pypi.org/project/snappi-trex/0.1.6/",
  "requires_dist": [
    "snappi (==0.3.20) ; extra == 'dev'",
    "pytest ; extra == 'dev'",
    "flake8 (==3.8.4) ; extra == 'dev'",
    "dpkt (==1.9.4) ; extra == 'dev'"
  ],
  "requires_python": ">=3, <4",
  "summary": "the trex open traffic generator python package",
  "version": "0.1.6",
  "releases": [],
  "developers": [
    "frederick.zhang@keysight.com",
    "fredpower44"
  ],
  "kwds": "alerts badge hello_snappi_trex trex badges",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_snappi_trex",
  "homepage": "https://github.com/open-traffic-generator",
  "release_count": 72,
  "dependency_ids": [
    "pypi_dpkt",
    "pypi_flake8",
    "pypi_pytest",
    "pypi_snappi"
  ]
}