{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu library or lesser general public license (lgpl)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "..\n    this file is part of lazr.batchnavigator.\n\n    lazr.batchnavigator is free software: you can redistribute it and/or\n    modify it under the terms of the gnu lesser general public license as\n    published by the free software foundation, version 3 of the license.\n\n    lazr.batchnavigator is distributed in the hope that it will be useful, but\n    without any warranty; without even the implied warranty of merchantability\n    or fitness for a particular purpose. see the gnu lesser general public\n    license for more details.\n\n    you should have received a copy of the gnu lesser general public license\n    along with lazr.batchnavigator. if not, see\n    <http://www.gnu.org/licenses/>.\n\nbatch navigation\n****************\n\nbatch navigation provides a way to navigate batch results in a web\npage by providing url links to the next, previous and numbered pages\nof results.\n\nit uses four query/post arguments to control the batching:\n\n  - memo: a record of the underlying storage index pointer for the position of\n    the batch.\n  - direction: indicates whether the memo is at the start or end of the batch.\n  - start: cosmetic - used to calculate the apparent location (but note that\n    due to the concurrent nature of repeated visits to batches that the\n    true offset may differ - however the collection won't skip or show\n    items twice. for compatibility with saved urls, if memo and\n    direction are both missing then start is used to do list slicing\n    into the collection.\n  - batch: controls the amount of items we are showing per batch. it will only\n    appear if it's different from the default value set when the batch\n    is created.\n\nthese values can be overriden in the request, unless you also pass\nforce_start=true, which will make the start argument (again, defaulting to 0)\nalways chosen.\n\nimports:\n\n    >>> from lazr.batchnavigator import batchnavigator, listrangefactory\n    >>> from zope.publisher.browser import testrequest\n    >>> from zope.publisher.http import httpcharsets\n    >>> from zope.component import getsitemanager\n    >>> sm = getsitemanager()\n    >>> sm.registeradapter(httpcharsets)\n\n    >>> def build_request(query_string_args=none, method='get'):\n    ...   if query_string_args is none:\n    ...       query_string = ''\n    ...   else:\n    ...       if getattr(query_string_args, 'items', none) is not none:\n    ...           query_string_args = query_string_args.items()\n    ...       query_string = \"&\".join(\n    ...           [\"%s=%s\" % (k,v) for k,v in query_string_args])\n    ...   request = testrequest(server_url='http://www.example.com/foo',\n    ...                                  method=method,\n    ...                                  environ={'query_string': query_string})\n    ...   request.processinputs()\n    ...   return request\n\na sample request object:\n\nsome sample data.\n\n    >>> reindeer = ['dasher', 'dancer', 'prancer', 'vixen', 'comet',\n    ...             'cupid', 'donner', 'blitzen', 'rudolph']\n\nbecause slicing large collections can be very expensive, batchnavigator offers\na non-slice protocol for determining the edge of batches. the range_factory\nsupplies an object implementing irangefactory and manages this protocol.\nlistrangefactory is a simple included implementation which batchnavigator will\nuse if no range_factory is supplied.\n\n    >>> _ = batchnavigator(reindeer, build_request(),\n    ...     range_factory=listrangefactory(reindeer))\n\nfor the examples in the documentation we let batchnavigator construct a\nrange_factory implicitly:\n\n    >>> safe_reindeer = reindeer\n    >>> safe_reindeer_batch_navigator = batchnavigator(\n    ...     safe_reindeer, build_request(), size=3)\n\nan important feature of lazr.batchnavigator is its reluctance to\ninvoke len() on an underlying data set. len() can be an expensive\noperation that provides little benefit, so this library tries hard to\navoid calling len() unless it's absolutely necessary. to show this\noff, we'll define a subclass of python's list type that explodes when\nlen() is invoked on it.\n\n    >>> class listwithexplosivelen(list):\n    ...     \"\"\"a list subclass that doesn't like its len() being called.\"\"\"\n    ...     def __len__(self):\n    ...         raise runtimeerror\n\nunless otherwise stated, we will use this list exclusively throughout\nthis test, to verify that len() is never called unless we want it to\nbe.\n\n    >>> explosive_reindeer = listwithexplosivelen(reindeer)\n    >>> reindeer_batch_navigator = batchnavigator(\n    ...     explosive_reindeer, build_request(), size=3)\n\nthe batchnavigator implements ibatchnavigator. we need to use the\n'safe' batch navigator here, because verifyobject probes all methods\nof the object it's passed, including __len__.\n\n    >>> from zope.interface.verify import verifyobject\n    >>> from lazr.batchnavigator.interfaces import ibatchnavigator\n\n    >>> verifyobject(ibatchnavigator, safe_reindeer_batch_navigator)\n    true\n\nthe batchnavigator class provides ibatchnavigatorfactory.  this can be used\nto register a batch navigator factory as a utility, for instance.\n\n    >>> from lazr.batchnavigator.interfaces import ibatchnavigatorfactory\n\n    >>> verifyobject(ibatchnavigatorfactory, batchnavigator)\n    true\n\nyou can ask the navigator for the chunk of results currently being shown\n(e.g. to iterate over them for rendering in zpt):\n\n    >>> list(reindeer_batch_navigator.currentbatch())\n    ['dasher', 'dancer', 'prancer']\n\nyou can ask for the first, previous, next and last results' links:\n\n    >>> reindeer_batch_navigator.firstbatchurl()\n    ''\n    >>> reindeer_batch_navigator.prevbatchurl()\n    ''\n    >>> reindeer_batch_navigator.nextbatchurl()\n    'http://www.example.com/foo?memo=3&start=3'\n\nthere's no way to get the url to the final batch without knowing the\nlength of the entire list, so we'll use the safe batch navigator to\ndemonstrate lastbatchurl():\n\n    >>> safe_reindeer_batch_navigator.lastbatchurl()\n    'http://www.example.com/foo?direction=backwards&start=6'\n\nthe next link will be empty when there are no further results:\n\n    >>> request = build_request({\"start\": \"3\", \"batch\": \"20\"})\n    >>> last_reindeer_batch_navigator = batchnavigator(reindeer, request=request)\n    >>> last_reindeer_batch_navigator.nextbatchurl()\n    ''\n\nthe first and previous link should appear even when we start at a point between 0\nand the batch size:\n\n    >>> request = build_request({\"start\": \"2\", \"batch\": \"3\"})\n    >>> last_reindeer_batch_navigator = batchnavigator(reindeer, request=request)\n\nhere, we can see too that the batch argument appears as part of the url.\nthat's because the request asked for a different size than the default\none when we create the batch object, by default, it's 5.\n\n    >>> last_reindeer_batch_navigator.firstbatchurl()\n    'http://www.example.com/foo?batch=3'\n\n    >>> last_reindeer_batch_navigator.prevbatchurl()\n    'http://www.example.com/foo?batch=3&direction=backwards&memo=2'\n\nthis all works with other values in the query string, too:\n\n    >>> request = build_request({'fnorb': 'bar',\n    ...                          'start': '3',\n    ...                          'batch': '3'})\n    >>> reindeer_batch_navigator_with_qs = batchnavigator(\n    ...     reindeer, request, size=3)\n    >>> safe_reindeer_batch_navigator_with_qs = batchnavigator(\n    ...     safe_reindeer, request, size=3)\n\n\nin this case, we created the batchnavigator with a default size of '3' and\nthe request is asking exactly that number of items per batch, and thus, we\ndon't need to show 'batch' as part of the url.\n\n    >>> reindeer_batch_navigator_with_qs.firstbatchurl()\n    'http://www.example.com/foo?fnorb=bar'\n    >>> reindeer_batch_navigator_with_qs.prevbatchurl()\n    'http://www.example.com/foo?fnorb=bar&direction=backwards&memo=3'\n    >>> reindeer_batch_navigator_with_qs.nextbatchurl()\n    'http://www.example.com/foo?fnorb=bar&memo=6&start=6'\n\n(again, there's no way to get the last batch without knowing the size\nof the entire list.)\n\n    >>> safe_reindeer_batch_navigator_with_qs.lastbatchurl()\n    'http://www.example.com/foo?fnorb=bar&direction=backwards&start=6'\n\nthe ``force_start`` argument allows you to ignore the start value in the\nrequest.  this can be useful when, for instance, a filter has changed, and the\ndesired behavior is to restart at 0.\n\n    >>> reindeer_batch_navigator_with_qs = batchnavigator(\n    ...     reindeer, request, size=3, force_start=true)\n    >>> reindeer_batch_navigator_with_qs.currentbatch().start\n    0\n    >>> reindeer_batch_navigator_with_qs.nextbatchurl()\n    'http://www.example.com/foo?fnorb=bar&memo=3&start=3'\n    >>> reindeer[:3] == list(reindeer_batch_navigator_with_qs.currentbatch())\n    true\n\nwe ensure that batch arguments supplied in the url are observed\nfor post operations too:\n\n    >>> request = build_request({'fnorb': 'bar',\n    ...                          'start': '3',\n    ...                          'batch': '3'}, method='post')\n    >>> reindeer_batch_navigator_post_with_qs = batchnavigator(\n    ...     reindeer, request)\n\n    >>> reindeer_batch_navigator_post_with_qs.start\n    3\n    >>> reindeer_batch_navigator_post_with_qs.nextbatchurl()\n    'http://www.example.com/foo?fnorb=bar&batch=3&memo=6&start=6'\n\nwe ensure that multiple size and batch arguments supplied in the url don't\nblow up the application.  the first one is preferred.\n\n    >>> request = build_request(\n    ...     [('batch', '1'), ('batch', '7'), ('start', '2'), ('start', '10')])\n    >>> navigator = batchnavigator(reindeer, request=request)\n    >>> navigator.nextbatchurl()\n    'http://www.example.com/foo?batch=1&memo=3&start=3'\n\nthe batch argument must be positive.  other numbers are ignored, and the\ndefault batch size is used instead.\n\n    >>> from six.moves.urllib.parse import parse_qs\n    >>> request = build_request({'batch': '0'})\n    >>> navigator = batchnavigator(range(99), request=request)\n    >>> print('batch' in parse_qs(navigator.nextbatchurl()))\n    false\n\n    >>> request = build_request({'batch': '-1'})\n    >>> navigator = batchnavigator(range(99), request=request)\n    >>> print('batch' in parse_qs(navigator.nextbatchurl()))\n    false\n\n\n=============\nempty batches\n=============\n\nyou can also create an empty batch that will not have any items:\n\n    >>> null_batch_navigator = batchnavigator(\n    ...     none, build_request(), size=3)\n    >>> null_batch_navigator.firstbatchurl()\n    ''\n    >>> null_batch_navigator.nextbatchurl()\n    ''\n    >>> null_batch_navigator.prevbatchurl()\n    ''\n    >>> null_batch_navigator.lastbatchurl()\n    ''\n\n    >>> null_batch_navigator = batchnavigator(\n    ...     [], build_request(), size=3)\n    >>> null_batch_navigator.firstbatchurl()\n    ''\n    >>> null_batch_navigator.nextbatchurl()\n    ''\n    >>> null_batch_navigator.prevbatchurl()\n    ''\n    >>> null_batch_navigator.lastbatchurl()\n    ''\n\ntodo:\n\n  - blowing up when start is beyond end\n  - orphans\n  - overlap\n\n====================================\nsupporting results without a __len__\n====================================\n\nsome result objects do not implement __len__ because generally python code\nassumes that __len__ is cheap. sqlobject and storm result sets both have this\nbehavior, for instance, so that it is cleat that getting the length is a non-\ntrivial operation.\n\nto support these objects, the batch looks for __len__ on the result set.  if\nit does not exist, it adapts the result to\nzope.interface.common.sequence.ifinitesequence and uses that __len__.\n\n    >>> class exampleresultset(object):\n    ...     def __init__(self, results):\n    ...         self.stub_results = results\n    ...     def count(self):\n    ...         # imagine this actually returned\n    ...         return len(self.stub_results)\n    ...     def __getitem__(self, ix):\n    ...         return self.stub_results[ix] # also works with slices\n    ...     def __iter__(self):\n    ...         return iter(self.stub_results)\n    ...\n    >>> from zope.interface import implementer\n    >>> from zope.component import adapter, getsitemanager\n    >>> from zope.interface.common.sequence import ifinitesequence\n    >>> @adapter(exampleresultset)\n    ... @implementer(ifinitesequence)\n    ... class exampleadapter(exampleresultset):\n    ...     def __len__(self):\n    ...         return self.stub_results.count()\n    ...\n    >>> sm = getsitemanager()\n    >>> sm.registeradapter(exampleadapter)\n    >>> example = exampleresultset(safe_reindeer)\n    >>> example_batch_navigator = batchnavigator(\n    ...     example, build_request(), size=3)\n    >>> example_batch_navigator.currentbatch().total()\n    9\n\n========================\nonly gets what is needed\n========================\n\nit's also important for performance of batching large result sets that the\nbatch only gets a slice of the results, rather than accessing the entirety.\n\n    >>> class exampleresultset(exampleresultset):\n    ...     def __init__(self, results):\n    ...         super(exampleresultset, self).__init__(results)\n    ...         self.getitem_history = []\n    ...     def __getitem__(self, ix):\n    ...         self.getitem_history.append(ix)\n    ...         return super(exampleresultset, self).__getitem__(ix)\n    ...\n\n    >>> example = exampleresultset(reindeer)\n    >>> example_batch_navigator = batchnavigator(\n    ...     example, build_request(), size=3)\n    >>> reindeer[:3] == list(example_batch_navigator.currentbatch())\n    true\n    >>> example.getitem_history\n    [slice(0, 4, none)]\n\nnote that although the batch is of the size requested, the underlying\nlist contains one more item than is necessary. this is to make it easy\nto determine whether a given batch is the final one in the list,\nwithout having to explicitly look up the length of the list\n(potentially an expensive operation).\n\n\n=========================\nadding callback functions\n=========================\n\nsometimes it is useful to have a function called with the batched\nvalues once they have been determined.  this is the case when there\nare subsequent queries that are needed to be executed for each batch,\nand it is undesirable or overly expensive to execute the query for\nevery value in the entire result set.\n\nthe callback function must define two parameters.  the first is the\nbatch navigator object itself, and the second it the current batch.\nthe callback function is called once and only once when the\nbatchnavigator is constructed, and the current batch is determined.\n\n    >>> def print_callback(context, batch):\n    ...     for item in batch:\n    ...         print(item)\n\n    >>> reindeer_batch_navigator = batchnavigator(\n    ...     reindeer, build_request(), size=3, callback=print_callback)\n    dasher\n    dancer\n    prancer\n\n    >>> request = build_request({\"start\": \"3\", \"batch\": \"20\"})\n    >>> last_reindeer_batch_navigator = batchnavigator(\n    ...     reindeer, request=request, callback=print_callback)\n    vixen\n    comet\n    cupid\n    donner\n    blitzen\n    rudolph\n\nmost likely, the callback function will be bound to a view class.\nby providing the batch navigator itself as the context for the\ncallback allows the addition of extra member variables.  this is\nuseful as the batchnavigator becomes the context in page templates\nthat are batched.\n\n    >>> class reindeerview:\n    ...     def constructreindeerfromatoms(self, context, batch):\n    ...         # some significantly slow process\n    ...         view.built_reindeer = list(batch)\n    ...     def batchedreindeer(self):\n    ...         return batchnavigator(\n    ...            reindeer, build_request(), size=3,\n    ...            callback=self.constructreindeerfromatoms)\n\n    >>> view = reindeerview()\n    >>> batch_navigator = view.batchedreindeer()\n    >>> print(view.built_reindeer)\n    ['dasher', 'dancer', 'prancer']\n    >>> print(list(batch_navigator.currentbatch()))\n    ['dasher', 'dancer', 'prancer']\n\n==================\nmaximum batch size\n==================\n\nsince the batch size is exposed in the url, it's possible for users to\ntweak the batch parameter to retrieve more results. since that may\npotentially exhaust server resources, an upper limit is put on the batch\nsize. if the requested batch parameter is higher than this, an\ninvalidbatchsizeerror is raised.\n\n    >>> from lazr.batchnavigator.interfaces import invalidbatchsizeerror\n\n    >>> class demobatchnavigator(batchnavigator):\n    ...     max_batch_size = 5\n    ...\n    >>> request = build_request({\"start\": \"0\", \"batch\": \"20\"})\n    >>> test_raises(\n    ...     invalidbatchsizeerror, demobatchnavigator,\n    ...     reindeer, request=request)\n    maximum for \"batch\" parameter is 5.\n\n==============\nurl parameters\n==============\n\nnormally, any parameters passed in the current page's url are\nreproduced in the batch navigator's links.  a \"transient\" parameter is\none that was only relevant for the current page request and shouldn't be\npassed on to subsequent ones.\n\nin this next batch navigator, two parameters occur in the page's url:\n\"noisy\" and \"quiet.\"\n\n    >>> request_parameters = {\n    ...     'quiet': 'ssht',\n    ...     'noisy': 'hello',\n    ...     }\n\n    >>> request_with_parameters = build_request(request_parameters)\n\none parameter, \"quiet,\" is transient.  there is another transient\nparameter called \"absent,\" but it's not passed in our ongoing page\nrequest.\n\n    >>> def build_navigator(list):\n    ...     return batchnavigator(\n    ...         list, request_with_parameters, size=3,\n    ...         transient_parameters=['quiet', 'absent'])\n    >>> navigator_with_parameters = build_navigator(reindeer)\n    >>> safe_navigator_with_parameters = build_navigator(safe_reindeer)\n\nof these three parameters, only \"noisy\" recurs in the links produced by\nthe batch navigator.\n\n    >>> navigator_with_parameters.nextbatchurl()\n    'http://www.example.com/foo?noisy=hello&memo=3&start=3'\n    >>> safe_navigator_with_parameters.lastbatchurl()\n    'http://www.example.com/foo?noisy=hello&direction=backwards&start=6'\n\nthe transient parameter is omitted, and the one that was never passed in\nin the first place does not magically appear.\n\n==============\nbatch headings\n==============\n\nthe batched values are usually one kind of object such as bugs. the\nbatchnavigator's heading property contains a description of the objects\nfor display.\n\n    >>> safe_reindeer_batch_navigator.heading\n    'results'\n\nthere is a special case for when there is only one item in the batch,\nthe singular version of the heading is returned.\n\n    >>> navigator = batchnavigator(['only-one'], request=request)\n    >>> navigator.heading\n    'result'\n\n(accessing .heading causes len() to be called on the underlying list,\nwhich is why we have to use the safe batch navigator. in theory, this\ncould be optimized, but there's no real point, since the heading is\ninvariably preceded by the actual length of the underlying list,\neg. \"10 results\". since len() is called anyway, and its value is\ncached, a second len() won't hurt performance.)\n\nthe heading can be set by passing a singular and a plural version of\nthe heading. the batch navigation will return the appropriate\nheader based on the total items in the batch.\n\n    >>> navigator = batchnavigator(safe_reindeer, request=request)\n    >>> navigator.setheadings('bug', 'bugs')\n    >>> navigator.heading\n    'bugs'\n\n    >>> navigator = batchnavigator(['only-one'], request=request)\n    >>> navigator.setheadings('bug', 'bugs')\n    >>> navigator.heading\n    'bug'\n\n(cleanup)\n\n    >>> sm.unregisteradapter(httpcharsets)\n    true\n    >>> sm.unregisteradapter(exampleadapter)\n    true\n\n\n============================\nnews for lazr.batchnavigator\n============================\n\n2.0.0 (2022-11-30)\n==================\n\n- drop support for python 2.7.\n- declare support for python 3.9, 3.10 and 3.11.\n- add ``pre-commit`` configuration.\n- publish documentation on read the docs.\n- apply ``black``, ``isort`` and ``flake8`` via ``pre-commit``.\n- apply inclusive naming via the woke pre-commit hook.\n\n1.3.1 (2021-09-13)\n==================\n\n- adjust versioning strategy to avoid importing pkg_resources, which is slow\n  in large environments.\n\n1.3.0 (2019-11-04)\n==================\n\n- switch from buildout to tox.\n- add python 3 support.\n\n1.2.11 (2015-04-09)\n===================\n\n- save a query if the slice is of the form [x:x].\n\n1.2.10 (2011-09-14)\n===================\n\n- delegate the calculation of the rough length of a result set to\n  irangefactory.\n\n1.2.9 (2011-08-25)\n==================\n\n- when a backwards batch is at first too short and when another chunk\n  from the result set is added, _batch,sliced_list() does no longer\n  use the memo value for the already retrived chunk.\n\n- don't use the parameter start to determine if a previous/next batch\n  exists; don't rely on len(resultset) and  to determine the real size\n  of a batch.\n\n- avoid negative start index on empty result sets.\n\n1.2.7 (2011-07-18)\n==================\n\n- retrieve slices of the result set in class _batch only via methods\n  of the range factory.\n\n1.2.6 (2011-07-28)\n==================\n\n- fixed an error in handling backwards batches which return less elements\n  than expected.\n- url-encode all query parameters in batchnavigator.generatebatchurl()\n\n1.2.5 (2011-07-13)\n==================\n\n- permit changing all variable names with a single prefix.\n\n1.2.4 (2011-04-11)\n==================\n\n- permit overriding determinesize to control how the batch default and concrete\n  sizes are determined in subclasses.\n- listify (once we have sliced) rather than assuming batched slices will honour\n  the complete list protocol.\n\n1.2.3 (2011-04-06)\n==================\n\n- add irangefactory and the ability to use backend database hints for efficient\n  retrieval of pages.\n\n- remove terrible-scaling getbatchurls method.\n\n1.2.2 (2010-08-19)\n==================\n\n- make len() cheap to call when the current batch is the last (or\n  only) batch.\n\n- avoid calling len() when generating navigator urls.\n\n1.2.1 (2010-08-12)\n==================\n\n- fix a bug in the len() of a batch when the batch had previously been\n  iterated over\n\n1.2.0 (2010-08-05)\n==================\n\n- avoid calling len() on the underlying sequence when possible\n- return none for endnumber when the batch is out of range\n\n1.1.1 (2010-05-10)\n==================\n\n- ignore negative batch sizes\n\n1.1 (2009-08-31)\n================\n\n- remove build dependencies on bzr and egg_info\n\n- remove sys.path hack in setup.py for __version__\n\n1.0 (2009-03-24)\n================\n\n- initial release on pypi\n",
  "docs_url": null,
  "keywords": "",
  "license": "lgpl v3",
  "name": "lazr.batchnavigator",
  "package_url": "https://pypi.org/project/lazr.batchnavigator/",
  "project_url": "https://pypi.org/project/lazr.batchnavigator/",
  "project_urls": {
    "Documentation": "https://lazrbatchnavigator.readthedocs.io/en/latest/",
    "Download": "https://launchpad.net/lazr.batchnavigator/+download",
    "Homepage": "https://launchpad.net/lazr.batchnavigator",
    "Issue Tracker": "https://bugs.launchpad.net/lazr.batchnavigator",
    "Source": "https://code.launchpad.net/lazr.batchnavigator"
  },
  "release_url": "https://pypi.org/project/lazr.batchnavigator/2.0.0/",
  "requires_dist": [
    "setuptools",
    "six",
    "zope.cachedescriptors",
    "zope.interface (>=3.6.0)",
    "importlib-metadata ; python_version < \"3.8\"",
    "Sphinx ; extra == 'docs'",
    "testtools ; extra == 'test'",
    "zope.publisher ; extra == 'test'",
    "zope.testrunner ; extra == 'test'"
  ],
  "requires_python": "",
  "summary": "a helper to navigate batched results in a web page.",
  "version": "2.0.0",
  "releases": [],
  "developers": [
    "lazr-users@lists.launchpad.net",
    "lazr_developers"
  ],
  "kwds": "batchedreindeer batchnavigator batch _batch batching",
  "license_kwds": "lgpl v3",
  "libtype": "pypi",
  "id": "pypi_lazr.batchnavigator",
  "homepage": "https://launchpad.net/lazr.batchnavigator",
  "release_count": 14,
  "dependency_ids": [
    "pypi_importlib_metadata",
    "pypi_setuptools",
    "pypi_six",
    "pypi_sphinx",
    "pypi_testtools",
    "pypi_zope.cachedescriptors",
    "pypi_zope.interface",
    "pypi_zope.publisher",
    "pypi_zope.testrunner"
  ]
}