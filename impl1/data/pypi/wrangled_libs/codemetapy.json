{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: gnu general public license v3 (gplv3)",
    "operating system :: posix",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development"
  ],
  "description": "[![project status: active -- the project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)\n[![github build](https://github.com/proycon/codemetapy/actions/workflows/codemetapy.yml/badge.svg?branch=master)](https://github.com/proycon/codemetapy/actions/)\n[![github release](https://img.shields.io/github/release/proycon/codemetapy.svg)](https://github.com/proycon/codemetapy/releases/)\n[![latest release in the python package index](https://img.shields.io/pypi/v/codemetapy)](https://pypi.org/project/codemetapy/)\n \n# codemetapy\n\ncodemetapy is a command-line tool to work with the [codemeta ](https://codemeta.github.io) software metadata standard.\ncodemeta builds upon [schema.org](https://schema.org) and defines a vocabulary for describing software source code. it\nmaps various existing metadata standards to a unified vocabulary.\n\nfor more general information about the codemeta project for defining\nsoftware metadata, see <https://codemeta.github.io>. in particular, new\nusers might want to start with the user guide, while those looking to\nlearn more about json-ld and consuming existing codemeta files should\nsee the developer guide.\n\nusing codemetapy you can generate a `codemeta.json` file, which\nserialises using [json-ld](https://json-ld.org) , for\nyour software. at the moment it supports conversions from the following\nexisting metadata specifications:\n\n* python distutils/pip packages (`setup.py`/`pyproject.toml`)\n* java/maven packages (`pom.xml`)\n* nodejs packages (`package.json`)\n* debian package (`apt show` output)\n* github api (when passed a github url)\n* gitlab api (when passed a gitlab url)\n* web sites/services (see the section on software types and service below):\n    * simple metadata from html `<meta>` elements.\n    * script blocks using `application/json+ld`\n\nit can also read and manipulate existing `codemeta.json` files as well\nas parse simple authors/contributors files. one of the most notable\nfeatures of codemetapy is that it allows chaining to successively update\na metadata description based on multiple sources. codemetapy is used in\nthat way by the [codemeta-harvester](https://github.com/proycon/codemeta-harvester). \n\n**note:** if you are looking for an all-in-one solution to automatically\ngenerate a `codemeta.json` for your project, then\n*[codemeta-harvester](https://github.com/proycon/codemeta-harvester) is the\nbest place to start*. it is a higher-level tool that automatically invokes\ncodemetapy on various sources it can automatically detect, and combined those into\na single codemeta representation.\n\n## installation\n\n`pip install codemetapy`\n\n## usage\n\nquery and convert any installed python package:\n\n`$ codemetapy somepackage`\n\noutput will be to standard output by default, to write it to an output\nfile instead, do either:\n\n`$ codemetapy somepackage > codemeta.json`\n\nor use the `-o` parameter:\n\n`$ codemetapy -o codemeta.json somepackage`\n\nif you are in the current working directory of any python project and\nthere is a `setup.py`or `pyproject.toml`, then you can simply call `codemetapy` without\narguments to output codemeta for the project. codemetapy will\nautomatically run `python setup.py egg_info` if needed and parse it's output to\nfacilitate this:\n\n`$ codemetapy`\n\nthe tool also supports adding properties through parameters:\n\n`$ codemetapy --developmentstatus active somepackage > codemeta.json`\n\nto read an existing codemeta.json and extend it:\n\n`$ codemetapy -o codemeta.json codemeta.json somepackage`\n\nor even:\n\n`$ codemetapy -o codemeta.json codemeta.json codemeta2.json codemeta3.json`\n\nthis makes use of an important characteristic of codemetapy which is *composition*. when you specify multiple input sources, they will be interpreted as referring to the same resource.\nproperties (on `schema:softwaresourcecode`) in the later resources will *overwrite* earlier properties. so if `codemeta3.json` specifies authors, all authors that were specified in `codemeta2.json` are lost rather than merged and the end result will have the authors from `codemeta3.json`. however, if `codemeta2.json` has a property that was not in `codemeta3.json`, say `deveopmentstatus`, then that will make it to the end rsult. in other words, the latest source always takes precedence. any non-overlapping properties will be be merged. this functionality is heavily relied on by the higher-level tool [codemeta-harvester](https://github.com/proycon/codemeta-harvester).\n\nif you want to start from scratch and build using command line parameters, use `/dev/null` as input, and make sure to pass some identifier and code repository:\n\n`$ codemetapy --identifier some-id --coderepository https://github.com/my/code /dev/null > codemeta.json`\n\nthis tool can also deal with debian packages by parsing the output of\n`apt show` (albeit limited):\n\n`$ apt show somepackage | codemetapy -i debian -`\n\nhere `-` represents standard input, which enables you to use piping\nsolutions on a unix shell, `-i` denotes the input types, you can chain\nas many as you want. the number of input types specifies must correspond\nexactly to the number of input sources (the positional arguments).\n\n\n## some notes on vocabulary\n\nfor `codemeta:developmentstatus`, codemetapy attempts to\nassign full [repostatus](https://www.repostatus.org/) uris whenever\npossible for `schema:license`, full [spdx](https://spdx.org) uris are used where possible.\n\n## identifiers\n\nwe distinguish two types of identifiers, first there is the uri or [iri](https://www.w3.org/tr/rdf11-concepts/#section-iris) \nthat identifies rdf resources. it is a globally unique identifier and often looks like a url. \n\ncodemetapy will assign new uris for resources if and only if you pass a base uri using ``--baseuri``. moreover, if you set this, codemetapy will *forcibly* set uris over any existing ones, effectively assigning new identifiers. the previous identifier will then be covered via the `owl:sameas` property instead. this allows you to ownership of all uris.  internally, codemetapy will create uris for everything even if you don't specified a base uri (even for blank nodes), but these uris are stripped again upon serialisation to json-ld.\n\nthe second identifier is the [schema:identifier](https://schema.org/identifier), of which there may even be multiple.\ncodemetapy typically expects such an identifier to be a simple unspaced string holding a name for software. for example, a python package name would make a good identifier. if this property is present, codemetapy will use it when generating uris.\nthe `schema:identifier` property can be contrasted with `schema:name`, which is the human readable form of the name and may be more elaborate.\nthe identifier is typically also used for other identifiers (such as dois, isbns, etc), which should come in the following form:\n\n```json\n\"identifier:\" {\n    \"@type\": \"propertyvalue\",\n    \"propertyid\": \"doi\",\n    \"value\": \"10.5281/zenodo.6882966\"\n}\n```\n\nbut short-hand forms such as ``doi:10.5281/zenodo.6882966`` or as a url like `https://doi.org/10.5281/zenodo.6882966` are also recognised by this library.\n\n\n## software types and services\n\ncodemetapy (since 2.0) implements an extension to codemeta that allows\nlinking the software source code to the actual instantiation of the\nsoftware, with explicit regard for the interface type. this is done via\nthe `schema:targetproduct` property, which takes as range a\n`schema:softwareapplication`, `schema:webapi`,\n`schema:website` or any of the extra types defined in\n<https://github.com/softwareunderstanding/software_types/> . this was\nproposed in [this issue](https://github.com/codemeta/codemeta/issues/271)\n\nthis extension is enabled by default and can be disabled by setting the\n`--strict` flag.\n\nwhen you pass codemetapy a url it will assume this is where the software\nis run as a service, and attempt to extract metadata from the site and\nencode is via `targetproduct`. for example, here we read an\nexisting `codemeta.json` and extend it with some place where\nit is instantiated as a service:\n\n`$ codemetapy codemeta.json https://example.org/`\n\nif served html, codemetapy will use your `<script>` block\nusing `application/json+ld` if it provides a valid software types (as\nmentioned above). for other html, codemetapy will simply extract some\nmetadata from html `<meta>` elements. content negotation will be used\nand the we favour json+ld, json and even yaml and xml over html.\n\n(note: the older entypoint extension from before codemetapy 2.0 is now deprecated)\n\n## graph\n\nyou can use codemetapy to generate one big knowledge graph expressing\nmultiple codemeta resources using the `--graph` parameter:\n\n`$ codemetapy --graph resource1.json resource2.json`\n\nthis will produce json-ld output with multiple resources in the graph.\n\n## github api\n\ncodemetapy can make use of the github api to query metdata from github,\nbut this allows only limited anonymous requests before you hit a limit.\nto allow more requests, please set the environment variable\n`$github_token` to a [personal access\ntoken](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\n\n## gitlab api\n\ncodemetapy can make use of the gitlab api to query metdata from gitlab,\nbut this allows only limited anonymous requests before you hit a limit.\nto allow more requests, please set the environment variable\n`$gitlab_token` to a [personal access\ntoken](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html).\n\n## integration in setup.py\n\nyou can integrate `codemeta.json` generation in your project's\n`setup.py`, this will add an extra `python setup.py codemeta` command\nthat will generate a new metadata file or update an already existing\nmetadata file. note that this must be run *after*\n`python setup.py install` (or `python setup.py develop`).\n\nto integrate this, add the following to your project's `setup.py`:\n\n```python\ntry:\n    from codemeta.codemeta import codemetacommand\n    cmdclass={\n        'codemeta': codemetacommand,\n    }\nexcept importerror:\n    cmdclass={}\n```\n\nand in your `setup()` call add the parameter:\n\n```python\ncmdclass=cmdclass\n```\n\nthis will ensure your `setup.py` works in all cases, even if codemetapy\nis not installed, and that the command will be available if codemetapy\nis available.\n\nif you want to ship your package with the generated `codemeta.json`,\nthen simply add a line saying `codemeta.json` to the file `manifest.in`\nin the root of your project.\n\n## acknowledgements\n\nthis work is conducted at the [knaw humanities cluster](https://huc.knaw.nl/)'s\n[digital infrastructure department](https://di.huc.knaw.nl/) in the scope of the \n[clariah](https://www.clariah.nl) project (clariah-plus, nwo grant 184.034.023) as\npart of the fair tool discovery track of the shared development roadmap.\n",
  "docs_url": null,
  "keywords": "software metadata,codemeta,schema.org,rdf,linked data",
  "license": "gpl-3.0-only",
  "name": "codemetapy",
  "package_url": "https://pypi.org/project/CodeMetaPy/",
  "project_url": "https://pypi.org/project/CodeMetaPy/",
  "project_urls": {
    "Homepage": "https://github.com/proycon/codemetapy"
  },
  "release_url": "https://pypi.org/project/CodeMetaPy/2.5.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "generate and manage codemeta software metadata",
  "version": "2.5.2",
  "releases": [],
  "developers": [
    "maarten_van_gompel",
    "proycon@anaproy.nl"
  ],
  "kwds": "codemetapy codemeta codemeta3 github codemeta2",
  "license_kwds": "gpl-3.0-only",
  "libtype": "pypi",
  "id": "pypi_codemetapy",
  "homepage": "https://github.com/proycon/codemetapy",
  "release_count": 31,
  "dependency_ids": []
}