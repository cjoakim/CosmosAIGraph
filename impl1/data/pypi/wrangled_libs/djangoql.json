{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "djangoql\n========\n\n.. image:: https://github.com/ivelum/djangoql/workflows/tests/badge.svg\n        :target: https://github.com/ivelum/djangoql/actions?query=workflow%3atests\n\nadvanced search language for django, with auto-completion. supports logical\noperators, parenthesis, table joins, and works with any django model. tested on\npython 2.7, 3.5 - 3.11, django 1.8 - 4.2. the auto-completion feature has been\ntested in chrome, firefox, safari, ie9+.\n\nsee a video: `djangoql demo <https://youtu.be/okvff4dhzb8>`_\n\n.. image:: https://raw.githubusercontent.com/ivelum/djangoql/master/djangoql/static/djangoql/img/completion_example_scaled.png\n\ndjangoql is used by:\n\n|logo1| |logo2| |logo3| |logo4|\n\n.. |logo1| image:: https://raw.githubusercontent.com/ivelum/djangoql/master/assets/redhat.svg\n   :width: 22%\n   :target: https://www.redhat.com\n\n.. |logo2| image:: https://raw.githubusercontent.com/ivelum/djangoql/master/assets/teamplify.svg\n   :width: 22%\n   :target: https://teamplify.com\n\n.. |logo3| image:: https://raw.githubusercontent.com/ivelum/djangoql/master/assets/police1.svg\n   :width: 22%\n   :target: https://www.police1.com\n\n.. |logo4| image:: https://raw.githubusercontent.com/ivelum/djangoql/master/assets/15-five.svg\n   :width: 22%\n   :target: https://www.15five.com\n\nis your project using djangoql? please submit a pr and let us know!\n\ncontents\n--------\n\n* `installation`_\n* `add it to your django admin`_\n* `using djangoql with the standard django admin search`_\n* `language reference`_\n* `djangoql schema`_\n* `custom search fields`_\n* `can i use it outside of django admin?`_\n* `using completion widget outside of django admin`_\n\ninstallation\n------------\n\n.. code:: shell\n\n    $ pip install djangoql\n\nadd ``'djangoql'`` to ``installed_apps`` in your ``settings.py``:\n\n.. code:: python\n\n    installed_apps = [\n        ...\n        'djangoql',\n        ...\n    ]\n\n\nadd it to your django admin\n---------------------------\n\nadding ``djangoqlsearchmixin`` to your model admin will replace the standard\ndjango search functionality with djangoql search. example:\n\n.. code:: python\n\n    from django.contrib import admin\n\n    from djangoql.admin import djangoqlsearchmixin\n\n    from .models import book\n\n\n    @admin.register(book)\n    class bookadmin(djangoqlsearchmixin, admin.modeladmin):\n        pass\n\n\nusing djangoql with the standard django admin search\n----------------------------------------------------\n\ndjangoql will recognize if you have defined ``search_fields`` in your modeladmin\nclass, and doing so will allow you to choose between an advanced search with\ndjangoql and a standard django search (as specified by search fields). example:\n\n.. code:: python\n\n    @admin.register(book)\n    class bookadmin(djangoqlsearchmixin, admin.modeladmin):\n        search_fields = ('title', 'author__name')\n\nfor the example above, a checkbox that controls search mode will appear near\nthe search input. if the checkbox is on, then djanqoql search is used. there is\nalso an option that controls if that checkbox is enabled by default -\n``djangoql_completion_enabled_by_default`` (set to ``true`` by default):\n\n.. code:: python\n\n    @admin.register(book)\n    class bookadmin(djangoqlsearchmixin, admin.modeladmin):\n        search_fields = ('title', 'author__name')\n        djangoql_completion_enabled_by_default = false\n\nif you don't want two search modes, simply remove ``search_fields`` from your\nmodeladmin class.\n\nlanguage reference\n------------------\n\ndjangoql is shipped with comprehensive syntax help, which can be found in django\nadmin (see the syntax help link in auto-completion popup). here's a quick\nsummary:\n\ndjangoql's syntax resembles python's, with some minor\ndifferences. basically you just reference model fields as you would\nin python code, then apply comparison and logical operators and\nparenthesis. djangoql is case-sensitive.\n\n- model fields: exactly as they are defined in python code. access\n  nested properties via ``.``, for example ``author.last_name``;\n- strings must be double-quoted. single quotes are not supported.\n  to escape a double quote use ``\\\"``;\n- boolean and null values: ``true``, ``false``, ``none``. please note\n  that they can be combined only with equality operators, so you can\n  write ``published = false or date_published = none``, but\n  ``published > false`` will cause an error;\n- logical operators: ``and``, ``or``;\n- comparison operators: ``=``, ``!=``, ``<``, ``<=``, ``>``, ``>=``\n  - work as you expect;\n- string-specific comparison operators: ``startswith``, ``not startswith``,\n  ``endswith``, ``not endswith`` - work as you expect. test whether or not a\n  string contains a substring: ``~`` and ``!~`` (translated into\n  ``__icontains`` under the hood).\n  example: ``name endswith \"peace\" or author.last_name ~ \"tolstoy\"``;\n- date-specific comparison operators, compare by date part: ``~`` and ``!~``.\n  example: ``date_published ~ \"2021-11\"`` - find books published in nov, 2021;\n- test a value vs. list: ``in``, ``not in``. example:\n  ``pk in (2, 3)``.\n\n\ndjangoql schema\n---------------\n\nschema defines limitations - what you can do with a djangoql query.\nif you don't specify any schema, djangoql will provide a default\nschema for you. this will walk recursively through all model fields and\nrelations and include everything it finds in the schema, so\nusers would be able to search through everything. sometimes\nthis is not what you want, either due to db performance or security\nconcerns. if you'd like to limit search models or fields, you should\ndefine a schema. here's an example:\n\n.. code:: python\n\n    class userqlschema(djangoqlschema):\n        exclude = (book,)\n        suggest_options = {\n            group: ['name'],\n        }\n\n        def get_fields(self, model):\n            if model == group:\n                return ['name']\n            return super(userqlschema, self).get_fields(model)\n\n\n    @admin.register(user)\n    class customuseradmin(djangoqlsearchmixin, useradmin):\n        djangoql_schema = userqlschema\n\nin the example above we created a schema that does 3 things:\n\n- excludes the book model from search via ``exclude`` option. instead of\n  ``exclude`` you may also use ``include``, which limits a search to\n  listed models only;\n- limits available search fields for group model to only the ``name`` field\n  , in the ``.get_fields()`` method;\n- enables completion options for group names via ``suggest_options``.\n\nan important note about ``suggest_options``: it looks for the ``choices`` model\nfield parameter first, and if it's not specified - it will synchronously pull\nall values for given model fields, so you should avoid large querysets there.\nif you'd like to define custom suggestion options, see below.\n\ncustom search fields\n--------------------\n\ndeeper search customization can be achieved with custom search fields. custom\nsearch fields can be used to search by annotations, define custom suggestion\noptions, or define fully custom search logic. in ``djangoql.schema``, djangoql\ndefines the following base field classes that you may\nsubclass to define your own behavior:\n\n* ``intfield``\n* ``floatfield``\n* ``strfield``\n* ``boolfield``\n* ``datefield``\n* ``datetimefield``\n* ``relationfield``\n\nhere are examples for common use cases:\n\n**search by queryset annotations:**\n\n.. code:: python\n\n    from djangoql.schema import djangoqlschema, intfield\n\n\n    class userqlschema(djangoqlschema):\n        def get_fields(self, model):\n            fields = super(userqlschema, self).get_fields(model)\n            if model == user:\n                fields += [intfield(name='groups_count')]\n            return fields\n\n\n    @admin.register(user)\n    class customuseradmin(djangoqlsearchmixin, useradmin):\n        djangoql_schema = userqlschema\n\n        def get_queryset(self, request):\n            qs = super(customuseradmin, self).get_queryset(request)\n            return qs.annotate(groups_count=count('groups'))\n\nlet's take a closer look at what's happening in the example above. first, we\nadd ``groups_count`` annotation to the queryset that is used by django admin\nin the ``customuseradmin.get_queryset()`` method. it would contain the number\nof groups a user belongs to. as our queryset now pulls this column, we can\nfilter by it. it just needs to be included in the schema. in\n``userqlschema.get_fields()`` we define a custom integer search field for the\n``user`` model. its name should match the name of the column in our queryset.\n\n**custom suggestion options**\n\n.. code:: python\n\n    from djangoql.schema import djangoqlschema, strfield\n\n\n    class groupnamefield(strfield):\n        model = group\n        name = 'name'\n        suggest_options = true\n\n        def get_options(self, search):\n            return super(groupnamefield, self)\\\n                .get_options(search)\\\n                .annotate(users_count=count('user'))\\\n                .order_by('-users_count')\n\n\n    class userqlschema(djangoqlschema):\n        def get_fields(self, model):\n            if model == group:\n                return ['id', groupnamefield()]\n            return super(userqlschema, self).get_fields(model)\n\n\n    @admin.register(user)\n    class customuseradmin(djangoqlsearchmixin, useradmin):\n        djangoql_schema = userqlschema\n\nin this example we've defined a custom groupnamefield that sorts suggestions\nfor group names by popularity (no. of users in a group) instead of default\nalphabetical sorting.\n\n**custom search lookup**\n\ndjangoql base fields provide two basic methods that you can override to\nsubstitute either search column, search value, or both -\n``.get_lookup_name()`` and ``.get_lookup_value(value)``:\n\n.. code:: python\n\n    class userdatejoinedyear(intfield):\n        name = 'date_joined_year'\n\n        def get_lookup_name(self):\n            return 'date_joined__year'\n\n\n    class userqlschema(djangoqlschema):\n        def get_fields(self, model):\n            fields = super(userqlschema, self).get_fields(model)\n            if model == user:\n                fields += [userdatejoinedyear()]\n            return fields\n\n\n    @admin.register(user)\n    class customuseradmin(djangoqlsearchmixin, useradmin):\n        djangoql_schema = userqlschema\n\nin this example we've defined the custom ``date_joined_year`` search field for\nusers, and used the built-in django ``__year`` filter option in\n``.get_lookup_name()`` to filter by date year only. similarly you can use\n``.get_lookup_value(value)`` hook to modify a search value before it's used in\nthe filter.\n\n**fully custom search lookup**\n\n``.get_lookup_name()`` and ``.get_lookup_value(value)`` hooks cover many\nsimple use cases, but sometimes they're not enough and you want a fully custom\nsearch logic. in such cases you can override main ``.get_lookup()`` method of\na field. example below demonstrates user ``age`` search:\n\n.. code:: python\n\n    from djangoql.schema import djangoqlschema, intfield\n\n\n    class useragefield(intfield):\n        \"\"\"\n        search by given number of full years\n        \"\"\"\n        model = user\n        name = 'age'\n\n        def get_lookup_name(self):\n            \"\"\"\n            we'll be doing comparisons vs. this model field\n            \"\"\"\n            return 'date_joined'\n\n        def get_lookup(self, path, operator, value):\n            \"\"\"\n            the lookup should support with all operators compatible with intfield\n            \"\"\"\n            if operator == 'in':\n                result = none\n                for year in value:\n                    condition = self.get_lookup(path, '=', year)\n                    result = condition if result is none else result | condition\n                return result\n            elif operator == 'not in':\n                result = none\n                for year in value:\n                    condition = self.get_lookup(path, '!=', year)\n                    result = condition if result is none else result & condition\n                return result\n\n            value = self.get_lookup_value(value)\n            search_field = '__'.join(path + [self.get_lookup_name()])\n            year_start = self.years_ago(value + 1)\n            year_end = self.years_ago(value)\n            if operator == '=':\n                return (\n                    q(**{'%s__gt' % search_field: year_start}) &\n                    q(**{'%s__lte' % search_field: year_end})\n                )\n            elif operator == '!=':\n                return (\n                    q(**{'%s__lte' % search_field: year_start}) |\n                    q(**{'%s__gt' % search_field: year_end})\n                )\n            elif operator == '>':\n                return q(**{'%s__lt' % search_field: year_start})\n            elif operator == '>=':\n                return q(**{'%s__lte' % search_field: year_end})\n            elif operator == '<':\n                return q(**{'%s__gt' % search_field: year_end})\n            elif operator == '<=':\n                return q(**{'%s__gte' % search_field: year_start})\n\n        def years_ago(self, n):\n            timestamp = now()\n            try:\n                return timestamp.replace(year=timestamp.year - n)\n            except valueerror:\n                # february 29\n                return timestamp.replace(month=2, day=28, year=timestamp.year - n)\n\n\n    class userqlschema(djangoqlschema):\n        def get_fields(self, model):\n            fields = super(userqlschema, self).get_fields(model)\n            if model == user:\n                fields += [useragefield()]\n            return fields\n\n\n    @admin.register(user)\n    class customuseradmin(djangoqlsearchmixin, useradmin):\n        djangoql_schema = userqlschema\n\n\ncan i use it outside of django admin?\n-------------------------------------\n\nsure. you can add djangoql search functionality to any django model using\n``djangoqlqueryset``:\n\n.. code:: python\n\n    from django.db import models\n\n    from djangoql.queryset import djangoqlqueryset\n\n\n    class book(models.model):\n        name = models.charfield(max_length=255)\n        author = models.foreignkey('auth.user')\n\n        objects = djangoqlqueryset.as_manager()\n\nwith the example above you can perform a search like this:\n\n.. code:: python\n\n    qs = book.objects.djangoql(\n        'name ~ \"war\" and author.last_name = \"tolstoy\"'\n    )\n\nit returns a normal queryset, so you can extend it and reuse if\nnecessary. the following code works fine:\n\n.. code:: python\n\n    print(qs.count())\n\nalternatively you can add djangoql search to any existing queryset,\neven if it's not an instance of djangoqlqueryset:\n\n.. code:: python\n\n    from django.contrib.auth.models import user\n\n    from djangoql.queryset import apply_search\n\n    qs = user.objects.all()\n    qs = apply_search(qs, 'groups = none')\n    print(qs.exists())\n\nschemas can be specified either as a queryset option, or passed\nto ``.djangoql()`` queryset method directly:\n\n.. code:: python\n\n    class bookqueryset(djangoqlqueryset):\n        djangoql_schema = bookschema\n\n\n    class book(models.model):\n        ...\n\n        objects = bookqueryset.as_manager()\n\n    # now, book.objects.djangoql() will use bookschema by default:\n    book.objects.djangoql('name ~ \"peace\")  # uses bookschema\n\n    # overriding default queryset schema with anotherschema:\n    book.objects.djangoql('name ~ \"peace\", schema=anotherschema)\n\nyou can also provide schema as an option for ``apply_search()``\n\n.. code:: python\n\n    qs = user.objects.all()\n    qs = apply_search(qs, 'groups = none', schema=customschema)\n\n\nusing completion widget outside of django admin\n-----------------------------------------------\n\nthe completion widget is not tightly coupled to django admin, so you can easily\nuse it outside of the admin if you want. the widget is\n`available on npm <https://www.npmjs.com/package/djangoql-completion>`_ as a\nstandalone package.\nsee the source code and the docs in the\n`djangoql-completion <https://github.com/ivelum/djangoql-completion>`_\nrepo on github.\n\nthe completion widget is also bundled with the\n`djangoql <https://pypi.org/project/djangoql/>`_ python package on pypi. if\nyou're not using webpack or another javascript bundler, you can use the\npre-built version that ships with the python package. here is an example:\n\ntemplate code, ``completion_demo.html``:\n\n.. code:: html\n\n    {% load static %}\n    <!doctype html>\n    <html lang=\"en\">\n    <head>\n      <meta charset=\"utf-8\">\n      <title>djangoql completion demo</title>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"{% static 'djangoql/css/completion.css' %}\" />\n      <script src=\"{% static 'djangoql/js/completion.js' %}\"></script>\n    </head>\n    <body>\n\n      <form action=\"\" method=\"get\">\n        <p style=\"color: red\">{{ error }}</p>\n        <textarea name=\"q\" cols=\"40\" rows=\"1\" autofocus>{{ q }}</textarea>\n      </form>\n\n      <ul>\n      {% for item in search_results %}\n        <li>{{ item }}</li>\n      {% endfor %}\n      </ul>\n\n      <script>\n        djangoql.domready(function () {\n          new djangoql({\n            // either js object with a result of djangoqlschema(mymodel).as_dict(),\n            // or an url from which this information could be loaded asynchronously\n            introspections: {{ introspections|safe }},\n\n            // css selector for query input or htmlelement object.\n            // it should be a textarea\n            selector: 'textarea[name=q]',\n\n            // optional, you can provide url for syntax help link here.\n            // if not specified, syntax help link will be hidden.\n            syntaxhelp: null,\n\n            // optional, enable textarea auto-resize feature. if enabled,\n            // textarea will automatically grow its height when entered text\n            // doesn't fit, and shrink back when text is removed. the purpose\n            // of this is to see full search query without scrolling, could be\n            // helpful for really long queries.\n            autoresize: true\n          });\n        });\n      </script>\n    </body>\n    </html>\n\nand in your ``views.py``:\n\n.. code:: python\n\n    import json\n\n    from django.contrib.auth.models import group, user\n    from django.shortcuts import render_to_response\n    from django.views.decorators.http import require_get\n\n    from djangoql.exceptions import djangoqlerror\n    from djangoql.queryset import apply_search\n    from djangoql.schema import djangoqlschema\n    from djangoql.serializers import djangoqlschemaserializer\n\n\n    class userqlschema(djangoqlschema):\n        include = (user, group)\n        suggest_options = {\n            group: ['name'],\n        }\n\n\n    @require_get\n    def completion_demo(request):\n        q = request.get.get('q', '')\n        error = ''\n        query = user.objects.all().order_by('username')\n        if q:\n            try:\n                query = apply_search(query, q, schema=userqlschema)\n            except djangoqlerror as e:\n                query = query.none()\n                error = str(e)\n        # you may want to use suggestionsapiserializer and an additional api\n        # endpoint (see in djangoql.views) for asynchronous suggestions loading\n        introspections = djangoqlschemaserializer().serialize(\n          userqlschema(query.model),\n        )\n        return render_to_response('completion_demo.html', {\n            'q': q,\n            'error': error,\n            'search_results': query,\n            'introspections': json.dumps(introspections),\n        })\n\n\nlicense\n-------\n\nmit\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "djangoql",
  "package_url": "https://pypi.org/project/djangoql/",
  "project_url": "https://pypi.org/project/djangoql/",
  "project_urls": {
    "Homepage": "https://github.com/ivelum/djangoql/"
  },
  "release_url": "https://pypi.org/project/djangoql/0.18.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "djangoql: advanced search language for django",
  "version": "0.18.0",
  "releases": [],
  "developers": [
    "denis_stebunov",
    "support@ivelum.com"
  ],
  "kwds": "djangoql_completion_enabled_by_default djangoql djangoqlsearchmixin djangoqlqueryset django",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_djangoql",
  "homepage": "https://github.com/ivelum/djangoql/",
  "release_count": 60,
  "dependency_ids": []
}