{
  "classifiers": [
    "development status :: 3 - alpha",
    "environment :: console",
    "intended audience :: developers",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# pydeprecate\n\n**simple tooling for marking deprecated functions or classes and re-routing to the new successors' instance.**\n\n[![pypi - python version](https://img.shields.io/pypi/pyversions/pydeprecate)](https://pypi.org/project/pydeprecate/)\n[![pypi status](https://badge.fury.io/py/pydeprecate.svg)](https://badge.fury.io/py/pydeprecate)\n[![pypi status](https://pepy.tech/badge/pydeprecate)](https://pepy.tech/project/pydeprecate)\n[![conda](https://img.shields.io/conda/v/conda-forge/pydeprecate?label=conda&color=success)](https://anaconda.org/conda-forge/pydeprecate)\n![conda](https://img.shields.io/conda/dn/conda-forge/pydeprecate)\n[![license](https://img.shields.io/badge/license-mit-blue.svg)](https://github.com/borda/pydeprecate/blob/master/license)\n\n[![ci testing](https://github.com/borda/pydeprecate/actions/workflows/ci_testing.yml/badge.svg?tag=0.3.2)](https://github.com/borda/pydeprecate/actions/workflows/ci_testing.yml)\n[![code formatting](https://github.com/borda/pydeprecate/actions/workflows/code-format.yml/badge.svg?tag=0.3.2)](https://github.com/borda/pydeprecate/actions/workflows/code-format.yml)\n[![codecov](https://codecov.io/gh/borda/pydeprecate/release/0.3.2/graph/badge.svg?token=bg7rq86uja)](https://codecov.io/gh/borda/pydeprecate)\n[![codefactor](https://www.codefactor.io/repository/github/borda/pydeprecate/badge)](https://www.codefactor.io/repository/github/borda/pydeprecate)\n[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/borda/pydeprecate/main.svg)](https://results.pre-commit.ci/latest/github/borda/pydeprecate/main)\n\n<!--\n[![language grade: python](https://img.shields.io/lgtm/grade/python/g/borda/pydeprecate.svg?logo=lgtm&logowidth=18)](https://lgtm.com/projects/g/borda/pydeprecate/context:python)\n-->\n\n---\n\nthe common use-case is moving your functions across codebase or outsourcing some functionalities to new packages.\nfor most of these cases, you want to hold some compatibility, so you cannot simply remove past function, and also for some time you want to warn users that functionality they have been using is moved and not it is deprecated in favor of another function (which shall be used instead) and soon it will be removed completely.\n\nanother good aspect is to do not overwhelm a user with too many warnings, so per function/class, this warning is raised only n times in the preferable stream (warning, logger, etc.).\n\n## installation\n\nsimple installation from pypi:\n```bash\npip install pydeprecate\n```\n\n<details>\n  <summary>other installations</summary>\n\n  simply install with pip from source:\n  ```bash\n  pip install https://github.com/borda/pydeprecate/archive/main.zip\n  ```\n\n</details>\n\n## use-cases\n\nthe functionality is kept simple and all default shall be reasonable, but still you can do extra customization such as:\n\n* define user warning message and preferable stream\n* extended argument mapping to target function/method\n* define deprecation logic for self arguments\n* specify warning count per:\n    - called function (for func deprecation)\n    - used arguments (for argument deprecation)\n* define conditional skip (e.g. depending on some package version)\n\nin particular the target values (cases):\n\n- _none_ - raise only warning message (ignore all argument mapping)\n- _true_ - deprecation some argument of itself (argument mapping shall be specified)\n- _callable_ - forward call to new methods (optional also argument mapping or extras)\n\n### simple function forwarding\n\nit is very straight forward, you forward your function call to new function and all arguments are mapped:\n\n```python\ndef base_sum(a: int = 0, b: int = 3) -> int:\n    \"\"\"my new function anywhere in codebase or even other package.\"\"\"\n    return a + b\n\n# ---------------------------\n\nfrom deprecate import deprecated\n\n@deprecated(target=base_sum, deprecated_in=\"0.1\", remove_in=\"0.5\")\ndef depr_sum(a: int, b: int = 5) -> int:\n    \"\"\"\n    my deprecated function which now has empty body\n     as all calls are routed to the new function.\n    \"\"\"\n    pass  # or you can just place docstring as one above\n\n# call this function will raise deprecation warning:\n#   the `depr_sum` was deprecated since v0.1 in favor of `__main__.base_sum`.\n#   it will be removed in v0.5.\nprint(depr_sum(1, 2))\n```\n<details>\n  <summary>sample output:</summary>\n  ```\n  3\n  ```\n</details>\n\n### advanced target argument mapping\n\nanother more complex example is using argument mapping is:\n\n\n<details>\n  <summary>advanced example</summary>\n\n  ```python\n  import logging\n  from sklearn.metrics import accuracy_score\n  from deprecate import deprecated, void\n\n  @deprecated(\n    # use standard sklearn accuracy implementation\n    target=accuracy_score,\n    # custom warning stream\n    stream=logging.warning,\n    # number or warnings per lifetime (with -1 for always_\n    num_warns=5,\n    # custom message template\n    template_mgs=\"`%(source_name)s` was deprecated, use `%(target_path)s`\",\n    # as target args are different, define mapping from source to target func\n    args_mapping={'preds': 'y_pred', 'target': 'y_true', 'blabla': none}\n  )\n  def depr_accuracy(preds: list, target: list, blabla: float) -> float:\n      \"\"\"my deprecated function which is mapping to sklearn accuracy.\"\"\"\n      # to stop complain your ide about unused argument you can use void/empty function\n      return void(preds, target, blabla)\n\n  # call this function will raise deprecation warning:\n  #   warning:root:`depr_accuracy` was deprecated, use `sklearn.metrics.accuracy_score`\n  print(depr_accuracy([1, 0, 1, 2], [0, 1, 1, 2], 1.23))\n  ```\n  sample output:\n  ```\n  0.5\n  ```\n\n</details>\n\n\n### deprecation warning only\n\nbase use-case with no forwarding and just raising warning :\n\n```python\nfrom deprecate import deprecated\n\n@deprecated(target=none, deprecated_in=\"0.1\", remove_in=\"0.5\")\ndef my_sum(a: int, b: int = 5) -> int:\n    \"\"\"my deprecated function which still has to have implementation.\"\"\"\n    return a + b\n\n# call this function will raise deprecation warning:\n#   the `my_sum` was deprecated since v0.1. it will be removed in v0.5.\nprint(my_sum(1, 2))\n```\n<details>\n  <summary>sample output:</summary>\n  ```\n  3\n  ```\n</details>\n\n### self argument mapping\n\nwe also support deprecation and argument mapping for the function itself:\n\n```python\nfrom deprecate import deprecated\n\n@deprecated(\n  # define as depreaction some self argument - mapping\n  target=true, args_mapping={'coef': 'new_coef'},\n  # common version info\n  deprecated_in=\"0.2\", remove_in=\"0.4\",\n)\ndef any_pow(base: float, coef: float = 0, new_coef: float = 0) -> float:\n    \"\"\"my function with deprecated argument `coef` mapped to `new_coef`.\"\"\"\n    return base ** new_coef\n\n# call this function will raise deprecation warning:\n#   the `any_pow` uses deprecated arguments: `coef` -> `new_coef`.\n#   they were deprecated since v0.2 and will be removed in v0.4.\nprint(any_pow(2, 3))\n```\n<details>\n  <summary>sample output:</summary>\n  ```\n  8\n  ```\n</details>\n\n### multiple deprecation levels\n\neventually you can set multiple deprecation levels via chaining deprecation arguments as each could be deprecated in another version:\n\n<details>\n  <summary>multiple deprecation levels</summary>\n\n  ```python\n  from deprecate import deprecated\n\n  @deprecated(\n    true, \"0.3\", \"0.6\", args_mapping=dict(c1='nc1'),\n    template_mgs=\"depr: v%(deprecated_in)s rm v%(remove_in)s for args: %(argument_map)s.\"\n  )\n  @deprecated(\n    true, \"0.4\", \"0.7\", args_mapping=dict(nc1='nc2'),\n    template_mgs=\"depr: v%(deprecated_in)s rm v%(remove_in)s for args: %(argument_map)s.\"\n  )\n  def any_pow(base, c1: float = 0, nc1: float = 0, nc2: float = 2) -> float:\n      return base**nc2\n\n  # call this function will raise deprecation warning:\n  #   deprecationwarning('depr: v0.3 rm v0.6 for args: `c1` -> `nc1`.')\n  #   deprecationwarning('depr: v0.4 rm v0.7 for args: `nc1` -> `nc2`.')\n  print(any_pow(2, 3))\n  ```\n  sample output:\n  ```\n  8\n  ```\n\n</details>\n\n### conditional skip\n\nconditional skip of which can be used for mapping between different target functions depending on additional input such as package version\n\n```python\nfrom deprecate import deprecated\n\nfake_version = 1\n\ndef version_greater_1():\n    return fake_version > 1\n\n@deprecated(\n  true, \"0.3\", \"0.6\", args_mapping=dict(c1='nc1'), skip_if=version_greater_1\n)\ndef skip_pow(base, c1: float = 1, nc1: float = 1) -> float:\n    return base**(c1 - nc1)\n\n# call this function will raise deprecation warning\nprint(skip_pow(2, 3))\n\n# change the fake versions\nfake_version = 2\n\n# will not raise any warning\nprint(skip_pow(2, 3))\n```\n<details>\n  <summary>sample output:</summary>\n  ```\n  0.25\n  4\n  ```\n</details>\n\nthis can be beneficial with multiple deprecation levels shown above...\n\n### class deprecation\n\nthis case can be quite complex as you may deprecate just some methods, here we show full class deprecation:\n\n```python\nclass newcls:\n    \"\"\"my new class anywhere in the codebase or other package.\"\"\"\n\n    def __init__(self, c: float, d: str = \"abc\"):\n        self.my_c = c\n        self.my_d = d\n\n# ---------------------------\n\nfrom deprecate import deprecated, void\n\nclass pastcls(newcls):\n    \"\"\"\n    the deprecated class shall be inherited from the successor class\n     to hold all methods.\n    \"\"\"\n\n    @deprecated(target=newcls, deprecated_in=\"0.2\", remove_in=\"0.4\")\n    def __init__(self, c: int, d: str = \"efg\"):\n        \"\"\"\n        you place the decorator around __init__ as you want\n         to warn user just at the time of creating object.\n        \"\"\"\n        return void(c, d)\n\n# call this function will raise deprecation warning:\n#   the `pastcls` was deprecated since v0.2 in favor of `__main__.newcls`.\n#   it will be removed in v0.4.\ninst = pastcls(7)\nprint(inst.my_c)  # returns: 7\nprint(inst.my_d)  # returns: \"efg\"\n```\n<details>\n  <summary>sample output:</summary>\n  ```\n  7\n  efg\n  ```\n</details>\n\n## contribution\n\nhave you faced this in past or even now, do you have good ideas for improvement, all is welcome!\n\n\n",
  "docs_url": null,
  "keywords": "python,development,deprecation",
  "license": "mit",
  "name": "pydeprecate",
  "package_url": "https://pypi.org/project/pyDeprecate/",
  "project_url": "https://pypi.org/project/pyDeprecate/",
  "project_urls": {
    "Homepage": "https://borda.github.io/pyDeprecate",
    "Source Code": "https://github.com/Borda/pyDeprecate"
  },
  "release_url": "https://pypi.org/project/pyDeprecate/0.3.2/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "deprecation tooling",
  "version": "0.3.2",
  "releases": [],
  "developers": [
    "jiri.borovec@fel.cvut.cz",
    "jiri_borovec"
  ],
  "kwds": "pydeprecate pyversions deprecated_in py pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pydeprecate",
  "homepage": "https://borda.github.io/pydeprecate",
  "release_count": 6,
  "dependency_ids": []
}