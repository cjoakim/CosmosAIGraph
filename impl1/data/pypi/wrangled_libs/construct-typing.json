{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: software development :: build tools",
    "topic :: software development :: code generators",
    "topic :: software development :: libraries :: python modules",
    "typing :: typed"
  ],
  "description": "# construct-typing\n[![pypi](https://img.shields.io/pypi/v/construct-typing)](https://pypi.org/project/construct-typing/)\n![pypi - implementation](https://img.shields.io/pypi/implementation/construct-typing)\n![pypi - python version](https://img.shields.io/pypi/pyversions/construct-typing)\n![github](https://img.shields.io/github/license/timrid/construct-typing)\n\nthis project is an extension of the python package [*construct*](https://pypi.org/project/construct/), which is a powerful **declarative** and **symmetrical** parser and builder for binary data. this repository consists of two packages:\n\n- **construct-stubs**: adding .pyi for the whole *construct 2.10* package (according to  [pep 561 stub-only packages](https://www.python.org/dev/peps/pep-0561/#stub-only-packages))\n- **construct_typed**: adding additional classes that help with autocompletion and additional type hints.\n\n## installation\nthis package comply to [pep 561](https://www.python.org/dev/peps/pep-0561/). so most of the static code analysers will recognise the stubs automatically. the installation only requires:\n```\npip install construct-typing\n```\n\n## tests\nthe stubs are tested against the pytests of the *construct* package in a slightly modified form. since the tests are relatively detailed i think most cases are covered.\n\nthe new typed constructs have new written pytests, which also passes all pytests and the static type checkers.\n\nthe following static type checkers are fully supported:\n- mypy\n- pyright\n\n## explanation\n### stubs\nthe **construct-stubs** package is used for creating type hints for the orignial *construct* package. in particular the `build` and `parse` methods get type hints. so the core of the stubs  are the `typevar`'s `parsedtype` and `buildtypes`:\n- `construct.build`: converts an object of one of the types defined by `buildtypes` to a `bytes` object.\n- `construct.parse`: converts a `bytes` object to an object of type `parsedtype`.\n\nfor each `construct` the stub file defines to which type it parses to and from which it can be build. for example:\n\n| construct            | parses to (parsedtype)         | builds from (buildtypes)                 |\n| -------------------- | ------------------------------ | ---------------------------------------- |\n| `int16ub`            | `int`                          | `int`                                    |\n| `bytes`              | `bytes`                        | `bytes`, `bytearray` or `memoryview`     |\n| `array(5, int16ub)`  | `listcontainer[int]`           | `typing.list[int]`                       |\n| `struct(\"i\" / byte)` | `container[typing.any]`        | `typing.dict[str, typing.any]` or `none` |\n\nthe problem is to describe the more complex constructs like:\n - `sequence`, `focusedseq` which has heterogenous subcons in comparison to an `array` with only homogenous subcons. \n - `struct`, `bitstruct`, `lazystruct`, `union` which has heterogenous and named subcons.\n\ncurrently only the very unspecific type `typing.any` can be used as type hint (maybe in the future it can be optimised a little, when [variadic generics](https://mail.python.org/archives/list/typing-sig@python.org/thread/sqvtqywioi4tio7nnbtffwfmsms2ta4j/) become available). but the biggest disadvantage is that autocompletion for the named subcons is not available.\n\nnote: the stubs are based on *construct* in version 2.10.\n\n\n### typed\n**!!! experimental version !!!**\n\nto include autocompletion and further enhance the type hints for these complex constructs the **construct_typed** package is used as an extension to the original *construct* package. it is mainly a few adapters with the focus on type hints.\n\nit implements the following new constructs:\n- `dataclassstruct`: similar to `construct.struct` but strictly tied to `dataclassmixin` and `@dataclasses.dataclass`\n- `dataclassbitstruct`: similar to `construct.bitstruct` but strictly tied to `dataclassmixin` and `@dataclasses.dataclass`\n- `tenum`: similar to `construct.enum` but strictly tied to a `tenumbase` class\n- `tflagsenum`: similar to `construct.flagsenum` but strictly tied to a `tflagsenumbase` class\n\nthese types are strongly typed, which means that there is no difference between the `parsedtype` and the `buildtypes`. so to build one of the constructs the correct type is enforced. the disadvantage is that the code will be a little bit longer, because you can not for example use a normal `dict` to build an `dataclassstruct`. but the big advantage is, that if you use the correct container type instead of a `dict`, the static code analyses can do its magic and find potential type errors and missing values without running the code itself.\n\n\na short example:\n\n```python\nimport dataclasses\nimport typing as t\nfrom construct import array, byte, const, int8ub, this\nfrom construct_typed import dataclassmixin, dataclassstruct, enumbase, tenum, csfield\n\nclass orientation(enumbase):\n    horizontal = 0\n    vertical = 1\n\n@dataclasses.dataclass\nclass image(dataclassmixin):\n    signature: bytes = csfield(const(b\"bmp\"))\n    orientation: orientation = csfield(tenum(int8ub, orientation))\n    width: int = csfield(int8ub)\n    height: int = csfield(int8ub)\n    pixels: t.list[int] = csfield(array(this.width * this.height, byte))\n\nformat = dataclassstruct(image)\nobj = image(\n    orientation=orientation.vertical,\n    width=3,\n    height=2,\n    pixels=[7, 8, 9, 11, 12, 13],\n)\nprint(format.build(obj))\nprint(format.parse(b\"bmp\\x01\\x03\\x02\\x07\\x08\\t\\x0b\\x0c\\r\"))\n```\noutput:\n```\nb'bmp\\x01\\x03\\x02\\x07\\x08\\t\\x0b\\x0c\\r'\nimage: \n    signature = b'bmp' (total 3)\n    orientation = orientation.vertical\n    width = 3\n    height = 2\n    pixels = listcontainer:\n        7\n        8\n        9\n        11\n        12\n        13\n```\n\n\n",
  "docs_url": null,
  "keywords": "construct,kaitai,declarative,data structure,struct,binary,symmetric,parser,builder,parsing,building,pack,unpack,packer,unpacker,bitstring,bytestring,annotation,type hint,typing,typed,bitstruct,pep 561",
  "license": "mit",
  "name": "construct-typing",
  "package_url": "https://pypi.org/project/construct-typing/",
  "project_url": "https://pypi.org/project/construct-typing/",
  "project_urls": {
    "Homepage": "https://github.com/timrid/construct-typing"
  },
  "release_url": "https://pypi.org/project/construct-typing/0.6.2/",
  "requires_dist": [
    "construct (==2.10.68)",
    "typing-extensions (>=4.6.0)"
  ],
  "requires_python": ">=3.7",
  "summary": "extension for the python package 'construct' that adds typing features",
  "version": "0.6.2",
  "releases": [],
  "developers": [
    "tim_riddermann"
  ],
  "kwds": "construct_typed constructs buildtypes pypi construct",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_construct_typing",
  "homepage": "https://github.com/timrid/construct-typing",
  "release_count": 17,
  "dependency_ids": [
    "pypi_construct",
    "pypi_typing_extensions"
  ]
}