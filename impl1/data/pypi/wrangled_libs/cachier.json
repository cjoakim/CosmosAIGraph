{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: other/nonlisted topic",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "cachier\n#######\n\n|pypi-status| |downloads| |pypi-versions| |build-status| |codecov| |codefactor| |licence|\n\npersistent, stale-free, local and cross-machine caching for python functions.\n\n.. code-block:: python\n\n  from cachier import cachier\n  import datetime\n\n  @cachier(stale_after=datetime.timedelta(days=3))\n  def foo(arg1, arg2):\n    \"\"\"foo now has a persistent cache, trigerring recalculation for values stored more than 3 days.\"\"\"\n    return {'arg1': arg1, 'arg2': arg2}\n\n\n.. role:: python(code)\n  :language: python\n\n.. contents::\n\n.. section-numbering:\n\n\n\ninstallation\n============\n\ninstall ``cachier`` with:\n\n.. code-block:: python\n\n    pip install cachier\n\nfor the latest version supporting python 2.7 please use:\n\n.. code-block:: python\n\n    pip install 'cachier==1.2.8'\n\nfeatures\n========\n\n* pure python.\n* compatible with python 3.8+ (python 2.7 was discontinued in version 1.2.8).\n* supported and `tested on linux, os x and windows <https://travis-ci.org/shaypal5/cachier>`_.\n* a simple interface.\n* defining \"shelf life\" for cached values.\n* local caching using pickle files.\n* cross-machine caching using mongodb.\n* thread-safety.\n\ncachier is **not**:\n\n* meant as a transient cache. python's @lru_cache is better.\n* especially fast. it is meant to replace function calls that take more than... a second, say (overhead is around 1 millisecond).\n\nfuture features\n---------------\n\n* s3 core.\n* multi-core caching.\n* `cache replacement policies <https://en.wikipedia.org/wiki/cache_replacement_policies>`_\n\n\nuse\n===\n\ncachier provides a decorator which you can wrap around your functions to give them a persistent cache. the positional and keyword arguments to the wrapped function must be hashable (i.e. python's immutable built-in objects, not mutable containers). also, notice that since objects which are instances of user-defined classes are hashable but all compare unequal (their hash value is their id), equal objects across different sessions will not yield identical keys.\n\nsetting up a cache\n------------------\nyou can add a default, pickle-based, persistent cache to your function - meaning it will last across different python kernels calling the wrapped function - by decorating it with the ``cachier`` decorator (notice the ``()``!).\n\n.. code-block:: python\n\n  from cachier import cachier\n\n  @cachier()\n  def foo(arg1, arg2):\n    \"\"\"your function now has a persistent cache mapped by argument values!\"\"\"\n    return {'arg1': arg1, 'arg2': arg2}\n\nclass and object methods can also be cached. cachier will automatically ignore the `self` parameter when determining the cache key for an object method. **this means that methods will be cached across all instances of an object, which may not be what you want.**\n\n.. code-block:: python\n\n  from cachier import cachier\n\n  class foo():\n    @staticmethod\n    @cachier()\n    def good_static_usage(arg_1, arg_2):\n      return arg_1 + arg_2\n\n    # instance method does not depend on object's internal state, so good to cache\n    @cachier()\n    def good_usage_1(self, arg_1, arg_2)\n      return arg_1 + arg_2\n\n    # instance method is calling external service, probably okay to cache\n    @cachier()\n    def good_usage_2(self, arg_1, arg_2)\n      result = self.call_api(arg_1, arg_2)\n      return result\n\n    # instance method relies on object attribute, not good to cache\n    @cachier()\n    def bad_usage(self, arg_1, arg_2)\n      return arg_1 + arg_2 + self.arg_3\n\n\nresetting a cache\n-----------------\nthe cachier wrapper adds a ``clear_cache()`` function to each wrapped function. to reset the cache of the wrapped function simply call this method:\n\n.. code-block:: python\n\n  foo.clear_cache()\n\ngeneral configuration\n----------------------\n\nglobal defaults\n~~~~~~~~~~~~~~~\n\nsettings can be globally configured across all cachier wrappers through the use of the `set_default_params` function. this function takes the same keyword parameters as the ones defined in the decorator, which can be passed all at once or with multiple calls. parameters given directly to a decorator take precedence over any values set by this function.\n\nthe following parameters will only be applied to decorators defined after `set_default_params` is called:\n\n*  `hash_func`\n*  `backend`\n*  `mongetter`\n*  `cache_dir`\n*  `pickle_reload`\n*  `separate_files`\n\nthese parameters can be changed at any time and they will apply to all decorators:\n\n*  `allow_none`\n*  `caching_enabled`\n*  `stale_after`\n*  `next_time`\n*  `wait_for_calc_timeout`\n\nthe current defaults can be fetched by calling `get_default_params`.\n\nthreads limit\n~~~~~~~~~~~~~\n\nto limit the number of threads cachier is allowed to spawn, set the ``cachier_max_workers`` with the desired number. the defeault is 8, so to enable cachier to spawn even more threads, you'll have to set a higher limit explicitly.\n\n\nglobal enable/disable\n---------------------\n\ncaching can be turned off across all decorators by calling `disable_caching`, and then re-activated by calling `enable_caching`.\n\nthese functions are convenience wrappers around the `caching_enabled` default setting.\n\n\ncache shelf life\n----------------\n\nsetting shelf life\n~~~~~~~~~~~~~~~~~~\nyou can set any duration as the shelf life of cached return values of a function by providing a corresponding ``timedelta`` object to the ``stale_after`` parameter:\n\n.. code-block:: python\n\n  import datetime\n\n  @cachier(stale_after=datetime.timedelta(weeks=2))\n  def bar(arg1, arg2):\n    return {'arg1': arg1, 'arg2': arg2}\n\nnow when a cached value matching the given arguments is found the time of its calculation is checked; if more than ``stale_after`` time has since passed, the function will be run again for the same arguments and the new value will be cached and returned.\n\nthis is useful for lengthy calculations that depend on a dynamic data source.\n\nfuzzy shelf life\n~~~~~~~~~~~~~~~~\nsometimes you may want your function to trigger a calculation when it encounters a stale result, but still not wait on it if it's not that critical. in that case, you can set ``next_time`` to ``true`` to have your function trigger a recalculation **in a separate thread**, but return the currently cached stale value:\n\n.. code-block:: python\n\n  @cachier(next_time=true)\n\nfurther function calls made while the calculation is being performed will not trigger redundant calculations.\n\n\nworking with unhashable arguments\n---------------------------------\n\nas mentioned above, the positional and keyword arguments to the wrapped function must be hashable (i.e. python's immutable built-in objects, not mutable containers). to get around this limitation the ``hash_func`` parameter of the ``cachier`` decorator can be provided with a callable that gets the args and kwargs from the decorated function and returns a hash key for them.\n\n.. code-block:: python\n\n  def calculate_hash(args, kwds):\n    key = ...  # compute a hash key here based on arguments\n    return key\n\n  @cachier(hash_func=calculate_hash)\n  def calculate_super_complex_stuff(custom_obj):\n    # amazing code goes here\n\nsee here for an example:\n\n`question: how to work with unhashable arguments <https://github.com/python-cachier/cachier/issues/91>`_\n\n\nprecaching values\n---------------------------------\n\nif you want to load a value into the cache without calling the underlying function, this can be done with the `precache_value` function.\n\n.. code-block:: python\n\n  @cachier()\n  def add(arg1, arg2):\n    return arg1 + arg2\n\n  add.precache_value(2, 2, value_to_cache=5)\n\n  result = add(2, 2)\n  print(result)  # prints 5\n\n\nper-function call arguments\n---------------------------\n\ncachier also accepts several keyword arguments in the calls of the function it wraps rather than in the decorator call, allowing you to modify its behaviour for a specific function call.\n\nignore cache\n~~~~~~~~~~~~\n\nyou can have ``cachier`` ignore any existing cache for a specific function call by passing ``ignore_cache=true`` to the function call. the cache will neither be checked nor updated with the new return value.\n\n.. code-block:: python\n\n  @cachier()\n  def sum(first_num, second_num):\n    return first_num + second_num\n\n  def main():\n    print(sum(5, 3, ignore_cache=true))\n\noverwrite cache\n~~~~~~~~~~~~~~~\n\nyou can have ``cachier`` overwrite an existing cache entry - if one exists - for a specific function call by passing ``overwrite_cache=true`` to the function call. the cache will not be checked but will be updated with the new return value.\n\nverbose cache call\n~~~~~~~~~~~~~~~~~~\n\nyou can have ``cachier`` print out a detailed explanation of the logic of a specific call by passing ``verbose_cache=true`` to the function call. this can be useful if you are not sure why a certain function result is, or is not, returned.\n\ncache `none` values\n~~~~~~~~~~~~~~~~~~~\n\nby default, ``cachier`` does not cache ``none`` values. you can override this behaviour by passing ``allow_none=true`` to the function call.\n\n\ncachier cores\n=============\n\npickle core\n-----------\n\nthe default core for cachier is pickle based, meaning each function will store its cache is a separate pickle file in the ``~/.cachier`` directory. naturally, this kind of cache is both machine-specific and user-specific.\n\nyou can configure ``cachier`` to use another directory by providing the ``cache_dir`` parameter with the path to that directory:\n\n.. code-block:: python\n\n  @cachier(cache_dir='~/.temp/.cache')\n\n\nyou can slightly optimise pickle-based caching if you know your code will only be used in a single thread environment by setting:\n\n.. code-block:: python\n\n  @cachier(pickle_reload=false)\n\nthis will prevent reading the cache file on each cache read, speeding things up a bit, while also nullifying inter-thread functionality (the code is still thread safe, but different threads will have different versions of the cache at times, and will sometime make unnecessary function calls).\n\nsetting the optional argument ``separate_files`` to ``true`` will cause the cache to be stored in several files: a file per argument set, per function. this can help if your per-function cache files become too large.\n\n.. code-block:: python\n\n  from cachier import cachier\n\n  @cachier(separate_files=true)\n  def foo(arg1, arg2):\n    \"\"\"your function now has a persistent cache mapped by argument values, split across several files, per argument set\"\"\"\n    return {'arg1': arg1, 'arg2': arg2}\n\nyou can get the fully qualified path to the directory of cache files used by ``cachier`` (``~/.cachier`` by default) by calling the ``cache_dpath()`` function:\n\n.. code-block:: python\n\n  >>> foo.cache_dpath()\n      \"/home/bigus/.cachier/\"\n\n\nmongodb core\n------------\nyou can set a mongodb-based cache by assigning ``mongetter`` with a callable that returns a ``pymongo.collection`` object with writing permissions:\n\n.. code-block:: python\n\n    from pymongo import mongoclient\n\n    def my_mongetter():\n        client = mongoclient(get_cachier_db_auth_uri())\n        db_obj = client['cachier_db']\n        if 'someapp_cachier_db' not in db_obj.list_collection_names():\n            db_obj.create_collection('someapp_cachier_db')\n        return db_obj['someapp_cachier_db']\n\n  @cachier(mongetter=my_mongetter)\n\nthis allows you to have a cross-machine, albeit slower, cache. this functionality requires that the installation of the ``pymongo`` python package.\n\nin certain cases the mongodb backend might leave a deadlock behind, blocking all subsequent requests from being processed. if you encounter this issue, supply the ``wait_for_calc_timeout`` with a reasonable number of seconds; calls will then wait at most this number of seconds before triggering a recalculation.\n\n.. code-block:: python\n\n  @cachier(mongetter=false, wait_for_calc_timeout=2)\n\n\nmemory core\n-----------\n\nyou can set an in-memory cache by assigning the ``backend`` parameter with ``'memory'``:\n\n.. code-block:: python\n\n  @cachier(backend='memory')\n\nnote, however, that ``cachier``'s in-memory core is simple, and has no monitoring or cap on cache size, and can thus lead to memory errors on large return values - it is mainly intended to be used with future multi-core functionality. as a rule, python's built-in ``lru_cache`` is a much better stand-alone solution.\n\n\ncontributing\n============\n\ncurrent maintainers are shay palachy affek (`shay.palachy@gmail.com <mailto:shay.palachy@gmail.com>`_, `@shaypal5 <https://github.com/shaypal5>`_) and judson neer (`@lordjabez <https://github.com/lordjabez>`_); you are more than welcome to approach them for help. contributions are very welcomed! :)\n\ninstalling for development\n--------------------------\n\nclone:\n\n.. code-block:: bash\n\n  git clone git@github.com:python-cachier/cachier.git\n\n\ninstall in development mode with test dependencies:\n\n.. code-block:: bash\n\n  cd cachier\n  pip install -e \".[test]\"\n\n\nrunning the tests\n-----------------\n\nto run the tests, call the ``pytest`` command in the repository's root, or:\n\n.. code-block:: bash\n\n  python -m pytest\n\nto run only mongodb core related tests, use:\n\n.. code-block:: bash\n\n  pytest -m mongo\n\nto run only memory core related tests, use:\n\n.. code-block:: bash\n\n  pytest -m memory\n\nto run all tests except mongodb core related tests, use:\n\n.. code-block:: bash\n\n  pytest -m \"not mongo\"\n\n\nto run all tests except memory core and mongodb core related tests, use:\n\n.. code-block:: bash\n\n  pytest -m \"not (mongo or memory)\"\n\n\nrunning mongodb tests against a live mongodb instance\n-----------------------------------------------------\n\n**note to developers:** by default, all mongodb tests are run against a mocked mongodb instance, provided by the ``pymongo_inmemory`` package. to run them against a live mongodb instance, the ``cachier_test_vs_live_mongo`` environment variable is set to ``true`` in the ``test`` environment of this repository (and additional environment variables are populated with the appropriate credentials), used by the github action running tests on every commit and pull request.\n\ncontributers are not expected to run these tests against a live mongodb instance when developing, as credentials for the testing instance used will not be shared, but rather use the testing against the in-memory mongodb instance as a good proxy.\n\n**however, the tests run against a live mongodb instance when you submit a pr are the determining tests for deciding whether your code functions correctly against mongodb.**\n\n\nadding documentation\n--------------------\n\nthis project is documented using the `numpy docstring conventions`_, which were chosen as they are perhaps the most widely-spread conventions that are both supported by common tools such as sphinx and result in human-readable docstrings (in my personal opinion, of course). when documenting code you add to this project, please follow `these conventions`_.\n\n.. _`numpy docstring conventions`: https://github.com/numpy/numpy/blob/master/doc/howto_document.rst.txt\n.. _`these conventions`: https://github.com/numpy/numpy/blob/master/doc/howto_document.rst.txt\n\nadditionally, if you update this ``readme.rst`` file, use ``python setup.py checkdocs`` to validate it compiles.\n\n\ncredits\n=======\n\ncreated by `shay palachy affek <https://github.com/shaypal5>`_ (shay.palachy@gmail.com), which currently assists in maintenance.\n\ncurrent lead developer/contributor: `judson neer <https://github.com/lordjabez>`_ (`@lordjabez <https://github.com/lordjabez>`_ on github).\n\nother major contributors:\n\n* `judson neer <https://github.com/lordjabez>`_ - precaching, method caching support and numerous improvements and bugfixes.\n\n* `cthoyt <https://github.com/cthoyt>`_ - base memory core implementation.\n\n* `amarczew <https://github.com/amarczew>`_ - the ``hash_func`` kwarg.\n\n* `non-senses <https://github.com/non-senses>`_ - the ``wait_for_calc_timeout`` kwarg.\n\n* `elad rapaport <https://github.com/erap129>`_ - multi-file pickle core, a.k.a ``separate_files`` (released on ``v1.5.3``).\n\n* `john didion <https://github.com/jdidion>`_ - support for pickle-based caching for cases where two identically-named methods of different classes are defined in the same module.\n\nnotable bugfixers:\n\n* `michaelrazum <https://github.com/michaelrazum>`_.\n\n* `eric ma <https://github.com/ericmjl>`_ - the inotify bugfix (released on ``v1.5.3``).\n\n* `ofir <https://github.com/ofirnk>`_ - the inotify bugfix (released on ``v1.5.3``).\n\n\n\n.. |pypi-status| image:: https://img.shields.io/pypi/v/cachier.svg\n  :target: https://pypi.python.org/pypi/cachier\n\n.. |pypi-versions| image:: https://img.shields.io/pypi/pyversions/cachier.svg\n   :target: https://pypi.python.org/pypi/cachier\n\n.. |build-status| image:: https://github.com/python-cachier/cachier/actions/workflows/test.yml/badge.svg\n  :target: https://github.com/python-cachier/cachier/actions/workflows/test.yml\n\n.. |licence| image:: https://img.shields.io/pypi/l/cachier.svg\n  :target: https://pypi.python.org/pypi/cachier\n\n.. |codecov| image:: https://codecov.io/github/python-cachier/cachier/coverage.svg?branch=master\n   :target: https://codecov.io/github/python-cachier/cachier?branch=master\n\n.. |downloads| image:: https://pepy.tech/badge/cachier\n     :target: https://pepy.tech/project/cachier\n     :alt: pepy stats\n\n.. |codefactor| image:: https://www.codefactor.io/repository/github/python-cachier/cachier/badge?style=plastic\n     :target: https://www.codefactor.io/repository/github/python-cachier/cachier\n     :alt: codefactor code quality\n\n.. links:\n.. _pymongo: https://api.mongodb.com/python/current/\n.. _watchdog: https://github.com/gorakhargosh/watchdog\n",
  "docs_url": null,
  "keywords": "cache,persistence,mongo,memoization,decorator",
  "license": "mit",
  "name": "cachier",
  "package_url": "https://pypi.org/project/cachier/",
  "project_url": "https://pypi.org/project/cachier/",
  "project_urls": {
    "Homepage": "https://github.com/python-cachier/cachier"
  },
  "release_url": "https://pypi.org/project/cachier/2.2.2/",
  "requires_dist": [
    "watchdog",
    "portalocker",
    "setuptools >=67.6.0",
    "pytest ; extra == 'test'",
    "coverage ; extra == 'test'",
    "pytest-cov ; extra == 'test'",
    "birch ; extra == 'test'",
    "bandit ; extra == 'test'",
    "flake8 ; extra == 'test'",
    "pylint ; extra == 'test'",
    "safety ; extra == 'test'",
    "mypy ; extra == 'test'",
    "types-setuptools ; extra == 'test'",
    "pandas-stubs ; extra == 'test'",
    "pymongo ; extra == 'test'",
    "dnspython ; extra == 'test'",
    "pymongo-inmemory ; extra == 'test'",
    "pandas ; extra == 'test'",
    "collective.checkdocs ; extra == 'test'",
    "pygments ; extra == 'test'"
  ],
  "requires_python": "",
  "summary": "persistent, stale-free, local and cross-machine caching for python functions.",
  "version": "2.2.2",
  "releases": [],
  "developers": [
    "shay.palachy@gmail.com",
    "shay_palachy"
  ],
  "kwds": "verbose_cache caching_enabled enable_caching value_to_cache cachier_test_vs_live_mongo",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_cachier",
  "homepage": "https://github.com/python-cachier/cachier",
  "release_count": 54,
  "dependency_ids": [
    "pypi_bandit",
    "pypi_birch",
    "pypi_collective.checkdocs",
    "pypi_coverage",
    "pypi_dnspython",
    "pypi_flake8",
    "pypi_mypy",
    "pypi_pandas",
    "pypi_pandas_stubs",
    "pypi_portalocker",
    "pypi_pygments",
    "pypi_pylint",
    "pypi_pymongo",
    "pypi_pymongo_inmemory",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_safety",
    "pypi_setuptools",
    "pypi_types_setuptools",
    "pypi_watchdog"
  ]
}