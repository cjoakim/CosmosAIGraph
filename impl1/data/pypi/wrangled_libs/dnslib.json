{
  "classifiers": [
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: internet :: name service (dns)"
  ],
  "description": "\n## from version 0.9.12 the master repository for _dnslib_ has been moved to github (https://github.com/paulc/dnslib). please update any links to the original bitbucket repository as this will no longer be maintained.\n\n\ndnslib\n------\n\na library to encode/decode dns wire-format packets supporting both\npython 2.7 and python 3.2+.\n\nthe library provides:\n\n * support for encoding/decoding dns packets between wire format,\n   python objects, and zone/dig textual representation (dnslib.dns)\n\n * a server framework allowing the simple creation of custom dns\n   resolvers (dnslib.server) and a number of example servers\n   created using this framework\n\n * a number of utilities for testing (dnslib.client, dnslib.proxy,\n   dnslib.intercept)\n\npython 3 support was added in version 0.9.0 which represented a fairly\nmajor update to the library - the key changes include:\n\n * python 2.7/3.2+ support (the last version supporting python 2.6\n   or earlier was version 0.8.3)\n\n * the 'bimap' interface was changed significantly to explicitly\n   split forward (value->text) lookups via __getitem__ and\n   reverse (text->value) lookups via __getattr__. applications\n   using the old interface will need to be updated.\n\n * hostnames are now returned with a trailing dot by default (in\n   line with rfc)\n\n * most object attributes are now typed in line with the record\n   definitions to make it harder to generate invalid packets\n\n * support for encoding/decoding resource records in 'zone' (bind)\n   file format\n\n * support for encoding/decoding packets in 'dig' format\n\n * server framework allowing (in most cases) custom resolvers to\n   be created by just subclassing the dnsresolver class and\n   overriding the 'resolve' method\n\n * a lot of fixes to error detection/handling which should make\n   the library much more robust to invalid/unsupported data. the\n   library should now either return a valid dnsrecord instance\n   when parsing a packet or raise dnserror (tested via fuzzing)\n\n * improved utilities (dnslib.client, dnslib.proxy, dnslib.intercept)\n\n * improvements to encoding/decoding tests including the ability\n   to generate test data automatically in test_decode.py (comparing\n   outputs against dig)\n\n * ability to compare and diff dnsrecords\n\nclasses\n-------\n\nthe key dns packet handling classes are in dnslib.dns and map to the\nstandard dns packet sections:\n\n * dnsrecord - container for dns packet. contains:\n    - dnsheader\n    - question section containing zero or more dnsquestion objects\n    - answer section containing zero or more rr objects\n    - authority section containing zero or more rr objects\n    - additional section containing zero or more rr objects\n * dns rrs (resource records) contain an rr header and an rd object)\n * specific rd types are implemented as subclasses of rd\n * dns labels are represented by a dnslabel class - in most cases\n   this handles conversion to/from textual representation however\n   does support arbitatry labels via a tuple of bytes objects\n\nusage\n-----\n\nto decode a dns packet:\n\n    >>> packet = binascii.unhexlify(b'd5ad818000010005000000000377777706676f6f676c6503636f6d0000010001c00c0005000100000005000803777777016cc010c02c0001000100000005000442f95b68c02c0001000100000005000442f95b63c02c0001000100000005000442f95b67c02c0001000100000005000442f95b93')\n    >>> d = dnsrecord.parse(packet)\n    >>> d\n    <dns header: id=0xd5ad type=response opcode=query flags=rd,ra rcode='noerror' q=1 a=5 ns=0 ar=0>\n    <dns question: 'www.google.com.' qtype=a qclass=in>\n    <dns rr: 'www.google.com.' rtype=cname rclass=in ttl=5 rdata='www.l.google.com.'>\n    <dns rr: 'www.l.google.com.' rtype=a rclass=in ttl=5 rdata='66.249.91.104'>\n    <dns rr: 'www.l.google.com.' rtype=a rclass=in ttl=5 rdata='66.249.91.99'>\n    <dns rr: 'www.l.google.com.' rtype=a rclass=in ttl=5 rdata='66.249.91.103'>\n    <dns rr: 'www.l.google.com.' rtype=a rclass=in ttl=5 rdata='66.249.91.147'>\n\nthe default text representation of the dnsrecord is in zone file format:\n\n    >>> print(d)\n    ;; ->>header<<- opcode: query, status: noerror, id: 54701\n    ;; flags: qr rd ra; query: 1, answer: 5, authority: 0, additional: 0\n    ;; question section:\n    ;www.google.com.                in      a\n    ;; answer section:\n    www.google.com.         5       in      cname   www.l.google.com.\n    www.l.google.com.       5       in      a       66.249.91.104\n    www.l.google.com.       5       in      a       66.249.91.99\n    www.l.google.com.       5       in      a       66.249.91.103\n    www.l.google.com.       5       in      a       66.249.91.147\n\nto create a dns request packet:\n\n    >>> d = dnsrecord.question(\"google.com\")\n\n(this is equivalent to: d = dnsrecord(q=dnsquestion(\"google.com\") )\n\n    >>> d\n    <dns header: id=... type=query opcode=query flags=rd rcode='noerror' q=1 a=0 ns=0 ar=0>\n    <dns question: 'google.com.' qtype=a qclass=in>\n\n    >>> str(dnsrecord.parse(d.pack())) == str(d)\n    true\n\n    >>> print(d)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: rd; query: 1, answer: 0, authority: 0, additional: 0\n    ;; question section:\n    ;google.com.                    in      a\n\n    >>> d = dnsrecord.question(\"google.com\",\"mx\")\n\n(this is equivalent to: d = dnsrecord(q=dnsquestion(\"google.com\",qtype.mx) )\n\n    >>> str(dnsrecord.parse(d.pack())) == str(d)\n    true\n\n    >>> print(d)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: rd; query: 1, answer: 0, authority: 0, additional: 0\n    ;; question section:\n    ;google.com.                    in      mx\n\nto create a dns response packet:\n\n    >>> d = dnsrecord(dnsheader(qr=1,aa=1,ra=1),\n    ...               q=dnsquestion(\"abc.com\"),\n    ...               a=rr(\"abc.com\",rdata=a(\"1.2.3.4\")))\n    >>> d\n    <dns header: id=... type=response opcode=query flags=aa,rd,ra rcode='noerror' q=1 a=1 ns=0 ar=0>\n    <dns question: 'abc.com.' qtype=a qclass=in>\n    <dns rr: 'abc.com.' rtype=a rclass=in ttl=0 rdata='1.2.3.4'>\n    >>> str(dnsrecord.parse(d.pack())) == str(d)\n    true\n\n    >>> print(d)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 1, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      a\n    ;; answer section:\n    abc.com.                0       in      a       1.2.3.4\n\nit is also possible to create rrs from a string in zone file format\n\n    >>> rr.fromzone(\"abc.com in a 1.2.3.4\")\n    [<dns rr: 'abc.com.' rtype=a rclass=in ttl=0 rdata='1.2.3.4'>]\n\n    (note: this produces a list of rrs which should be unpacked if being\n    passed to add_answer/add_auth/add_ar etc)\n\n    >>> q = dnsrecord.question(\"abc.com\")\n    >>> a = q.reply()\n    >>> a.add_answer(*rr.fromzone(\"abc.com 60 a 1.2.3.4\"))\n    >>> print(a)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 1, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      a\n    ;; answer section:\n    abc.com.                60      in      a       1.2.3.4\n\nthe zone file can contain multiple entries and supports most of the normal\nformat defined in rfc1035 (specifically not $include)\n\n    >>> z = '''\n    ...         $ttl 300\n    ...         $origin abc.com\n    ...\n    ...         @       in      mx      10  mail.abc.com.\n    ...         www     in      a       1.2.3.4\n    ...                 in      txt     \"some text\"\n    ...         mail    in      cname   www.abc.com.\n    ... '''\n    >>> for rr in rr.fromzone(textwrap.dedent(z)):\n    ...     print(rr)\n    abc.com.                300     in      mx      10 mail.abc.com.\n    www.abc.com.            300     in      a       1.2.3.4\n    www.abc.com.            300     in      txt     \"some text\"\n    mail.abc.com.           300     in      cname   www.abc.com.\n\nto create a skeleton reply to a dns query:\n\n    >>> q = dnsrecord(q=dnsquestion(\"abc.com\",qtype.any))\n    >>> a = q.reply()\n    >>> a.add_answer(rr(\"abc.com\",qtype.a,rdata=a(\"1.2.3.4\"),ttl=60))\n    >>> str(dnsrecord.parse(a.pack())) == str(a)\n    true\n    >>> print(a)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 1, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      any\n    ;; answer section:\n    abc.com.                60      in      a       1.2.3.4\n\nadd additional rrs:\n\n    >>> a.add_answer(rr(\"xxx.abc.com\",qtype.a,rdata=a(\"1.2.3.4\")))\n    >>> a.add_answer(rr(\"xxx.abc.com\",qtype.aaaa,rdata=aaaa(\"1234:5678::1\")))\n    >>> str(dnsrecord.parse(a.pack())) == str(a)\n    true\n    >>> print(a)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 3, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      any\n    ;; answer section:\n    abc.com.                60      in      a       1.2.3.4\n    xxx.abc.com.            0       in      a       1.2.3.4\n    xxx.abc.com.            0       in      aaaa    1234:5678::1\n\n\nit is also possible to create a reply from a string in zone file format:\n\n    >>> q = dnsrecord(q=dnsquestion(\"abc.com\",qtype.any))\n    >>> a = q.replyzone(\"abc.com 60 in cname xxx.abc.com\")\n    >>> print(a)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 1, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      any\n    ;; answer section:\n    abc.com.                60      in      cname   xxx.abc.com.\n\n    >>> str(dnsrecord.parse(a.pack())) == str(a)\n    true\n\n    >>> q = dnsrecord(q=dnsquestion(\"abc.com\",qtype.any))\n    >>> a = q.replyzone(textwrap.dedent(z))\n    >>> print(a)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: qr aa rd ra; query: 1, answer: 4, authority: 0, additional: 0\n    ;; question section:\n    ;abc.com.                       in      any\n    ;; answer section:\n    abc.com.                300     in      mx      10 mail.abc.com.\n    www.abc.com.            300     in      a       1.2.3.4\n    www.abc.com.            300     in      txt     \"some text\"\n    mail.abc.com.           300     in      cname   www.abc.com.\n\nto send a dnssec request (edns opt record with do flag & header ad flag):\n\n    >>> q = dnsrecord(q=dnsquestion(\"abc.com\",qtype.a))\n    >>> q.add_ar(edns0(flags=\"do\",udp_len=4096))\n    >>> q.header.ad = 1\n    >>> print(q)\n    ;; ->>header<<- opcode: query, status: noerror, id: ...\n    ;; flags: rd ad; query: 1, answer: 0, authority: 0, additional: 1\n    ;; question section:\n    ;abc.com.                       in      a\n    ;; additional section:\n    ;; opt pseudosection\n    ; edns: version: 0, flags: do; udp: 4096\n\nnote that when using the library you should always validate the received txid \n\n    q = dnsrecord.question(\"abc.com\")\n    a_pkt = q.send(address,port,tcp=args.tcp)\n    a = dnsrecord.parse(a_pkt)\n    if q.header.id != a.header.id:\n        raise dnserror('response transaction id does not match query transaction id')\n\nthe library also includes a simple framework for generating custom dns\nresolvers in dnslib.server (see module docs). in most cases this just\nrequires implementing a custom 'resolve' method which receives a question\nobject and returns a response.\n\na number of sample resolvers are provided as examples (see cli --help):\n\n * dnslib.fixedresolver    - respond to all requests with fixed response\n * dnslib.zoneresolver     - respond from zone file\n * dnslib.shellresolver    - call shell script to generate response\n\nthe library includes a number of client utilities:\n\n * dig like client library\n\n        # python -m dnslib.client --help\n\n * dns proxy server\n\n        # python -m dnslib.proxy --help\n\n * intercepting dns proxy server (replace proxy responses for specified domains)\n\n        # python -m dnslib.intercept --help\n\n\nchangelog:\n----------\n\n *   0.1     2010-09-19  initial release\n *   0.2     2010-09-22  minor fixes\n *   0.3     2010-10-02  add dnslabel class to support arbitrary labels (embedded '.')\n *   0.4     2012-02-26  merge with dbslib-circuits\n *   0.5     2012-09-13  add support for rfc2136 ddns updates\n                         patch provided by wesley shields <wxs@freebsd.org> - thanks\n *   0.6     2012-10-20  basic aaaa support\n *   0.7     2012-10-20  add initial edns0 support (untested)\n *   0.8     2012-11-04  add support for naptr, authority rr and additional rr\n                         patch provided by stefan andersson (https://bitbucket.org/norox) - thanks\n *   0.8.1   2012-11-05  added naptr test case and fixed logic error\n                         patch provided by stefan andersson (https://bitbucket.org/norox) - thanks\n *   0.8.2   2012-11-11  patch to fix ipv6 formatting\n                         patch provided by torbjorn lonnemark (https://bitbucket.org/tobbezz) - thanks\n *   0.8.3   2013-04-27  don't parse rdata if rdlength is 0\n                         patch provided by wesley shields <wxs@freebsd.org> - thanks\n *   0.9.0   2014-05-05  major update including py3 support (see docs)\n *   0.9.1   2014-05-05  minor fixes\n *   0.9.2   2014-08-26  fix bimap handling of unknown mappings to avoid exception in printing\n                         add typed attributes to classes\n                         misc fixes from james mills - thanks\n *   0.9.3   2014-08-26  workaround for argparse bug which raises assertionerror if [] is\n                         present in option text (really?)\n *   0.9.4   2015-04-10  fix to support multiple strings in txt record\n                         patch provided by james cherry (https://bitbucket.org/james_cherry) - thanks\n                         note: for consistency this patch changes the 'repr' output for\n                               txt records to always be quoted\n *   0.9.5   2015-10-27  add threading & timeout handling to dnsserver\n *   0.9.6   2015-10-28  replace strftime in rrsig formatting to avoid possible locale issues\n                         identified by bryan everly - thanks\n *   0.9.7   2017-01-15  sort out caa/type257 dig parsing mismatch\n *   0.9.8   2019-02-25  force dnskey key to be bytes object\n                         catch bimap __wrapped__ attr (used by inspect module in 3.7)\n *   0.9.9   2019-03-19  add support for dnssec flag getters/setters (from <raul@dinosec.com> - thanks)\n                         added --dnssec flags to dnslib.client & dnslib.test_decode (sets edns0 do flag)\n                         added edns0 support to dnslib.digparser\n *   0.9.10  2019-03-24  fixes to dnssec support\n                         add nsec rr support\n                         add --dnssec flag to dnslib.client & dnslib.test_decode\n                         quote/unquote non-printable characters in dns labels\n                         update test data\n                         (thanks to <raul@dinosec.com> for help)\n *   0.9.11  2019-12-17  encode notify opcode (issue #26)\n *   0.9.12  2019-12-17  transition master repository to github (bitbucket shutting down hg)\n *   0.9.13  2020-06-01  handle truncated requests in server.py (issue #9)\n                         replace thred.isalive with thread.is_alive (deprecated in py3.9)\n                         merged pull request #4 (extra options for intercept.py) - thanks to @nolanl\n *   0.9.14  2020-06-09  merged pull request #10 (return doctest status via exit code)\n                         thanks to @mgorny\n *   0.9.15  2021-05-07  dnsserver fixes - support ipv6 (from pull request #21) - thanks to @mikma\n                                         - deamon threads (pull request #19) - thanks to @wojons\n                         add unsupported rr types (issue #27)\n *   0.9.16  2021-05-07  merge pull request #23 from tugzrida/patch-1\n                            add support for all rr types to nsec type bitmap\n                         merge pull request #17 from sunds/issue_16\n                            issue 16: uncaught exceptions leak open sockets\n *   0.9.18  2022-01-09  validate txid in client.py (issue #30 - thanks to @daniel4x)\n *   0.9.19  2022-01-09  allow custom log function (logf) in  dnslogger\n                            (issue #31 - thanks to @dmitryfrolovtri)\n *   0.9.20  2022-07-17  fix deprecationwarnings about invalid escape sequences\n                            (pull-request #39 - thanks to @brianmaissy)\n                         make dnslabel matchsuffix and stripsuffix case-insensitive\n                            (pull-request #37 - thanks to @nikize)\n                         add support for https rr\n                            (pull-request #35 - thanks to @jkl-caliber)\n                         fix display of non-printable characters in txt records\n                            (issue #32 - thanks to @sbv-csis)\n                         add --strip-aaaa option to dnslib.proxy \n *   0.9.21  2022-09-19  minor clean-up / add wheels to distro\n *   0.9.22  2022-09027  issue #43 (0.9.21 raises typeerror instead of dnserror when failing to parse https records)\n                         note that we just fix the exception - there still seems to be a problem with parsing https records\n                         (thanks to @robinlandstrom)\n *   0.9.23  2022-10-28  issue #43: https reads after rd end (thanks to @robinlandstrom for pull request)\n                         issue #45: dnslib fails to handle unknown rr types in nsec rd type bitmap\n                            bimap now supports a function to map unknown types which we use to\n                            dynamically map from rtype <-> typexxxx for unknown record types\n                            rr zone representation updated to match rfc3597\n                         pull request #47: add support for ds, sshfp, and tlsa records (thanks to @rmbolger)\n\nlicense:\n--------\n\nbsd\n\nauthor:\n-------\n\n *   paulc\n\nmaster repository/issues:\n-------------------------\n\n *   https://github.com/paulc/dnslib\n\n (note: https://bitbucket.org/paulc/dnslib has been deprecated and will not be updated)\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "dnslib",
  "package_url": "https://pypi.org/project/dnslib/",
  "project_url": "https://pypi.org/project/dnslib/",
  "project_urls": {
    "Homepage": "https://github.com/paulc/dnslib"
  },
  "release_url": "https://pypi.org/project/dnslib/0.9.23/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "simple library to encode/decode dns wire-format packets",
  "version": "0.9.23",
  "releases": [],
  "developers": [
    "paulc"
  ],
  "kwds": "dnslib _dnslib_ dns dnsresolver dnsserver",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_dnslib",
  "homepage": "https://github.com/paulc/dnslib",
  "release_count": 39,
  "dependency_ids": []
}