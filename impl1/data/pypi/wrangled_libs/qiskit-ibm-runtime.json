{
  "classifiers": [
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering"
  ],
  "description": "# qiskit runtime ibm client\n[![license](https://img.shields.io/github/license/qiskit/qiskit-ibm-runtime.svg?style=popout-square)](https://opensource.org/licenses/apache-2.0)\n[![ci](https://github.com/qiskit/qiskit-ibm-runtime/actions/workflows/ci.yml/badge.svg)](https://github.com/qiskit/qiskit-ibm-runtime/actions/workflows/ci.yml)\n[![](https://img.shields.io/github/release/qiskit/qiskit-ibm-runtime.svg?style=popout-square)](https://github.com/qiskit/qiskit-ibm-runtime/releases)\n[![](https://img.shields.io/pypi/dm/qiskit-ibm-runtime.svg?style=popout-square)](https://pypi.org/project/qiskit-ibm-runtime/)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n[![coverage status](https://coveralls.io/repos/github/qiskit/qiskit-ibm-runtime/badge.svg?branch=main)](https://coveralls.io/github/qiskit/qiskit-ibm-runtime?branch=main)\n\n\n**qiskit** is an open-source sdk for working with quantum computers at the level of extended quantum circuits, operators, and primitives.\n\n**qiskit ibm runtime** is a new environment offered by ibm quantum that streamlines quantum computations and provides optimal\nimplementations of the qiskit primitives `sampler` and `estimator` for ibm quantum hardware. it is designed to use additional classical compute resources to execute quantum circuits with more efficiency on quantum processors, by including near-time computations such as error suppression and error mitigation. examples of error suppression include dynamical decoupling, noise-aware compilation, error mitigation including readout mitigation, zero-noise extrapolation (zne), and probabilistic error cancellation (pec).\n\nusing the runtime service, a research team at ibm quantum was able to achieve a 120x speedup\nin their lithium hydride simulation. for more information, see the\n[ibm research blog](https://research.ibm.com/blog/120x-quantum-speedup).\n\nthis module provides the interface to access the qiskit runtime service on ibm quantum platform or ibm cloud.\n\n## installation\n\nyou can install this package using pip:\n\n```bash\npip install qiskit-ibm-runtime\n```\n\n## account setup\n\n### qiskit runtime service on ibm quantum platform\n\nyou will need your ibm quantum api token to authenticate with the runtime service:\n\n1. create an ibm quantum account or log in to your existing account by visiting the [ibm quantum login page].\n\n1. copy (and optionally regenerate) your api token from your\n   [ibm quantum account page].\n\n### qiskit runtime service on ibm cloud\n\nthe runtime service is now part of the ibm quantum services on ibm cloud. to use this service, you'll\nneed to create an ibm cloud account and a quantum service instance.\n[this guide](https://cloud.ibm.com/docs/quantum-computing?topic=quantum-computing-get-started)\ncontains step-by-step instructions, including how to find your\nibm cloud api key and cloud resource name (crn), which you will need for authentication.\n\n\n### save your account on disk\n\nonce you have the account credentials, you can save them on disk, so you won't have to input\nthem each time. the credentials are saved in the `$home/.qiskit/qiskit-ibm.json` file, where `$home` is your home directory.\n\n| :warning: account credentials are saved in plain text, so only do so if you are using a trusted device. |\n|:---------------------------|\n\n ```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice\n\n# save an ibm cloud account.\nqiskitruntimeservice.save_account(channel=\"ibm_cloud\", token=\"my_ibm_cloud_api_key\", instance=\"my_ibm_cloud_crn\")\n\n# save an ibm quantum account.\nqiskitruntimeservice.save_account(channel=\"ibm_quantum\", token=\"my_ibm_quantum_token\")\n```\n\nonce the account is saved on disk, you can instantiate the service without any arguments:\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice\nservice = qiskitruntimeservice()\n```\n\n### loading account from environment variables\n\nalternatively, the service can discover credentials from environment variables:\n```bash\nexport qiskit_ibm_token=\"my_ibm_cloud_api_key\"\nexport qiskit_ibm_instance=\"my_ibm_cloud_crn\"\nexport qiskit_ibm_channel=\"ibm_cloud\"\n```\n\nthen instantiate the service without any arguments:\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice\nservice = qiskitruntimeservice()\n```\n\n### enabling account for current python session\n\nas another alternative, you can also enable an account just for the current session by instantiating the\nservice with your credentials.\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice\n\n# for an ibm cloud account.\nibm_cloud_service = qiskitruntimeservice(channel=\"ibm_cloud\", token=\"my_ibm_cloud_api_key\", instance=\"my_ibm_cloud_crn\")\n\n# for an ibm quantum account.\nibm_quantum_service = qiskitruntimeservice(channel=\"ibm_quantum\", token=\"my_ibm_quantum_token\")\n```\n\n## primitives\n\nall quantum applications and algorithms level are fundamentally built using three steps:\n1. choose a quantum circuit to encode the quantum state.\n2. define the observable or the classical register to be measured.\n4. execute the quantum circuits by using a primitive (estimator or sampler).\n\n**primitives** are base-level functions that serve as building blocks for many quantum algorithms and applications. the [primitive interfaces](https://qiskit.org/documentation/apidoc/primitives.html) are defined in qiskit.\n\nthe ibm runtime service offers these primitives with additional features, such as built-in error suppression and mitigation.\n\nthere are several different options you can specify when calling the primitives. see [`qiskit_ibm_runtime.options`](https://github.com/qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/options/options.py#l33) class for more information.\n\n### sampler\n\nthis primitive takes a list of user circuits (including measurements) as input and generates an error-mitigated readout of quasi-probability distributions. this provides users a way to better evaluate shot results using error mitigation, and enables them to more efficiently evaluate the possibility of multiple relevant data points in the context of destructive interference.\n\nto invoke the `sampler` primitive\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice, options, sampler\nfrom qiskit import quantumcircuit\n\nservice = qiskitruntimeservice()\noptions = options(optimization_level=1)\noptions.execution.shots = 1024  # options can be set using auto-complete.\n\n# 1. a quantum circuit for preparing the quantum state (|00> + |11>)/rt{2}\nbell = quantumcircuit(2)\nbell.h(0)\nbell.cx(0, 1)\n\n# 2. map the qubits to a classical register in ascending order\nbell.measure_all()\n\n# 3. execute using the sampler primitive\nbackend = service.get_backend('ibmq_qasm_simulator')\nsampler = sampler(backend=backend, options=options)\njob = sampler.run(circuits=bell)\nprint(f\"job id is {job.job_id()}\")\nprint(f\"job result is {job.result()}\")\n```\n\n### estimator\n\nthis primitive takes circuits and observables as input, to evaluate expectation values and variances for a given parameter input. this estimator allows users to efficiently calculate and interpret expectation values of quantum operators required for many algorithms.\n\nto invoke the `estimator` primitive:\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice, options, estimator\nfrom qiskit.quantum_info import sparsepauliop\nfrom qiskit import quantumcircuit\nfrom qiskit.circuit import parameter\nimport numpy as np\n\nservice = qiskitruntimeservice()\noptions = options(optimization_level=1)\noptions.execution.shots = 1024  # options can be set using auto-complete.\n\n# 1. a quantum circuit for preparing the quantum state (|000> + e^{itheta} |111>)/rt{2}\ntheta = parameter('\u03b8')\nqc_example = quantumcircuit(3)\nqc_example.h(0) # generate superposition\nqc_example.p(theta, 0) # add quantum phase\nqc_example.cx(0, 1) # condition 1st qubit on 0th qubit\nqc_example.cx(0, 2) # condition 2nd qubit on 0th qubit\n\n# 2. the observable to be measured\nm1 = sparsepauliop.from_list([(\"xxy\", 1), (\"xyx\", 1), (\"yxx\", 1), (\"yyy\", -1)])\n\n# batch of theta parameters to be executed\npoints = 50\ntheta1 = []\nfor x in range(points):\n    theta = [x*2.0*np.pi/50]\n    theta1.append(theta)\n\n# 3. execute using the estimator primitive\nbackend = service.get_backend('ibmq_qasm_simulator')\nestimator = estimator(backend, options=options)\njob = estimator.run(circuits=[qc_example]*points, observables=[m1]*points, parameter_values=theta1)\nprint(f\"job id is {job.job_id()}\")\nprint(f\"job result is {job.result().values}\")\n```\n\nthis code batches together 50 parameters to be executed in a single job. if a user wanted to find the `theta` that optimized the observable, they could plot and observe it occurs at `theta=np.pi/2`. for speed we recommend batching results together (note that depending on your access, there may be limits on the number of circuits, objects, and parameters that you can send).\n\n\n## session\n\nin many algorithms and applications, an estimator needs to be called iteratively without incurring queuing delays on each iteration. to solve this, the ibm runtime service provides a **session**. a session starts when the first job within the session is started, and subsequent jobs within the session are prioritized by the scheduler.\n\nyou can use the [`qiskit_ibm_runtime.session`](https://github.com/qiskit/qiskit-ibm-runtime/blob/main/qiskit_ibm_runtime/session.py) class to start a\nsession. consider the same example above and try to find the optimal `theta`. the following example uses the [golden search method](https://en.wikipedia.org/wiki/golden-section_search) to iteratively find the optimal theta that maximizes the observable.\n\nto invoke the `estimator` primitive within a session:\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice, session, options, estimator\nfrom qiskit.quantum_info import sparsepauliop\nfrom qiskit import quantumcircuit\nfrom qiskit.circuit import parameter\nimport numpy as np\n\nservice = qiskitruntimeservice()\noptions = options(optimization_level=1)\noptions.execution.shots = 1024  # options can be set using auto-complete.\n\n# 1. a quantum circuit for preparing the quantum state (|000> + e^{itheta} |111>)/rt{2}\ntheta = parameter('\u03b8')\nqc_example = quantumcircuit(3)\nqc_example.h(0) # generate superpostion\nqc_example.p(theta,0) # add quantum phase\nqc_example.cx(0, 1) # condition 1st qubit on 0th qubit\nqc_example.cx(0, 2) # condition 2nd qubit on 0th qubit\n\n# 2. the observable to be measured\nm1 = sparsepauliop.from_list([(\"xxy\", 1), (\"xyx\", 1), (\"yxx\", 1), (\"yyy\", -1)])\n\n\ngr = (np.sqrt(5) + 1) / 2 # golden ratio\nthetaa = 0 # lower range of theta\nthetab = 2*np.pi # upper range of theta\ntol = 1e-1 # tol\n\n# 3. execute iteratively using the estimator primitive\nwith session(service=service, backend=\"ibmq_qasm_simulator\") as session:\n    estimator = estimator(session=session, options=options)\n    #next test range\n    thetac = thetab - (thetab - thetaa) / gr\n    thetad = thetaa + (thetab - thetaa) / gr\n    while abs(thetab - thetaa) > tol:\n        print(f\"max value of m1 is in the range theta = {[thetaa, thetab]}\")\n        job = estimator.run(circuits=[qc_example]*2, observables=[m1]*2, parameter_values=[[thetac],[thetad]])\n        test =job.result().values\n        if test[0] > test[1]:\n            thetab = thetad\n        else:\n            thetaa = thetac\n        thetac = thetab - (thetab - thetaa) / gr\n        thetad = thetaa + (thetab - thetaa) / gr\n\n    # final job to evaluate estimator at midpoint found using golden search method\n    theta_mid = (thetab + thetaa) / 2\n    job = estimator.run(circuits=qc_example, observables=m1, parameter_values=theta_mid)\n    print(f\"session id is {session.session_id}\")\n    print(f\"final job id is {job.job_id()}\")\n    print(f\"job result is {job.result().values} at theta = {theta_mid}\")\n```\n\nthis code returns `job result is [4.] at theta = 1.575674623307102` using only nine iterations. this is a very powerful extension to the primitives. however, using too much code between iterative calls can lock the qpu and use excessive qpu time, which is expensive. we recommend only using sessions when needed. the sampler can also be used within a session, but there are not any well-defined examples for this.\n\n## instances\n\naccess to ibm quantum platform channel is controlled by the instances (previously called providers) to which you are assigned. an instance is defined by a hierarchical organization of hub, group, and project. a hub is the top level of a given hierarchy (organization) and contains within it one or more groups. these groups are in turn populated with projects. the combination of hub/group/project is called an instance. users can belong to more than one instance at any time.\n\n> **_note:_** ibm cloud instances are different from ibm quantum platform instances.  ibm cloud does not use the hub/group/project structure for user management. to view and create ibm cloud instances, visit the [ibm cloud quantum instances page](https://cloud.ibm.com/quantum/instances).\n\nto view a list of your instances, visit your [account settings page](https://www.quantum-computing.ibm.com/account) or use the `instances()` method.\n\nyou can specify an instance when initializing the service or provider, or when picking a backend:\n\n```python\n# optional: list all the instances you can access.\nservice = qiskitruntimeservice(channel='ibm_quantum')\nprint(service.instances())\n\n# optional: specify the instance at service level. this becomes the default unless overwritten.\nservice = qiskitruntimeservice(channel='ibm_quantum', instance=\"hub1/group1/project1\")\nbackend1 = service.backend(\"ibmq_manila\")\n\n# optional: specify the instance at the backend level, which overwrites the service-level specification when this backend is used.\nbackend2 = service.backend(\"ibmq_manila\", instance=\"hub2/group2/project2\")\n\nsampler1 = sampler(backend=backend1)    # this will use hub1/group1/project1\nsampler2 = sampler(backend=backend2)    # this will use hub2/group2/project2\n```\n\nif you do not specify an instance, then the code will select one in the following order:\n\n1. if your account only has access to one instance, it is selected by default.\n2. if your account has access to multiple instances, but only one can access the requested backend, the instance with access is selected.\n3. in all other cases, the code selects the first instance other than ibm-q/open/main that has access to the backend.\n\n## access your ibm quantum backends\n\na **backend** is a quantum device or simulator capable of running quantum circuits or pulse schedules.\n\nyou can query for the backends you have access to. attributes and methods of the returned instances\nprovide information, such as qubit counts, error rates, and statuses, of the backends.\n\n```python\nfrom qiskit_ibm_runtime import qiskitruntimeservice\nservice = qiskitruntimeservice()\n\n# display all backends you have access.\nprint(service.backends())\n\n# get a specific backend.\nbackend = service.backend('ibmq_qasm_simulator')\n\n# print backend coupling map.\nprint(backend.coupling_map)\n```\n\n## next steps\n\nnow you're set up and ready to check out some of the [tutorials].\n\n## contribution guidelines\n\nif you'd like to contribute to qiskit-ibm-runtime, please take a look at our\n[contribution guidelines]. this project adheres to qiskit's [code of conduct].\nby participating, you are expected to uphold to this code.\n\nwe use [github issues] for tracking requests and bugs. please use our [slack]\nfor discussion and simple questions. to join our slack community use the\ninvite link at [qiskit.org]. for questions that are more suited for a forum we\nuse the `qiskit` tag in [stack exchange].\n\n## license\n\n[apache license 2.0].\n\n\n[ibm quantum]: https://www.ibm.com/quantum-computing/\n[ibm quantum login page]:  https://quantum-computing.ibm.com/login\n[ibm quantum account page]: https://quantum-computing.ibm.com/account\n[contribution guidelines]: https://github.com/qiskit/qiskit-ibm-runtime/blob/main/contributing.md\n[code of conduct]: https://github.com/qiskit/qiskit-ibm-runtime/blob/main/code_of_conduct.md\n[github issues]: https://github.com/qiskit/qiskit-ibm-runtime/issues\n[slack]: https://qiskit.slack.com\n[qiskit.org]: https://qiskit.org\n[stack exchange]: https://quantumcomputing.stackexchange.com/questions/tagged/qiskit\n[many people]: https://github.com/qiskit/qiskit-ibm-runtime/graphs/contributors\n[bibtex file]: https://github.com/qiskit/qiskit/blob/master/qiskit.bib\n[apache license 2.0]: https://github.com/qiskit/qiskit-ibm-runtime/blob/main/license.txt\n[tutorials]: https://github.com/qiskit/qiskit-ibm-runtime/tree/main/docs/tutorials\n",
  "docs_url": null,
  "keywords": "qiskit sdk quantum api runtime ibm",
  "license": "apache 2.0",
  "name": "qiskit-ibm-runtime",
  "package_url": "https://pypi.org/project/qiskit-ibm-runtime/",
  "project_url": "https://pypi.org/project/qiskit-ibm-runtime/",
  "project_urls": {
    "Bug Tracker": "https://github.com/Qiskit/qiskit-ibm-runtime/issues",
    "Documentation": "https://qiskit.org/documentation/",
    "Homepage": "https://github.com/Qiskit/qiskit-ibm-runtime",
    "Source Code": "https://github.com/Qiskit/qiskit-ibm-runtime"
  },
  "release_url": "https://pypi.org/project/qiskit-ibm-runtime/0.17.0/",
  "requires_dist": [
    "qiskit >=0.44.1",
    "requests >=2.19",
    "requests-ntlm >=1.1.0",
    "numpy >=1.13",
    "urllib3 >=1.21.1",
    "python-dateutil >=2.8.0",
    "websocket-client >=1.5.1",
    "ibm-platform-services >=0.22.6",
    "qiskit-ibm-provider >=0.7.2"
  ],
  "requires_python": ">=3.8",
  "summary": "ibm quantum client for qiskit runtime.",
  "version": "0.17.0",
  "releases": [],
  "developers": [
    "hello@qiskit.org",
    "qiskit_development_team"
  ],
  "kwds": "qiskit_ibm_token qiskit_ibm_runtime ibm_quantum ibm_quantum_service qiskit_ibm_instance",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_qiskit_ibm_runtime",
  "homepage": "https://github.com/qiskit/qiskit-ibm-runtime",
  "release_count": 35,
  "dependency_ids": [
    "pypi_ibm_platform_services",
    "pypi_numpy",
    "pypi_python_dateutil",
    "pypi_qiskit",
    "pypi_qiskit_ibm_provider",
    "pypi_requests",
    "pypi_requests_ntlm",
    "pypi_urllib3",
    "pypi_websocket_client"
  ]
}