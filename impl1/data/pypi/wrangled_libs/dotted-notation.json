{
  "classifiers": [
    "development status :: 3 - alpha",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "# dotted\n\nsometimes you want to fetch data from a deeply nested data structure. dotted notation\nhelps you do that.\n\nlet's say you have a dictionary containing a dictionary containing a list and you wish\nto fetch the ith value from that nested list.\n\n    >>> import dotted\n    >>> d = {'hi': {'there': [1, 2, 3]}}\n    >>> dotted.get(d, 'hi.there[1]')\n    2\n\n## api\n\nprobably the easiest thing to do is pydoc the api layer.\n\n    $ pydoc dotted.api\n\n### get\n\nsee grammar discussion below about things you can do get data via dotted.\n\n    >>> import dotted\n    >>> dotted.get({'a': {'b': {'c': {'d': 'nested'}}}}, 'a.b.c.d')\n    'nested'\n\n### update\n\nupdate will mutate the object if it can.  it always returns the changed object though. if\nit's not mutable, then get via the return.\n\n    >>> import dotted\n    >>> l = []\n    >>> t = ()\n    >>> dotted.update(l, '[0]', 'hello')\n    ['hello']\n    >>> l\n    ['hello']\n    >>> dotted.update(t, '[0]', 'hello')\n    ('hello',)\n    >>> t\n    ()\n    ```\n#### update via pattern\n\nyou can update all fields that match pattern given by either a wildcard or regex.\n\n    >>> import dotted\n    >>> d = {'a': 'hello', 'b': {'bye'}}\n    >>> dotted.update(d, '*', 'me')\n    {'a': 'me', 'b': 'me'}\n\n### remove\n\nyou can remove a field or do so only if it matches value.  for example,\n\n    >>> import dotted\n    >>> d = {'a': 'hello', 'b': 'bye'}\n    >>> dotted.remove(d, 'b')\n    {'a': 'hello'}\n    >>> dotted.remove(d, 'a', 'bye')\n    {'a': 'hello'}\n\n#### remove via pattern\n\nsimilar to update, all patterns that match will be removed.  if you provide a value as\nwell, only the matched patterns that also match the value will be removed.\n\n### match\n\nuse to match a dotted-style pattern to a field.  partial matching is on by default.  you\ncan match via wildcard or via regex.  here's a regex example:\n\n    >>> import dotted\n    >>> dotted.match('/a.+/', 'abced.b')\n    'abced.b'\n    >>> dotted.match('/a.+/', 'abced.b', partial=false)\n\nwith the `groups=true` parameter, you'll see how it was matched:\n\n    >>> import dotted\n    >>> match('hello.*', 'hello.there.bye', groups=true)\n    ('hello.there.bye', ('hello', 'there.bye'))\n\nin the above example, `hello` matched to `hello` and `*` matched to `there.bye` (partial\nmatching is enabled by default).\n\n### expand\n\nyou may wish to _expand_ all fields that match a pattern in an object.\n\n    >>> import dotted\n    >>> d = {'hello': {'there': [1, 2, 3]}, 'bye': 7}\n    >>> dotted.expand(d, '*')\n    ('hello', 'bye')\n    >>> dotted.expand(d, '*.*')\n    ('hello.there',)\n    >>> dptted.expand(d, '*.*[*]')\n    ('hello.there[0]', 'hello.there[1]', 'hello.there[2]')\n    >>> dotted.expand(d, '*.*[1:]')\n    ('hello.there[1:]',)\n\n## grammar\n\ndotted notation shares similarities with python. a _dot_ `.` field expects to see a\ndictionary-like object (using `keys` and `__getitem__` internally.  a _bracket_ `[]`\nfield is biased towards sequences (like lists or strs) but can also act on dicts.  a\n_attr_ `@` field uses `getattr/setattr/delattr`.  dotted also support slicing notation\nas well as transforms discussed below.\n\n### key fields\n\na key field is expressed as `a` or part of a dotted expression, such as `a.b`.  the\ngrammar parser is permissive for what can be in a key field.  pretty much any non-reserved\nchar will match.  note that key fields will only work on objects that have a `keys`\nmethod.  basically, they work with dictionary or dictionary-like objects.\n\n    >>> import dotted\n    >>> dotted.get({'a': {'b': 'hello'}}, 'a.b')\n    'hello'\n\nif the key field starts with a space or `-`, you should either quote it or you may use\na `\\` as the first char.\n\n### bracketed fields\n\nyou may also use bracket notation, such as `a[0]` which does a `__getitem__` at key 0.\nthe parser prefers numeric types over string types (if you wish to look up a non-numeric\nfield using brackets be sure to quote it).  bracketed fields will work with pretty much\nany object that can be looked up via `__getitem__`.\n\n    >>> import dotted\n    >>> dotted.get({'a': ['first', 'second', 'third']}, 'a[0]')\n    'first'\n    >>> dotted.get({'a': {'b': 'hello'}}, 'a[\"b\"]')\n    'first'\n\n### attr fields\n\nan attr field is expressed by prefixing with `@`. this will fetch data at that attribute.\nyou may wonder why have this when you can just as easily use standard python to access.\ntwo important reasons: nested expressions and patterns.\n\n    >>> import dotted, types\n    >>> ns = types.simplenamespace\n    >>> ns.hello = {'me': 'goodbye'}\n    >>> dotted.get(ns, '@hello.me')\n    'goodbye'\n\n### numeric types\n\nthe parser will attempt to interpret a field numerically if it can, such as `field.1`\nwill interpret the `1` part numerically.\n\n    >>> import dotted\n    >>> dotted.get({'7': 'me', 7: 'you'}, '7')\n    'you'\n\n### quoting\n\nsometimes you need to quote a field which you can do by just putting the field in quotes.\n\n    >>> import dotted\n    >>> dotted.get({'has . in it': 7}, '\"has . in it\"')\n    7\n\n### the numericize `#` operator\n\nnon-integer numeric fields may be interpreted incorrectly if they have decimal point. to\nsolve, use the numerize operator `#` at the front of a quoted field, such as `#'123.45'`.\nthis will coerce to a numeric type (e.g. float).\n\n    >>> import dotted\n    >>> d = {'a': {1.2: 'hello', 1: {2: 'fooled you'}}}\n    >>> dotted.get(d, 'a.1.2')\n    'fooled you'\n    >>> dotted.get(d, 'a.#\"1.2\"')\n    'hello'\n\n### slicing\n\ndotted slicing works like python slicing and all that entails.\n\n    >>> import dotted\n    >>> d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}\n    >>> dotted.get(d, 'hi.there[::2]')\n    [1, 3]\n    >>> dotted.get(d, '*.there[1:]')\n    ([2, 3], [5, 6])\n\n### the append `+` operator\n\nboth bracketed fileds and slices support the '+' operator which refers to the end of\nsequence. you may append an item or slice to the end a sequence.\n\n    >>> import dotted\n    >>> d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}\n    >>> dotted.update(d, '*.there[+]', 8)\n    {'hi': {'there': [1, 2, 3, 8]}, 'bye': {'there': [4, 5, 6, 8]}}\n    >>> dotted.update(d, '*.there[+:]', [999])\n    {'hi': {'there': [1, 2, 3, 8, 999]}, 'bye': {'there': [4, 5, 6, 8, 999]}}\n\n### the append-unique `+?` operator\n\nif you want to update only _unique_ items to a list, you can use the `?`\npostfix.  this will ensure that it's only added once (see match-first below).\n\n    >>> import dotted\n    >>> items = [1, 2]\n    >>> dotted.update(items, '[+?]', 3)\n    [1, 2, 3]\n    >>> dotted.update(items, '[+?]', 3)\n    [1, 2, 3]\n\n### the invert `-` operator\n\nyou can invert the meaning of the notation by prefixing a `-`.  for example,\nto remove an item using `update`:\n\n    >>> import dotted\n    >>> d = {'a': 'hello', 'b': 'bye'}\n    >>> dotted.update(d, '-b', dotted.any)\n    {'a': 'hello'}\n    >>> dotted.remove(d, '-b', 'bye again')\n    {'a': 'hello', 'b': 'bye again'}\n\n## patterns\n\nyou may use dotted for pattern matching. you can match to wildcards or regular\nexpressions.  you'll note that patterns always return a tuple of matches.\n\n    >>> import dotted\n    >>> d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}\n    >>> dotted.get(d, '*.there[2]')\n    (3, 6)\n    >>> dotted.get(d, '/h.*/.*')\n    ([1, 2, 3],)\n\ndotted will return all values that match the pattern(s).\n\n### wildcards\n\nthe wildcard pattern is `*`.  it will match anything.\n\n### regular expressions\n\nthe regex pattern is enclosed in slashes: `/regex/`. note that if the field is a non-str,\nthe regex pattern will internally match to its str representation.\n\n### the match-first operatoer\n\nyou can also postfix any pattern with a `?`.  this will return only\nthe first match.\n\n    >>> import dotted\n    >>> d = {'hi': {'there': [1, 2, 3]}, 'bye': {'there': [4, 5, 6]}}\n    >>> dotted.get(d, '*?.there[2]')\n    (3,)\n\n## transforms\n\nyou can optionally add transforms to the end of dotted notation. these will\nbe applied on `get` and `update`. transforms are separated by the `|` operator\nand multiple may be chained together. transforms may be parameterized using\nthe `:` operator.\n\n    >>> import dotted\n    >>> d = [1, '2', 3]\n    >>> dotted.get(d, '[1]')\n    '2'\n    >>> dotted.get(d, '[1]|int')\n    2\n    >>> dotted.get(d, '[0]|str:number=%d')\n    'number=1'\n\nyou may register new transforms via either `register` or the `@transform`\ndecorator. look at transforms.py for preregistered.\n\n## filters\n\n### the key-value filter\n\nyou may filter by key-value to narrow your result set.  you may use with __key__ or\n__bracketed__ fields.  key-value fields may be disjunctively (or) specified via the `,`\ndelimiter.\n\na key-value field on __key__ field looks like: `keyfield.key1=value1,key2=value2...`.\nthis will return all key-value matches on a subordinate dict-like object.  for example,\n\n    >>> d = {\n    ...    'a': {\n    ...         'id': 1,\n    ...         'hello': 'there',\n    ...     },\n    ...     'b': {\n    ...         'id': 2,\n    ...         'hello': 'there',\n    ...     },\n    ... }\n    >>> dotted.get(d, '*.id=1')\n    ({'id': 1, 'hello': 'there'},)\n    >>> dotted.get(d, '*.id=*')\n    ({'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'})\n\na key-value field on a __bracketed__ field looks like: `[key1=value1,key2=value2...]`.\nthis will return all items in a list that match key-value filter.  for example,\n\n    >>> d = {\n    ...     'a': [{'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'}],\n    ...     'b': [{'id': 3, 'hello': 'there'}, {'id': 4, 'hello': 'bye'}],\n    ... }\n    >>> dotted.get(d, 'a[hello=\"there\"][*].id')\n    (1, 2)\n    >>> dotted.get(d, '*[hello=\"there\"][*].id')\n    r == (1, 2, 3)\n\n### the key-value first filter\n\nyou can have it match first by appending a `?` to the end of the filter.\n\n    >>> d = {\n    ...     'a': [{'id': 1, 'hello': 'there'}, {'id': 2, 'hello': 'there'}],\n    ...     'b': [{'id': 3, 'hello': 'there'}, {'id': 4, 'hello': 'bye'}],\n    ... }\n    >>> dotted.get(d, 'a[hello=\"there\"?]')\n    return [{'id': 1, 'hello': 'there'}]\n\n### conjunction vs disjunction\n\nto _conjunctively_ connect filters use the `.` operator. filters offer the ability to act\n_disjunctively_ as well by using the `,` operator.\n\nfor example, given\n`*.key1=value1,key2=value2.key3=value3`. this will filter\n(`key1=value1` or `key2=value2`) and `key3=value3`.\n\nnote that this gives you the abilty to have a key filter multiple values, such as:\n`*.key1=value1,key2=value2`.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "dotted-notation",
  "package_url": "https://pypi.org/project/dotted-notation/",
  "project_url": "https://pypi.org/project/dotted-notation/",
  "project_urls": {
    "Homepage": "https://github.com/freywaid/dotted"
  },
  "release_url": "https://pypi.org/project/dotted-notation/0.11.0/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "dotted notation parser with pattern matching",
  "version": "0.11.0",
  "releases": [],
  "developers": [
    "frey_waid",
    "logophage1@gmail.com"
  ],
  "kwds": "dotted dict dicts dictionary pydoc",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_dotted_notation",
  "homepage": "https://github.com/freywaid/dotted",
  "release_count": 53,
  "dependency_ids": []
}