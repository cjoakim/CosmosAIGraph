{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: debuggers",
    "topic :: system :: monitoring",
    "topic :: system :: networking",
    "topic :: utilities"
  ],
  "description": "========\noverview\n========\n\n\n\n\nfeatures\n========\n\n* uses unix domain sockets, only root or same effective user can connect.\n* can run the connection in a thread or in a signal handler (see ``oneshot_on`` option).\n* can start the thread listening for connections from a signal handler (see ``activate_on`` option)\n* compatible with apps that fork, reinstalls the manhole thread after fork - had to monkeypatch os.fork/os.forkpty for\n  this.\n* compatible with gevent and eventlet with some limitations - you need to either:\n\n  * use ``oneshot_on``, *or*\n  * disable thread monkeypatching (eg: ``gevent.monkey.patch_all(thread=false)``, ``eventlet.monkey_patch(thread=false)``\n\n  note: on eventlet `you might <https://github.com/eventlet/eventlet/issues/401>`_ need to setup the hub first to prevent\n  circular import problems:\n\n  .. sourcecode:: python\n\n    import eventlet\n    eventlet.hubs.get_hub()  # do this first\n    eventlet.monkey_patch(thread=false)\n\n* the thread is compatible with apps that use signalfd (will mask all signals for the manhole threads).\n\noptions\n-------\n\n.. code-block:: python\n\n    manhole.install(\n        verbose=true,\n        verbose_destination=2,\n        patch_fork=true,\n        activate_on=none,\n        oneshot_on=none,\n        sigmask=manhole.all_signals,\n        socket_path=none,\n        reinstall_delay=0.5,\n        locals=none,\n        strict=true,\n    )\n\n* ``verbose`` - set it to ``false`` to squelch the logging.\n* ``verbose_destination`` - destination for verbose messages. set it to a file descriptor or handle. default is\n  unbuffered stderr (stderr ``2`` file descriptor).\n* ``patch_fork`` - set it to ``false`` if you don't want your ``os.fork`` and ``os.forkpy`` monkeypatched\n* ``activate_on`` - set to ``\"usr1\"``, ``\"usr2\"`` or some other signal name, or a number if you want the manhole thread\n  to start when this signal is sent. this is desirable in case you don't want the thread active all the time.\n* ``thread`` - set to ``true`` to start the always-on manholethread. default: ``true``.\n  automatically switched to ``false`` if ``oneshot_on`` or ``activate_on`` are used.\n* ``oneshot_on`` - set to ``\"usr1\"``, ``\"usr2\"`` or some other signal name, or a number if you want the manhole to\n  listen for connection in the signal handler. this is desireable in case you don't want threads at all.\n* ``sigmask`` - will set the signal mask to the given list (using ``signalfd.sigprocmask``). no action is done if\n  ``signalfd`` is not importable. **note**: this is done so that the manhole thread doesn't *steal* any signals;\n  normally that is fine because python will force all the signal handling to be run in the main thread but signalfd\n  doesn't.\n* ``socket_path`` - use a specific path for the unix domain socket (instead of ``/tmp/manhole-<pid>``). this disables\n  ``patch_fork`` as children cannot reuse the same path.\n* ``reinstall_delay`` - delay the unix domain socket creation *reinstall_delay* seconds. this alleviates\n  cleanup failures when using fork+exec patterns.\n* ``locals`` - names to add to manhole interactive shell locals.\n* ``daemon_connection`` - the connection thread is daemonic (dies on app exit). default: ``false``.\n* ``redirect_stderr`` - redirect output from stderr to manhole console. default: ``true``.\n* ``strict`` - if ``true`` then ``alreadyinstalled`` will be raised when attempting to install manhole twice.\n  default: ``true``.\n\nenvironment variable installation\n---------------------------------\n\nmanhole can be installed via the ``pythonmanhole`` environment variable.\n\nthis::\n\n    pythonmanhole='' python yourapp.py\n\nis equivalent to having this in ``yourapp.py``::\n\n    import manhole\n    manhole.install()\n\nany extra text in the environment variable is passed to ``manhole.install()``. example::\n\n    pythonmanhole='onshot_on=\"usr2\"' python yourapp.py\n\nwhat happens when you actually connect to the socket\n----------------------------------------------------\n\n1. credentials are checked (if it's same user or root)\n2. ``sys.__std*__``/``sys.std*`` are redirected to the uds\n3. stacktraces for each thread are written to the uds\n4. repl is started so you can fiddle with the process\n\nknown issues\n============\n\n* using threads and file handle (not raw file descriptor) ``verbose_destination`` can cause deadlocks. see bug reports:\n  `pypy <https://foss.heptapod.net/pypy/pypy/-/issues/1895>`_ and `python 3.4 <http://bugs.python.org/issue22697>`_.\n\nsigterm and socket cleanup\n--------------------------\n\nby default python doesn't call the ``atexit`` callbacks with the default sigterm handling. this makes manhole leave\nstray socket files around. if this is undesirable you should install a custom sigterm handler so ``atexit`` is\nproperly invoked.\n\nexample:\n\n.. code-block:: python\n\n    import signal\n    import sys\n\n    def handle_sigterm(signo, frame):\n        sys.exit(128 + signo)  # this will raise systemexit and cause atexit to be called\n\n    signal.signal(signal.sigterm, handle_sigterm)\n\nusing manhole with uwsgi\n------------------------\n\nbecause uwsgi overrides signal handling manhole is a bit more tricky to setup. one way is to use \"uwsgi signals\" (not\nthe posix signals) and have the workers check a file for the pid you want to open the manhole in.\n\nstick something this in your wsgi application file:\n\n.. sourcecode:: python\n\n    from __future__ import print_function\n    import sys\n    import os\n    import manhole\n\n    stack_dump_file = '/tmp/manhole-pid'\n    uwsgi_signal_number = 17\n\n    try:\n        import uwsgi\n\n        if not os.path.exists(stack_dump_file):\n            open(stack_dump_file, 'w')\n\n        def open_manhole(dummy_signum):\n            with open(stack_dump_file, 'r') as fh:\n                pid = fh.read().strip()\n                if pid == str(os.getpid()):\n                    inst = manhole.install(strict=false, thread=false)\n                    inst.handle_oneshot(dummy_signum, dummy_signum)\n\n        uwsgi.register_signal(uwsgi_signal_number, 'workers', open_manhole)\n        uwsgi.add_file_monitor(uwsgi_signal_number, stack_dump_file)\n\n        print(\"listening for stack mahole requests via %r\" % (stack_dump_file,), file=sys.stderr)\n    except importerror:\n        print(\"not running under uwsgi; unable to configure manhole trigger\", file=sys.stderr)\n    except ioerror:\n        print(\"ioerror creating manhole trigger %r\" % (stack_dump_file,), file=sys.stderr)\n\n\n    # somewhere bellow you'd have something like\n    from django.core.wsgi import get_wsgi_application\n    application = get_wsgi_application()\n    # or\n    def application(environ, start_response):\n        start_response('200 ok', [('content-type', 'text/plain'), ('content-length', '2')])\n        yield b'ok'\n\nto open the manhole just run `echo 1234 > /tmp/manhole-pid` and then `manhole-cli 1234`.\n\nrequirements\n============\n\n:os: linux, os x\n:runtime: python 2.7, 3.4, 3.5, 3.6 or pypy\n\nsimilar projects\n================\n\n* twisted's `manhole <http://twistedmatrix.com/documents/current/api/twisted.conch.manhole.html>`__ - it has colors and\n  server-side history.\n* `wsgi-shell <https://github.com/grahamdumpleton/wsgi-shell>`_ - spawns a thread.\n* `pyrasite <https://github.com/lmacken/pyrasite>`_ - uses gdb to inject code.\n* `pydbattach <https://github.com/albertz/pydbattach>`_ - uses gdb to inject code.\n* `pystuck <https://github.com/alonho/pystuck>`_ - very similar, uses `rpyc <https://github.com/tomerfiliba/rpyc>`_ for\n  communication.\n* `pyringe <https://github.com/google/pyringe>`_ - uses gdb to inject code, more reliable, but relies on `dbg` python\n  builds unfortunatelly.\n* `pdb-clone <https://pypi.python.org/pypi/pdb-clone>`_ - uses gdb to inject code, with a `different strategy\n  <https://code.google.com/p/pdb-clone/wiki/remotedebugging>`_.\n\n\nchangelog\n=========\n\n1.8.0 (2021-04-08)\n------------------\n\n* simplified connection closing code.\n  contributed by anton ryzhov in `#62 <https://github.com/ionelmc/python-manhole/pull/62>`_.\n* made connection shutdown in ``manhole-cli`` more graceful.\n  contributed by anton ryzhov in `#63 <https://github.com/ionelmc/python-manhole/pull/63>`_.\n\n1.7.0 (2021-03-22)\n------------------\n\n* fixed memory leak via ``sys.last_type``, ``sys.last_value``, ``sys.last_traceback``.\n  contributed by anton ryzhov in `#59 <https://github.com/ionelmc/python-manhole/pull/59>`_.\n* fixed a bunch of double-close bugs and simplified stream handler code.\n  contributed by anton ryzhov in `#58 <https://github.com/ionelmc/python-manhole/pull/58>`_.\n* loosen up ``pid`` argument parsing in ``manhole-cli`` to allow using paths with any prefix\n  (not just ``/tmp``).\n\n1.6.0 (2019-01-19)\n------------------\n\n* testing improvements (changed some skips to xfail, added osx in travis).\n* fixed long standing python 2.7 bug where ``sys.getfilesystemencoding()`` would be broken after installing a threaded\n  manhole. see `#51 <https://github.com/ionelmc/python-manhole/issues/51>`_.\n* dropped support for python 2.6, 3.3 and 3.4.\n* fixed handling when ``socket.setdefaulttimeout()`` is used.\n  contributed by \"honnix\" in `#53 <https://github.com/ionelmc/python-manhole/pull/53>`_.\n* fixed some typos. contributed by jes\u00fas cea in `#43 <https://github.com/ionelmc/python-manhole/pull/43>`_.\n* fixed handling in ``manhole-cli`` so that timeout is actually seconds and not milliseconds.\n  contributed by nir soffer in `#45 <https://github.com/ionelmc/python-manhole/pull/45>`_.\n* cleaned up useless polling options in ``manhole-cli``.\n  contributed by nir soffer in `#46 <https://github.com/ionelmc/python-manhole/pull/46>`_.\n* documented and implemented a solution for using manhole with eventlet.\n  see `#49 <https://github.com/ionelmc/python-manhole/issues/49>`_.\n\n1.5.0 (2017-08-31)\n------------------\n\n* added two string aliases for ``connection_handler`` option. now you can conveniently use ``connection_handler=\"exec\"``.\n* improved ``handle_connection_exec``. it now has a clean way to exit (``exit()``) and properly closes the socket.\n\n1.4.0 (2017-08-29)\n------------------\n\n* added the ``connection_handler`` install option. default value is ``manhole.handle_connection_repl``, and alternate\n  ``manhole.handle_connection_exec`` is provided (very simple: no output redirection, no stacktrace dumping).\n* dropped python 3.2 from the test grid. it may work but it's a huge pain to support (pip/pytest don't support it anymore).\n* added python 3.5 and 3.6 in the test grid.\n* fixed issues with piping to ``manhole-cli``. now ``echo foobar | manhole-cli`` will wait 1 second for output from manhole\n  (you can customize this with the ``--timeout`` option).\n* fixed issues with newer pypy (caused by gevent/eventlet socket unwrapping).\n\n1.3.0 (2015-09-03)\n------------------\n\n* allowed manhole to be configured without any thread or activation (in case you want to manually activate).\n* added an example and tests for using manhole with uwsgi.\n* fixed error handling in ``manhole-cli`` on python 3 (exc vars don't leak anymore).\n* fixed support for running in gevent/eventlet-using apps on python 3 (now that they support python 3).\n* allowed reinstalling the manhole (in non-``strict`` mode). previous install is undone.\n\n1.2.0 (2015-07-06)\n------------------\n\n* changed ``manhole-cli``:\n\n  * won't spam the terminal with errors if socket file doesn't exist.\n  * allowed sending any signal (new ``--signal`` argument).\n  * fixed some validation issues for the ``pid`` argument.\n\n1.1.0 (2015-06-06)\n------------------\n\n* added support for installing the manhole via the ``pythonmanhole`` environment variable.\n* added a ``strict`` install option. set it to false to avoid getting the ``alreadyinstalled`` exception.\n* added a ``manhole-cli`` script that emulates ``socat readline unix-connect:/tmp/manhole-1234``.\n\n1.0.0 (2014-10-13)\n------------------\n\n* added ``socket_path`` install option (contributed by `nir soffer`_).\n* added ``reinstall_delay`` install option.\n* added ``locals`` install option (contributed by `nir soffer`_).\n* added ``redirect_stderr`` install option (contributed by `nir soffer`_).\n* lots of internals cleanup (contributed by `nir soffer`_).\n\n0.6.2 (2014-04-28)\n------------------\n\n* fix os x regression.\n\n0.6.1 (2014-04-28)\n------------------\n\n* support for os x (contributed by `saulius menkevi\u010dius`_).\n\n.. _saulius menkevi\u010dius: https://github.com/razzmatazz\n.. _nir soffer: https://github.com/nirs\n\n\n",
  "docs_url": null,
  "keywords": "debugging,manhole,thread,socket,unix domain socket",
  "license": "bsd 2-clause license",
  "name": "manhole",
  "package_url": "https://pypi.org/project/manhole/",
  "project_url": "https://pypi.org/project/manhole/",
  "project_urls": {
    "Changelog": "https://python-manhole.readthedocs.io/en/latest/changelog.html",
    "Documentation": "https://python-manhole.readthedocs.io/",
    "Homepage": "https://github.com/ionelmc/python-manhole",
    "Issue Tracker": "https://github.com/ionelmc/python-manhole/issues"
  },
  "release_url": "https://pypi.org/project/manhole/1.8.0/",
  "requires_dist": [],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
  "summary": "manhole is in-process service that will accept unix domain socket connections and present the",
  "version": "1.8.0",
  "releases": [],
  "developers": [
    "contact@ionelmc.ro"
  ],
  "kwds": "monkey_patch connection_handler daemon_connection manholethread handle_connection_exec",
  "license_kwds": "bsd 2-clause license",
  "libtype": "pypi",
  "id": "pypi_manhole",
  "homepage": "https://github.com/ionelmc/python-manhole",
  "release_count": 23,
  "dependency_ids": []
}