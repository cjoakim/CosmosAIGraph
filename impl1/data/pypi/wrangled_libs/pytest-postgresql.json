{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v3 or later (lgplv3+)",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: software development :: testing"
  ],
  "description": ".. image:: https://raw.githubusercontent.com/clearcodehq/pytest-postgresql/master/logo.png\n    :width: 100px\n    :height: 100px\n    \npytest-postgresql\n=================\n\n.. image:: https://img.shields.io/pypi/v/pytest-postgresql.svg\n    :target: https://pypi.python.org/pypi/pytest-postgresql/\n    :alt: latest pypi version\n\n.. image:: https://img.shields.io/pypi/wheel/pytest-postgresql.svg\n    :target: https://pypi.python.org/pypi/pytest-postgresql/\n    :alt: wheel status\n\n.. image:: https://img.shields.io/pypi/pyversions/pytest-postgresql.svg\n    :target: https://pypi.python.org/pypi/pytest-postgresql/\n    :alt: supported python versions\n\n.. image:: https://img.shields.io/pypi/l/pytest-postgresql.svg\n    :target: https://pypi.python.org/pypi/pytest-postgresql/\n    :alt: license\n\nwhat is this?\n=============\n\nthis is a pytest plugin, that enables you to test your code that relies on a running postgresql database.\nit allows you to specify fixtures for postgresql process and client.\n\nhow to use\n==========\n\n.. warning::\n\n    tested on postgresql versions >= 10. see tests for more details.\n\ninstall with:\n\n.. code-block:: sh\n\n    pip install pytest-postgresql\n\nyou will also need to install ``psycopg``. see `its installation instructions <https://www.psycopg.org/psycopg3/docs/basic/install.html>`_.\nnote that this plugin requires ``psycopg`` version 3. it is possible to simultaneously install version 3\nand version 2 for libraries that require the latter (see `those instructions <https://www.psycopg.org/docs/install.html>`_).\n\nplugin contains three fixtures:\n\n* **postgresql** - it's a client fixture that has functional scope.\n  after each test it ends all leftover connections, and drops test database\n  from postgresql ensuring repeatability.\n  this fixture returns already connected psycopg connection.\n\n* **postgresql_proc** - session scoped fixture, that starts postgresql instance\n  at it's first use and stops at the end of the tests.\n* **postgresql_noproc** - a noprocess fixture, that's connecting to already\n  running postgresql instance.\n  for example on dockerized test environments, or ci providing postgresql services\n\nsimply include one of these fixtures into your tests fixture list.\n\nyou can also create additional postgresql client and process fixtures if you'd need to:\n\n\n.. code-block:: python\n\n    from pytest_postgresql import factories\n\n    postgresql_my_proc = factories.postgresql_proc(\n        port=none, unixsocketdir='/var/run')\n    postgresql_my = factories.postgresql('postgresql_my_proc')\n\n.. note::\n\n    each postgresql process fixture can be configured in a different way than the others through the fixture factory arguments.\n\nsample test\n\n.. code-block:: python\n\n    def test_example_postgres(postgresql):\n        \"\"\"check main postgresql fixture.\"\"\"\n        cur = postgresql.cursor()\n        cur.execute(\"create table test (id serial primary key, num integer, data varchar);\")\n        postgresql.commit()\n        cur.close()\n\nif you want the database fixture to be automatically populated with your schema there are two ways:\n\n#. client fixture specific\n#. process fixture specific\n\nboth are accepting same set of possible loaders:\n\n* sql file path\n* loading function import path (string)\n* actual loading function\n\nthat function will receive **host**, **port**, **user**, **dbname** and **password** kwargs and will have to perform\nconnection to the database inside. however, you'll be able to run sql files or even trigger programmatically database\nmigrations you have.\n\nclient specific loads the database each test\n\n.. code-block:: python\n\n    postgresql_my_with_schema = factories.postgresql(\n        'postgresql_my_proc',\n        load=[\"schemafile.sql\", \"otherschema.sql\", \"import.path.to.function\", \"import.path.to:otherfunction\", load_this]\n    )\n\n.. warning::\n\n    this way, the database will still be dropped each time.\n\n\nthe process fixture performs the load once per test session, and loads the data into the template database.\nclient fixture then creates test database out of the template database each test, which significantly speeds up the tests.\n\n.. code-block:: python\n\n    postgresql_my_proc = factories.postgresql_proc(\n        load=[\"schemafile.sql\", \"otherschema.sql\", \"import.path.to.function\", \"import.path.to:otherfunction\", load_this]\n    )\n\n\n.. code-block:: bash\n\n    pytest --postgresql-populate-template=path.to.loading_function --postgresql-populate-template=path.to.other:loading_function --postgresql-populate-template=path/to/file.sql\n\n\nthe loading_function from example will receive , and have to commit that.\nconnecting to already existing postgresql database\n--------------------------------------------------\n\nsome projects are using already running postgresql servers (ie on docker instances).\nin order to connect to them, one would be using the ``postgresql_noproc`` fixture.\n\n.. code-block:: python\n\n    postgresql_external = factories.postgresql('postgresql_noproc')\n\nby default the  ``postgresql_noproc`` fixture would connect to postgresql instance using **5432** port. standard configuration options apply to it.\n\nthese are the configuration options that are working on all levels with the ``postgresql_noproc`` fixture:\n\nconfiguration\n=============\n\nyou can define your settings in three ways, it's fixture factory argument, command line option and pytest.ini configuration option.\nyou can pick which you prefer, but remember that these settings are handled in the following order:\n\n    * ``fixture factory argument``\n    * ``command line option``\n    * ``configuration option in your pytest.ini file``\n\n\n.. list-table:: configuration options\n   :header-rows: 1\n\n   * - postgresql option\n     - fixture factory argument\n     - command line option\n     - pytest.ini option\n     - noop process fixture\n     - default\n   * - path to executable\n     - executable\n     - --postgresql-exec\n     - postgresql_exec\n     - -\n     - /usr/lib/postgresql/13/bin/pg_ctl\n   * - host\n     - host\n     - --postgresql-host\n     - postgresql_host\n     - yes\n     - 127.0.0.1\n   * - port\n     - port\n     - --postgresql-port\n     - postgresql_port\n     - yes (5432)\n     - random\n   * - postgresql user\n     - user\n     - --postgresql-user\n     - postgresql_user\n     - yes\n     - postgres\n   * - password\n     - password\n     - --postgresql-password\n     - postgresql_password\n     - yes\n     -\n   * - starting parameters (extra pg_ctl arguments)\n     - startparams\n     - --postgresql-startparams\n     - postgresql_startparams\n     - -\n     - -w\n   * - postgres exe extra arguments (passed via pg_ctl's -o argument)\n     - postgres_options\n     - --postgresql-postgres-options\n     - postgresql_postgres_options\n     - -\n     -\n   * - location for unixsockets\n     - unixsocket\n     - --postgresql-unixsocketdir\n     - postgresql_unixsocketdir\n     - -\n     - $tmpdir\n   * - database name\n     - dbname\n     - --postgresql-dbname\n     - postgresql_dbname\n     - yes, however with xdist an index is being added to name, resulting in test0, test1 for each worker.\n     - test\n   * - default schema either in sql files or import path to function that will load it (list of values for each)\n     - load\n     - --postgresql-load\n     - postgresql_load\n     - yes\n     -\n   * - postgresql connection options\n     - options\n     - --postgresql-options\n     - postgresql_options\n     - yes\n     -\n\n\nexample usage:\n\n* pass it as an argument in your own fixture\n\n    .. code-block:: python\n\n        postgresql_proc = factories.postgresql_proc(\n            port=8888)\n\n* use ``--postgresql-port`` command line option when you run your tests\n\n    .. code-block::\n\n        py.test tests --postgresql-port=8888\n\n\n* specify your port as ``postgresql_port`` in your ``pytest.ini`` file.\n\n    to do so, put a line like the following under the ``[pytest]`` section of your ``pytest.ini``:\n\n    .. code-block:: ini\n\n        [pytest]\n        postgresql_port = 8888\n\nexamples\n========\n\npopulating database for tests\n-----------------------------\n\nwith sqlalchemy\n+++++++++++++++\n\nthis example shows how to populate database and create an sqlalchemy's orm connection:\n\nsample below is simplified session fixture from\n`pyramid_fullauth <https://github.com/fizyk/pyramid_fullauth/>`_ tests:\n\n.. code-block:: python\n\n    from sqlalchemy import create_engine\n    from sqlalchemy.orm import scoped_session, sessionmaker\n    from sqlalchemy.pool import nullpool\n    from zope.sqlalchemy import register\n\n\n    @pytest.fixture\n    def db_session(postgresql):\n        \"\"\"session for sqlalchemy.\"\"\"\n        from pyramid_fullauth.models import base\n\n        connection = f'postgresql+psycopg2://{postgresql.info.user}:@{postgresql.info.host}:{postgresql.info.port}/{postgresql.info.dbname}'\n\n        engine = create_engine(connection, echo=false, poolclass=nullpool)\n        pyramid_basemodel.session = scoped_session(sessionmaker(extension=zopetransactionextension()))\n        pyramid_basemodel.bind_engine(\n            engine, pyramid_basemodel.session, should_create=true, should_drop=true)\n\n        yield pyramid_basemodel.session\n\n        transaction.commit()\n        base.metadata.drop_all(engine)\n\n\n    @pytest.fixture\n    def user(db_session):\n        \"\"\"test user fixture.\"\"\"\n        from pyramid_fullauth.models import user\n        from tests.tools import default_user\n\n        new_user = user(**default_user)\n        db_session.add(new_user)\n        transaction.commit()\n        return new_user\n\n\n    def test_remove_last_admin(db_session, user):\n        \"\"\"\n        sample test checks internal login, but shows usage in tests with sqlalchemy\n        \"\"\"\n        user = db_session.merge(user)\n        user.is_admin = true\n        transaction.commit()\n        user = db_session.merge(user)\n\n        with pytest.raises(attributeerror):\n            user.is_admin = false\n.. note::\n\n    see the original code at `pyramid_fullauth's conftest file <https://github.com/fizyk/pyramid_fullauth/blob/2950e7f4a397b313aaf306d6d1a763ab7d8abf2b/tests/conftest.py#l35>`_.\n    depending on your needs, that in between code can fire alembic migrations in case of sqlalchemy stack or any other code\n\nmaintaining database state outside of the fixtures\n--------------------------------------------------\n\nit is possible and appears it's used in other libraries for tests,\nto maintain database state with the use of the ``pytest-postgresql`` database\nmanaging functionality:\n\nfor this import databasejanitor and use its init and drop methods:\n\n\n.. code-block:: python\n\n    import pytest\n    from pytest_postgresql.janitor import databasejanitor\n\n    @pytest.fixture\n    def database(postgresql_proc):\n        # variable definition\n\n        janitor = databasejanitor(\n            postgresql_proc.user,\n            postgresql_proc.host,\n            postgresql_proc.port,\n            \"my_test_database\",\n            postgresql_proc.version,\n            password=\"secret_password,\n        ):\n        janitor.init()\n        yield psycopg2.connect(\n            dbname=\"my_test_database\",\n            user=postgresql_proc.user,\n            password=\"secret_password\",\n            host=postgresql_proc.host,\n            port=postgresql_proc.port,\n        )\n        janitor.drop()\n\nor use it as a context manager:\n\n.. code-block:: python\n\n    import pytest\n    from pytest_postgresql.janitor import databasejanitor\n\n    @pytest.fixture\n    def database(postgresql_proc):\n        # variable definition\n\n        with databasejanitor(\n            postgresql_proc.user,\n            postgresql_proc.host,\n            postgresql_proc.port,\n            \"my_test_database\",\n            postgresql_proc.version,\n            password=\"secret_password,\n        ):\n            yield psycopg2.connect(\n                dbname=\"my_test_database\",\n                user=postgresql_proc.user,\n                password=\"secret_password\",\n                host=postgresql_proc.host,\n                port=postgresql_proc.port,\n            )\n\n.. note::\n\n    databasejanitor manages the state of the database, but you'll have to create\n    connection to use in test code yourself.\n\n    you can optionally pass in a recognized postgresql isolation_level for\n    additional control.\n\n.. note::\n\n    see databasejanitor usage in python's warehouse test code https://github.com/pypa/warehouse/blob/5d15bfe/tests/conftest.py#l127\n\nconnecting to postgresql (in a docker)\n--------------------------------------\n\nto connect to a docker run postgresql and run test on it, use noproc fixtures.\n\n.. code-block:: sh\n\n    docker run --name some-postgres -e postgres_password=mysecretpassword -d postgres\n\nthis will start postgresql in a docker container, however using a postgresql installed locally is not much different.\n\nin tests, make sure that all your tests are using **postgresql_noproc** fixture like that:\n\n.. code-block:: python\n\n    from pytest_postgresql import factories\n\n\n    postgresql_in_docker = factories.postgresql_noproc()\n    postgresql = factories.postgresql(\"postgresql_in_docker\", dbname=\"test\")\n\n\n    def test_postgres_docker(postgresql):\n        \"\"\"run test.\"\"\"\n        cur = postgresql.cursor()\n        cur.execute(\"create table test (id serial primary key, num integer, data varchar);\")\n        postgresql.commit()\n        cur.close()\n\nand run tests:\n\n.. code-block:: sh\n\n    pytest --postgresql-host=172.17.0.2 --postgresql-password=mysecretpassword\n\nusing a common database initialisation between tests\n----------------------------------------------------\n\nif you've got several tests that require common initialisation, you need to define a `load` and pass it to\nyour custom postgresql process fixture:\n\n.. code-block:: python\n\n    import pytest_postgresql.factories\n    def load_database(**kwargs):\n        db_connection: connection = psycopg2.connect(**kwargs)\n        with db_connection.cursor() as cur:\n            cur.execute(\"create table stories (id serial primary key, name varchar);\")\n            cur.execute(\n                \"insert into stories (name) values\"\n                \"('silmarillion'), ('star wars'), ('the expanse'), ('battlestar galactica')\"\n            )\n            db_connection.commit()\n\n    postgresql_proc = factories.postgresql_proc(\n        load=[load_database],\n    )\n\n    postgresql = factories.postgresql(\n        \"postgresql_proc\",\n    )\n\nyou can also define your own database name by passing same dbname value\nto **both** factories.\n\nthe way this will work is that the process fixture will populate template database,\nwhich in turn will be used automatically by client fixture to create a test database from scratch.\nfast, clean and no dangling transactions, that could be accidentally rolled back.\n\nsame approach will work with noproces fixture, while connecting to already running postgresql instance whether\nit'll be on a docker machine or running remotely or locally.\nrelease\n=======\n\ninstall pipenv and --dev dependencies first, then run:\n\n.. code-block::\n\n    pipenv run tbump [new_version]\n",
  "docs_url": null,
  "keywords": "tests,pytest,fixture,postgresql",
  "license": "",
  "name": "pytest-postgresql",
  "package_url": "https://pypi.org/project/pytest-postgresql/",
  "project_url": "https://pypi.org/project/pytest-postgresql/",
  "project_urls": {
    "Bug Tracker": "https://github.com/ClearcodeHQ/pytest-postgresql/issues",
    "Changelog": "https://github.com/ClearcodeHQ/pytest-postgresql/blob/v5.0.0/CHANGES.rst",
    "Source": "https://github.com/ClearcodeHQ/pytest-postgresql"
  },
  "release_url": "https://pypi.org/project/pytest-postgresql/5.0.0/",
  "requires_dist": [
    "pytest (>=6.2)",
    "port-for (>=0.6.0)",
    "mirakuru",
    "setuptools",
    "psycopg (>=3.0.0)"
  ],
  "requires_python": ">=3.8",
  "summary": "postgresql fixtures and fixture factories for pytest.",
  "version": "5.0.0",
  "releases": [],
  "developers": [
    "fizyk+pypi@fizyk.dev"
  ],
  "kwds": "pytest_postgresql pytest pypi test_postgres_docker pip",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pytest_postgresql",
  "homepage": "",
  "release_count": 36,
  "dependency_ids": [
    "pypi_mirakuru",
    "pypi_port_for",
    "pypi_psycopg",
    "pypi_pytest",
    "pypi_setuptools"
  ]
}