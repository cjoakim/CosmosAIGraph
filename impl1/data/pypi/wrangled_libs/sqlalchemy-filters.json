{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: database",
    "topic :: database :: front-ends",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "sqlalchemy filters\n==================\n\n.. pull-quote::\n\n    filter, sort and paginate sqlalchemy query objects. ideal for\n    exposing these actions over a rest api.\n\n\n.. image:: https://img.shields.io/pypi/v/sqlalchemy-filters.svg\n    :target: https://pypi.org/project/sqlalchemy-filters/\n\n.. image:: https://img.shields.io/pypi/pyversions/sqlalchemy-filters.svg\n    :target: https://pypi.org/project/sqlalchemy-filters/\n\n.. image:: https://img.shields.io/pypi/format/sqlalchemy-filters.svg\n    :target: https://pypi.org/project/sqlalchemy-filters/\n\n.. image:: https://github.com/juliotrigo/sqlalchemy-filters/actions/workflows/tests.yml/badge.svg\n    :target: https://github.com/juliotrigo/sqlalchemy-filters/actions\n\n\nfiltering\n---------\n\nassuming that we have a sqlalchemy_ ``query`` object:\n\n.. code-block:: python\n\n    from sqlalchemy import column, integer, string\n    from sqlalchemy.ext.declarative import declarative_base\n\n\n    class base(object):\n        id = column(integer, primary_key=true)\n        name = column(string(50), nullable=false)\n        count = column(integer, nullable=true)\n\n        @hybrid_property\n        def count_square(self):\n            return self.count * self.count\n\n        @hybrid_method\n        def three_times_count(self):\n            return self.count * 3\n\n\n    base = declarative_base(cls=base)\n\n\n    class foo(base):\n\n        __tablename__ = 'foo'\n\n    # ...\n\n    query = session.query(foo)\n\nthen we can apply filters to that ``query`` object (multiple times):\n\n.. code-block:: python\n\n    from sqlalchemy_filters import apply_filters\n\n\n    # `query` should be a sqlalchemy query object\n\n    filter_spec = [{'field': 'name', 'op': '==', 'value': 'name_1'}]\n    filtered_query = apply_filters(query, filter_spec)\n\n    more_filters = [{'field': 'foo_id', 'op': 'is_not_null'}]\n    filtered_query = apply_filters(filtered_query, more_filters)\n\n    result = filtered_query.all()\n\nit is also possible to filter queries that contain multiple models,\nincluding joins:\n\n.. code-block:: python\n\n    class bar(base):\n\n        __tablename__ = 'bar'\n\n        foo_id = column(integer, foreignkey('foo.id'))\n\n\n.. code-block:: python\n\n    query = session.query(foo).join(bar)\n\n    filter_spec = [\n        {'model': 'foo', 'field': 'name', 'op': '==', 'value': 'name_1'},\n        {'model': 'bar', 'field': 'count', 'op': '>=', 'value': 5},\n    ]\n    filtered_query = apply_filters(query, filter_spec)\n\n    result = filtered_query.all()\n\n\n``apply_filters`` will attempt to automatically join models to ``query``\nif they're not already present and a model-specific filter is supplied.\nfor example, the value of ``filtered_query`` in the following two code\nblocks is identical:\n\n.. code-block:: python\n\n    query = session.query(foo).join(bar)  # join pre-applied to query\n\n    filter_spec = [\n        {'model': 'foo', 'field': 'name', 'op': '==', 'value': 'name_1'},\n        {'model': 'bar', 'field': 'count', 'op': '>=', 'value': 5},\n    ]\n    filtered_query = apply_filters(query, filter_spec)\n\n.. code-block:: python\n\n    query = session.query(foo)  # join to bar will be automatically applied\n\n    filter_spec = [\n        {field': 'name', 'op': '==', 'value': 'name_1'},\n        {'model': 'bar', 'field': 'count', 'op': '>=', 'value': 5},\n    ]\n    filtered_query = apply_filters(query, filter_spec)\n\nthe automatic join is only possible if sqlalchemy_ can implictly\ndetermine the condition for the join, for example because of a foreign\nkey relationship.\n\nautomatic joins allow flexibility for clients to filter and sort by related\nobjects without specifying all possible joins on the server beforehand. feature\ncan be explicitly disabled by passing ``do_auto_join=false`` argument to the\n``apply_filters`` call.\n\nnote that first filter of the second block does not specify a model.\nit is implictly applied to the ``foo`` model because that is the only\nmodel in the original query passed to ``apply_filters``.\n\nit is also possible to apply filters to queries defined by fields, functions or\n``select_from`` clause:\n\n.. code-block:: python\n\n    query_alt_1 = session.query(foo.id, foo.name)\n    query_alt_2 = session.query(func.count(foo.id))\n    query_alt_3 = session.query().select_from(foo).add_column(foo.id)\n\nhybrid attributes\n^^^^^^^^^^^^^^^^^\n\nyou can filter by a `hybrid attribute`_: a `hybrid property`_ or a `hybrid method`_.\n\n.. code-block:: python\n\n    query = session.query(foo)\n\n    filter_spec = [{'field': 'count_square', 'op': '>=', 'value': 25}]\n    filter_spec = [{'field': 'three_times_count', 'op': '>=', 'value': 15}]\n\n    filtered_query = apply_filters(query, filter_spec)\n    result = filtered_query.all()\n\n\nrestricted loads\n----------------\n\nyou can restrict the fields that sqlalchemy_ loads from the database by\nusing the ``apply_loads`` function:\n\n.. code-block:: python\n\n    query = session.query(foo, bar).join(bar)\n    load_spec = [\n        {'model': 'foo', 'fields': ['name']},\n        {'model': 'bar', 'fields': ['count']}\n    ]\n    query = apply_loads(query, load_spec)  # will load only foo.name and bar.count\n\n\nthe effect of the ``apply_loads`` function is to ``_defer_`` the load\nof any other fields to when/if they're accessed, rather than loading\nthem when the query is executed. it only applies to fields that would be\nloaded during normal query execution.\n\n\neffect on joined queries\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe default sqlalchemy_ join is lazy, meaning that columns from the\njoined table are loaded only when required. therefore ``apply_loads``\nhas limited effect in the following scenario:\n\n.. code-block:: python\n\n    query = session.query(foo).join(bar)\n    load_spec = [\n        {'model': 'foo', 'fields': ['name']}\n        {'model': 'bar', 'fields': ['count']}  # ignored\n    ]\n    query = apply_loads(query, load_spec)  # will load only foo.name\n\n\n``apply_loads`` cannot be applied to columns that are loaded as\n`joined eager loads <http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html#joined-eager-loading>`_.\nthis is because a joined eager load does not add the joined model to the\noriginal query, as explained\n`here <http://docs.sqlalchemy.org/en/latest/orm/loading_relationships.html#the-zen-of-joined-eager-loading>`_\n\nthe following would not prevent all columns from ``bar`` being eagerly\nloaded:\n\n.. code-block:: python\n\n    query = session.query(foo).options(joinedload(foo.bar))\n    load_spec = [\n        {'model': 'foo', 'fields': ['name']}\n        {'model': 'bar', 'fields': ['count']}\n    ]\n    query = apply_loads(query, load_spec)\n\n.. sidebar:: automatic join\n\n    in fact, what happens here is that ``bar`` is automatically joined\n    to ``query``, because it is determined that ``bar`` is not part of\n    the original query. the ``load_spec`` therefore has no effect\n    because the automatic join results in lazy evaluation.\n\nif you wish to perform a joined load with restricted columns, you must\nspecify the columns as part of the joined load, rather than with\n``apply_loads``:\n\n.. code-block:: python\n\n    query = session.query(foo).options(joinedload(bar).load_only('count'))\n    load_spec = [\n        {'model': 'foo', 'fields': ['name']}\n    ]\n    query = apply_loads(query. load_spec)  # will load ony foo.name and bar.count\n\n\nsort\n----\n\n.. code-block:: python\n\n    from sqlalchemy_filters import apply_sort\n\n\n    # `query` should be a sqlalchemy query object\n\n    sort_spec = [\n        {'model': 'foo', 'field': 'name', 'direction': 'asc'},\n        {'model': 'bar', 'field': 'id', 'direction': 'desc'},\n    ]\n    sorted_query = apply_sort(query, sort_spec)\n\n    result = sorted_query.all()\n\n\n``apply_sort`` will attempt to automatically join models to ``query`` if\nthey're not already present and a model-specific sort is supplied.\nthe behaviour is the same as in ``apply_filters``.\n\nthis allows flexibility for clients to sort by fields on related objects\nwithout specifying all possible joins on the server beforehand.\n\nhybrid attributes\n^^^^^^^^^^^^^^^^^\n\nyou can sort by a `hybrid attribute`_: a `hybrid property`_ or a `hybrid method`_.\n\n\npagination\n----------\n\n.. code-block:: python\n\n    from sqlalchemy_filters import apply_pagination\n\n\n    # `query` should be a sqlalchemy query object\n\n    query, pagination = apply_pagination(query, page_number=1, page_size=10)\n\n    page_size, page_number, num_pages, total_results = pagination\n\n    assert 10 == len(query)\n    assert 10 == page_size == pagination.page_size\n    assert 1 == page_number == pagination.page_number\n    assert 3 == num_pages == pagination.num_pages\n    assert 22 == total_results == pagination.total_results\n\nfilters format\n--------------\n\nfilters must be provided in a list and will be applied sequentially.\neach filter will be a dictionary element in that list, using the\nfollowing format:\n\n.. code-block:: python\n\n    filter_spec = [\n        {'model': 'model_name', 'field': 'field_name', 'op': '==', 'value': 'field_value'},\n        {'model': 'model_name', 'field': 'field_2_name', 'op': '!=', 'value': 'field_2_value'},\n        # ...\n    ]\n\nthe ``model`` key is optional if the original query being filtered only\napplies to one model.\n\nif there is only one filter, the containing list may be omitted:\n\n.. code-block:: python\n\n    filter_spec = {'field': 'field_name', 'op': '==', 'value': 'field_value'}\n\nwhere ``field`` is the name of the field that will be filtered using the\noperator provided in ``op`` (optional, defaults to ``==``) and the\nprovided ``value`` (optional, depending on the operator).\n\nthis is the list of operators that can be used:\n\n- ``is_null``\n- ``is_not_null``\n- ``==``, ``eq``\n- ``!=``, ``ne``\n- ``>``, ``gt``\n- ``<``, ``lt``\n- ``>=``, ``ge``\n- ``<=``, ``le``\n- ``like``\n- ``ilike``\n- ``not_ilike``\n- ``in``\n- ``not_in``\n- ``any``\n- ``not_any``\n\nany / not_any\n^^^^^^^^^^^^^\n\npostgresql specific operators allow to filter queries on columns of type ``array``.\nuse ``any`` to filter if a value is present in an array and ``not_any`` if it's not.\n\nboolean functions\n^^^^^^^^^^^^^^^^^\n``and``, ``or``, and ``not`` functions can be used and nested within the\nfilter specification:\n\n.. code-block:: python\n\n    filter_spec = [\n        {\n            'or': [\n                {\n                    'and': [\n                        {'field': 'field_name', 'op': '==', 'value': 'field_value'},\n                        {'field': 'field_2_name', 'op': '!=', 'value': 'field_2_value'},\n                    ]\n                },\n                {\n                    'not': [\n                        {'field': 'field_3_name', 'op': '==', 'value': 'field_3_value'}\n                    ]\n                },\n            ],\n        }\n    ]\n\n\nnote: ``or`` and ``and`` must reference a list of at least one element.\n``not`` must reference a list of exactly one element.\n\nsort format\n-----------\n\nsort elements must be provided as dictionaries in a list and will be\napplied sequentially:\n\n.. code-block:: python\n\n    sort_spec = [\n        {'model': 'foo', 'field': 'name', 'direction': 'asc'},\n        {'model': 'bar', 'field': 'id', 'direction': 'desc'},\n        # ...\n    ]\n\nwhere ``field`` is the name of the field that will be sorted using the\nprovided ``direction``.\n\nthe ``model`` key is optional if the original query being sorted only\napplies to one model.\n\nnullsfirst / nullslast\n^^^^^^^^^^^^^^^^^^^^^^\n\n.. code-block:: python\n\n    sort_spec = [\n        {'model': 'baz', 'field': 'count', 'direction': 'asc', 'nullsfirst': true},\n        {'model': 'qux', 'field': 'city', 'direction': 'desc', 'nullslast': true},\n        # ...\n    ]\n\n``nullsfirst`` is an optional attribute that will place ``null`` values first\nif set to ``true``, according to the `sqlalchemy documentation <https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst>`__.\n\n``nullslast`` is an optional attribute that will place ``null`` values last\nif set to ``true``, according to the `sqlalchemy documentation <https://docs.sqlalchemy.org/en/latest/core/sqlelement.html#sqlalchemy.sql.expression.nullslast>`__.\n\nif none of them are provided, then ``null`` values will be sorted according\nto the rdbms being used. sql defines that ``null`` values should be placed\ntogether when sorting, but it does not specify whether they should be placed\nfirst or last.\n\neven though both ``nullsfirst`` and ``nullslast`` are part of sqlalchemy_,\nthey will raise an unexpected exception if the rdbms that is being used does\nnot support them.\n\nat the moment they are\n`supported by postgresql <https://www.postgresql.org/docs/current/queries-order.html>`_,\nbut they are **not** supported by sqlite and mysql.\n\n\n\nrunning tests\n-------------\n\nthe default configuration uses **sqlite**, **mysql** (if the driver is\ninstalled, which is the case when ``tox`` is used) and **postgresql**\n(if the driver is installed, which is the case when ``tox`` is used) to\nrun the tests, with the following uris:\n\n.. code-block:: shell\n\n    sqlite+pysqlite:///test_sqlalchemy_filters.db\n    mysql+mysqlconnector://root:@localhost:3306/test_sqlalchemy_filters\n    postgresql+psycopg2://postgres:@localhost:5432/test_sqlalchemy_filters?client_encoding=utf8'\n\na test database will be created, used during the tests and destroyed\nafterwards for each rdbms configured.\n\nthere are makefile targets to run docker containers locally for both\n**mysql** and **postgresql**, using the default ports and configuration:\n\n.. code-block:: shell\n\n    $ make mysql-container\n    $ make postgres-container\n\nto run the tests locally:\n\n.. code-block:: shell\n\n    $ # create/activate a virtual environment\n    $ pip install tox\n    $ tox\n\nthere are some other makefile targets that can be used to run the tests:\n\nthere are other makefile targets to run the tests, but extra\ndependencies will have to be installed:\n\n.. code-block:: shell\n\n    $ pip install -u --editable \".[dev,mysql,postgresql]\"\n    $ # using default settings\n    $ make test\n    $ make coverage\n\n    $ # overriding db parameters\n    $ args='--mysql-test-db-uri mysql+mysqlconnector://root:@192.168.99.100:3340/test_sqlalchemy_filters' make test\n    $ args='--sqlite-test-db-uri sqlite+pysqlite:///test_sqlalchemy_filters.db' make test\n\n    $ args='--mysql-test-db-uri mysql+mysqlconnector://root:@192.168.99.100:3340/test_sqlalchemy_filters' make coverage\n    $ args='--sqlite-test-db-uri sqlite+pysqlite:///test_sqlalchemy_filters.db' make coverage\n\n\n\ndatabase management systems\n---------------------------\n\nthe following rdbms are supported (tested):\n\n- sqlite\n- mysql\n- postgresql\n\n\nsqlalchemy support\n------------------\n\nthe following sqlalchemy_ versions are supported: ``1.0``, ``1.1``,\n``1.2``, ``1.3``, ``1.4``.\n\n\nchangelog\n---------\n\nconsult the `changelog <https://github.com/juliotrigo/sqlalchemy-filters/blob/master/changelog.rst>`_\ndocument for fixes and enhancements of each version.\n\n\nlicense\n-------\n\napache 2.0. see `license <https://github.com/juliotrigo/sqlalchemy-filters/blob/master/license>`_\nfor details.\n\n\n.. _sqlalchemy: https://www.sqlalchemy.org/\n.. _hybrid attribute: https://docs.sqlalchemy.org/en/13/orm/extensions/hybrid.html\n.. _hybrid property: https://docs.sqlalchemy.org/en/13/orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property\n.. _hybrid method: https://docs.sqlalchemy.org/en/13/orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_method\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license, version 2.0",
  "name": "sqlalchemy-filters",
  "package_url": "https://pypi.org/project/sqlalchemy-filters/",
  "project_url": "https://pypi.org/project/sqlalchemy-filters/",
  "project_urls": {
    "Homepage": "https://github.com/juliotrigo/sqlalchemy-filters"
  },
  "release_url": "https://pypi.org/project/sqlalchemy-filters/0.13.0/",
  "requires_dist": [
    "sqlalchemy (>=1.0.16)",
    "six (>=1.10.0)",
    "pytest (>=4.6.9) ; extra == 'dev'",
    "coverage (~=5.0.4) ; extra == 'dev'",
    "sqlalchemy-utils (>=0.37) ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "restructuredtext-lint ; extra == 'dev'",
    "Pygments ; extra == 'dev'",
    "coverage-conditional-plugin ; extra == 'dev'",
    "mysql-connector-python-rf (==2.2.2) ; extra == 'mysql'",
    "psycopg2 (==2.8.4) ; extra == 'postgresql'"
  ],
  "requires_python": ">=3.7",
  "summary": "a library to filter sqlalchemy queries.",
  "version": "0.13.0",
  "releases": [],
  "developers": [
    "student",
    "wearehiring@student.com"
  ],
  "kwds": "sqlalchemy_filters test_sqlalchemy_filters sqlalchemy sqlalchemy_ _sqlalchemy",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_sqlalchemy_filters",
  "homepage": "https://github.com/juliotrigo/sqlalchemy-filters",
  "release_count": 12,
  "dependency_ids": [
    "pypi_coverage",
    "pypi_coverage_conditional_plugin",
    "pypi_flake8",
    "pypi_mysql_connector_python_rf",
    "pypi_psycopg2",
    "pypi_pygments",
    "pypi_pytest",
    "pypi_restructuredtext_lint",
    "pypi_six",
    "pypi_sqlalchemy",
    "pypi_sqlalchemy_utils"
  ]
}