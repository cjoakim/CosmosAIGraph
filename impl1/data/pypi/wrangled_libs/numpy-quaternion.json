{
  "classifiers": [],
  "description": "[![test status](https://github.com/moble/quaternion/workflows/tests/badge.svg)](https://github.com/moble/quaternion/actions)\n[![documentation status](https://readthedocs.org/projects/quaternion/badge/?version=latest)](https://quaternion.readthedocs.io/en/latest/?badge=latest)\n[![pypi version](https://img.shields.io/pypi/v/numpy-quaternion?color=)](https://pypi.org/project/numpy-quaternion/)\n[![conda version](https://img.shields.io/conda/vn/conda-forge/quaternion.svg?color=)](https://anaconda.org/conda-forge/quaternion)\n[![mit license](https://img.shields.io/github/license/moble/quaternion.svg)](https://github.com/moble/quaternion/blob/main/license)\n[![doi](https://zenodo.org/badge/27896013.svg)](https://zenodo.org/badge/latestdoi/27896013)\n\n\n# quaternions in numpy\n\nthis python module adds a quaternion dtype to numpy.\n\nthe code was originally based on [code by martin\nling](https://github.com/martinling/numpy_quaternion) (which he wrote\nwith help from mark wiebe), but was rewritten with ideas from\n[rational](https://github.com/numpy/numpy-dtypes/tree/master/npytypes/rational)\nto work with newer python versions (and to fix a few bugs), and\n*greatly* expands the applications of quaternions.\n\nsee also the pure-python package\n[quaternionic](https://github.com/moble/quaternionic).\n\n## quickstart\n\n```sh\nconda install -c conda-forge quaternion\n```\n\nor\n\n```sh\npython -m pip install --upgrade --force-reinstall numpy-quaternion\n```\n\noptionally add `--user` after `install` in the second command if\nyou're not using a python environment \u2014 though you should start.\n\n\n## dependencies\n\nthe basic requirements for this code are reasonably current versions\nof `python` and `numpy`.  in particular, `python` versions 3.8 through\n3.11 are routinely tested.  earlier `python` versions, including 2.7,\nwill work with older versions of this package; they *might* still work\nwith more recent versions of this package, but even numpy no longer\nsupports `python` previous to 3.8, so your mileage may vary.  also,\nany `numpy` version [greater than\n1.13.0](https://github.com/moble/quaternion/issues/114) should work,\nbut the tests are run on the most recent release at the time of the\ntest.\n\nhowever, certain advanced functions in this package (including\n`squad`, `mean_rotor_in_intrinsic_metric`,\n`integrate_angular_velocity`, and related functions) require\n[`scipy`](http://scipy.org/) and can automatically use\n[`numba`](http://numba.pydata.org/).  `scipy` is a standard python\npackage for scientific computation, and implements interfaces to c and\nfortran codes for optimization (among other things) need for finding\nmean and optimal rotors.  `numba` uses [llvm](http://llvm.org/) to\ncompile python code to machine code, accelerating many numerical\nfunctions by factors of anywhere from 2 to 2000.  it is *possible* to\nrun all the code without `numba`, but these particular functions can\nbe anywhere from 4 to 400 times slower without it.\n\nboth `scipy` and `numba` can be installed with `pip` or `conda`.\nhowever, because `conda` is specifically geared toward scientific\npython, it is generally more robust for these more complicated\npackages.  in fact, the main\n[`anaconda`](https://www.anaconda.com/products/individual) package\ncomes with both `numba` and `scipy`.  if you prefer the smaller\ndownload size of [`miniconda`](http://conda.pydata.org/miniconda.html)\n(which comes with minimal extras), you'll also have to run this\ncommand:\n\n```sh\nconda install numpy scipy numba\n```\n\n\n## installation\n\nassuming you use `conda` to manage your python installation (which is\ncurrently the preferred choice for science and engineering with\npython), you can install this package simply as\n\n```sh\nconda install -c conda-forge quaternion\n```\n\nif you prefer to use `pip`, you can instead do\n\n```sh\npython -m pip install --upgrade --force-reinstall numpy-quaternion\n```\n\n(see [here](https://snarky.ca/why-you-should-use-python-m-pip/) for a\nveteran python core contributor's explanation of why you should always\nuse `python -m pip` instead of just `pip` or `pip3`.)  the `--upgrade\n--force-reinstall` options are not always necessary, but will ensure\nthat pip will update numpy if it has to.\n\nif you refuse to use `conda`, you might want to install inside your\nhome directory without root privileges.  (conda does this by default\nanyway.)  this is done by adding `--user` to the above command:\n\n```sh\npython -m pip install --user --upgrade --force-reinstall numpy-quaternion\n```\n\nnote that pip will attempt to compile the code \u2014 which requires a\nworking `c` compiler.\n\nfinally, there's also the fully manual option of just downloading the\ncode, changing to the code directory, and running\n\n```sh\npython -m pip install --upgrade --force-reinstall .\n```\n\nthis should work regardless of the installation method, as long as you\nhave a compiler hanging around.\n\n\n## basic usage\n\nthe full documentation can be found on [read the\ndocs](https://quaternion.readthedocs.io/), and most functions have\ndocstrings that should explain the relevant points.  the following are\nmostly for the purposes of example.\n\n```python\n>>> import numpy as np\n>>> import quaternion\n>>> np.quaternion(1,0,0,0)\nquaternion(1, 0, 0, 0)\n>>> q1 = np.quaternion(1,2,3,4)\n>>> q2 = np.quaternion(5,6,7,8)\n>>> q1 * q2\nquaternion(-60, 12, 30, 24)\n>>> a = np.array([q1, q2])\n>>> a\narray([quaternion(1, 2, 3, 4), quaternion(5, 6, 7, 8)], dtype=quaternion)\n>>> np.exp(a)\narray([quaternion(1.69392, -0.78956, -1.18434, -1.57912),\n       quaternion(138.909, -25.6861, -29.9671, -34.2481)], dtype=quaternion)\n```\n\nnote that this package represents a quaternion as a scalar, followed\nby the `x` component of the vector part, followed by `y`, followed by\n`z`.  these components can be accessed directly:\n```python\n>>> q1.w, q1.x, q1.y, q1.z\n(1.0, 2.0, 3.0, 4.0)\n```\nhowever, this only works on an individual `quaternion`; for arrays it\nis better to use \"vectorized\" operations like `as_float_array`.\n\nthe following ufuncs are implemented (which means they run fast on\nnumpy arrays):\n```python\nadd, subtract, multiply, divide, log, exp, power, negative, conjugate,\ncopysign, equal, not_equal, less, less_equal, isnan, isinf, isfinite, absolute\n```\n\nquaternion components are stored as double-precision floating point\nnumbers \u2014 `float`s, in python language, or `float64` in more precise\nnumpy language.  numpy arrays with `dtype=quaternion` can be accessed\nas arrays of doubles without any (slow, memory-consuming) copying of\ndata; rather, a `view` of the exact same memory space can be created\nwithin a microsecond, regardless of the shape or size of the\nquaternion array.\n\ncomparison operations follow the same lexicographic ordering as\ntuples.\n\nthe unary tests isnan and isinf return true if they would return true\nfor any individual component; isfinite returns true if it would return\ntrue for all components.\n\nreal types may be cast to quaternions, giving quaternions with zero\nfor all three imaginary components. complex types may also be cast to\nquaternions, with their single imaginary component becoming the first\nimaginary component of the quaternion. quaternions may not be cast to\nreal or complex types.\n\nseveral array-conversion functions are also included.  for example, to\nconvert an nx4 array of floats to an n-dimensional array of\nquaternions, use `as_quat_array`:\n```python\n>>> import numpy as np\n>>> import quaternion\n>>> a = np.random.rand(7, 4)\n>>> a\narray([[ 0.93138726,  0.46972279,  0.18706385,  0.86605021],\n       [ 0.70633523,  0.69982741,  0.93303559,  0.61440879],\n       [ 0.79334456,  0.65912598,  0.0711557 ,  0.46622885],\n       [ 0.88185987,  0.9391296 ,  0.73670503,  0.27115149],\n       [ 0.49176628,  0.56688076,  0.13216632,  0.33309146],\n       [ 0.11951624,  0.86804078,  0.77968826,  0.37229404],\n       [ 0.33187593,  0.53391165,  0.8577846 ,  0.18336855]])\n>>> qs = quaternion.as_quat_array(a)\n>>> qs\narray([ quaternion(0.931387262880247, 0.469722787598354, 0.187063852060487, 0.866050210100621),\n       quaternion(0.706335233363319, 0.69982740767353, 0.933035590130247, 0.614408786768725),\n       quaternion(0.793344561317281, 0.659125976566815, 0.0711557025000925, 0.466228847713644),\n       quaternion(0.881859869074069, 0.939129602918467, 0.736705031709562, 0.271151494174001),\n       quaternion(0.491766284854505, 0.566880763189927, 0.132166320200012, 0.333091463422536),\n       quaternion(0.119516238634238, 0.86804077992676, 0.779688263524229, 0.372294043850009),\n       quaternion(0.331875925159073, 0.533911652483908, 0.857784598617977, 0.183368547490701)], dtype=quaternion)\n```\n[note that quaternions are printed with full precision, unlike floats,\nwhich is why you see extra digits above.  but the actual data is\nidentical in the two cases.]  to convert an n-dimensional array of\nquaternions to an nx4 array of floats, use `as_float_array`:\n```python\n>>> b = quaternion.as_float_array(qs)\n>>> b\narray([[ 0.93138726,  0.46972279,  0.18706385,  0.86605021],\n       [ 0.70633523,  0.69982741,  0.93303559,  0.61440879],\n       [ 0.79334456,  0.65912598,  0.0711557 ,  0.46622885],\n       [ 0.88185987,  0.9391296 ,  0.73670503,  0.27115149],\n       [ 0.49176628,  0.56688076,  0.13216632,  0.33309146],\n       [ 0.11951624,  0.86804078,  0.77968826,  0.37229404],\n       [ 0.33187593,  0.53391165,  0.8577846 ,  0.18336855]])\n```\n\nit is also possible to convert a quaternion to or from a 3x3 array of\nfloats representing a rotation matrix, or an array of n quaternions to\nor from an nx3x3 array of floats representing n rotation matrices,\nusing `as_rotation_matrix` and `from_rotation_matrix`.  similar\nconversions are possible for rotation vectors using\n`as_rotation_vector` and `from_rotation_vector`, and for spherical\ncoordinates using `as_spherical_coords` and `from_spherical_coords`.\nfinally, it is possible to derive the euler angles from a quaternion\nusing `as_euler_angles`, or create a quaternion from euler angles\nusing `from_euler_angles` \u2014\u00a0though be aware that euler angles are\nbasically the worst things\never.<sup>[1](#1-euler-angles-are-awful)</sup> before you complain\nabout those functions using something other than your favorite\nconventions, please read [this\npage](https://github.com/moble/quaternion/wiki/euler-angles-are-horrible).\n\n\n## bug reports and feature requests\n\nbug reports and feature requests are entirely welcome (with [very few\nexceptions](https://github.com/moble/quaternion/wiki/euler-angles-are-horrible#opening-issues-and-pull-requests)).\nthe best way to do this is to open an [issue on this code's github\npage](https://github.com/moble/quaternion/issues).  for bug reports,\nplease try to include a minimal working example demonstrating the\nproblem.\n\n[pull requests](https://help.github.com/articles/using-pull-requests/)\nare also entirely welcome, of course, if you have an idea where the\ncode is going wrong, or have an idea for a new feature that you know\nhow to implement.\n\nthis code is routinely tested on recent versions of both python (3.8\nthough 3.11) and numpy (>=1.13).  but the test coverage is not\nnecessarily as complete as it could be, so bugs may certainly be\npresent, especially in the higher-level functions like\n`mean_rotor_...`.\n\n\n## acknowledgments\n\nthis code is, of course, hosted on github.  because it is an\nopen-source project, the hosting is free, and all the wonderful\nfeatures of github are available, including free wiki space and web\npage hosting, pull requests, a nice interface to the git logs, etc.\ngithub user hannes ovr\u00e9n (hovren) pointed out some errors in a\nprevious version of this code and suggested some nice utility\nfunctions for rotation matrices, etc.  github user stijn van drongelen\n(rhymoid) contributed some code that makes compilation work with\nmsvc++.  github user jon long (longjon) has provided some elegant\ncontributions to substantially improve several tricky parts of this\ncode.  rebecca turner (9999years) and leo stein (duetosymmetry) did\nall the work in getting the documentation onto [read the\ndocs](https://quaternion.readthedocs.io/).\n\nevery change in this code is [automatically\ntested](https://github.com/moble/quaternion/actions) on github\nactions.  the code is downloaded and installed fresh each time, and\nthen tested, on each of the different supported versions of python, on\neach of the supported platforms.  this ensures that no change i make\nto the code breaks either installation or any of the features that i\nhave written tests for.  github actions also automatically builds the\n`pip` versions of the code hosted on\n[pypi](https://pypi.python.org/pypi/numpy-quaternion).  conda-forge\nalso uses github actions to build [the conda/mamba\nversion](https://github.com/conda-forge/quaternion-feedstock) hosted\non [anaconda.org](https://anaconda.org/conda-forge/quaternion).  these\nare all free services for open-source projects like this one.\n\nthe work of creating this code was supported in part by the sherman\nfairchild foundation and by nsf grants no. phy-1306125 and\nast-1333129.\n\n\n\n\n<br/>\n\n---\n\n###### <sup>1</sup> euler angles are awful\n\neuler angles are pretty much [the worst things\never](https://moble.github.io/spherical_functions/#euler-angles) and it\nmakes me feel bad even supporting them.  quaternions are faster, more\naccurate, basically free of singularities, more intuitive, and\ngenerally easier to understand.  you can work entirely without euler\nangles (i certainly do).  you absolutely never need them.  but if\nyou really can't give them up, they are mildly supported.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "numpy-quaternion",
  "package_url": "https://pypi.org/project/numpy-quaternion/",
  "project_url": "https://pypi.org/project/numpy-quaternion/",
  "project_urls": {
    "Homepage": "https://github.com/moble/quaternion"
  },
  "release_url": "https://pypi.org/project/numpy-quaternion/2023.0.2/",
  "requires_dist": [
    "numpy >=1.13",
    "mkdocs ; extra == 'docs'",
    "mktheapidocs[plugin] ; extra == 'docs'",
    "pymdown-extensions ; extra == 'docs'",
    "numba <0.49.0 ; (python_version < '3.6' and platform_python_implementation != 'PyPy') and extra == 'numba'",
    "llvmlite <0.32.0 ; (python_version < '3.6' and platform_python_implementation != 'PyPy') and extra == 'numba'",
    "numba ; (python_version >= '3.6' and platform_python_implementation != 'PyPy') and extra == 'numba'",
    "scipy ; extra == 'scipy'",
    "pytest ; extra == 'testing'",
    "pytest-cov ; extra == 'testing'"
  ],
  "requires_python": "",
  "summary": "add a quaternion dtype to numpy",
  "version": "2023.0.2",
  "releases": [],
  "developers": [
    "michael_boyle",
    "mob22@cornell.edu"
  ],
  "kwds": "quaternions quaternionic quaternion numpy_quaternion badge",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_numpy_quaternion",
  "homepage": "https://github.com/moble/quaternion",
  "release_count": 169,
  "dependency_ids": [
    "pypi_llvmlite",
    "pypi_mkdocs",
    "pypi_mktheapidocs",
    "pypi_numba",
    "pypi_numpy",
    "pypi_pymdown_extensions",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_scipy"
  ]
}