{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "===========\nrecordtype\n===========\n\nnote\n====\n\nin python 3.7 a better solution than recordtype is to use dataclasses.\n\ni have switched active development to my `namedlist project\n<https://bitbucket.org/ericvsmith/namedlist>`_. it has a better\nimplementation that makes it easier to modify the code. it should be\nfully compatible with recordtype.\n\nand in general, the attrs project\n(https://attrs.readthedocs.io/en/stable/) is an improvement to both\nrecordtype and namedlist.\n\noverview\n========\n\nrecordtype provides a factory function, named\nrecordtype.recordtype. it is similar to collections.namedtuple, with\nthe following differences:\n\n* recordtype instances are mutable.\n\n* recordtype supports per-field default values.\n\n* recordtype supports an optional default value, to be used by all\n  fields do not have an explicit default value.\n\ntypical usage\n=============\n\nyou can use recordtype like a mutable namedtuple::\n\n    >>> from recordtype import recordtype\n\n    >>> point = recordtype('point', 'x y')\n    >>> p = point(1, 3)\n    >>> p.x = 2\n    >>> assert p.x == 2\n    >>> assert p.y == 3\n\nor, you can specify a default value for all fields::\n\n    >>> point = recordtype('point', 'x y', default=3)\n    >>> p = point(y=2)\n    >>> assert p.x == 3\n    >>> assert p.y == 2\n\nor, you can specify per-field default values::\n\n    >>> point = recordtype('point', [('x', 0), ('y', 100)])\n    >>> p = point()\n    >>> assert p.x == 0\n    >>> assert p.y == 100\n\nyou can also specify a the per-field defaults with a mapping, instead\nof an interable. note that this is only useful with an ordered\nmapping, such as an ordereddict::\n\n    >>> from collections import ordereddict\n    >>> point = recordtype('point', ordereddict((('y', 0),\n    ...                                          ('x', 100))))\n    >>> p = point()\n    >>> assert p.x == 100\n    >>> assert p.y == 0\n\nthe default value will only be used if it is provided and a per-field\ndefault is not used::\n\n    >>> point = recordtype('point', ['x', ('y', 100)], default=10)\n    >>> p = point()\n    >>> assert p.x == 10\n    >>> assert p.y == 100\n\nif you use a mapping, the value no_default is convenient to specify\nthat a field uses the default value::\n\n    >>> from recordtype import no_default\n    >>> point = recordtype('point', ordereddict((('y', no_default),\n    ...                                          ('x', 100))),\n    ...                             default=5)\n    >>> p = point()\n    >>> assert p.x == 100\n    >>> assert p.y == 5\n\n\ncreating types\n==============\n\nspecifying fields\n-----------------\n\nfields can be specified as in namedtuple: as either a string specifing\nthe field names, or as a iterable of field names. these two uses are\nequivalent::\n\n    >>> point = recordtype('point', 'x y')\n    >>> point = recordtype('point', ['x', 'y'])\n\nif using a string, commas are first converted to spaces. so these are\nequivalent::\n\n    >>> point = recordtype('point', 'x y')\n    >>> point = recordtype('point', 'x,y')\n\n\nspecifying defaults\n-------------------\n\nper-field defaults can be specified by supplying a 2-tuple (name,\ndefault_value) instead of just a string for the field name. this is\nonly supported when you specify a list of field names::\n\n    >>> point = recordtype('point', [('x', 0), ('y', 0)])\n    >>> p = point(3)\n    >>> assert p.x == 3\n    >>> assert p.y == 0\n\nin addition to, or instead of, these per-field defaults, you can also\nspecify a default value which is used when no per-field default value\nis specified::\n\n    >>> point = recordtype('point', 'x y z', default=0)\n    >>> p = point(y=3)\n    >>> assert p.x == 0\n    >>> assert p.y == 3\n    >>> assert p.z == 0\n\n    >>> point = recordtype('point', [('x', 0), 'y', ('z', 0)], default=4)\n    >>> p = point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nin addition to supplying the field names as an iterable of 2-tuples,\nyou can also specify a mapping. the keys will be the field names, and\nthe values will be the per-field default values. this is most useful\nwith an ordereddict, as the order of the fields will then be\ndeterministic.  the module variable no_default can be specified if you\nwant a field to use the per-type default value instead of specifying\nit with a field::\n\n    >>> point = recordtype('point', ordereddict((('x', 0),\n    ...                                          ('y', no_default),\n    ...                                          ('z', 0),\n    ...                                          )),\n    ...                             default=4)\n    >>> p = point(z=2)\n    >>> assert p.x == 0\n    >>> assert p.y == 4\n    >>> assert p.z == 2\n\nwriting to values\n-----------------\n\nthe objects retured by the factory function are fully writable, unlike\nthe tuple-derived classes returned by namedtuple::\n\n    >>> point = recordtype('point', 'x y')\n    >>> p = point(1, 2)\n    >>> p.y = 4\n    >>> assert p.x == 1\n    >>> assert p.y == 4\n\n\nspecifying __slots__\n--------------------\n\nby default, the returned class sets __slots__, which is initialized to\nthe field names. while this decreases memory usage by eliminating the\ninstance dict, it also means that you cannot create new instance\nmembers.\n\nto change this behavior, specify use_slots=false when creating the\nrecordtype::\n\n    >>> point = recordtype('point', 'x y', use_slots=false)\n    >>> p = point(0, 1)\n    >>> p.z = 2\n    >>> assert p.x == 0\n    >>> assert p.y == 1\n    >>> assert p.z == 2\n\n\nadditional class members\n------------------------\n\nrecordtype classes contain these members:\n\n* _asdict(): returns a dict which maps field names to their\n  corresponding values.\n\n* _source: a string with the pure python source code used to create\n  the recordtype class. the source makes the recordtype\n  self-documenting. it can be printed, executed using exec(), or saved\n  to a file and imported.\n\n* _fields: tuple of strings listing the field names. useful for introspection.\n\n\nrenaming invalid field names\n----------------------------\n\nthis functionality is identical to namedtuple. if you specify\nrename=true, then any invalid field names are changed to _0, _1,\netc. reasons for a field name to be invalid are:\n\n* zero length strings.\n\n* containing characters other than alphanumerics and underscores.\n\n* a conflict with a python reserved identifier.\n\n* beginning with a digit.\n\n* beginning with an underscore.\n\n* using the same field name more than once.\n\nfor example::\n\n    >>> point = recordtype('point', 'x x for', rename=true)\n    >>> assert point._fields == ('x', '_1', '_2')\n\n\nmutable default values\n----------------------\n\nbe aware of creating mutable default values. due to the way python\nhandles default values, each instance of a recordtype will share the\ndefault. this is especially problematic with default values that are\nlists. for example::\n\n    >>> a = recordtype('a', [('x', [])])\n    >>> a = a()\n    >>> a.x.append(4)\n    >>> b = a()\n    >>> assert b.x == [4]\n\nthis is probably not the desired behavior.\n\ncreating and using instances\n============================\n\nbecause the type returned by recordtype is a normal python class, you\ncreate instances as you would with any python class.\n\n\nchange log\n==========\n\n1.4 2022-09-22 eric v. smith\n----------------------------\n* for python 3.10 compatibility, try to import collections.abc.mapping.\n* reformat with black.\n\n1.3 2018-08-03 eric v. smith\n----------------------------\n* python 3 support (thanks jakob stasiak).\n* reformat with black.\n\n1.2 <unreleased> eric v. smith\n------------------------------\n* switch readme.txt to support doctest.\n* add tests for mutable default values.\n* add warning for mutable default values.\n\n1.1 2011-11-14 eric v. smith\n----------------------------\n* no api or code changes.\n* fixed project url in setup.py.\n* fixed license description in setup.py.\n\n1.0 2011-10-23 eric v. smith\n----------------------------\n* stabilize api, move to version 1.0.\n* added \"python setup.py test\" support to run unittests.\n* improve documentation examples.\n* renamed \"default_default\" to just \"default\".\n* expose \"no_default\".\n* support mapping objects in addition to strings and lists for field_names.\n* add tests for iterables, not just lists, for field_names.\n\n0.2 2011-10-13 eric v. smith\n----------------------------\n* fix a typo in the documentation, no code changes.\n\n0.1 2011-10-12 eric v. smith\n----------------------------\n* initial release.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license version 2.0",
  "name": "recordtype",
  "package_url": "https://pypi.org/project/recordtype/",
  "project_url": "https://pypi.org/project/recordtype/",
  "project_urls": {
    "Homepage": "https://bitbucket.org/ericvsmith/recordtype"
  },
  "release_url": "https://pypi.org/project/recordtype/1.4/",
  "requires_dist": [
    "six"
  ],
  "requires_python": "",
  "summary": "similar to namedtuple, but instances are mutable.",
  "version": "1.4",
  "releases": [],
  "developers": [
    "eric@trueblade.com",
    "eric_v"
  ],
  "kwds": "recordtype field_names namedlist namedtuple type",
  "license_kwds": "apache license version 2.0",
  "libtype": "pypi",
  "id": "pypi_recordtype",
  "homepage": "https://bitbucket.org/ericvsmith/recordtype",
  "release_count": 6,
  "dependency_ids": [
    "pypi_six"
  ]
}