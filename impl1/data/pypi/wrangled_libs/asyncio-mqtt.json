{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: macos",
    "operating system :: microsoft :: windows",
    "operating system :: posix :: linux",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy"
  ],
  "description": "<h1 align=\"center\">idiomatic asyncio mqtt client \ud83d\ude4c</h1>\n<p align=\"center\">\n    <a href=\"https://github.com/sbtinstruments/asyncio-mqtt/blob/main/license\"><img alt=\"license: bsd-3-clause\" src=\"https://img.shields.io/github/license/sbtinstruments/asyncio-mqtt\"></a>\n    <a href=\"https://pypi.org/project/asyncio-mqtt\"><img alt=\"pypi version\" src=\"https://img.shields.io/pypi/v/asyncio-mqtt\"></a>\n    <a href=\"https://pypi.org/project/asyncio-mqtt\"><img alt=\"supported python versions\" src=\"https://img.shields.io/pypi/pyversions/asyncio-mqtt.svg\"></a>\n    <a href=\"https://pypi.org/project/asyncio-mqtt\"><img alt=\"pypi downloads\" src=\"https://img.shields.io/pypi/dm/asyncio-mqtt\"></a>\n    <a href=\"https://github.com/sbtinstruments/asyncio-mqtt/actions/workflows/test.yml\"><img alt=\"coverage\" src=\"https://github.com/sbtinstruments/asyncio-mqtt/actions/workflows/test.yml/badge.svg\"></a>\n    <a href=\"https://codecov.io/gh/sbtinstruments/asyncio-mqtt\"><img alt=\"coverage\" src=\"https://img.shields.io/codecov/c/github/sbtinstruments/asyncio-mqtt\"></a>\n    <a href=\"https://results.pre-commit.ci/latest/github/sbtinstruments/asyncio-mqtt/master\"><img alt=\"pre-commit.ci status\" src=\"https://results.pre-commit.ci/badge/github/sbtinstruments/asyncio-mqtt/master.svg\"></a>\n    <a href=\"https://github.com/sbtinstruments/asyncio-mqtt\"><img alt=\"typing: strict\" src=\"https://img.shields.io/badge/typing-strict-green.svg\"></a>\n    <a href=\"https://github.com/sbtinstruments/asyncio-mqtt\"><img alt=\"code style: black\" src=\"https://img.shields.io/badge/code%20style-black-black\"></a>\n</p>\n\nwrite code like this:\n\n**subscriber**\n\n```python\nasync with client(\"test.mosquitto.org\") as client:\n    async with client.messages() as messages:\n        await client.subscribe(\"humidity/#\")\n        async for message in messages:\n            print(message.payload)\n```\n\n**publisher**\n\n```python\nasync with client(\"test.mosquitto.org\") as client:\n    await client.publish(\"humidity/outside\", payload=0.38)\n```\n\n_asyncio-mqtt_ combines the stability of the time-proven [paho-mqtt](https://github.com/eclipse/paho.mqtt.python) library with a modern, asyncio-based interface.\n\n- no more callbacks! \ud83d\udc4d\n- no more return codes (welcome to the `mqtterror`)\n- graceful disconnection (forget about `on_unsubscribe`, `on_disconnect`, etc.)\n- compatible with `async` code\n- fully type-hinted\n- did we mention no more callbacks?\n\nthe whole thing is less than [700 lines of code](asyncio-mqtt/client.py).\n\n## contents \ud83d\udd0d\n\n- [installation](#installation-)\n  - [note for windows users](#note-for-windows-users)\n- [advanced usage](#advanced-usage-)\n  - [configuring the client](#configuring-the-client)\n  - [filtering messages](#filtering-messages)\n  - [sharing the connection](#sharing-the-connection)\n    - [side by side with web frameworks](#side-by-side-with-web-frameworks)\n    - [why can't i `connect`/`disconnect` manually?](#why-cant-i-connectdisconnect-manually)\n  - [listening without blocking](#listening-without-blocking)\n  - [reconnecting](#reconnecting)\n  - [tls](#tls)\n  - [proxying](#proxying)\n- [license](#license-)\n- [versioning](#versioning-)\n- [changelog](#changelog-)\n- [related projects](#related-projects-)\n\n## installation \ud83d\udcda\n\n_asyncio-mqtt_ can be installed via `pip install asyncio-mqtt`. it requires python 3.7+ to run. the only dependency is [paho-mqtt](https://github.com/eclipse/paho.mqtt.python).\n\nif you can't wait for the latest version and want to install directly from github, use:\n\n`pip install git+https://github.com/sbtinstruments/asyncio-mqtt`\n\n### note for windows users\n\nsince python 3.8, the default asyncio event loop is the `proactoreventloop`. said loop [doesn't support the `add_reader` method](https://docs.python.org/3/library/asyncio-platforms.html#windows) that is required by _asyncio-mqtt_. please switch to an event loop that supports the `add_reader` method such as the built-in `selectoreventloop`:\n\n```python\n# change to the \"selector\" event loop\nasyncio.set_event_loop_policy(asyncio.windowsselectoreventlooppolicy())\n# run your async application as usual\nasyncio.run(main())\n```\n\n## advanced usage \u26a1\n\nlet's make the example from before more interesting:\n\n### configuring the client\n\nyou can configure quite a few things when initializing the client. these are all the possible parameters together with their default values. see [paho-mqtt's documentation](https://github.com/eclipse/paho.mqtt.python) for more information about the individual parameters.\n\n```python\nimport asyncio_mqtt as aiomqtt\nimport paho.mqtt as mqtt\n\n\naiomqtt.client(\n    hostname=\"test.mosquitto.org\",  # the only non-optional parameter\n    port=1883,\n    username=none,\n    password=none,\n    logger=none,\n    client_id=none,\n    tls_context=none,\n    tls_params=none,\n    proxy=none,\n    protocol=none,\n    will=none,\n    clean_session=none,\n    transport=\"tcp\",\n    keepalive=60,\n    bind_address=\"\",\n    bind_port=0,\n    clean_start=mqtt.client.mqtt_clean_start_first_only,\n    properties=none,\n    message_retry_set=20,\n    socket_options=(),\n    max_concurrent_outgoing_calls=none,\n    websocket_path=none,\n    websocket_headers=none,\n)\n```\n\n### filtering messages\n\nimagine you're measuring temperature and humidity on the outside and inside, and our topics look like this: `temperature/outside`. you want to receive all types of measurements but handle them differently. _asyncio-mqtt_ provides `topic.matches()` to make this easy:\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\n\n\nasync def main():\n    async with aiomqtt.client(\"test.mosquitto.org\") as client:\n        async with client.messages() as messages:\n            await client.subscribe(\"#\")\n            async for message in messages:\n                if message.topic.matches(\"humidity/outside\"):\n                    print(f\"[humidity/outside] {message.payload}\")\n                if message.topic.matches(\"+/inside\"):\n                    print(f\"[+/inside] {message.payload}\")\n                if message.topic.matches(\"temperature/#\"):\n                    print(f\"[temperature/#] {message.payload}\")\n\n\nasyncio.run(main())\n```\n\nnote that in our example, messages to `temperature/inside` are handled twice!\n\n### sharing the connection\n\nin many cases, you'll want to send and receive messages in different locations in your code. you could create a new client each time, but\n\n1. this is not very performant, and\n2. you'll use a lot more network bandwidth.\n\nyou can share the connection by passing the `client` instance to all functions that need it:\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\n\n\nasync def publish_humidity(client):\n    await client.publish(\"humidity/outside\", payload=0.38)\n\n\nasync def publish_temperature(client):\n    await client.publish(\"temperature/outside\", payload=28.3)\n\n\nasync def main():\n    async with aiomqtt.client(\"test.mosquitto.org\") as client:\n        await publish_humidity(client)\n        await publish_temperature(client)\n\n\nasyncio.run(main())\n```\n\n#### side by side with web frameworks\n\nmost web frameworks take control over the \"main\" function, which makes it difficult to figure out where to create and connect the `client` and how to share this connection.\n\nsome frameworks like [starlette](https://github.com/encode/starlette) directly support lifespan context managers, with which you can safely set up a global client instance that you can then pass to functions that need it, just like before:\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\nimport starlette.applications\nimport contextlib\n\n\nclient = none\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(app):\n    global client\n    async with aiomqtt.client(\"test.mosquitto.org\") as c:\n        client = c\n        yield\n\n\napp = starlette.applications.starlette(\n    routes=[],\n    lifespan=lifespan,\n)\n```\n\nfastapi (which is built upon starlette) doesn't expose that api yet, but there are [multiple](https://github.com/tiangolo/fastapi/pull/5503) [open prs](https://github.com/tiangolo/fastapi/pull/2944) to add it. in the meantime, you can work around it via fastapi's dependency injection.\n\n#### why can't i `connect`/`disconnect` manually?\n\nmanaging a connection by calling `connect` and `disconnect` directly is a bit tricky. for example, when you're disconnecting the client, you'd have to make sure that there's no other task that still relies on the connection. there are many similar situations where something can easily go wrong.\n\ncontext managers take care of all connection and disconnection logic for you, in a way that makes it very difficult to shoot yourself in the foot. they are a lot easier and less error-prone to use than `connect`/`disconnect`.\n\nsupporting both context managers and manual `connect`/`disconnect` would add a lot of complexity to _asyncio-mqtt_. to keep maintainer burden manageable, we focus only on the preferred option: context managers.\n\n### listening without blocking\n\nif you run the basic example for subscribing and listening for messages, you'll notice that the program doesn't finish until you stop it. waiting for messages blocks the execution of everything that comes afterwards. if you want to run other code after starting your listener (e.g. handling http requests in a web framework) you don't want this.\n\nto solve this, you can use asyncio's `create_task` without `await`ing the created task. the concept is similar to starting a new thread without `join`ing it in a multithreaded application.\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\n\n\nasync def listen():\n    async with aiomqtt.client(\"test.mosquitto.org\") as client:\n        async with client.messages() as messages:\n            await client.subscribe(\"humidity/#\")\n            async for message in messages:\n                print(message.payload)\n\n\nasync def main():\n    # wait for messages in (unawaited) asyncio task\n    loop = asyncio.get_event_loop()\n    task = loop.create_task(listen())\n    # this will still run!\n    print(\"magic!\")\n    # if you don't await the task here the program will simply finish.\n    # however, if you're using an async web framework you usually don't have to await\n    # the task, as the framework runs in an endless loop.\n    await task\n\n\nasyncio.run(main())\n```\n\n### reconnecting\n\nyou can reconnect when the connection to the broker is lost by wrapping your code in a `try/except`-block and listening for `mqtterror`s.\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\n\n\nasync def main():\n    reconnect_interval = 5  # in seconds\n    while true:\n        try:\n            async with aiomqtt.client(\"test.mosquitto.org\") as client:\n                async with client.messages() as messages:\n                    await client.subscribe(\"humidity/#\")\n                    async for message in messages:\n                        print(message.payload.decode())\n        except aiomqtt.mqtterror as error:\n            print(f'error \"{error}\". reconnecting in {reconnect_interval} seconds.')\n            await asyncio.sleep(reconnect_interval)\n\n\n\nasyncio.run(main())\n```\n\n### tls\n\nyou can configure tls via the `tlsparameters` class. the parameters are directly passed through to paho-mqtt's `tls_set` function. see [paho-mqtt's documentation](https://github.com/eclipse/paho.mqtt.python) for more information about the individual parameters.\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\nimport ssl\n\n\ntls_params = aiomqtt.tlsparameters(\n    ca_certs=none,\n    certfile=none,\n    keyfile=none,\n    cert_reqs=ssl.cert_required,\n    tls_version=ssl.protocol_tls,\n    ciphers=none,\n)\n\n\nasync def main():\n    async with aiomqtt.client(\"test.mosquitto.org\", tls_params=tls_params) as client:\n        await client.publish(\"humidity/outside\", payload=0.38)\n\n\nasyncio.run(main())\n```\n\n### proxying\n\nyou can configure proxying via the `proxysettings` class. the parameters are directly passed through to paho-mqtt's `proxy_set` functionality. both socks and http proxies are supported. note that proxying is an extra feature (even in paho-mqtt) that requires the `pysocks` dependency. see [paho-mqtt's documentation](https://github.com/eclipse/paho.mqtt.python) for more information about the individual parameters.\n\n```python\nimport asyncio\nimport asyncio_mqtt as aiomqtt\nimport socks\n\n\nproxy_params = aiomqtt.proxysettings(\n    proxy_type=socks.http,\n    proxy_addr=\"www.example.com\",\n    proxy_rdns=true,\n    proxy_username=none,\n    proxy_password=none,\n)\n\nasync def main():\n    async with aiomqtt.client(\"test.mosquitto.org\", proxy=proxy_params) as client:\n        await client.publish(\"humidity/outside\", payload=0.38)\n\n\nasyncio.run(main())\n```\n\n## license \ud83d\udccb\n\n<a href=\"https://github.com/sbtinstruments/asyncio-mqtt/blob/main/license\"><img alt=\"license: bsd-3-clause\" src=\"https://img.shields.io/github/license/sbtinstruments/asyncio-mqtt\"></a>\n\nnote that the underlying paho-mqtt library is dual-licensed. one of the licenses is the so-called [eclipse distribution license v1.0](https://www.eclipse.org/org/documents/edl-v10.php). it is almost word-for-word identical to the [bsd 3-clause license](https://opensource.org/licenses/bsd-3-clause). the only differences are:\n\n- one use of \"copyright owner\" (edl) instead of \"copyright holder\" (bsd)\n- one use of \"eclipse foundation, inc.\" (edl) instead of \"copyright holder\" (bsd)\n\n## versioning \ud83c\udfaf\n\n<a href=\"https://pypi.org/project/asyncio-mqtt\"><img alt=\"pypi\" src=\"https://img.shields.io/pypi/v/asyncio-mqtt\"></a>\n\nthis project adheres to [semantic versioning](https://semver.org/spec/v2.0.0.html).\n\nexpect api changes until we reach version `1.0.0`. after `1.0.0`, breaking changes will only occur in major release (e.g., `2.0.0`, `3.0.0`, etc.).\n\n## changelog \ud83d\udea7\n\nplease refer to the [changelog](https://github.com/sbtinstruments/asyncio-mqtt/blob/master/changelog.md) document. it adheres to the principles of [keep a changelog](https://keepachangelog.com/en/1.0.0/).\n\n## related projects \ud83c\udf1f\n\nis _asyncio-mqtt_ not what you are looking for? try another client:\n\n- [paho-mqtt](https://github.com/eclipse/paho.mqtt.python) \u2014 own protocol implementation. synchronous.<br>![github stars](https://img.shields.io/github/stars/eclipse/paho.mqtt.python) ![license](https://img.shields.io/github/license/eclipse/paho.mqtt.python)\n- [gmqtt](https://github.com/wialon/gmqtt) \u2014 own protocol implementation. asynchronous.<br>![github stars](https://img.shields.io/github/stars/wialon/gmqtt) ![license](https://img.shields.io/github/license/wialon/gmqtt)\n- [fastapi-mqtt](https://github.com/sabuhish/fastapi-mqtt) \u2014 asynchronous wrapper around gmqtt. simplifies integration in your fastapi application.<br>![github stars](https://img.shields.io/github/stars/sabuhish/fastapi-mqtt) ![license](https://img.shields.io/github/license/sabuhish/fastapi-mqtt)\n- [amqtt](https://github.com/yakifo/amqtt) \u2014 own protocol implementation. asynchronous. includes a broker.<br>![github stars](https://img.shields.io/github/stars/yakifo/amqtt) ![license](https://img.shields.io/github/license/yakifo/amqtt)\n- [mqttools](https://github.com/eerimoq/mqttools) \u2014 own protocol implementation. asynchronous.<br>![github stars](https://img.shields.io/github/stars/eerimoq/mqttools) ![license](https://img.shields.io/github/license/eerimoq/mqttools)\n- [trio-paho-mqtt](https://github.com/bkanuka/trio-paho-mqtt) \u2014 asynchronous wrapper around paho-mqtt (similar to _asyncio-mqtt_). based on trio instead of asyncio.<br>![github stars](https://img.shields.io/github/stars/bkanuka/trio-paho-mqtt) ![license](https://img.shields.io/github/license/bkanuka/trio-paho-mqtt)\n",
  "docs_url": null,
  "keywords": "mqtt,async,asyncio,paho-mqtt,wrapper",
  "license": "bsd 3-clause license",
  "name": "asyncio-mqtt",
  "package_url": "https://pypi.org/project/asyncio-mqtt/",
  "project_url": "https://pypi.org/project/asyncio-mqtt/",
  "project_urls": {
    "Issue tracker": "https://github.com/sbtinstruments/asyncio-mqtt/issues",
    "Source code": "https://github.com/sbtinstruments/asyncio-mqtt"
  },
  "release_url": "https://pypi.org/project/asyncio-mqtt/0.16.2/",
  "requires_dist": [
    "paho-mqtt (>=1.6.0)",
    "typing-extensions (>=4.4.0) ; python_version < \"3.10\"",
    "black (>=22.10.0) ; extra == 'format'",
    "mypy (>=0.991) ; extra == 'lint'",
    "ruff (>=0.0.158) ; extra == 'lint'",
    "types-paho-mqtt (>=1.6.0.1) ; extra == 'lint'",
    "pytest (>=7.2.0) ; extra == 'tests'",
    "pytest-cov (>=4.0.0) ; extra == 'tests'",
    "anyio (>=3.6.2) ; extra == 'tests'"
  ],
  "requires_python": ">=3.7",
  "summary": "idiomatic asyncio wrapper around paho-mqtt",
  "version": "0.16.2",
  "releases": [],
  "developers": [
    "felix@felixboehm.dev",
    "fpa@sbtinstruments.com",
    "jonathan.plasse@live.fr"
  ],
  "kwds": "asyncio_mqtt amqtt mqtt mqtt_ asyncio",
  "license_kwds": "bsd 3-clause license",
  "libtype": "pypi",
  "id": "pypi_asyncio_mqtt",
  "homepage": "",
  "release_count": 27,
  "dependency_ids": [
    "pypi_anyio",
    "pypi_black",
    "pypi_mypy",
    "pypi_paho_mqtt",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_ruff",
    "pypi_types_paho_mqtt",
    "pypi_typing_extensions"
  ]
}