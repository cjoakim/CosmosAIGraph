{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "mammoth .docx to html converter\n===============================\n\nmammoth is designed to convert .docx documents, such as those created by\nmicrosoft word, google docs and libreoffice, and convert them to html.\nmammoth aims to produce simple and clean html by using semantic\ninformation in the document, and ignoring other details. for instance,\nmammoth converts any paragraph with the style ``heading 1`` to ``h1``\nelements, rather than attempting to exactly copy the styling (font, text\nsize, colour, etc.) of the heading.\n\nthere\u2019s a large mismatch between the structure used by .docx and the\nstructure of html, meaning that the conversion is unlikely to be perfect\nfor more complicated documents. mammoth works best if you only use\nstyles to semantically mark up your document.\n\nthe following features are currently supported:\n\n-  headings.\n\n-  lists.\n\n-  customisable mapping from your own docx styles to html. for instance,\n   you could convert ``warningheading`` to ``h1.warning`` by providing\n   an appropriate style mapping.\n\n-  tables. the formatting of the table itself, such as borders, is\n   currently ignored, but the formatting of the text is treated the same\n   as in the rest of the document.\n\n-  footnotes and endnotes.\n\n-  images.\n\n-  bold, italics, underlines, strikethrough, superscript and subscript.\n\n-  links.\n\n-  line breaks.\n\n-  text boxes. the contents of the text box are treated as a separate\n   paragraph that appears after the paragraph containing the text box.\n\n-  comments.\n\ninstallation\n------------\n\n::\n\n   pip install mammoth\n\nother supported platforms\n-------------------------\n\n-  `javascript <https://github.com/mwilliamson/mammoth.js>`__, both the\n   browser and node.js. available `on\n   npm <https://www.npmjs.com/package/mammoth>`__.\n\n-  `wordpress <https://wordpress.org/plugins/mammoth-docx-converter/>`__.\n\n-  `java/jvm <https://github.com/mwilliamson/java-mammoth>`__. available\n   `on maven\n   central <http://search.maven.org/#search%7cga%7c1%7cg%3a%22org.zwobble.mammoth%22%20and%20a%3a%22mammoth%22>`__.\n\n-  `.net <https://github.com/mwilliamson/dotnet-mammoth>`__. available\n   `on nuget <https://www.nuget.org/packages/mammoth/>`__.\n\nusage\n-----\n\ncli\n~~~\n\nyou can convert docx files by passing the path to the docx file and the\noutput file. for instance:\n\n::\n\n   mammoth document.docx output.html\n\nif no output file is specified, output is written to stdout instead.\n\nthe output is an html fragment, rather than a full html document,\nencoded with utf-8. since the encoding is not explicitly set in the\nfragment, opening the output file in a web browser may cause unicode\ncharacters to be rendered incorrectly if the browser doesn\u2019t default to\nutf-8.\n\nimages\n^^^^^^\n\nby default, images are included inline in the output html. if an output\ndirectory is specified by ``--output-dir``, the images are written to\nseparate files instead. for instance:\n\n::\n\n   mammoth document.docx --output-dir=output-dir\n\nexisting files will be overwritten if present.\n\nstyles\n^^^^^^\n\na custom style map can be read from a file using ``--style-map``. for\ninstance:\n\n::\n\n   mammoth document.docx output.html --style-map=custom-style-map\n\nwhere ``custom-style-map`` looks something like:\n\n::\n\n   p[style-name='aside heading'] => div.aside > h2:fresh\n   p[style-name='aside text'] => div.aside > p:fresh\n\na description of the syntax for style maps can be found in the section\n`\u201cwriting style maps\u201d <#writing-style-maps>`__.\n\nmarkdown\n^^^^^^^^\n\nmarkdown support is deprecated. generating html and using a separate\nlibrary to convert the html to markdown is recommended, and is likely to\nproduce better results.\n\nusing ``--output-format=markdown`` will cause markdown to be generated.\nfor instance:\n\n::\n\n   mammoth document.docx --output-format=markdown\n\nlibrary\n~~~~~~~\n\nbasic conversion\n^^^^^^^^^^^^^^^^\n\nto convert an existing .docx file to html, pass a file-like object to\n``mammoth.convert_to_html``. the file should be opened in binary mode.\nfor instance:\n\n.. code:: python\n\n   import mammoth\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file)\n       html = result.value # the generated html\n       messages = result.messages # any messages, such as warnings during conversion\n\nyou can also extract the raw text of the document by using\n``mammoth.extract_raw_text``. this will ignore all formatting in the\ndocument. each paragraph is followed by two newlines.\n\n.. code:: python\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.extract_raw_text(docx_file)\n       text = result.value # the raw text\n       messages = result.messages # any messages\n\ncustom style map\n^^^^^^^^^^^^^^^^\n\nby default, mammoth maps some common .docx styles to html elements. for\ninstance, a paragraph with the style name ``heading 1`` is converted to\na ``h1`` element. you can pass in a custom map for styles by passing an\noptions object with a ``style_map`` property as a second argument to\n``convert_to_html``. a description of the syntax for style maps can be\nfound in the section `\u201cwriting style maps\u201d <#writing-style-maps>`__. for\ninstance, if paragraphs with the style name ``section title`` should be\nconverted to ``h1`` elements, and paragraphs with the style name\n``subsection title`` should be converted to ``h2`` elements:\n\n.. code:: python\n\n   import mammoth\n\n   style_map = \"\"\"\n   p[style-name='section title'] => h1:fresh\n   p[style-name='subsection title'] => h2:fresh\n   \"\"\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\nuser-defined style mappings are used in preference to the default style\nmappings. to stop using the default style mappings altogether, pass\n``include_default_style_map=false``:\n\n.. code:: python\n\n   result = mammoth.convert_to_html(docx_file, style_map=style_map, include_default_style_map=false)\n\ncustom image handlers\n^^^^^^^^^^^^^^^^^^^^^\n\nby default, images are converted to ``<img>`` elements with the source\nincluded inline in the ``src`` attribute. this behaviour can be changed\nby setting the ``convert_image`` argument to an `image\nconverter <#image-converters>`__ .\n\nfor instance, the following would replicate the default behaviour:\n\n.. code:: python\n\n   def convert_image(image):\n       with image.open() as image_bytes:\n           encoded_src = base64.b64encode(image_bytes.read()).decode(\"ascii\")\n\n       return {\n           \"src\": \"data:{0};base64,{1}\".format(image.content_type, encoded_src)\n       }\n\n   mammoth.convert_to_html(docx_file, convert_image=mammoth.images.img_element(convert_image))\n\nbold\n^^^^\n\nby default, bold text is wrapped in ``<strong>`` tags. this behaviour\ncan be changed by adding a style mapping for ``b``. for instance, to\nwrap bold text in ``<em>`` tags:\n\n.. code:: python\n\n   style_map = \"b => em\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\nitalic\n^^^^^^\n\nby default, italic text is wrapped in ``<em>`` tags. this behaviour can\nbe changed by adding a style mapping for ``i``. for instance, to wrap\nitalic text in ``<strong>`` tags:\n\n.. code:: python\n\n   style_map = \"i => strong\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\nunderline\n^^^^^^^^^\n\nby default, the underlining of any text is ignored since underlining can\nbe confused with links in html documents. this behaviour can be changed\nby adding a style mapping for ``u``. for instance, suppose that a source\ndocument uses underlining for emphasis. the following will wrap any\nexplicitly underlined source text in ``<em>`` tags:\n\n.. code:: python\n\n   import mammoth\n\n   style_map = \"u => em\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\nstrikethrough\n^^^^^^^^^^^^^\n\nby default, strikethrough text is wrapped in ``<s>`` tags. this\nbehaviour can be changed by adding a style mapping for ``strike``. for\ninstance, to wrap strikethrough text in ``<del>`` tags:\n\n.. code:: python\n\n   style_map = \"strike => del\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\ncomments\n^^^^^^^^\n\nby default, comments are ignored. to include comments in the generated\nhtml, add a style mapping for ``comment-reference``. for instance:\n\n.. code:: python\n\n   style_map = \"comment-reference => sup\"\n\n   with open(\"document.docx\", \"rb\") as docx_file:\n       result = mammoth.convert_to_html(docx_file, style_map=style_map)\n\ncomments will be appended to the end of the document, with links to the\ncomments wrapped using the specified style mapping.\n\napi\n~~~\n\n``mammoth.convert_to_html(fileobj, **kwargs)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nconverts the source document to html.\n\n-  ``fileobj``: a file-like object containing the source document. files\n   should be opened in binary mode.\n\n-  ``style_map``: a string to specify the mapping of word styles to\n   html. see the section `\u201cwriting style maps\u201d <#writing-style-maps>`__\n   for a description of the syntax.\n\n-  ``include_embedded_style_map``: by default, if the document contains\n   an embedded style map, then it is combined with the default style\n   map. to ignore any embedded style maps, pass\n   ``include_embedded_style_map=false``.\n\n-  ``include_default_style_map``: by default, the style map passed in\n   ``style_map`` is combined with the default style map. to stop using\n   the default style map altogether, pass\n   ``include_default_style_map=false``.\n\n-  ``convert_image``: by default, images are converted to ``<img>``\n   elements with the source included inline in the ``src`` attribute.\n   set this argument to an `image converter <#image-converters>`__ to\n   override the default behaviour.\n\n-  ``ignore_empty_paragraphs``: by default, empty paragraphs are\n   ignored. set this option to ``false`` to preserve empty paragraphs in\n   the output.\n\n-  ``id_prefix``: a string to prepend to any generated ids, such as\n   those used by bookmarks, footnotes and endnotes. defaults to an empty\n   string.\n\n-  ``transform_document``: if set, this function is applied to the\n   document read from the docx file before the conversion to html. the\n   api for document transforms should be considered unstable. see\n   `document transforms <#document-transforms>`__.\n\n-  returns a result with the following properties:\n\n   -  ``value``: the generated html\n\n   -  ``messages``: any messages, such as errors and warnings, generated\n      during the conversion\n\n``mammoth.convert_to_markdown(fileobj, **kwargs)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nmarkdown support is deprecated. generating html and using a separate\nlibrary to convert the html to markdown is recommended, and is likely to\nproduce better results.\n\nconverts the source document to markdown. this behaves the same as\n``convert_to_html``, except that the ``value`` property of the result\ncontains markdown rather than html.\n\n``mammoth.extract_raw_text(fileobj)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nextract the raw text of the document. this will ignore all formatting in\nthe document. each paragraph is followed by two newlines.\n\n-  ``fileobj``: a file-like object containing the source document. files\n   should be opened in binary mode.\n\n-  returns a result with the following properties:\n\n   -  ``value``: the raw text\n\n   -  ``messages``: any messages, such as errors and warnings\n\n``mammoth.embed_style_map(fileobj, style_map)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nembeds the style map ``style_map`` into ``fileobj``. when mammoth reads\na file object, it will use the embedded style map.\n\n-  ``fileobj``: a file-like object containing the source document. files\n   should be opened for reading and writing in binary mode.\n\n-  ``style_map``: the style map to embed.\n\n-  returns ``none``.\n\nmessages\n^^^^^^^^\n\neach message has the following properties:\n\n-  ``type``: a string representing the type of the message, such as\n   ``\"warning\"``\n\n-  ``message``: a string containing the actual message\n\nimage converters\n^^^^^^^^^^^^^^^^\n\nan image converter can be created by calling\n``mammoth.images.img_element(func)``. this creates an ``<img>`` element\nfor each image in the original docx. ``func`` should be a function that\nhas one argument ``image``. this argument is the image element being\nconverted, and has the following properties:\n\n-  ``open()``: open the image file. returns a file-like object.\n\n-  ``content_type``: the content type of the image, such as\n   ``image/png``.\n\n``func`` should return a ``dict`` of attributes for the ``<img>``\nelement. at a minimum, this should include the ``src`` attribute. if any\nalt text is found for the image, this will be automatically added to the\nelement\u2019s attributes.\n\nfor instance, the following replicates the default image conversion:\n\n.. code:: python\n\n   def convert_image(image):\n       with image.open() as image_bytes:\n           encoded_src = base64.b64encode(image_bytes.read()).decode(\"ascii\")\n\n       return {\n           \"src\": \"data:{0};base64,{1}\".format(image.content_type, encoded_src)\n       }\n\n   mammoth.images.img_element(convert_image)\n\n``mammoth.images.data_uri`` is the default image converter.\n\nwmf images are not handled by default by mammoth. the recipes directory\ncontains `an example of how they can be converted using\nlibreoffice <https://github.com/mwilliamson/python-mammoth/blob/master/recipes/wmf_images.py>`__,\nalthough the fidelity of the conversion depends entirely on libreoffice.\n\ndocument transforms\n~~~~~~~~~~~~~~~~~~~\n\n**the api for document transforms should be considered unstable, and may\nchange between any versions. if you rely on this behaviour, you should\npin to a specific version of mammoth, and test carefully before\nupdating.**\n\nmammoth allows a document to be transformed before it is converted. for\ninstance, suppose that document has not been semantically marked up, but\nyou know that any centre-aligned paragraph should be a heading. you can\nuse the ``transform_document`` argument to modify the document\nappropriately:\n\n.. code:: python\n\n   import mammoth.transforms\n\n   def transform_paragraph(element):\n       if element.alignment == \"center\" and not element.style_id:\n           return element.copy(style_id=\"heading2\")\n       else:\n           return element\n\n   transform_document = mammoth.transforms.paragraph(transform_paragraph)\n\n   mammoth.convert_to_html(fileobj, transform_document=transform_document)\n\nor if you want paragraphs that have been explicitly set to use monospace\nfonts to represent code:\n\n.. code:: python\n\n   import mammoth.documents\n   import mammoth.transforms\n\n   _monospace_fonts = set([\"consolas\", \"courier\", \"courier new\"])\n\n   def transform_paragraph(paragraph):\n       runs = mammoth.transforms.get_descendants_of_type(paragraph, mammoth.documents.run)\n       if runs and all(run.font and run.font.lower() in _monospace_fonts for run in runs):\n           return paragraph.copy(style_id=\"code\", style_name=\"code\")\n       else:\n           return paragraph\n\n   convert_to_html(\n       fileobj,\n       transform_document=mammoth.transforms.paragraph(transform_paragraph),\n       style_map=\"p[style-name='code'] => pre:separator('\\n')\",\n   )\n\n``mammoth.transforms.paragraph(transform_paragraph)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nreturns a function that can be used as the ``transform_document``\nargument. this will apply the function ``transform_paragraph`` to each\nparagraph element. ``transform_paragraph`` should return the new\nparagraph.\n\n``mammoth.transforms.run(transform_run)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nreturns a function that can be used as the ``transform_document``\nargument. this will apply the function ``transform_run`` to each run\nelement. ``transform_run`` should return the new run.\n\n``mammoth.transforms.get_descendants(element)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ngets all descendants of an element.\n\n``mammoth.transforms.get_descendants_of_type(element, type)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ngets all descendants of a particular type of an element. for instance,\nto get all runs within an element ``paragraph``:\n\n.. code:: python\n\n   import mammoth.documents\n   import mammoth.transforms\n\n   runs = mammoth.transforms.get_descendants_of_type(paragraph, documents.run);\n\nwriting style maps\n------------------\n\na style map is made up of a number of style mappings separated by new\nlines. blank lines and lines starting with ``#`` are ignored.\n\na style mapping has two parts:\n\n-  on the left, before the arrow, is the document element matcher.\n-  on the right, after the arrow, is the html path.\n\nwhen converting each paragraph, mammoth finds the first style mapping\nwhere the document element matcher matches the current paragraph.\nmammoth then ensures the html path is satisfied.\n\nfreshness\n~~~~~~~~~\n\nwhen writing style mappings, it\u2019s helpful to understand mammoth\u2019s notion\nof freshness. when generating, mammoth will only close an html element\nwhen necessary. otherwise, elements are reused.\n\nfor instance, suppose one of the specified style mappings is\n``p[style-name='heading 1'] => h1``. if mammoth encounters a .docx\nparagraph with the style name ``heading 1``, the .docx paragraph is\nconverted to a ``h1`` element with the same text. if the next .docx\nparagraph also has the style name ``heading 1``, then the text of that\nparagraph will be appended to the *existing* ``h1`` element, rather than\ncreating a new ``h1`` element.\n\nin most cases, you\u2019ll probably want to generate a new ``h1`` element\ninstead. you can specify this by using the ``:fresh`` modifier:\n\n``p[style-name='heading 1'] => h1:fresh``\n\nthe two consecutive ``heading 1`` .docx paragraphs will then be\nconverted to two separate ``h1`` elements.\n\nreusing elements is useful in generating more complicated html\nstructures. for instance, suppose your .docx contains asides. each aside\nmight have a heading and some body text, which should be contained\nwithin a single ``div.aside`` element. in this case, style mappings\nsimilar to ``p[style-name='aside heading'] => div.aside > h2:fresh`` and\n``p[style-name='aside text'] => div.aside > p:fresh`` might be helpful.\n\ndocument element matchers\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nparagraphs, runs and tables\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nmatch any paragraph:\n\n::\n\n   p\n\nmatch any run:\n\n::\n\n   r\n\nmatch any table:\n\n::\n\n   table\n\nto match a paragraph, run or table with a specific style, you can\nreference the style by name. this is the style name that is displayed in\nmicrosoft word or libreoffice. for instance, to match a paragraph with\nthe style name ``heading 1``:\n\n::\n\n   p[style-name='heading 1']\n\nyou can also match a style name by prefix. for instance, to match a\nparagraph where the style name starts with ``heading``:\n\n::\n\n   p[style-name^='heading']\n\nstyles can also be referenced by style id. this is the id used\ninternally in the .docx file. to match a paragraph or run with a\nspecific style id, append a dot followed by the style id. for instance,\nto match a paragraph with the style id ``heading1``:\n\n::\n\n   p.heading1\n\n.. _bold-1:\n\nbold\n^^^^\n\nmatch explicitly bold text:\n\n::\n\n   b\n\nnote that this matches text that has had bold explicitly applied to it.\nit will not match any text that is bold because of its paragraph or run\nstyle.\n\n.. _italic-1:\n\nitalic\n^^^^^^\n\nmatch explicitly italic text:\n\n::\n\n   i\n\nnote that this matches text that has had italic explicitly applied to\nit. it will not match any text that is italic because of its paragraph\nor run style.\n\n.. _underline-1:\n\nunderline\n^^^^^^^^^\n\nmatch explicitly underlined text:\n\n::\n\n   u\n\nnote that this matches text that has had underline explicitly applied to\nit. it will not match any text that is underlined because of its\nparagraph or run style.\n\nstrikethough\n^^^^^^^^^^^^\n\nmatch explicitly struckthrough text:\n\n::\n\n   strike\n\nnote that this matches text that has had strikethrough explicitly\napplied to it. it will not match any text that is struckthrough because\nof its paragraph or run style.\n\nall caps\n^^^^^^^^\n\nmatch explicitly all caps text:\n\n::\n\n   all-caps\n\nnote that this matches text that has had all caps explicitly applied to\nit. it will not match any text that is all caps because of its paragraph\nor run style.\n\nsmall caps\n^^^^^^^^^^\n\nmatch explicitly small caps text:\n\n::\n\n   small-caps\n\nnote that this matches text that has had small caps explicitly applied\nto it. it will not match any text that is small caps because of its\nparagraph or run style.\n\nignoring document elements\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nuse ``!`` to ignore a document element. for instance, to ignore any\nparagraph with the style ``comment``:\n\n::\n\n   p[style-name='comment'] => !\n\nhtml paths\n~~~~~~~~~~\n\nsingle elements\n^^^^^^^^^^^^^^^\n\nthe simplest html path is to specify a single element. for instance, to\nspecify an ``h1`` element:\n\n::\n\n   h1\n\nto give an element a css class, append a dot followed by the name of the\nclass:\n\n::\n\n   h1.section-title\n\nto require that an element is fresh, use ``:fresh``:\n\n::\n\n   h1:fresh\n\nmodifiers must be used in the correct order:\n\n::\n\n   h1.section-title:fresh\n\nseparators\n^^^^^^^^^^\n\nto specify a separator to place between the contents of paragraphs that\nare collapsed together, use ``:separator('separator string')``.\n\nfor instance, suppose a document contains a block of code where each\nline of code is a paragraph with the style ``code block``. we can write\na style mapping to map such paragraphs to ``<pre>`` elements:\n\n::\n\n   p[style-name='code block'] => pre\n\nsince ``pre`` isn\u2019t marked as ``:fresh``, consecutive ``pre`` elements\nwill be collapsed together. however, this results in the code all being\non one line. we can use ``:separator`` to insert a newline between each\nline of code:\n\n::\n\n   p[style-name='code block'] => pre:separator('\\n')\n\nnested elements\n^^^^^^^^^^^^^^^\n\nuse ``>`` to specify nested elements. for instance, to specify ``h2``\nwithin ``div.aside``:\n\n::\n\n   div.aside > h2\n\nyou can nest elements to any depth.\n\ndonations\n---------\n\nif you\u2019d like to say thanks, feel free to `make a donation through\nko-fi <https://ko-fi.com/s6s01mg20>`__.\n\nif you use mammoth as part of your business, please consider supporting\nthe ongoing maintenance of mammoth by `making a weekly donation through\nliberapay <https://liberapay.com/mwilliamson/donate>`__.\n",
  "docs_url": null,
  "keywords": "docx word office clean html markdown md",
  "license": "bsd-2-clause",
  "name": "mammoth",
  "package_url": "https://pypi.org/project/mammoth/",
  "project_url": "https://pypi.org/project/mammoth/",
  "project_urls": {
    "Homepage": "https://github.com/mwilliamson/python-mammoth"
  },
  "release_url": "https://pypi.org/project/mammoth/1.6.0/",
  "requires_dist": [
    "cobble (<0.2,>=0.1.3)"
  ],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*",
  "summary": "convert word documents from docx to simple and clean html and markdown",
  "version": "1.6.0",
  "releases": [],
  "developers": [
    "michael_williamson",
    "mike@zwobble.org"
  ],
  "kwds": "docx_file docx markdown convert_to_markdown convert_to_html",
  "license_kwds": "bsd-2-clause",
  "libtype": "pypi",
  "id": "pypi_mammoth",
  "homepage": "https://github.com/mwilliamson/python-mammoth",
  "release_count": 75,
  "dependency_ids": [
    "pypi_cobble"
  ]
}