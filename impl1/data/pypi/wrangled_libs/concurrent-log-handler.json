{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: apache software license",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules",
    "topic :: system :: logging"
  ],
  "description": "# concurrent-log-handler\n\nthis package provides an additional log handler for python's standard logging\npackage (pep 282). this handler will write log events to a log file which is\nrotated when the log file reaches a certain size. multiple processes can\nsafely write to the same log file concurrently. rotated logs can be gzipped\nif desired. both windows and posix systems are supported. an optional threaded\nqueue logging handler is provided to perform logging in the background.\n\nthis is a fork of lowell alleman's concurrentloghandler 0.9.1 which fixes\na hanging/deadlocking problem. [see this](https://bugs.launchpad.net/python-concurrent-log-handler/+bug/1265150).\n\nsummary of other changes:\n\n* new: requires python 3.6 or higher.\n  * if you require support for python 2.7, use version\n    [0.9.22](https://github.com/preston-landers/concurrent-log-handler/releases/tag/0.9.22).\n* renamed package to `concurrent_log_handler` (abbreviated clh in this file.)\n* provide `use_gzip` option to compress rotated logs\n* support for windows\n* uses file locking to ensure exclusive write access\n  note: file locking is advisory, not a hard lock against external processes\n* more secure generation of random numbers for temporary filenames\n* change the name of the lockfile to have .__ in front of it.\n* provide a class for time-based rotation: [concurrenttimedrotatingfilehandler](#time-based-rotation-settings)\n* provide an optional queuelistener / queuehandler implementation for\n  handling log events in a background thread.\n* allow setting owner and mode permissions of rollover file on unix\n* depends on `portalocker` package, which (on windows only) depends on `pywin32`\n\n## links\n\n* [concurrent-log-handler on github](https://github.com/preston-landers/concurrent-log-handler)\n* [concurrent-log-handler on the python package index (pypi)](https://pypi.org/project/concurrent-log-handler/)\n\n## primary use cases\n\nthe main use case this is designed to support is when you have a python application that runs in\nmultiple processes, potentially on multiple hosts connected with a shared network drive, and you want\nto write all log events to a central log file and have those files rotated based on size and/or time,\ne.g. daily or hourly.\n\nhowever, this is not the only way to achieve shared logging from multiple processes. you can also\ncentralize logging by using cloud logging services like azure log monitor, logstash, etc. or you can\nimplement your own remote logging server as shown here:\n\n[logging cookbook: network](https://docs.python.org/3/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network)\n\nconcurrent-log-handler includes a queuehandler and queuelistener implementation that can be used to\nperform logging in the background asynchronously, so the thread or process making the log statement doesn't have\nto wait for its completion. see [this section](#simple-example). using that example code, each process still\nlocks and writes the file separately, so there is no centralized writer. you could also write code to use\nqueuehandler and queuelistener to queue up log events within each process to be sent to a central server,\ninstead of clh's model where each process locks and writes to the log file.\n\n### time-based rotation\n\nthe main `concurrentrotatingfilehandler` class supports size-based rotation only.\nin addition, a `concurrenttimedrotatingfilehandler` class is provided that supports both time-based\nand size-based rotation. by default, it does hourly time-based rotation and no size rotation.\nsee [this section](#time-based-rotation-settings) for more details.\n\n## instructions and usage\n\n### installation\n\nyou can download and install the package with `pip` using the following command:\n\n    pip install concurrent-log-handler\n\nthis will also install the portalocker module, which on windows in turn depends on pywin32.\n\nif installing from source, use the following command:\n\n    python setup.py install\n\n### developer setup\n\nif you plan to modify the code, you should follow this procedure:\n\n* clone the repository\n* create a virtual environment (`venv`) and activate it.\n* install the package in editable mode with the [dev] option: `pip install -e .[dev]`\n\n* run the tests:  `tox` or run `pytest` directly.\n\n  or manually run a single pass of the stress test with specific options:\n\n```shell\npython tests/stresstest.py --help\npython tests/stresstest.py --gzip --num-processes 12 --log-calls=5000\n```\n\n* to build a python \"wheel\" for distribution, use the following:\n\n```shell\npython setup.py clean --all build sdist bdist_wheel\n# copy the .whl file from under the \"dist\" folder\n# or upload with twine:\npip install twine\ntwine upload dist/concurrent-log-handler-0.9.23.tar.gz dist/concurrent_log_handler-0.9.23-py3-none-any.whl\n```\n\n### important requirements\n\nconcurrent log handler (clh) is designed to allow multiple processes to write to the same\nlogfile in a concurrent manner. it is important that each process involved must follow\nthese requirements:\n\n* you can't serialize a handler instance and reuse it in another process. this means you cannot, for\n  example, pass a clh handler instance from parent process to child process using\n  the `multiprocessing` package in spawn mode (or similar techniques that use serialized objects).\n  each child process must initialize its own clh instance.\n\n* when using the `multiprocessing` module in \"spawn\" (non-fork) mode, each child process must create\n  its own instance of the handler (`concurrentrotatingfilehandler`). the child target function\n  should call code that initializes a new clh instance.\n\n  * this requirement does not apply to threads within a given process. different threads within a\n    process can use the same clh instance. thread locking is handled automatically.\n\n  * this also does not apply to `fork()` based child processes such as gunicorn --preload.\n    child processes of a fork() call should be able to inherit the clh object instance.\n\n  * this limitation exists because the clh object can't be serialized, passed over a network or\n    pipe, and reconstituted at the other end.\n\n* it is important that every process or thread writing to a given logfile must all use the same\n  settings, especially related to file rotation. also do not attempt to mix different handler\n  classes writing to the same file, e.g. do not also use a `rotatingfilehandler` on the same file.\n\n* special attention may need to be paid when the log file being written to resides on a network\n  shared drive or a cloud synced folder (dropbox, google drive, etc.). whether the multiprocess\n  advisory lock technique (via portalocker) works in these folders may depend on the details of\n  your configuration.\n\n  note that a `lock_file_directory` setting (kwarg) now exists (as of v0.9.21) which lets you\n  place the lockfile at a different location from the main logfile. this might solve problems\n  related to trying to lock files in network shares or cloud folders (dropbox, google drive, etc.)\n  however, if multiple hosts are writing to the same shared logfile, they must also have access\n  to the same lock file.\n\n  alternatively, you may be able to set your cloud sync software to ignore all `.lock` files.\n\n* a separate handler instance is needed for each individual log file. for instance, if your app\n  writes to two different log files you will need to set up two clh instances per process.\n\n### simple example\n\nhere is a simple direct usage example:\n\n```python\nfrom logging import getlogger, info\nfrom concurrent_log_handler import concurrentrotatingfilehandler\nimport os\n\nlog = getlogger(__name__)\n# use an absolute path to prevent file rotation trouble.\nlogfile = os.path.abspath(\"mylogfile.log\")\n# rotate log after reaching 512k, keep 5 old copies.\nrotatehandler = concurrentrotatingfilehandler(logfile, \"a\", 512 * 1024, 5)\nlog.addhandler(rotatehandler)\nlog.setlevel(info)\n\nlog.info(\"here is a very exciting log message, just for you\")\n```\n\nsee also the file [src/example.py](src/example.py) for a configuration and usage example.\nthis shows both the standard non-threaded non-async usage, and the use of the `asyncio`\nbackground logging feature. under that option, when your program makes a logging statement,\nit is added to a background queue and may not be written immediately and synchronously. this\nqueue can span multiple processes using `multiprocessing` or `concurrent.futures`, and spanning\nmultiple hosts works due to the use of file locking on the log file. note that with this async\nlogging feature, currently there is no way for the caller to know when the logging statement\ncompleted (no \"promise\" or \"future\" object is returned).\n\n[queuehandler](https://docs.python.org/3/library/logging.handlers.html#queuehandler)\n\n### configuration\n\nto use this module from a logging config file, use a handler entry like this:\n\n```ini\n[handler_hand01]\nclass = handlers.concurrentrotatingfilehandler\nlevel = notset\nformatter = form01\nargs = (\"rotating.log\", \"a\")\nkwargs = {'backupcount': 5, 'maxbytes': 1048576, 'use_gzip': true}\n```\n\nthat sets the files to be rotated at about 10 mb, and to keep the last 5 rotations.\nit also turns on gzip compression for rotated files.\n\nplease note that python 3.7 and higher accepts keyword arguments (kwargs) in a logging\nconfig file, but earlier versions of python only accept positional args.\n\nnote: you must have an `import concurrent_log_handler` before you call fileconfig(). for\nmore information see python docs on [log file formats](https://docs.python.org/3/library/logging.config.html#logging-config-fileformat)\n\n### limitations\n\nthe size-based rotation limit (`maxbytes`) is not strict. the files may become slightly\nlarger than `maxbytes`. how much larger depends on the size of the log message being\nwritten when the rollover occurs.\n\nby contrast, the base `rotatingloghandler` class tries to ensure that the log file is\nalways kept under `maxbytes` taking into account the size of the current log message being\nwritten. this limitation may be changed in the future.\n\n### recommended settings\n\nfor best performance, avoid setting the `backupcount` (number of rollover files to keep) too\nhigh. what counts as \"too high\" is situational, but a good rule of thumb might be to keep\naround a maximum of 20 rollover files. if necessary, increase the `maxbytes` so that each\nfile can hold more. too many rollover files can slow down the rollover process due to the\nmass file renames, and the rollover occurs while the file lock is held for the main logfile.\n\nhow big to allow each file to grow (`maxbytes`) is up to your needs, but generally a value of\n10 mb (1048576) to 100 mb (1048576) is reasonable.\n\ngzip compression is turned off by default. if enabled it will reduce the storage needed for rotated\nfiles, at the cost of some minimal cpu overhead. use of the background logging queue shown below\ncan help offload the cost of logging to another thread.\n\nsometimes you may need to place the lock file at a different location from the main log\nfile. a `lock_file_directory` setting (kwarg) now exists (as of v0.9.21) which lets you\nplace the lockfile at a different location. this can often solve problems related to trying\nto lock files in cloud folders (dropbox, google drive, onedrive, etc.) however, in\norder for this to work, each process writing to the log must have access to the same\nlock file location, even if they are running on different hosts.\n\nyou can set the `namer` attribute of the handler to customize the naming of the rotated files,\nin line with the `baserotatinghandler` class. see the python docs for \n[more details](https://docs.python.org/3.11/library/logging.handlers.html#logging.handlers.baserotatinghandler.namer).\n\n### line endings\n\nby default, the logfile will have line endings appropriate to the platform. on windows\nthe line endings will be crlf ('\\r\\n') and on unix/mac they will be lf ('\\n').\n\nit is possible to force another line ending format by using the newline and terminator\narguments.\n\nthe following would force windows-style crlf line endings on unix:\n\n    kwargs={'newline': '', 'terminator': '\\r\\n'}\n\nthe following would force unix-style lf line endings on windows:\n\n    kwargs={'newline': '', 'terminator': '\\n'}\n\n### time-based rotation settings\n\nan alternative class `concurrenttimedrotatingfilehandler` is also provided which supports\ntime-based rotation, defaulting to hourly. like the main class, it uses advisory file\nlocking to both ensure that only one process/thread is writing to the log file at a time,\nand to coordinate the rollover time between processes.\n\nby default, it has `maxbytes` set to 0, which means that it will not rotate based on file size,\nbut it is possible to set `maxbytes` to a value to limit the size of each file in addition\nto the time-based rotation. when files are rotated based on size, they may have an additional\nnumeric suffix like `.1` added to the filename. note that like with the main clh class,\nthe file size limits are *not* strictly adhered to.\n\nall the same settings are available for this class as for the main class, including\n`maxbytes`, `use_gzip`, `lock_file_directory`, `newline`, and `terminator`. however,\nthe ordering of the arguments is different, so it's recommended to use keyword arguments\nwhen using or configuring this class. the arguments shared with `timedrotatingfilehandler`\nare in the same order as the base class, and the extra clh arguments come after that,\nalthough not in the exact same order due to some overlap.\n\nfor configuration, see the [configuration section](#configuration) above, but substitute in\n`class=handlers.concurrenttimedrotatingfilehandler` and other appropriate settings\nlike `when` and `interval`. see the python docs for `timedrotatingfilehandler` for  \n[more details](https://docs.python.org/3.11/library/logging.handlers.html#logging.handlers.timedrotatingfilehandler).\n\n### background logging queue\n\nto use the background logging queue, you must call this code at some point in your\napp after it sets up logging configuration. please read the doc string in the\nfile `concurrent_log_handler/queue.py` for more details. this requires python 3.\nsee also [src/example.py](src/example.py).\n\n```python\nfrom concurrent_log_handler.queue import setup_logging_queues\n\n# convert all configured loggers to use a background thread\nsetup_logging_queues()\n```\n\nthis module is designed to function well in a multi-threaded or multi-processes\nconcurrent environment. however, all writers to a given log file should be using\nthe same class and the *same settings* at the same time, otherwise unexpected\nbehavior may result during file rotation.\n\nthis may mean that if you change the logging settings at any point you may need to\nrestart your app service so that all processes are using the same settings at the same time.\n\n## other usage details\n\nthe `concurrentrotatingfilehandler` class is a drop-in replacement for\npython's standard log handler `rotatingfilehandler`. this module uses file\nlocking so that multiple processes can concurrently log to a single file without\ndropping or clobbering log events. this module provides a file rotation scheme\nlike with `rotatingfilehandler`. extra care is taken to ensure that logs\ncan be safely rotated before the rotation process is started. (this module works\naround the file rename issue with `rotatingfilehandler` on windows, where a\nrotation failure means that all subsequent log events are dropped).\n\nthis module attempts to preserve log records at all cost. this means that log\nfiles will grow larger than the specified maximum (rotation) size. so if disk\nspace is tight, you may want to stick with `rotatingfilehandler`, which will\nstrictly adhere to the maximum file size.\n\nimportant:\n\nif you have multiple instances of a script (or multiple scripts) all running at\nthe same time and writing to the same log file, then *all* of the scripts should\nbe using `concurrentrotatingfilehandler`. you should not attempt to mix\nand match `rotatingfilehandler` and `concurrentrotatingfilehandler`.\nthe file locking is advisory only - it is respected by other concurrent log handler\ninstances, but does not protect against outside processes (or different python logging\nfile handlers) from writing to a log file in use.\n\n## changelog\n\nsee [changelog.md](changelog.md)\n\n## contributors\n\nthe original version was written by lowell alleman.\n\nother contributors are listed in [contributors.md](contributors.md).\n\n## license\n\nsee the [license file](license)\n",
  "docs_url": null,
  "keywords": "queuehandler,queuelistener,linux,logging,portalocker,rotate,unix,windows",
  "license": "",
  "name": "concurrent-log-handler",
  "package_url": "https://pypi.org/project/concurrent-log-handler/",
  "project_url": "https://pypi.org/project/concurrent-log-handler/",
  "project_urls": {
    "Homepage": "https://github.com/Preston-Landers/concurrent-log-handler"
  },
  "release_url": "https://pypi.org/project/concurrent-log-handler/0.9.25/",
  "requires_dist": [
    "portalocker>=1.6.0"
  ],
  "requires_python": ">=3.6",
  "summary": "rotatingfilehandler replacement with concurrency, gzip and windows support",
  "version": "0.9.25",
  "releases": [],
  "developers": [
    "planders@utexas.edu"
  ],
  "kwds": "concurrent_log_handler concurrentloghandler setup_logging_queues concurrentrotatingfilehandler concurrenttimedrotatingfilehandler",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_concurrent_log_handler",
  "homepage": "",
  "release_count": 22,
  "dependency_ids": [
    "pypi_portalocker"
  ]
}