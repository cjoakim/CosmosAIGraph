{
  "classifiers": [
    "development status :: 2 - pre-alpha",
    "operating system :: os independent",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "# typing-utils\n\nbackport python3.8+ typing utils &amp; issubtype &amp; more\n\n- [install](#install)\n- [api](#api)\n    - [issubtype](#issubtype)\n    - [get_origin](#get_origin)\n    - [get_args](#get_args)\n    - [get_type_hints](#get_type_hints)\n\n[![python 3.6](https://github.com/bojiang/typing_utils/workflows/python%203.6/badge.svg)](https://github.com/bojiang/typing_utils/actions/workflows/py36.yml)\n[![python 3.7](https://github.com/bojiang/typing_utils/workflows/python%203.7/badge.svg)](https://github.com/bojiang/typing_utils/actions/workflows/py37.yml)\n[![python 3.8](https://github.com/bojiang/typing_utils/workflows/python%203.8/badge.svg)](https://github.com/bojiang/typing_utils/actions/workflows/py38.yml)\n[![python 3.9](https://github.com/bojiang/typing_utils/workflows/python%203.9/badge.svg)](https://github.com/bojiang/typing_utils/actions/workflows/py39.yml)\n\n## install\n\n``` bash\n    pip install typing_utils\n```\n\n\n## api\n\n- [issubtype](#issubtype)\n- [get_origin](#get_origin)\n- [get_args](#get_args)\n- [get_type_hints](#get_type_hints)\n\n\n### issubtype\n\ncheck that the left argument is a subtype of the right.\n\nfor unions, check if the type arguments of the left is a subset of the right.\nalso works for nested types including forwardrefs.\n\nexamples:\n\n```python\n    from typing_utils import issubtype\n\n    issubtype(typing.list, typing.any) == true\n    issubtype(list, list) == true\n    issubtype(list, typing.list) == true\n    issubtype(list, typing.sequence) == true\n    issubtype(typing.list[int], list) == true\n    issubtype(typing.list[typing.list], list) == true\n    issubtype(list, typing.list[int]) == false\n    issubtype(list, typing.union[typing.tuple, typing.set]) == false\n    issubtype(typing.list[typing.list], typing.list[typing.sequence]) == true\n    json = typing.union[\n        int, float, bool, str, none, typing.sequence[\"json\"],\n        typing.mapping[str, \"json\"]\n    ]\n    issubtype(str, json, forward_refs={'json': json}) == true\n    issubtype(typing.dict[str, str], json, forward_refs={'json': json}) == true\n    issubtype(typing.dict[str, bytes], json, forward_refs={'json': json}) == false\n```\n\n\n### get_origin\n\nget the unsubscripted version of a type.\n\nthis supports generic types, callable, tuple, union, literal, final and classvar.\nreturn none for unsupported types.\n\nexamples:\n\n```python\n    from typing_utils import get_origin\n\n    get_origin(literal[42]) is literal\n    get_origin(int) is none\n    get_origin(classvar[int]) is classvar\n    get_origin(generic) is generic\n    get_origin(generic[t]) is generic\n    get_origin(union[t, int]) is union\n    get_origin(list[tuple[t, t]][int]) == list\n```\n\n\n### get_args\n\nget type arguments with all substitutions performed.\n\nfor unions, basic simplifications used by union constructor are performed.\n\nexamples:\n\n```python\n    from typing_utils import get_args\n\n    get_args(dict[str, int]) == (str, int)\n    get_args(int) == ()\n    get_args(union[int, union[t, int], str][int]) == (int, str)\n    get_args(union[int, tuple[t, int]][str]) == (int, tuple[str, int])\n    get_args(callable[[], t][int]) == ([], int)\n```\n\n\n### get_type_hints\n\nreturn type hints for an object.\n\n\nthis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals, and if necessary\nadds optional[t] if a default value equal to none is set.\n\nthe argument may be a module, class, method, or function. the annotations\nare returned as a dictionary. for classes, annotations include also\ninherited members.\n\ntypeerror is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nbeware -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  the\nsearch order is locals first, then globals.\n\n- if no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  if the object does not appear\n  to have globals, an empty dictionary is used.\n\n- if one dict argument is passed, it is used for both globals and\n  locals.\n\n- if two dict arguments are passed, they specify globals and\n  locals, respectively.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license 2.0",
  "name": "typing-utils",
  "package_url": "https://pypi.org/project/typing-utils/",
  "project_url": "https://pypi.org/project/typing-utils/",
  "project_urls": {
    "Homepage": "https://github.com/bojiang/typing_utils"
  },
  "release_url": "https://pypi.org/project/typing-utils/0.1.0/",
  "requires_dist": [
    "pytest ; extra == 'test'"
  ],
  "requires_python": ">=3.6.1",
  "summary": "utils to inspect python type annotations",
  "version": "0.1.0",
  "releases": [],
  "developers": [
    "bojiang",
    "bojiang_@outlook.com"
  ],
  "kwds": "typing_utils get_type_hints python3 workflows py36",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_typing_utils",
  "homepage": "https://github.com/bojiang/typing_utils",
  "release_count": 4,
  "dependency_ids": [
    "pypi_pytest"
  ]
}