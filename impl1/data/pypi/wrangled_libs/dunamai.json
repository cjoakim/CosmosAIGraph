{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: end users/desktop",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "\n# dunamai\ndunamai is a python 3.5+ library and command line tool for producing dynamic,\nstandards-compliant version strings, derived from tags in your version\ncontrol system. this facilitates uniquely identifying nightly or per-commit\nbuilds in continuous integration and releasing new versions of your software\nsimply by creating a tag.\n\ndunamai is also available as a [github action](https://github.com/marketplace/actions/run-dunamai).\n\n## features\n* version control system support:\n  * [git](https://git-scm.com) (2.7.0+ is recommended, but versions as old as 1.8.2.3 will work with some reduced functionality)\n  * [mercurial](https://www.mercurial-scm.org)\n  * [darcs](http://darcs.net)\n  * [subversion](https://subversion.apache.org)\n  * [bazaar](https://bazaar.canonical.com/en)\n  * [fossil](https://www.fossil-scm.org/home/doc/trunk/www/index.wiki)\n  * [pijul](https://pijul.org)\n* version styles:\n  * [pep 440](https://www.python.org/dev/peps/pep-0440)\n  * [semantic versioning](https://semver.org)\n  * [haskell package versioning policy](https://pvp.haskell.org)\n  * custom output formats\n* can be used for projects written in any programming language.\n  for python, this means you do not need a setup.py.\n\n## usage\n### installation\n```\npip install dunamai\n```\n\n### cli\n```console\n# suppose you are on commit g29045e8, 7 commits after the v0.2.0 tag.\n\n# auto-detect the version control system and generate a version:\n$ dunamai from any\n0.2.0.post7.dev0+g29045e8\n\n# or use an explicit vcs and style:\n$ dunamai from git --no-metadata --style semver\n0.2.0-post.7\n\n# custom formats:\n$ dunamai from any --format \"v{base}+{distance}.{commit}\"\nv0.2.0+7.g29045e8\n\n# if you'd prefer to frame the version in terms of progress toward the next\n# release rather than distance from the latest one, you can bump it:\n$ dunamai from any --bump\n0.2.1.dev7+g29045e8\n\n# validation of custom formats:\n$ dunamai from any --format \"v{base}\" --style pep440\nversion 'v0.2.0' does not conform to the pep 440 style\n\n# validate your own freeform versions:\n$ dunamai check 0.01.0 --style semver\nversion '0.01.0' does not conform to the semantic versioning style\n\n# more info:\n$ dunamai --help\n$ dunamai from --help\n$ dunamai from git --help\n```\n\n### library\n\n```python\nfrom dunamai import version, style\n\n# let's say you're on commit g644252b, which is tagged as v0.1.0.\nversion = version.from_git()\nassert version.serialize() == \"0.1.0\"\n\n# let's say there was a v0.1.0rc5 tag 44 commits ago\n# and you have some uncommitted changes.\nversion = version.from_any_vcs()\nassert version.serialize() == \"0.1.0rc5.post44.dev0+g644252b\"\nassert version.serialize(metadata=false) == \"0.1.0rc5.post44.dev0\"\nassert version.serialize(dirty=true) == \"0.1.0rc5.post44.dev0+g644252b.dirty\"\nassert version.serialize(style=style.semver) == \"0.1.0-rc.5.post.44+g644252b\"\n```\n\nthe `serialize()` method gives you an opinionated, pep 440-compliant default\nthat ensures that versions for untagged commits are compatible with pip's\n`--pre` flag. the individual parts of the version are also available for you\nto use and inspect as you please:\n\n```python\nassert version.base == \"0.1.0\"\nassert version.stage == \"rc\"\nassert version.revision == 5\nassert version.distance == 44\nassert version.commit == \"g644252b\"\nassert version.dirty is true\n\n# available if the latest tag includes metadata, like v0.1.0+linux:\nassert version.tagged_metadata == \"linux\"\n```\n\n### tips\nby default, the \"v\" prefix on the tag is required, unless you specify\na custom tag pattern. you can either write a regular expression:\n\n```console\n$ dunamai from any --pattern \"(?p<base>\\d+\\.\\d+\\.\\d+)\"\n```\n\n```python\nfrom dunamai import version\n\nversion = version.from_any_vcs(pattern=r\"(?p<base>\\d+\\.\\d+\\.\\d+)\")\n```\n\n...or use a named preset:\n\n```console\n$ dunamai from any --pattern default-unprefixed\n```\n\n```python\nfrom dunamai import version, pattern\n\nversion = version.from_any_vcs(pattern=pattern.defaultunprefixed)\n```\n\n### vcs archives\nsometimes, you may only have access to an archive of a repository (e.g., a zip file) without the full history.\ndunamai can still detect a version in some of these cases:\n\n* for git, you can configure `git archive` to produce a file with some metadata for dunamai.\n\n  add a `.git_archival.json` file to the root of your repository with this content:\n  ```\n  {\n    \"hash-full\": \"$format:%h$\",\n    \"hash-short\": \"$format:%h$\",\n    \"timestamp\": \"$format:%ci$\",\n    \"refs\": \"$format:%d$\",\n    \"describe\": \"$format:%(describe:tags=true,match=v[0-9]*)$\"\n  }\n  ```\n\n  add this line to your `.gitattributes` file.\n  if you don't already have this file, add it to the root of your repository:\n  ```\n  .git_archival.json  export-subst\n  ```\n\n* for mercurial, dunamai will detect and use an `.hg_archival.txt` file created by `hg archive`.\n  it will also recognize `.hgtags` if present.\n\n### custom formats\nhere are the available substitutions for custom formats. if you have a tag like\n`v9!0.1.2-beta.3+other`, then:\n\n* `{base}` = `0.1.2`\n* `{stage}` = `beta`\n* `{revision}` = `3`\n* `{distance}` is the number of commits since the last\n* `{commit}` is the commit hash (defaults to short form, unless you use `--full-commit`)\n* `{dirty}` expands to either \"dirty\" or \"clean\" if you have uncommitted modified files\n* `{tagged_metadata}` = `other`\n* `{epoch}` = `9`\n* `{branch}` = `feature/foo`\n* `{branch_escaped}` = `featurefoo`\n* `{timestamp}` is in the format `yyyymmddhhmmss` as utc\n\nif you specify a substitution, its value will always be included in the output.\nfor conditional formatting, you can do something like this (bash):\n\n```bash\ndistance=$(dunamai from any --format \"{distance}\")\nif [ \"$distance\" = \"0\" ]; then\n    dunamai from any --format \"v{base}\"\nelse\n    dunamai from any --format \"v{base}+{distance}.{dirty}\"\nfi\n```\n\n## comparison to versioneer\n[versioneer](https://github.com/warner/python-versioneer) is another great\nlibrary for dynamic versions, but there are some design decisions that\nprompted the creation of dunamai as an alternative:\n\n* versioneer requires a setup.py file to exist, or else `versioneer install`\n  will fail, rendering it incompatible with non-setuptools-based projects\n  such as those using poetry or flit. dunamai can be used regardless of the\n  project's build system.\n* versioneer has a cli that generates python code which needs to be committed\n  into your repository, whereas dunamai is just a normal importable library\n  with an optional cli to help statically include your version string.\n* versioneer produces the version as an opaque string, whereas dunamai provides\n  a version class with discrete parts that can then be inspected and serialized\n  separately.\n* versioneer provides customizability through a config file, whereas dunamai\n  aims to offer customizability through its library api and cli for both\n  scripting support and use in other libraries.\n\n## integration\n* setting a `__version__` statically:\n\n  ```console\n  $ echo \"__version__ = '$(dunamai from any)'\" > your_library/_version.py\n  ```\n  ```python\n  # your_library/__init__.py\n  from your_library._version import __version__\n  ```\n\n  or dynamically (but dunamai becomes a runtime dependency):\n\n  ```python\n  # your_library/__init__.py\n  import dunamai as _dunamai\n  __version__ = _dunamai.get_version(\"your-library\", third_choice=_dunamai.version.from_any_vcs).serialize()\n  ```\n\n* setup.py (no install-time dependency on dunamai as long as you use wheels):\n\n  ```python\n  from setuptools import setup\n  from dunamai import version\n\n  setup(\n      name=\"your-library\",\n      version=version.from_any_vcs().serialize(),\n  )\n  ```\n\n  or you could use a static inclusion approach as in the prior example.\n\n* [poetry](https://poetry.eustace.io):\n\n  ```console\n  $ poetry version $(dunamai from any)\n  ```\n\n  or you can use the [poetry-dynamic-versioning](https://github.com/mtkennerly/poetry-dynamic-versioning) plugin.\n\n## other notes\n* dunamai needs access to the full version history to find tags and compute distance.\n  be careful if your ci system does a shallow clone by default.\n\n  * for github workflows, invoke `actions/checkout@v3` with `fetch-depth: 0`.\n  * for gitlab pipelines, set the `git_depth` variable to 0.\n\n  for git, you can also avoid doing a full clone by specifying a remote branch for tags\n  (e.g., `--tag-branch remotes/origin/master`).\n* when using git, remember that lightweight tags do not store their creation time.\n  therefore, if a commit has multiple lightweight tags,\n  we cannot reliably determine which one should be considered the newest.\n  the solution is to use annotated tags instead.\n* when using git, the initial commit must **not** be both tagged and empty\n  (i.e., created with `--allow-empty`). this is related to a reporting issue\n  in git. for more info, [click here](https://github.com/mtkennerly/dunamai/issues/14).\n",
  "docs_url": null,
  "keywords": "version,versioning,dynamic",
  "license": "mit",
  "name": "dunamai",
  "package_url": "https://pypi.org/project/dunamai/",
  "project_url": "https://pypi.org/project/dunamai/",
  "project_urls": {
    "Homepage": "https://github.com/mtkennerly/dunamai",
    "Repository": "https://github.com/mtkennerly/dunamai"
  },
  "release_url": "https://pypi.org/project/dunamai/1.19.0/",
  "requires_dist": [
    "packaging (>=20.9)",
    "importlib-metadata (>=1.6.0) ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.5,<4.0",
  "summary": "dynamic version generation",
  "version": "1.19.0",
  "releases": [],
  "developers": [
    "matthew_t",
    "mtkennerly@gmail.com"
  ],
  "kwds": "versioning versioneer versions get_version git_archival",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_dunamai",
  "homepage": "https://github.com/mtkennerly/dunamai",
  "release_count": 44,
  "dependency_ids": [
    "pypi_importlib_metadata",
    "pypi_packaging"
  ]
}