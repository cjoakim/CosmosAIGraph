{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# aws glue construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthis module is part of the [aws cloud development kit](https://github.com/aws/aws-cdk) project.\n\n## job\n\na `job` encapsulates a script that connects to data sources, processes them, and then writes output to a data target.\n\nthere are 3 types of jobs supported by aws glue: spark etl, spark streaming, and python shell jobs.\n\nthe `glue.jobexecutable` allows you to specify the type of job, the language to use and the code assets required by the job.\n\n`glue.code` allows you to refer to the different code assets required by the job, either from an existing s3 location or from a local file path.\n\n### spark jobs\n\nthese jobs run in an apache spark environment managed by aws glue.\n\n#### etl jobs\n\nan etl job processes data in batches using apache spark.\n\n```python\n# bucket: s3.bucket\n\nglue.job(self, \"scalasparketljob\",\n    executable=glue.jobexecutable.scala_etl(\n        glue_version=glue.glueversion.v2_0,\n        script=glue.code.from_bucket(bucket, \"src/com/example/helloworld.scala\"),\n        class_name=\"com.example.helloworld\",\n        extra_jars=[glue.code.from_bucket(bucket, \"jars/helloworld.jar\")]\n    ),\n    description=\"an example scala etl job\"\n)\n```\n\n#### streaming jobs\n\na streaming job is similar to an etl job, except that it performs etl on data streams. it uses the apache spark structured streaming framework. some spark job features are not available to streaming etl jobs.\n\n```python\nglue.job(self, \"pythonsparkstreamingjob\",\n    executable=glue.jobexecutable.python_streaming(\n        glue_version=glue.glueversion.v2_0,\n        python_version=glue.pythonversion.three,\n        script=glue.code.from_asset(path.join(__dirname, \"job-script/hello_world.py\"))\n    ),\n    description=\"an example python streaming job\"\n)\n```\n\n### python shell jobs\n\na python shell job runs python scripts as a shell and supports a python version that depends on the aws glue version you are using.\nthis can be used to schedule and run tasks that don't require an apache spark environment.\n\n```python\n# bucket: s3.bucket\n\nglue.job(self, \"pythonshelljob\",\n    executable=glue.jobexecutable.python_shell(\n        glue_version=glue.glueversion.v1_0,\n        python_version=glue.pythonversion.three,\n        script=glue.code.from_bucket(bucket, \"script.py\")\n    ),\n    description=\"an example python shell job\"\n)\n```\n\nsee [documentation](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) for more information on adding jobs in glue.\n\n## connection\n\na `connection` allows glue jobs, crawlers and development endpoints to access certain types of data stores. for example, to create a network connection to connect to a data source within a vpc:\n\n```python\n# security_group: ec2.securitygroup\n# subnet: ec2.subnet\n\nglue.connection(self, \"myconnection\",\n    type=glue.connectiontype.network,\n    # the security groups granting aws glue inbound access to the data source within the vpc\n    security_groups=[security_group],\n    # the vpc subnet which contains the data source\n    subnet=subnet\n)\n```\n\nif you need to use a connection type that doesn't exist as a static member on `connectiontype`, you can instantiate a `connectiontype` object, e.g: `new glue.connectiontype('new_type')`.\n\nsee [adding a connection to your data store](https://docs.aws.amazon.com/glue/latest/dg/populate-add-connection.html) and [connection structure](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-catalog-connections.html#aws-glue-api-catalog-connections-connection) documentation for more information on the supported data stores and their configurations.\n\n## securityconfiguration\n\na `securityconfiguration` is a set of security properties that can be used by aws glue to encrypt data at rest.\n\n```python\nglue.securityconfiguration(self, \"mysecurityconfiguration\",\n    security_configuration_name=\"name\",\n    cloud_watch_encryption=glue.cloudwatchencryption(\n        mode=glue.cloudwatchencryptionmode.kms\n    ),\n    job_bookmarks_encryption=glue.jobbookmarksencryption(\n        mode=glue.jobbookmarksencryptionmode.client_side_kms\n    ),\n    s3_encryption=glue.s3encryption(\n        mode=glue.s3encryptionmode.kms\n    )\n)\n```\n\nby default, a shared kms key is created for use with the encryption configurations that require one. you can also supply your own key for each encryption config, for example, for cloudwatch encryption:\n\n```python\n# key: kms.key\n\nglue.securityconfiguration(self, \"mysecurityconfiguration\",\n    security_configuration_name=\"name\",\n    cloud_watch_encryption=glue.cloudwatchencryption(\n        mode=glue.cloudwatchencryptionmode.kms,\n        kms_key=key\n    )\n)\n```\n\nsee [documentation](https://docs.aws.amazon.com/glue/latest/dg/encryption-security-configuration.html) for more info for glue encrypting data written by crawlers, jobs, and development endpoints.\n\n## database\n\na `database` is a logical grouping of `tables` in the glue catalog.\n\n```python\nglue.database(self, \"mydatabase\",\n    database_name=\"my_database\"\n)\n```\n\n## table\n\na glue table describes a table of data in s3: its structure (column names and types), location of data (s3 objects with a common prefix in a s3 bucket), and format for the files (json, avro, parquet, etc.):\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    ), glue.column(\n        name=\"col2\",\n        type=glue.schema.array(glue.schema.string),\n        comment=\"col2 is an array of strings\"\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\nby default, a s3 bucket will be created to store the table's data but you can manually pass the `bucket` and `s3prefix`:\n\n```python\n# my_bucket: s3.bucket\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    bucket=my_bucket,\n    s3_prefix=\"my-table/\",\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\nby default, an s3 bucket will be created to store the table's data and stored in the bucket root. you can also manually pass the `bucket` and `s3prefix`:\n\n### partition keys\n\nto improve query performance, a table can specify `partitionkeys` on which data is stored and queried separately. for example, you might partition a table by `year` and `month` to optimize queries based on a time window:\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    partition_keys=[glue.column(\n        name=\"year\",\n        type=glue.schema.small_int\n    ), glue.column(\n        name=\"month\",\n        type=glue.schema.small_int\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\n### partition indexes\n\nanother way to improve query performance is to specify partition indexes. if no partition indexes are\npresent on the table, aws glue loads all partitions of the table and filters the loaded partitions using\nthe query expression. the query takes more time to run as the number of partitions increase. with an\nindex, the query will try to fetch a subset of the partitions instead of loading all partitions of the\ntable.\n\nthe keys of a partition index must be a subset of the partition keys of the table. you can have a\nmaximum of 3 partition indexes per table. to specify a partition index, you can use the `partitionindexes`\nproperty:\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    partition_keys=[glue.column(\n        name=\"year\",\n        type=glue.schema.small_int\n    ), glue.column(\n        name=\"month\",\n        type=glue.schema.small_int\n    )],\n    partition_indexes=[glue.partitionindex(\n        index_name=\"my-index\",  # optional\n        key_names=[\"year\"]\n    )],  # supply up to 3 indexes\n    data_format=glue.dataformat.json\n)\n```\n\nalternatively, you can call the `addpartitionindex()` function on a table:\n\n```python\n# my_table: glue.table\n\nmy_table.add_partition_index(\n    index_name=\"my-index\",\n    key_names=[\"year\"]\n)\n```\n\n## [encryption](https://docs.aws.amazon.com/athena/latest/ug/encryption.html)\n\nyou can enable encryption on a table's data:\n\n* `unencrypted` - files are not encrypted. the default encryption setting.\n* [s3managed](https://docs.aws.amazon.com/amazons3/latest/dev/usingserversideencryption.html) - server side encryption (`sse-s3`) with an amazon s3-managed key.\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.s3_managed,\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\n* [kms](https://docs.aws.amazon.com/amazons3/latest/dev/usingkmsencryption.html) - server-side encryption (`sse-kms`) with an aws kms key managed by the account owner.\n\n```python\n# my_database: glue.database\n\n# kms key is created automatically\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.kms,\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n\n# with an explicit kms key\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.kms,\n    encryption_key=kms.key(self, \"mykey\"),\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\n* [kmsmanaged](https://docs.aws.amazon.com/amazons3/latest/dev/usingkmsencryption.html) - server-side encryption (`sse-kms`), like `kms`, except with an aws kms key managed by the aws key management service.\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.kms_managed,\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\n* [clientsidekms](https://docs.aws.amazon.com/amazons3/latest/dev/usingclientsideencryption.html#client-side-encryption-kms-managed-master-key-intro) - client-side encryption (`cse-kms`) with an aws kms key managed by the account owner.\n\n```python\n# my_database: glue.database\n\n# kms key is created automatically\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.client_side_kms,\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n\n# with an explicit kms key\nglue.table(self, \"mytable\",\n    encryption=glue.tableencryption.client_side_kms,\n    encryption_key=kms.key(self, \"mykey\"),\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    columns=[glue.column(\n        name=\"col1\",\n        type=glue.schema.string\n    )],\n    data_format=glue.dataformat.json\n)\n```\n\n*note: you cannot provide a `bucket` when creating the `table` if you wish to use server-side encryption (`kms`, `kms_managed` or `s3_managed`)*.\n\n## types\n\na table's schema is a collection of columns, each of which have a `name` and a `type`. types are recursive structures, consisting of primitive and complex types:\n\n```python\n# my_database: glue.database\n\nglue.table(self, \"mytable\",\n    columns=[glue.column(\n        name=\"primitive_column\",\n        type=glue.schema.string\n    ), glue.column(\n        name=\"array_column\",\n        type=glue.schema.array(glue.schema.integer),\n        comment=\"array<integer>\"\n    ), glue.column(\n        name=\"map_column\",\n        type=glue.schema.map(glue.schema.string, glue.schema.timestamp),\n        comment=\"map<string,string>\"\n    ), glue.column(\n        name=\"struct_column\",\n        type=glue.schema.struct([\n            name=\"nested_column\",\n            type=glue.schema.date,\n            comment=\"nested comment\"\n        ]),\n        comment=\"struct<nested_column:date comment 'nested comment'>\"\n    )],\n    # ...\n    database=my_database,\n    table_name=\"my_table\",\n    data_format=glue.dataformat.json\n)\n```\n\n### primitives\n\n#### numeric\n\n| name      \t| type     \t| comments                                                                                                          |\n|-----------\t|----------\t|------------------------------------------------------------------------------------------------------------------\t|\n| float     \t| constant \t| a 32-bit single-precision floating point number                                                                   |\n| integer   \t| constant \t| a 32-bit signed value in two's complement format, with a minimum value of -2^31 and a maximum value of 2^31-1 \t|\n| double    \t| constant \t| a 64-bit double-precision floating point number                                                                   |\n| big_int   \t| constant \t| a 64-bit signed integer in two\u2019s complement format, with a minimum value of -2^63 and a maximum value of 2^63 -1  |\n| small_int \t| constant \t| a 16-bit signed integer in two\u2019s complement format, with a minimum value of -2^15 and a maximum value of 2^15-1   |\n| tiny_int  \t| constant \t| a 8-bit signed integer in two\u2019s complement format, with a minimum value of -2^7 and a maximum value of 2^7-1      |\n\n#### date and time\n\n| name      \t| type     \t| comments                                                                                                                                                                \t|\n|-----------\t|----------\t|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------\t|\n| date      \t| constant \t| a date in unix format, such as yyyy-mm-dd.                                                                                                                              \t|\n| timestamp \t| constant \t| date and time instant in the unix format, such as yyyy-mm-dd hh:mm:ss[.f...]. for example, timestamp '2008-09-15 03:04:05.324'. this format uses the session time zone. \t|\n\n#### string\n\n| name                                       \t| type     \t| comments                                                                                                                                                                                          \t|\n|--------------------------------------------\t|----------\t|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\t|\n| string                                     \t| constant \t| a string literal enclosed in single or double quotes                                                                                                                                              \t|\n| decimal(precision: number, scale?: number) \t| function \t| `precision` is the total number of digits. `scale` (optional) is the number of digits in fractional part with a default of 0. for example, use these type definitions: decimal(11,5), decimal(15) \t|\n| char(length: number)                       \t| function \t| fixed length character data, with a specified length between 1 and 255, such as char(10)                                                                                                          \t|\n| varchar(length: number)                    \t| function \t| variable length character data, with a specified length between 1 and 65535, such as varchar(10)                                                                                                  \t|\n\n#### miscellaneous\n\n| name    \t| type     \t| comments                      \t|\n|---------\t|----------\t|-------------------------------\t|\n| boolean \t| constant \t| values are `true` and `false` \t|\n| binary  \t| constant \t| value is in binary            \t|\n\n### complex\n\n| name                                \t| type     \t| comments                                                          \t|\n|-------------------------------------\t|----------\t|-------------------------------------------------------------------\t|\n| array(itemtype: type)               \t| function \t| an array of some other type                                       \t|\n| map(keytype: type, valuetype: type) \t| function \t| a map of some primitive key type to any value type                \t|\n| struct(collumns: column[])          \t| function \t| nested structure containing individually named and typed collumns \t|\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-glue",
  "package_url": "https://pypi.org/project/aws-cdk.aws-glue/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-glue/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-glue/1.204.0/",
  "requires_dist": [
    "aws-cdk.assets (==1.204.0)",
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-ec2 (==1.204.0)",
    "aws-cdk.aws-events (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-kms (==1.204.0)",
    "aws-cdk.aws-logs (==1.204.0)",
    "aws-cdk.aws-s3-assets (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.custom-resources (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::glue",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws glue_version cdk glueversion amazons3",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_glue",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.assets",
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_ec2",
    "pypi_aws_cdk.aws_events",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_kms",
    "pypi_aws_cdk.aws_logs",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.aws_s3_assets",
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.custom_resources",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}