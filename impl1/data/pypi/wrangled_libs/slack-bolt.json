{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "# bolt ![bolt logo](docs/assets/bolt-logo.svg) for python\n\n[![python version][python-version]][pypi-url]\n[![pypi package][pypi-image]][pypi-url]\n[![codecov][codecov-image]][codecov-url]\n\na python framework to build slack apps in a flash with the latest platform features. read the [getting started guide](https://slack.dev/bolt-python/tutorial/getting-started) and look at our [code examples](https://github.com/slackapi/bolt-python/tree/main/examples) to learn how to build apps using bolt. the python module documents are available [here](https://slack.dev/bolt-python/api-docs/slack_bolt/).\n\n## setup\n\n```bash\n# python 3.6+ required\npython -m venv .venv\nsource .venv/bin/activate\n\npip install -u pip\npip install slack_bolt\n```\n\n## creating an app\n\ncreate a bolt for python app by calling a constructor, which is a top-level export. if you'd prefer, you can create an [async app](#creating-an-async-app).\n\n```python\nimport logging\nlogging.basicconfig(level=logging.debug)\n\nfrom slack_bolt import app\n\n# export slack_signing_secret=***\n# export slack_bot_token=xoxb-***\napp = app()\n\n# add functionality here\n\nif __name__ == \"__main__\":\n    app.start(3000)  # post http://localhost:3000/slack/events\n```\n\n## running an app\n\n```bash\nexport slack_signing_secret=***\nexport slack_bot_token=xoxb-***\npython app.py\n\n# in another terminal\nngrok http 3000\n```\n\n## running a socket mode app\n\nif you use [socket mode](https://api.slack.com/socket-mode) for running your app, `socketmodehandler` is available for it.\n\n```python\nimport os\nfrom slack_bolt import app\nfrom slack_bolt.adapter.socket_mode import socketmodehandler\n\n# install the slack app and get xoxb- token in advance\napp = app(token=os.environ[\"slack_bot_token\"])\n\n# add functionality here\n\nif __name__ == \"__main__\":\n    # create an app-level token with connections:write scope\n    handler = socketmodehandler(app, os.environ[\"slack_app_token\"])\n    handler.start()\n```\n\nrun the app this way:\n\n```bash\nexport slack_app_token=xapp-***\nexport slack_bot_token=xoxb-***\npython app.py\n\n# slack_signing_secret is not required\n# running ngrok is not required\n```\n\n## listening for events\n\napps typically react to a collection of incoming events, which can correspond to [events api events](https://api.slack.com/events-api), [actions](https://api.slack.com/interactivity/components), [shortcuts](https://api.slack.com/interactivity/shortcuts), [slash commands](https://api.slack.com/interactivity/slash-commands) or [options requests](https://api.slack.com/reference/block-kit/block-elements#external_select). for each type of\nrequest, there's a method to build a listener function.\n\n```python\n# listen for an event from the events api\napp.event(event_type)(fn)\n\n# convenience method to listen to only `message` events using a string or re.pattern\napp.message([pattern ,])(fn)\n\n# listen for an action from a block kit element (buttons, select menus, date pickers, etc)\napp.action(action_id)(fn)\n\n# listen for dialog submissions\napp.action({\"callback_id\": callbackid})(fn)\n\n# listen for a global or message shortcuts\napp.shortcut(callback_id)(fn)\n\n# listen for slash commands\napp.command(command_name)(fn)\n\n# listen for view_submission modal events\napp.view(callback_id)(fn)\n\n# listen for options requests (from select menus with an external data source)\napp.options(action_id)(fn)\n```\n\nthe recommended way to use these methods are decorators:\n\n```python\n@app.event(event_type)\ndef handle_event(event):\n    pass\n```\n\n## making things happen\n\nmost of the app's functionality will be inside listener functions (the `fn` parameters above). these functions are called with a set of arguments, each of which can be used in any order. if you'd like to access arguments off of a single object, you can use `args`, an [`slack_bolt.kwargs_injection.args`](https://github.com/slackapi/bolt-python/blob/main/slack_bolt/kwargs_injection/args.py) instance that contains all available arguments for that event.\n\n| argument  | description  |\n| :---: | :--- |\n| `body` | dictionary that contains the entire body of the request (superset of `payload`). some accessory data is only available outside of the payload (such as `trigger_id` and `authorizations`).\n| `payload` | contents of the incoming event. the payload structure depends on the listener. for example, for an events api event, `payload` will be the [event type structure](https://api.slack.com/events-api#event_type_structure). for a block action, it will be the action from within the `actions` list. the `payload` dictionary is also accessible via the alias corresponding to the listener (`message`, `event`, `action`, `shortcut`, `view`, `command`, or `options`). for example, if you were building a `message()` listener, you could use the `payload` and `message` arguments interchangably. **an easy way to understand what's in a payload is to log it**. |\n| `context` | event context. this dictionary contains data about the event and app, such as the `botid`. middleware can add additional context before the event is passed to listeners.\n| `ack` | function that **must** be called to acknowledge that your app received the incoming event. `ack` exists for all actions, shortcuts, view submissions, slash command and options requests. `ack` returns a promise that resolves when complete. read more in [acknowledging events](https://slack.dev/bolt-python/concepts#acknowledge).\n| `respond` | utility function that responds to incoming events **if** it contains a `response_url` (shortcuts, actions, and slash commands).\n| `say` | utility function to send a message to the channel associated with the incoming event. this argument is only available when the listener is triggered for events that contain a `channel_id` (the most common being `message` events). `say` accepts simple strings (for plain-text messages) and dictionaries (for messages containing blocks).\n| `client` | web api client that uses the token associated with the event. for single-workspace installations, the token is provided to the constructor. for multi-workspace installations, the token is returned by using [the oauth library](https://slack.dev/bolt-python/concepts#authenticating-oauth), or manually using the `authorize` function.\n| `logger` | the built-in [`logging.logger`](https://docs.python.org/3/library/logging.html) instance you can use in middleware/listeners.\n\n## creating an async app\n\nif you'd prefer to build your app with [asyncio](https://docs.python.org/3/library/asyncio.html), you can import the [aiohttp](https://docs.aiohttp.org/en/stable/) library and call the `asyncapp` constructor. within async apps, you can use the async/await pattern.\n\n```bash\n# python 3.6+ required\npython -m venv .venv\nsource .venv/bin/activate\n\npip install -u pip\n# aiohttp is required\npip install slack_bolt aiohttp\n```\n\nin async apps, all middleware/listeners must be async functions. when calling utility methods (like `ack` and `say`) within these functions, it's required to use the `await` keyword.\n\n```python\n# import the async app instead of the regular one\nfrom slack_bolt.async_app import asyncapp\n\napp = asyncapp()\n\n@app.event(\"app_mention\")\nasync def event_test(body, say, logger):\n    logger.info(body)\n    await say(\"what's up?\")\n\n@app.command(\"/hello-bolt-python\")\nasync def command(ack, body, respond):\n    await ack()\n    await respond(f\"hi <@{body['user_id']}>!\")\n\nif __name__ == \"__main__\":\n    app.start(3000)\n```\n\nif you want to use another async web framework (e.g., sanic, fastapi, starlette), take a look at the built-in adapters and their examples.\n\n* [the bolt app examples](https://github.com/slackapi/bolt-python/tree/main/examples)\n* [the built-in adapters](https://github.com/slackapi/bolt-python/tree/main/slack_bolt/adapter)\napps can be run the same way as the syncronous example above. if you'd prefer another async web framework (e.g., sanic, fastapi, starlette), take a look at [the built-in adapters](https://github.com/slackapi/bolt-python/tree/main/slack_bolt/adapter) and their corresponding [examples](https://github.com/slackapi/bolt-python/tree/main/examples).\n\n## getting help\n\n[the documentation](https://slack.dev/bolt-python) has more information on basic and advanced concepts for bolt for python. also, all the python module documents of this library are available [here](https://slack.dev/bolt-python/api-docs/slack_bolt/).\n\nif you otherwise get stuck, we're here to help. the following are the best ways to get assistance working through your issue:\n\n  * [issue tracker](http://github.com/slackapi/bolt-python/issues) for questions, bug reports, feature requests, and general discussion related to bolt for python. try searching for an existing issue before creating a new one.\n  * [email](mailto:support@slack.com) our developer support team: `support@slack.com`\n\n\n[pypi-image]: https://badge.fury.io/py/slack-bolt.svg\n[pypi-url]: https://pypi.org/project/slack-bolt/\n[codecov-image]: https://codecov.io/gh/slackapi/bolt-python/branch/main/graph/badge.svg\n[codecov-url]: https://codecov.io/gh/slackapi/bolt-python\n[python-version]: https://img.shields.io/pypi/pyversions/slack-bolt.svg\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "slack-bolt",
  "package_url": "https://pypi.org/project/slack-bolt/",
  "project_url": "https://pypi.org/project/slack-bolt/",
  "project_urls": {
    "Homepage": "https://github.com/slackapi/bolt-python"
  },
  "release_url": "https://pypi.org/project/slack-bolt/1.18.1/",
  "requires_dist": [
    "slack-sdk (<4,>=3.25.0)",
    "boto3 (<=2) ; extra == 'adapter'",
    "bottle (<1,>=0.12) ; extra == 'adapter'",
    "chalice (<2,>=1.28) ; extra == 'adapter'",
    "CherryPy (<19,>=18) ; extra == 'adapter'",
    "Django (<5,>=3) ; extra == 'adapter'",
    "falcon (<4,>=2) ; extra == 'adapter'",
    "fastapi (<1,>=0.70.0) ; extra == 'adapter'",
    "Flask (<3,>=1) ; extra == 'adapter'",
    "Werkzeug (<3,>=2) ; extra == 'adapter'",
    "pyramid (<3,>=1) ; extra == 'adapter'",
    "sanic (<23,>=22) ; extra == 'adapter'",
    "starlette (<1,>=0.14) ; extra == 'adapter'",
    "tornado (<7,>=6) ; extra == 'adapter'",
    "uvicorn (<1) ; extra == 'adapter'",
    "gunicorn (<21,>=20) ; extra == 'adapter'",
    "websocket-client (<2,>=1.2.3) ; extra == 'adapter'",
    "moto (<4,>=3) ; extra == 'adapter_testing'",
    "docker (<6,>=5) ; extra == 'adapter_testing'",
    "boddle (<0.3,>=0.2) ; extra == 'adapter_testing'",
    "Flask (<2,>=1) ; extra == 'adapter_testing'",
    "Werkzeug (<2,>=1) ; extra == 'adapter_testing'",
    "sanic-testing (>=0.7) ; extra == 'adapter_testing'",
    "requests (<3,>=2) ; extra == 'adapter_testing'",
    "aiohttp (<4,>=3) ; extra == 'async'",
    "websockets (<11,>=10) ; extra == 'async'",
    "pytest (<7,>=6.2.5) ; extra == 'testing'",
    "pytest-cov (<4,>=3) ; extra == 'testing'",
    "Flask-Sockets (<1,>=0.2) ; extra == 'testing'",
    "Werkzeug (<2,>=1) ; extra == 'testing'",
    "itsdangerous (==2.0.1) ; extra == 'testing'",
    "Jinja2 (==3.0.3) ; extra == 'testing'",
    "black (==22.8.0) ; extra == 'testing'",
    "click (<=8.0.4) ; extra == 'testing'",
    "pytest-asyncio (<1,>=0.18.2) ; extra == 'testing'",
    "aiohttp (<4,>=3) ; extra == 'testing'",
    "pytest (<7,>=6.2.5) ; extra == 'testing_without_asyncio'",
    "pytest-cov (<4,>=3) ; extra == 'testing_without_asyncio'",
    "Flask-Sockets (<1,>=0.2) ; extra == 'testing_without_asyncio'",
    "Werkzeug (<2,>=1) ; extra == 'testing_without_asyncio'",
    "itsdangerous (==2.0.1) ; extra == 'testing_without_asyncio'",
    "Jinja2 (==3.0.3) ; extra == 'testing_without_asyncio'",
    "black (==22.8.0) ; extra == 'testing_without_asyncio'",
    "click (<=8.0.4) ; extra == 'testing_without_asyncio'"
  ],
  "requires_python": ">=3.6",
  "summary": "the bolt framework for python",
  "version": "1.18.1",
  "releases": [],
  "developers": [
    "opensource@slack.com",
    "slack_technologies"
  ],
  "kwds": "slack_bolt slack_app_token slack_bot_token slack slack_signing_secret",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_slack_bolt",
  "homepage": "https://github.com/slackapi/bolt-python",
  "release_count": 112,
  "dependency_ids": [
    "pypi_aiohttp",
    "pypi_black",
    "pypi_boddle",
    "pypi_boto3",
    "pypi_bottle",
    "pypi_chalice",
    "pypi_cherrypy",
    "pypi_click",
    "pypi_django",
    "pypi_docker",
    "pypi_falcon",
    "pypi_fastapi",
    "pypi_flask",
    "pypi_flask_sockets",
    "pypi_gunicorn",
    "pypi_itsdangerous",
    "pypi_jinja2",
    "pypi_moto",
    "pypi_pyramid",
    "pypi_pytest",
    "pypi_pytest_asyncio",
    "pypi_pytest_cov",
    "pypi_requests",
    "pypi_sanic",
    "pypi_sanic_testing",
    "pypi_slack_sdk",
    "pypi_starlette",
    "pypi_tornado",
    "pypi_uvicorn",
    "pypi_websocket_client",
    "pypi_websockets",
    "pypi_werkzeug"
  ]
}