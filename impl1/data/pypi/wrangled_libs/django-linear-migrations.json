{
  "classifiers": [
    "development status :: 5 - production/stable",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "framework :: django :: 4.1",
    "framework :: django :: 4.2",
    "framework :: django :: 5.0",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "typing :: typed"
  ],
  "description": "========================\ndjango-linear-migrations\n========================\n\n.. image:: https://img.shields.io/github/actions/workflow/status/adamchainz/django-linear-migrations/main.yml?branch=main&style=for-the-badge\n   :target: https://github.com/adamchainz/django-linear-migrations/actions?workflow=ci\n\n.. image:: https://img.shields.io/badge/coverage-100%25-success?style=for-the-badge\n   :target: https://github.com/adamchainz/django-linear-migrations/actions?workflow=ci\n\n.. image:: https://img.shields.io/pypi/v/django-linear-migrations.svg?style=for-the-badge\n   :target: https://pypi.org/project/django-linear-migrations/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge\n   :target: https://github.com/psf/black\n\n.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logocolor=white&style=for-the-badge\n   :target: https://github.com/pre-commit/pre-commit\n   :alt: pre-commit\n\nensure your migration history is linear.\n\nfor a bit of background, see the `introductory blog post <https://adamj.eu/tech/2020/12/10/introducing-django-linear-migrations/>`__.\n\nrequirements\n============\n\npython 3.8 to 3.12 supported.\n\ndjango 3.2 to 5.0 supported.\n\n----\n\n**want to work smarter and faster?**\ncheck out my book `boost your django dx <https://adamchainz.gumroad.com/l/byddx>`__ which covers django-linear-migrations and many other tools to improve your development experience.\n\n----\n\ninstallation\n============\n\n**first,** install with pip:\n\n.. code-block:: bash\n\n    python -m pip install django-linear-migrations\n\n**second,** add the app to your ``installed_apps`` setting:\n\n.. code-block:: python\n\n    installed_apps = [\n        ...,\n        \"django_linear_migrations\",\n        ...,\n    ]\n\nthe app relies on overriding the built-in ``makemigrations`` command.\n*if your project has a custom* ``makemigrations`` *command,* ensure the app containing your custom command is **above** ``django_linear_migrations``, and that your command subclasses its ``command`` class:\n\n.. code-block:: python\n\n    # myapp/management/commands/makemigrations.py\n    from django_linear_migrations.management.commands.makemigrations import (\n        command as basecommand,\n    )\n\n\n    class command(basecommand):\n        ...\n\n**third,** check the automatic detection of first-party apps.\nrun this command:\n\n.. code-block:: sh\n\n    python manage.py create_max_migration_files --dry-run\n\nthis command is for creating ``max_migration.txt`` files (more on which later) - in dry run mode it lists the apps it would make such files for.\nit tries to automatically detect which apps are first-party, i.e. belong to your project.\nthe automatic detection checks the path of app\u2019s code to see if is within a virtualenv, but this detection can sometimes fail, for example on editable packages installed with ``-e``.\nif you see any apps listed that *aren\u2019t* part of your project, define the list of first-party apps\u2019 labels in a ``first_party_apps`` setting that you combine into ``installed_apps``:\n\n.. code-block:: python\n\n    first_party_apps = []\n\n    installed_apps = first_party_apps + [\"django_linear_migrations\", ...]\n\n(note: django recommends you always list first-party apps first in your project so they can override things in third-party and contrib apps.)\n\n**fourth,** create the ``max_migration.txt`` files for your first-party apps by re-running the command without the dry run flag:\n\n.. code-block:: sh\n\n    python manage.py create_max_migration_files\n\nin the future, when you add a new app to your project, you\u2019ll need to create its ``max_migration.txt`` file.\nadd the new app to ``installed_apps`` or ``first_party_apps`` as appropriate, then rerun the creation command for the new app by specifying its label:\n\n.. code-block:: sh\n\n    python manage.py create_max_migration_files my_new_app\n\nusage\n=====\n\ndjango-linear-migrations helps you work on django projects where several branches adding migrations may be in progress at any time.\nit enforces that your apps have a *linear* migration history, avoiding merge migrations and the problems they can cause from migrations running in different orders.\nit does this by making ``makemigrations`` record the name of the latest migration in per-app ``max_migration.txt`` files.\nthese files will then cause a merge conflicts in your source control tool (git, mercurial, etc.) in the case of migrations being developed in parallel.\nthe first merged migration for an app will prevent the second from being merged, without addressing the conflict.\nthe included ``rebase_migration`` command can help automatically such conflicts.\n\nsystem checks\n-------------\n\ndjango-linear-migrations comes with several system checks that verify that your ``max_migration.txt`` files are in sync.\nthese are:\n\n* ``dlm.e001``: ``<app_label>``'s max_migration.txt does not exist.\n* ``dlm.e002``: ``<app_label>``'s max_migration.txt contains multiple lines.\n* ``dlm.e003``: ``<app_label>``'s max_migration.txt points to non-existent migration '``<bad_migration_name>``'.\n* ``dlm.e004``: ``<app_label>``'s max_migration.txt contains '``<max_migration_name>``', but the latest migration is '``<real_max_migration_name>``'.\n* ``dlm.e005``: conflicting migrations detected; multiple leaf nodes in the migration graph: ``<conflicting_migrations>``\n\n``create_max_migration_files`` command\n--------------------------------------\n\n.. code-block:: sh\n\n    python manage.py create_max_migration_files [app_label [app_label ...]]\n\nthis management command creates ``max_migration.txt`` files for all first party apps, or the given labels.\nit\u2019s used in initial installation of django-linear-migrations, and for recreating.\n\npass the ``--dry-run`` flag to only list the ``max_migration.txt`` files that would be created.\n\npass the ``--recreate`` flag to re-create files that already exist.\nthis may be useful after altering migrations with merges or manually.\n\n``rebase_migration`` command\n----------------------------\n\nthis management command can help you fix migration conflicts.\nfollowing a conflicted \u201crebase\u201d operation in git, run it with the name of the app to auto-fix the migrations for:\n\n.. code-block:: console\n\n    $ python manage.py rebase_migration <app_label>\n\nthe command uses the conflict information in the ``max_migration.txt`` file to determine which migration to rebase.\nit automatically detects whether a git merge or rebase operation is in progress, assuming rebase if a git repository cannot be found.\nthe command then:\n\n1. renames the migration\n2. edits it to depend on the new migration from your main branch\n3. updates ``max_migration.txt``.\n\nif black is installed, the command formats the updated migration file with it, like django\u2019s built-in migration commands do (from version 4.1+).\nsee below for some examples and caveats.\n\nnote rebasing the migration might not always be the *correct* thing to do.\nif the migrations in your main and feature branches have both affected the same models, rebasing the migration to the end may not make sense.\nhowever, such parallel changes would *normally* cause conflicts in your model files or other parts of the source code as well.\n\nworked example\n^^^^^^^^^^^^^^\n\nimagine you were working on your project's ``books`` app in a feature branch called ``titles`` and created a migration called ``0002_longer_titles``.\nmeanwhile a commit has been merged to your ``main`` branch with a *different* 2nd migration for ``books`` called ``0002_author_nicknames``.\nthanks to django-linear-migrations, the ``max_migration.txt`` file will show as conflicted between your feature and main branches.\n\nstart the fix by reversing your new migration from your local database.\nthis is necessary since it will be renamed after rebasing and seen as unapplied.\ndo this by switching to the feature branch ``titles`` migrating back to the last common migration:\n\n.. code-block:: console\n\n    $ git switch titles\n    $ python manage.py migrate books 0001\n\nthen, fetch the latest code:\n\n.. code-block:: console\n\n    $ git switch main\n    $ git pull\n    ...\n\nnext, rebase your ``titles`` branch on top of it.\nduring this process, git will detect the conflict on ``max_migration.txt``:\n\n.. code-block:: console\n\n    $ git switch titles\n    $ git rebase main\n    auto-merging books/models.py\n    conflict (content): merge conflict in books/migrations/max_migration.txt\n    error: could not apply 123456789... increase book title length\n    resolve all conflicts manually, mark them as resolved with\n    \"git add/rm <conflicted_files>\", then run \"git rebase --continue\".\n    you can instead skip this commit: run \"git rebase --skip\".\n    to abort and get back to the state before \"git rebase\", run \"git rebase --abort\".\n    could not apply 123456789... increase book title length\n\nthe contents of the ``books`` app's ``max_migration.txt`` at this point will look something like this:\n\n.. code-block:: console\n\n    $ cat books/migrations/max_migration.txt\n    <<<<<<< head\n    0002_author_nicknames\n    =======\n    0002_longer_titles\n    >>>>>>> 123456789 (increase book title length)\n\nat this point, use ``rebase_migration`` to automatically fix the ``books`` migration history:\n\n.. code-block:: console\n\n    $ python manage.py rebase_migration books\n    renamed 0002_longer_titles.py to 0003_longer_titles.py, updated its dependencies, and updated max_migration.txt.\n\nthis places the conflicted migration on the end of the migration history.\nit renames the file appropriately, modifies its ``dependencies = [...]`` declaration, and updates the migration named in ``max_migration.txt`` appropriately.\n\nafter this, you should be able to continue the rebase:\n\n.. code-block:: console\n\n    $ git add books/migrations\n    $ git rebase --continue\n\nand then migrate your local database to allow you to continue development:\n\n.. code-block:: console\n\n    $ python manage.py migrate books\n    operations to perform:\n      target specific migration: 0003_longer_titles, from books\n    running migrations:\n      applying books.0002_author_nicknames... ok\n      applying books.0003_longer_titles... ok\n\ncode formatting\n^^^^^^^^^^^^^^^\n\n``rebase_migration`` does not guarantee that its edits match your code style.\nif you use a formatter like black, you\u2019ll want to run it after applying ``rebase_migration``.\n\nif you use `pre-commit <https://pre-commit.com/>`__, note that git does not invoke hooks during rebase commits.\nyou can run it manually on changed files with ``pre-commit run``.\n\nbranches with multiple commits\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nimagine the same example as above, but your feature branch has several commits editing the migration.\nthis time, before rebasing onto the latest ``main`` branch, squash the commits in your feature branch together.\nthis way, ``rebase_migration`` can edit the migration file when the conflict occurs.\n\nyou can do this with:\n\n.. code-block:: console\n\n    $ git rebase -i --keep-base main\n\nthis will open git\u2019s `interactive mode <https://git-scm.com/docs/git-rebase#_interactive_mode>`__ file.\nedit this so that every comit after the first will be squashed, by starting each line with \u201cs\u201d.\nthen close the file, and the rebase will execute.\n\nafter this operation, you can rebase onto your latest ``main`` branch as per the previous example.\n\nbranches with multiple migrations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``rebase_migration`` does not currently support rebasing multiple migrations (in the same app).\nthis is `an open feature request <https://github.com/adamchainz/django-linear-migrations/issues/27>`__, but it is not a priority, since it\u2019s generally a good idea to restrict changes to one migration at a time.\nconsider merging your migrations into one before rebasing.\n\ninspiration\n===========\n\ni\u2019ve seen similar techniques to the one implemented by django-linear-migrations at several places, and they acted as the inspiration for putting this package together.\nmy previous client `pollen <https://pollen.co/>`__ and current client `ev.energy <https://ev.energy/>`__ both have implementations.\nthis `doordash blogpost <https://doordash.engineering/2017/05/15/tips-for-building-high-quality-django-apps-at-scale/>`__ covers a similar system that uses a single file for tracking latest migrations.\nand there's also a package called `django-migrations-git-conflicts <https://pypi.org/project/django-migrations-git-conflicts/>`__ which works fairly similarly.\n",
  "docs_url": null,
  "keywords": "django",
  "license": "mit",
  "name": "django-linear-migrations",
  "package_url": "https://pypi.org/project/django-linear-migrations/",
  "project_url": "https://pypi.org/project/django-linear-migrations/",
  "project_urls": {
    "Changelog": "https://github.com/adamchainz/django-linear-migrations/blob/main/CHANGELOG.rst",
    "Homepage": "https://github.com/adamchainz/django-linear-migrations",
    "Mastodon": "https://fosstodon.org/@adamchainz",
    "Twitter": "https://twitter.com/adamchainz"
  },
  "release_url": "https://pypi.org/project/django-linear-migrations/2.12.0/",
  "requires_dist": [
    "Django >=3.2"
  ],
  "requires_python": ">=3.8",
  "summary": "ensure your migrations are linear.",
  "version": "2.12.0",
  "releases": [],
  "developers": [
    "adam_johnson",
    "me@adamj.eu"
  ],
  "kwds": "django_linear_migrations django max_migration badge max_migration_name",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_django_linear_migrations",
  "homepage": "https://github.com/adamchainz/django-linear-migrations",
  "release_count": 25,
  "dependency_ids": [
    "pypi_django"
  ]
}