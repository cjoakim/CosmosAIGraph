{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.4",
    "programming language :: python :: 2.5",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.1",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "pytz - world timezone definitions for python\n============================================\n\n:author: stuart bishop <stuart@stuartbishop.net>\n\nintroduction\n~~~~~~~~~~~~\n\npytz brings the olson tz database into python. this library allows\naccurate and cross platform timezone calculations using python 2.4\nor higher. it also solves the issue of ambiguous times at the end\nof daylight saving time, which you can read more about in the python\nlibrary reference (``datetime.tzinfo``).\n\nalmost all of the olson timezones are supported.\n\n.. note::\n\n    projects using python 3.9 or later should be using the support\n    now included as part of the standard library, and third party\n    packages work with it such as `tzdata <https://pypi.org/project/tzdata/>`_.\n    pytz offers no advantages beyond backwards compatibility with\n    code written for earlier versions of python.\n\n.. note::\n\n    this library differs from the documented python api for\n    tzinfo implementations; if you want to create local wallclock\n    times you need to use the ``localize()`` method documented in this\n    document. in addition, if you perform date arithmetic on local\n    times that cross dst boundaries, the result may be in an incorrect\n    timezone (ie. subtract 1 minute from 2002-10-27 1:00 est and you get\n    2002-10-27 0:59 est instead of the correct 2002-10-27 1:59 edt). a\n    ``normalize()`` method is provided to correct this. unfortunately these\n    issues cannot be resolved without modifying the python datetime\n    implementation (see pep-431).\n\n\ninstallation\n~~~~~~~~~~~~\n\nthis package can either be installed using ``pip`` or from a tarball using the\nstandard python distutils.\n\nif you are installing using ``pip``, you don't need to download anything as the\nlatest version will be downloaded for you from pypi::\n\n    pip install pytz\n\nif you are installing from a tarball, run the following command as an\nadministrative user::\n\n    python setup.py install\n\n\npytz for enterprise\n~~~~~~~~~~~~~~~~~~~\n\navailable as part of the tidelift subscription.\n\nthe maintainers of pytz and thousands of other packages are working with tidelift to deliver commercial support and maintenance for the open source dependencies you use to build your applications. save time, reduce risk, and improve code health, while paying the maintainers of the exact dependencies you use. `learn more. <https://tidelift.com/subscription/pkg/pypi-pytz?utm_source=pypi-pytz&utm_medium=referral&utm_campaign=enterprise&utm_term=repo>`_.\n\n\nexample & usage\n~~~~~~~~~~~~~~~\n\nlocalized times and date arithmetic\n-----------------------------------\n\n>>> from datetime import datetime, timedelta\n>>> from pytz import timezone\n>>> import pytz\n>>> utc = pytz.utc\n>>> utc.zone\n'utc'\n>>> eastern = timezone('us/eastern')\n>>> eastern.zone\n'us/eastern'\n>>> amsterdam = timezone('europe/amsterdam')\n>>> fmt = '%y-%m-%d %h:%m:%s %z%z'\n\nthis library only supports two ways of building a localized time. the\nfirst is to use the ``localize()`` method provided by the pytz library.\nthis is used to localize a naive datetime (datetime with no timezone\ninformation):\n\n>>> loc_dt = eastern.localize(datetime(2002, 10, 27, 6, 0, 0))\n>>> print(loc_dt.strftime(fmt))\n2002-10-27 06:00:00 est-0500\n\nthe second way of building a localized time is by converting an existing\nlocalized time using the standard ``astimezone()`` method:\n\n>>> ams_dt = loc_dt.astimezone(amsterdam)\n>>> ams_dt.strftime(fmt)\n'2002-10-27 12:00:00 cet+0100'\n\nunfortunately using the tzinfo argument of the standard datetime\nconstructors ''does not work'' with pytz for many timezones.\n\n>>> datetime(2002, 10, 27, 12, 0, 0, tzinfo=amsterdam).strftime(fmt)  # /!\\ does not work this way!\n'2002-10-27 12:00:00 lmt+0018'\n\nit is safe for timezones without daylight saving transitions though, such\nas utc:\n\n>>> datetime(2002, 10, 27, 12, 0, 0, tzinfo=pytz.utc).strftime(fmt)  # /!\\ not recommended except for utc\n'2002-10-27 12:00:00 utc+0000'\n\nthe preferred way of dealing with times is to always work in utc,\nconverting to localtime only when generating output to be read\nby humans.\n\n>>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)\n>>> loc_dt = utc_dt.astimezone(eastern)\n>>> loc_dt.strftime(fmt)\n'2002-10-27 01:00:00 est-0500'\n\nthis library also allows you to do date arithmetic using local\ntimes, although it is more complicated than working in utc as you\nneed to use the ``normalize()`` method to handle daylight saving time\nand other timezone transitions. in this example, ``loc_dt`` is set\nto the instant when daylight saving time ends in the us/eastern\ntimezone.\n\n>>> before = loc_dt - timedelta(minutes=10)\n>>> before.strftime(fmt)\n'2002-10-27 00:50:00 est-0500'\n>>> eastern.normalize(before).strftime(fmt)\n'2002-10-27 01:50:00 edt-0400'\n>>> after = eastern.normalize(before + timedelta(minutes=20))\n>>> after.strftime(fmt)\n'2002-10-27 01:10:00 est-0500'\n\ncreating local times is also tricky, and the reason why working with\nlocal times is not recommended. unfortunately, you cannot just pass\na ``tzinfo`` argument when constructing a datetime (see the next\nsection for more details)\n\n>>> dt = datetime(2002, 10, 27, 1, 30, 0)\n>>> dt1 = eastern.localize(dt, is_dst=true)\n>>> dt1.strftime(fmt)\n'2002-10-27 01:30:00 edt-0400'\n>>> dt2 = eastern.localize(dt, is_dst=false)\n>>> dt2.strftime(fmt)\n'2002-10-27 01:30:00 est-0500'\n\nconverting between timezones is more easily done, using the\nstandard astimezone method.\n\n>>> utc_dt = datetime.fromtimestamp(1143408899, tz=utc)\n>>> utc_dt.strftime(fmt)\n'2006-03-26 21:34:59 utc+0000'\n>>> au_tz = timezone('australia/sydney')\n>>> au_dt = utc_dt.astimezone(au_tz)\n>>> au_dt.strftime(fmt)\n'2006-03-27 08:34:59 aedt+1100'\n>>> utc_dt2 = au_dt.astimezone(utc)\n>>> utc_dt2.strftime(fmt)\n'2006-03-26 21:34:59 utc+0000'\n>>> utc_dt == utc_dt2\ntrue\n\nyou can take shortcuts when dealing with the utc side of timezone\nconversions. ``normalize()`` and ``localize()`` are not really\nnecessary when there are no daylight saving time transitions to\ndeal with.\n\n>>> utc_dt = datetime.fromtimestamp(1143408899, tz=utc)\n>>> utc_dt.strftime(fmt)\n'2006-03-26 21:34:59 utc+0000'\n>>> au_tz = timezone('australia/sydney')\n>>> au_dt = au_tz.normalize(utc_dt.astimezone(au_tz))\n>>> au_dt.strftime(fmt)\n'2006-03-27 08:34:59 aedt+1100'\n>>> utc_dt2 = au_dt.astimezone(utc)\n>>> utc_dt2.strftime(fmt)\n'2006-03-26 21:34:59 utc+0000'\n\n\n``tzinfo`` api\n--------------\n\nthe ``tzinfo`` instances returned by the ``timezone()`` function have\nbeen extended to cope with ambiguous times by adding an ``is_dst``\nparameter to the ``utcoffset()``, ``dst()`` && ``tzname()`` methods.\n\n>>> tz = timezone('america/st_johns')\n\n>>> normal = datetime(2009, 9, 1)\n>>> ambiguous = datetime(2009, 10, 31, 23, 30)\n\nthe ``is_dst`` parameter is ignored for most timestamps. it is only used\nduring dst transition ambiguous periods to resolve that ambiguity.\n\n>>> print(tz.utcoffset(normal, is_dst=true))\n-1 day, 21:30:00\n>>> print(tz.dst(normal, is_dst=true))\n1:00:00\n>>> tz.tzname(normal, is_dst=true)\n'ndt'\n\n>>> print(tz.utcoffset(ambiguous, is_dst=true))\n-1 day, 21:30:00\n>>> print(tz.dst(ambiguous, is_dst=true))\n1:00:00\n>>> tz.tzname(ambiguous, is_dst=true)\n'ndt'\n\n>>> print(tz.utcoffset(normal, is_dst=false))\n-1 day, 21:30:00\n>>> tz.dst(normal, is_dst=false).seconds\n3600\n>>> tz.tzname(normal, is_dst=false)\n'ndt'\n\n>>> print(tz.utcoffset(ambiguous, is_dst=false))\n-1 day, 20:30:00\n>>> tz.dst(ambiguous, is_dst=false)\ndatetime.timedelta(0)\n>>> tz.tzname(ambiguous, is_dst=false)\n'nst'\n\nif ``is_dst`` is not specified, ambiguous timestamps will raise\nan ``pytz.exceptions.ambiguoustimeerror`` exception.\n\n>>> print(tz.utcoffset(normal))\n-1 day, 21:30:00\n>>> print(tz.dst(normal))\n1:00:00\n>>> tz.tzname(normal)\n'ndt'\n\n>>> import pytz.exceptions\n>>> try:\n...     tz.utcoffset(ambiguous)\n... except pytz.exceptions.ambiguoustimeerror:\n...     print('pytz.exceptions.ambiguoustimeerror: %s' % ambiguous)\npytz.exceptions.ambiguoustimeerror: 2009-10-31 23:30:00\n>>> try:\n...     tz.dst(ambiguous)\n... except pytz.exceptions.ambiguoustimeerror:\n...     print('pytz.exceptions.ambiguoustimeerror: %s' % ambiguous)\npytz.exceptions.ambiguoustimeerror: 2009-10-31 23:30:00\n>>> try:\n...     tz.tzname(ambiguous)\n... except pytz.exceptions.ambiguoustimeerror:\n...     print('pytz.exceptions.ambiguoustimeerror: %s' % ambiguous)\npytz.exceptions.ambiguoustimeerror: 2009-10-31 23:30:00\n\n\nproblems with localtime\n~~~~~~~~~~~~~~~~~~~~~~~\n\nthe major problem we have to deal with is that certain datetimes\nmay occur twice in a year. for example, in the us/eastern timezone\non the last sunday morning in october, the following sequence\nhappens:\n\n    - 01:00 edt occurs\n    - 1 hour later, instead of 2:00am the clock is turned back 1 hour\n      and 01:00 happens again (this time 01:00 est)\n\nin fact, every instant between 01:00 and 02:00 occurs twice. this means\nthat if you try and create a time in the 'us/eastern' timezone\nthe standard datetime syntax, there is no way to specify if you meant\nbefore of after the end-of-daylight-saving-time transition. using the\npytz custom syntax, the best you can do is make an educated guess:\n\n>>> loc_dt = eastern.localize(datetime(2002, 10, 27, 1, 30, 00))\n>>> loc_dt.strftime(fmt)\n'2002-10-27 01:30:00 est-0500'\n\nas you can see, the system has chosen one for you and there is a 50%\nchance of it being out by one hour. for some applications, this does\nnot matter. however, if you are trying to schedule meetings with people\nin different timezones or analyze log files it is not acceptable.\n\nthe best and simplest solution is to stick with using utc.  the pytz\npackage encourages using utc for internal timezone representation by\nincluding a special utc implementation based on the standard python\nreference implementation in the python documentation.\n\nthe utc timezone unpickles to be the same instance, and pickles to a\nsmaller size than other pytz tzinfo instances.  the utc implementation\ncan be obtained as pytz.utc, pytz.utc, or pytz.timezone('utc').\n\n>>> import pickle, pytz\n>>> dt = datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)\n>>> naive = dt.replace(tzinfo=none)\n>>> p = pickle.dumps(dt, 1)\n>>> naive_p = pickle.dumps(naive, 1)\n>>> len(p) - len(naive_p)\n17\n>>> new = pickle.loads(p)\n>>> new == dt\ntrue\n>>> new is dt\nfalse\n>>> new.tzinfo is dt.tzinfo\ntrue\n>>> pytz.utc is pytz.utc is pytz.timezone('utc')\ntrue\n\nnote that some other timezones are commonly thought of as the same (gmt,\ngreenwich, universal, etc.). the definition of utc is distinct from these\nother timezones, and they are not equivalent. for this reason, they will\nnot compare the same in python.\n\n>>> utc == pytz.timezone('gmt')\nfalse\n\nsee the section `what is utc`_, below.\n\nif you insist on working with local times, this library provides a\nfacility for constructing them unambiguously:\n\n>>> loc_dt = datetime(2002, 10, 27, 1, 30, 00)\n>>> est_dt = eastern.localize(loc_dt, is_dst=true)\n>>> edt_dt = eastern.localize(loc_dt, is_dst=false)\n>>> print(est_dt.strftime(fmt) + ' / ' + edt_dt.strftime(fmt))\n2002-10-27 01:30:00 edt-0400 / 2002-10-27 01:30:00 est-0500\n\nif you pass none as the is_dst flag to localize(), pytz will refuse to\nguess and raise exceptions if you try to build ambiguous or non-existent\ntimes.\n\nfor example, 1:30am on 27th oct 2002 happened twice in the us/eastern\ntimezone when the clocks where put back at the end of daylight saving\ntime:\n\n>>> dt = datetime(2002, 10, 27, 1, 30, 00)\n>>> try:\n...     eastern.localize(dt, is_dst=none)\n... except pytz.exceptions.ambiguoustimeerror:\n...     print('pytz.exceptions.ambiguoustimeerror: %s' % dt)\npytz.exceptions.ambiguoustimeerror: 2002-10-27 01:30:00\n\nsimilarly, 2:30am on 7th april 2002 never happened at all in the\nus/eastern timezone, as the clocks where put forward at 2:00am skipping\nthe entire hour:\n\n>>> dt = datetime(2002, 4, 7, 2, 30, 00)\n>>> try:\n...     eastern.localize(dt, is_dst=none)\n... except pytz.exceptions.nonexistenttimeerror:\n...     print('pytz.exceptions.nonexistenttimeerror: %s' % dt)\npytz.exceptions.nonexistenttimeerror: 2002-04-07 02:30:00\n\nboth of these exceptions share a common base class to make error handling\neasier:\n\n>>> isinstance(pytz.ambiguoustimeerror(), pytz.invalidtimeerror)\ntrue\n>>> isinstance(pytz.nonexistenttimeerror(), pytz.invalidtimeerror)\ntrue\n\n\na special case is where countries change their timezone definitions\nwith no daylight savings time switch. for example, in 1915 warsaw\nswitched from warsaw time to central european time with no daylight savings\ntransition. so at the stroke of midnight on august 5th 1915 the clocks\nwere wound back 24 minutes creating an ambiguous time period that cannot\nbe specified without referring to the timezone abbreviation or the\nactual utc offset. in this case midnight happened twice, neither time\nduring a daylight saving time period. pytz handles this transition by\ntreating the ambiguous period before the switch as daylight savings\ntime, and the ambiguous period after as standard time.\n\n\n>>> warsaw = pytz.timezone('europe/warsaw')\n>>> amb_dt1 = warsaw.localize(datetime(1915, 8, 4, 23, 59, 59), is_dst=true)\n>>> amb_dt1.strftime(fmt)\n'1915-08-04 23:59:59 wmt+0124'\n>>> amb_dt2 = warsaw.localize(datetime(1915, 8, 4, 23, 59, 59), is_dst=false)\n>>> amb_dt2.strftime(fmt)\n'1915-08-04 23:59:59 cet+0100'\n>>> switch_dt = warsaw.localize(datetime(1915, 8, 5, 00, 00, 00), is_dst=false)\n>>> switch_dt.strftime(fmt)\n'1915-08-05 00:00:00 cet+0100'\n>>> str(switch_dt - amb_dt1)\n'0:24:01'\n>>> str(switch_dt - amb_dt2)\n'0:00:01'\n\nthe best way of creating a time during an ambiguous time period is\nby converting from another timezone such as utc:\n\n>>> utc_dt = datetime(1915, 8, 4, 22, 36, tzinfo=pytz.utc)\n>>> utc_dt.astimezone(warsaw).strftime(fmt)\n'1915-08-04 23:36:00 cet+0100'\n\nthe standard python way of handling all these ambiguities is not to\nhandle them, such as demonstrated in this example using the us/eastern\ntimezone definition from the python documentation (note that this\nimplementation only works for dates between 1987 and 2006 - it is\nincluded for tests only!):\n\n>>> from pytz.reference import eastern # pytz.reference only for tests\n>>> dt = datetime(2002, 10, 27, 0, 30, tzinfo=eastern)\n>>> str(dt)\n'2002-10-27 00:30:00-04:00'\n>>> str(dt + timedelta(hours=1))\n'2002-10-27 01:30:00-05:00'\n>>> str(dt + timedelta(hours=2))\n'2002-10-27 02:30:00-05:00'\n>>> str(dt + timedelta(hours=3))\n'2002-10-27 03:30:00-05:00'\n\nnotice the first two results? at first glance you might think they are\ncorrect, but taking the utc offset into account you find that they are\nactually two hours appart instead of the 1 hour we asked for.\n\n>>> from pytz.reference import utc # pytz.reference only for tests\n>>> str(dt.astimezone(utc))\n'2002-10-27 04:30:00+00:00'\n>>> str((dt + timedelta(hours=1)).astimezone(utc))\n'2002-10-27 06:30:00+00:00'\n\n\ncountry information\n~~~~~~~~~~~~~~~~~~~\n\na mechanism is provided to access the timezones commonly in use\nfor a particular country, looked up using the iso 3166 country code.\nit returns a list of strings that can be used to retrieve the relevant\ntzinfo instance using ``pytz.timezone()``:\n\n>>> print(' '.join(pytz.country_timezones['nz']))\npacific/auckland pacific/chatham\n\nthe olson database comes with a iso 3166 country code to english country\nname mapping that pytz exposes as a dictionary:\n\n>>> print(pytz.country_names['nz'])\nnew zealand\n\n\nwhat is utc\n~~~~~~~~~~~\n\n'utc' is `coordinated universal time`_. it is a successor to, but distinct\nfrom, greenwich mean time (gmt) and the various definitions of universal\ntime. utc is now the worldwide standard for regulating clocks and time\nmeasurement.\n\nall other timezones are defined relative to utc, and include offsets like\nutc+0800 - hours to add or subtract from utc to derive the local time. no\ndaylight saving time occurs in utc, making it a useful timezone to perform\ndate arithmetic without worrying about the confusion and ambiguities caused\nby daylight saving time transitions, your country changing its timezone, or\nmobile computers that roam through multiple timezones.\n\n..  _coordinated universal time: https://en.wikipedia.org/wiki/coordinated_universal_time\n\n\nhelpers\n~~~~~~~\n\nthere are two lists of timezones provided.\n\n``all_timezones`` is the exhaustive list of the timezone names that can\nbe used.\n\n>>> from pytz import all_timezones\n>>> len(all_timezones) >= 500\ntrue\n>>> 'etc/greenwich' in all_timezones\ntrue\n\n``common_timezones`` is a list of useful, current timezones. it doesn't\ncontain deprecated zones or historical zones, except for a few i've\ndeemed in common usage, such as us/eastern (open a bug report if you\nthink other timezones are deserving of being included here). it is also\na sequence of strings.\n\n>>> from pytz import common_timezones\n>>> len(common_timezones) < len(all_timezones)\ntrue\n>>> 'etc/greenwich' in common_timezones\nfalse\n>>> 'australia/melbourne' in common_timezones\ntrue\n>>> 'us/eastern' in common_timezones\ntrue\n>>> 'canada/eastern' in common_timezones\ntrue\n>>> 'australia/yancowinna' in all_timezones\ntrue\n>>> 'australia/yancowinna' in common_timezones\nfalse\n\nboth ``common_timezones`` and ``all_timezones`` are alphabetically\nsorted:\n\n>>> common_timezones_dupe = common_timezones[:]\n>>> common_timezones_dupe.sort()\n>>> common_timezones == common_timezones_dupe\ntrue\n>>> all_timezones_dupe = all_timezones[:]\n>>> all_timezones_dupe.sort()\n>>> all_timezones == all_timezones_dupe\ntrue\n\n``all_timezones`` and ``common_timezones`` are also available as sets.\n\n>>> from pytz import all_timezones_set, common_timezones_set\n>>> 'us/eastern' in all_timezones_set\ntrue\n>>> 'us/eastern' in common_timezones_set\ntrue\n>>> 'australia/victoria' in common_timezones_set\nfalse\n\nyou can also retrieve lists of timezones used by particular countries\nusing the ``country_timezones()`` function. it requires an iso-3166\ntwo letter country code.\n\n>>> from pytz import country_timezones\n>>> print(' '.join(country_timezones('ch')))\neurope/zurich\n>>> print(' '.join(country_timezones('ch')))\neurope/zurich\n\n\ninternationalization - i18n/l10n\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\npytz is an interface to the iana database, which uses ascii names. the `unicode  consortium's unicode locales (cldr) <http://cldr.unicode.org>`_\nproject provides translations. python packages such as\n`babel <https://babel.pocoo.org/en/latest/api/dates.html#timezone-functionality>`_\nand thomas khyn's `l18n <https://pypi.org/project/l18n/>`_ package can be used\nto access these translations from python.\n\n\nlicense\n~~~~~~~\n\nmit license.\n\nthis code is also available as part of zope 3 under the zope public\nlicense,  version 2.1 (zpl).\n\ni'm happy to relicense this code if necessary for inclusion in other\nopen source projects.\n\n\nlatest versions\n~~~~~~~~~~~~~~~\n\nthis package will be updated after releases of the olson timezone\ndatabase.  the latest version can be downloaded from the `python package\nindex <https://pypi.org/project/pytz/>`_.  the code that is used\nto generate this distribution is hosted on github and available\nusing git::\n\n    git clone https://github.com/stub42/pytz.git\n\nannouncements of new releases are made on\n`launchpad <https://launchpad.net/pytz>`_, and the\n`atom feed <http://feeds.launchpad.net/pytz/announcements.atom>`_\nhosted there.\n\n\nbugs, feature requests & patches\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nbugs should be reported on `github <https://github.com/stub42/pytz/issues>`_.\nfeature requests are unlikely to be considered, and efforts instead directed\nto timezone support now built into python or packages that work with it.\n\n\nsecurity issues\n~~~~~~~~~~~~~~~\n\nreports about security issues can be made via `tidelift <https://tidelift.com/security>`_.\n\n\nissues & limitations\n~~~~~~~~~~~~~~~~~~~~\n\n- this project is in maintenance mode. projects using python 3.9 or later\n  are best served by using the timezone functionaly now included in core\n  python and packages that work with it such as `tzdata <https://pypi.org/project/tzdata/>`_.\n\n- offsets from utc are rounded to the nearest whole minute, so timezones\n  such as europe/amsterdam pre 1937 will be up to 30 seconds out. this\n  was a limitation of the python datetime library.\n\n- if you think a timezone definition is incorrect, i probably can't fix\n  it. pytz is a direct translation of the olson timezone database, and\n  changes to the timezone definitions need to be made to this source.\n  if you find errors they should be reported to the time zone mailing\n  list, linked from http://www.iana.org/time-zones.\n\n\nfurther reading\n~~~~~~~~~~~~~~~\n\nmore info than you want to know about timezones:\nhttps://data.iana.org/time-zones/tz-link.html\n\n\ncontact\n~~~~~~~\n\nstuart bishop <stuart@stuartbishop.net>\n\n\n",
  "docs_url": "https://pythonhosted.org/pytz/",
  "keywords": "timezone,tzinfo,datetime,olson,time",
  "license": "mit",
  "name": "pytz",
  "package_url": "https://pypi.org/project/pytz/",
  "project_url": "https://pypi.org/project/pytz/",
  "project_urls": {
    "Download": "https://pypi.org/project/pytz/",
    "Homepage": "http://pythonhosted.org/pytz"
  },
  "release_url": "https://pypi.org/project/pytz/2023.3.post1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "world timezone definitions, modern and historical",
  "version": "2023.3.post1",
  "releases": [],
  "developers": [
    "stuart@stuartbishop.net",
    "stuart_bishop"
  ],
  "kwds": "common_timezones country_timezones all_timezones all_timezones_set common_timezones_set",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytz",
  "homepage": "http://pythonhosted.org/pytz",
  "release_count": 113,
  "dependency_ids": []
}