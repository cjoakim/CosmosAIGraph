{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: information technology",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules",
    "topic :: software development :: testing",
    "topic :: utilities"
  ],
  "description": ".. contents:: **allpairspy** forked from `bayandin/allpairs <https://github.com/bayandin/allpairs>`__\n   :backlinks: top\n   :depth: 2\n\n.. image:: https://badge.fury.io/py/allpairspy.svg\n    :target: https://badge.fury.io/py/allpairspy\n    :alt: pypi package version\n\n.. image:: https://img.shields.io/pypi/pyversions/allpairspy.svg\n    :target: https://pypi.org/project/allpairspy\n    :alt: supported python versions\n\n.. image:: https://github.com/thombashi/allpairspy/workflows/tests/badge.svg\n    :target: https://github.com/thombashi/allpairspy/actions?query=workflow%3atests\n    :alt: linux/macos/windows ci status\n\n.. image:: https://coveralls.io/repos/github/thombashi/allpairspy/badge.svg?branch=master\n    :target: https://coveralls.io/github/thombashi/allpairspy?branch=master\n    :alt: test coverage\n\n\nallpairs test combinations generator\n------------------------------------------------\nallpairs is an open source test combinations generator written in\npython, developed and maintained by metacommunications engineering.\nthe generator allows one to create a set of tests using \"pairwise\ncombinations\" method, reducing a number of combinations of variables\ninto a lesser set that covers most situations.\n\nfor more info on pairwise testing see http://www.pairwise.org.\n\n\nfeatures\n--------\n* produces good enough dataset.\n* pythonic, iterator-style enumeration interface.\n* allows to filter out \"invalid\" combinations during search for the next combination.\n* goes beyond pairs! if/when required can generate n-wise combinations.\n\n\nget started\n---------------\n\nbasic usage\n==================\n:sample code:\n    .. code:: python\n\n        from allpairspy import allpairs\n\n        parameters = [\n            [\"brand x\", \"brand y\"],\n            [\"98\", \"nt\", \"2000\", \"xp\"],\n            [\"internal\", \"modem\"],\n            [\"salaried\", \"hourly\", \"part-time\", \"contr.\"],\n            [6, 10, 15, 30, 60],\n        ]\n\n        print(\"pairwise:\")\n        for i, pairs in enumerate(allpairs(parameters)):\n            print(\"{:2d}: {}\".format(i, pairs))\n\n:output:\n    .. code::\n\n        pairwise:\n         0: ['brand x', '98', 'internal', 'salaried', 6]\n         1: ['brand y', 'nt', 'modem', 'hourly', 6]\n         2: ['brand y', '2000', 'internal', 'part-time', 10]\n         3: ['brand x', 'xp', 'modem', 'contr.', 10]\n         4: ['brand x', '2000', 'modem', 'part-time', 15]\n         5: ['brand y', 'xp', 'internal', 'hourly', 15]\n         6: ['brand y', '98', 'modem', 'salaried', 30]\n         7: ['brand x', 'nt', 'internal', 'contr.', 30]\n         8: ['brand x', '98', 'internal', 'hourly', 60]\n         9: ['brand y', '2000', 'modem', 'contr.', 60]\n        10: ['brand y', 'nt', 'modem', 'salaried', 60]\n        11: ['brand y', 'xp', 'modem', 'part-time', 60]\n        12: ['brand y', '2000', 'modem', 'hourly', 30]\n        13: ['brand y', '98', 'modem', 'contr.', 15]\n        14: ['brand y', 'xp', 'modem', 'salaried', 15]\n        15: ['brand y', 'nt', 'modem', 'part-time', 15]\n        16: ['brand y', 'xp', 'modem', 'part-time', 30]\n        17: ['brand y', '98', 'modem', 'part-time', 6]\n        18: ['brand y', '2000', 'modem', 'salaried', 6]\n        19: ['brand y', '98', 'modem', 'salaried', 10]\n        20: ['brand y', 'xp', 'modem', 'contr.', 6]\n        21: ['brand y', 'nt', 'modem', 'hourly', 10]\n\n\nfiltering\n==================\nyou can restrict pairs by setting a filtering function to ``filter_func`` at\n``allpairs`` constructor.\n\n:sample code:\n    .. code:: python\n\n        from allpairspy import allpairs\n\n        def is_valid_combination(row):\n            \"\"\"\n            this is a filtering function. filtering functions should return true\n            if combination is valid and false otherwise.\n\n            test row that is passed here can be incomplete.\n            to prevent search for unnecessary items filtering function\n            is executed with found subset of data to validate it.\n            \"\"\"\n\n            n = len(row)\n\n            if n > 1:\n                # brand y does not support windows 98\n                if \"98\" == row[1] and \"brand y\" == row[0]:\n                    return false\n\n                # brand x does not work with xp\n                if \"xp\" == row[1] and \"brand x\" == row[0]:\n                    return false\n\n            if n > 4:\n                # contractors are billed in 30 min increments\n                if \"contr.\" == row[3] and row[4] < 30:\n                    return false\n\n            return true\n\n        parameters = [\n            [\"brand x\", \"brand y\"],\n            [\"98\", \"nt\", \"2000\", \"xp\"],\n            [\"internal\", \"modem\"],\n            [\"salaried\", \"hourly\", \"part-time\", \"contr.\"],\n            [6, 10, 15, 30, 60]\n        ]\n\n        print(\"pairwise:\")\n        for i, pairs in enumerate(allpairs(parameters, filter_func=is_valid_combination)):\n            print(\"{:2d}: {}\".format(i, pairs))\n\n:output:\n    .. code::\n\n        pairwise:\n         0: ['brand x', '98', 'internal', 'salaried', 6]\n         1: ['brand y', 'nt', 'modem', 'hourly', 6]\n         2: ['brand y', '2000', 'internal', 'part-time', 10]\n         3: ['brand x', '2000', 'modem', 'contr.', 30]\n         4: ['brand x', 'nt', 'internal', 'contr.', 60]\n         5: ['brand y', 'xp', 'modem', 'salaried', 60]\n         6: ['brand x', '98', 'modem', 'part-time', 15]\n         7: ['brand y', 'xp', 'internal', 'hourly', 15]\n         8: ['brand y', 'nt', 'internal', 'part-time', 30]\n         9: ['brand x', '2000', 'modem', 'hourly', 10]\n        10: ['brand y', 'xp', 'modem', 'contr.', 30]\n        11: ['brand y', '2000', 'modem', 'salaried', 15]\n        12: ['brand y', 'nt', 'modem', 'salaried', 10]\n        13: ['brand y', 'xp', 'modem', 'part-time', 6]\n        14: ['brand y', '2000', 'modem', 'contr.', 60]\n\n\ndata source: ordereddict\n====================================\nyou can use ``collections.ordereddict`` instance as an argument for ``allpairs`` constructor.\npairs will be returned as ``collections.namedtuple`` instances.\n\n:sample code:\n    .. code:: python\n\n        from collections import ordereddict\n        from allpairspy import allpairs\n\n        parameters = ordereddict({\n            \"brand\": [\"brand x\", \"brand y\"],\n            \"os\": [\"98\", \"nt\", \"2000\", \"xp\"],\n            \"minute\": [15, 30, 60],\n        })\n\n        print(\"pairwise:\")\n        for i, pairs in enumerate(allpairs(parameters)):\n            print(\"{:2d}: {}\".format(i, pairs))\n\n:sample code:\n    .. code::\n\n        pairwise:\n         0: pairs(brand='brand x', os='98', minute=15)\n         1: pairs(brand='brand y', os='nt', minute=15)\n         2: pairs(brand='brand y', os='2000', minute=30)\n         3: pairs(brand='brand x', os='xp', minute=30)\n         4: pairs(brand='brand x', os='2000', minute=60)\n         5: pairs(brand='brand y', os='xp', minute=60)\n         6: pairs(brand='brand y', os='98', minute=60)\n         7: pairs(brand='brand x', os='nt', minute=60)\n         8: pairs(brand='brand x', os='nt', minute=30)\n         9: pairs(brand='brand x', os='98', minute=30)\n        10: pairs(brand='brand x', os='xp', minute=15)\n        11: pairs(brand='brand x', os='2000', minute=15)\n\n\nparameterized testing pairwise by using pytest\n====================================================================\n\nparameterized testing: value matrix\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n:sample code:\n    .. code:: python\n\n        import pytest\n        from allpairspy import allpairs\n\n        def function_to_be_tested(brand, operating_system, minute) -> bool:\n            # do something\n            return true\n\n        class testparameterized(object):\n            @pytest.mark.parametrize([\"brand\", \"operating_system\", \"minute\"], [\n                values for values in allpairs([\n                    [\"brand x\", \"brand y\"],\n                    [\"98\", \"nt\", \"2000\", \"xp\"],\n                    [10, 15, 30, 60]\n                ])\n            ])\n            def test(self, brand, operating_system, minute):\n                assert function_to_be_tested(brand, operating_system, minute)\n\n:output:\n    .. code::\n\n        $ py.test test_parameterize.py -v\n        ============================= test session starts ==============================\n        ...\n        collected 16 items\n\n        test_parameterize.py::testparameterized::test[brand x-98-10] passed      [  6%]\n        test_parameterize.py::testparameterized::test[brand y-nt-10] passed      [ 12%]\n        test_parameterize.py::testparameterized::test[brand y-2000-15] passed    [ 18%]\n        test_parameterize.py::testparameterized::test[brand x-xp-15] passed      [ 25%]\n        test_parameterize.py::testparameterized::test[brand x-2000-30] passed    [ 31%]\n        test_parameterize.py::testparameterized::test[brand y-xp-30] passed      [ 37%]\n        test_parameterize.py::testparameterized::test[brand y-98-60] passed      [ 43%]\n        test_parameterize.py::testparameterized::test[brand x-nt-60] passed      [ 50%]\n        test_parameterize.py::testparameterized::test[brand x-nt-30] passed      [ 56%]\n        test_parameterize.py::testparameterized::test[brand x-98-30] passed      [ 62%]\n        test_parameterize.py::testparameterized::test[brand x-xp-60] passed      [ 68%]\n        test_parameterize.py::testparameterized::test[brand x-2000-60] passed    [ 75%]\n        test_parameterize.py::testparameterized::test[brand x-2000-10] passed    [ 81%]\n        test_parameterize.py::testparameterized::test[brand x-xp-10] passed      [ 87%]\n        test_parameterize.py::testparameterized::test[brand x-98-15] passed      [ 93%]\n        test_parameterize.py::testparameterized::test[brand x-nt-15] passed      [100%]\n\nparameterized testing: ordereddict\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n:sample code:\n    .. code:: python\n\n        import pytest\n        from allpairspy import allpairs\n\n        def function_to_be_tested(brand, operating_system, minute) -> bool:\n            # do something\n            return true\n\n        class testparameterized(object):\n            @pytest.mark.parametrize(\n                [\"pair\"],\n                [\n                    [pair]\n                    for pair in allpairs(\n                        ordereddict(\n                            {\n                                \"brand\": [\"brand x\", \"brand y\"],\n                                \"operating_system\": [\"98\", \"nt\", \"2000\", \"xp\"],\n                                \"minute\": [10, 15, 30, 60],\n                            }\n                        )\n                    )\n                ],\n            )\n            def test(self, pair):\n                assert function_to_be_tested(pair.brand, pair.operating_system, pair.minute)\n\n\nother examples\n=================\nother examples could be found in `examples <https://github.com/thombashi/allpairspy/tree/master/examples>`__ directory.\n\n\ninstallation\n------------\n\ninstallation: pip\n==================================\n::\n\n    pip install allpairspy\n\ninstallation: apt\n==================================\nyou can install the package by ``apt`` via a personal package archive (`ppa <https://launchpad.net/~thombashi/+archive/ubuntu/ppa>`__):\n\n::\n\n    sudo add-apt-repository ppa:thombashi/ppa\n    sudo apt update\n    sudo apt install python3-allpairspy\n\n\nknown issues\n------------\n* not optimal - there are tools that can create smaller set covering\n  all the pairs. however, they are missing some other important\n  features and/or do not integrate well with python.\n\n* lousy written filtering function may lead to full permutation of parameters.\n\n* version 2.0 has become slower (a side-effect of introducing ability to produce n-wise combinations).\n\n\ndependencies\n------------\npython 3.7+\nno external dependencies.\n\n\nsponsors\n------------\n.. image:: https://avatars.githubusercontent.com/u/3658062?s=48&v=4\n   :target: https://github.com/b4tman\n   :alt: dmitry belyaev (b4tman)\n.. image:: https://avatars.githubusercontent.com/u/44389260?s=48&u=6da7176e51ae2654bcfd22564772ef8a3bb22318&v=4\n   :target: https://github.com/chasbecker\n   :alt: charles becker (chasbecker)\n.. image:: https://avatars.githubusercontent.com/u/46711571?s=48&u=57687c0e02d5d6e8eeaf9177f7b7af4c9f275eb5&v=4\n   :target: https://github.com/arturi0\n   :alt: arturi0\n\n`become a sponsor <https://github.com/sponsors/thombashi>`__\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit license",
  "name": "allpairspy",
  "package_url": "https://pypi.org/project/allpairspy/",
  "project_url": "https://pypi.org/project/allpairspy/",
  "project_urls": {
    "Homepage": "https://github.com/thombashi/allpairspy",
    "Source": "https://github.com/thombashi/allpairspy",
    "Tracker": "https://github.com/thombashi/allpairspy/issues"
  },
  "release_url": "https://pypi.org/project/allpairspy/2.5.1/",
  "requires_dist": [
    "pytest (>=6.0.1) ; extra == 'test'",
    "pytest-md-report (>=0.3) ; extra == 'test'"
  ],
  "requires_python": ">=3.7",
  "summary": "pairwise test combinations generator",
  "version": "2.5.1",
  "releases": [],
  "developers": [
    "metacomm@users.sourceforge.net",
    "metacommunications_engineering",
    "tsuyoshi.hombashi@gmail.com",
    "tsuyoshi_hombashi"
  ],
  "kwds": "allpairspy allpairs pyversions pytest py",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_allpairspy",
  "homepage": "https://github.com/thombashi/allpairspy",
  "release_count": 10,
  "dependency_ids": [
    "pypi_pytest",
    "pypi_pytest_md_report"
  ]
}