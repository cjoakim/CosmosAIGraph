{
  "classifiers": [
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: pypy",
    "topic :: internet :: www/http"
  ],
  "description": "|build status| |requirements status|\n\nwebpush data encryption library for python\n==========================================\n\nthis is a work in progress. this library is available on `pypi as\npywebpush <https://pypi.python.org/pypi/pywebpush>`__. source is\navailable on `github <https://github.com/mozilla-services/pywebpush>`__.\n\ninstallation\n------------\n\nyou\u2019ll need to run ``python virtualenv``. then\n\n::\n\n   bin/pip install -r requirements.txt\n   bin/python setup.py develop\n\nusage\n-----\n\nin the browser, the promise handler for\n`registration.pushmanager.subscribe() <https://developer.mozilla.org/en-us/docs/web/api/pushmanager/subscribe>`__\nreturns a\n`pushsubscription <https://developer.mozilla.org/en-us/docs/web/api/pushsubscription>`__\nobject. this object has a .tojson() method that will return a json\nobject that contains all the info we need to encrypt and push data.\n\nas illustration, a ``subscription_info`` object may look like:\n\n.. code:: json\n\n   {\n     \"endpoint\": \"https://updates.push.services.mozilla.com/push/v1/gaa...\",\n     \"keys\": { \"auth\": \"k8j...\", \"p256dh\": \"bor...\" }\n   }\n\nhow you send the pushsubscription data to your backend, store it\nreferenced to the user who requested it, and recall it when there\u2019s a\nnew push subscription update is left as an exercise for the reader.\n\nsending data using ``webpush()`` one call\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin many cases, your code will be sending a single message to many\nrecipients. there\u2019s a \u201cone call\u201d function which will make things easier.\n\n.. code:: python\n\n   from pywebpush import webpush\n\n   webpush(subscription_info,\n           data,\n           vapid_private_key=\"private key or file path[1]\",\n           vapid_claims={\"sub\": \"mailto:youremailaddress\"})\n\nthis will encode ``data``, add the appropriate vapid auth headers if\nrequired and send it to the push server identified in the\n``subscription_info`` block.\n\n**parameters**\n\n*subscription_info* - the ``dict`` of the subscription info (described\nabove).\n\n*data* - can be any serial content (string, bit array, serialized json,\netc), but be sure that your receiving application is able to parse and\nunderstand it. (e.g.\u00a0``data = \"mary had a little lamb.\"``)\n\n*content_type* - specifies the form of encryption to use, either\n``'aes128gcm'`` or the deprecated ``'aesgcm'``. note that not all user\nagents can decrypt ``'aesgcm'``, so the library defaults to the rfc 8188\nstandard form.\n\n*vapid_claims* - a ``dict`` containing the vapid claims required for\nauthorization (see\n`py_vapid <https://github.com/web-push-libs/vapid/tree/master/python>`__\nfor more details). if ``aud`` is not specified, pywebpush will attempt\nto auto-fill from the ``endpoint``.\n\n*vapid_private_key* - either a path to a vapid ec2 private key pem file,\nor a string containing the der representation. (see\n`py_vapid <https://github.com/web-push-libs/vapid/tree/master/python>`__\nfor more details.) the ``private_key`` may be a base64 encoded der\nformatted private key, or the path to an openssl exported private key\nfile.\n\ne.g.\u00a0the output of:\n\n::\n\n   openssl ecparam -name prime256v1 -genkey -noout -out private_key.pem\n\n**example**\n\n.. code:: python\n\n   from pywebpush import webpush, webpushexception\n\n   try:\n       webpush(\n           subscription_info={\n               \"endpoint\": \"https://push.example.com/v1/12345\",\n               \"keys\": {\n                   \"p256dh\": \"0123abcde...\",\n                   \"auth\": \"abc123...\"\n               }},\n           data=\"mary had a little lamb, with a nice mint jelly\",\n           vapid_private_key=\"path/to/vapid_private.pem\",\n           vapid_claims={\n                   \"sub\": \"mailto:yournamehere@example.org\",\n               }\n       )\n   except webpushexception as ex:\n       print(\"i'm sorry, dave, but i can't do that: {}\", repr(ex))\n       # mozilla returns additional information in the body of the response.\n       if ex.response and ex.response.json():\n           extra = ex.response.json()\n           print(\"remote service replied with a {}:{}, {}\",\n                 extra.code,\n                 extra.errno,\n                 extra.message\n                 )\n\nmethods\n~~~~~~~\n\nif you expect to resend to the same recipient, or have more needs than\njust sending data quickly, you can pass just\n``wp = webpusher(subscription_info)``. this will return a ``webpusher``\nobject.\n\nthe following methods are available:\n\n``.send(data, headers={}, ttl=0, gcm_key=\"\", reg_id=\"\", content_encoding=\"aes128gcm\", curl=false, timeout=none)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nsend the data using additional parameters. on error, returns a\n``webpushexception``\n\n**parameters**\n\n*data* binary string of data to send\n\n*headers* a ``dict`` containing any additional headers to send\n\n*ttl* message time to live on push server waiting for the client to\nreconnect (in seconds)\n\n*gcm_key* google cloud messaging key (if using the older gcm push\nsystem) this is the api key obtained from the google developer console.\n\n*reg_id* google cloud messaging registration id (will be extracted from\nendpoint if not specified)\n\n*content_encoding* ece content encoding type (defaults to \u201caes128gcm\u201d)\n\n*curl* do not execute the post, but return as a ``curl`` command. this\nwill write the encrypted content to a local file named\n``encrpypted.data``. this command is meant to be used for debugging\npurposes.\n\n*timeout* timeout for requests post query. see `requests\ndocumentation <http://docs.python-requests.org/en/master/user/quickstart/#timeouts>`__.\n\n**example**\n\nto send from chrome using the old gcm mode:\n\n.. code:: python\n\n   webpusher(subscription_info).send(data, headers, ttl, gcm_key)\n\n``.encode(data, content_encoding=\"aes128gcm\")``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nencode the ``data`` for future use. on error, returns a\n``webpushexception``\n\n**parameters**\n\n*data* binary string of data to send\n\n*content_encoding* ece content encoding type (defaults to \u201caes128gcm\u201d)\n\n**example**\n\n.. code:: python\n\n   encoded_data = webpush(subscription_info).encode(data)\n\nstand alone webpush\n-------------------\n\nif you\u2019re not really into coding your own solution, there\u2019s also a\n\u201cstand-alone\u201d ``pywebpush`` command in the ./bin directory.\n\nthis uses two files:\n\n-  the *data* file, which contains the message to send, in whatever form\n   you like.\n-  the *subscription info* file, which contains the subscription\n   information as json encoded data. this is usually returned by the\n   push ``subscribe`` method and looks something like:\n\n.. code:: json\n\n   {\n     \"endpoint\": \"https://push...\",\n     \"keys\": {\n       \"auth\": \"ab01...\",\n       \"p256dh\": \"aa02...\"\n     }\n   }\n\nif you\u2019re interested in just testing your applications webpush\ninterface, you could use the command line:\n\n.. code:: bash\n\n   ./bin/pywebpush --data stuff_to_send.data --info subscription.info\n\nwhich will encrypt and send the contents of ``stuff_to_send.data``.\n\nsee ``./bin/pywebpush --help`` for available commands and options.\n\n.. |build status| image:: https://travis-ci.org/web-push-libs/pywebpush.svg?branch=main\n   :target: https://travis-ci.org/web-push-libs/pywebpush\n.. |requirements status| image:: https://requires.io/github/web-push-libs/pywebpush/requirements.svg?branch=main\n   :target: https://requires.io/github/web-push-libs/pywebpush/requirements/?branch=main\n\n\n# i am terrible at keeping this up-to-date.\n\n## 1.14.0 (2021-07-28)\nbug: accept all vapid key instances (thanks @mthu)\n\n## 1.13.0 (2021-03-15)\nsupport requests_session param in webpush fn too\n\n## 1.12.0 (2021-03-15)\nchore: library update, remove nose tests\n\n## 1.11.0 (2020-04-29)\nfeat: add `--head` to read headers out of a json file (thanks @braedon)\n\n## 1.10.2 (2020-04-11)\nbug: update min vapid requirement to 1.7.0\n\n## 1.10.1 (2019-12-03)\nfeat: use six.text_type instead of six.string_types\n\n## 1.10.0 (2019-08-13)\nfeat: add `--verbose` flag with some initial commentary\nbug: update tests to use latest vapid version\n\n## 1.9.4 (2019-05-09)\nbug: update vapid `exp` header if missing or expired\n\n## 0.7.0 (2017-02-14)\nfeat: update to http-ece 0.7.0 (with draft-06 support)\nfeat: allow empty payloads for send()\nfeat: add python3 classfiers & python3.6 travis tests\nfeat: add readme.rst\nbug: change long to int to support python3\n\n## 0.4.0 (2016-06-05)\nfeat: make python 2.7 / 3.5 polyglot\n\n## 0.3.4 (2016-05-17)\nbug: make header keys case insenstive\n\n## 0.3.3 (2016-05-17)\nbug: force key string encoding to utf8\n\n## 0.3.2 (2016-04-28)\nbug: fix setup.py issues\n\n## 0.3 (2016-04-27)\nfeat: added travis, normalized directories\n\n\n## 0.2 (2016-04-27)\nfeat: added tests, restructured code\n\n\n## 0.1 (2016-04-25)\n\ninitial release",
  "docs_url": null,
  "keywords": "push webpush publication",
  "license": "mpl2",
  "name": "pywebpush",
  "package_url": "https://pypi.org/project/pywebpush/",
  "project_url": "https://pypi.org/project/pywebpush/",
  "project_urls": {
    "Homepage": "https://github.com/web-push-libs/pywebpush"
  },
  "release_url": "https://pypi.org/project/pywebpush/1.14.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "webpush publication library",
  "version": "1.14.0",
  "releases": [],
  "developers": [
    "jr_conlin",
    "src+webpusher@jrconlin.com"
  ],
  "kwds": "pywebpush webpush webpushexception webpusher pushmanager",
  "license_kwds": "mpl2",
  "libtype": "pypi",
  "id": "pypi_pywebpush",
  "homepage": "https://github.com/web-push-libs/pywebpush",
  "release_count": 41,
  "dependency_ids": []
}