{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: scrapy",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "topic :: internet :: www/http",
    "topic :: software development :: libraries :: application frameworks",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "==============================================\nscrapy & javascript integration through splash\n==============================================\n\n.. image:: https://img.shields.io/pypi/v/scrapy-splash.svg\n   :target: https://pypi.python.org/pypi/scrapy-splash\n   :alt: pypi version\n\n.. image:: https://github.com/scrapy-plugins/scrapy-splash/workflows/tests/badge.svg\n   :target: https://github.com/scrapy-plugins/scrapy-splash/actions/workflows/tests.yml\n   :alt: test status\n\n.. image:: http://codecov.io/github/scrapy-plugins/scrapy-splash/coverage.svg?branch=master\n   :target: http://codecov.io/github/scrapy-plugins/scrapy-splash?branch=master\n   :alt: code coverage\n\nthis library provides scrapy_ and javascript integration using splash_.\nthe license is bsd 3-clause.\n\n.. _scrapy: https://github.com/scrapy/scrapy\n.. _splash: https://github.com/scrapinghub/splash\n\ninstallation\n============\n\ninstall scrapy-splash using pip::\n\n    $ pip install scrapy-splash\n\nscrapy-splash uses splash_ http api, so you also need a splash instance.\nusually to install & run splash, something like this is enough::\n\n    $ docker run -p 8050:8050 scrapinghub/splash\n\ncheck splash `install docs`_ for more info.\n\n.. _install docs: http://splash.readthedocs.org/en/latest/install.html\n\n\nconfiguration\n=============\n\n1. add the splash server address to ``settings.py`` of your scrapy project\n   like this::\n\n      splash_url = 'http://192.168.59.103:8050'\n\n2. enable the splash middleware by adding it to ``downloader_middlewares``\n   in your ``settings.py`` file and changing httpcompressionmiddleware\n   priority::\n\n      downloader_middlewares = {\n          'scrapy_splash.splashcookiesmiddleware': 723,\n          'scrapy_splash.splashmiddleware': 725,\n          'scrapy.downloadermiddlewares.httpcompression.httpcompressionmiddleware': 810,\n      }\n\n   order `723` is just before `httpproxymiddleware` (750) in default\n   scrapy settings.\n\n   httpcompressionmiddleware priority should be changed in order to allow\n   advanced response processing; see https://github.com/scrapy/scrapy/issues/1895\n   for details.\n\n3. enable ``splashdeduplicateargsmiddleware`` by adding it to\n   ``spider_middlewares`` in your ``settings.py``::\n\n      spider_middlewares = {\n          'scrapy_splash.splashdeduplicateargsmiddleware': 100,\n      }\n\n   this middleware is needed to support ``cache_args`` feature; it allows\n   to save disk space by not storing duplicate splash arguments multiple\n   times in a disk request queue. if splash 2.1+ is used the middleware\n   also allows to save network traffic by not sending these duplicate\n   arguments to splash server multiple times.\n\n4. set a custom ``dupefilter_class``::\n\n      dupefilter_class = 'scrapy_splash.splashawaredupefilter'\n\n5. if you use scrapy http cache then a custom cache storage backend\n   is required. scrapy-splash provides a subclass of\n   ``scrapy.contrib.httpcache.filesystemcachestorage``::\n\n      httpcache_storage = 'scrapy_splash.splashawarefscachestorage'\n\n   if you use other cache storage then it is necesary to subclass it and\n   replace all ``scrapy.util.request.request_fingerprint`` calls with\n   ``scrapy_splash.splash_request_fingerprint``.\n\n.. note::\n\n    steps (4) and (5) are necessary because scrapy doesn't provide a way\n    to override request fingerprints calculation algorithm globally; this\n    could change in future.\n\n\nthere are also some additional options available.\nput them into your ``settings.py`` if you want to change the defaults:\n\n* ``splash_cookies_debug`` is ``false`` by default.\n  set to ``true`` to enable debugging cookies in the ``splashcookiesmiddleware``.\n  this option is similar to ``cookies_debug``\n  for the built-in scarpy cookies middleware: it logs sent and received cookies\n  for all requests.\n* ``splash_log_400`` is ``true`` by default - it instructs to log all 400 errors\n  from splash. they are important because they show errors occurred\n  when executing the splash script. set it to ``false`` to disable this logging.\n* ``splash_slot_policy`` is ``scrapy_splash.slotpolicy.per_domain`` (as object, not just a string) by default.\n  it specifies how concurrency & politeness are maintained for splash requests,\n  and specify the default value for ``slot_policy`` argument for\n  ``splashrequest``, which is described below.\n\n\nusage\n=====\n\nrequests\n--------\n\nthe easiest way to render requests with splash is to\nuse ``scrapy_splash.splashrequest``::\n\n    yield splashrequest(url, self.parse_result,\n        args={\n            # optional; parameters passed to splash http api\n            'wait': 0.5,\n\n            # 'url' is prefilled from request url\n            # 'http_method' is set to 'post' for post requests\n            # 'body' is set to request body for post requests\n        },\n        endpoint='render.json', # optional; default is render.html\n        splash_url='<url>',     # optional; overrides splash_url\n        slot_policy=scrapy_splash.slotpolicy.per_domain,  # optional\n    )\n\nalternatively, you can use regular scrapy.request and\n``'splash'`` request `meta` key::\n\n    yield scrapy.request(url, self.parse_result, meta={\n        'splash': {\n            'args': {\n                # set rendering arguments here\n                'html': 1,\n                'png': 1,\n\n                # 'url' is prefilled from request url\n                # 'http_method' is set to 'post' for post requests\n                # 'body' is set to request body for post requests\n            },\n\n            # optional parameters\n            'endpoint': 'render.json',  # optional; default is render.json\n            'splash_url': '<url>',      # optional; overrides splash_url\n            'slot_policy': scrapy_splash.slotpolicy.per_domain,\n            'splash_headers': {},       # optional; a dict with headers sent to splash\n            'dont_process_response': true, # optional, default is false\n            'dont_send_headers': true,  # optional, default is false\n            'magic_response': false,    # optional, default is true\n        }\n    })\n\nuse ``request.meta['splash']`` api in middlewares or when scrapy.request\nsubclasses are used (there is also ``splashformrequest`` described below).\nfor example, ``meta['splash']`` allows to create a middleware which enables\nsplash for all outgoing requests by default.\n\n``splashrequest`` is a convenient utility to fill ``request.meta['splash']``;\nit should be easier to use in most cases. for each ``request.meta['splash']``\nkey there is a corresponding ``splashrequest`` keyword argument: for example,\nto set ``meta['splash']['args']`` use ``splashrequest(..., args=myargs)``.\n\n* ``meta['splash']['args']`` contains arguments sent to splash.\n  scrapy-splash adds some default keys/values to ``args``:\n\n  * 'url' is set to request.url;\n  * 'http_method' is set to 'post' for post requests;\n  * 'body' is set to to request.body for post requests.\n\n  you can override default values by setting them explicitly.\n\n  note that by default scrapy escapes url fragments using ajax escaping scheme.\n  if you want to pass a url with a fragment to splash then set ``url``\n  in ``args`` dict manually. this is handled automatically if you use\n  ``splashrequest``, but you need to keep that in mind if you use raw\n  ``meta['splash']`` api.\n\n  splash 1.8+ is required to handle post requests; in earlier splash versions\n  'http_method' and 'body' arguments are ignored. if you work with ``/execute``\n  endpoint and want to support post requests you have to handle\n  ``http_method`` and ``body`` arguments in your lua script manually.\n\n* ``meta['splash']['cache_args']`` is a list of argument names to cache\n  on splash side. these arguments are sent to splash only once, then cached\n  values are used; it allows to save network traffic and decreases request\n  queue disk memory usage. use ``cache_args`` only for large arguments\n  which don't change with each request; ``lua_source`` is a good candidate\n  (if you don't use string formatting to build it). splash 2.1+ is required\n  for this feature to work.\n\n* ``meta['splash']['endpoint']`` is the splash endpoint to use.\n  in case of splashrequest\n  `render.html <http://splash.readthedocs.org/en/latest/api.html#render-html>`_\n  is used by default. if you're using raw scrapy.request then\n  `render.json <http://splash.readthedocs.org/en/latest/api.html#render-json>`_\n  is a default (for historical reasons). it is better to always pass endpoint\n  explicitly.\n\n  see splash `http api docs`_ for a full list of available endpoints\n  and parameters.\n\n.. _http api docs: http://splash.readthedocs.org/en/latest/api.html\n\n* ``meta['splash']['splash_url']`` overrides the splash url set\n  in ``settings.py``.\n\n* ``meta['splash']['splash_headers']`` allows to add or change headers\n  which are sent to splash server. note that this option **is not** for\n  setting headers which are sent to the remote website.\n\n* ``meta['splash']['slot_policy']`` customize how\n  concurrency & politeness are maintained for splash requests.\n\n  currently there are 3 policies available:\n\n  1. ``scrapy_splash.slotpolicy.per_domain`` (default) - send splash requests to\n     downloader slots based on url being rendered. it is useful if you want\n     to maintain per-domain politeness & concurrency settings.\n\n  2. ``scrapy_splash.slotpolicy.single_slot`` - send all splash requests to\n     a single downloader slot. it is useful if you want to throttle requests\n     to splash.\n\n  3. ``scrapy_splash.slotpolicy.scrapy_default`` - don't do anything with slots.\n     it is similar to ``single_slot`` policy, but can be different if you access\n     other services on the same address as splash.\n\n* ``meta['splash']['dont_process_response']`` - when set to true,\n  splashmiddleware won't change the response to a custom scrapy.response\n  subclass. by default for splash requests one of splashresponse,\n  splashtextresponse or splashjsonresponse is passed to the callback.\n\n* ``meta['splash']['dont_send_headers']``: by default scrapy-splash passes\n  request headers to splash in 'headers' json post field. for all render.xxx\n  endpoints it means scrapy header options are respected by default\n  (http://splash.readthedocs.org/en/stable/api.html#arg-headers). in lua\n  scripts you can use ``headers`` argument of ``splash:go`` to apply the\n  passed headers: ``splash:go{url, headers=splash.args.headers}``.\n\n  set 'dont_send_headers' to true if you don't want to pass ``headers``\n  to splash.\n\n* ``meta['splash']['http_status_from_error_code']`` - set response.status\n  to http error code when ``assert(splash:go(..))`` fails; it requires\n  ``meta['splash']['magic_response']=true``. ``http_status_from_error_code``\n  option is false by default if you use raw meta api;\n  splashrequest sets it to true by default.\n\n* ``meta['splash']['magic_response']`` - when set to true and a json\n  response is received from splash, several attributes of the response\n  (headers, body, url, status code) are filled using data returned in json:\n\n  * response.headers are filled from 'headers' keys;\n  * response.url is set to the value of 'url' key;\n  * response.body is set to the value of 'html' key,\n    or to base64-decoded value of 'body' key;\n  * response.status is set to the value of 'http_status' key.\n    when ``meta['splash']['http_status_from_error_code']`` is true\n    and ``assert(splash:go(..))`` fails with an http error\n    response.status is also set to http error code.\n\n  original url, status and headers are available as ``response.real_url``,\n  ``response.splash_response_status`` and ``response.splash_response_headers``.\n\n  this option is set to true by default if you use splashrequest.\n  ``render.json`` and ``execute`` endpoints may not have all the necessary\n  keys/values in the response.\n  for non-json endpoints, only url is filled, regardless of the\n  ``magic_response`` setting.\n\n\nuse ``scrapy_splash.splashformrequest`` if you want to make a ``formrequest``\nvia splash. it accepts the same arguments as ``splashrequest``,\nand also ``formdata``, like ``formrequest`` from scrapy::\n\n    >>> splashformrequest('http://example.com', formdata={'foo': 'bar'})\n    <post http://example.com>\n\n``splashformrequest.from_response`` is also supported, and works as described\nin `scrapy documentation <http://scrapy.readthedocs.org/en/latest/topics/request-response.html#scrapy.http.formrequest.from_response>`_.\n\nresponses\n---------\n\nscrapy-splash returns response subclasses for splash requests:\n\n* splashresponse is returned for binary splash responses - e.g. for\n  /render.png responses;\n* splashtextresponse is returned when the result is text - e.g. for\n  /render.html responses;\n* splashjsonresponse is returned when the result is a json object - e.g.\n  for /render.json responses or /execute responses when script returns\n  a lua table.\n\nto use standard response classes set ``meta['splash']['dont_process_response']=true``\nor pass ``dont_process_response=true`` argument to splashrequest.\n\nall these responses set ``response.url`` to the url of the original request\n(i.e. to the url of a website you want to render), not to the url of the\nrequested splash endpoint. \"true\" url is still available as\n``response.real_url``.\n\nsplashjsonresponse provide extra features:\n\n* ``response.data`` attribute contains response data decoded from json;\n  you can access it like ``response.data['html']``.\n\n* if splash session handling is configured, you can access current cookies\n  as ``response.cookiejar``; it is a cookiejar instance.\n\n* if scrapy-splash response magic is enabled in request (default),\n  several response attributes (headers, body, url, status code)\n  are set automatically from original response body:\n\n  * response.headers are filled from 'headers' keys;\n  * response.url is set to the value of 'url' key;\n  * response.body is set to the value of 'html' key,\n    or to base64-decoded value of 'body' key;\n  * response.status is set from the value of 'http_status' key.\n\nwhen ``response.body`` is updated in splashjsonresponse\n(either from 'html' or from 'body' keys) familiar ``response.css``\nand ``response.xpath`` methods are available.\n\nto turn off special handling of json result keys either set\n``meta['splash']['magic_response']=false`` or pass ``magic_response=false``\nargument to splashrequest.\n\nsession handling\n================\n\nsplash itself is stateless - each request starts from a clean state.\nin order to support sessions the following is required:\n\n1. client (scrapy) must send current cookies to splash;\n2. splash script should make requests using these cookies and update\n   them from http response headers or javascript code;\n3. updated cookies should be sent back to the client;\n4. client should merge current cookies wiht the updated cookies.\n\nfor (2) and (3) splash provides ``splash:get_cookies()`` and\n``splash:init_cookies()`` methods which can be used in splash lua scripts.\n\nscrapy-splash provides helpers for (1) and (4): to send current cookies\nin 'cookies' field and merge cookies back from 'cookies' response field\nset ``request.meta['splash']['session_id']`` to the session\nidentifier. if you only want a single session use the same ``session_id`` for\nall request; any value like '1' or 'foo' is fine.\n\nfor scrapy-splash session handling to work you must use ``/execute`` endpoint\nand a lua script which accepts 'cookies' argument and returns 'cookies'\nfield in the result::\n\n   function main(splash)\n       splash:init_cookies(splash.args.cookies)\n\n       -- ... your script\n\n       return {\n           cookies = splash:get_cookies(),\n           -- ... other results, e.g. html\n       }\n   end\n\nsplashrequest sets ``session_id`` automatically for ``/execute`` endpoint,\ni.e. cookie handling is enabled by default if you use splashrequest,\n``/execute`` endpoint and a compatible lua rendering script.\n\nif you want to start from the same set of cookies, but then 'fork' sessions\nset ``request.meta['splash']['new_session_id']`` in addition to\n``session_id``. request cookies will be fetched from cookiejar ``session_id``,\nbut response cookies will be merged back to the ``new_session_id`` cookiejar.\n\nstandard scrapy ``cookies`` argument can be used with ``splashrequest``\nto add cookies to the current splash cookiejar.\n\nexamples\n========\n\nget html contents::\n\n    import scrapy\n    from scrapy_splash import splashrequest\n\n    class myspider(scrapy.spider):\n        start_urls = [\"http://example.com\", \"http://example.com/foo\"]\n\n        def start_requests(self):\n            for url in self.start_urls:\n                yield splashrequest(url, self.parse, args={'wait': 0.5})\n\n        def parse(self, response):\n            # response.body is a result of render.html call; it\n            # contains html processed by a browser.\n            # ...\n\nget html contents and a screenshot::\n\n    import json\n    import base64\n    import scrapy\n    from scrapy_splash import splashrequest\n\n    class myspider(scrapy.spider):\n\n        # ...\n            splash_args = {\n                'html': 1,\n                'png': 1,\n                'width': 600,\n                'render_all': 1,\n            }\n            yield splashrequest(url, self.parse_result, endpoint='render.json',\n                                args=splash_args)\n\n        # ...\n        def parse_result(self, response):\n            # magic responses are turned on by default,\n            # so the result under 'html' key is available as response.body\n            html = response.body\n\n            # you can also query the html result as usual\n            title = response.css('title').extract_first()\n\n            # full decoded json data is available as response.data:\n            png_bytes = base64.b64decode(response.data['png'])\n\n            # ...\n\nrun a simple `splash lua script`_::\n\n    import json\n    import base64\n    from scrapy_splash import splashrequest\n\n\n    class myspider(scrapy.spider):\n\n        # ...\n            script = \"\"\"\n            function main(splash)\n                assert(splash:go(splash.args.url))\n                return splash:evaljs(\"document.title\")\n            end\n            \"\"\"\n            yield splashrequest(url, self.parse_result, endpoint='execute',\n                                args={'lua_source': script})\n\n        # ...\n        def parse_result(self, response):\n            doc_title = response.text\n            # ...\n\n\nmore complex `splash lua script`_ example - get a screenshot of an html\nelement by its css selector (it requires splash 2.1+).\nnote how are arguments passed to the script::\n\n    import json\n    import base64\n    from scrapy_splash import splashrequest\n\n    script = \"\"\"\n    -- arguments:\n    -- * url - url to render;\n    -- * css - css selector to render;\n    -- * pad - screenshot padding size.\n\n    -- this function adds padding around region\n    function pad(r, pad)\n      return {r[1]-pad, r[2]-pad, r[3]+pad, r[4]+pad}\n    end\n\n    -- main script\n    function main(splash)\n\n      -- this function returns element bounding box\n      local get_bbox = splash:jsfunc([[\n        function(css) {\n          var el = document.queryselector(css);\n          var r = el.getboundingclientrect();\n          return [r.left, r.top, r.right, r.bottom];\n        }\n      ]])\n\n      assert(splash:go(splash.args.url))\n      assert(splash:wait(0.5))\n\n      -- don't crop image by a viewport\n      splash:set_viewport_full()\n\n      local region = pad(get_bbox(splash.args.css), splash.args.pad)\n      return splash:png{region=region}\n    end\n    \"\"\"\n\n    class myspider(scrapy.spider):\n\n\n        # ...\n            yield splashrequest(url, self.parse_element_screenshot,\n                endpoint='execute',\n                args={\n                    'lua_source': script,\n                    'pad': 32,\n                    'css': 'a.title'\n                }\n             )\n\n        # ...\n        def parse_element_screenshot(self, response):\n            image_data = response.body  # binary image data in png format\n            # ...\n\n\nuse a lua script to get an html response with cookies, headers, body\nand method set to correct values; ``lua_source`` argument value is cached\non splash server and is not sent with each request (it requires splash 2.1+)::\n\n    import scrapy\n    from scrapy_splash import splashrequest\n\n    script = \"\"\"\n    function main(splash)\n      splash:init_cookies(splash.args.cookies)\n      assert(splash:go{\n        splash.args.url,\n        headers=splash.args.headers,\n        http_method=splash.args.http_method,\n        body=splash.args.body,\n        })\n      assert(splash:wait(0.5))\n\n      local entries = splash:history()\n      local last_response = entries[#entries].response\n      return {\n        url = splash:url(),\n        headers = last_response.headers,\n        http_status = last_response.status,\n        cookies = splash:get_cookies(),\n        html = splash:html(),\n      }\n    end\n    \"\"\"\n\n    class myspider(scrapy.spider):\n\n\n        # ...\n            yield splashrequest(url, self.parse_result,\n                endpoint='execute',\n                cache_args=['lua_source'],\n                args={'lua_source': script},\n                headers={'x-my-header': 'value'},\n            )\n\n        def parse_result(self, response):\n            # here response.body contains result html;\n            # response.headers are filled with headers from last\n            # web page loaded to splash;\n            # cookies from all responses and from javascript are collected\n            # and put into set-cookie response header, so that scrapy\n            # can remember them.\n\n\n\n.. _splash lua script: http://splash.readthedocs.org/en/latest/scripting-tutorial.html\n\n\nhttp basic auth\n===============\n\nif you need to use http basic authentication to access splash, use the\n``splash_user`` and ``splash_pass`` optional settings::\n\n    splash_user = 'user'\n    splash_pass = 'userpass'\n\nanother option is ``meta['splash']['splash_headers']``: it allows to set\ncustom headers which are sent to splash server; add authorization header\nto ``splash_headers`` if you want to change credentials per-request::\n\n    import scrapy\n    from w3lib.http import basic_auth_header\n\n    class myspider(scrapy.spider):\n        # ...\n        def start_requests(self):\n            auth = basic_auth_header('user', 'userpass')\n            yield splashrequest(url, self.parse,\n                                splash_headers={'authorization': auth})\n\n**warning:** don't use `httpauthmiddleware`_\n(i.e. ``http_user`` / ``http_pass`` spider attributes) for splash\nauthentication: if you occasionally send a non-splash request from your spider,\nyou may expose splash credentials to a remote website, as httpauthmiddleware\nsets credentials for all requests unconditionally.\n\n.. _httpauthmiddleware: http://doc.scrapy.org/en/latest/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpauth\n\nwhy not use the splash http api directly?\n=========================================\n\nthe obvious alternative to scrapy-splash would be to send requests directly\nto the splash `http api`_. take a look at the example below and make\nsure to read the observations after it::\n\n    import json\n\n    import scrapy\n    from scrapy.http.headers import headers\n\n    render_html_url = \"http://127.0.0.1:8050/render.html\"\n\n    class myspider(scrapy.spider):\n        start_urls = [\"http://example.com\", \"http://example.com/foo\"]\n\n        def start_requests(self):\n            for url in self.start_urls:\n                body = json.dumps({\"url\": url, \"wait\": 0.5}, sort_keys=true)\n                headers = headers({'content-type': 'application/json'})\n                yield scrapy.request(render_html_url, self.parse, method=\"post\",\n                                     body=body, headers=headers)\n\n        def parse(self, response):\n            # response.body is a result of render.html call; it\n            # contains html processed by a browser.\n            # ...\n\n\nit works and is easy enough, but there are some issues that you should be\naware of:\n\n1. there is a bit of boilerplate.\n\n2. as seen by scrapy, we're sending requests to ``render_html_url`` instead\n   of the target urls. it affects concurrency and politeness settings:\n   ``concurrent_requests_per_domain``, ``download_delay``, etc could behave\n   in unexpected ways since delays and concurrency settings are no longer\n   per-domain.\n\n3. as seen by scrapy, response.url is an url of the splash server.\n   scrapy-splash fixes it to be an url of a requested page.\n   \"real\" url is still available as ``response.real_url``. scrapy-splash also\n   allows to handle ``response.status`` and ``response.headers`` transparently\n   on scrapy side.\n\n4. some options depend on each other - for example, if you use timeout_\n   splash option then you may want to set ``download_timeout``\n   scrapy.request meta key as well.\n\n5. it is easy to get it subtly wrong - e.g. if you won't use\n   ``sort_keys=true`` argument when preparing json body then binary post body\n   content could vary even if all keys and values are the same, and it means\n   dupefilter and cache will work incorrectly.\n\n6. default scrapy duplication filter doesn't take splash specifics in\n   account. for example, if an url is sent in a json post request body\n   scrapy will compute request fingerprint without canonicalizing this url.\n\n7. splash bad request (http 400) errors are hard to debug because by default\n   response content is not displayed by scrapy. splashmiddleware logs content\n   of http 400 splash responses by default (it can be turned off by setting\n   ``splash_log_400 = false`` option).\n\n8. cookie handling is tedious to implement, and you can't use scrapy\n   built-in cookie middleware to handle cookies when working with splash.\n\n9. large splash arguments which don't change with every request\n   (e.g. ``lua_source``) may take a lot of space when saved to scrapy disk\n   request queues. ``scrapy-splash`` provides a way to store such static\n   parameters only once.\n\n10. splash 2.1+ provides a way to save network traffic by caching large\n    static arguments on server, but it requires client support: client should\n    send proper ``save_args`` and ``load_args`` values and handle http 498\n    responses.\n\nscrapy-splash utlities allow to handle such edge cases and reduce\nthe boilerplate.\n\n.. _http api: http://splash.readthedocs.org/en/latest/api.html\n.. _timeout: http://splash.readthedocs.org/en/latest/api.html#arg-timeout\n\n\ngetting help\n============\n\n* for problems with rendering pages read \"`splash faq`_\" page\n* for scrapy-related bugs take a look at \"`reporting scrapy bugs`_\" page\n\nbest approach to get any other help is to ask a question on `stack overflow`_\n\n.. _reporting scrapy bugs: https://doc.scrapy.org/en/master/contributing.html#reporting-bugs\n.. _splash faq: http://splash.readthedocs.io/en/stable/faq.html#website-is-not-rendered-correctly\n.. _stack overflow: https://stackoverflow.com/questions/tagged/scrapy-splash?sort=frequent&pagesize=15&mixed=1\n\n\ncontributing\n============\n\nsource code and bug tracker are on github:\nhttps://github.com/scrapy-plugins/scrapy-splash\n\nto run tests, install \"tox\" python package and then run ``tox`` command\nfrom the source checkout.\n\nto run integration tests, start splash and set splash_url env variable\nto splash address before running ``tox`` command::\n\n   docker run -d --rm -p8050:8050 scrapinghub/splash:3.0\n   splash_url=http://127.0.0.1:8050 tox -e py36\n\n\nchanges\n=======\n\n0.9.0 (2023-02-03)\n------------------\n\n* removed official support for python 2.7, 3.4, 3.5 and 3.6, and added official\n  support for python 3.9, 3.10 and 3.11.\n\n* deprecated ``splashjsonresponse.body_as_unicode()``, to be replaced by\n  ``splashjsonresponse.text``.\n\n* removed calls to obsolete ``to_native_str``, removed in scrapy 2.8.\n\n0.8.0 (2021-10-05)\n------------------\n\n*   **security bug fix:**\n\n    if you use httpauthmiddleware_ (i.e. the ``http_user`` and ``http_pass``\n    spider attributes) for splash authentication, any non-splash request will\n    expose your credentials to the request target. this includes ``robots.txt``\n    requests sent by scrapy when the ``robotstxt_obey`` setting is set to\n    ``true``.\n\n    use the new ``splash_user`` and ``splash_pass`` settings instead to set\n    your splash authentication credentials safely.\n\n    .. _httpauthmiddleware: http://doc.scrapy.org/en/latest/topics/downloader-middleware.html#module-scrapy.downloadermiddlewares.httpauth\n\n*   responses now expose the http status code and headers from splash as\n    ``response.splash_response_status`` and\n    ``response.splash_response_headers`` (#158)\n\n*   the ``meta`` argument passed to the ``scrapy_splash.request.splashrequest``\n    constructor is no longer modified (#164)\n\n*   website responses with 400 or 498 as http status code are no longer\n    handled as the equivalent splash responses (#158)\n\n*   cookies are no longer sent to splash itself (#156)\n\n*   ``scrapy_splash.utils.dict_hash`` now also works with ``obj=none``\n    (``225793b``)\n\n*   our test suite now includes integration tests (#156) and tests can be run\n    in parallel (``6fb8c41``)\n\n*   there\u2019s a new \u2018getting help\u2019 section in the ``readme.rst`` file (#161,\n    #162), the documentation about ``splash_slot_policy`` has been improved\n    (#157) and a typo as been fixed (#121)\n\n*   made some internal improvements (``ee5000d``, ``25de545``, ``2aaa79d``)\n\n\n0.7.2 (2017-03-30)\n------------------\n\n* fixed issue with response type detection.\n\n0.7.1 (2016-12-20)\n------------------\n\n* scrapy 1.0.x support is back;\n* readme updates.\n\n0.7 (2016-05-16)\n----------------\n\n* ``splash_cookies_debug`` setting allows to log cookies\n  sent and received to/from splash in ``cookies`` request/response fields.\n  it is similar to scrapy's builtin ``cookies_debug``, but works for\n  splash requests;\n* readme cleanup.\n\n0.6.1 (2016-04-29)\n------------------\n\n* warning about http methods is no longer logged for non-splash requests.\n\n0.6 (2016-04-20)\n----------------\n\n* ``splashawaredupefilter`` and ``splash_request_fingerprint`` are improved:\n  they now canonicalize urls and take url fragments in account;\n* ``cache_args`` value fingerprints are now calculated faster.\n\n0.5 (2016-04-18)\n----------------\n\n* ``cache_args`` splashrequest argument and\n  ``request.meta['splash']['cache_args']`` key allow to save network traffic\n  and disk storage by not storing duplicate splash arguments in disk request\n  queues and not sending them to splash multiple times. this feature requires\n  splash 2.1+.\n\nto upgrade from v0.4 enable ``splashdeduplicateargsmiddleware`` in settings.py::\n\n  spider_middlewares = {\n      'scrapy_splash.splashdeduplicateargsmiddleware': 100,\n  }\n\n0.4 (2016-04-14)\n----------------\n\n* splashformrequest class is added; it is a variant of formrequest which uses\n  splash;\n* splash parameters are no longer stored in request.meta twice; this change\n  should decrease disk queues data size;\n* splashmiddleware now increases request priority when rescheduling the request;\n  this should decrease disk queue data size and help with stale cookie\n  problems.\n\n0.3 (2016-04-11)\n----------------\n\npackage is renamed from ``scrapyjs`` to ``scrapy-splash``.\n\nan easiest way to upgrade is to replace ``scrapyjs`` imports with\n``scrapy_splash`` and update ``settings.py`` with new defaults\n(check the readme).\n\nthere are many new helpers to handle javascript rendering transparently;\nthe recommended way is now to use ``scrapy_splash.splashrequest`` instead\nof  ``request.meta['splash']``. please make sure to read the readme if\nyou're upgrading from scrapyjs - you may be able to drop some code from your\nproject, especially if you want to access response html, handle cookies\nand headers.\n\n* new splashrequest class; it can be used as a replacement for scrapy.request\n  to provide a better integration with splash;\n* added support for post requests;\n* splashresponse, splashtextresponse and splashjsonresponse allow to\n  handle splash responses transparently, taking care of response.url,\n  response.body, response.headers and response.status. splashjsonresponse\n  allows to access decoded response json data as ``response.data``.\n* cookie handling improvements: it is possible to handle scrapy and splash\n  cookies transparently; current cookiejar is exposed as response.cookiejar;\n* headers are passed to splash by default;\n* urls with fragments are handled automatically when using splashrequest;\n* logging is improved: ``splashrequest.__repr__`` shows both requested url\n  and splash url;\n* in case of splash http 400 errors the response is logged by default;\n* an issue with dupefilters is fixed: previously the order of keys in\n  json request body could vary, making requests appear as non-duplicates;\n* it is now possible to pass custom headers to splash server itself;\n* test coverage reports are enabled.\n\n0.2 (2016-03-26)\n----------------\n\n* scrapy 1.0 and 1.1 support;\n* python 3 support;\n* documentation improvements;\n* project is moved to https://github.com/scrapy-plugins/scrapy-splash.\n\n0.1.1 (2015-03-16)\n------------------\n\nfixed fingerprint calculation for non-string meta values.\n\n0.1 (2015-02-28)\n----------------\n\ninitial release\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "scrapy-splash",
  "package_url": "https://pypi.org/project/scrapy-splash/",
  "project_url": "https://pypi.org/project/scrapy-splash/",
  "project_urls": {
    "Homepage": "https://github.com/scrapy-plugins/scrapy-splash"
  },
  "release_url": "https://pypi.org/project/scrapy-splash/0.9.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "javascript support for scrapy using splash",
  "version": "0.9.0",
  "releases": [],
  "developers": [
    "kmike84@gmail.com",
    "mikhail_korobov",
    "scrapy_developers"
  ],
  "kwds": "scrapy_splash scrapyjs scrapy scrapy_ scrapy_default",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_scrapy_splash",
  "homepage": "https://github.com/scrapy-plugins/scrapy-splash",
  "release_count": 11,
  "dependency_ids": []
}