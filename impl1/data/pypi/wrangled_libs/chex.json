{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: scientific/engineering :: artificial intelligence",
    "topic :: software development :: libraries :: python modules",
    "topic :: software development :: testing :: mocking",
    "topic :: software development :: testing :: unit"
  ],
  "description": "# chex\n\n![ci status](https://github.com/deepmind/chex/workflows/ci/badge.svg)\n![docs](https://readthedocs.org/projects/chex/badge/?version=latest)\n![pypi](https://img.shields.io/pypi/v/chex)\n\nchex is a library of utilities for helping to write reliable jax code.\n\nthis includes utils to help:\n\n* instrument your code (e.g. assertions)\n* debug (e.g. transforming `pmaps` in `vmaps` within a context manager).\n* test jax code across many `variants` (e.g. jitted vs non-jitted).\n\n## installation\n\nyou can install the latest released version of chex from pypi via:\n\n```sh\npip install chex\n```\n\nor you can install the latest development version from github:\n\n```sh\npip install git+https://github.com/deepmind/chex.git\n```\n\n## modules overview\n\n### dataclass ([dataclass.py](https://github.com/deepmind/chex/blob/master/chex/_src/dataclass.py))\n\ndataclasses are a popular construct introduced by python 3.7 to allow to\neasily specify typed data structures with minimal boilerplate code. they are\nnot, however, compatible with jax and\n[dm-tree](https://github.com/deepmind/tree) out of the box.\n\nin chex we provide a jax-friendly dataclass implementation reusing python [dataclasses](https://docs.python.org/3/library/dataclasses.html#module-dataclasses).\n\nchex implementation of `dataclass` registers dataclasses as internal [_pytree_\nnodes](https://jax.readthedocs.io/en/latest/pytrees.html) to ensure\ncompatibility with jax data structures.\n\nin addition, we provide a class wrapper that exposes dataclasses as\n`collections.mapping` descendants which allows to process them\n(e.g. (un-)flatten) in `dm-tree` methods as usual python dictionaries.\nsee [`@mappable_dataclass`](https://github.com/deepmind/chex/blob/master/chex/_src/dataclass.py#l27)\ndocstring for more details.\n\nexample:\n\n```python\n@chex.dataclass\nclass parameters:\n  x: chex.arraydevice\n  y: chex.arraydevice\n\nparameters = parameters(\n    x=jnp.ones((2, 2)),\n    y=jnp.ones((1, 2)),\n)\n\n# dataclasses can be treated as jax pytrees\njax.tree_util.tree_map(lambda x: 2.0 * x, parameters)\n\n# and as mappings by dm-tree\ntree.flatten(parameters)\n```\n\n**note**: unlike standard python 3.7 dataclasses, chex\ndataclasses cannot be constructed using positional arguments. they support\nconstruction arguments provided in the same format as the python dict\nconstructor. dataclasses can be converted to tuples with the `from_tuple` and\n`to_tuple` methods if necessary.\n\n```python\nparameters = parameters(\n    jnp.ones((2, 2)),\n    jnp.ones((1, 2)),\n)\n# valueerror: mappable dataclass constructor doesn't support positional args.\n```\n\n### assertions ([asserts.py](https://github.com/deepmind/chex/blob/master/chex/_src/asserts.py))\n\none limitation of pytype annotations for jax is that they do not support the\nspecification of `devicearray` ranks, shapes or dtypes. chex includes a number\nof functions that allow flexible and concise specification of these properties.\n\ne.g. suppose you want to ensure that all tensors `t1`, `t2`, `t3` have the same\nshape, and that tensors `t4`, `t5` have rank `2` and (`3` or `4`), respectively.\n\n```python\nchex.assert_equal_shape([t1, t2, t3])\nchex.assert_rank([t4, t5], [2, {3, 4}])\n```\n\nmore examples:\n\n```python\nfrom chex import assert_shape, assert_rank, ...\n\nassert_shape(x, (2, 3))                # x has shape (2, 3)\nassert_shape([x, y], [(), (2,3)])      # x is scalar and y has shape (2, 3)\n\nassert_rank(x, 0)                      # x is scalar\nassert_rank([x, y], [0, 2])            # x is scalar and y is a rank-2 array\nassert_rank([x, y], {0, 2})            # x and y are scalar or rank-2 arrays\n\nassert_type(x, int)                    # x has type `int` (x can be an array)\nassert_type([x, y], [int, float])      # x has type `int` and y has type `float`\n\nassert_equal_shape([x, y, z])          # x, y, and z have equal shapes\n\nassert_trees_all_close(tree_x, tree_y) # values and structure of trees match\nassert_tree_all_finite(tree_x)         # all tree_x leaves are finite\n\nassert_devices_available(2, 'gpu')     # 2 gpus available\nassert_tpu_available()                 # at least 1 tpu available\n\nassert_numerical_grads(f, (x, y), j)   # f^{(j)}(x, y) matches numerical grads\n```\n\nsee `asserts.py`\n[documentation](https://chex.readthedocs.io/en/latest/api.html#assertions) to\nfind all supported assertions.\n\nif you cannot find a specific assertion, please consider making a pull request\nor openning an issue on\n[the bug tracker](https://github.com/deepmind/chex/issues).\n\n#### optional arguments\n\nall chex assertions support the following optional kwargs for manipulating the\nemitted exception messages:\n\n* `custom_message`: a string to include into the emitted exception messages.\n* `include_default_message`: whether to include the default chex message into\n  the emitted exception messages.\n* `exception_type`: an exception type to use. `assertionerror` by default.\n\nfor example, the following code:\n\n```python\ndataset = load_dataset()\nparams = init_params()\nfor i in range(num_steps):\n  params = update_params(params, dataset.sample())\n  chex.assert_tree_all_finite(params,\n                              custom_message=f'failed at iteration {i}.',\n                              exception_type=valueerror)\n```\n\nwill raise a `valueerror` that includes a step number when `params` get polluted\nwith `nans` or `none`s.\n\n#### static and value (aka *runtime*) assertions\n\nchex divides all assertions into 2 classes: ***static*** and ***value***\nassertions.\n\n1.  ***static*** assertions use anything except concrete values of tensors.\n    examples: `assert_shape`, `assert_trees_all_equal_dtypes`,\n    `assert_max_traces`.\n\n2.  ***value*** assertions require access to tensor values, which are not\n    available during jax tracing (see\n    [howjax primitives work](https://jax.readthedocs.io/en/latest/notebooks/how_jax_primitives_work.html)),\n    thus such assertion need special treatment in a *jitted* code.\n\nto enable value assertions in a jitted function, it can be decorated with\n`chex.chexify()` wrapper. example:\n\n```python\n  @chex.chexify\n  @jax.jit\n  def logp1_abs_safe(x: chex.array) -> chex.array:\n    chex.assert_tree_all_finite(x)\n    return jnp.log(jnp.abs(x) + 1)\n\n  logp1_abs_safe(jnp.ones(2))  # ok\n  logp1_abs_safe(jnp.array([jnp.nan, 3]))  # fails (in async mode)\n\n  # the error will be raised either at the next line or at the next\n  # `logp1_abs_safe` call. see the docs for more detain on async mode.\n  logp1_abs_safe.wait_checks()  # wait for the (async) computation to complete.\n```\n\nsee\n[this docstring](https://chex.readthedocs.io/en/latest/api.html#chex.chexify)\nfor more detail on `chex.chexify()`.\n\n#### jax tracing assertions\n\njax re-traces jit'ted function every time the structure of passed arguments\nchanges. often this behavior is inadvertent and leads to a significant\nperformance drop which is hard to debug. [@chex.assert_max_traces](https://github.com/deepmind/chex/blob/master/chex/_src/asserts.py#l44)\ndecorator asserts that the function is not re-traced more than `n` times during\nprogram execution.\n\nglobal trace counter can be cleared by calling\n`chex.clear_trace_counter()`. this function be used to isolate unittests relying\non `@chex.assert_max_traces`.\n\nexamples:\n\n```python\n  @jax.jit\n  @chex.assert_max_traces(n=1)\n  def fn_sum_jitted(x, y):\n    return x + y\n\n  fn_sum_jitted(jnp.zeros(3), jnp.zeros(3))  # tracing for the 1st time - ok\n  fn_sum_jitted(jnp.zeros([6, 7]), jnp.zeros([6, 7]))  # assertionerror!\n```\n\ncan be used with `jax.pmap()` as well:\n\n```python\n  def fn_sub(x, y):\n    return x - y\n\n  fn_sub_pmapped = jax.pmap(chex.assert_max_traces(fn_sub, n=10))\n```\n\nsee\n[howjax primitives work](https://jax.readthedocs.io/en/latest/notebooks/how_jax_primitives_work.html)\nsection for more information about tracing.\n\n### test variants ([variants.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants.py))\n\njax relies extensively on code transformation and compilation, meaning that it\ncan be hard to ensure that code is properly tested. for instance, just testing a\npython function using jax code will not cover the actual code path that is\nexecuted when jitted, and that path will also differ whether the code is jitted\nfor cpu, gpu, or tpu. this has been a source of obscure and hard to catch bugs\nwhere xla changes would lead to undesirable behaviours that however only\nmanifest in one specific code transformation.\n\nvariants make it easy to ensure that unit tests cover different \u2018variations\u2019 of\na function, by providing a simple decorator that can be used to repeat any test\nunder all (or a subset) of the relevant code transformations.\n\ne.g. suppose you want to test the output of a function `fn` with or without jit.\nyou can use `chex.variants` to run the test with both the jitted and non-jitted\nversion of the function by simply decorating a test method with\n`@chex.variants`, and then using `self.variant(fn)` in place of `fn` in the body\nof the test.\n\n```python\ndef fn(x, y):\n  return x + y\n...\n\nclass exampletest(chex.testcase):\n\n  @chex.variants(with_jit=true, without_jit=true)\n  def test(self):\n    var_fn = self.variant(fn)\n    self.assertequal(fn(1, 2), 3)\n    self.assertequal(var_fn(1, 2), fn(1, 2))\n```\n\nif you define the function in the test method, you may also use `self.variant`\nas a decorator in the function definition. for example:\n\n```python\nclass exampletest(chex.testcase):\n\n  @chex.variants(with_jit=true, without_jit=true)\n  def test(self):\n    @self.variant\n    def var_fn(x, y):\n       return x + y\n\n    self.assertequal(var_fn(1, 2), 3)\n```\n\nexample of parameterized test:\n\n```python\nfrom absl.testing import parameterized\n\n# could also be:\n#  `class exampleparameterizedtest(chex.testcase, parameterized.testcase):`\n#  `class exampleparameterizedtest(chex.testcase):`\nclass exampleparameterizedtest(parameterized.testcase):\n\n  @chex.variants(with_jit=true, without_jit=true)\n  @parameterized.named_parameters(\n      ('case_positive', 1, 2, 3),\n      ('case_negative', -1, -2, -3),\n  )\n  def test(self, arg_1, arg_2, expected):\n    @self.variant\n    def var_fn(x, y):\n       return x + y\n\n    self.assertequal(var_fn(arg_1, arg_2), expected)\n```\n\nchex currently supports the following variants:\n\n* `with_jit` -- applies `jax.jit()` transformation to the function.\n* `without_jit` -- uses the function as is, i.e. identity transformation.\n* `with_device` -- places all arguments (except specified in `ignore_argnums`\n   argument) into device memory before applying the function.\n* `without_device` -- places all arguments in ram before applying the function.\n* `with_pmap` -- applies `jax.pmap()` transformation to the function (see notes below).\n\nsee documentation in [variants.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants.py) for more details on the supported variants.\nmore examples can be found in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py).\n\n### variants notes\n\n* test classes that use `@chex.variants` must inherit from\n`chex.testcase` (or any other base class that unrolls tests generators\nwithin `testcase`, e.g. `absl.testing.parameterized.testcase`).\n\n* **[`jax.vmap`]** all variants can be applied to a vmapped function;\nplease see an example in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py) (`test_vmapped_fn_named_params` and\n`test_pmap_vmapped_fn`).\n\n* **[`@chex.all_variants`]** you can get all supported variants\nby using the decorator `@chex.all_variants`.\n\n* **[`with_pmap` variant]** `jax.pmap(fn)`\n([doc](https://jax.readthedocs.io/en/latest/jax.html#jax.pmap)) performs\nparallel map of `fn` onto multiple devices. since most tests run in a\nsingle-device environment (i.e. having access to a single cpu or gpu), in which\ncase `jax.pmap` is a functional equivalent to `jax.jit`, ` with_pmap` variant is\nskipped by default (although it works fine with a single device). below we\ndescribe  a way to properly test `fn` if it is supposed to be used in\nmulti-device environments (tpus or multiple cpus/gpus). to disable skipping\n`with_pmap` variants in case of a single device, add\n`--chex_skip_pmap_variant_if_single_device=false` to your test command.\n\n### fakes ([fake.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake.py))\n\ndebugging in jax is made more difficult by code transformations such as `jit`\nand `pmap`, which introduce optimizations that make code hard to inspect and\ntrace. it can also be difficult to disable those transformations during\ndebugging as they can be called at several places in the underlying\ncode. chex provides tools to globally replace `jax.jit` with a no-op\ntransformation and `jax.pmap` with a (non-parallel) `jax.vmap`, in order to more\neasily debug code in a single-device context.\n\nfor example, you can use chex to fake `pmap` and have it replaced with a `vmap`.\nthis can be achieved by wrapping your code with a context manager:\n\n```python\nwith chex.fake_pmap():\n  @jax.pmap\n  def fn(inputs):\n    ...\n\n  # function will be vmapped over inputs\n  fn(inputs)\n```\n\nthe same functionality can also be invoked with `start` and `stop`:\n\n```python\nfake_pmap = chex.fake_pmap()\nfake_pmap.start()\n... your jax code ...\nfake_pmap.stop()\n```\n\nin addition, you can fake a real multi-device test environment with a\nmulti-threaded cpu. see section **faking multi-device test environments** for\nmore details.\n\nsee documentation in [fake.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake.py) and examples in [fake_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_test.py) for more details.\n\n## faking multi-device test environments\n\nin situations where you do not have easy access to multiple devices, you can\nstill test parallel computation using single-device multi-threading.\n\nin particular, one can force xla to use a single cpu's threads as separate\ndevices, i.e. to fake a real multi-device environment with a multi-threaded one.\nthese two options are theoretically equivalent from xla perspective because they\nexpose the same interface and use identical abstractions.\n\nchex has a flag `chex_n_cpu_devices` that specifies a number of cpu threads to\nuse as xla devices.\n\nto set up a multi-threaded xla environment for `absl` tests, define\n`setupmodule` function in your test module:\n\n```python\ndef setupmodule():\n  chex.set_n_cpu_devices()\n```\n\nnow you can launch your test with `python test.py --chex_n_cpu_devices=n` to run\nit in multi-device regime. note that **all** tests within a module will have an\naccess to `n` devices.\n\nmore examples can be found in [variants_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/variants_test.py), [fake_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_test.py) and [fake_set_n_cpu_devices_test.py](https://github.com/deepmind/chex/blob/master/chex/_src/fake_set_n_cpu_devices_test.py).\n\n### using named dimension sizes.\n\nchex comes with a small utility that allows you to package a collection of\ndimension sizes into a single object. the basic idea is:\n\n```python\ndims = chex.dimensions(b=batch_size, t=sequence_len, e=embedding_dim)\n...\nchex.assert_shape(arr, dims['bte'])\n```\n\nstring lookups are translated integer tuples. for instance, let's say\n`batch_size == 3`, `sequence_len = 5` and `embedding_dim = 7`, then\n\n```python\ndims['bte'] == (3, 5, 7)\ndims['b'] == (3,)\ndims['ttbee'] == (5, 5, 3, 7, 7)\n...\n```\n\nyou can also assign dimension sizes dynamically as follows:\n\n```python\ndims['xy'] = some_matrix.shape\ndims.z = 13\n```\n\nfor more examples, see [chex.dimensions](https://chex.readthedocs.io/en/latest/api.html#chex.dimensions)\ndocumentation.\n\n## citing chex\n\nthis repository is part of the [deepmind jax ecosystem], to cite chex please use\nthe [deepmind jax ecosystem citation].\n\n[deepmind jax ecosystem]: https://deepmind.com/blog/article/using-jax-to-accelerate-our-research \"deepmind jax ecosystem\"\n[deepmind jax ecosystem citation]: https://github.com/deepmind/jax/blob/main/deepmind2020jax.txt \"citation\"\n",
  "docs_url": null,
  "keywords": "jax testing debugging python machine learning",
  "license": "apache 2.0",
  "name": "chex",
  "package_url": "https://pypi.org/project/chex/",
  "project_url": "https://pypi.org/project/chex/",
  "project_urls": {
    "Homepage": "https://github.com/deepmind/chex"
  },
  "release_url": "https://pypi.org/project/chex/0.1.85/",
  "requires_dist": [
    "absl-py >=0.9.0",
    "typing-extensions >=4.2.0",
    "jax >=0.4.16",
    "jaxlib >=0.1.37",
    "numpy >=1.24.1",
    "toolz >=0.9.0",
    "setuptools ; python_version >= \"3.12\""
  ],
  "requires_python": ">=3.9",
  "summary": "chex: testing made fun, in jax!",
  "version": "0.1.85",
  "releases": [],
  "developers": [
    "chex-dev@google.com",
    "deepmind"
  ],
  "kwds": "jax how_jax_primitives_work chex_skip_pmap_variant_if_single_device chex debugging",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_chex",
  "homepage": "https://github.com/deepmind/chex",
  "release_count": 23,
  "dependency_ids": [
    "pypi_absl_py",
    "pypi_jax",
    "pypi_jaxlib",
    "pypi_numpy",
    "pypi_setuptools",
    "pypi_toolz",
    "pypi_typing_extensions"
  ]
}