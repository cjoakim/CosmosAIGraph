{
  "classifiers": [
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "<img src=\"https://raw.githubusercontent.com/cknd/stackprinter/master/darkbg.png\" width=\"500\">\n\n[![build](https://github.com/cknd/stackprinter/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/cknd/stackprinter/actions/workflows/build.yml)\n\n# better tracebacks\n\nthis is a more helpful version of python's built-in exception message: it shows more code context and the current values of nearby variables. that answers many of the questions i'd ask an interactive debugger: where in the code was the crash, what's in the relevant variables, and why was _that_ function called with _those_ arguments. it either prints to the console or gives you a string for logging.\n\n```bash\npip3 install stackprinter\n```\n### before\n```\ntraceback (most recent call last):\n  file \"demo.py\", line 12, in <module>\n    dangerous_function(somelist + anotherlist)\n  file \"demo.py\", line 6, in dangerous_function\n    return sorted(blub, key=lambda xs: sum(xs))\n  file \"demo.py\", line 6, in <lambda>\n    return sorted(blub, key=lambda xs: sum(xs))\ntypeerror: unsupported operand type(s) for +: 'int' and 'str'\n```\n\n### after\n```\nfile demo.py, line 12, in <module>\n    9        somelist = [[1,2], [3,4]]\n    10       anotherlist = [['5', 6]]\n    11       spam = numpy.zeros((3,3))\n--> 12       dangerous_function(somelist + anotherlist)\n    13   except:\n    ..................................................\n     somelist = [[1, 2, ], [3, 4, ], ]\n     anotherlist = [['5', 6, ], ]\n     spam = 3x3 array([[0. 0. 0.]\n                       [0. 0. 0.]\n                       [0. 0. 0.]])\n    ..................................................\n\nfile demo.py, line 6, in dangerous_function\n    5    def dangerous_function(blub):\n--> 6        return sorted(blub, key=lambda xs: sum(xs))\n    ..................................................\n     blub = [[1, 2, ], [3, 4, ], ['5', 6, ], ]\n    ..................................................\n\nfile demo.py, line 6, in <lambda>\n    3\n    4\n    5    def dangerous_function(blub):\n--> 6        return sorted(blub, key=lambda xs: sum(xs))\n    7\n    ..................................................\n     xs = ['5', 6, ]\n    ..................................................\n\ntypeerror: unsupported operand type(s) for +: 'int' and 'str'\n```\ni rarely use this locally instead of a real debugger, but it helps me sleep when my code runs somewhere where the only debug tool is a log file (though it's not a fully-grown [error monitoring system](https://sentry.io/welcome/)).\n\nby default, it tries to be somewhat polite about screen space, showing only a few source lines & the function header, and only the variables _that appear in those lines_, and using only (?) 500 characters per variable. you can [configure](https://github.com/cknd/stackprinter/blob/master/stackprinter/__init__.py#l28-l149) exactly how verbose things should be.\n\nit outputs plain text normally, which is good for log files. there's also a color mode for some reason \ud83c\udf08, with a few different color schemes for light and dark backgrounds. (the colors [track different variables](https://medium.com/@brianwill/making-semantic-highlighting-useful-9aeac92411df) instead of the language syntax.)\n\n<img src=\"https://raw.githubusercontent.com/cknd/stackprinter/master/notebook.png\" width=\"500\">\n\n# usage\n\n## option 1: set and forget\nto replace the default python crash printout, call `set_excepthook()` somewhere once. afterwards, any uncaught exception will be printed with an extended traceback (to stderr, by default). you could also [make this permanent for your python installation](#making-it-stick).\n\n```python\nimport stackprinter\nstackprinter.set_excepthook(style='darkbg2')  # for jupyter notebooks try style='lightbg'\n```\n## option 2: call it selectively during exception handling\nfor more control, call [`show()`](https://github.com/cknd/stackprinter/blob/master/stackprinter/__init__.py#l166-l183) or [`format()`](https://github.com/cknd/stackprinter/blob/master/stackprinter/__init__.py#l28-l149) inside an `except` block. `show()` prints to stderr, `format()` returns a string, for custom logging.\n\n```python\ntry:\n    something()\nexcept:\n    # print the current exception to stderr:\n    stackprinter.show()\n\n    # ...or instead, get a string for logging:\n    logger.error(stackprinter.format())\n```\nor pass specific exceptions explicitly:\n```python\ntry:\n    something()\nexcept runtimeerror as exc:\n    tb = stackprinter.format(exc)\n    logger.error('the front fell off.\\n' + tb)\n```\n\n## config options\n\n`format()`, `show()` and `set_excepthook()` accept a common set of keyword args. they allow you to tweak the formatting, hide certain variables by name, skip variables in calls within certain files, and some other stuff. \n\n```python\ntry:\n    something()\nexcept runtimeerror as exc:\n    stackprinter.show(exc, suppressed_vars=[r\".*secret.*\"],\n                           suppressed_paths=[r\"lib/python.*/site-packages/boringstuff\"],\n                           truncate_vals=9001,\n                           style=\"darkbg2\")\n```\nfor all the options [see the docstring of `format()`](https://github.com/cknd/stackprinter/blob/master/stackprinter/__init__.py#l28-l149).\n\n## option 3: integrate with the standard `logging` module\n\nwith a bit of extra plumbing you can log errors like this via the normal `logging` methods, without having to import `stackprinter` at the site of the logging call. so you can continue to write nice and simple error handlers like so...\n\n```python\nlogger = logging.getlogger()\ntry:\n    nothing = {}\n    dangerous_function(nothing.get(\"something\"))\nexcept:\n    logger.exception('my hovercraft is full of eels.')\n```\n...but still get annotated tracebacks in the resulting log.\n```\n2022-04-02 16:16:40,905 error: my hovercraft is full of eels.\n  \u2506 file \"demo_logging.py\", line 56, in <module>\n  \u2506     54   try:\n  \u2506     55       nothing = {}\n  \u2506 --> 56       dangerous_function(nothing.get(\"something\"))\n  \u2506     57   except:\n  \u2506     ..................................................\n  \u2506      nothing = {}\n  \u2506     ..................................................\n  \u2506\n  \u2506 file \"demo_logging.py\", line 52, in dangerous_function\n  \u2506     51   def dangerous_function(something):\n  \u2506 --> 52       return something + 1\n  \u2506     ..................................................\n  \u2506      something = none\n  \u2506     ..................................................\n  \u2506\n  \u2506 typeerror: unsupported operand type(s) for +: 'nonetype' and 'int'\n```\n\nyou can get this by adding a [custom formatter](https://docs.python.org/3/howto/logging-cookbook.html#customized-exception-formatting) to the logger before using it:\n\n```python\nimport logging\nimport stackprinter\n\nclass verboseexceptionformatter(logging.formatter):\n    def formatexception(self, exc_info):\n        msg = stackprinter.format(exc_info)\n        lines = msg.split('\\n')\n        lines_indented = [\"  \u2506 \" + line + \"\\n\" for line in lines]\n        msg_indented = \"\".join(lines_indented)\n        return msg_indented\n\ndef configure_logger(logger_name=none):\n    fmt = '%(asctime)s %(levelname)s: %(message)s'\n    formatter = verboseexceptionformatter(fmt)\n\n    handler = logging.streamhandler()\n    handler.setformatter(formatter)\n\n    logger = logging.getlogger(logger_name)\n    logger.addhandler(handler)\n\nconfigure_logger(\"some_logger\")\n```\nsee [demo_logging.py](https://github.com/cknd/stackprinter/blob/master/demo_logging.py) for a runnable example.\n\n## printing the current call stack\nto see your own thread's current call stack, call `show` or `format` anywhere outside of exception handling.\n\n```python\nstackprinter.show() # or format()\n```\n\n## printing the stack of another thread\nto inspect the call stack of any other running thread:\n\n```python\nthread = threading.thread(target=something)\nthread.start()\n# (...)\nstackprinter.show(thread) # or format(thread)\n```\n\n## making it stick\n\nto permanently replace the crash message for your python installation, you *could* put a file `sitecustomize.py` into the `site-packages` directory under one of the paths revealed by `python -c \"import site; print(site.prefixes)\"`, with contents like this:\n\n```python\n    # in e.g. some_virtualenv/lib/python3.x/site-packages/sitecustomize.py:\n    import stackprinter\n    stackprinter.set_excepthook(style='darkbg2')\n```\n\nthat would give you colorful tracebacks automatically every time, even in the repl.\n\n(you could do a similar thing for ipython, [but they have their own method](https://ipython.readthedocs.io/en/stable/interactive/tutorial.html?highlight=startup#configuration), where the file goes into `~/.ipython/profile_default/startup` instead, and also i don't want to talk about what this module does to set an excepthook under ipython.)\n\n# docs\n\nfor now, the documentation consists only of some fairly detailed docstrings, [e.g. those of `format()`](https://github.com/cknd/stackprinter/blob/master/stackprinter/__init__.py#l28-l149)\n\n# caveats\n\nthis displays variable values as they are _at the time of formatting_. in\nmulti-threaded programs, variables can change while we're busy walking\nthe stack & printing them. so, if nothing seems to make sense, consider that\nyour exception and the traceback messages are from slightly different times.\nsadly, there is no responsible way to freeze all other threads as soon\nas we want to inspect some thread's call stack (...or is there?)\n\n# how it works\n\nbasically, this is a frame formatter. for each [frame on the call stack](https://en.wikipedia.org/wiki/call_stack), it grabs the source code to find out which source lines reference which variables. then it displays code and variables in the neighbourhood of the last executed line.\n\nsince this already requires a map of where each variable occurs in the code, it was difficult not to also implement the whole semantic highlighting color thing seen in the screenshots. the colors are ansi escape codes now, but it should be fairly straightforward\u2122 to render the underlying data without any 1980ies terminal technology. say, a foldable and clickable html page with downloadable pickled variables. for now you'll have to pipe the ansi strings through [ansi2html](https://github.com/ralphbean/ansi2html/) or something.\n\nthe format and everything is inspired by the excellent [`ultratb`](https://ipython.readthedocs.io/en/stable/api/generated/ipython.core.ultratb.html) in ipython. one day i'd like to contribute the whole \"find out which variables in `locals` and `globals` are nearby in the source and print only those\" machine over there, after trimming its complexity a bit.\n\n## tracing a piece of code\n\nmore for curiosity than anything else, you can watch a piece of code execute step-by-step, printing a trace of all calls & returns 'live' as they are happening. slows everything down though, of course.\n```python\nwith stackprinter.traceprinter(style='darkbg2'):\n    dosomething()\n```\n\nor\n```python\ntp = stackprinter.traceprinter(style='darkbg2')\ntp.enable()\ndosomething()\n# (...) +1 million lines\ntp.disable()\n```\n<img src=\"https://raw.githubusercontent.com/cknd/stackprinter/master/trace.png\" width=\"300\">\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "stackprinter",
  "package_url": "https://pypi.org/project/stackprinter/",
  "project_url": "https://pypi.org/project/stackprinter/",
  "project_urls": {
    "Homepage": "https://github.com/cknd/stackprinter"
  },
  "release_url": "https://pypi.org/project/stackprinter/0.2.11/",
  "requires_dist": [],
  "requires_python": ">=3.4",
  "summary": "debug-friendly stack traces, with variable values and semantic highlighting",
  "version": "0.2.11",
  "releases": [],
  "developers": [
    "ck-github@mailbox.org",
    "cknd"
  ],
  "kwds": "debug debugger python3 pip3 traceback",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_stackprinter",
  "homepage": "https://github.com/cknd/stackprinter",
  "release_count": 20,
  "dependency_ids": []
}