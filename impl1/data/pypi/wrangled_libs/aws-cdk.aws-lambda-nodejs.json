{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# amazon lambda node.js library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthis library provides constructs for node.js lambda functions.\n\n## node.js function\n\nthe `nodejsfunction` construct creates a lambda function with automatic transpiling and bundling\nof typescript or javascript code. this results in smaller lambda packages that contain only the\ncode and dependencies needed to run the function.\n\nit uses [esbuild](https://esbuild.github.io/) under the hood.\n\n## reference project architecture\n\nthe `nodejsfunction` allows you to define your cdk and runtime dependencies in a single\npackage.json and to collocate your runtime code with your infrastructure code:\n\n```plaintext\n.\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 my-construct.api.ts # lambda handler for api\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 my-construct.auth.ts # lambda handler for auth\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 my-construct.ts # cdk construct with two lambda functions\n\u251c\u2500\u2500 package-lock.json # single lock file\n\u251c\u2500\u2500 package.json # cdk and runtime dependencies defined in a single package.json\n\u2514\u2500\u2500 tsconfig.json\n```\n\nby default, the construct will use the name of the defining file and the construct's\nid to look up the entry file. in `my-construct.ts` above we have:\n\n```python\n# automatic entry look up\napi_handler = lambda_.nodejsfunction(self, \"api\")\nauth_handler = lambda_.nodejsfunction(self, \"auth\")\n```\n\nalternatively, an entry file and handler can be specified:\n\n```python\nlambda_.nodejsfunction(self, \"myfunction\",\n    entry=\"/path/to/my/file.ts\",  # accepts .js, .jsx, .ts, .tsx and .mjs files\n    handler=\"myexportedfunc\"\n)\n```\n\nfor monorepos, the reference architecture becomes:\n\n```plaintext\n.\n\u251c\u2500\u2500 packages\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cool-package\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cool-construct.api.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 cool-construct.auth.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 cool-construct.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 package.json # cdk and runtime dependencies for cool-package\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tsconfig.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 super-package\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 super-construct.handler.ts\n\u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 super-construct.ts\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 package.json # cdk and runtime dependencies for super-package\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 package-lock.json # single lock file\n\u251c\u2500\u2500 package.json # root dependencies\n\u2514\u2500\u2500 tsconfig.json\n```\n\n## customizing the underlying lambda function\n\nall properties of `lambda.function` can be used to customize the underlying `lambda.function`.\n\nsee also the [aws lambda construct library](https://github.com/aws/aws-cdk/tree/master/packages/%40aws-cdk/aws-lambda).\n\nthe `nodejsfunction` construct automatically [reuses existing connections](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/node-reusing-connections.html)\nwhen working with the aws sdk for javascript. set the `awssdkconnectionreuse` prop to `false` to disable it.\n\n## lock file\n\nthe `nodejsfunction` requires a dependencies lock file (`yarn.lock`, `pnpm-lock.yaml` or\n`package-lock.json`). when bundling in a docker container, the path containing this lock file is\nused as the source (`/asset-input`) for the volume mounted in the container.\n\nby default, the construct will try to automatically determine your project lock file.\nalternatively, you can specify the `depslockfilepath` prop manually. in this\ncase you need to ensure that this path includes `entry` and any module/dependencies\nused by your function. otherwise bundling will fail.\n\n## local bundling\n\nif `esbuild` is available it will be used to bundle your code in your environment. otherwise,\nbundling will happen in a [lambda compatible docker container](https://gallery.ecr.aws/sam/build-nodejs12.x)\nwith the docker platform based on the target architecture of the lambda function.\n\nfor macos the recommended approach is to install `esbuild` as docker volume performance is really poor.\n\n`esbuild` can be installed with:\n\n```console\n$ npm install --save-dev esbuild@0\n```\n\nor\n\n```console\n$ yarn add --dev esbuild@0\n```\n\nif you're using a monorepo layout, the `esbuild` dependency needs to be installed in the \"root\" `package.json` file,\nnot in the workspace. from the reference architecture described [above](#reference-project-architecture), the `esbuild`\ndev dependency needs to be in `./package.json`, not `packages/cool-package/package.json` or\n`packages/super-package/package.json`.\n\nto force bundling in a docker container even if `esbuild` is available in your environment,\nset `bundling.forcedockerbundling` to `true`. this is useful if your function relies on node\nmodules that should be installed (`nodemodules` prop, see [below](#install-modules)) in a lambda\ncompatible environment. this is usually the case with modules using native dependencies.\n\n## working with modules\n\n### externals\n\nby default, all node modules are bundled except for `aws-sdk`. this can be configured by specifying\n`bundling.externalmodules`:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        external_modules=[\"aws-sdk\", \"cool-module\"\n        ]\n    )\n)\n```\n\n### install modules\n\nby default, all node modules referenced in your lambda code will be bundled by `esbuild`.\nuse the `nodemodules` prop under `bundling` to specify a list of modules that should not be\nbundled but instead included in the `node_modules` folder of the lambda package. this is useful\nwhen working with native dependencies or when `esbuild` fails to bundle a module.\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        node_modules=[\"native-module\", \"other-module\"]\n    )\n)\n```\n\nthe modules listed in `nodemodules` must be present in the `package.json`'s dependencies or\ninstalled. the same version will be used for installation. the lock file (`yarn.lock`,\n`pnpm-lock.yaml` or `package-lock.json`) will be used along with the right installer (`yarn`,\n`pnpm` or `npm`).\n\nwhen working with `nodemodules` using native dependencies, you might want to force bundling in a\ndocker container even if `esbuild` is available in your environment. this can be done by setting\n`bundling.forcedockerbundling` to `true`.\n\n## configuring `esbuild`\n\nthe `nodejsfunction` construct exposes [esbuild options](https://esbuild.github.io/api/#build-api)\nvia properties under `bundling`:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        minify=true,  # minify code, defaults to false\n        source_map=true,  # include source map, defaults to false\n        source_map_mode=lambda_.sourcemapmode.inline,  # defaults to sourcemapmode.default\n        sources_content=false,  # do not include original source into source map, defaults to true\n        target=\"es2020\",  # target environment for the generated javascript code\n        loader={ # use the 'dataurl' loader for '.png' files\n            \".png\": \"dataurl\"},\n        define={ # replace strings during build time\n            \"process.env.api_key\": json.stringify(\"xxx-xxxx-xxx\"),\n            \"process.env.production\": json.stringify(true),\n            \"process.env.number\": json.stringify(123)},\n        log_level=lambda_.loglevel.silent,  # defaults to loglevel.warning\n        keep_names=true,  # defaults to false\n        tsconfig=\"custom-tsconfig.json\",  # use custom-tsconfig.json instead of default,\n        metafile=true,  # include meta file, defaults to false\n        banner=\"/* comments */\",  # requires esbuild >= 0.9.0, defaults to none\n        footer=\"/* comments */\",  # requires esbuild >= 0.9.0, defaults to none\n        charset=lambda_.charset.utf8,  # do not escape non-ascii characters, defaults to charset.ascii\n        format=lambda_.outputformat.esm,  # ecmascript module output format, defaults to outputformat.cjs (outputformat.esm requires node.js 14.x)\n        main_fields=[\"module\", \"main\"],  # prefer ecmascript versions of dependencies\n        inject=[\"./my-shim.js\", \"./other-shim.js\"],  # allows to automatically replace a global variable with an import from another file\n        esbuild_args={ # pass additional arguments to esbuild\n            \"--log-limit\": \"0\",\n            \"--splitting\": true}\n    )\n)\n```\n\n## command hooks\n\nit is possible to run additional commands by specifying the `commandhooks` prop:\n\n```text\n// this example only available in typescript\n// run additional props via `commandhooks`\nnew lambda.nodejsfunction(this, 'my-handler-with-commands', {\n  bundling: {\n    commandhooks: {\n      beforebundling(inputdir: string, outputdir: string): string[] {\n        return [\n          `echo hello > ${inputdir}/a.txt`,\n          `cp ${inputdir}/a.txt ${outputdir}`,\n        ];\n      },\n      afterbundling(inputdir: string, outputdir: string): string[] {\n        return [`cp ${inputdir}/b.txt ${outputdir}/txt`];\n      },\n      beforeinstall() {\n        return [];\n      },\n      // ...\n    },\n    // ...\n  },\n});\n```\n\nthe following hooks are available:\n\n* `beforebundling`: runs before all bundling commands\n* `beforeinstall`: runs before node modules installation\n* `afterbundling`: runs after all bundling commands\n\nthey all receive the directory containing the lock file (`inputdir`) and the\ndirectory where the bundled asset will be output (`outputdir`). they must return\nan array of commands to run. commands are chained with `&&`.\n\nthe commands will run in the environment in which bundling occurs: inside the\ncontainer for docker bundling or on the host os for local bundling.\n\n## pre compilation with tsc\n\nin some cases, `esbuild` may not yet support some newer features of the typescript language, such as,\n[`emitdecoratormetadata`](https://www.typescriptlang.org/tsconfig#emitdecoratormetadata).\nin such cases, it is possible to run pre-compilation using `tsc` by setting the `precompilation` flag.\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        pre_compilation=true\n    )\n)\n```\n\nnote: a [`tsconfig.json` file](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html) is required\n\n## customizing docker bundling\n\nuse `bundling.environment` to define environments variables when `esbuild` runs:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        environment={\n            \"node_env\": \"production\"\n        }\n    )\n)\n```\n\nuse `bundling.buildargs` to pass build arguments when building the docker bundling image:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        build_args={\n            \"https_proxy\": \"https://127.0.0.1:3001\"\n        }\n    )\n)\n```\n\nuse `bundling.dockerimage` to use a custom docker bundling image:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        docker_image=dockerimage.from_build(\"/path/to/dockerfile\")\n    )\n)\n```\n\nthis image should have `esbuild` installed **globally**. if you plan to use `nodemodules` it\nshould also have `npm`, `yarn` or `pnpm` depending on the lock file you're using.\n\nuse the [default image provided by `@aws-cdk/aws-lambda-nodejs`](https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-lambda-nodejs/lib/dockerfile)\nas a source of inspiration.\n\n## asset hash\n\nby default the asset hash will be calculated based on the bundled output (`assethashtype.output`).\n\nuse the `assethash` prop to pass a custom hash:\n\n```python\nlambda_.nodejsfunction(self, \"my-handler\",\n    bundling=lambda.bundlingoptions(\n        asset_hash=\"my-custom-hash\"\n    )\n)\n```\n\nif you chose to customize the hash, you will need to make sure it is updated every time the asset\nchanges, or otherwise it is possible that some deployments will not be invalidated.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-lambda-nodejs",
  "package_url": "https://pypi.org/project/aws-cdk.aws-lambda-nodejs/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-lambda-nodejs/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-lambda-nodejs/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-lambda (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws lambda in node.js",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "nodejsfunction nodejs12 nodejs aws node_env",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_lambda_nodejs",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 211,
  "dependency_ids": [
    "pypi_aws_cdk.aws_lambda",
    "pypi_aws_cdk.core",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}