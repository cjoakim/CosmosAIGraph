{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "jq.py: a lightweight and flexible json processor\n================================================\n\nthis project contains python bindings for\n`jq <http://stedolan.github.io/jq/>`_ 1.7.\n\ninstallation\n------------\n\nwheels are built for various python versions and architectures on linux and mac os x.\non these platforms, you should be able to install jq with a normal pip install:\n\n.. code-block:: sh\n\n    pip install jq\n\nif a wheel is not available,\nthe source for jq 1.7 is built.\nthis requires:\n\n* autoreconf\n\n* the normal c compiler toolchain, such as gcc and make.\n\n* libtool\n\n* python headers.\n\nalternatively, set the environment variable ``jqpy_use_system_libs`` to ``1`` when installing the package\nto use the libjq and libonig versions available on the system rather than building them.\n\ndebian, ubuntu or relatives\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif on debian, ubuntu or relatives, running the following command should be sufficient:\n\n.. code-block:: sh\n\n    apt-get install autoconf automake build-essential libtool python-dev\n\nred hat, fedora, centos or relatives\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif on red hat, fedora, centos, or relatives, running the following command should be sufficient:\n\n.. code-block:: sh\n\n    yum groupinstall \"development tools\"\n    yum install autoconf automake libtool python python-devel\n\nmac os x\n~~~~~~~~\n\nif on mac os x, you probably want to install\n`xcode <https://developer.apple.com/xcode/>`_ and `homebrew <http://brew.sh/>`_.\nonce homebrew is installed, you can install the remaining dependencies with:\n\n.. code-block:: sh\n\n    brew install autoconf automake libtool\n\nusage\n-----\n\nusing jq requires three steps:\n\n#. call ``jq.compile()`` to compile a jq program.\n#. call an input method on the compiled program to supply the input.\n#. call an output method on the result to retrieve the output.\n\nfor instance:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".+5\").input_value(42).first() == 47\n\ninput methods\n~~~~~~~~~~~~~\n\ncall ``.input_value()`` to supply a valid json value, such as the values returned from ``json.load``:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".\").input_value(none).first() == none\n    assert jq.compile(\".\").input_value(42).first() == 42\n    assert jq.compile(\".\").input_value(0.42).first() == 0.42\n    assert jq.compile(\".\").input_value(true).first() == true\n    assert jq.compile(\".\").input_value(\"hello\").first() == \"hello\"\n\ncall ``.input_values()`` to supply multiple valid json values, such as the values returned from ``json.load``:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".+5\").input_values([1, 2, 3]).all() == [6, 7, 8]\n\ncall ``.input_text()`` to supply unparsed json text:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".\").input_text(\"null\").first() == none\n    assert jq.compile(\".\").input_text(\"42\").first() == 42\n    assert jq.compile(\".\").input_text(\"0.42\").first() == 0.42\n    assert jq.compile(\".\").input_text(\"true\").first() == true\n    assert jq.compile(\".\").input_text('\"hello\"').first() == \"hello\"\n    assert jq.compile(\".\").input_text(\"1\\n2\\n3\").all() == [1, 2, 3]\n\npass ``slurp=true`` to ``.input_text()`` to read the entire input into an array:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".\").input_text(\"1\\n2\\n3\", slurp=true).first() == [1, 2, 3]\n\nyou can also call the older ``input()`` method by passing:\n\n* a valid json value, such as the values returned from ``json.load``, as a positional argument\n* unparsed json text as the keyword argument ``text``\n\nfor instance:\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".\").input(\"hello\").first() == \"hello\"\n    assert jq.compile(\".\").input(text='\"hello\"').first() == \"hello\"\n\noutput methods\n~~~~~~~~~~~~~~\n\ncalling ``first()`` on the result will run the program with the given input,\nand return the first output element.\n\n.. code-block:: python\n\n    import jq\n\n    assert jq.compile(\".\").input_value(\"hello\").first() == \"hello\"\n    assert jq.compile(\"[.[]+1]\").input_value([1, 2, 3]).first() == [2, 3, 4]\n    assert jq.compile(\".[]+1\").input_value([1, 2, 3]).first() == 2\n\ncall ``text()`` instead of ``first()`` to serialise the output into json text:\n\n.. code-block:: python\n\n    assert jq.compile(\".\").input_value(\"42\").text() == '\"42\"'\n\nwhen calling ``text()``, if there are multiple output elements, each element is represented by a separate line:\n\n.. code-block:: python\n\n    assert jq.compile(\".[]\").input_value([1, 2, 3]).text() == \"1\\n2\\n3\"\n\ncall ``all()`` to get all of the output elements in a list:\n\n.. code-block:: python\n\n    assert jq.compile(\".[]+1\").input_value([1, 2, 3]).all() == [2, 3, 4]\n\ncall ``iter()`` to get all of the output elements as an iterator:\n\n.. code-block:: python\n\n    iterator = iter(jq.compile(\".[]+1\").input_value([1, 2, 3]))\n    assert next(iterator, none) == 2\n    assert next(iterator, none) == 3\n    assert next(iterator, none) == 4\n    assert next(iterator, none) == none\n\narguments\n~~~~~~~~~\n\ncalling ``compile()`` with the ``args`` argument allows predefined variables to be used within the program:\n\n.. code-block:: python\n\n    program = jq.compile(\"$a + $b + .\", args={\"a\": 100, \"b\": 20})\n    assert program.input_value(3).first() == 123\n\nconvenience functions\n~~~~~~~~~~~~~~~~~~~~~\n\nconvenience functions are available to get the output for a program and input in one call:\n\n.. code-block:: python\n\n    assert jq.first(\".[] + 1\", [1, 2, 3]) == 2\n    assert jq.first(\".[] + 1\", text=\"[1, 2, 3]\") == 2\n    assert jq.text(\".[] + 1\", [1, 2, 3]) == \"2\\n3\\n4\"\n    assert jq.all(\".[] + 1\", [1, 2, 3]) == [2, 3, 4]\n    assert list(jq.iter(\".[] + 1\", [1, 2, 3])) == [2, 3, 4]\n\noriginal program string\n~~~~~~~~~~~~~~~~~~~~~~~\n\nthe original program string is available on a compiled program as the ``program_string`` attribute:\n\n.. code-block:: python\n\n    program = jq.compile(\".\")\n    assert program.program_string == \".\"\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd 2-clause",
  "name": "jq",
  "package_url": "https://pypi.org/project/jq/",
  "project_url": "https://pypi.org/project/jq/",
  "project_urls": {
    "Homepage": "https://github.com/mwilliamson/jq.py"
  },
  "release_url": "https://pypi.org/project/jq/1.6.0/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "jq is a lightweight and flexible json processor.",
  "version": "1.6.0",
  "releases": [],
  "developers": [
    "michael_williamson"
  ],
  "kwds": "jqpy_use_system_libs libjq jq pip python",
  "license_kwds": "bsd 2-clause",
  "libtype": "pypi",
  "id": "pypi_jq",
  "homepage": "https://github.com/mwilliamson/jq.py",
  "release_count": 36,
  "dependency_ids": []
}