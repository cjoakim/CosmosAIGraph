{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8"
  ],
  "description": "datetime-glob\n=============\n\n.. image:: https://github.com/parquery/datetime-glob/workflows/check-push/badge.svg\n    :target: https://github.com/parquery/datetime-glob/actions?query=workflow%3acheck-push\n    :alt: check status\n\n.. image:: https://coveralls.io/repos/github/parquery/datetime-glob/badge.svg?branch=master\n    :target: https://coveralls.io/github/parquery/datetime-glob\n    :alt: test coverage\n\n.. image:: https://badge.fury.io/py/datetime-glob.svg\n    :target: https://pypi.org/project/datetime-glob/\n    :alt: pypi - version\n\n.. image:: https://img.shields.io/pypi/pyversions/datetime-glob.svg\n    :target: https://pypi.org/project/datetime-glob/\n    :alt: pypi - python version\n\n\nparses date/times from a path given a glob pattern intertwined with date/time format akin to strptime/strftime format.\n\ndatetime.datetime.strptime suffices for simple date/time parsing. however, as soon as you need to handle wildcards,\nit becomes tricky and you need to resort to regular expressions.\n\nwe found the glob patterns and strptime format to be far easier to read and write than regular expressions, and\nencapsulated the logic involving regular expressions in this module.\n\ninstallation\n============\n\n* create a virtual environment:\n\n.. code-block:: bash\n\n    python3 -m venv venv3\n\n* activate it:\n\n.. code-block:: bash\n\n    source venv3/bin/activate\n\n* install datetime-glob with pip:\n\n.. code-block:: bash\n\n    pip3 install datetime-glob\n\nusage\n=====\nto match a path:\n\n.. code-block:: python\n\n    >>> import datetime_glob\n    >>> matcher = datetime_glob.matcher(pattern='/some/path/*%y-%m-%dt%h-%m-%sz.jpg')\n    >>> match = matcher.match(path='/some/path/some-text2016-07-03t21-22-23z.jpg')\n    >>> match\n    datetime_glob.match(year = 2016, month = 7, day = 3, hour = 21, minute = 22, second = 23)\n\n    >>> match.as_datetime()\n    datetime.datetime(2016, 7, 3, 21, 22, 23)\n    >>> match.as_date()\n    datetime.date(2016, 7, 3)\n    >>> match.as_time()\n    datetime.time(21, 22, 23)\n\nif you specify a directive for the same field twice, the matcher will make sure that the field has the same semantical\nvalue in order to match:\n\n.. code-block:: python\n\n    >>> import datetime_glob\n    >>> matcher = datetime_glob.matcher(pattern='/some/path/%y/%y-%m-%d.txt')\n\n    >>> match = matcher.match(path='/some/path/16/2016-07-03.txt')\n    >>> match\n    datetime_glob.match(year = 2016, month = 7, day = 3)\n\n    >>> match = matcher.match(path='/some/path/19/2016-07-03.txt')\n    >>> type(match)\n    <class 'nonetype'>\n\nyou can walk the pattern on the file system:\n\n.. code-block:: python\n\n    import datetime_glob\n    for match, path in datetime_glob.walk(pattern='/some/path/*%y/%m/%d/%h-%m-%sz.jpg'):\n        dtime = match.as_datetime()\n        print(dtime, path)\n    2016-03-04 12:13:14 /some/path/saved-2016/03/04/12-13-14z.jpg\n    2017-11-23 22:23:24 /some/path/restored-2017/11/23/22-23-24z.jpg\n\nto iterate manually over a tree, and match incrementally each path segment by yourself:\n\n.. code-block:: python\n\n    >>> import datetime_glob\n    >>> pattern_segments = datetime_glob.parse_pattern(pattern='/some/path/*%y/%m/%d/%h-%m-%sz.jpg')\n    >>> match = datetime_glob.match()\n\n    >>> match=datetime_glob.match_segment(segment='some', pattern_segment=pattern_segments[0], match=match)\n    >>> match\n    datetime_glob.match()\n\n    >>> match=datetime_glob.match_segment(segment='path', pattern_segment=pattern_segments[1], match=match)\n    >>> match\n    datetime_glob.match()\n\n    >>> match=datetime_glob.match_segment(segment='some-text2016', pattern_segment=pattern_segments[2], match=match)\n    >>> match\n    datetime_glob.match(year = 2016)\n\n    >>> match=datetime_glob.match_segment(segment='07', pattern_segment=pattern_segments[3], match=match)\n    >>> match\n    datetime_glob.match(year = 2016, month = 7)\n\n    >>> match=datetime_glob.match_segment(segment='03', pattern_segment=pattern_segments[4], match=match)\n    >>> match\n    datetime_glob.match(year = 2016, month = 7, day = 3)\n\n    >>> match=datetime_glob.match_segment(segment='21-22-23z.jpg', pattern_segment=pattern_segments[5], match=match)\n    >>> match\n    datetime_glob.match(year = 2016, month = 7, day = 3, hour = 21, minute = 22, second = 23)\n\n\nsupported strftime directives\n=============================\n(subset from https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior)\n\n=========   =========================================================   ==========================\ndirective   meaning                                                     example\n=========   =========================================================   ==========================\n%d          day of the month as a zero-padded decimal number.           01, 02, \u2026, 31\n%-d         day of the month as a decimal number.                       1, 2, \u2026, 31\n%m          month as a zero-padded decimal number.                      01, 02, \u2026, 12\n%-m         month as a  decimal number.                                 1, 2, \u2026, 12\n%y          year without century as a zero-padded decimal number.       00, 01, \u2026, 99\n%y          year with century as a decimal number.                      1970, 1988, 2001, 2013\n%h          hour (24-hour clock) as a zero-padded decimal number.       00, 01, \u2026, 23\n%-h         hour (24-hour clock) as a decimal number.                   0, 1, \u2026, 23\n%m          minute as a zero-padded decimal number.                     00, 01, \u2026, 59\n%-m         minute as a decimal number.                                 0, 1, \u2026, 59\n%s          second as a zero-padded decimal number.                     00, 01, \u2026, 59\n%-s         second as a decimal number.                                 0, 1, \u2026, 59\n%f          microsecond as a decimal number, zero-padded on the left.   000000, 000001, \u2026, 999999\n%%          a literal '%' character.                                    %\n=========   =========================================================   ==========================\n\ndevelopment\n===========\n\n* check out the repository.\n\n* in the repository root, create the virtual environment:\n\n.. code-block:: bash\n\n    python3 -m venv venv3\n\n* activate the virtual environment:\n\n.. code-block:: bash\n\n    source venv3/bin/activate\n\n* install the development dependencies:\n\n.. code-block:: bash\n\n    pip3 install -e .[dev]\n\n* run `precommit.py` to execute pre-commit checks locally.",
  "docs_url": null,
  "keywords": "date time datetime parse glob pattern strptime wildcards",
  "license": "",
  "name": "datetime-glob",
  "package_url": "https://pypi.org/project/datetime-glob/",
  "project_url": "https://pypi.org/project/datetime-glob/",
  "project_urls": {
    "Homepage": "https://github.com/Parquery/datetime-glob"
  },
  "release_url": "https://pypi.org/project/datetime-glob/1.0.8/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "parse date/time from paths using glob wildcard pattern intertwined with date/time format",
  "version": "1.0.8",
  "releases": [],
  "developers": [
    "marko.ristin@gmail.com",
    "marko_ristin"
  ],
  "kwds": "datetime_glob strptime as_datetime datetime strftime",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_datetime_glob",
  "homepage": "https://github.com/parquery/datetime-glob",
  "release_count": 9,
  "dependency_ids": []
}