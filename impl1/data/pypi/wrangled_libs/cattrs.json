{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "typing :: typed"
  ],
  "description": "# cattrs\n\n<a href=\"https://pypi.python.org/pypi/cattrs\"><img src=\"https://img.shields.io/pypi/v/cattrs.svg\"/></a>\n<a href=\"https://github.com/python-attrs/cattrs/actions?workflow=ci\"><img src=\"https://github.com/python-attrs/cattrs/workflows/ci/badge.svg\"/></a>\n<a href=\"https://catt.rs/en/latest/?badge=latest\"><img src=\"https://readthedocs.org/projects/cattrs/badge/?version=latest\" alt=\"documentation status\"/></a>\n<a href=\"https://github.com/python-attrs/cattrs\"><img src=\"https://img.shields.io/pypi/pyversions/cattrs.svg\" alt=\"supported python versions\"/></a>\n<a href=\"https://github.com/python-attrs/cattrs/actions/workflows/main.yml\"><img src=\"https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/tinche/22405310d6a663164d894a2beab4d44d/raw/covbadge.json\"/></a>\n<a href=\"https://github.com/psf/black\"><img src=\"https://img.shields.io/badge/code%20style-black-000000.svg\"/></a>\n\n---\n\n**cattrs** is an open source python library for structuring and unstructuring\ndata. _cattrs_ works best with _attrs_ classes, dataclasses and the usual\npython collections, but other kinds of classes are supported by manually\nregistering converters.\n\npython has a rich set of powerful, easy to use, built-in data types like\ndictionaries, lists and tuples. these data types are also the lingua franca\nof most data serialization libraries, for formats like json, msgpack, cbor,\nyaml or toml.\n\ndata types like this, and mappings like `dict` s in particular, represent\nunstructured data. your data is, in all likelihood, structured: not all\ncombinations of field names or values are valid inputs to your programs. in\npython, structured data is better represented with classes and enumerations.\n_attrs_ is an excellent library for declaratively describing the structure of\nyour data, and validating it.\n\nwhen you're handed unstructured data (by your network, file system, database...),\n_cattrs_ helps to convert this data into structured data. when you have to\nconvert your structured data into data types other libraries can handle,\n_cattrs_ turns your classes and enumerations into dictionaries, integers and\nstrings.\n\nhere's a simple taste. the list containing a float, an int and a string\ngets converted into a tuple of three ints.\n\n```python\n>>> import cattrs\n\n>>> cattrs.structure([1.0, 2, \"3\"], tuple[int, int, int])\n(1, 2, 3)\n```\n\n_cattrs_ works well with _attrs_ classes out of the box.\n\n```python\n>>> from attrs import frozen\n>>> import cattrs\n\n>>> @frozen  # it works with non-frozen classes too.\n... class c:\n...     a: int\n...     b: str\n\n>>> instance = c(1, 'a')\n>>> cattrs.unstructure(instance)\n{'a': 1, 'b': 'a'}\n>>> cattrs.structure({'a': 1, 'b': 'a'}, c)\nc(a=1, b='a')\n```\n\nhere's a much more complex example, involving `attrs` classes with type\nmetadata.\n\n```python\n>>> from enum import unique, enum\n>>> from typing import optional, sequence, union\n>>> from cattrs import structure, unstructure\n>>> from attrs import define, field\n\n>>> @unique\n... class catbreed(enum):\n...     siamese = \"siamese\"\n...     maine_coon = \"maine_coon\"\n...     sacred_birman = \"birman\"\n\n>>> @define\n... class cat:\n...     breed: catbreed\n...     names: sequence[str]\n\n>>> @define\n... class dogmicrochip:\n...     chip_id = field()  # type annotations are optional, but recommended\n...     time_chipped: float = field()\n\n>>> @define\n... class dog:\n...     cuteness: int\n...     chip: optional[dogmicrochip] = none\n\n>>> p = unstructure([dog(cuteness=1, chip=dogmicrochip(chip_id=1, time_chipped=10.0)),\n...                  cat(breed=catbreed.maine_coon, names=('fluffly', 'fluffer'))])\n\n>>> print(p)\n[{'cuteness': 1, 'chip': {'chip_id': 1, 'time_chipped': 10.0}}, {'breed': 'maine_coon', 'names': ('fluffly', 'fluffer')}]\n>>> print(structure(p, list[union[dog, cat]]))\n[dog(cuteness=1, chip=dogmicrochip(chip_id=1, time_chipped=10.0)), cat(breed=<catbreed.maine_coon: 'maine_coon'>, names=['fluffly', 'fluffer'])]\n```\n\nconsider unstructured data a low-level representation that needs to be converted\nto structured data to be handled, and use `structure`. when you're done,\n`unstructure` the data to its unstructured form and pass it along to another\nlibrary or module. use [attrs type metadata](http://attrs.readthedocs.io/en/stable/examples.html#types)\nto add type metadata to attributes, so _cattrs_ will know how to structure and\ndestructure them.\n\n- free software: mit license\n- documentation: https://catt.rs\n- python versions supported: 3.8 and up. (older python versions are supported by older versions; see the changelog.)\n\n## features\n\n- converts structured data into unstructured data, recursively:\n\n  - _attrs_ classes and dataclasses are converted into dictionaries in a way similar to `attrs.asdict`, or into tuples in a way similar to `attrs.astuple`.\n  - enumeration instances are converted to their values.\n  - other types are let through without conversion. this includes types such as\n    integers, dictionaries, lists and instances of non-_attrs_ classes.\n  - custom converters for any type can be registered using `register_unstructure_hook`.\n\n- converts unstructured data into structured data, recursively, according to\n  your specification given as a type. the following types are supported:\n\n  - `typing.optional[t]`.\n  - `typing.list[t]`, `typing.mutablesequence[t]`, `typing.sequence[t]` (converts to a list).\n  - `typing.tuple` (both variants, `tuple[t, ...]` and `tuple[x, y, z]`).\n  - `typing.mutableset[t]`, `typing.set[t]` (converts to a set).\n  - `typing.frozenset[t]` (converts to a frozenset).\n  - `typing.dict[k, v]`, `typing.mutablemapping[k, v]`, `typing.mapping[k, v]` (converts to a dict).\n  - `typing.typeddict`.\n  - _attrs_ classes with simple attributes and the usual `__init__`.\n\n    - simple attributes are attributes that can be assigned unstructured data,\n      like numbers, strings, and collections of unstructured data.\n\n  - all _attrs_ classes and dataclasses with the usual `__init__`, if their complex attributes have type metadata.\n  - `typing.union` s of supported _attrs_ classes, given that all of the classes have a unique field.\n  - `typing.union` s of anything, given that you provide a disambiguation function for it.\n  - custom converters for any type can be registered using `register_structure_hook`.\n\n_cattrs_ comes with preconfigured converters for a number of serialization libraries, including json, msgpack, cbor2, bson, yaml and toml.\nfor details, see the [cattrs.preconf package](https://catt.rs/en/stable/preconf.html).\n\n## design decisions\n\n_cattrs_ is based on a few fundamental design decisions.\n\n- un/structuring rules are separate from the models.\n  this allows models to have a one-to-many relationship with un/structuring rules, and to create un/structuring rules for models which you do not own and you cannot change.\n  (_cattrs_ can be configured to use un/structuring rules from models using the [`use_class_methods` strategy](https://catt.rs/en/latest/strategies.html#using-class-specific-structure-and-unstructure-methods).)\n- invent as little as possible; reuse existing ordinary python instead.\n  for example, _cattrs_ did not have a custom exception type to group exceptions until the sanctioned python [`exceptiongroups`](https://docs.python.org/3/library/exceptions.html#exceptiongroup).\n  a side-effect of this design decision is that, in a lot of cases, when you're solving _cattrs_ problems you're actually learning python instead of learning _cattrs_.\n- refuse the temptation to guess.\n  if there are two ways of solving a problem, _cattrs_ should refuse to guess and let the user configure it themselves.\n\na foolish consistency is the hobgoblin of little minds so these decisions can and are sometimes broken, but they have proven to be a good foundation.\n\n## additional documentation and talks\n\n- [on structured and unstructured data, or the case for cattrs](https://threeofwands.com/on-structured-and-unstructured-data-or-the-case-for-cattrs/)\n- [why i use attrs instead of pydantic](https://threeofwands.com/why-i-use-attrs-instead-of-pydantic/)\n- [cattrs i: un/structuring speed](https://threeofwands.com/why-cattrs-is-so-fast/)\n- [python has a macro language - it's python (pycon it 2022)](https://www.youtube.com/watch?v=uyrsixikuto)\n- [intro to cattrs 23.1](https://threeofwands.com/intro-to-cattrs-23-1-0/)\n\n## credits\n\nmajor credits to hynek schlawack for creating [attrs](https://attrs.org) and its predecessor, [characteristic](https://github.com/hynek/characteristic).\n\n_cattrs_ is tested with [hypothesis](http://hypothesis.readthedocs.io/en/latest/), by david r. maciver.\n\n_cattrs_ is benchmarked using [perf](https://github.com/haypo/perf) and [pytest-benchmark](https://pytest-benchmark.readthedocs.io/en/latest/index.html).\n\nthis package was created with [cookiecutter](https://github.com/audreyr/cookiecutter) and the [`audreyr/cookiecutter-pypackage`](https://github.com/audreyr/cookiecutter-pypackage) project template.\n",
  "docs_url": null,
  "keywords": "attrs,dataclasses,serialization",
  "license": "mit",
  "name": "cattrs",
  "package_url": "https://pypi.org/project/cattrs/",
  "project_url": "https://pypi.org/project/cattrs/",
  "project_urls": {
    "Bug Tracker": "https://github.com/python-attrs/cattrs/issues",
    "Changelog": "https://catt.rs/en/latest/history.html",
    "Documentation": "https://catt.rs/en/stable/",
    "Homepage": "https://catt.rs",
    "Repository": "https://github.com/python-attrs/cattrs"
  },
  "release_url": "https://pypi.org/project/cattrs/23.2.3/",
  "requires_dist": [
    "attrs>=23.1.0",
    "exceptiongroup>=1.1.1; python_version < '3.11'",
    "typing-extensions!=4.6.3,>=4.1.0; python_version < '3.11'",
    "pymongo>=4.4.0; extra == 'bson'",
    "cbor2>=5.4.6; extra == 'cbor2'",
    "msgpack>=1.0.5; extra == 'msgpack'",
    "orjson>=3.9.2; implementation_name == 'cpython' and extra == 'orjson'",
    "pyyaml>=6.0; extra == 'pyyaml'",
    "tomlkit>=0.11.8; extra == 'tomlkit'",
    "ujson>=5.7.0; extra == 'ujson'"
  ],
  "requires_python": ">=3.8",
  "summary": "composable complex class support for attrs and dataclasses.",
  "version": "23.2.3",
  "releases": [],
  "developers": [
    "tinchester@gmail.com"
  ],
  "kwds": "_attrs_ badge _cattrs_ python documentation",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_cattrs",
  "homepage": "",
  "release_count": 33,
  "dependency_ids": [
    "pypi_attrs",
    "pypi_cbor2",
    "pypi_exceptiongroup",
    "pypi_msgpack",
    "pypi_orjson",
    "pypi_pymongo",
    "pypi_pyyaml",
    "pypi_tomlkit",
    "pypi_typing_extensions!",
    "pypi_ujson"
  ]
}