{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "========\njson-cfg\n========\n\n.. image:: https://img.shields.io/travis/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://travis-ci.org/pasztorpisti/json-cfg\n    :alt: build\n\n.. image:: https://img.shields.io/codacy/25854a088e89472f9fbf2bd5c1633834.svg?style=flat\n    :target: https://www.codacy.com/app/pasztorpisti/json-cfg\n    :alt: code quality\n\n.. image:: https://landscape.io/github/pasztorpisti/json-cfg/master/landscape.svg?style=flat\n    :target: https://landscape.io/github/pasztorpisti/json-cfg/master\n    :alt: code health\n\n.. image:: https://img.shields.io/coveralls/pasztorpisti/json-cfg/master.svg?style=flat\n    :target: https://coveralls.io/r/pasztorpisti/json-cfg?branch=master\n    :alt: coverage\n\n.. image:: https://img.shields.io/pypi/v/json-cfg.svg?style=flat\n    :target: https://pypi.python.org/pypi/json-cfg\n    :alt: pypi\n\n.. image:: https://img.shields.io/github/tag/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://github.com/pasztorpisti/json-cfg\n    :alt: github\n\n.. image:: https://img.shields.io/github/license/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://github.com/pasztorpisti/json-cfg/blob/master/license.txt\n    :alt: license: mit\n\n.. contents::\n\n------------\nintroduction\n------------\n\nthe goal of this library is providing a json config file loader that has\nthe following extras compared to the standard ``json.load()``:\n\n- a larger subset of javascript (and not some weird/exotic extension to json that\n  would turn it into something that has nothing to do with json/javascript):\n\n    - backward compatible with json so you can still load standard json files too\n    - single and multi-line comments - this is more useful then you would think:\n      it is good not only for documentation but also for temporarily disabling\n      a block in your config without actually deleting entries\n    - object (dictionary) keys without quotes: less quotation marks, less noise\n    - trailing commas (allowing a comma after the last item of objects and arrays)\n\n- providing line number information for each element of the loaded config file\n  and using this to display useful error messages that help locating errors not\n  only while parsing the file but also when processing/interpreting it.\n- a simple config query syntax that handles default values, required elements and\n  automatically raises an exception in case of error (with useful info including\n  the location of the error in the config file).\n\n\nconfig file examples\n--------------------\n\na traditional json config file:\n\n.. code-block:: javascript\n\n    {\n        \"servers\": [\n            {\n                \"ip_address\": \"127.0.0.1\",\n                \"port\": 8080\n            },\n            {\n                \"ip_address\": \"127.0.0.1\",\n                \"port\": 8081\n            }\n        ],\n        \"superuser_name\": \"tron\"\n    }\n\nsomething similar but better with json-cfg:\n\n.. code-block:: javascript\n\n    {\n        // note that we can get rid of most quotation marks.\n        servers: [\n            {\n                ip_address: \"127.0.0.1\",\n                port: 8080\n            },\n            // we have commented out the block of the second server below.\n            // trailing commas are allowed so the comma after the\n            // first block (above) doesn't cause any problems.\n            /*\n            {\n                ip_address: \"127.0.0.1\",\n                port: 8081\n            },  // <-- optional trailing comma\n            /**/\n        ],\n        superuser_name: \"tron\",  // <-- optional trailing comma\n    }\n\nnote that json-cfg can load both config files because standard json is a subset of the extended\nsyntax allowed by json-cfg.\n\n.. tip::\n\n    use javascript syntax highlight in your text editor for json config files\n    whenever possible - this makes reading config files much easier especially\n    when you have a lot of comments or large commented config blocks.\n\n-----\nusage\n-----\n\ninstallation\n------------\n\n.. code-block:: sh\n\n    pip install json-cfg\n\nalternatively you can download the zipped library from https://pypi.python.org/pypi/json-cfg\n\nquick-starter\n-------------\n\nthe json-cfg library provides two modes when it comes to loading config files: one that is very\nsimilar to the standard ``json.loads()`` and another one that returns the json wrapped into special\nconfig nodes that make handling the config file much easier:\n\n- ``jsoncfg.load()`` and ``jsoncfg.loads()`` are very similar to the standard ``json.loads()``.\n  these functions allow you to load config files into bare python representation of the json\n  data (dictionaries, lists, numbers, etc...).\n- ``jsoncfg.load_config()`` and ``jsoncfg.loads_config()`` load the json data into special wrapper\n  objects that help you to query the config with much nicer syntax. at the same time if you\n  are looking for a value that doesn't exist in the config then these problems are handled with\n  exceptions that contain line/column number info about the location of the error.\n\none of the biggest problems with loading the config into bare python objects with a simple json\nlibrary is that the loaded json data doesn't contain the line/column numbers for the loaded json\nnodes/elements. this means that by using a simple json library you can report the location of errors\nwith config file line/column numbers only in case of json syntax errors (in best case).\nby loading the json nodes/elements into our wrapper objects we can retain the line/column numbers\nfor the json nodes/elements and we can use them in our error messages in case of semantic errors.\n\ni assume that you have already installed json-cfg and you have the previously shown server config\nexample in a ``server.cfg`` file in the current directory.\n\nthis is how to load and process the above server configuration with a simple json library:\n\n.. code-block:: python\n\n    import json\n\n    with open('server.cfg') as f:\n        config = json.load(f)\n    for server in config['servers']:\n        listen_on_interface(server['ip_address'], server.get('port', 8000))\n    superuser_name = config['superuser_name']\n\nthe same with json-cfg:\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n    for server in config.servers:\n        listen_on_interface(server.ip_address(), server.port(8000))\n    superuser_name = config.superuser_name()\n\nseemingly the difference isn't that big. with json-cfg you can use extended syntax in the config\nfile and the code that loads/processes the config is also somewhat nicer but real difference is\nwhat happens when you encounter an error. with json-cfg you get an exception with a message that\npoints to the problematic part of the json config file while the pure-json example can't tell you\nline/column numbers in the config file. in case of larger configs this can cause headaches.\n\nopen your ``server.cfg`` file and remove the required ``ip_address`` attribute from one of the server\nconfig blocks. this will cause an error when we try to load the config file with the above code\nexamples. the above code snippets report the following error messages in this scenario:\n\njson:\n\n.. code-block::\n\n    keyerror: 'ip_address'\n\njson-cfg:\n\n.. code-block::\n\n    jsoncfg.config_classes.jsonconfigvaluenotfounderror: required config node not found. missing query path: .ip_address (relative to error location) [line=3;col=9]\n\ndetailed explanation of the library interface\n---------------------------------------------\n\nwhen you load your json with ``jsoncfg.load_config()`` or ``jsoncfg.loads_config()`` the returned json\ndata - the hierarchy - is a tree of wrapper objects provided by this library. these wrapper objects\nmake it possible to store the column/line numbers for each json node/element (for error reporting)\nand these wrappers allow you to query the config with the nice syntax you've seen above.\n\nthis library differentiates 3 types of json nodes/elements and each of these have their own wrapper\nclasses:\n\n- json object (dictionary like stuff)\n- json array (list like stuff)\n- json scalar (i use \"scalar\" to refer any json value that isn't a container)\n\ni use *json value* to refer to any json node/element whose type is unknown or unimportant.\nthe public api of the wrapper classes is very simple: they have no public methods. all they provide\nis a few magic methods that you can use to read/query the loaded json data. (these magic methods\nare ``__contains__``, ``__getattr__``, ``__getitem__``, ``__len__``, ``__iter__`` and ``__call__`` but don't\nworry if you don't know about these magic methods as i will demonstrate the usage with simple code\nexamples that don't assume that you know them.)\nthe reason for having no public methods is simple: we allow querying json object keys with\n``__getattr__`` (with the dot or member access operator like ``config.myvalue``) and we don't want any\npublic methods to conflict with the key values in your config file.\n\nafter loading the config you have a tree of wrapper object nodes and you have to perform these two\noperations to get values from the config:\n\n1. querying/reading/traversing the json hierarchy: the result of querying is a wrapper object\n2. fetching the python value from the selected wrapper object: this can be done by calling the\n   queried wrapper object.\n\nthe following sections explain these two operations in detail.\n\nquerying the json config hierarchy\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nto read and query the json hierarchy and the wrapper object nodes that build up the tree you have\nto exploit the ``__contains__``, ``__getattr__``, ``__getitem__``, ``__len__``, ``__iter__`` magic methods\nof the wrapper objects. we will use the previously shown server config for the following examples.\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # using __getattr__ to get the servers key from the config json object.\n    # the result of this expression is a wrapper object that wraps the servers array/list.\n    server_array = config.servers\n\n    # the equivalent of the previous expression using __getitem__:\n    server_array = config['servers']\n\n    # note that querying a non-existing key from an object doesn't raise an error. instead\n    # it returns a special valuenotfoundnode instance that you can continue using as a\n    # wrapper object. the error happens only if you try to fetch the value of this key\n    # without specifying a default value - but more on this later in the section where we\n    # discuss value fetching from wrapper objects.\n    special_value_not_found_node = config.non_existing_key\n\n    # checking whether a key exists in a json object:\n    servers_exists = 'servers' in config\n\n    # using __getitem__ to index into json array wrapper objects:\n    # over-indexing the array would raise an exception with useful error message\n    # containing the location of the servers_array in the config file.\n    first_item_wrapper_object = servers_array[0]\n\n    # getting the length of json object and json array wrappers:\n    num_config_key_value_pairs = len(config)\n    servers_array_len = len(servers_array)\n\n    # iterating the items of a json object or array:\n    for key_string, value_wrapper_object in config:\n        pass\n    for value_wrapper_object in config.servers:\n        pass\n\nnot all node types (object, array, scalar) support all operations. for example a scalar json value\ndoesn't support ``len()`` and you can not iterate it. what happens if someone puts a scalar value\ninto the config in place of the servers array? in that case the config loader code sooner or\nlater performs an array-specific operation on that scalar value (for example iteration) and this\nraises an exception with a useful error message pointing the the loader code with the stack trace\nand pointing to the scalar value in the config file with line/column numbers. you can find more info\nabout json-node-type related checks and error handling mechanisms in the following sections (value\nfetching and error handling).\n\nfetching python values from the queried wrapper objects\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nafter selecting any of the wrapper object nodes from the json config hierarchy you can fetch its\nwrapped value by using its ``__call__`` magic method. this works on all json node types: objects,\narrays and scalars. if you fetch a container (object or array) then this fetch is recursive: it\nfetches the whole subtree whose root node is the fetched wrapper object. in most cases it is a\ngood practice to fetch only leaf nodes of the config. leaving the containers (objects, arrays) in\nwrappers helps getting better error messages if something goes wrong while you are processing the\nconfig data.\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # fetching the value of the whole json object hierarchy.\n    # python_hierarchy now looks like something you normally\n    # get as a result of a standard ``json.load()``.\n    python_hierarchy = config()\n\n    # converting only the servers array into python-object format:\n    python_server_list = config.servers()\n\n    # getting the ip_address of the first server.\n    server_0_ip_address_str = config.servers[0].ip_address()\n\n\nfetching optional config values (by specifying a default value)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe value fetcher call has some optional parameters. you can call it with an optional default value\nfollowed by zero or more ``jsoncfg.jsonvaluemapper`` instances. the default value comes in handy when\nyou are querying an **optional** item from a json object:\n\n.. code-block:: python\n\n    # if \"optional_value\" isn't in the config then return the default value (50).\n    v0 = config.optional_value(50)\n\n    # this raises an exception if \"required_value\" isn't in the config.\n    v1 = config.required_value()\n\n\nusing value mappers to validate and/or transform fetched values\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwhether you are using a default value or not you can specify zero or more ``jsoncfg.jsonvaluemapper``\ninstances too in the parameter list of the fetcher function call. these instances have to be\ncallable, they have to have a ``__call__`` method that receives one parameter - the fetched value -\nand they have to return the transformed (or untouched) value. if you specify more than one value\nmapper instances then these value mappers are applied to the fetched value in left-to-right order\nas you specify them in the argument list. you can use these value mapper instances not only to\ntransform the fetched value, but also to perform (type) checks on them. the ``jsoncfg.value_mappers``\nmodule contains a few predefined type-checkers but you can create your own value mappers.\n\n.. warning::\n\n    if you specify both a default value and one or more value mapper instances in your value fetcher\n    call then the value mappers are never applied to the default value. the value mappers are used\n    only when you fetch a value that exists in the config. json-cfg uses either the default value\n    or the list of value mapper instances but not both.\n\n.. code-block:: python\n\n    from jsoncfg.value_mappers import requiretype\n    from jsoncfg.value_mappers import require_list, require_string, require_integer, require_number\n\n    # require_list is a jsoncfg.jsonvaluemapper instance that checks if the fetched value is a list.\n    # if the \"servers\" key is missing form the config or its type isn't list then an exception is\n    # raised because we haven't specified a default value.\n    python_server_list = config.servers(require_list)\n\n    # if the \"servers\" key is missing from the config then the return value is none. if \"servers\"\n    # is in the config and it isn't a list instance then an exception is raised otherwise the\n    # return value is the servers list.\n    python_server_list = config.servers(none, require_list)\n\n    # querying the required ip_address parameter with required string type.\n    ip_address = config.servers[0].ip_address(require_string)\n\n    # querying the optional port parameter with a default value of 8000.\n    # if the optional port parameter is specified in the config then it has to be an integer.\n    ip_address = config.servers[0].port(8000, require_integer)\n\n    # an optional timeout parameter with a default value of 5. if the timeout parameter is in\n    # the config then it has to be a number (int, long, or float).\n    timeout = config.timeout(5, require_number)\n\n    # getting a required guest_name parameter from the config. the parameter has to be either\n    # none (null in the json file) or a string.\n    guest_name = config.guest_name(requiretype(type(none), str))\n\n\nwriting a custom value mapper (or validator)\n````````````````````````````````````````````\n\n- derive your own value mapper class from ``jsoncfg.jsonvaluemapper``.\n- implement the ``__call__`` method that receives one value and returns one value:\n\n    - your ``__call__`` method can return the received value intact but it is allowed to\n      return a completely different transformed value.\n    - your ``__call__`` implementation can perform validation. if the validation fails then\n      you have to raise an exception. this exception can be anything but if you don't have\n      a better idea then simply use the standard ``valueerror`` or ``typeerror``. this exception\n      is caught by the value fetcher call and re-raised as another json-cfg specific\n      exception that contains useful error message with the location of the error and that\n      exception also contains the exception you raised while validating.\n\ncustom value mapper example code:\n\n.. code-block:: python\n\n    import datetime\n    import jsoncfg\n    from jsoncfg import jsonvaluemapper\n    from jsoncfg.value_mappers import require_integer\n\n    class oneof(jsonvaluemapper):\n        def __init__(self, *enum_members):\n            self.enum_members = set(enum_members)\n\n        def __call__(self, v):\n            if v not in self.enum_members:\n                raise valueerror('%r is not one of these: %r' % (v, self.enum_members))\n            return v\n\n    class rangecheck(jsonvaluemapper):\n        def __init__(self, min_, max_):\n            self.min = min_\n            self.max = max_\n\n        def __call__(self, v):\n            if self.min <= v < self.max:\n                return v\n            raise valueerror('%r is not in range [%r, %r)' % (v, self.min, self.max))\n\n    class todatetime(jsonvaluemapper):\n        def __call__(self, v):\n            if not isinstance(v, str):\n                raise typeerror('expected a naive iso8601 datetime string but found %r' % (v,))\n            return datetime.datetime.strptime(v, '%y-%m-%dt%h:%m:%s')\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # creating a value mapper instance for reuse.\n    require_cool_superuser_name = oneof('tron', 'neo')\n    superuser_name = config.superuser_name(none, require_cool_superuser_name)\n\n    check_http_port_range = rangecheck(8000, 9000)\n    port = config.servers[0].port(8000, check_http_port_range)\n\n    # chaining value mappers. first require_integer receives the value of the port\n    # attribute, checks/transforms it and the output of require_integer goes\n    # to the check_http_port_range value mapper. what you receive as a result of\n    # value fetching is the output of check_http_port_range.\n    port = config.servers[0].port(require_integer, check_http_port_range)\n\n    # to_datetime converts a naive iso8601 datetime string into a datetime instance.\n    to_datetime = todatetime()\n    superuser_birthday = config.superuser_birthday(none, to_datetime)\n\n\nerror handling: exceptions\n--------------------------\n\nthe base of all library exceptions is ``jsoncfg.jsonconfigexception``. if the parsed json contains a\nsyntax error then you receive a ``jsoncfg.jsonconfigparserexception`` - this exception has no\nsubclasses. in case of config query errors you receive a ``jsoncfg.jsonconfigqueryerror`` - this\nexception has several subclasses.\n\n.. code-block::\n\n                         +---------------------+\n                         | jsonconfigexception |\n                         +---------------------+\n                            ^               ^\n                            |               |\n        +-------------------+-------+       |\n        | jsonconfigparserexception |       |\n        +---------------------------+       |\n                                      +-----+----------------+\n              +---------------------->| jsonconfigqueryerror |<------------------------+\n              |                       +----------------------+                         |\n              |                          ^                ^                            |\n              |                          |                |                            |\n              |   +----------------------+-----+    +-----+------------------------+   |\n              |   | jsonconfigvaluemappererror |    | jsonconfigvaluenotfounderror |   |\n              |   +----------------------------+    +------------------------------+   |\n              |                                                                        |\n        +-----+-------------------+                                   +----------------+-----+\n        | jsonconfignodetypeerror |                                   | jsonconfigindexerror |\n        +-------------------------+                                   +----------------------+\n\njsoncfg.\\ **jsonconfigexception**\n\n    this is the mother of all exceptions raised by the library (aside from some some ``valueerror``s\n    and ``typeerrors`` that are raised in case of trivial programming mistakes). note that this\n    exception is never raised directly - the library raises only exceptions that are derived from\n    this.\n\njsoncfg.\\ **jsonconfigparserexception**\n\n    you receive this exception if there is a syntax error in the parsed json.\n\n    - ``error_message``: the error message without the line/column number\n      info. the standard ``exception.message`` field contains this very same message but with the\n      line/column info formatted into it as a postfix.\n    - ``line``, ``column``: line and column information to locate the error easily in the parsed json.\n\njsoncfg.\\ **jsonconfigqueryerror**\n\n    you receive this exception in case of errors you make while processing the parsed json. this\n    exception class is never instantiated directly, only its subclasses are used.\n\n    - ``config_node``: the json node/element that was processed when the error happened.\n    - ``line``, ``column``: line and column information to locate the error easily in the parsed json.\n\njsoncfg.\\ **jsonconfigvaluemappererror**\n\n    raised when you query and fetch a value by specifying a value mapper but the value mapper\n    instance raises an exception during while fetching the value.\n\n    - ``mapper_exception``: the exception instance raised by the value mapper.\n\njsoncfg.\\ **jsonconfigvaluenotfounderror**\n\n    this is raised when you try to fetch a required (non-optional) value that doesn't exist in the\n    config file.\n\njsoncfg.\\ **jsonconfignodetypeerror**\n\n    you get this exception if you try to perform an operation on a node that is not allowed for\n    that node type (object, array or scalar), for example indexing into an array with a string.\n\njsoncfg.\\ **jsonconfigindexerror**\n\n    over-indexing a json array results in this exception.\n\n    - ``index``: the index used to over-index the array.\n\nutility functions\n-----------------\n\nthe config wrapper objects have no public methods but in some cases you may want to extract some info from them\n(for example line/column number, type of node). you can do that with utility functions that can be imported from\nthe ``jsoncfg`` module.\n\n\njsoncfg.\\ **node_location**\\ *(config_node)*\n\n    returns the location of the specified config node in the file it was parsed from. the returned location is a\n    named tuple ``nodelocation(line, column)`` containing the 1-based line and column numbers.\n\njsoncfg.\\ **node_exists**\\ *(config_node)*\n\n    the library doesn't raise an error if you query a non-existing key. it raises error only when you try to fetch\n    a value from it. querying a non-existing key returns a special ``valuenotfoundnode`` instance and this function\n    actually checks whether the node is something else than a ``valuenotfoundnode`` instance. a node can be\n    any part of the json: an object/dict, a list, or any other json value. before trying to fetch a value from the\n    queried node you can test the result of a query with ``node_exists()`` whether it is an existing or non-existing\n    node in order to handle missing/optional config blocks gracefully without exceptions.\n\n    .. code-block:: python\n\n        from jsoncfg import load_config, node_exists\n\n        config = load_config('my_config.cfg')\n        if node_exists(config.whatever1.whatever2.whatever3):\n            ...\n\n        # or an equivalent piece of code:\n\n        node = config.whatever1.whatever2.whatever3\n        if node_exists(node):\n            ...\n\n        # this node_exists() call returns true:\n        exists_1 = node_exists(config.existing_key1.existing_key2.existing_key3)\n\n        # this node_exists() call returns false:\n        exists_2 = node_exists(config.non_existing_key1.non_existing_key2)\n\n\njsoncfg.\\ **node_is_object**\\ *(config_node)*\n\n    returns ``true`` if the specified ``config_node`` is a json object/dict.\n\n\njsoncfg.\\ **node_is_array**\\ *(config_node)*\n\n    returns ``true`` if the specified ``config_node`` is a json array/list.\n\n\njsoncfg.\\ **node_is_scalar**\\ *(config_node)*\n\n    returns ``true`` if the specified ``config_node`` is a json value other than an object or array - if it isn't a\n    container.\n\n\njsoncfg.\\ **ensure_exists**\\ *(config_node)*\n\n    returns the specified ``config_node`` if it is an existing node, otherwise it raises a config error (with\n    config file location info when possible).\n\n\njsoncfg.\\ **expect_object**\\ *(config_node)*\n\n    returns the specified ``config_node`` if it is a json object/dict, otherwise it raises a config error (with\n    config file location info when possible).\n\n    in many cases you can just query and fetch objects using jsoncfg without doing explicit error handling and\n    jsoncfg provides useful error messages when an error occurs (like trying the fetch the value from a non-existing\n    node, trying to map a non-integer value to an integer, etc...). there is however at least one exception when\n    jsoncfg can't really auto-detect problems in a smart way: when you iterate over a json object or array. a json\n    object returns `(key, value)` pairs during iteration while an array returns simple items. if you just assume\n    (without actually checking) that a config node is a json object/dict and you iterate over it with auto-unpacking\n    the returned `(key, value)` pairs into two variables then you might get into trouble if your assumption is\n    incorrect and the actual config node is a json array. if it is an array then it will return simple items and\n    python fails to unpack it into two variables. the result is an ugly python runtime error and not a nice jsoncfg\n    error that says that the config node is an array and not an object/dict that your code expected. to overcome this\n    problem you can use this ``jsoncfg.expect_object()`` function to ensure that the node you iterate is a json\n    object. the same is recommended in case of json arrays: it is recommended to check them with\n    ``jsoncfg.expect_array()`` before iteration:\n\n    .. code-block:: python\n\n        from jsoncfg import load_config, expect_object, expect_array\n\n        config = load_config('server.cfg')\n        for server in expect_array(config.servers):\n            print('------------')\n            for key, value in expect_object(server):\n                print('%s: %r' % (key, value))\n\n\njsoncfg.\\ **expect_array**\\ *(config_node)*\n\n    returns the specified ``config_node`` if it is a json array/list, otherwise it raises a config error (with\n    config file location info when possible).\n\n\njsoncfg.\\ **expect_scalar**\\ *(config_node)*\n\n    returns the specified ``config_node`` if it isn't a json object or array, otherwise it raises a config error (with\n    config file location info when possible).\n\n\n",
  "docs_url": null,
  "keywords": "json config file parser configuration comment",
  "license": "mit",
  "name": "json-cfg",
  "package_url": "https://pypi.org/project/json-cfg/",
  "project_url": "https://pypi.org/project/json-cfg/",
  "project_urls": {
    "Homepage": "https://github.com/pasztorpisti/json-cfg"
  },
  "release_url": "https://pypi.org/project/json-cfg/0.4.2/",
  "requires_dist": [
    "kwonly-args (>=1.0.7)"
  ],
  "requires_python": "",
  "summary": "json config file parser with extended syntax (e.g.: comments), line/column numbers in error messages, etc...",
  "version": "0.4.2",
  "releases": [],
  "developers": [
    "pasztorpisti@gmail.com"
  ],
  "kwds": "jsonconfigindexerror jsonconfigqueryerror jsoncfg jsonconfignodetypeerror jsonconfigvaluenotfounderror",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_json_cfg",
  "homepage": "https://github.com/pasztorpisti/json-cfg",
  "release_count": 10,
  "dependency_ids": [
    "pypi_kwonly_args"
  ]
}