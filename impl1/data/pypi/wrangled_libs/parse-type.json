{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "environment :: web environment",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.2",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: code generators",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "===============================================================================\nparse_type\n===============================================================================\n\n.. image:: https://github.com/jenisys/parse_type/actions/workflows/test.yml/badge.svg\n    :target: https://github.com/jenisys/parse_type/actions/workflows/test.yml\n    :alt: ci build status\n\n.. image:: https://img.shields.io/pypi/v/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: latest version\n\n.. image:: https://img.shields.io/pypi/dm/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type\n    :alt: downloads\n\n.. image:: https://img.shields.io/pypi/l/parse_type.svg\n    :target: https://pypi.python.org/pypi/parse_type/\n    :alt: license\n\n\n`parse_type`_ extends the `parse`_ module (opposite of `string.format()`_)\nwith the following features:\n\n* build type converters for common use cases (enum/mapping, choice)\n* build a type converter with a cardinality constraint (0..1, 0..*, 1..*)\n    from the type converter with cardinality=1.\n* compose a type converter from other type converters\n* an extended parser that supports the cardinalityfield naming schema\n    and creates missing type variants (0..1, 0..*, 1..*) from the\n    primary type converter\n\n.. _parse_type: http://pypi.python.org/pypi/parse_type\n.. _parse:      http://pypi.python.org/pypi/parse\n.. _`string.format()`: http://docs.python.org/library/string.html#format-string-syntax\n\n\ndefinitions\n-------------------------------------------------------------------------------\n\n*type converter*\n    a type converter function that converts a textual representation\n    of a value type into instance of this value type.\n    in addition, a type converter function is often annotated with attributes\n    that allows the `parse`_ module to use it in a generic way.\n    a type converter is also called a *parse_type* (a definition used here).\n\n*cardinality field*\n    a naming convention for related types that differ in cardinality.\n    a cardinality field is a type name suffix in the format of a field.\n    it allows parse format expression, ala::\n\n        \"{person:person}\"     #< cardinality: 1    (one; the normal case)\n        \"{person:person?}\"    #< cardinality: 0..1 (zero or one  = optional)\n        \"{persons:person*}\"   #< cardinality: 0..* (zero or more = many0)\n        \"{persons:person+}\"   #< cardinality: 1..* (one  or more = many)\n\n    this naming convention mimics the relationship descriptions in uml diagrams.\n\n\nbasic example\n-------------------------------------------------------------------------------\n\ndefine an own type converter for numbers (integers):\n\n.. code-block:: python\n\n    # -- use case:\n    def parse_number(text):\n        return int(text)\n    parse_number.pattern = r\"\\d+\"  # -- regular expression pattern for type.\n\nthis is equivalent to:\n\n.. code-block:: python\n\n    import parse\n\n    @parse.with_pattern(r\"\\d+\")\n    def parse_number(text):\n         return int(text)\n    assert hasattr(parse_number, \"pattern\")\n    assert parse_number.pattern == r\"\\d+\"\n\n\n.. code-block:: python\n\n    # -- use case: use the type converter with the parse module.\n    schema = \"hello {number:number}\"\n    parser = parse.parser(schema, dict(number=parse_number))\n    result = parser.parse(\"hello 42\")\n    assert result is not none, \"require: text matches the schema.\"\n    assert result[\"number\"] == 42\n\n    result = parser.parse(\"hello xxx\")\n    assert result is none, \"mismatch: text does not match the schema.\"\n\n.. hint::\n\n    the described functionality above is standard functionality\n    of the `parse`_ module. it serves as introduction for the remaining cases.\n\n\ncardinality\n-------------------------------------------------------------------------------\n\ncreate an type converter for \"manynumbers\" (list, separated with commas)\nwith cardinality \"1..* = 1+\" (many) from the type converter for a \"number\".\n\n.. code-block:: python\n\n    # -- use case: create new type converter with a cardinality constraint.\n    # cardinality: many := one or more (1..*)\n    from parse import parser\n    from parse_type import typebuilder\n    parse_numbers = typebuilder.with_many(parse_number, listsep=\",\")\n\n    schema = \"list: {numbers:manynumbers}\"\n    parser = parser(schema, dict(manynumbers=parse_numbers))\n    result = parser.parse(\"list: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n\n\ncreate an type converter for an \"optionalnumbers\" with cardinality \"0..1 = ?\"\n(optional) from the type converter for a \"number\".\n\n.. code-block:: python\n\n    # -- use case: create new type converter with cardinality constraint.\n    # cardinality: optional := zero or one (0..1)\n    from parse import parser\n    from parse_type import typebuilder\n\n    parse_optional_number = typebuilder.with_optional(parse_number)\n    schema = \"optional: {number:optionalnumber}\"\n    parser = parser(schema, dict(optionalnumber=parse_optional_number))\n    result = parser.parse(\"optional: 42\")\n    assert result[\"number\"] == 42\n    result = parser.parse(\"optional: \")\n    assert result[\"number\"] == none\n\n\nenumeration (name-to-value mapping)\n-------------------------------------------------------------------------------\n\ncreate an type converter for an \"enumeration\" from the description of\nthe mapping as dictionary.\n\n.. code-block:: python\n\n    # -- use case: create a type converter for an enumeration.\n    from parse import parser\n    from parse_type import typebuilder\n\n    parse_enum_yesno = typebuilder.make_enum({\"yes\": true, \"no\": false})\n    parser = parser(\"answer: {answer:yesno}\", dict(yesno=parse_enum_yesno))\n    result = parser.parse(\"answer: yes\")\n    assert result[\"answer\"] == true\n\n\ncreate an type converter for an \"enumeration\" from the description of\nthe mapping as an enumeration class (`python 3.4 enum`_ or the `enum34`_\nbackport; see also: `pep-0435`_).\n\n.. code-block:: python\n\n    # -- use case: create a type converter for enum34 enumeration class.\n    # note: use python 3.4 or enum34 backport.\n    from parse import parser\n    from parse_type import typebuilder\n    from enum import enum\n\n    class color(enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    parse_enum_color = typebuilder.make_enum(color)\n    parser = parser(\"select: {color:color}\", dict(color=parse_enum_color))\n    result = parser.parse(\"select: red\")\n    assert result[\"color\"] is color.red\n\n.. _`python 3.4 enum`: http://docs.python.org/3.4/library/enum.html#module-enum\n.. _enum34:   http://pypi.python.org/pypi/enum34\n.. _pep-0435: http://www.python.org/dev/peps/pep-0435\n\n\nchoice (name enumeration)\n-------------------------------------------------------------------------------\n\na choice data type allows to select one of several strings.\n\ncreate an type converter for an \"choice\" list, a list of unique names\n(as string).\n\n.. code-block:: python\n\n    from parse import parser\n    from parse_type import typebuilder\n\n    parse_choice_yesno = typebuilder.make_choice([\"yes\", \"no\"])\n    schema = \"answer: {answer:choiceyesno}\"\n    parser = parser(schema, dict(choiceyesno=parse_choice_yesno))\n    result = parser.parse(\"answer: yes\")\n    assert result[\"answer\"] == \"yes\"\n\n\nvariant (type alternatives)\n-------------------------------------------------------------------------------\n\nsometimes you need a type converter that can accept text for multiple\ntype converter alternatives. this is normally called a \"variant\" (or: union).\n\ncreate an type converter for an \"variant\" type that accepts:\n\n* numbers (positive numbers, as integer)\n* color enum values (by name)\n\n.. code-block:: python\n\n    from parse import parser, with_pattern\n    from parse_type import typebuilder\n    from enum import enum\n\n    class color(enum):\n        red   = 1\n        green = 2\n        blue  = 3\n\n    @with_pattern(r\"\\d+\")\n    def parse_number(text):\n        return int(text)\n\n    # -- make variant: alternatives of different type converters.\n    parse_color = typebuilder.make_enum(color)\n    parse_variant = typebuilder.make_variant([parse_number, parse_color])\n    schema = \"variant: {variant:number_or_color}\"\n    parser = parser(schema, dict(number_or_color=parse_variant))\n\n    # -- test variant: with number, color and mismatch.\n    result = parser.parse(\"variant: 42\")\n    assert result[\"variant\"] == 42\n    result = parser.parse(\"variant: blue\")\n    assert result[\"variant\"] is color.blue\n    result = parser.parse(\"variant: __mismatch__\")\n    assert not result\n\n\n\nextended parser with cardinalityfield support\n-------------------------------------------------------------------------------\n\nthe parser extends the ``parse.parser`` and adds the following functionality:\n\n* supports the cardinalityfield naming scheme\n* automatically creates missing type variants for types with\n  a cardinalityfield by using the primary type converter for cardinality=1\n* extends the provide type converter dictionary with new type variants.\n\nexample:\n\n.. code-block:: python\n\n    # -- use case: parser with cardinalityfield support.\n    # note: automatically adds missing type variants with cardinalityfield part.\n    # use:  parse_number() type converter from above.\n    from parse_type.cfparse import parser\n\n    # -- prepare: parser, adds missing type variant for cardinality 1..* (many)\n    type_dict = dict(number=parse_number)\n    schema = \"list: {numbers:number+}\"\n    parser = parser(schema, type_dict)\n    assert \"number+\" in type_dict, \"created missing type variant based on: number\"\n\n    # -- use: parser.\n    result = parser.parse(\"list: 1, 2, 3\")\n    assert result[\"numbers\"] == [1, 2, 3]\n",
  "docs_url": null,
  "keywords": "parse,parsing",
  "license": "mit",
  "name": "parse-type",
  "package_url": "https://pypi.org/project/parse-type/",
  "project_url": "https://pypi.org/project/parse-type/",
  "project_urls": {
    "Download": "http://pypi.python.org/pypi/parse_type",
    "Homepage": "https://github.com/jenisys/parse_type",
    "Issue Tracker": "https://github.com/jenisys/parse_type/issues/",
    "Source Code": "https://github.com/jenisys/parse_type"
  },
  "release_url": "https://pypi.org/project/parse-type/0.6.2/",
  "requires_dist": [
    "six (>=1.15)",
    "enum34 ; python_version < \"3.4\"",
    "parse (>=1.13.1) ; python_version <= \"2.7\"",
    "parse (>=1.18.0) ; python_version >= \"3.0\"",
    "build (>=0.5.1) ; extra == 'develop'",
    "twine (>=1.13.0) ; extra == 'develop'",
    "coverage (>=4.4) ; extra == 'develop'",
    "pytest-html (>=1.19.0) ; extra == 'develop'",
    "pytest-cov ; extra == 'develop'",
    "tox (<4.0,>=2.8) ; extra == 'develop'",
    "pylint ; extra == 'develop'",
    "pytest (<5.0) ; (python_version < \"3.0\") and extra == 'develop'",
    "virtualenv (<20.22.0) ; (python_version <= \"3.6\") and extra == 'develop'",
    "virtualenv (>=20.0.0) ; (python_version > \"3.6\") and extra == 'develop'",
    "pytest (>=5.0) ; (python_version >= \"3.0\") and extra == 'develop'",
    "ruff ; (python_version >= \"3.7\") and extra == 'develop'",
    "Sphinx (>=1.6) ; extra == 'docs'",
    "sphinx-bootstrap-theme (>=0.6.0) ; extra == 'docs'",
    "pytest-html (>=1.19.0) ; extra == 'testing'",
    "pytest (<5.0) ; (python_version < \"3.0\") and extra == 'testing'",
    "pytest (>=5.0) ; (python_version >= \"3.0\") and extra == 'testing'"
  ],
  "requires_python": ">=2.7, !=3.0.*, !=3.1.*",
  "summary": "simplifies to build parse types based on the parse module",
  "version": "0.6.2",
  "releases": [],
  "developers": [
    "jenisys@noreply.github.com",
    "jens_engel"
  ],
  "kwds": "parse _parse parser _parse_type parsing",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_parse_type",
  "homepage": "https://github.com/jenisys/parse_type",
  "release_count": 8,
  "dependency_ids": [
    "pypi_build",
    "pypi_coverage",
    "pypi_enum34",
    "pypi_parse",
    "pypi_pylint",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_pytest_html",
    "pypi_ruff",
    "pypi_six",
    "pypi_sphinx",
    "pypi_sphinx_bootstrap_theme",
    "pypi_tox",
    "pypi_twine",
    "pypi_virtualenv"
  ]
}