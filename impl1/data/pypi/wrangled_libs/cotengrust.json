{
  "classifiers": [
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "programming language :: rust"
  ],
  "description": "# cotengrust\n\n`cotengrust` provides fast rust implementations of contraction ordering\nprimitives for tensor networks or einsum expressions. the two main functions\nare:\n\n- `optimize_optimal(inputs, output, size_dict, **kwargs)`\n- `optimize_greedy(inputs, output, size_dict, **kwargs)`\n\nthe optimal algorithm is an optimized version of the `opt_einsum` 'dp' \npath - itself an implementation of https://arxiv.org/abs/1304.6112.\n\n\n## installation\n\n`cotengrust` is available for most platforms from\n[pypi](https://pypi.org/project/cotengrust/):\n\n```bash\npip install cotengrust\n```\n\nor if you want to develop locally (which requires [pyo3](https://github.com/pyo3/pyo3) \nand [maturin](https://github.com/pyo3/maturin)):\n\n```bash\ngit clone https://github.com/jcmgray/cotengrust.git\ncd cotengrust\nmaturin develop --release\n```\n(the release flag is very important for assessing performance!).\n\n\n## usage\n\nif `cotengrust` is installed, then by default `cotengra` will use it for its\ngreedy and optimal subroutines, notably subtree reconfiguration. you can also\ncall the routines directly:\n\n```python\nimport cotengra as ctg\nimport cotengrust as ctgr\n\n# specify an 8x8 square lattice contraction\ninputs, output, shapes, size_dict = ctg.utils.lattice_equation([8, 8])\n\n# find the optimal 'combo' contraction path\n%%time\npath = ctgr.optimize_optimal(inputs, output, size_dict, minimize='combo')\n# cpu times: user 13.7 s, sys: 83.4 ms, total: 13.7 s\n# wall time: 13.7 s\n\n# construct a contraction tree for further introspection\ntree = ctg.contractiontree.from_path(\n    inputs, output, size_dict, path=path\n)\ntree.plot_rubberband()\n```\n![optimal-8x8-order](https://github.com/jcmgray/cotengrust/assets/8982598/f8e18ff2-5ace-4e46-81e1-06bffaef5e45)\n\n\n## api\n\nthe optimize functions follow the api of the python implementations in `cotengra.pathfinders.path_basic.py`.\n\n```python\ndef optimize_optimal(\n    inputs,\n    output,\n    size_dict,\n    minimize='flops',\n    cost_cap=2,\n    search_outer=false,\n    simplify=true,\n    use_ssa=false,\n):\n    \"\"\"find an optimal contraction ordering.\n\n    parameters\n    ----------\n    inputs : sequence[sequence[str]]\n        the indices of each input tensor.\n    output : sequence[str]\n        the indices of the output tensor.\n    size_dict : dict[str, int]\n        the size of each index.\n    minimize : str, optional\n        the cost function to minimize. the options are:\n\n        - \"flops\": minimize with respect to total operation count only\n          (also known as contraction cost)\n        - \"size\": minimize with respect to maximum intermediate size only\n          (also known as contraction width)\n        - 'write' : minimize the sum of all tensor sizes, i.e. memory written\n        - 'combo' or 'combo={factor}` : minimize the sum of\n          flops + factor * write, with a default factor of 64.\n        - 'limit' or 'limit={factor}` : minimize the sum of\n          max(flops, alpha * write) for each individual contraction, with a\n          default factor of 64.\n\n        'combo' is generally a good default in term of practical hardware\n        performance, where both memory bandwidth and compute are limited.\n    cost_cap : float, optional\n        the maximum cost of a contraction to initially consider. this acts like\n        a sieve and is doubled at each iteration until the optimal path can\n        be found, but supplying an accurate guess can speed up the algorithm.\n    search_outer : bool, optional\n        if true, consider outer product contractions. this is much slower but\n        theoretically might be required to find the true optimal 'flops'\n        ordering. in practical settings (i.e. with minimize='combo'), outer\n        products should not be required.\n    simplify : bool, optional\n        whether to perform simplifications before optimizing. these are:\n\n            - ignore any indices that appear in all terms\n            - combine any repeated indices within a single term\n            - reduce any non-output indices that only appear on a single term\n            - combine any scalar terms\n            - combine any tensors with matching indices (hadamard products)\n\n        such simpifications may be required in the general case for the proper\n        functioning of the core optimization, but may be skipped if the input\n        indices are already in a simplified form.\n    use_ssa : bool, optional\n        whether to return the contraction path in 'single static assignment'\n        (ssa) format (i.e. as if each intermediate is appended to the list of\n        inputs, without removals). this can be quicker and easier to work with\n        than the 'linear recycled' format that `numpy` and `opt_einsum` use.\n\n    returns\n    -------\n    path : list[list[int]]\n        the contraction path, given as a sequence of pairs of node indices. it\n        may also have single term contractions if `simplify=true`.\n    \"\"\"\n    ...\n\n\ndef optimize_greedy(\n    inputs,\n    output,\n    size_dict,\n    costmod=1.0,\n    temperature=0.0,\n    simplify=true,\n    use_ssa=false,\n):\n    \"\"\"find a contraction path using a (randomizable) greedy algorithm.\n\n    parameters\n    ----------\n    inputs : sequence[sequence[str]]\n        the indices of each input tensor.\n    output : sequence[str]\n        the indices of the output tensor.\n    size_dict : dict[str, int]\n        a dictionary mapping indices to their dimension.\n    costmod : float, optional\n        when assessing local greedy scores how much to weight the size of the\n        tensors removed compared to the size of the tensor added::\n\n            score = size_ab - costmod * (size_a + size_b)\n\n        this can be a useful hyper-parameter to tune.\n    temperature : float, optional\n        when asessing local greedy scores, how much to randomly perturb the\n        score. this is implemented as::\n\n            score -> sign(score) * log(|score|) - temperature * gumbel()\n\n        which implements boltzmann sampling.\n    simplify : bool, optional\n        whether to perform simplifications before optimizing. these are:\n\n            - ignore any indices that appear in all terms\n            - combine any repeated indices within a single term\n            - reduce any non-output indices that only appear on a single term\n            - combine any scalar terms\n            - combine any tensors with matching indices (hadamard products)\n\n        such simpifications may be required in the general case for the proper\n        functioning of the core optimization, but may be skipped if the input\n        indices are already in a simplified form.\n    use_ssa : bool, optional\n        whether to return the contraction path in 'single static assignment'\n        (ssa) format (i.e. as if each intermediate is appended to the list of\n        inputs, without removals). this can be quicker and easier to work with\n        than the 'linear recycled' format that `numpy` and `opt_einsum` use.\n\n    returns\n    -------\n    path : list[list[int]]\n        the contraction path, given as a sequence of pairs of node indices. it\n        may also have single term contractions if `simplify=true`.\n    \"\"\"\n\ndef optimize_simplify(\n    inputs,\n    output,\n    size_dict,\n    use_ssa=false,\n):\n    \"\"\"find the (partial) contracton path for simplifiactions only.\n\n    parameters\n    ----------\n    inputs : sequence[sequence[str]]\n        the indices of each input tensor.\n    output : sequence[str]\n        the indices of the output tensor.\n    size_dict : dict[str, int]\n        a dictionary mapping indices to their dimension.\n    use_ssa : bool, optional\n        whether to return the contraction path in 'single static assignment'\n        (ssa) format (i.e. as if each intermediate is appended to the list of\n        inputs, without removals). this can be quicker and easier to work with\n        than the 'linear recycled' format that `numpy` and `opt_einsum` use.\n\n    returns\n    -------\n    path : list[list[int]]\n        the contraction path, given as a sequence of pairs of node indices. it\n        may also have single term contractions.\n\n    \"\"\"\n    ...\n\ndef ssa_to_linear(ssa_path, n=none):\n    \"\"\"convert a ssa path to linear format.\"\"\"\n    ...\n\ndef find_subgraphs(inputs, output, size_dict,):\n    \"\"\"find all disconnected subgraphs of a specified contraction.\"\"\"\n    ...\n```\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "cotengrust",
  "package_url": "https://pypi.org/project/cotengrust/",
  "project_url": "https://pypi.org/project/cotengrust/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/cotengrust/0.1.1/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "fast contraction ordering primitives for tensor networks.",
  "version": "0.1.1",
  "releases": [],
  "developers": [
    "johnniemcgray@gmail.com"
  ],
  "kwds": "cotengrust optimize_greedy optimize_optimal opt_einsum cotengra",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_cotengrust",
  "homepage": "",
  "release_count": 2,
  "dependency_ids": []
}