{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: testing"
  ],
  "description": ".. image:: https://img.shields.io/pypi/v/pytest-localserver.svg?style=flat\n    :alt: pypi version\n    :target: https://pypi.python.org/pypi/pytest-localserver\n\n.. image:: https://img.shields.io/pypi/pyversions/pytest-localserver.svg\n    :alt: supported python versions\n    :target: https://pypi.python.org/pypi/pytest-localserver\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/psf/black\n\n.. image:: https://results.pre-commit.ci/badge/github/pytest-dev/pytest-localserver/master.svg\n   :target: https://results.pre-commit.ci/latest/github/pytest-dev/pytest-localserver/master\n   :alt: pre-commit.ci status\n\n==================\npytest-localserver\n==================\n\npytest-localserver is a plugin for the `pytest`_ testing framework which enables\nyou to test server connections locally.\n\nsometimes `monkeypatching`_ ``urllib2.urlopen()`` just does not cut it, for\ninstance if you work with ``urllib2.request``, define your own openers/handlers\nor work with ``httplib``. in these cases it may come in handy to have an http\nserver running locally which behaves just like the real thing [1]_. well, look\nno further!\n\nquickstart\n==========\n\nlet's say you have a function to scrape html which only required to be pointed\nat a url ::\n\n    import requests\n    def scrape(url):\n        html = requests.get(url).text\n        # some parsing happens here\n        # ...\n        return result\n\nyou want to test this function in its entirety without having to rely on a\nremote server whose content you cannot control, neither do you want to waste\ntime setting up a complex mechanism to mock or patch the underlying python\nmodules dealing with the actual http request (of which there are more than one\nbtw). so what do you do?\n\nyou simply use pytest's `funcargs feature`_ and simulate an entire server\nlocally! ::\n\n    def test_retrieve_some_content(httpserver):\n        httpserver.serve_content(open('cached-content.html').read())\n        assert scrape(httpserver.url) == 'found it!'\n\nwhat happened here is that for the duration of your tests an http server is\nstarted on a random port on localhost which will serve the content you tell it\nto and behaves just like the real thing.\n\nthe added bonus is that you can test whether your code behaves gracefully if\nthere is a network problem::\n\n    def test_content_retrieval_fails_graciously(httpserver):\n        httpserver.serve_content('file not found!', 404)\n        pytest.raises(contentnotfoundexception, scrape, httpserver.url)\n\nthe same thing works for smtp servers, too::\n\n    def test_sending_some_message(smtpserver):\n        mailer = mymailer(host=smtpserver.addr[0], port=smtpserver.addr[1])\n        mailer.send(to='bob@example.com', from_='alice@example.com',\n            subject='mymailer v1.0', body='check out my mailer!')\n        assert len(smtpserver.outbox)==1\n\nhere an smtp server is started which accepts e-mails being sent to it. the\nnice feature here is that you can actually check if the message was received\nand what was sent by looking into the smtpserver's ``outbox``.\n\nit is really that easy!\n\navailable funcargs\n==================\n\nhere is a short overview of the available funcargs. for more details i suggest\npoking around in the code itself.\n\n``httpserver``\n    provides a threaded http server instance running on localhost. it has the\n    following attributes:\n\n    * ``code`` - http response code (int)\n    * ``content`` - content of next response (str, bytes, or iterable of either)\n    * ``headers`` - response headers (dict)\n    * ``chunked`` - whether to chunk-encode the response (enumeration)\n\n    once these attributes are set, all subsequent requests will be answered with\n    these values until they are changed or the server is stopped. a more\n    convenient way to change these is ::\n\n        httpserver.serve_content(content=none, code=200, headers=none, chunked=pytest_localserver.http.chunked.no)\n\n    the ``chunked`` attribute or parameter can be set to\n\n    * ``chunked.yes``, telling the server to always apply chunk encoding\n    * ``chunked.no``, telling the server to never apply chunk encoding\n    * ``chunked.auto``, telling the server to apply chunk encoding only if\n      the ``transfer-encoding`` header includes ``chunked``\n\n    if chunk encoding is applied, each str or bytes in ``content`` becomes one\n    chunk in the response.\n\n    the server address can be found in property\n\n    * ``url``\n\n    which is the string representation of tuple ``server_address`` (host as str,\n    port as int).\n\n    if you want to check which form fields have been posted, try ::\n\n        httpserver.serve_content(..., show_post_vars=true)\n\n    which will display them as parsable text.\n\n    if you need to inspect the requests sent to the server, a list of all\n    received requests can be found in property\n\n    * ``requests``\n\n    which is a list of ``werkzeug.wrappers.request`` objects.\n\n``httpsserver``\n    is the same as ``httpserver`` only with ssl encryption.\n\n``smtpserver``\n    provides a threaded smtp server, with an api similar to ``smtpd.smtpserver``,\n    (the deprecated class from the python standard library) running on localhost.\n    it has the following attributes:\n\n    * ``addr`` - server address as tuple (host as str, port as int)\n    * ``outbox`` - list of ``email.message.message`` instances received.\n\nusing your a wsgi application as test server\n============================================\n\nas of version 0.3 you can now use a `wsgi application`_ to run on the test\nserver ::\n\n    from pytest_localserver.http import wsgiserver\n\n    def simple_app(environ, start_response):\n        \"\"\"simplest possible wsgi application\"\"\"\n        status = '200 ok'\n        response_headers = [('content-type', 'text/plain')]\n        start_response(status, response_headers)\n        return ['hello world!\\n']\n\n    @pytest.fixture\n    def testserver(request):\n        \"\"\"defines the testserver funcarg\"\"\"\n        server = wsgiserver(application=simple_app)\n        server.start()\n        request.addfinalizer(server.stop)\n        return server\n\n    def test_retrieve_some_content(testserver):\n        assert scrape(testserver.url) == 'hello world!\\n'\n\nhave a look at the following page for more information on wsgi:\nhttp://wsgi.readthedocs.org/en/latest/learn.html\n\ndownload and installation\n=========================\n\nyou can install the plugin by running ::\n\n    pip install pytest-localserver\n\nalternatively, get the latest stable version from `pypi`_ or the latest\n`bleeding-edge`_ from github.\n\nlicense and credits\n===================\n\nthis plugin is released under the mit license. you can find the full text of\nthe license in the license file.\n\ncopyright (c) 2010-2022 sebastian rahlf and others (see authors).\n\nsome parts of this package is based on ideas or code from other people:\n\n- i borrowed some implementation ideas for the httpserver from `linkchecker`_.\n- the implementation for the smtp server is based on the `mailsink recipe`_ by\n  adam feuer, matt branthwaite and troy frever.\n- the https implementation is based on work by `sebastien martini`_.\n\nthanks guys!\n\ndevelopment and future plans\n============================\n\nfeel free to clone the repository and add your own changes. pull requests are\nalways welcome!::\n\n    git clone https://github.com/pytest-dev/pytest-localserver\n\nif you find any bugs, please file a `report`_.\n\ntest can be run with tox.\n\ni already have a couple of ideas for future versions:\n\n* support for ftp, ssh (maybe base all on twisted?)\n* making the smtp outbox as convenient to use as ``django.core.mail.outbox``\n* add your own here!\n\npreparing a release\n-------------------\n\nfor package maintainers, here is how we release a new version:\n\n#. ensure that the ``changes`` file is up to date with the latest changes.\n#. make sure that all tests pass on the version you want to release.\n#. use the `new release form on github`_ (or some other equivalent method) to\n   create a new release, following the pattern of previous releases.\n\n   * each release has to be based on a tag. you can either create the tag first\n     (e.g. using ``git tag``) and then make a release from that tag, or you can\n     have github create the tag as part of the process of making a release;\n     either way works.\n   * the tag name **must** be the `pep 440`_-compliant version number prefixed\n     by ``v``, making sure to include at least three version number components\n     (e.g. ``v0.6.0``).\n   * the \"auto-generate release notes\" button will be useful in summarizing\n     the changes since the last release.\n\n#. using either the `release workflows page`_ or the link in the email you\n   received about a \"deployment review\", go to the workflow run created for\n   the new release and click \"review deployments\", then either approve or reject\n   the two deployments, one to test pypi and one to real pypi. (it should not be\n   necessary to reject a deployment unless something really weird happens.)\n   once the deployment is approved, github will automatically upload the files.\n\n----\n\n.. [1] the idea for this project was born when i needed to check that `a piece\n       of software`_ behaved itself when receiving http error codes 404 and 500.\n       having unsuccessfully tried to mock a server, i stumbled across\n       `linkchecker`_ which uses a the same idea to test its internals.\n\n.. _monkeypatching: http://pytest.org/latest/monkeypatch.html\n.. _pytest: http://pytest.org/\n.. _funcargs feature: http://pytest.org/latest/funcargs.html\n.. _linkchecker: http://linkchecker.sourceforge.net/\n.. _wsgi application: http://www.python.org/dev/peps/pep-0333/\n.. _pypi: http://pypi.python.org/pypi/pytest-localserver/\n.. _bleeding-edge: https://github.com/pytest-dev/pytest-localserver\n.. _report: https://github.com/pytest-dev/pytest-localserver/issues/\n.. _tox: http://testrun.org/tox/\n.. _a piece of software: http://pypi.python.org/pypi/python-amazon-product-api/\n.. _mailsink recipe: http://code.activestate.com/recipes/440690/\n.. _sebastien martini: http://code.activestate.com/recipes/442473/\n.. _pep 440: https://peps.python.org/pep-0440/\n.. _build: https://pypa-build.readthedocs.io/en/latest/\n.. _twine: https://twine.readthedocs.io/en/stable/\n.. _new release form on github: https://github.com/pytest-dev/pytest-localserver/releases/new\n.. _release workflows page: https://github.com/pytest-dev/pytest-localserver/actions/workflows/release.yml\n",
  "docs_url": null,
  "keywords": "pytest server localhost http smtp",
  "license": "mit license",
  "name": "pytest-localserver",
  "package_url": "https://pypi.org/project/pytest-localserver/",
  "project_url": "https://pypi.org/project/pytest-localserver/",
  "project_urls": {
    "Homepage": "https://github.com/pytest-dev/pytest-localserver"
  },
  "release_url": "https://pypi.org/project/pytest-localserver/0.8.1/",
  "requires_dist": [
    "werkzeug >=0.10",
    "aiosmtpd ; extra == 'smtp'"
  ],
  "requires_python": ">=3.5",
  "summary": "pytest plugin to test server connections locally.",
  "version": "0.8.1",
  "releases": [],
  "developers": [
    "basti@redtoad.de",
    "david_zaslavsky",
    "diazona@ellipsix.net",
    "sebastian_rahlf"
  ],
  "kwds": "pytest_localserver pytest _pytest localserver pyversions",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_pytest_localserver",
  "homepage": "https://github.com/pytest-dev/pytest-localserver",
  "release_count": 26,
  "dependency_ids": [
    "pypi_aiosmtpd",
    "pypi_werkzeug"
  ]
}