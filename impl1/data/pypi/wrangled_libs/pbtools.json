{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 3"
  ],
  "description": "|nala|_\n\nabout\n=====\n\n`google protocol buffers`_ tools in python 3.6+.\n\n- `c` source code generator.\n\n- `proto3`_ language parser.\n\nknown limitations:\n\n- options, services (grpc) and reserved fields are ignored.\n\n- public imports are not implemented.\n\nproject homepage: https://github.com/eerimoq/pbtools\n\ndocumentation: https://pbtools.readthedocs.io\n\ninstallation\n============\n\n.. code-block:: python\n\n   pip install pbtools\n\nc source code design\n====================\n\nthe c source code is designed with the following in mind:\n\n- clean and easy to use api.\n\n- no malloc/free. uses a workspace/arena for memory allocations.\n\n- fast encoding and decoding.\n\n- small memory footprint.\n\n- thread safety.\n\nknown limitations:\n\n- ``char`` must be 8 bits.\n\ntodo:\n\n- make ``map`` easier to use. only one allocation should be needed\n  before encoding, not one per sub-message item.\n\nmemory management\n-----------------\n\na workspace, or arena, is used to allocate memory when encoding and\ndecoding messages. for simplicity, allocated memory can't be freed,\nwhich puts restrictions on how a message can be modified between\nencodings (if one want to do that). scalar value type fields (ints,\nstrings, bytes, etc.) can be modified, but the length of repeated\nfields can't.\n\nscalar value types\n------------------\n\nprotobuf scalar value types are mapped to c types as shown in the\ntable below.\n\n+---------------+--------------------------------------------+\n| protubuf type | c type                                     |\n+===============+============================================+\n| ``double``    | ``double``                                 |\n+---------------+--------------------------------------------+\n| ``float``     | ``float``                                  |\n+---------------+--------------------------------------------+\n| ``int32``     | ``int32_t``                                |\n+---------------+--------------------------------------------+\n| ``int64``     | ``int64_t``                                |\n+---------------+--------------------------------------------+\n| ``uint32``    | ``uint32_t``                               |\n+---------------+--------------------------------------------+\n| ``uint64``    | ``uint64_t``                               |\n+---------------+--------------------------------------------+\n| ``sint32``    | ``int32_t``                                |\n+---------------+--------------------------------------------+\n| ``sint64``    | ``int64_t``                                |\n+---------------+--------------------------------------------+\n| ``fixed32``   | ``int32_t``                                |\n+---------------+--------------------------------------------+\n| ``fixed64``   | ``int64_t``                                |\n+---------------+--------------------------------------------+\n| ``sfixed32``  | ``int32_t``                                |\n+---------------+--------------------------------------------+\n| ``sfixed64``  | ``int64_t``                                |\n+---------------+--------------------------------------------+\n| ``bool``      | ``bool``                                   |\n+---------------+--------------------------------------------+\n| ``string``    | ``char *``                                 |\n+---------------+--------------------------------------------+\n| ``bytes``     | ``struct { uint8_t *buf_p, size_t size }`` |\n+---------------+--------------------------------------------+\n\nmessage\n-------\n\na message is a struct in c.\n\nfor example, let's create a protocol specification.\n\n.. code-block:: proto\n\n   syntax = \"proto3\";\n\n   package foo;\n\n   message bar {\n       bool v1 = 1;\n   }\n\n   message fie {\n       int32 v2 = 1;\n       bar v3 = 2;\n   }\n\none struct is generated per message.\n\n.. code-block:: c\n\n   struct foo_bar_t {\n       bool v1;\n   };\n\n   struct foo_fie_t {\n       int32_t v2;\n       struct foo_bar_t *v3_p;\n   };\n\nthe sub-message ``v3`` has to be allocated before encoding and checked\nif ``null`` after decoding.\n\n.. code-block:: c\n\n   struct foo_fie_t *fie_p;\n\n   /* encode. */\n   fie_p = foo_fie_new(...);\n   fie_p->v2 = 5;\n   foo_fie_v3_alloc(fie_p);\n   fie_p->v3_p->v1 = true;\n   foo_fie_encode(fie_p, ...);\n\n   /* decode. */\n   fie_p = foo_fie_new(...);\n   foo_fie_decode(fie_p, ...);\n\n   printf(\"%d\\n\", fie_p->v2);\n\n   if (fie_p->v3_p != null) {\n       printf(\"%d\\n\", fie_p->v3_p->v1);\n   }\n\noneof\n-----\n\na oneof is an enum (the choice) and a union in c.\n\nfor example, let's create a protocol specification.\n\n.. code-block:: proto\n\n   syntax = \"proto3\";\n\n   package foo;\n\n   message bar {\n       oneof fie {\n           int32 v1 = 1;\n           bool v2 = 2;\n       };\n   }\n\none enum and one struct is generated per oneof.\n\n.. code-block:: c\n\n   enum foo_bar_fie_e {\n       foo_bar_fie_none_e = 0,\n       foo_bar_fie_v1_e = 1,\n       foo_bar_fie_v2_e = 2\n   };\n\n   struct foo_bar_t {\n       enum foo_bar_fie_choice_e fie;\n       union {\n           int32_t v1;\n           bool v2;\n       };\n   };\n\nthe generated code can encode and decode messages. call\n``_<field>_init()`` or ``_<field>_alloc()`` to select which oneof\nfield to encode. use the ``enum`` to check which oneof field was\ndecoded (if any).\n\n.. code-block:: c\n\n   struct foo_bar_t *bar_p;\n\n   /* encode with choice v1. */\n   bar_p = foo_bar_new(...);\n   foo_bar_v1_init(bar_p);\n   bar_p->v1 = -2;\n   foo_bar_encode(bar_p, ...);\n\n   /* decode. */\n   bar_p = foo_bar_new(...);\n   foo_bar_decode(bar_p, ...);\n\n   switch (bar_p->fie) {\n\n   case foo_bar_fie_none_e:\n       printf(\"not present.\\n\");\n       break;\n\n   case foo_bar_fie_v1_e:\n       printf(\"%d\\n\", bar_p->v1);\n       break;\n\n   case foo_bar_fie_v2_e:\n       printf(\"%d\\n\", bar_p->v2);\n       break;\n\n   default:\n       printf(\"can not happen.\\n\");\n       break;\n   }\n\nbenchmark\n---------\n\nsee `benchmark`_ for a benchmark of a few c/c++ protobuf libraries.\n\nexample usage\n=============\n\nc source code\n-------------\n\nin this example we use the simple proto-file `hello_world.proto`_.\n\n.. code-block:: proto\n\n   syntax = \"proto3\";\n\n   package hello_world;\n\n   message foo {\n       int32 bar = 1;\n   }\n\ngenerate c source code from the proto-file.\n\n.. code-block:: text\n\n   $ pbtools generate_c_source examples/hello_world/hello_world.proto\n\nsee `hello_world.h`_ and `hello_world.c`_ for the contents of the\ngenerated files.\n\nwe'll use the generated types and functions below.\n\n.. code-block:: c\n\n   struct hello_world_foo_t {\n      struct pbtools_message_base_t base;\n      int32_t bar;\n   };\n\n   struct hello_world_foo_t *hello_world_foo_new(\n       void *workspace_p,\n       size_t size);\n\n   int hello_world_foo_encode(\n       struct hello_world_foo_t *self_p,\n       void *encoded_p,\n       size_t size);\n\n   int hello_world_foo_decode(\n       struct hello_world_foo_t *self_p,\n       const uint8_t *encoded_p,\n       size_t size);\n\nencode and decode the foo-message in `main.c`_.\n\n.. code-block:: c\n\n   #include <stdio.h>\n   #include \"hello_world.h\"\n\n   int main(int argc, const char *argv[])\n   {\n       int size;\n       uint8_t workspace[64];\n       uint8_t encoded[16];\n       struct hello_world_foo_t *foo_p;\n\n       /* encode. */\n       foo_p = hello_world_foo_new(&workspace[0], sizeof(workspace));\n\n       if (foo_p == null) {\n           return (1);\n       }\n\n       foo_p->bar = 78;\n       size = hello_world_foo_encode(foo_p, &encoded[0], sizeof(encoded));\n\n       if (size < 0) {\n           return (2);\n       }\n\n       printf(\"successfully encoded foo into %d bytes.\\n\", size);\n\n       /* decode. */\n       foo_p = hello_world_foo_new(&workspace[0], sizeof(workspace));\n\n       if (foo_p == null) {\n           return (3);\n       }\n\n       size = hello_world_foo_decode(foo_p, &encoded[0], size);\n\n       if (size < 0) {\n           return (4);\n       }\n\n       printf(\"successfully decoded %d bytes into foo.\\n\", size);\n       printf(\"foo.bar: %d\\n\", foo_p->bar);\n\n       return (0);\n   }\n\nbuild and run the program.\n\n.. code-block:: text\n\n   $ gcc -i lib/include main.c hello_world.c lib/src/pbtools.c -o main\n   $ ./main\n   successfully encoded foo into 2 bytes.\n   successfully decoded 2 bytes into foo.\n   foo.bar: 78\n\nsee `examples/hello_world`_ for all files used in this example.\n\ncommand line tool\n-----------------\n\nthe generate c source subcommand\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nbelow is an example of how to generate c source code from a\nproto-file.\n\n.. code-block:: text\n\n   $ pbtools generate_c_source examples/address_book/address_book.proto\n\nsee `address_book.h`_ and `address_book.c`_ for the contents of the\ngenerated files.\n\n.. |nala| image:: https://img.shields.io/badge/nala-test-blue.svg\n.. _nala: https://github.com/eerimoq/nala\n\n.. _google protocol buffers: https://developers.google.com/protocol-buffers\n\n.. _proto3: https://developers.google.com/protocol-buffers/docs/proto3\n\n.. _address_book.h: https://github.com/eerimoq/pbtools/blob/master/examples/address_book/generated/address_book.h\n\n.. _address_book.c: https://github.com/eerimoq/pbtools/blob/master/examples/address_book/generated/address_book.c\n\n.. _hello_world.proto: https://github.com/eerimoq/pbtools/blob/master/examples/hello_world/hello_world.proto\n\n.. _hello_world.h: https://github.com/eerimoq/pbtools/blob/master/examples/hello_world/generated/hello_world.h\n\n.. _hello_world.c: https://github.com/eerimoq/pbtools/blob/master/examples/hello_world/generated/hello_world.c\n\n.. _main.c: https://github.com/eerimoq/pbtools/blob/master/examples/hello_world/main.c\n\n.. _examples/hello_world: https://github.com/eerimoq/pbtools/blob/master/examples/hello_world\n\n.. _benchmark: https://github.com/eerimoq/pbtools/blob/master/benchmark\n",
  "docs_url": null,
  "keywords": "protobuf,proto,protocol buffers",
  "license": "mit",
  "name": "pbtools",
  "package_url": "https://pypi.org/project/pbtools/",
  "project_url": "https://pypi.org/project/pbtools/",
  "project_urls": {
    "Homepage": "https://github.com/eerimoq/pbtools"
  },
  "release_url": "https://pypi.org/project/pbtools/0.47.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "google protocol buffers tools.",
  "version": "0.47.0",
  "releases": [],
  "developers": [
    "erik.moqvist@gmail.com",
    "erik_moqvist"
  ],
  "kwds": "pbtools_message_base_t protobuf pbtools proto3 pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pbtools",
  "homepage": "https://github.com/eerimoq/pbtools",
  "release_count": 54,
  "dependency_ids": []
}