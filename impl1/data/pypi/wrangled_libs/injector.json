{
  "classifiers": [],
  "description": "injector - python dependency injection framework, inspired by guice\n===================================================================\n\n|image| |coverage status|\n\nintroduction\n------------\n\nwhile dependency injection is easy to do in python due to its support\nfor keyword arguments, the ease with which objects can be mocked and its\ndynamic nature, a framework for assisting in this process can remove a\nlot of boiler-plate from larger applications. that\u2019s where injector can\nhelp. it automatically and transitively provides dependencies for you.\nas an added benefit, injector encourages nicely compartmentalised code\nthrough the use of modules.\n\nif you\u2019re not sure what dependency injection is or you\u2019d like to learn\nmore about it see:\n\n-  `the clean code talks - don\u2019t look for things! (a talk by mi\u0161ko\n   hevery) <https://www.youtube.com/watch?v=rlflcwkxhj0>`__\n-  `inversion of control containers and the dependency injection pattern\n   (an article by martin\n   fowler) <https://martinfowler.com/articles/injection.html>`__\n\nthe core values of injector are:\n\n-  simplicity - while being inspired by guice, injector does not\n   slavishly replicate its api. providing a pythonic api trumps\n   faithfulness. additionally some features are omitted because\n   supporting them would be cumbersome and introduce a little bit too\n   much \u201cmagic\u201d (member injection, method injection).\n\n   connected to this, injector tries to be as nonintrusive as possible.\n   for example while you may declare a class\u2019 constructor to expect some\n   injectable parameters, the class\u2019 constructor remains a standard\n   constructor \u2013\u00a0you may instantiate the class just the same manually,\n   if you want.\n\n-  no global state \u2013 you can have as many\n   `injector <https://injector.readthedocs.io/en/latest/api.html#injector.injector>`__\n   instances as you like, each with a different configuration and each\n   with different objects in different scopes. code like this won\u2019t work\n   for this very reason:\n\n   .. code:: python\n\n        class myclass:\n            @inject\n            def __init__(t: sometype):\n                # ...\n\n        myclass()\n\n   this is simply because there\u2019s no global ``injector`` to use. you\n   need to be explicit and use\n   `injector.get <https://injector.readthedocs.io/en/latest/api.html#injector.injector.get>`__,\n   `injector.create_object <https://injector.readthedocs.io/en/latest/api.html#injector.injector.create_object>`__\n   or inject ``myclass`` into the place that needs it.\n\n-  cooperation with static type checking infrastructure \u2013\u00a0the api\n   provides as much static type safety as possible and only breaks it\n   where there\u2019s no other option. for example the\n   `injector.get <https://injector.readthedocs.io/en/latest/api.html#injector.injector.get>`__\n   method is typed such that ``injector.get(sometype)`` is statically\n   declared to return an instance of ``sometype``, therefore making it\n   possible for tools such as `mypy <https://github.com/python/mypy>`__\n   to type-check correctly the code using it.\n\n-  the client code only knows about dependency injection to the extent\n   it needs \u2013\u00a0\n   ```inject`` <https://injector.readthedocs.io/en/latest/api.html#injector.inject>`__,\n   ```inject`` <https://injector.readthedocs.io/en/latest/api.html#injector.inject>`__\n   and\n   ```noinject`` <https://injector.readthedocs.io/en/latest/api.html#injector.noinject>`__\n   are simple markers that don\u2019t really do anything on their own and\n   your code can run just fine without injector orchestrating things.\n\nhow to get injector?\n~~~~~~~~~~~~~~~~~~~~\n\n-  github (code repository, issues):\n   https://github.com/alecthomas/injector\n\n-  pypi (installable, stable distributions):\n   https://pypi.org/project/injector/. you can install it using pip:\n\n   .. code:: bash\n\n      pip install injector\n\n-  documentation: https://injector.readthedocs.org\n\n-  change log: https://injector.readthedocs.io/en/latest/changelog.html\n\ninjector works with cpython 3.7+ and pypy 3 implementing python 3.7+.\n\na quick example\n---------------\n\n.. code:: python\n\n   >>> from injector import injector, inject\n   >>> class inner:\n   ...     def __init__(self):\n   ...         self.forty_two = 42\n   ...\n   >>> class outer:\n   ...     @inject\n   ...     def __init__(self, inner: inner):\n   ...         self.inner = inner\n   ...\n   >>> injector = injector()\n   >>> outer = injector.get(outer)\n   >>> outer.inner.forty_two\n   42\n\nor with ``dataclasses`` if you like:\n\n.. code:: python\n\n   from dataclasses import dataclass\n   from injector import injector, inject\n   class inner:\n       def __init__(self):\n           self.forty_two = 42\n\n   @inject\n   @dataclass\n   class outer:\n       inner: inner\n\n   injector = injector()\n   outer = injector.get(outer)\n   print(outer.inner.forty_two)  # prints 42\n\na full example\n--------------\n\nhere\u2019s a full example to give you a taste of how injector works:\n\n.. code:: python\n\n   >>> from injector import module, provider, injector, inject, singleton\n\nwe\u2019ll use an in-memory sqlite database for our example:\n\n.. code:: python\n\n   >>> import sqlite3\n\nand make up an imaginary ``requesthandler`` class that uses the sqlite\nconnection:\n\n.. code:: python\n\n   >>> class requesthandler:\n   ...   @inject\n   ...   def __init__(self, db: sqlite3.connection):\n   ...     self._db = db\n   ...\n   ...   def get(self):\n   ...     cursor = self._db.cursor()\n   ...     cursor.execute('select key, value from data order by key')\n   ...     return cursor.fetchall()\n\nnext, for the sake of the example, we\u2019ll create a configuration type:\n\n.. code:: python\n\n   >>> class configuration:\n   ...     def __init__(self, connection_string):\n   ...         self.connection_string = connection_string\n\nnext, we bind the configuration to the injector, using a module:\n\n.. code:: python\n\n   >>> def configure_for_testing(binder):\n   ...     configuration = configuration(':memory:')\n   ...     binder.bind(configuration, to=configuration, scope=singleton)\n\nnext we create a module that initialises the db. it depends on the\nconfiguration provided by the above module to create a new db\nconnection, then populates it with some dummy data, and provides a\n``connection`` object:\n\n.. code:: python\n\n   >>> class databasemodule(module):\n   ...   @singleton\n   ...   @provider\n   ...   def provide_sqlite_connection(self, configuration: configuration) -> sqlite3.connection:\n   ...     conn = sqlite3.connect(configuration.connection_string)\n   ...     cursor = conn.cursor()\n   ...     cursor.execute('create table if not exists data (key primary key, value)')\n   ...     cursor.execute('insert or replace into data values (\"hello\", \"world\")')\n   ...     return conn\n\n(note how we have decoupled configuration from our database\ninitialisation code.)\n\nfinally, we initialise an ``injector`` and use it to instantiate a\n``requesthandler`` instance. this first transitively constructs a\n``sqlite3.connection`` object, and the configuration dictionary that it\nin turn requires, then instantiates our ``requesthandler``:\n\n.. code:: python\n\n   >>> injector = injector([configure_for_testing, databasemodule()])\n   >>> handler = injector.get(requesthandler)\n   >>> tuple(map(str, handler.get()[0]))  # py3/py2 compatibility hack\n   ('hello', 'world')\n\nwe can also verify that our ``configuration`` and ``sqlite`` connections\nare indeed singletons within the injector:\n\n.. code:: python\n\n   >>> injector.get(configuration) is injector.get(configuration)\n   true\n   >>> injector.get(sqlite3.connection) is injector.get(sqlite3.connection)\n   true\n\nyou\u2019re probably thinking something like: \u201cthis is a large amount of work\njust to give me a database connection\u201d, and you are correct; dependency\ninjection is typically not that useful for smaller projects. it comes\ninto its own on large projects where the up-front effort pays for itself\nin two ways:\n\n1. forces decoupling. in our example, this is illustrated by decoupling\n   our configuration and database configuration.\n2. after a type is configured, it can be injected anywhere with no\n   additional effort. simply ``@inject`` and it appears. we don\u2019t really\n   illustrate that here, but you can imagine adding an arbitrary number\n   of ``requesthandler`` subclasses, all of which will automatically\n   have a db connection provided.\n\nfootnote\n--------\n\nthis framework is similar to snake-guice, but aims for simplification.\n\n\u00a9 copyright 2010-2013 to alec thomas, under the bsd license\n\n.. |image| image:: https://github.com/alecthomas/injector/workflows/ci/badge.svg\n   :target: https://github.com/alecthomas/injector/actions?query=workflow%3aci+branch%3amaster\n.. |coverage status| image:: https://codecov.io/gh/alecthomas/injector/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/alecthomas/injector\n\n\n",
  "docs_url": null,
  "keywords": "dependency injection,di,dependency injection framework,inversion of control,ioc,inversion of control container",
  "license": "bsd",
  "name": "injector",
  "package_url": "https://pypi.org/project/injector/",
  "project_url": "https://pypi.org/project/injector/",
  "project_urls": {
    "Download": "https://pypi.org/project/injector/",
    "Homepage": "https://github.com/alecthomas/injector"
  },
  "release_url": "https://pypi.org/project/injector/0.21.0/",
  "requires_dist": [
    "typing-extensions (>=3.7.4) ; python_version < \"3.9\"",
    "build (==0.10.0) ; extra == 'dev'",
    "check-manifest (==0.49) ; extra == 'dev'",
    "click (==8.1.3) ; extra == 'dev'",
    "coverage (==7.2.7) ; extra == 'dev'",
    "exceptiongroup (==1.1.1) ; extra == 'dev'",
    "iniconfig (==2.0.0) ; extra == 'dev'",
    "mypy-extensions (==1.0.0) ; extra == 'dev'",
    "packaging (==23.1) ; extra == 'dev'",
    "pathspec (==0.11.1) ; extra == 'dev'",
    "platformdirs (==3.8.0) ; extra == 'dev'",
    "pluggy (==1.2.0) ; extra == 'dev'",
    "pyproject-hooks (==1.0.0) ; extra == 'dev'",
    "pytest (==7.4.0) ; extra == 'dev'",
    "pytest-cov (==4.1.0) ; extra == 'dev'",
    "tomli (==2.0.1) ; extra == 'dev'",
    "typing-extensions (==4.7.0) ; extra == 'dev'",
    "black (==23.3.0) ; (implementation_name == \"cpython\") and extra == 'dev'",
    "mypy (==1.4.1) ; (implementation_name == \"cpython\") and extra == 'dev'"
  ],
  "requires_python": "",
  "summary": "injector - python dependency injection framework, inspired by guice",
  "version": "0.21.0",
  "releases": [],
  "developers": [
    "alec@swapoff.org",
    "alec_thomas"
  ],
  "kwds": "injection injector injected inject dependency",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_injector",
  "homepage": "https://github.com/alecthomas/injector",
  "release_count": 54,
  "dependency_ids": [
    "pypi_black",
    "pypi_build",
    "pypi_check_manifest",
    "pypi_click",
    "pypi_coverage",
    "pypi_exceptiongroup",
    "pypi_iniconfig",
    "pypi_mypy",
    "pypi_mypy_extensions",
    "pypi_packaging",
    "pypi_pathspec",
    "pypi_platformdirs",
    "pypi_pluggy",
    "pypi_pyproject_hooks",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_tomli",
    "pypi_typing_extensions"
  ]
}