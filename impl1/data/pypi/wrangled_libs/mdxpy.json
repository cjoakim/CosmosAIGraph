{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython"
  ],
  "description": "![logo](./images/logo.png)\r\n\r\n\r\n## mdxpy\r\n\r\na simple, yet elegant mdx library for tm1\r\n\r\n## install\r\n\r\n    pip install mdxpy\r\n\r\n## usage\r\n\r\ncreate mdx queries programmatically with the `member`, `mdxtuple`, `mdxhierarchyset`, `mdxbuilder` classes.\r\n\r\nbenefits of using mdxpy over hacking raw mdx queries in your code\r\n- faster to write\r\n- requires less mdx knowledge\r\n- eliminates syntax errors (e.g. forget `}`, `]`, `)` in a query) forever\r\n- makes code more robust and easier to refactor\r\n- escaping of `]` in object names is taken care of \r\n\r\n### member\r\n\r\n`member` is used in `mdxtuple` and `mdxhierarchyset`. \r\ncreate a `member` with the static `member.of(*args: str)` method.\r\n\r\n``` python\r\n>>> member = member.of(\"product\", \"product1\")\r\n>>> print(member.unique_name)\r\n[product].[product].[product1]\r\n\r\n>>> member = member.of(\"region\", \"bygeography\", \"uk\")\r\n>>> print(member.unique_name)\r\n[region].[bygeography].[uk]\r\n```\r\n\r\n### mdxtuple\r\n\r\ncreate a `mdxtuple` with the static `of(*args: member)` method. the mdx expression of the tuple is generated with the `to_mdx` method.\r\n\r\n``` python\r\n>>> mdx_tuple = mdxtuple.of(member.of(\"product\", \"product1\"), member.of(\"region\", \"us\"))\r\n\r\n>>> print(mdx_tuple.to_mdx())\r\n([product].[product].[product1],[region].[region].[us])\r\n\r\n>>> mdx_tuple = mdxtuple.of(member.of(\"product\", \"bytype\", \"product1\"), member.of(\"region\", \"bygeography\", \"north america\"))\r\n\r\n>>> print(mdx_tuple.to_mdx())\r\n([product].[bytype].[product1],[region].[bygeography].[north america])\r\n\r\n```     \r\n\r\nyou can add a `member` to a `mdxtuple`\r\n\r\n``` python\r\n>>> mdx_tuple = mdxtuple.of(member.of(\"product\", \"bytype\", \"product1\"))\r\n\r\n>>> mdx_tuple.add_member(member.of(\"region\", \"bygeography\", \"north america\"))\r\n\r\n>>> print(mdx_tuple.to_mdx())\r\n([product].[bytype].[product1],[region].[bygeography].[northamerica])\r\n```\r\n\r\n### mdxhierarchyset\r\n\r\n`mdxhierarchyset` is created with any of the static methods on the `mdxhierarchyset` class. the `mdx` expression of the set is generated with the `to_mdx` method.\r\n\r\n``` python\r\n>>> mdx_set = mdxhierarchyset.tm1_subset_all(\"product\")\r\n>>> print(mdx_set.to_mdx())\r\n{tm1subsetall([product].[product])}\r\n\r\n>>> mdx_set = mdxhierarchyset.tm1_subset_to_set(\"region\", \"by geography\", \"default\")\r\n>>> print(mdx_set.to_mdx())\r\n{tm1subsettoset([region].[bygeography],'default')}\r\n\r\n>>> mdx_set = mdxhierarchyset.all_leaves(\"region\")\r\n>>> print(mdx_set.to_mdx())\r\n{tm1filterbylevel({tm1subsetall([region].[region])},0)}\r\n\r\n>>> mdx_set = mdxhierarchyset.members([member.of(\"region\", \"us\"), member.of(\"product\", \"product1\")])\r\n>>> print(mdx_set.to_mdx())\r\n{[region].[region].[us],[product].[product].[product1]}\r\n```\r\n\r\nfunctions on `mdxhierarchyset` can be concatenated to arbitrary length in a functional style:\r\n\r\n``` python\r\n>>> mdx_set = mdxhierarchyset.tm1_subset_all(\"region\").filter_by_level(0).filter_by_pattern(\"i*\").tm1_sort()\r\n>>> print(mdx_set.to_mdx())\r\n{tm1sort({tm1filterbypattern({tm1filterbylevel({tm1subsetall([region].[region])},0)},'i*')},asc)}\r\n```\r\n\r\n### mdxbuilder\r\n\r\nthe `mdxbuilder` is used to build mdx queries. `mdxhierarchyset` or `mdxtuple` are placed on the axes. zero suppression can be switched on or off per axis. the actual `mdx` expression is generated with the `to_mdx` method. \r\n\r\n``` python\r\n>>> query = mdxbuilder.from_cube(\"cube\").add_hierarchy_set_to_column_axis(mdxhierarchyset.all_leaves(\"product\"))\r\n>>> print(query.to_mdx())\r\nselect {tm1filterbylevel({tm1subsetall([product].[product])},0)} on 0\r\nfrom [cube] \r\n\r\n>>> query = mdxbuilder.from_cube(\"cube\").add_hierarchy_set_to_column_axis(mdxhierarchyset.member(member.of(\"product\", \"product1\")))\r\n>>> print(query.to_mdx())\r\nselect {[product].[product].[product1]} on 0\r\nfrom [cube] \r\n\r\n>>> query =  mdxbuilder.from_cube(\"cube\").add_member_tuple_to_axis(0, member.of(\"product\", \"product1\"), member.of(\"region\", \"emea\"))\r\n>>> print(query.to_mdx())\r\nselect\r\n{([product].[product].[product1],[region].[region].[emea])} on 0\r\nfrom [cube] \r\n\r\n>>> query = mdxbuilder.from_cube(\"cube\").columns_non_empty().add_hierarchy_set_to_column_axis(mdxhierarchyset.member(member.of(\"product\", \"product1\")))\r\n>>> print(query.to_mdx())\r\nselect\r\nnon empty {[product].[product].[product1]} on 0 \r\nfrom [cube]\r\n```\r\n\r\nmdx queries can have any number of axes. axis 0 _(=columns)_ must be defined.\r\n\r\n``` python\r\n>>> mdx = mdxbuilder.from_cube(\"cube\") \\\r\n    .add_hierarchy_set_to_axis(0, mdxhierarchyset.member(member.of(\"region\", \"us\"))) \\\r\n    .add_hierarchy_set_to_axis(1, mdxhierarchyset.all_leaves(\"product\")) \\\r\n    .add_hierarchy_set_to_axis(2, mdxhierarchyset.member(member.of(\"version\", \"actual\"))) \\\r\n    .add_hierarchy_set_to_axis(3, mdxhierarchyset.tm1_subset_to_set(\"time\", \"time\", \"2020-q1\")) \\\r\n    .to_mdx()\r\n\r\n>>> print(mdx)\r\nselect\r\n{[region].[region].[us]} on 0,\r\n{tm1filterbylevel({tm1subsetall([product].[product])},0)} on 1,\r\n{[version].[version].[actual]} on 2,\r\n{tm1subsettoset([time].[time],'2020-q1')} on 3\r\nfrom [cube]\r\n```\r\n\r\nthe `calculatedmember` class is used to define query-scoped calculated members. they are used with the `mdxbuilder` through the `with_member` function.\r\n\r\n``` python\r\n>>> mdx = mdxbuilder.from_cube(cube=\"record rating\").with_member(\r\n        calculatedmember.avg(\r\n            dimension=\"period\",\r\n            hierarchy=\"period\",\r\n            element=\"avg 2016\",\r\n            cube=\"record rating\",\r\n            mdx_set=mdxhierarchyset.children(member=member.of(\"period\", \"2016\")),\r\n            mdx_tuple=mdxtuple.of(member.of(\"chart\", \"total charts\"), member.of(\"record rating measure\", \"rating\")))) \\\r\n        .add_hierarchy_set_to_row_axis(\r\n        mdxhierarchyset\r\n            .children(member.of(\"record\", \"total records\"))\r\n            .top_count(cube=\"record rating\", mdx_tuple=mdxtuple.of(member.of(\"period\", \"avg 2016\")), top=5)) \\\r\n        .add_member_tuple_to_columns(member.of(\"period\", \"avg 2016\")) \\\r\n        .where(member.of(\"chart\", \"total charts\"), member.of(\"record rating measure\", \"rating\")) \\\r\n        .to_mdx()\r\n\r\n>>> print(mdx)\r\nwith \r\nmember [period].[period].[avg2016] as avg({[period].[period].[2016].children},[record rating].([chart].[chart].[totalcharts],[recordratingmeasure].[recordratingmeasure].[rating]))\r\nselect\r\n{([period].[period].[avg2016])} on 0,\r\n{topcount({[record].[record].[totalrecords].children},5,[recordrating].([period].[period].[avg2016]))} on 1\r\nfrom [recordrating]\r\nwhere ([chart].[chart].[totalcharts],[recordratingmeasure].[recordratingmeasure].[rating])\r\n```\r\n\r\nthe `dimensionproperty` class is used to query attributes in conjunction with data. \r\nit is used with the `mdxbuilder` through the `add_properties_to_row_axis`, `add_hierarchy_set_to_column_axis` functions.\r\n\r\n``` python\r\nfrom mdxpy import dimensionproperty, mdxhierarchyset, mdxbuilder, member\r\n\r\nquery = mdxbuilder.from_cube(\"sales\")\r\n\r\nquery = query.rows_non_empty()\r\nquery = query.add_hierarchy_set_to_row_axis(mdxhierarchyset.all_leaves(\"product\"))\r\nquery = query.add_properties_to_row_axis(dimensionproperty.of(\"product\", \"description\"))\r\n\r\nquery = query.columns_non_empty()\r\nquery = query.add_hierarchy_set_to_column_axis(mdxhierarchyset.member(member.of(\"sales measure\", \"revenue\")))\r\n\r\nquery = query.where(member.of(\"year\", \"2022\"), member.of(\"region\", \"switzerland\"))\r\n\r\nprint(query.to_mdx())\r\n\r\n>>> print(mdx)\r\nselect\r\nnon empty {[salesmeasure].[salesmeasure].[revenue]} dimension properties member_name on 0,\r\nnon empty {tm1filterbylevel({tm1subsetall([product].[product])},0)} dimension properties [product].[product].[description] on 1\r\nfrom [sales]\r\nwhere ([year].[year].[2022],[region].[region].[switzerland])\r\n```\r\n\r\nto see all samples checkout the `test.py` file\r\n\r\n## supported mdx functions\r\n\r\n- tm1subsetall\r\n- members\r\n- tm1subsettoset\r\n- defaultmember\r\n- parent\r\n- firstchild\r\n- lastchild\r\n- children\r\n- ancestors\r\n- ancestor\r\n- drilldownlevel\r\n- filter\r\n- tm1filterbypattern\r\n- tm1filterbylevel\r\n- tm1sort\r\n- head\r\n- tail\r\n- subset\r\n- topcount\r\n- bottomcount\r\n- union\r\n- intersect\r\n- except\r\n- order\r\n\r\n## tests\r\n\r\nall tests in `test.py`\r\n\r\n## contribution\r\n\r\ncontribution is welcome. if you find a bug or feel like you can contribute please fork the repository, update the code and then create a pull request so we can merge in the changes.\r\n",
  "docs_url": null,
  "keywords": "mdx,tm1,ibm cognos tm1,planning analytics,pa,cognos",
  "license": "mit-license",
  "name": "mdxpy",
  "package_url": "https://pypi.org/project/mdxpy/",
  "project_url": "https://pypi.org/project/mdxpy/",
  "project_urls": {
    "Homepage": "https://github.com/cubewise-code/mdxpy"
  },
  "release_url": "https://pypi.org/project/mdxpy/1.3.2/",
  "requires_dist": [],
  "requires_python": ">=3.5",
  "summary": "a simple, yet elegant mdx library for tm1",
  "version": "1.3.2",
  "releases": [],
  "developers": [
    "marius_wirtz",
    "mwirtz@cubewise.com"
  ],
  "kwds": "mdxpy mdx_tuple mdx_set to_mdx mdxbuilder",
  "license_kwds": "mit-license",
  "libtype": "pypi",
  "id": "pypi_mdxpy",
  "homepage": "https://github.com/cubewise-code/mdxpy",
  "release_count": 10,
  "dependency_ids": []
}