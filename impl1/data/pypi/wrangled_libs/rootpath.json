{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries"
  ],
  "description": "\n# `rootpath` [![pypi version](https://badge.fury.io/py/rootpath.svg)](https://badge.fury.io/py/rootpath) [![build status](https://travis-ci.com/grimen/python-rootpath.svg?branch=master)](https://travis-ci.com/grimen/python-rootpath) [![coverage status](https://codecov.io/gh/grimen/python-rootpath/branch/master/graph/badge.svg)](https://codecov.io/gh/grimen/python-rootpath)\n\n*python project/package root path detection.*\n\n\n## introduction\n\nauto-magic project/package root path detection - from a child module file for python libraries/projects.\n\nit does this by detecting typical package/project root files/folders (e.g. `.git`, `requirements.txt`, etc.), but it can also be overriden easily if needed.\n\nas a little bonus it exposes an optional helper for adding root path to the python load path (`sys.path`) for resolving python module import hell (which is terribly broken by design).\n\n\n## install\n\ninstall using **pip**:\n\n```sh\npip install rootpath\n```\n\n\n## use: basic\n\ndetect a project/package root path:\n\n**1.** assuming we have a **python** library/application project...\n\n```\n/home/me/projects\n    \u2514\u2500\u2500 py-foo\n            \u2514\u2500\u2500 foo\n                \u2514\u2500\u2500 utils\n                    \u2514\u2500\u2500 __init__.py\n                    \u2514\u2500\u2500 baz.py\n                    \u2514\u2500\u2500 say.py\n                \u2514\u2500\u2500 __init__.py\n                \u2514\u2500\u2500 bar.py\n            readme.md\n            requirements.txt\n            setup.py\n```\n\n`foo/bar.py` - top level package module\n\n```python\nimport rootpath\n\ndef bar():\n    path = rootpath.detect()\n\n    assert path == '/home/me/projects/py-foo'\n\n    print('---')\n    print('file:', __file__)\n    print('root:', path)\n    print('---')\n\nif __name__ == '__main__':\n    bar()\n```\n\n`foo/utils/baz.py` - nested level package module (dependency)\n\n```python\nimport rootpath\n\ndef baz():\n    path = rootpath.detect()\n\n    assert path == '/home/me/projects/py-foo'\n\n    print('---')\n    print('file:', __file__)\n    print('root:', path)\n    print('---')\n\nif __name__ == '__main__':\n    baz()\n```\n\n`foo/utils/say.py` - nested level package module (dependency)\n\n```python\nimport rootpath\n\ndef say():\n    print('---')\n    print('say: {0}'.format(rootpath.detect()))\n    print('---')\n\nif __name__ == '__main__':\n    say()\n```\n\n**2.** let's run the files individually - they should both with successful assertions and output accurately detected root paths...\n\n```sh\n$ cd /home/me/projects/py-foo\n\n$ python ./foo/bar.py\n\n---\nfile: /home/me/projects/py-foo/foo/bar.py\nroot: /home/me/projects/py-foo\n---\n\n$ python ./foo/utils/baz.py\n\n---\nfile: /home/me/projects/py-foo/foo/utils/baz.py\nroot: /home/me/projects/py-foo\n---\n\n$ python ./foo/utils/say.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n```\n\n\n## use: painless python module imports\n\nusing the above example code project as a reference, as and example to enable painless python module imports:\n\n**1.** let's make use of the load path helper in the higher order modules...\n\n`foo/bar.py`\n\n```python\nimport rootpath\n\n# 1. prepends root path to `sys.path`\nrootpath.append()\n\n# 2. will import correctly without errors no matter if imported/executed from same path or any other system path - which is not true for the native python 3 relative import\nimport rootpath.utils.say as say\n\ndef bar():\n    say()\n\nif __name__ == '__main__':\n    bar()\n```\n\n`foo/utils/baz.py`\n\n```python\nimport rootpath\n\n# 1. prepends root path to `sys.path`\nrootpath.append()\n\n# 2. will import correctly without errors no matter if imported/executed from same path or any other system path - which is not true for the native python 3 relative import\nimport rootpath.utils.say as say\n\ndef baz():\n    hello()\n\nif __name__ == '__main__':\n    baz()\n```\n\n**2.** let's run the files individually - `say` module should be imported correctly without any errors from any module path namespace...\n\n```sh\n$ cd /home/me/projects/py-foo\n\n$ python ./foo/bar.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n$ python ./foo/utils/baz.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n$ python ./foo/utils/say.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n$ cd /home/me/projects/py-foo/foo\n\n$ python ./bar.py\n---\nsay: /home/me/projects/py-foo\n---\n\n$ python ./utils/baz.py\n---\nsay: /home/me/projects/py-foo\n---\n\n$ python ./utils/say.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n$ cd /home/me/projects/py-foo/foo/utils\n\n$ python ./utils/baz.py\n\n---\nsay: /home/me/projects/py-foo\n---\n\n$ python ./utils/say.py\n\n---\nsay: /home/me/projects/py-foo\n---\n```\n\n\n## about\n\nthis project was mainly initiated - in lack of well tested and reliable existing alternatives - to be used at our work at **[markable.ai](https://markable.ai)** to have common code conventions between various programming environments where **python** (research, cv, ai) is heavily used.\n\n\n## license\n\nreleased under the mit license.\n\n\n",
  "docs_url": null,
  "keywords": "python,utlity,common,root,rootpath,root-path,detect,autodetect,auto-detect,project-root,project-root-path,package-root,package-root-path",
  "license": "mit",
  "name": "rootpath",
  "package_url": "https://pypi.org/project/rootpath/",
  "project_url": "https://pypi.org/project/rootpath/",
  "project_urls": {
    "Download": "https://github.com/grimen/python-rootpath",
    "Homepage": "https://github.com/grimen/python-rootpath",
    "bugs": "https://github.com/grimen/python-rootpath/issues",
    "repository": "https://github.com/grimen/python-rootpath"
  },
  "release_url": "https://pypi.org/project/rootpath/0.1.1/",
  "requires_dist": [
    "six (>=1.11.0)",
    "coloredlogs (>=10.0)",
    "termcolor (>=1.1.0)",
    "colour-runner (>=0.0.5)",
    "deepdiff (>=3.3.0)",
    "pygments (>=2.2.0)",
    "tox (>=3.0.0)",
    "coverage (>=4.5.2)",
    "codecov (>=2.0.15)"
  ],
  "requires_python": "",
  "summary": "python project/package root path detection.",
  "version": "0.1.1",
  "releases": [],
  "developers": [
    "grimen@gmail.com",
    "jonas_grimfelt"
  ],
  "kwds": "rootpath path paths root pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_rootpath",
  "homepage": "https://github.com/grimen/python-rootpath",
  "release_count": 2,
  "dependency_ids": [
    "pypi_codecov",
    "pypi_coloredlogs",
    "pypi_colour_runner",
    "pypi_coverage",
    "pypi_deepdiff",
    "pypi_pygments",
    "pypi_six",
    "pypi_termcolor",
    "pypi_tox"
  ]
}