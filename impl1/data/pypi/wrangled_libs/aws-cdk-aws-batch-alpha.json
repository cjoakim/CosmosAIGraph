{
  "classifiers": [
    "development status :: 4 - beta",
    "framework :: aws cdk",
    "framework :: aws cdk :: 2",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# aws batch construct library\n\n<!--begin stability banner-->---\n\n\n![cdk-constructs: developer preview](https://img.shields.io/badge/cdk--constructs-developer--preview-informational.svg?style=for-the-badge)\n\n> the apis of higher level constructs in this module are in **developer preview** before they\n> become stable. we will only make breaking changes to address unforeseen api issues. therefore,\n> these apis are not subject to [semantic versioning](https://semver.org/), and breaking changes\n> will be announced in release notes. this means that while you may use them, you may need to\n> update your source code when upgrading to a newer version of this package.\n\n---\n<!--end stability banner-->\n\nthis module is part of the [aws cloud development kit](https://github.com/aws/aws-cdk) project.\n\naws batch is a batch processing tool for efficiently running hundreds of thousands computing jobs in aws.\nbatch can dynamically provision [amazon ec2](https://aws.amazon.com/ec2/) instances to meet the resource requirements of submitted jobs\nand simplifies the planning, scheduling, and executions of your batch workloads. batch achieves this through four different resources:\n\n* computeenvironments: contain the resources used to execute jobs\n* jobdefinitions: define a type of job that can be submitted\n* jobqueues: route waiting jobs to computeenvironments\n* schedulingpolicies: applied to queues to control how and when jobs exit the jobqueue and enter the computeenvironment\n\n`computeenvironment`s can be managed or unmanaged. batch will automatically provision ec2 instances in a managed `computeenvironment` and will\nnot provision any instances in an unmanaged `computeenvironment`. managed `computeenvironment`s can use ecs, fargate, or eks resources to spin up\nec2 instances in (ensure your eks cluster has [been configured](https://docs.aws.amazon.com/batch/latest/userguide/getting-started-eks.html)\nto support a batch computeenvironment before linking it). you can use launch templates and placement groups to configure exactly how these resources\nwill be provisioned.\n\n`jobdefinition`s can use either ecs resources or eks resources. ecs `jobdefinition`s can use multiple containers to execute distributed workloads.\neks `jobdefinition`s can only execute a single container. submitted jobs use `jobdefinition`s as templates.\n\n`jobqueue`s must link at least one `computeenvironment`. jobs exit the queue in fifo order unless a `schedulingpolicy` is specified.\n\n`schedulingpolicy`s tell the scheduler how to choose which jobs should be executed next by the computeenvironment.\n\n## use cases & examples\n\n### cost optimization\n\n#### spot instances\n\nspot instances are significantly discounted ec2 instances that can be reclaimed at any time by aws.\nworkloads that are fault-tolerant or stateless can take advantage of spot pricing.\nto use spot spot instances, set `spot` to `true` on a managed ec2 or fargate compute environment:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\nbatch.fargatecomputeenvironment(self, \"myfargatecomputeenv\",\n    vpc=vpc,\n    spot=true\n)\n```\n\nbatch allows you to specify the percentage of the on-demand instance that the current spot price\nmust be to provision the instance using the `spotbidpercentage`.\nthis defaults to 100%, which is the recommended value.\nthis value cannot be specified for `fargatecomputeenvironment`s\nand only applies to `managedec2ecscomputeenvironment`s.\nthe following code configures a compute environment to only use spot instances that\nare at most 20% the price of the on-demand instance price:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\nbatch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    spot=true,\n    spot_bid_percentage=20\n)\n```\n\nfor stateful or otherwise non-interruption-tolerant workflows, omit `spot` or set it to `false` to only provision on-demand instances.\n\n#### choosing your instance types\n\nbatch allows you to choose the instance types or classes that will run your workload.\nthis example configures your `computeenvironment` to use only the `m5ad.large` instance:\n\n```python\nvpc = ec2.vpc(self, \"vpc\")\n\nbatch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    instance_types=[ec2.instancetype.of(ec2.instanceclass.m5ad, ec2.instancesize.large)]\n)\n```\n\nbatch allows you to specify only the instance class and to let it choose the size, which you can do like this:\n\n```python\n# compute_env: batch.imanagedec2ecscomputeenvironment\nvpc = ec2.vpc(self, \"vpc\")\ncompute_env.add_instance_class(ec2.instanceclass.m5ad)\n# or, specify it on the constructor:\nbatch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    instance_classes=[ec2.instanceclass.r4]\n)\n```\n\nunless you explicitly specify `useoptimalinstanceclasses: false`, this compute environment will use `'optimal'` instances,\nwhich tells batch to pick an instance from the c4, m4, and r4 instance families.\n*note*: batch does not allow specifying instance types or classes with different architectures.\nfor example, `instanceclass.a1` cannot be specified alongside `'optimal'`,\nbecause `a1` uses arm and `'optimal'` uses x86_64.\nyou can specify both `'optimal'` alongside several different instance types in the same compute environment:\n\n```python\n# vpc: ec2.ivpc\n\n\ncompute_env = batch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    instance_types=[ec2.instancetype.of(ec2.instanceclass.m5ad, ec2.instancesize.large)],\n    use_optimal_instance_classes=true,  # default\n    vpc=vpc\n)\n# note: this is equivalent to specifying\ncompute_env.add_instance_type(ec2.instancetype.of(ec2.instanceclass.m5ad, ec2.instancesize.large))\ncompute_env.add_instance_class(ec2.instanceclass.c4)\ncompute_env.add_instance_class(ec2.instanceclass.m4)\ncompute_env.add_instance_class(ec2.instanceclass.r4)\n```\n\n#### allocation strategies\n\n| allocation strategy           | optimized for              | downsides                     |\n| -----------------------       | -------------              | ----------------------------- |\n| best_fit                      | cost                       | may limit throughput          |\n| best_fit_progressive          | throughput                 | may increase cost             |\n| spot_capacity_optimized       | least interruption         | only useful on spot instances |\n| spot_price_capacity_optimized | least interruption + price | only useful on spot instances |\n\nbatch provides different allocation strategies to help it choose which instances to provision.\nif your workflow tolerates interruptions, you should enable `spot` on your `computeenvironment`\nand use `spot_price_capacity_optimized` (this is the default if `spot` is enabled).\nthis will tell batch to choose the instance types from the ones you\u2019ve specified that have\nthe most spot capacity available to minimize the chance of interruption and have the lowest price.\nto get the most benefit from your spot instances,\nyou should allow batch to choose from as many different instance types as possible.\nif you only care about minimal interruptions and not want batch to optimize for cost, use\n`spot_capacity_optimized`. `spot_price_capacity_optimized` is recommended over `spot_capacity_optimized`\nfor most use cases.\n\nif your workflow does not tolerate interruptions and you want to minimize your costs at the expense\nof potentially longer waiting times, use `allocationstrategy.best_fit`.\nthis will choose the lowest-cost instance type that fits all the jobs in the queue.\nif instances of that type are not available,\nthe queue will not choose a new type; instead, it will wait for the instance to become available.\nthis can stall your `queue`, with your compute environment only using part of its max capacity\n(or none at all) until the `best_fit` instance becomes available.\n\nif you are running a workflow that does not tolerate interruptions and you want to maximize throughput,\nyou can use `allocationstrategy.best_fit_progressive`.\nthis is the default allocation strategy if `spot` is `false` or unspecified.\nthis strategy will examine the jobs in the queue and choose whichever instance type meets the requirements\nof the jobs in the queue and with the lowest cost per vcpu, just as `best_fit`.\nhowever, if not all of the capacity can be filled with this instance type,\nit will choose a new next-best instance type to run any jobs that couldn\u2019t fit into the `best_fit` capacity.\nto make the most use of this allocation strategy,\nit is recommended to use as many instance classes as is feasible for your workload.\nthis example shows a `computeenvironment` that uses `best_fit_progressive`\nwith `'optimal'` and `instanceclass.m5` instance types:\n\n```python\n# vpc: ec2.ivpc\n\n\ncompute_env = batch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    instance_classes=[ec2.instanceclass.m5]\n)\n```\n\nthis example shows a `computeenvironment` that uses `best_fit` with `'optimal'` instances:\n\n```python\n# vpc: ec2.ivpc\n\n\ncompute_env = batch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    allocation_strategy=batch.allocationstrategy.best_fit\n)\n```\n\n*note*: `allocationstrategy` cannot be specified on fargate compute environments.\n\n### controlling vcpu allocation\n\nyou can specify the maximum and minimum vcpus a managed `computeenvironment` can have at any given time.\nbatch will *always* maintain `minvcpus` worth of instances in your computeenvironment, even if it is not executing any jobs,\nand even if it is disabled. batch will scale the instances up to `maxvcpus` worth of instances as\njobs exit the jobqueue and enter the computeenvironment. if you use `allocationstrategy.best_fit_progressive`,\n`allocationstrategy.spot_price_capacity_optimized`, or `allocationstrategy.spot_capacity_optimized`,\nbatch may exceed `maxvcpus`; it will never exceed `maxvcpus` by more than a single instance type. this example configures a\n`minvcpus` of 10 and a `maxvcpus` of 100:\n\n```python\n# vpc: ec2.ivpc\n\n\nbatch.managedec2ecscomputeenvironment(self, \"myec2computeenv\",\n    vpc=vpc,\n    instance_classes=[ec2.instanceclass.r4],\n    minv_cpus=10,\n    maxv_cpus=100\n)\n```\n\n### tagging instances\n\nyou can tag any instances launched by your managed ec2 computeenvironments by using the cdk `tags` api:\n\n```python\nfrom aws_cdk import tags\n\n# vpc: ec2.ivpc\n\n\ntag_ce = batch.managedec2ecscomputeenvironment(self, \"cethatmakestaggedinstnaces\",\n    vpc=vpc\n)\n\ntags.of(tag_ce).add(\"super\", \"salamander\")\n```\n\nunmanaged `computeenvironment`s do not support `maxvcpus` or `minvcpus` because you must provision and manage the instances yourself;\nthat is, batch will not scale them up and down as needed.\n\n### sharing a computeenvironment between multiple jobqueues\n\nmultiple `jobqueue`s can share the same `computeenvironment`.\nif multiple queues are attempting to submit jobs to the same `computeenvironment`,\nbatch will pick the job from the queue with the highest priority.\nthis example creates two `jobqueue`s that share a `computeenvironment`:\n\n```python\n# vpc: ec2.ivpc\n\nshared_compute_env = batch.fargatecomputeenvironment(self, \"spotenv\",\n    vpc=vpc,\n    spot=true\n)\nlow_priority_queue = batch.jobqueue(self, \"jobqueue\",\n    priority=1\n)\nhigh_priority_queue = batch.jobqueue(self, \"jobqueue\",\n    priority=10\n)\nlow_priority_queue.add_compute_environment(shared_compute_env, 1)\nhigh_priority_queue.add_compute_environment(shared_compute_env, 1)\n```\n\n### fairshare scheduling\n\nbatch `jobqueue`s execute jobs submitted to them in fifo order unless you specify a `schedulingpolicy`.\nfifo queuing can cause short-running jobs to be starved while long-running jobs fill the compute environment.\nto solve this, jobs can be associated with a share.\n\nshares consist of a `shareidentifier` and a `weightfactor`, which is inversely correlated with the vcpu allocated to that share identifier.\nwhen submitting a job, you can specify its `shareidentifier` to associate that particular job with that share.\nlet's see how the scheduler uses this information to schedule jobs.\n\nfor example, if there are two shares defined as follows:\n\n| share identifier | weight factor |\n| ---------------- | ------------- |\n| a                | 1             |\n| b                | 1             |\n\nthe weight factors share the following relationship:\n\n```math\na_{vcpus} / a_{weight} = b_{vcpus} / b_{weight}\n```\n\nwhere `bvcpus` is the number of vcpus allocated to jobs with share identifier `'b'`, and `b_weight` is the weight factor of `b`.\n\nthe total number of vcpus allocated to a share is equal to the amount of jobs in that share times the number of vcpus necessary for every job.\nlet's say that each a job needs 32 vcpus (`a_requirement` = 32) and each b job needs 64 vcpus (`b_requirement` = 64):\n\n```math\na_{vcpus} = a_{jobs} * a_{requirement}\n```\n\n```math\nb_{vcpus} = b_{jobs} * b_{requirement}\n```\n\nwe have:\n\n```math\na_{vcpus} / a_{weight} = b_{vcpus} / b_{weight}\n```\n\n```math\na_{jobs} * a_{requirement} / a_{weight} = b_{jobs} * b_{requirement} / b_{weight}\n```\n\n```math\na_{jobs} * 32 / 1 = b_{jobs} * 64 / 1\n```\n\n```math\na_{jobs} * 32 = b_{jobs} * 64\n```\n\n```math\na_{jobs} = b_{jobs} * 2\n```\n\nthus the scheduler will schedule two `'a'` jobs for each `'b'` job.\n\nyou can control the weight factors to change these ratios, but note that\nweight factors are inversely correlated with the vcpus allocated to the corresponding share.\n\nthis example would be configured like this:\n\n```python\nfairshare_policy = batch.fairshareschedulingpolicy(self, \"myfairsharepolicy\")\n\nfairshare_policy.add_share(\n    share_identifier=\"a\",\n    weight_factor=1\n)\nfairshare_policy.add_share(\n    share_identifier=\"b\",\n    weight_factor=1\n)\nbatch.jobqueue(self, \"jobqueue\",\n    scheduling_policy=fairshare_policy\n)\n```\n\n*note*: the scheduler will only consider the current usage of the compute environment unless you specify `sharedecay`.\nfor example, a `sharedecay` of 5 minutes in the above example means that at any given point in time, twice as many `'a'` jobs\nwill be scheduled for each `'b'` job, but only for the past 5 minutes. if `'b'` jobs run longer than 5 minutes, then\nthe scheduler is allowed to put more than two `'a'` jobs for each `'b'` job, because the usage of those long-running\n`'b'` jobs will no longer be considered after 5 minutes. `sharedecay` linearly decreases the usage of\nlong running jobs for calculation purposes. for example if share decay is 60 seconds,\nthen jobs that run for 30 seconds have their usage considered to be only 50% of what it actually is,\nbut after a whole minute the scheduler pretends they don't exist for fairness calculations.\n\nthe following code specifies a `sharedecay` of 5 minutes:\n\n```python\nimport aws_cdk as cdk\n\nfairshare_policy = batch.fairshareschedulingpolicy(self, \"myfairsharepolicy\",\n    share_decay=cdk.duration.minutes(5)\n)\n```\n\nif you have high priority jobs that should always be executed as soon as they arrive,\nyou can define a `computereservation` to specify the percentage of the\nmaximum vcpu capacity that should be reserved for shares that are *not in the queue*.\nthe actual reserved percentage is defined by batch as:\n\n```math\n (\\frac{computereservation}{100}) ^ {activefairshares}\n```\n\nwhere `activefairshares` is the number of shares for which there exists\nat least one job in the queue with a unique share identifier.\n\nthis is best illustrated with an example.\nsuppose there are three shares with share identifiers `a`, `b` and `c` respectively\nand we specify the `computereservation` to be 75%. the queue is currently empty,\nand no other shares exist.\n\nthere are no active fair shares, since the queue is empty.\nthus (75/100)^0 = 1 = 100% of the maximum vcpus are reserved for all shares.\n\na job with identifier `a` enters the queue.\n\nthe number of active fair shares is now 1, hence\n(75/100)^1 = .75 = 75% of the maximum vcpus are reserved for all shares that do not have the identifier `a`;\nfor this example, this is `b` and `c`,\n(but if jobs are submitted with a share identifier not covered by this fairshare policy, those would be considered just as `b` and `c` are).\n\nnow a `b` job enters the queue. the number of active fair shares is now 2,\nso (75/100)^2 = .5625 = 56.25% of the maximum vcpus are reserved for all shares that do not have the identifier `a` or `b`.\n\nnow a second `a` job enters the queue. the number of active fair shares is still 2,\nso the percentage reserved is still 56.25%\n\nnow a `c` job enters the queue. the number of active fair shares is now 3,\nso (75/100)^3 = .421875 = 42.1875% of the maximum vcpus are reserved for all shares that do not have the identifier `a`, `b`, or `c`.\n\nif there are no other shares that your jobs can specify, this means that 42.1875% of your capacity will never be used!\n\nnow, `a`, `b`, and `c` can only consume 100% - 42.1875% = 57.8125% of the maximum vcpus.\nnote that the this percentage is **not** split between `a`, `b`, and `c`.\ninstead, the scheduler will use their `weightfactor`s to decide which jobs to schedule;\nthe only difference is that instead of competing for 100% of the max capacity, jobs compete for 57.8125% of the max capacity.\n\nthis example specifies a `computereservation` of 75% that will behave as explained in the example above:\n\n```python\nbatch.fairshareschedulingpolicy(self, \"myfairsharepolicy\",\n    compute_reservation=75,\n    shares=[batch.share(weight_factor=1, share_identifier=\"a\"), batch.share(weight_factor=0.5, share_identifier=\"b\"), batch.share(weight_factor=2, share_identifier=\"c\")\n    ]\n)\n```\n\nyou can specify a `priority` on your `jobdefinition`s to tell the scheduler to prioritize certain jobs that share the same share identifier.\n\n### configuring job retry policies\n\ncertain workflows may result in jobs failing due to intermittent issues.\njobs can specify retry policies to respond to different failures with different actions.\nthere are three different ways information about the way a job exited can be conveyed;\n\n* `exitcode`: the exit code returned from the process executed by the container. will only match non-zero exit codes.\n* `reason`: any middleware errors, like your docker registry being down.\n* `statusreason`: infrastructure errors, most commonly your spot instance being reclaimed.\n\nfor most use cases, only one of these will be associated with a particular action at a time.\nto specify common `exitcode`s, `reason`s, or `statusreason`s, use the corresponding value from\nthe `reason` class. this example shows some common failure reasons:\n\n```python\nimport aws_cdk as cdk\n\n\njob_defn = batch.ecsjobdefinition(self, \"jobdefn\",\n    container=batch.ecsec2containerdefinition(self, \"containerdefn\",\n        image=ecs.containerimage.from_registry(\"public.ecr.aws/amazonlinux/amazonlinux:latest\"),\n        memory=cdk.size.mebibytes(2048),\n        cpu=256\n    ),\n    retry_attempts=5,\n    retry_strategies=[\n        batch.retrystrategy.of(batch.action.exit, batch.reason.cannot_pull_container)\n    ]\n)\njob_defn.add_retry_strategy(\n    batch.retrystrategy.of(batch.action.exit, batch.reason.spot_instance_reclaimed))\njob_defn.add_retry_strategy(\n    batch.retrystrategy.of(batch.action.exit, batch.reason.cannot_pull_container))\njob_defn.add_retry_strategy(\n    batch.retrystrategy.of(batch.action.exit, batch.reason.custom(\n        on_exit_code=\"40*\",\n        on_reason=\"some reason\"\n    )))\n```\n\nwhen specifying a custom reason,\nyou can specify a glob string to match each of these and react to different failures accordingly.\nup to five different retry strategies can be configured for each job,\nand each strategy can match against some or all of `exitcode`, `reason`, and `statusreason`.\nyou can optionally configure the number of times a job will be retried,\nbut you cannot configure different retry counts for different strategies; they all share the same count.\nif multiple conditions are specified in a given retry strategy,\nthey must all match for the action to be taken; the conditions are anded together, not ored.\n\n### running single-container ecs workflows\n\nbatch can run jobs on ecs or eks. ecs jobs can be defined as single container or multinode.\nthis example creates a `jobdefinition` that runs a single container with ecs:\n\n```python\nimport aws_cdk as cdk\nimport aws_cdk.aws_iam as iam\nimport aws_cdk.aws_efs as efs\n\n# my_file_system: efs.ifilesystem\n# my_job_role: iam.role\n\nmy_file_system.grant_read(my_job_role)\n\njob_defn = batch.ecsjobdefinition(self, \"jobdefn\",\n    container=batch.ecsec2containerdefinition(self, \"containerdefn\",\n        image=ecs.containerimage.from_registry(\"public.ecr.aws/amazonlinux/amazonlinux:latest\"),\n        memory=cdk.size.mebibytes(2048),\n        cpu=256,\n        volumes=[batch.ecsvolume.efs(\n            name=\"myvolume\",\n            file_system=my_file_system,\n            container_path=\"/volumes/myvolume\",\n            use_job_role=true\n        )],\n        job_role=my_job_role\n    )\n)\n```\n\nfor workflows that need persistent storage, batch supports mounting `volume`s to the container.\nyou can both provision the volume and mount it to the container in a single operation:\n\n```python\nimport aws_cdk.aws_efs as efs\n\n# my_file_system: efs.ifilesystem\n# job_defn: batch.ecsjobdefinition\n\n\njob_defn.container.add_volume(batch.ecsvolume.efs(\n    name=\"myvolume\",\n    file_system=my_file_system,\n    container_path=\"/volumes/myvolume\"\n))\n```\n\n### secrets\n\nyou can expose secretsmanager secret arns or ssm parameters to your container as environment variables.\nthe following example defines the `my_secret_env_var` environment variable that contains the\narn of the secret defined by `mysecret`:\n\n```python\nimport aws_cdk as cdk\n\n# my_secret: secretsmanager.isecret\n\n\njob_defn = batch.ecsjobdefinition(self, \"jobdefn\",\n    container=batch.ecsec2containerdefinition(self, \"containerdefn\",\n        image=ecs.containerimage.from_registry(\"public.ecr.aws/amazonlinux/amazonlinux:latest\"),\n        memory=cdk.size.mebibytes(2048),\n        cpu=256,\n        secrets={\n            \"my_secret_env_var\": batch.secret.from_secrets_manager(my_secret)\n        }\n    )\n)\n```\n\n### running kubernetes workflows\n\nbatch also supports running workflows on eks. the following example creates a `jobdefinition` that runs on eks:\n\n```python\nimport aws_cdk as cdk\n\njob_defn = batch.eksjobdefinition(self, \"eksf2\",\n    container=batch.ekscontainerdefinition(self, \"container\",\n        image=ecs.containerimage.from_registry(\"amazon/amazon-ecs-sample\"),\n        volumes=[batch.eksvolume.empty_dir(\n            name=\"myemptydirvolume\",\n            mount_path=\"/mount/path\",\n            medium=batch.emptydirmediumtype.memory,\n            readonly=true,\n            size_limit=cdk.size.mebibytes(2048)\n        )]\n    )\n)\n```\n\nyou can mount `volume`s to these containers in a single operation:\n\n```python\n# job_defn: batch.eksjobdefinition\n\njob_defn.container.add_volume(batch.eksvolume.empty_dir(\n    name=\"emptydir\",\n    mount_path=\"/volumes/emptydir\"\n))\njob_defn.container.add_volume(batch.eksvolume.host_path(\n    name=\"hostpath\",\n    host_path=\"/sys\",\n    mount_path=\"/volumes/hostpath\"\n))\njob_defn.container.add_volume(batch.eksvolume.secret(\n    name=\"secret\",\n    optional=true,\n    mount_path=\"/volumes/secret\",\n    secret_name=\"mysecret\"\n))\n```\n\n### running distributed workflows\n\nsome workflows benefit from parallellization and are most powerful when run in a distributed environment,\nsuch as certain numerical calculations or simulations. batch offers `multinodejobdefinition`s,\nwhich allow a single job to run on multiple instances in parallel, for this purpose.\nmessage passing interface (mpi) is often used with these workflows.\nyou must configure your containers to use mpi properly,\nbut batch allows different nodes running different containers to communicate easily with one another.\nyou must configure your containers to use certain environment variables that batch will provide them,\nwhich lets them know which one is the main node, among other information.\nfor an in-depth example on using mpi to perform numerical computations on batch,\nsee this [blog post](https://aws.amazon.com/blogs/compute/building-a-tightly-coupled-molecular-dynamics-workflow-with-multi-node-parallel-jobs-in-aws-batch/)\nin particular, the environment variable that tells the containers which one is the main node can be configured on your `multinodejobdefinition` as follows:\n\n```python\nimport aws_cdk as cdk\n\nmulti_node_job = batch.multinodejobdefinition(self, \"jobdefinition\",\n    instance_type=ec2.instancetype.of(ec2.instanceclass.r4, ec2.instancesize.large),\n    containers=[batch.multinodecontainer(\n        container=batch.ecsec2containerdefinition(self, \"mainmpicontainer\",\n            image=ecs.containerimage.from_registry(\"yourregsitry.com/yourmpiimage:latest\"),\n            cpu=256,\n            memory=cdk.size.mebibytes(2048)\n        ),\n        start_node=0,\n        end_node=5\n    )]\n)\n# convenience method\nmulti_node_job.add_container(\n    start_node=6,\n    end_node=10,\n    container=batch.ecsec2containerdefinition(self, \"multicontainer\",\n        image=ecs.containerimage.from_registry(\"amazon/amazon-ecs-sample\"),\n        cpu=256,\n        memory=cdk.size.mebibytes(2048)\n    )\n)\n```\n\nif you need to set the control node to an index other than 0, specify it in directly:\n\n```python\nmulti_node_job = batch.multinodejobdefinition(self, \"jobdefinition\",\n    main_node=5,\n    instance_type=ec2.instancetype.of(ec2.instanceclass.r4, ec2.instancesize.large)\n)\n```\n\n### pass parameters to a job\n\nbatch allows you define parameters in your `jobdefinition`, which can be referenced in the container command. for example:\n\n```python\nimport aws_cdk as cdk\n\nbatch.ecsjobdefinition(self, \"jobdefn\",\n    parameters={\"echo_param\": \"foobar\"},\n    container=batch.ecsec2containerdefinition(self, \"containerdefn\",\n        image=ecs.containerimage.from_registry(\"public.ecr.aws/amazonlinux/amazonlinux:latest\"),\n        memory=cdk.size.mebibytes(2048),\n        cpu=256,\n        command=[\"echo\", \"ref::echoparam\"\n        ]\n    )\n)\n```\n\n### understanding progressive allocation strategies\n\naws batch uses an [allocation strategy](https://docs.aws.amazon.com/batch/latest/userguide/allocation-strategies.html) to determine what compute resource will efficiently handle incoming job requests. by default, **best_fit** will pick an available compute instance based on vcpu requirements. if none exist, the job will wait until resources become available. however, with this strategy, you may have jobs waiting in the queue unnecessarily despite having more powerful instances available. below is an example of how that situation might look like:\n\n```plaintext\ncompute environment:\n\n1. m5.xlarge => 4 vcpu\n2. m5.2xlarge => 8 vcpu\n```\n\n```plaintext\njob queue:\n---------\n| a | b |\n---------\n\njob requirements:\na => 4 vcpu - allocated to m5.xlarge\nb => 2 vcpu - waiting\n```\n\nin this situation, batch will allocate **job a** to compute resource #1 because it is the most cost efficient resource that matches the vcpu requirement. however, with this `best_fit` strategy, **job b** will not be allocated to our other available compute resource even though it is strong enough to handle it. instead, it will wait until the first job is finished processing or wait a similar `m5.xlarge` resource to be provisioned.\n\nthe alternative would be to use the `best_fit_progressive` strategy in order for the remaining job to be handled in larger containers regardless of vcpu requirement and costs.\n\n### permissions\n\nyou can grant any principal the `batch:submitjob` permission on both a job definition and a job queue like this:\n\n```python\nimport aws_cdk as cdk\nimport aws_cdk.aws_iam as iam\n\n# vpc: ec2.ivpc\n\n\necs_job = batch.ecsjobdefinition(self, \"jobdefn\",\n    container=batch.ecsec2containerdefinition(self, \"containerdefn\",\n        image=ecs.containerimage.from_registry(\"public.ecr.aws/amazonlinux/amazonlinux:latest\"),\n        memory=cdk.size.mebibytes(2048),\n        cpu=256\n    )\n)\n\nqueue = batch.jobqueue(self, \"jobqueue\",\n    compute_environments=[batch.orderedcomputeenvironment(\n        compute_environment=batch.managedec2ecscomputeenvironment(self, \"managedec2ce\",\n            vpc=vpc\n        ),\n        order=1\n    )],\n    priority=10\n)\n\nuser = iam.user(self, \"myuser\")\necs_job.grant_submit_job(user, queue)\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-batch-alpha",
  "package_url": "https://pypi.org/project/aws-cdk.aws-batch-alpha/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-batch-alpha/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-batch-alpha/2.95.1a0/",
  "requires_dist": [
    "aws-cdk-lib ==2.95.1",
    "constructs <11.0.0,>=10.0.0",
    "jsii <2.0.0,>=1.88.0",
    "publication >=0.0.3",
    "typeguard ~=2.13.3"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::batch",
  "version": "2.95.1a0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk aws_iam aws aws_efs ecsjobdefinition",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_batch_alpha",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 139,
  "dependency_ids": [
    "pypi_aws_cdk_lib",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}