{
  "classifiers": [
    "development status :: 5 - production/stable",
    "operating system :: os independent",
    "programming language :: python :: 3"
  ],
  "description": "macaddress\n==========\n\na module for handling hardware identifiers like mac addresses.\n\nthis module makes it easy to:\n\n1. check if a string represents a valid mac address, or a similar\n   hardware identifier like an eui-64, oui, etc,\n\n2. convert between string and binary forms of mac addresses and\n   other hardware identifiers,\n\nand so on.\n\nheavily inspired by the ``ipaddress`` module, but not yet quite\nas featureful.\n\n\nversioning\n----------\n\nthis library's version numbers follow the `semver 2.0.0\nspecification <https://semver.org/spec/v2.0.0.html>`_.\n\n\ninstallation\n------------\n\n::\n\n    pip install macaddress\n\n\nusage\n-----\n\nimport:\n\n.. code:: python\n\n    >>> import macaddress\n\nclasses are provided for the common hardware identifier\ntypes: ``eui48`` (also available as ``mac``), ``eui64``,\n``oui``, and so on. if those aren't enough, you can\neasily define others with just a few lines of code.\n\n\nparse or validate string\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nwhen only one address type is valid:\n````````````````````````````````````\n\nall provided classes support the standard and common formats.\nfor example, the ``eui48`` class supports the following\nformats:\n\n.. code:: python\n\n    >>> macaddress.eui48('01-23-45-67-89-ab')\n    eui48('01-23-45-67-89-ab')\n    >>> macaddress.eui48('01:23:45:67:89:ab')\n    eui48('01-23-45-67-89-ab')\n    >>> macaddress.eui48('0123.4567.89ab')\n    eui48('01-23-45-67-89-ab')\n    >>> macaddress.eui48('0123456789ab')\n    eui48('01-23-45-67-89-ab')\n\nyou can inspect what formats a hardware address class supports\nby looking at its ``formats`` attribute:\n\n.. code:: python\n\n    >>> macaddress.oui.formats\n    ('xx-xx-xx', 'xx:xx:xx', 'xxxxxx')\n\neach ``x`` in the format string matches one hexadecimal\n\"digit\", and all other characters are matched literally.\n\nif the string does not match one of the formats, a\n``valueerror`` is raised:\n\n.. code:: python\n\n    >>> try:\n    ...     macaddress.mac('foo bar')\n    ... except valueerror as error:\n    ...     print(error)\n    ...\n    'foo bar' cannot be parsed as eui48\n\nif you need to parse in a format that isn't supported,\nyou can define a subclass and add the formats:\n\n.. code:: python\n\n    >>> class mac(macaddress.mac):\n    ...     formats = macaddress.mac.formats + (\n    ...         'xx-xx-xx-xx-xx-xx-',\n    ...         'xx:xx:xx:xx:xx:xx:',\n    ...         'xxxx.xxxx.xxxx.',\n    ...     )\n    ...\n    >>> mac('01-02-03-04-05-06-')\n    mac('01-02-03-04-05-06')\n\n    >>> class mac(macaddress.mac):\n    ...     formats = macaddress.mac.formats + (\n    ...         'xxx-xxx-xxx-xxx',\n    ...         'xxx xxx xxx xxx',\n    ...         'xxx:xxx:xxx:xxx',\n    ...         'xxx.xxx.xxx.xxx',\n    ...     )\n    ...\n    >>> mac('012 345 678 9ab')\n    mac('01-23-45-67-89-ab')\n\nwhen multiple address types are valid:\n``````````````````````````````````````\n\nthere is also a ``parse`` function for when you have a string\nwhich might be one of several classes:\n\n.. code:: python\n\n    >>> from macaddress import eui48, eui64, oui\n\n    >>> macaddress.parse('01:02:03', oui, eui48)\n    oui('01-02-03')\n    >>> macaddress.parse('01:02:03:04:05:06', oui, eui48, eui64)\n    eui48('01-02-03-04-05-06')\n    >>> macaddress.parse('010203040506', eui64, eui48)\n    eui48('01-02-03-04-05-06')\n    >>> macaddress.parse('0102030405060708', eui64, eui48, oui)\n    eui64('01-02-03-04-05-06-07-08')\n\nif the input string cannot be parsed as any of\nthe given classes, a ``valueerror`` is raised:\n\n.. code:: python\n\n    >>> try:\n    ...     macaddress.parse('01:23', eui48, oui)\n    ... except valueerror as error:\n    ...     print(error)\n    ...\n    '01:23' cannot be parsed as eui48 or oui\n    >>> try:\n    ...     macaddress.parse('01:23', eui48, oui, eui64)\n    ... except valueerror as error:\n    ...     print(error)\n    ...\n    '01:23' cannot be parsed as eui48, oui, or eui64\n\nnote that the message of the ``valueerror`` tries to be helpful\nfor developers, but it is not localized, nor is its exact text\npart of the official public interface covered by semver.\n\n\nparse from bytes\n~~~~~~~~~~~~~~~~\n\nall ``macaddress`` classes can be constructed from raw bytes:\n\n.. code:: python\n\n    >>> macaddress.mac(b'abcdef')\n    eui48('61-62-63-64-65-66')\n    >>> macaddress.oui(b'abc')\n    oui('61-62-63')\n\nif the byte string is the wrong size, a ``valueerror`` is raised:\n\n.. code:: python\n\n    >>> try:\n    ...     macaddress.mac(b'\\x01\\x02\\x03')\n    ... except valueerror as error:\n    ...     print(error)\n    ...\n    b'\\x01\\x02\\x03' has wrong length for eui48\n\n\nparse from integers\n~~~~~~~~~~~~~~~~~~~\n\nall ``macaddress`` classes can be constructed from raw integers:\n\n.. code:: python\n\n    >>> macaddress.mac(0x010203ffeedd)\n    eui48('01-02-03-ff-ee-dd')\n    >>> macaddress.oui(0x010203)\n    oui('01-02-03')\n\nnote that the least-significant bit of the integer value maps\nto the last bit in the address type, so the same integer has\na different meaning depending on the class you use it with:\n\n.. code:: python\n\n    >>> macaddress.mac(1)\n    eui48('00-00-00-00-00-01')\n    >>> macaddress.oui(1)\n    oui('00-00-01')\n\nif the integer is too large for the hardware identifier class\nthat you're trying to construct, a ``valueerror`` is raised:\n\n.. code:: python\n\n    >>> try:\n    ...     macaddress.oui(1_000_000_000)\n    ... except valueerror as error:\n    ...     print(error)\n    ...\n    1000000000 is too big for oui\n\n\nget as string\n~~~~~~~~~~~~~\n\n.. code:: python\n\n    >>> mac = macaddress.mac('01-02-03-0a-0b-0c')\n    >>> str(mac)\n    '01-02-03-0a-0b-0c'\n\nfor simple cases of changing the output format, you\ncan just compose string operations:\n\n.. code:: python\n\n    >>> str(mac).replace('-', ':')\n    '01:02:03:0a:0b:0c'\n    >>> str(mac).replace('-', '')\n    '0102030a0b0c'\n    >>> str(mac).lower()\n    '01-02-03-0a-0b-0c'\n\nfor more complicated cases, you can define a subclass\nwith the desired output format as the first format:\n\n.. code:: python\n\n    >>> class mac(macaddress.mac):\n    ...     formats = (\n    ...         'xxx xxx xxx xxx',\n    ...     ) + macaddress.mac.formats\n    ...\n    >>> mac(mac)\n    mac('010 203 0a0 b0c')\n\n\nget as bytes\n~~~~~~~~~~~~\n\n.. code:: python\n\n    >>> mac = macaddress.mac('61-62-63-04-05-06')\n    >>> bytes(mac)\n    b'abc\\x04\\x05\\x06'\n\n\nget as integer\n~~~~~~~~~~~~~~\n\n.. code:: python\n\n    >>> mac = macaddress.mac('01-02-03-04-05-06')\n    >>> int(mac)\n    1108152157446\n    >>> int(mac) == 0x010203040506\n    true\n\n\nget the oui\n~~~~~~~~~~~\n\nmost classes supplied by this module have the ``oui``\nattribute, which returns their first three bytes as\nan oui object:\n\n.. code:: python\n\n    >>> macaddress.mac('01:02:03:04:05:06').oui\n    oui('01-02-03')\n\n\ncompare\n~~~~~~~\n\nequality\n````````\n\nall ``macaddress`` classes support equality comparisons:\n\n.. code:: python\n\n    >>> macaddress.oui('01-02-03') == macaddress.oui('01:02:03')\n    true\n    >>> macaddress.oui('01-02-03') == macaddress.oui('ff-ee-dd')\n    false\n    >>> macaddress.oui('01-02-03') != macaddress.cdi32('01-02-03-04')\n    true\n    >>> macaddress.oui('01-02-03') != macaddress.cdi32('01-02-03-04').oui\n    false\n\nordering\n````````\n\nall ``macaddress`` classes support total\nordering. the comparisons are designed to\nintuitively sort identifiers that start\nwith the same bits next to each other:\n\n.. code:: python\n\n    >>> some_values = [\n    ...     macaddress.mac('ff-ee-dd-01-02-03'),\n    ...     macaddress.mac('ff-ee-00-99-88-77'),\n    ...     macaddress.mac('ff-ee-dd-01-02-04'),\n    ...     macaddress.oui('ff-ee-dd'),\n    ... ]\n    >>> for x in sorted(some_values):\n    ...     print(x)\n    ff-ee-00-99-88-77\n    ff-ee-dd\n    ff-ee-dd-01-02-03\n    ff-ee-dd-01-02-04\n\n\ndefine new types\n~~~~~~~~~~~~~~~~\n\nif this library does not provide a hardware address\ntype that you need, you can easily define your own.\n\nfor example, this is all it takes to define\nip-over-infiniband link-layer addresses:\n\n.. code:: python\n\n    class infiniband(macaddress.hwaddress):\n        size = 20 * 8  # size in bits; 20 octets\n\n        formats = (\n            'xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx-xx',\n            'xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx',\n            'xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx.xxxx',\n            'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',\n            # or whatever formats you want to support\n        )\n        # all formats are tried when parsing from string,\n        # and the first format is used when stringifying.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "0bsd",
  "name": "macaddress",
  "package_url": "https://pypi.org/project/macaddress/",
  "project_url": "https://pypi.org/project/macaddress/",
  "project_urls": {
    "Homepage": "https://github.com/mentalisttraceur/python-macaddress"
  },
  "release_url": "https://pypi.org/project/macaddress/2.0.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "like ``ipaddress``, but for hardware identifiers such as mac addresses.",
  "version": "2.0.2",
  "releases": [],
  "developers": [
    "alexander_kozhevnikov",
    "mentalisttraceur@gmail.com"
  ],
  "kwds": "macaddress semver ipaddress identifiers identifier",
  "license_kwds": "0bsd",
  "libtype": "pypi",
  "id": "pypi_macaddress",
  "homepage": "https://github.com/mentalisttraceur/python-macaddress",
  "release_count": 10,
  "dependency_ids": []
}