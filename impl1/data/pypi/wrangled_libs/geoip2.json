{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "intended audience :: developers",
    "intended audience :: system administrators",
    "license :: osi approved :: apache software license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet",
    "topic :: internet :: proxy servers"
  ],
  "description": "=========================\nmaxmind geoip2 python api\n=========================\n\ndescription\n-----------\n\nthis package provides an api for the geoip2 and geolite2 `web services\n<https://dev.maxmind.com/geoip/docs/web-services?lang=en>`_ and `databases\n<https://dev.maxmind.com/geoip/docs/databases?lang=en>`_.\n\ninstallation\n------------\n\nto install the ``geoip2`` module, type:\n\n.. code-block:: bash\n\n    $ pip install geoip2\n\nif you are not able to use pip, you may also use easy_install from the\nsource directory:\n\n.. code-block:: bash\n\n    $ easy_install .\n\ndatabase reader extension\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nif you wish to use the c extension for the database reader, you must first\ninstall the `libmaxminddb c api <https://github.com/maxmind/libmaxminddb>`_.\nplease `see the instructions distributed with it\n<https://github.com/maxmind/libmaxminddb/blob/main/readme.md>`_.\n\nip geolocation usage\n--------------------\n\nip geolocation is inherently imprecise. locations are often near the center of\nthe population. any location provided by a geoip2 database or web service\nshould not be used to identify a particular address or household.\n\nweb service usage\n-----------------\n\nto use this api, you first construct either a ``geoip2.webservice.client`` or\n``geoip2.webservice.asyncclient``, passing your maxmind ``account_id`` and\n``license_key`` to the constructor. to use the geolite2 web service instead of\nthe geoip2 web service, set the optional ``host`` keyword argument to\n``geolite.info``. to use the sandbox geoip2 web service instead of the\nproduction geoip2 web service, set the optional ``host`` keyword argument to\n``sandbox.maxmind.com``.\n\nafter doing this, you may call the method corresponding to request type\n(e.g., ``city`` or ``country``), passing it the ip address you want to look up.\n\nif the request succeeds, the method call will return a model class for the\nendpoint you called. this model in turn contains multiple record classes,\neach of which represents part of the data returned by the web service.\n\nif the request fails, the client class throws an exception.\n\nsync web service example\n------------------------\n\n.. code-block:: pycon\n\n    >>> import geoip2.webservice\n    >>>\n    >>> # this creates a client object that can be reused across requests.\n    >>> # replace \"42\" with your account id and \"license_key\" with your license\n    >>> # key. set the \"host\" keyword argument to \"geolite.info\" to use the\n    >>> # geolite2 web service instead of the geoip2 web service. set the\n    >>> # \"host\" keyword argument to \"sandbox.maxmind.com\" to use the sandbox\n    >>> # geoip2 web service instead of the production geoip2 web service.\n    >>> with geoip2.webservice.client(42, 'license_key') as client:\n    >>>\n    >>>     # replace \"city\" with the method corresponding to the web service\n    >>>     # that you are using, i.e., \"country\", \"city\", or \"insights\". please\n    >>>     # note that insights is not supported by the geolite2 web service.\n    >>>     response = client.city('203.0.113.0')\n    >>>\n    >>>     response.country.iso_code\n    'us'\n    >>>     response.country.name\n    'united states'\n    >>>     response.country.names['zh-cn']\n    u'\u7f8e\u56fd'\n    >>>\n    >>>     response.subdivisions.most_specific.name\n    'minnesota'\n    >>>     response.subdivisions.most_specific.iso_code\n    'mn'\n    >>>\n    >>>     response.city.name\n    'minneapolis'\n    >>>\n    >>>     response.postal.code\n    '55455'\n    >>>\n    >>>     response.location.latitude\n    44.9733\n    >>>     response.location.longitude\n    -93.2323\n    >>>\n    >>>     response.traits.network\n    ipv4network('203.0.113.0/32')\n\nasync web service example\n-------------------------\n\n.. code-block:: pycon\n\n    >>> import asyncio\n    >>>\n    >>> import geoip2.webservice\n    >>>\n    >>> async def main():\n    >>>     # this creates an asyncclient object that can be reused across\n    >>>     # requests on the running event loop. if you are using multiple event\n    >>>     # loops, you must ensure the object is not used on another loop.\n    >>>     #\n    >>>     # replace \"42\" with your account id and \"license_key\" with your license\n    >>>     # key. set the \"host\" keyword argument to \"geolite.info\" to use the\n    >>>     # geolite2 web service instead of the geoip2 web service. set the\n    >>>     # \"host\" keyword argument to \"sandbox.maxmind.com\" to use the sandbox\n    >>>     # geoip2 web service instead of the production geoip2 web service.\n    >>>     async with geoip2.webservice.asyncclient(42, 'license_key') as client:\n    >>>\n    >>>         # replace \"city\" with the method corresponding to the web service\n    >>>         # that you are using, i.e., \"country\", \"city\", or \"insights\". please\n    >>>         # note that insights is not supported by the geolite2 web service.\n    >>>         response = await client.city('203.0.113.0')\n    >>>\n    >>>         response.country.iso_code\n    'us'\n    >>>         response.country.name\n    'united states'\n    >>>         response.country.names['zh-cn']\n    u'\u7f8e\u56fd'\n    >>>\n    >>>         response.subdivisions.most_specific.name\n    'minnesota'\n    >>>         response.subdivisions.most_specific.iso_code\n    'mn'\n    >>>\n    >>>         response.city.name\n    'minneapolis'\n    >>>\n    >>>         response.postal.code\n    '55455'\n    >>>\n    >>>         response.location.latitude\n    44.9733\n    >>>         response.location.longitude\n    -93.2323\n    >>>\n    >>>         response.traits.network\n    ipv4network('203.0.113.0/32')\n    >>>\n    >>> asyncio.run(main())\n\nweb service client exceptions\n-----------------------------\n\nfor details on the possible errors returned by the web service itself, see\nhttps://dev.maxmind.com/geoip/docs/web-services?lang=en for the geoip2 web\nservice docs.\n\nif the web service returns an explicit error document, this is thrown as a\n``addressnotfounderror``, ``authenticationerror``, ``invalidrequesterror``, or\n``outofquerieserror`` as appropriate. these all subclass ``geoip2error``.\n\nif some other sort of error occurs, this is thrown as an ``httperror``. this\nis thrown when some sort of unanticipated error occurs, such as the web\nservice returning a 500 or an invalid error document. if the web service\nreturns any status code besides 200, 4xx, or 5xx, this also becomes an\n``httperror``.\n\nfinally, if the web service returns a 200 but the body is invalid, the client\nthrows a ``geoip2error``.\n\ndatabase usage\n--------------\n\nto use the database api, you first construct a ``geoip2.database.reader`` using\nthe path to the file as the first argument. after doing this, you may call the\nmethod corresponding to database type (e.g., ``city`` or ``country``), passing it\nthe ip address you want to look up.\n\nif the lookup succeeds, the method call will return a model class for the\ndatabase method you called. this model in turn contains multiple record classes,\neach of which represents part of the data for the record.\n\nif the request fails, the reader class throws an exception.\n\ndatabase example\n----------------\n\ncity database\n^^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geolite2-city.mmdb') as reader:\n    >>>\n    >>>     # replace \"city\" with the method corresponding to the database\n    >>>     # that you are using, e.g., \"country\".\n    >>>     response = reader.city('203.0.113.0')\n    >>>\n    >>>     response.country.iso_code\n    'us'\n    >>>     response.country.name\n    'united states'\n    >>>     response.country.names['zh-cn']\n    u'\u7f8e\u56fd'\n    >>>\n    >>>     response.subdivisions.most_specific.name\n    'minnesota'\n    >>>     response.subdivisions.most_specific.iso_code\n    'mn'\n    >>>\n    >>>     response.city.name\n    'minneapolis'\n    >>>\n    >>>     response.postal.code\n    '55455'\n    >>>\n    >>>     response.location.latitude\n    44.9733\n    >>>     response.location.longitude\n    -93.2323\n    >>>\n    >>>     response.traits.network\n    ipv4network('203.0.113.0/24')\n\nanonymous ip database\n^^^^^^^^^^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geoip2-anonymous-ip.mmdb') as reader:\n    >>>\n    >>>     response = reader.anonymous_ip('203.0.113.0')\n    >>>\n    >>>     response.is_anonymous\n    true\n    >>>     response.is_anonymous_vpn\n    false\n    >>>     response.is_hosting_provider\n    false\n    >>>     response.is_public_proxy\n    false\n    >>>     response.is_residential_proxy\n    false\n    >>>     response.is_tor_exit_node\n    true\n    >>>     response.ip_address\n    '203.0.113.0'\n    >>>     response.network\n    ipv4network('203.0.113.0/24')\n\nasn database\n^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geolite2-asn.mmdb') as reader:\n    >>>     response = reader.asn('203.0.113.0')\n    >>>     response.autonomous_system_number\n    1221\n    >>>     response.autonomous_system_organization\n    'telstra pty ltd'\n    >>>     response.ip_address\n    '203.0.113.0'\n    >>>     response.network\n    ipv4network('203.0.113.0/24')\n\nconnection-type database\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geoip2-connection-type.mmdb') as reader:\n    >>>     response = reader.connection_type('203.0.113.0')\n    >>>     response.connection_type\n    'corporate'\n    >>>     response.ip_address\n    '203.0.113.0'\n    >>>     response.network\n    ipv4network('203.0.113.0/24')\n\n\ndomain database\n^^^^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geoip2-domain.mmdb') as reader:\n    >>>     response = reader.domain('203.0.113.0')\n    >>>     response.domain\n    'umn.edu'\n    >>>     response.ip_address\n    '203.0.113.0'\n\nenterprise database\n^^^^^^^^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geoip2-enterprise.mmdb') as reader:\n    >>>\n    >>>     # use the .enterprise method to do a lookup in the enterprise database\n    >>>     response = reader.enterprise('203.0.113.0')\n    >>>\n    >>>     response.country.confidence\n    99\n    >>>     response.country.iso_code\n    'us'\n    >>>     response.country.name\n    'united states'\n    >>>     response.country.names['zh-cn']\n    u'\u7f8e\u56fd'\n    >>>\n    >>>     response.subdivisions.most_specific.name\n    'minnesota'\n    >>>     response.subdivisions.most_specific.iso_code\n    'mn'\n    >>>     response.subdivisions.most_specific.confidence\n    77\n    >>>\n    >>>     response.city.name\n    'minneapolis'\n    >>>     response.country.confidence\n    11\n    >>>\n    >>>     response.postal.code\n    '55455'\n    >>>\n    >>>     response.location.accuracy_radius\n    50\n    >>>     response.location.latitude\n    44.9733\n    >>>     response.location.longitude\n    -93.2323\n    >>>\n    >>>     response.traits.network\n    ipv4network('203.0.113.0/24')\n\n\nisp database\n^^^^^^^^^^^^\n\n.. code-block:: pycon\n\n    >>> import geoip2.database\n    >>>\n    >>> # this creates a reader object. you should use the same object\n    >>> # across multiple requests as creation of it is expensive.\n    >>> with geoip2.database.reader('/path/to/geoip2-isp.mmdb') as reader:\n    >>>     response = reader.isp('203.0.113.0')\n    >>>     response.autonomous_system_number\n    1221\n    >>>     response.autonomous_system_organization\n    'telstra pty ltd'\n    >>>     response.isp\n    'telstra internet'\n    >>>     response.organization\n    'telstra internet'\n    >>>     response.ip_address\n    '203.0.113.0'\n    >>>     response.network\n    ipv4network('203.0.113.0/24')\n\ndatabase reader exceptions\n--------------------------\n\nif the database file does not exist or is not readable, the constructor will\nraise a ``filenotfounderror`` or a ``permissionerror``. if the ip address passed\nto a method is invalid, a ``valueerror`` will be raised. if the file is invalid\nor there is a bug in the reader, a ``maxminddb.invaliddatabaseerror`` will be\nraised with a description of the problem. if an ip address is not in the\ndatabase, a ``addressnotfounderror`` will be raised.\n\n``addressnotfounderror`` references the largest subnet where no address would be\nfound. this can be used to efficiently enumerate entire subnets:\n\n.. code-block:: python\n\n    import geoip2.database\n    import geoip2.errors\n    import ipaddress\n\n    # this creates a reader object. you should use the same object\n    # across multiple requests as creation of it is expensive.\n    with geoip2.database.reader('/path/to/geolite2-asn.mmdb') as reader:\n        network = ipaddress.ip_network(\"192.128.0.0/15\")\n\n        ip_address = network[0]\n        while ip_address in network:\n            try:\n                response = reader.asn(ip_address)\n                response_network = response.network\n            except geoip2.errors.addressnotfounderror as e:\n                response = none\n                response_network = e.network\n            print(f\"{response_network}: {response!r}\")\n            ip_address = response_network[-1] + 1  # move to next subnet\n\nvalues to use for database or dictionary keys\n---------------------------------------------\n\n**we strongly discourage you from using a value from any ``names`` property as\na key in a database or dictionaries.**\n\nthese names may change between releases. instead we recommend using one of the\nfollowing:\n\n* ``geoip2.records.city`` - ``city.geoname_id``\n* ``geoip2.records.continent`` - ``continent.code`` or ``continent.geoname_id``\n* ``geoip2.records.country`` and ``geoip2.records.representedcountry`` - ``country.iso_code`` or ``country.geoname_id``\n* ``geoip2.records.subdivision`` - ``subdivision.iso_code`` or ``subdivision.geoname_id``\n\nwhat data is returned?\n----------------------\n\nwhile many of the models contain the same basic records, the attributes which\ncan be populated vary between web service endpoints or databases. in\naddition, while a model may offer a particular piece of data, maxmind does not\nalways have every piece of data for any given ip address.\n\nbecause of these factors, it is possible for any request to return a record\nwhere some or all of the attributes are unpopulated.\n\nthe only piece of data which is always returned is the ``ip_address``\nattribute in the ``geoip2.records.traits`` record.\n\nintegration with geonames\n-------------------------\n\n`geonames <https://www.geonames.org/>`_ offers web services and downloadable\ndatabases with data on geographical features around the world, including\npopulated places. they offer both free and paid premium data. each feature is\nuniquely identified by a ``geoname_id``, which is an integer.\n\nmany of the records returned by the geoip web services and databases include a\n``geoname_id`` field. this is the id of a geographical feature (city, region,\ncountry, etc.) in the geonames database.\n\nsome of the data that maxmind provides is also sourced from geonames. we\nsource things like place names, iso codes, and other similar data from the\ngeonames premium data set.\n\nreporting data problems\n-----------------------\n\nif the problem you find is that an ip address is incorrectly mapped, please\n`submit your correction to maxmind <https://www.maxmind.com/en/correction>`_.\n\nif you find some other sort of mistake, like an incorrect spelling, please\ncheck the `geonames site <https://www.geonames.org/>`_ first. once you've\nsearched for a place and found it on the geonames map view, there are a\nnumber of links you can use to correct data (\"move\", \"edit\", \"alternate\nnames\", etc.). once the correction is part of the geonames data set, it\nwill be automatically incorporated into future maxmind releases.\n\nif you are a paying maxmind customer and you're not sure where to submit a\ncorrection, please `contact maxmind support\n<https://www.maxmind.com/en/support>`_ for help.\n\nrequirements\n------------\n\npython 3.8 or greater is required. older versions are not supported.\n\nthe requests http library is also required. see\n<https://pypi.org/project/requests/> for details.\n\nversioning\n----------\n\nthe geoip2 python api uses `semantic versioning <https://semver.org/>`_.\n\nsupport\n-------\n\nplease report all issues with this code using the `github issue tracker\n<https://github.com/maxmind/geoip2-python/issues>`_\n\nif you are having an issue with a maxmind service that is not specific to the\nclient api, please contact `maxmind support\n<https://www.maxmind.com/en/support>`_ for assistance.\n",
  "docs_url": "https://pythonhosted.org/geoip2/",
  "keywords": "",
  "license": "apache license, version 2.0",
  "name": "geoip2",
  "package_url": "https://pypi.org/project/geoip2/",
  "project_url": "https://pypi.org/project/geoip2/",
  "project_urls": {
    "Documentation": "https://geoip2.readthedocs.org/",
    "Homepage": "https://www.maxmind.com/",
    "Issue Tracker": "https://github.com/maxmind/GeoIP2-python/issues",
    "Source Code": "https://github.com/maxmind/GeoIP2-python"
  },
  "release_url": "https://pypi.org/project/geoip2/4.8.0/",
  "requires_dist": [
    "aiohttp <4.0.0,>=3.6.2",
    "maxminddb <3.0.0,>=2.5.1",
    "requests <3.0.0,>=2.24.0",
    "setuptools >=60.0.0",
    "mocket >=3.11.1 ; extra == 'test'"
  ],
  "requires_python": ">=3.8",
  "summary": "maxmind geoip2 api",
  "version": "4.8.0",
  "releases": [],
  "developers": [
    "goschwald@maxmind.com"
  ],
  "kwds": "geoip2error geoip2 geoip maxminddb geolite2",
  "license_kwds": "apache license, version 2.0",
  "libtype": "pypi",
  "id": "pypi_geoip2",
  "homepage": "",
  "release_count": 39,
  "dependency_ids": [
    "pypi_aiohttp",
    "pypi_maxminddb",
    "pypi_mocket",
    "pypi_requests",
    "pypi_setuptools"
  ]
}