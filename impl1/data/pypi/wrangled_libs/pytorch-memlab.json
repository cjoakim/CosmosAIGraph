{
  "classifiers": [
    "programming language :: python",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "pytorch_memlab\n======\n[![build status](https://travis-ci.com/stonesjtu/pytorch_memlab.svg?token=vytdxhbi1pcrzv6dishp&branch=master)](https://travis-ci.com/stonesjtu/pytorch_memlab)\n![pypi](https://img.shields.io/pypi/v/pytorch_memlab.svg)\n[![codeql: python](https://github.com/stonesjtu/pytorch_memlab/actions/workflows/github-code-scanning/codeql/badge.svg)](https://github.com/stonesjtu/pytorch_memlab/actions/workflows/github-code-scanning/codeql)\n![pypi - downloads](https://img.shields.io/pypi/dm/pytorch_memlab.svg)\n\na simple and accurate **cuda** memory management laboratory for pytorch,\nit consists of different parts about the memory:\n\n- features:\n\n  - memory profiler: a `line_profiler` style cuda memory profiler with simple api.\n  - memory reporter: a reporter to inspect tensors occupying the cuda memory.\n  - courtesy: an interesting feature to temporarily move all the cuda tensors into\n    cpu memory for courtesy, and of course the backward transferring.\n  - ipython support through `%mlrun`/`%%mlrun` line/cell magic\n    commands.\n\n\n- table of contents\n  * [installation](#installation)\n  * [user-doc](#user-doc)\n    + [memory profiler](#memory-profiler)\n    + [ipython support](#ipython-support)\n    + [memory reporter](#memory-reporter)\n    + [courtesy](#courtesy)\n    + [ack](#ack)\n  * [changes](#changes)\n\ninstallation\n-----\n\n- released version:\n```bash\npip install pytorch_memlab\n```\n\n- newest version:\n```bash\npip install git+https://github.com/stonesjtu/pytorch_memlab\n```\n\nwhat's for\n-----\n\nout-of-memory errors in pytorch happen frequently, for new-bees and\nexperienced programmers. a common reason is that most people don't really\nlearn the underlying memory management philosophy of pytorch and gpus.\nthey wrote memory in-efficient codes and complained about pytorch eating too\nmuch cuda memory.\n\nin this repo, i'm going to share some useful tools to help debugging oom, or\nto inspect the underlying mechanism if anyone is interested in.\n\n\nuser-doc\n-----\n\n### memory profiler\n\nthe memory profiler is a modification of python's `line_profiler`, it gives\nthe memory usage info for each line of code in the specified function/method.\n\n#### sample:\n\n```python\nimport torch\nfrom pytorch_memlab import lineprofiler\n\ndef inner():\n    torch.nn.linear(100, 100).cuda()\n\ndef outer():\n    linear = torch.nn.linear(100, 100).cuda()\n    linear2 = torch.nn.linear(100, 100).cuda()\n    linear3 = torch.nn.linear(100, 100).cuda()\n\nwork()\n```\n\nafter the script finishes or interrupted by keyboard, it gives the following\nprofiling info if you're in a jupyter notebook:\n\n<p align=\"center\"><img src=\"readme-output.png\" width=\"640\"></p>\n\nor the following info if you're in a text-only terminal:\n\n```\n## outer\n\nactive_bytes reserved_bytes line  code\n         all            all\n        peak           peak\n       0.00b          0.00b    7  def outer():\n      40.00k          2.00m    8      linear = torch.nn.linear(100, 100).cuda()\n      80.00k          2.00m    9      linear2 = torch.nn.linear(100, 100).cuda()\n     120.00k          2.00m   10      inner()\n\n\n## inner\n\nactive_bytes reserved_bytes line  code\n         all            all\n        peak           peak\n      80.00k          2.00m    4  def inner():\n     120.00k          2.00m    5      torch.nn.linear(100, 100).cuda()\n```\n\nan explanation of what each column means can be found in the [torch documentation](https://pytorch.org/docs/stable/cuda.html#torch.cuda.memory_stats). the name of any field from `memory_stats()`\ncan be passed to `display()` to view the corresponding statistic.\n\nif you use `profile` decorator, the memory statistics are collected during\nmultiple runs and only the maximum one is displayed at the end.\nwe also provide a more flexible api called `profile_every` which prints the\nmemory info every *n* times of function execution. you can simply replace\n`@profile` with `@profile_every(1)` to print the memory usage for each\nexecution.\n\nthe `@profile` and `@profile_every` can also be mixed to gain more control\nof the debugging granularity.\n\n- you can also add the decorator in the module class:\n\n```python\nclass net(torch.nn.module):\n    def __init__(self):\n        super().__init__()\n    @profile\n    def forward(self, inp):\n        #do_something\n```\n\n- the *line profiler* profiles the memory usage of cuda device 0 by default,\nyou may want to switch the device to profile by `set_target_gpu`. the gpu\nselection is globally,  which means you have to remember which gpu you are\nprofiling on during the whole process:\n\n```python\nimport torch\nfrom pytorch_memlab import profile, set_target_gpu\n@profile\ndef func():\n    net1 = torch.nn.linear(1024, 1024).cuda(0)\n    set_target_gpu(1)\n    net2 = torch.nn.linear(1024, 1024).cuda(1)\n    set_target_gpu(0)\n    net3 = torch.nn.linear(1024, 1024).cuda(0)\n\nfunc()\n```\n\n\nmore samples can be found in `test/test_line_profiler.py`\n\n### ipython support\n\nmake sure you have `ipython` installed, or have installed `pytorch-memlab` with\n`pip install pytorch-memlab[ipython]`.\n\nfirst, load the extension:\n\n```python\n%load_ext pytorch_memlab\n```\n\nthis makes the `%mlrun` and `%%mlrun` line/cell magics available for use. for\nexample, in a new cell run the following to profile an entire cell\n\n```python\n%%mlrun -f func\nimport torch\nfrom pytorch_memlab import profile, set_target_gpu\ndef func():\n    net1 = torch.nn.linear(1024, 1024).cuda(0)\n    set_target_gpu(1)\n    net2 = torch.nn.linear(1024, 1024).cuda(1)\n    set_target_gpu(0)\n    net3 = torch.nn.linear(1024, 1024).cuda(0)\n```\n\nor you can invoke the profiler for a single statement on via the `%mlrun` cell\nmagic.\n\n```python\nimport torch\nfrom pytorch_memlab import profile, set_target_gpu\ndef func(input_size):\n    net1 = torch.nn.linear(input_size, 1024).cuda(0)\n%mlrun -f func func(2048)\n```\n\nsee `%mlrun?` for help on what arguments are supported. you can set the gpu\ndevice to profile, dump profiling results to a file, and return the\n`lineprofiler` object for post-profile inspection.\n\nfind out more by checking out the [demo jupyter notebook](./demo.ipynb)\n\n\n### memory reporter\n\nas *memory profiler* only gives the overall memory usage information by lines,\na more low-level memory usage information can be obtained by *memory reporter*.\n\n*memory reporter* iterates all the `tensor` objects and gets the underlying\n`storage` object to get the actual memory usage instead of the surface\n`tensor.size`.\n\n#### sample\n\n- a minimal one:\n\n```python\nimport torch\nfrom pytorch_memlab import memreporter\nlinear = torch.nn.linear(1024, 1024).cuda()\nreporter = memreporter()\nreporter.report()\n```\noutputs:\n```\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nparameter0                                      (1024, 1024)     4.00m\nparameter1                                           (1024,)     4.00k\n-------------------------------------------------------------------------------\ntotal tensors: 1049600  used memory: 4.00m\nthe allocated memory on cuda:0: 4.00m\n-------------------------------------------------------------------------------\n```\n\n- you can also pass in a model object for automatically name inference.\n\n```python\nimport torch\nfrom pytorch_memlab import memreporter\n\nlinear = torch.nn.linear(1024, 1024).cuda()\ninp = torch.tensor(512, 1024).cuda()\n# pass in a model to automatically infer the tensor names\nreporter = memreporter(linear)\nout = linear(inp).mean()\nprint('========= before backward =========')\nreporter.report()\nout.backward()\nprint('========= after backward =========')\nreporter.report()\n```\n\noutputs:\n```\n========= before backward =========\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nweight                                          (1024, 1024)     4.00m\nbias                                                 (1024,)     4.00k\ntensor0                                          (512, 1024)     2.00m\ntensor1                                                 (1,)   512.00b\n-------------------------------------------------------------------------------\ntotal tensors: 1573889  used memory: 6.00m\nthe allocated memory on cuda:0: 6.00m\n-------------------------------------------------------------------------------\n========= after backward =========\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nweight                                          (1024, 1024)     4.00m\nweight.grad                                     (1024, 1024)     4.00m\nbias                                                 (1024,)     4.00k\nbias.grad                                            (1024,)     4.00k\ntensor0                                          (512, 1024)     2.00m\ntensor1                                                 (1,)   512.00b\n-------------------------------------------------------------------------------\ntotal tensors: 2623489  used memory: 10.01m\nthe allocated memory on cuda:0: 10.01m\n-------------------------------------------------------------------------------\n```\n\n\n- the reporter automatically deals with the sharing weights parameters:\n\n```python\nimport torch\nfrom pytorch_memlab import memreporter\n\nlinear = torch.nn.linear(1024, 1024).cuda()\nlinear2 = torch.nn.linear(1024, 1024).cuda()\nlinear2.weight = linear.weight\ncontainer = torch.nn.sequential(\n    linear, linear2\n)\ninp = torch.tensor(512, 1024).cuda()\n# pass in a model to automatically infer the tensor names\n\nout = container(inp).mean()\nout.backward()\n\n# verbose shows how storage is shared across multiple tensors\nreporter = memreporter(container)\nreporter.report(verbose=true)\n```\n\noutputs:\n```\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\n0.weight                                        (1024, 1024)     4.00m\n0.weight.grad                                   (1024, 1024)     4.00m\n0.bias                                               (1024,)     4.00k\n0.bias.grad                                          (1024,)     4.00k\n1.bias                                               (1024,)     4.00k\n1.bias.grad                                          (1024,)     4.00k\ntensor0                                          (512, 1024)     2.00m\ntensor1                                                 (1,)   512.00b\n-------------------------------------------------------------------------------\ntotal tensors: 2625537  used memory: 10.02m\nthe allocated memory on cuda:0: 10.02m\n-------------------------------------------------------------------------------\n```\n\n- you can better understand the memory layout for more complicated module:\n\n```python\nimport torch\nfrom pytorch_memlab import memreporter\n\nlstm = torch.nn.lstm(1024, 1024).cuda()\nreporter = memreporter(lstm)\nreporter.report(verbose=true)\ninp = torch.tensor(10, 10, 1024).cuda()\nout, _ = lstm(inp)\nout.mean().backward()\nreporter.report(verbose=true)\n```\n\nas shown below, the `(->)` indicates the re-use of the same storage back-end\noutputs:\n```\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nweight_ih_l0                                    (4096, 1024)    32.03m\nweight_hh_l0(->weight_ih_l0)                    (4096, 1024)     0.00b\nbias_ih_l0(->weight_ih_l0)                           (4096,)     0.00b\nbias_hh_l0(->weight_ih_l0)                           (4096,)     0.00b\ntensor0                                       (10, 10, 1024)   400.00k\n-------------------------------------------------------------------------------\ntotal tensors: 8499200  used memory: 32.42m\nthe allocated memory on cuda:0: 32.52m\nmemory differs due to the matrix alignment\n-------------------------------------------------------------------------------\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nweight_ih_l0                                    (4096, 1024)    32.03m\nweight_ih_l0.grad                               (4096, 1024)    32.03m\nweight_hh_l0(->weight_ih_l0)                    (4096, 1024)     0.00b\nweight_hh_l0.grad(->weight_ih_l0.grad)          (4096, 1024)     0.00b\nbias_ih_l0(->weight_ih_l0)                           (4096,)     0.00b\nbias_ih_l0.grad(->weight_ih_l0.grad)                 (4096,)     0.00b\nbias_hh_l0(->weight_ih_l0)                           (4096,)     0.00b\nbias_hh_l0.grad(->weight_ih_l0.grad)                 (4096,)     0.00b\ntensor0                                       (10, 10, 1024)   400.00k\ntensor1                                       (10, 10, 1024)   400.00k\ntensor2                                        (1, 10, 1024)    40.00k\ntensor3                                        (1, 10, 1024)    40.00k\n-------------------------------------------------------------------------------\ntotal tensors: 17018880         used memory: 64.92m\nthe allocated memory on cuda:0: 65.11m\nmemory differs due to the matrix alignment\n-------------------------------------------------------------------------------\n```\n\nnotice:\n> when forwarding with `grad_mode=true`, pytorch maintains tensor buffers for\n> future back-propagation, in c level. so these buffers are not going to be\n> managed or collected by pytorch. but if you store these intermediate results\n> as python variables, then they will be reported.\n\n- you can also filter the device to report on by passing extra arguments:\n`report(device=torch.device(0))`\n\n- a failed example due to pytorch's c side tensor buffers\n\nin the following example, a temp buffer is created at `inp * (inp + 2)` to\nstore both `inp` and `inp + 2`, unfortunately python only knows the existence\nof inp, so we have *2m* memory lost, which is the same size of tensor `inp`.\n\n```python\nimport torch\nfrom pytorch_memlab import memreporter\n\nlinear = torch.nn.linear(1024, 1024).cuda()\ninp = torch.tensor(512, 1024).cuda()\n# pass in a model to automatically infer the tensor names\nreporter = memreporter(linear)\nout = linear(inp * (inp + 2)).mean()\nreporter.report()\n```\n\noutputs:\n```\nelement type                                            size  used mem\n-------------------------------------------------------------------------------\nstorage on cuda:0\nweight                                          (1024, 1024)     4.00m\nbias                                                 (1024,)     4.00k\ntensor0                                          (512, 1024)     2.00m\ntensor1                                                 (1,)   512.00b\n-------------------------------------------------------------------------------\ntotal tensors: 1573889  used memory: 6.00m\nthe allocated memory on cuda:0: 8.00m\nmemory differs due to the matrix alignment or invisible gradient buffer tensors\n-------------------------------------------------------------------------------\n```\n\n\n### courtesy\n\nsometimes people would like to preempt your running task, but you don't want\nto save checkpoint and then load, actually all they need is gpu resources (\ntypically cpu resources and cpu memory is always spare in gpu clusters), so\nyou can move all your workspaces from gpu to cpu and then halt your task until\na restart signal is triggered, instead of saving&loading checkpoints and\nbootstrapping from scratch.\n\nstill developing..... but you can have fun with:\n```python\nfrom pytorch_memlab import courtesy\n\niamcourtesy = courtesy()\nfor i in range(num_iteration):\n    if something_happens:\n        iamcourtesy.yield_memory()\n        wait_for_restart_signal()\n        iamcourtesy.restore()\n```\n\n#### known issues\n\n- as is stated above in `memory_reporter`, intermediate tensors are not covered\nproperly, so you may want to insert such courtesy logics after `backward` or\nbefore `forward`.\n- currently the cuda context of pytorch requires about 1 gb cuda memory, which\nmeans even all tensors are on cpu, 1gb of cuda memory is wasted, :-(. however\nit's still under investigation if i can fully destroy the context and then\nre-init.\n\n\n### ack\n\ni suffered a lot debugging weird memory usage during my 3-years of developing\nefficient deep learning models, and of course learned a lot from the great\nopen source community.\n\n## changes\n\n\n##### 0.2.4 (2021-10-28)\n  - fix colab error (#35)\n  - support python3.8 (#38)\n  - support sparse tensor (#30)\n##### 0.2.3 (2020-12-01)\n  - fix name mapping in `memreporter` (#24)\n  - fix reporter without model input (#22 #25)\n##### 0.2.2 (2020-10-23)\n  - fix memory leak in `memreporter`\n##### 0.2.1 (2020-06-18)\n  - fix `line_profiler` not found\n##### 0.2.0 (2020-06-15)\n  - add jupyter notebook figure and ipython support\n##### 0.1.0 (2020-04-17)\n  - add ipython magic support (#8)\n##### 0.0.4 (2019-10-08)\n  - add gpu switch for line-profiler(#2)\n  - add device filter for reporter\n##### 0.0.3 (2019-06-15)\n  - install dependency for pip installation\n##### 0.0.2 (2019-06-04)\n  - fix statistics shift in loop\n##### 0.0.1 (2019-05-28)\n  - initial release\n\n\n",
  "docs_url": null,
  "keywords": "pytorch memory profile",
  "license": "mit",
  "name": "pytorch-memlab",
  "package_url": "https://pypi.org/project/pytorch-memlab/",
  "project_url": "https://pypi.org/project/pytorch-memlab/",
  "project_urls": {
    "Homepage": "https://github.com/Stonesjtu/pytorch_memlab"
  },
  "release_url": "https://pypi.org/project/pytorch-memlab/0.3.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a lab to do simple and accurate memory experiments on pytorch",
  "version": "0.3.0",
  "releases": [],
  "developers": [
    "kaiyu_shi",
    "skyisno.1@gmail.com"
  ],
  "kwds": "pytorch_memlab pytorch memory_reporter memory_stats yield_memory",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytorch_memlab",
  "homepage": "https://github.com/stonesjtu/pytorch_memlab",
  "release_count": 11,
  "dependency_ids": []
}