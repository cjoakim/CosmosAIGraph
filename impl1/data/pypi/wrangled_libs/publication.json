{
  "classifiers": [
    "license :: osi approved :: mit license",
    "programming language :: python :: 2",
    "programming language :: python :: 3"
  ],
  "description": "what is this?\n=============\n\nsetting expectations around what apis you can rely on in a python\nlibrary is very difficult.\n\npublication makes it easy.\n\nthe problem\n-----------\n\nas `hyrum's law <http://www.hyrumslaw.com>`_ somewhat grimly states,\n\n    | with a sufficient number of users of an api,\n    | it does not matter what you promise in the contract:\n    | all observable behaviors of your system\n    | will be depended on by somebody.\n\nin general, python famously has a somewhat different philosophical view of this\nreality.  we assume each other to be `responsible users\n<https://github.com/realpython/python-guide/pull/524/files>`_ of the libraries\nwe consume.  mucking with implementation details might break every time you\nupgrade, but it's sufficiently useful for testing, debugging, and\nexperimentation that retaining that ability is worth paying the cost.\n\nbut, critical to this assumption is that everybody *knows* when they're\nbreaking into the \"private\" area of the library's interface.  here, there's a\nmismatch of expectations:\n\n- *library authors* write documentation, and then think that users sit down and\n  read the documentation, front to back, and learn about what the \"public\"\n  interface is by doing so.  they then assume that users will know that they've\n  used private implementation details if they ever deviate from these\n  documented features.\n- *library users* ``pip install`` a thing, open up a repl, import the module,\n  and discover the library by doing ``dir()`` on the module and its contents,\n  assuming that their program is not using any private implementation details\n  as long as they never had to type ``library._something_private()`` while\n  doing so.  if they ever encounter a traceback they may consult the\n  documentation, briefly, until it is resolved.\n\npublication makes it possible to align the wildly divergent expectations of\nthese groups, so that users can still get the benefits of being able to use\ninternal details if they want, but they'll know that they're doing so.  it\nmakes the runtime namespace of your module look like the public documentation\nof your library.\n\nhow does this look in practice?\n-------------------------------\n\nyou, a prospective library author, want to write a library that makes it easy to zorf a sprocket.\ngreat! you do, and it looks like this:\n\n.. code:: python\n\n   # sprocket_zorfer.py\n   from sprocket import sprocket_with_name\n   from zorf import zorfable_thing\n\n   def zorf_sprocket_internal(sprocket, zorfulations):\n       ...\n   def compute_zorfulations():\n       ...\n\n   def zorf_sprocket_named(sprocket_name, how_much):\n       sprocket = sprocket_with_name(sprocket_name)\n       zorfulations = compute_zorfulations(how_much)\n       return zorf_sprocket_internal(sprocket, zorfulations)\n\n\n   __all__ = [\n       'zorf_sprocket_named'\n   ]\n\nyour intent here, of course, is that you have exposed a module with a\nsingle function: ``zorf_sprocket_named``, and everything else is an\nimplementation detail. you even said so, explicitly, with ``__all__``.\nyour api documentation says the same.\n\nhowever, reading reference documentation and cleanly respecting\nconventions is not how working programmers really figure out how to use\nstuff. your users all do stuff like:\n\n-  load up an interactive ``python`` interpreter and call ``dir()`` on\n   your module\n-  install jupyter and tab-complete their way around your module to find\n   what they want\n-  use the auto-import function in pycharm to grab some private\n   implementation detail\n\nand, before you know it, you have thousands of users of your library\nwith code like\n\n.. code:: python\n\n   from sprocket_zorfer import compute_zorfulations, zorf_sprocket_internal, sprocket_with_name\n\n   sprocket = sprocket_with_name(name)\n   zorf_sprocket_internal(sprocket, compute_zorfulations(7) * 2)\n\nnow you can never change *any* of your implementation details! worse\nyet, ``sprocket_with_name`` isn\u2019t even your own code; that\u2019s something\nyou got from a library! but when someone does\n``import sprocket_zorfer; sprocket_zorfer.<tab>`` in an interactive\nshell, none of that information comes through.\n\nunderscore paranoia\n-------------------\n\nthe convention in python is that we use ``_`` to indicate private names.\nso when we library authors notice this problem starting to happen, a\ncommon reaction is to start putting ``_`` in front of *everything* \u2013\nclass names, function names, module names \u2013 and only explicitly export\nthose things that should be public by \u201cmoving\u201d them via an import and an\nentry in a public module\u2019s ``__all__``.\n\nhowever, this has a bunch of disadvantages:\n\n-  most code inspection tooling and ides won\u2019t see that the public name\n   is \u201cmoved\u201d, so code exploration just makes it seem like *everything*\n   is an implementation detail now, rather than making it seem like\n   nothing is.\n\n-  all your ``__repr__``\\ s now have ugly and inaccurate function and\n   class names in them, at least from the perspective of your users; how\n   are they supposed to know ``zorf_sprocket_named`` is actually defined\n   in ``zorf_sprocket._impl_details.funcs._zorf_sprocket_public`` now?\n   how are they supposed to find the good, public name once they\u2019re\n   looking at the goofy internal one?\n\n-  you constantly need to remember to put *all* of your code in these\n   ugly ``_``-prefixed modules, and educate new contributors as to the\n   risks of creating new modules in your package that are not carefully\n   hidden away from public users.\n\na better world\n--------------\n\nwhat if you could write all your code *as if* it were just regular\npublic code, and have all your implementation details and imports\nautomatically squirreled away in an underscore namespace so that curious\ncoders won\u2019t accidentally find every module you ever imported and every\ntemporary helper function you ever defined and think they\u2019re part of the\npermanent public face of your library?\n\nenter ``publication``.\n\n``publication`` uses the existing convention of ``__all__`` and a little\nruntime hackery to hide everything that you have not marked as\nexplicitly public, like so:\n\n.. code:: python\n\n   # sprocket_zorfer.py\n\n   from publication import publish\n\n   from sprocket import sprocket_with_name\n   from zorf import zorfable_thing\n\n   def zorf_sprocket_internal(sprocket, zorfulations):\n       ...\n   def compute_zorfulations():\n       ...\n\n   def zorf_sprocket_named(sprocket_name, how_much):\n       sprocket = sprocket_with_name(sprocket_name)\n       zorfulations = compute_zorfulations(how_much)\n       return zorf_sprocket_internal(sprocket, zorfulations)\n\n\n   __all__ = [\n       'zorf_sprocket_named'\n   ]\n\n   publish()\n\nthat\u2019s it! now, ``from sprocket_zorfer import zorf_sprocket_named``\nworks as intended, but\n``from sprocket_zorfer import compute_zorfulations`` is an\n``importerror``.\n\nbut what about\u2026\n---------------\n\nother modules in my package, like tests, that need to peek at implementation details?\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndon\u2019t worry, your code didn\u2019t go anywhere. the original module is still\navailable as a special pseudo-module called ``<your_module>._private``.\nin the example above, ``sprocket_zorfer.py``\\ \u2019s tests can still do:\n\n.. code:: python\n\n   from sprocket_zorfer._private import compute_zorfulations\n\n   def test_compute_zorfulations():\n       assert compute_zorfulations(0) > 7\n\nmypy?\n~~~~~\n\nyour types should *probably* just be part of your published api, if\nyou\u2019re expecting that users will need to know about them. but, if there\nare cases which need to be type-checked internally in your library, as\nfar as mypy is concerned, all your private classes are still there. so,\nin the simple case you can just do this:\n\n.. code:: python\n\n   from typing import type_checking\n   if type_checking:\n       from something import t\n\n   def returns_a() -> \"t\":\n       ...\n\nand in the hopefully very unusual case you need to mix runtime and\ntype-checking access to a different module\u2019s private details,\n\n.. code:: python\n\n   from typing import type_checking\n   if type_checking:\n       from something import t\n   else:\n       from something._private import t\n\n   def returns_a() -> a:\n       ...\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "publication",
  "package_url": "https://pypi.org/project/publication/",
  "project_url": "https://pypi.org/project/publication/",
  "project_urls": {
    "Homepage": "https://github.com/glyph/publication"
  },
  "release_url": "https://pypi.org/project/publication/0.0.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "publication helps you maintain public-api-friendly modules by preventing unintentional access to private implementation details via introspection.",
  "version": "0.0.3",
  "releases": [],
  "developers": [
    "glyph",
    "glyph@twistedmatrix.com"
  ],
  "kwds": "apis api py libraries python",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_publication",
  "homepage": "https://github.com/glyph/publication",
  "release_count": 3,
  "dependency_ids": []
}