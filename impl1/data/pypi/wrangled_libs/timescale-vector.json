{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# timescale vector\n\n<!-- warning: this file was autogenerated! do not edit! -->\n\npostgresql++ for ai applications.\n\n- [signup for timescale\n  vector](https://console.cloud.timescale.com/signup?utm_campaign=vectorlaunch&utm_source=github&utm_medium=direct):\n  get 90 days free to try timescale vector on the timescale cloud data\n  platform. there is no self-managed version at this time.\n- [documentation](https://timescale.github.io/python-vector/): learn the\n  key features of timescale vector and how to use them.\n- [getting started\n  tutorial](https://timescale.github.io/python-vector/tsv_python_getting_started_tutorial.html):\n  learn how to use timescale vector for semantic search on a real-world\n  dataset.\n- [learn\n  more](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/?utm_campaign=vectorlaunch&utm_source=github&utm_medium=direct):\n  learn more about timescale vector, how it works and why we built it.\n\nif you prefer to use an llm development or data framework, see timescale\nvector\u2019s integrations with\n[langchain](https://python.langchain.com/docs/integrations/vectorstores/timescalevector)\nand\n[llamaindex](https://gpt-index.readthedocs.io/en/stable/examples/vector_stores/timescalevector.html)\n\n## install\n\nto install the main library use:\n\n``` sh\npip install timescale_vector\n```\n\nwe also use `dotenv` in our examples for passing around secrets and\nkeys. you can install that with:\n\n``` sh\npip install python-dotenv\n```\n\n## basic usage\n\nfirst, import all the necessary libraries:\n\n``` python\nfrom dotenv import load_dotenv, find_dotenv\nimport os\nfrom timescale_vector import client\nimport uuid\nfrom datetime import datetime, timedelta\n```\n\nload up your postgresql credentials. safest way is with a .env file:\n\n``` python\n_ = load_dotenv(find_dotenv(), override=true) \nservice_url  = os.environ['timescale_service_url']\n```\n\nnext, create the client. in this tutorial, we will use the sync client.\nbut we have an async client as well (with an identical interface that\nuses async functions).\n\nthe client constructor takes three required arguments:\n\n| name           | description                                                                               |\n|----------------|-------------------------------------------------------------------------------------------|\n| service_url    | timescale service url / connection string                                                 |\n| table_name     | name of the table to use for storing the embeddings. think of this as the collection name |\n| num_dimensions | number of dimensions in the vector                                                        |\n\n``` python\nvec  = client.sync(service_url, \"my_data\", 2)\n```\n\nnext, create the tables for the collection:\n\n``` python\nvec.create_tables()\n```\n\nnext, insert some data. the data record contains:\n\n- a uuid to uniquely identify the embedding\n- a json blob of metadata about the embedding\n- the text the embedding represents\n- the embedding itself\n\nbecause this data includes uuids which become primary keys, we ingest\nwith upserts.\n\n``` python\nvec.upsert([\\\n    (uuid.uuid1(), {\"animal\": \"fox\"}, \"the brown fox\", [1.0,1.3]),\\\n    (uuid.uuid1(), {\"animal\": \"fox\", \"action\":\"jump\"}, \"jumped over the\", [1.0,10.8]),\\\n])\n```\n\nyou can now create a vector index to speed up similarity search:\n\n``` python\nvec.create_embedding_index(client.timescalevectorindex())\n```\n\nnow, you can query for similar items:\n\n``` python\nvec.search([1.0, 9.0])\n```\n\n    [[uuid('73d05df0-84c1-11ee-98da-6ee10b77fd08'),\n      {'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456],\n     [uuid('73d05d6e-84c1-11ee-98da-6ee10b77fd08'),\n      {'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\nthere are many search options which we will cover below in the\n`advanced search` section.\n\nas one example, we will return one item using a similarity search\nconstrained by a metadata filter.\n\n``` python\nvec.search([1.0, 9.0], limit=1, filter={\"action\": \"jump\"})\n```\n\n    [[uuid('73d05df0-84c1-11ee-98da-6ee10b77fd08'),\n      {'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\nthe returned records contain 5 fields:\n\n| name      | description                                             |\n|-----------|---------------------------------------------------------|\n| id        | the uuid of the record                                  |\n| metadata  | the json metadata associated with the record            |\n| contents  | the text content that was embedded                      |\n| embedding | the vector embedding                                    |\n| distance  | the distance between the query embedding and the vector |\n\nyou can access the fields by simply using the record as a dictionary\nkeyed on the field name:\n\n``` python\nrecords = vec.search([1.0, 9.0], limit=1, filter={\"action\": \"jump\"})\n(records[0][\"id\"],records[0][\"metadata\"], records[0][\"contents\"], records[0][\"embedding\"], records[0][\"distance\"])\n```\n\n    (uuid('73d05df0-84c1-11ee-98da-6ee10b77fd08'),\n     {'action': 'jump', 'animal': 'fox'},\n     'jumped over the',\n     array([ 1. , 10.8], dtype=float32),\n     0.00016793422934946456)\n\nyou can delete by id:\n\n``` python\nvec.delete_by_ids([records[0][\"id\"]])\n```\n\nor you can delete by metadata filters:\n\n``` python\nvec.delete_by_metadata({\"action\": \"jump\"})\n```\n\nto delete all records use:\n\n``` python\nvec.delete_all()\n```\n\n## advanced usage\n\nin this section, we will go into more detail about our feature. we will\ncover:\n\n1.  search filter options - how to narrow your search by additional\n    constraints\n2.  indexing - how to speed up your similarity queries\n3.  time-based partitioning - how to optimize similarity queries that\n    filter on time\n4.  setting different distance types to use in distance calculations\n\n### search options\n\nthe `search` function is very versatile and allows you to search for the\nright vector in a wide variety of ways. we\u2019ll describe the search option\nin 3 parts:\n\n1.  we\u2019ll cover basic similarity search.\n2.  then, we\u2019ll describe how to filter your search based on the\n    associated metadata.\n3.  finally, we\u2019ll talk about filtering on time when time-partitioning\n    is enabled.\n\nlet\u2019s use the following data for our example:\n\n``` python\nvec.upsert([\\\n    (uuid.uuid1(), {\"animal\":\"fox\", \"action\": \"sit\", \"times\":1}, \"the brown fox\", [1.0,1.3]),\\\n    (uuid.uuid1(),  {\"animal\":\"fox\", \"action\": \"jump\", \"times\":100}, \"jumped over the\", [1.0,10.8]),\\\n])\n```\n\nthe basic query looks like:\n\n``` python\nvec.search([1.0, 9.0])\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456],\n     [uuid('7487af14-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\nyou could provide a limit for the number of items returned:\n\n``` python\nvec.search([1.0, 9.0], limit=1)\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\n#### narrowing your search by metadata\n\nwe have two main ways to filter results by metadata: - `filters` for\nequality matches on metadata. - `predicates` for complex conditions on\nmetadata.\n\nfilters are more likely to be performant but are more limited in what\nthey can express, so we suggest using those if your use case allows it.\n\n##### filters\n\nyou could specify a match on the metadata as a dictionary where all keys\nhave to match the provided values (keys not in the filter are\nunconstrained):\n\n``` python\nvec.search([1.0, 9.0], limit=1, filter={\"action\": \"sit\"})\n```\n\n    [[uuid('7487af14-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\nyou can also specify a list of filter dictionaries, where an item is\nreturned if it matches any dict:\n\n``` python\nvec.search([1.0, 9.0], limit=2, filter=[{\"action\": \"jump\"}, {\"animal\": \"fox\"}])\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456],\n     [uuid('7487af14-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\n##### predicates\n\npredicates allow for more complex search conditions. for example, you\ncould use greater than and less than conditions on numeric values.\n\n``` python\nvec.search([1.0, 9.0], limit=2, predicates=client.predicates(\"times\", \">\", 1))\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\n[`predicates`](https://timescale.github.io/python-vector/vector.html#predicates)\nobjects are defined by the name of the metadata key, an operator, and a\nvalue.\n\nthe supported operators are: `==`, `!=`, `<`, `<=`, `>`, `>=`\n\nthe type of the values determines the type of comparison to perform. for\nexample, passing in `\"sam\"` (a string) will do a string comparison while\na `10` (an int) will perform an integer comparison while a `10.0`\n(float) will do a float comparison. it is important to note that using a\nvalue of `\"10\"` will do a string comparison as well so it\u2019s important to\nuse the right type. supported python types are: `str`, `int`, and\n`float`. one more example with a string comparison:\n\n``` python\nvec.search([1.0, 9.0], limit=2, predicates=client.predicates(\"action\", \"==\", \"jump\"))\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\nthe real power of predicates is that they can also be combined using the\n`&` operator (for combining predicates with and semantics) and `|`(for\ncombining using or semantic). so you can do:\n\n``` python\nvec.search([1.0, 9.0], limit=2, predicates=client.predicates(\"action\", \"==\", \"jump\") & client.predicates(\"times\", \">\", 1))\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\njust for sanity, let\u2019s show a case where no results are returned because\nor predicates:\n\n``` python\nvec.search([1.0, 9.0], limit=2, predicates=client.predicates(\"action\", \"==\", \"jump\") & client.predicates(\"times\", \"==\", 1))\n```\n\n    []\n\nand one more example where we define the predicates as a variable and\nuse grouping with parenthesis:\n\n``` python\nmy_predicates = client.predicates(\"action\", \"==\", \"jump\") & (client.predicates(\"times\", \"==\", 1) | client.predicates(\"times\", \">\", 1))\nvec.search([1.0, 9.0], limit=2, predicates=my_predicates)\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\nwe also have some semantic sugar for combining many predicates with and\nsemantics. you can pass in multiple 3-tuples to\n[`predicates`](https://timescale.github.io/python-vector/vector.html#predicates):\n\n``` python\nvec.search([1.0, 9.0], limit=2, predicates=client.predicates((\"action\", \"==\", \"jump\"), (\"times\", \">\", 10)))\n```\n\n    [[uuid('7487af96-84c1-11ee-98da-6ee10b77fd08'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\n#### filter your search by time\n\nwhen using `time-partitioning`(see below). you can very efficiently\nfilter your search by time. time-partitioning makes a timestamp embedded\nas part of the uuid-based id associated with an embedding. let us first\ncreate a collection with time partitioning and insert some data (one\nitem from january 2018 and another in january 2019):\n\n``` python\ntpvec = client.sync(service_url, \"time_partitioned_table\", 2, time_partition_interval=timedelta(hours=6))\ntpvec.create_tables()\n\nspecific_datetime = datetime(2018, 1, 1, 12, 0, 0)\ntpvec.upsert([\\\n    (client.uuid_from_time(specific_datetime), {\"animal\":\"fox\", \"action\": \"sit\", \"times\":1}, \"the brown fox\", [1.0,1.3]),\\\n    (client.uuid_from_time(specific_datetime+timedelta(days=365)),  {\"animal\":\"fox\", \"action\": \"jump\", \"times\":100}, \"jumped over the\", [1.0,10.8]),\\\n])\n```\n\nthen, you can filter using the timestamps by specifing a\n`uuid_time_filter`:\n\n``` python\ntpvec.search([1.0, 9.0], limit=4, uuid_time_filter=client.uuidtimerange(specific_datetime, specific_datetime+timedelta(days=1)))\n```\n\n    [[uuid('33c52800-ef15-11e7-be03-4f1f9a1bde5a'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\na\n[`uuidtimerange`](https://timescale.github.io/python-vector/vector.html#uuidtimerange)\ncan specify a start_date or end_date or both(as in the example above).\nspecifying only the start_date or end_date leaves the other end\nunconstrained.\n\n``` python\ntpvec.search([1.0, 9.0], limit=4, uuid_time_filter=client.uuidtimerange(start_date=specific_datetime))\n```\n\n    [[uuid('ac8be800-0de6-11e9-889a-5eec84ba8a7b'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456],\n     [uuid('33c52800-ef15-11e7-be03-4f1f9a1bde5a'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\nyou have the option to define the inclusivity of the start and end dates\nwith the `start_inclusive` and `end_inclusive` parameters. setting\n`start_inclusive` to true results in comparisons using the `>=`\noperator, whereas setting it to false applies the `>` operator. by\ndefault, the start date is inclusive, while the end date is exclusive.\none example:\n\n``` python\ntpvec.search([1.0, 9.0], limit=4, uuid_time_filter=client.uuidtimerange(start_date=specific_datetime, start_inclusive=false))\n```\n\n    [[uuid('ac8be800-0de6-11e9-889a-5eec84ba8a7b'),\n      {'times': 100, 'action': 'jump', 'animal': 'fox'},\n      'jumped over the',\n      array([ 1. , 10.8], dtype=float32),\n      0.00016793422934946456]]\n\nnotice how the results are different when we use the\n`start_inclusive=false` option because the first row has the exact\ntimestamp specified by `start_date`.\n\nwe\u2019ve also made it easy to integrate time filters using the `filter` and\n`predicates` parameters described above using special reserved key names\nto make it appear that the timestamps are part of your metadata. we\nfound this useful when integrating with other systems that just want to\nspecify a set of filters (often these are \u201cauto retriever\u201d type\nsystems). the reserved key names are `__start_date` and `__end_date` for\nfilters and `__uuid_timestamp` for predicates. some examples below:\n\n``` python\ntpvec.search([1.0, 9.0], limit=4, filter={ \"__start_date\": specific_datetime, \"__end_date\": specific_datetime+timedelta(days=1)})\n```\n\n    [[uuid('33c52800-ef15-11e7-be03-4f1f9a1bde5a'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\n``` python\ntpvec.search([1.0, 9.0], limit=4, \n             predicates=client.predicates(\"__uuid_timestamp\", \">\", specific_datetime) & client.predicates(\"__uuid_timestamp\", \"<\", specific_datetime+timedelta(days=1)))\n```\n\n    [[uuid('33c52800-ef15-11e7-be03-4f1f9a1bde5a'),\n      {'times': 1, 'action': 'sit', 'animal': 'fox'},\n      'the brown fox',\n      array([1. , 1.3], dtype=float32),\n      0.14489260377438218]]\n\n### indexing\n\nindexing speeds up queries over your data. by default, we set up indexes\nto query your data by the uuid and the metadata.\n\nbut to speed up similarity search based on the embeddings, you have to\ncreate additional indexes.\n\nnote that if performing a query without an index, you will always get an\nexact result, but the query will be slow (it has to read all of the data\nyou store for every query). with an index, your queries will be\norder-of-magnitude faster, but the results are approximate (because\nthere are no known indexing techniques that are exact).\n\nnevertheless, there are excellent approximate algorithms. there are 3\ndifferent indexing algorithms available on the timescale platform:\ntimescale vector index, pgvector hnsw, and pgvector ivfflat. below are\nthe trade-offs between these algorithms:\n\n| algorithm        | build speed | query speed | need to rebuild after updates |\n|------------------|-------------|-------------|-------------------------------|\n| timescale vector | slow        | fastest     | no                            |\n| pgvector hnsw    | slowest     | faster      | no                            |\n| pgvector ivfflat | fastest     | slowest     | yes                           |\n\nyou can see\n[benchmarks](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/)\non our blog.\n\nwe recommend using the timescale vector index for most use cases. this\ncan be created with:\n\n``` python\nvec.create_embedding_index(client.timescalevectorindex())\n```\n\nindexes are created for a particular distance metric type. so it is\nimportant that the same distance metric is set on the client during\nindex creation as it is during queries. see the `distance type` section\nbelow.\n\neach of these indexes has a set of build-time options for controlling\nthe speed/accuracy trade-off when creating the index and an additional\nquery-time option for controlling accuracy during a particular query. we\nhave smart defaults for all of these options but will also describe the\ndetails below so that you can adjust these options manually.\n\n#### timescale vector index\n\nthe timescale vector index is a graph-based algorithm that uses the\n[diskann](https://github.com/microsoft/diskann) algorithm. you can read\nmore about it on our\n[blog](https://www.timescale.com/blog/how-we-made-postgresql-the-best-vector-database/)\nannouncing its release.\n\nto create this index, run:\n\n``` python\nvec.create_embedding_index(client.timescalevectorindex())\n```\n\nthe above command will create the index using smart defaults. there are\na number of parameters you could tune to adjust the accuracy/speed\ntrade-off.\n\nthe parameters you can set at index build time are:\n\n| parameter name   | description                                                                                                                                                   | default value |\n|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|\n| num_neighbors    | sets the maximum number of neighbors per node. higher values increase accuracy but make the graph traversal slower.                                           | 50            |\n| search_list_size | this is the s parameter used in the greedy search algorithm used during construction. higher values improve graph quality at the cost of slower index builds. | 100           |\n| max_alpha        | is the alpha parameter in the algorithm. higher values improve graph quality at the cost of slower index builds.                                              | 1.0           |\n\nto set these parameters, you could run:\n\n``` python\nvec.create_embedding_index(client.timescalevectorindex(num_neighbors=50, search_list_size=100, max_alpha=1.0))\n```\n\nyou can also set a parameter to control the accuracy vs.\u00a0query speed\ntrade-off at query time. the parameter is set in the `search()` function\nusing the `query_params` argment. you can set the\n`search_list_size`(default: 100). this is the number of additional\ncandidates considered during the graph search at query time. higher\nvalues improve query accuracy while making the query slower.\n\nyou can specify this value during search as follows:\n\n``` python\n# vec.search([1.0, 9.0], limit=4, query_params=timescalevectorindexparams(search_list_size=10))\n```\n\nto drop the index, run:\n\n``` python\nvec.drop_embedding_index()\n```\n\n#### pgvector hnsw index\n\npgvector provides a graph-based indexing algorithm based on the popular\n[hnsw algorithm](https://arxiv.org/abs/1603.09320).\n\nto create this index, run:\n\n``` python\nvec.create_embedding_index(client.hnswindex())\n```\n\nthe above command will create the index using smart defaults. there are\na number of parameters you could tune to adjust the accuracy/speed\ntrade-off.\n\nthe parameters you can set at index build time are:\n\n| parameter name  | description                                                                                                                                                                                                                                                            | default value |\n|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|\n| m               | represents the maximum number of connections per layer. think of these connections as edges created for each node during graph construction. increasing m increases accuracy but also increases index build time and size.                                             | 16            |\n| ef_construction | represents the size of the dynamic candidate list for constructing the graph. it influences the trade-off between index quality and construction speed. increasing ef_construction enables more accurate search results at the expense of lengthier index build times. | 64            |\n\nto set these parameters, you could run:\n\n``` python\nvec.create_embedding_index(client.hnswindex(m=16, ef_construction=64))\n```\n\nyou can also set a parameter to control the accuracy vs.\u00a0query speed\ntrade-off at query time. the parameter is set in the `search()` function\nusing the `query_params` argument. you can set the `ef_search`(default:\n40). this parameter specifies the size of the dynamic candidate list\nused during search. higher values improve query accuracy while making\nthe query slower.\n\nyou can specify this value during search as follows:\n\n``` python\n# vec.search([1.0, 9.0], limit=4, query_params=hnswindexparams(ef_search=10))\n```\n\nto drop the index run:\n\n``` python\nvec.drop_embedding_index()\n```\n\n#### pgvector ivfflat index\n\npgvector provides a clustering-based indexing algorithm. our [blog\npost](https://www.timescale.com/blog/nearest-neighbor-indexes-what-are-ivfflat-indexes-in-pgvector-and-how-do-they-work/)\ndescribes how it works in detail. it provides the fastest index-build\nspeed but the slowest query speeds of any indexing algorithm.\n\nto create this index, run:\n\n``` python\nvec.create_embedding_index(client.ivfflatindex())\n```\n\nnote: *ivfflat should never be created on empty tables* because it needs\nto cluster data, and that only happens when an index is first created,\nnot when new rows are inserted or modified. also, if your table\nundergoes a lot of modifications, you will need to rebuild this index\noccasionally to maintain good accuracy. see our [blog\npost](https://www.timescale.com/blog/nearest-neighbor-indexes-what-are-ivfflat-indexes-in-pgvector-and-how-do-they-work/)\nfor details.\n\npgvector ivfflat has a `lists` index parameter that is automatically set\nwith a smart default based on the number of rows in your table. if you\nknow that you\u2019ll have a different table size, you can specify the number\nof records to use for calculating the `lists` parameter as follows:\n\n``` python\nvec.create_embedding_index(client.ivfflatindex(num_records=1000000))\n```\n\nyou can also set the `lists` parameter directly:\n\n``` python\nvec.create_embedding_index(client.ivfflatindex(num_lists=100))\n```\n\nyou can also set a parameter to control the accuracy vs.\u00a0query speed\ntrade-off at query time. the parameter is set in the `search()` function\nusing the `query_params` argument. you can set the `probes`. this\nparameter specifies the number of clusters searched during a query. it\nis recommended to set this parameter to `sqrt(lists)` where lists is the\n`num_list` parameter used above during index creation. higher values\nimprove query accuracy while making the query slower.\n\nyou can specify this value during search as follows:\n\n``` python\n# vec.search([1.0, 9.0], limit=4, query_params=ivfflatindexparams(probes=10))\n```\n\nto drop the index, run:\n\n``` python\nvec.drop_embedding_index()\n```\n\n### time partitioning\n\nin many use cases where you have many embeddings, time is an important\ncomponent associated with the embeddings. for example, when embedding\nnews stories, you often search by time as well as similarity (e.g.,\nstories related to bitcoin in the past week or stories about clinton in\nnovember 2016).\n\nyet, traditionally, searching by two components \u201csimilarity\u201d and \u201ctime\u201d\nis challenging for approximate nearest neighbor (ann) indexes and makes\nthe similarity-search index less effective.\n\none approach to solving this is partitioning the data by time and\ncreating ann indexes on each partition individually. then, during\nsearch, you can:\n\n- step 1: filter our partitions that don\u2019t match the time predicate.\n- step 2: perform the similarity search on all matching partitions.\n- step 3: combine all the results from each partition in step 2, rerank,\n  and filter out results by time.\n\nstep 1 makes the search a lot more efficient by filtering out whole\nswaths of data in one go.\n\ntimescale-vector supports time partitioning using timescaledb\u2019s\nhypertables. to use this feature, simply indicate the length of time for\neach partition when creating the client:\n\n``` python\nfrom datetime import timedelta\nfrom datetime import datetime\n```\n\n``` python\nvec = client.async(service_url, \"my_data_with_time_partition\", 2, time_partition_interval=timedelta(hours=6))\nawait vec.create_tables()\n```\n\nthen, insert data where the ids use uuids v1 and the time component of\nthe uuid specifies the time of the embedding. for example, to create an\nembedding for the current time, simply do:\n\n``` python\nid = uuid.uuid1()\nawait vec.upsert([(id, {\"key\": \"val\"}, \"the brown fox\", [1.0, 1.2])])\n```\n\nto insert data for a specific time in the past, create the uuid using\nour\n[`uuid_from_time`](https://timescale.github.io/python-vector/vector.html#uuid_from_time)\nfunction\n\n``` python\nspecific_datetime = datetime(2018, 8, 10, 15, 30, 0)\nawait vec.upsert([(client.uuid_from_time(specific_datetime), {\"key\": \"val\"}, \"the brown fox\", [1.0, 1.2])])\n```\n\nyou can then query the data by specifying a `uuid_time_filter` in the\nsearch call:\n\n``` python\nrec = await vec.search([1.0, 2.0], limit=4, uuid_time_filter=client.uuidtimerange(specific_datetime-timedelta(days=7), specific_datetime+timedelta(days=7)))\n```\n\n### distance metrics\n\nby default, we use cosine distance to measure how similarly an embedding\nis to a given query. in addition to cosine distance, we also support\neuclidean/l2 distance. the distance type is set when creating the client\nusing the `distance_type` parameter. for example, to use the euclidean\ndistance metric, you can create the client with:\n\n``` python\nvec  = client.sync(service_url, \"my_data\", 2, distance_type=\"euclidean\")\n```\n\nvalid values for `distance_type` are `cosine` and `euclidean`.\n\nit is important to note that you should use consistent distance types on\nclients that create indexes and perform queries. that is because an\nindex is only valid for one particular type of distance measure.\n\nplease note the timescale vector index only supports cosine distance at\nthis time.\n\n# langchain integration\n\n[langchain](https://www.langchain.com/) is a popular framework for\ndevelopment applications powered by llms. timescale vector has a native\nlangchain integration, enabling you to use timescale vector as a\nvectorstore and leverage all its capabilities in your applications built\nwith langchain.\n\nhere are resources about using timescale vector with langchain:\n\n- [getting started with langchain and timescale\n  vector](https://python.langchain.com/docs/integrations/vectorstores/timescalevector):\n  you\u2019ll learn how to use timescale vector for (1) semantic search, (2)\n  time-based vector search, (3) self-querying, and (4) how to create\n  indexes to speed up queries.\n- [postgresql self\n  querying](https://python.langchain.com/docs/integrations/retrievers/self_query/timescalevector_self_query):\n  learn how to use timescale vector with self-querying in langchain.\n- [langchain template: rag with conversational\n  retrieval](https://github.com/langchain-ai/langchain/tree/master/templates/rag-timescale-conversation):\n  this template is used for conversational retrieval, which is one of\n  the most popular llm use-cases. it passes both a conversation history\n  and retrieved documents into an llm for synthesis.\n- [langchain template: rag with time-based search and self-query\n  retrieval](https://github.com/langchain-ai/langchain/tree/master/templates/rag-timescale-hybrid-search-time):this\n  template shows how to use timescale-vector with the self-query\n  retriver to perform hybrid search on similarity and time. this is\n  useful any time your data has a strong time-based component.\n- [learn more about timescale vector and\n  langchain](https://blog.langchain.dev/timescale-vector-x-langchain-making-postgresql-a-better-vector-database-for-ai-applications/)\n\n# llamaindex integration\n\n\\[llamaindex\\] is a popular data framework for connecting custom data\nsources to large language models (llms). timescale vector has a native\nllamaindex integration, enabling you to use timescale vector as a\nvectorstore and leverage all its capabilities in your applications built\nwith llamaindex.\n\nhere are resources about using timescale vector with llamaindex:\n\n- [getting started with llamaindex and timescale\n  vector](https://docs.llamaindex.ai/en/stable/examples/vector_stores/timescalevector.html):\n  you\u2019ll learn how to use timescale vector for (1) similarity\n  search, (2) time-based vector search, (3) faster search with indexes,\n  and (4) retrieval and query engine.\n- [time-based\n  retrieval](https://youtu.be/eymzvfkcrzm?si=i0h3uupgzkbqw__w): learn\n  how to power rag applications with time-based retrieval.\n- [llama pack: auto retrieval with time-based\n  search](https://github.com/run-llama/llama-hub/tree/main/llama_hub/llama_packs/timescale_vector_autoretrieval):\n  this pack demonstrates performing auto-retrieval for hybrid search\n  based on both similarity and time, using the timescale-vector\n  (postgresql) vectorstore.  \n- [learn more about timescale vector and\n  llamaindex](https://www.timescale.com/blog/timescale-vector-x-llamaindex-making-postgresql-a-better-vector-database-for-ai-applications/)\n\n# pgvectorize\n\npgvectorize enables you to create vector embeddings from any data that\nyou already have stored in postgresql. you can get more background\ninformation in our [blog\npost](https://www.timescale.com/blog/a-complete-guide-to-creating-and-storing-embeddings-for-postgresql-data/)\nannouncing this feature, as well as a [\u201chow we built\nin\u201d](https://www.timescale.com/blog/how-we-designed-a-resilient-vector-embedding-creation-system-for-postgresql-data/)\npost going into the details of the design.\n\nto create vector embeddings, simply attach pgvectorize to any postgresql\ntable, and it will automatically sync that table\u2019s data with a set of\nembeddings stored in timescale vector. for example, let\u2019s say you have a\nblog table defined in the following way:\n\n``` python\nimport psycopg2\nfrom langchain.docstore.document import document\nfrom langchain.text_splitter import charactertextsplitter\nfrom timescale_vector import client, pgvectorizer\nfrom langchain.embeddings.openai import openaiembeddings\nfrom langchain.vectorstores.timescalevector import timescalevector\nfrom datetime import timedelta\n```\n\n``` python\nwith psycopg2.connect(service_url) as conn:\n    with conn.cursor() as cursor:\n        cursor.execute('''\n        create table if not exists blog (\n            id              serial primary key not null,\n            title           text not null,\n            author          text not null,\n            contents        text not null,\n            category        text not null,\n            published_time  timestamptz null --null if not yet published\n        );\n        ''')\n```\n\nyou can insert some data as follows:\n\n``` python\nwith psycopg2.connect(service_url) as conn:\n    with conn.cursor() as cursor:\n        cursor.execute('''\n            insert into blog (title, author, contents, category, published_time) values ('first post', 'matvey arye', 'some super interesting content about cats.', 'ai', '2021-01-01');\n        ''')\n```\n\nnow, say you want to embed these blogs in timescale vector. first, you\nneed to define an `embed_and_write` function that takes a set of blog\nposts, creates the embeddings, and writes them into timescalevector. for\nexample, if using langchain, it could look something like the following.\n\n``` python\ndef get_document(blog):\n    text_splitter = charactertextsplitter(\n        chunk_size=1000,\n        chunk_overlap=200,\n    )\n    docs = []\n    for chunk in text_splitter.split_text(blog['contents']):\n        content = f\"author {blog['author']}, title: {blog['title']}, contents:{chunk}\"\n        metadata = {\n            \"id\": str(client.uuid_from_time(blog['published_time'])),\n            \"blog_id\": blog['id'], \n            \"author\": blog['author'], \n            \"category\": blog['category'],\n            \"published_time\": blog['published_time'].isoformat(),\n        }\n        docs.append(document(page_content=content, metadata=metadata))\n    return docs\n\ndef embed_and_write(blog_instances, vectorizer):\n    embedding = openaiembeddings()\n    vector_store = timescalevector(\n        collection_name=\"blog_embedding\",\n        service_url=service_url,\n        embedding=embedding,\n        time_partition_interval=timedelta(days=30),\n    )\n\n    # delete old embeddings for all ids in the work queue. locked_id is a special column that is set to the primary key of the table being\n    # embedded. for items that are deleted, it is the only key that is set.\n    metadata_for_delete = [{\"blog_id\": blog['locked_id']} for blog in blog_instances]\n    vector_store.delete_by_metadata(metadata_for_delete)\n\n    documents = []\n    for blog in blog_instances:\n        # skip blogs that are not published yet, or are deleted (in which case it will be null)\n        if blog['published_time'] != none:\n            documents.extend(get_document(blog))\n\n    if len(documents) == 0:\n        return\n    \n    texts = [d.page_content for d in documents]\n    metadatas = [d.metadata for d in documents]\n    ids = [d.metadata[\"id\"] for d in documents]\n    vector_store.add_texts(texts, metadatas, ids)\n```\n\nthen, all you have to do is run the following code in a scheduled job\n(cron job, lambda job, etc):\n\n``` python\n# this job should be run on a schedule\nvectorizer = pgvectorizer.vectorize(service_url, 'blog')\nwhile vectorizer.process(embed_and_write) > 0:\n    pass\n```\n\nevery time that job runs, it will sync the table with your embeddings.\nit will sync all inserts, updates, and deletes to an embeddings table\ncalled `blog_embedding`.\n\nnow, you can simply search the embeddings as follows (again, using\nlangchain in the example):\n\n``` python\nembedding = openaiembeddings()\nvector_store = timescalevector(\n    collection_name=\"blog_embedding\",\n    service_url=service_url,\n    embedding=embedding,\n    time_partition_interval=timedelta(days=30),\n)\n\nres = vector_store.similarity_search_with_score(\"blogs about cats\")\nres\n```\n\n    [(document(page_content='author matvey arye, title: first post, contents:some super interesting content about cats.', metadata={'id': '4a784000-4bc4-11eb-855a-06302dbc8ce7', 'author': 'matvey arye', 'blog_id': 1, 'category': 'ai', 'published_time': '2021-01-01t00:00:00+00:00'}),\n      0.12595687795193833)]\n\n## development\n\nthis project is developed with [nbdev](https://nbdev.fast.ai/). please\nsee that website for the development process.\n",
  "docs_url": null,
  "keywords": "nbdev jupyter notebook python",
  "license": "apache software license 2.0",
  "name": "timescale-vector",
  "package_url": "https://pypi.org/project/timescale-vector/",
  "project_url": "https://pypi.org/project/timescale-vector/",
  "project_urls": {
    "Homepage": "https://github.com/timescale/python-vector"
  },
  "release_url": "https://pypi.org/project/timescale-vector/0.0.4/",
  "requires_dist": [
    "asyncpg",
    "psycopg2",
    "pgvector",
    "python-dotenv ; extra == 'dev'",
    "langchain ; extra == 'dev'"
  ],
  "requires_python": ">=3.7",
  "summary": "python library for storing vector data in postgres",
  "version": "0.0.4",
  "releases": [],
  "developers": [
    "mat@timescale.com",
    "matvey_arye"
  ],
  "kwds": "timescale_vector timescale_vector_autoretrieval timescalevector_self_query timescaledb timescale",
  "license_kwds": "apache software license 2.0",
  "libtype": "pypi",
  "id": "pypi_timescale_vector",
  "homepage": "https://github.com/timescale/python-vector",
  "release_count": 4,
  "dependency_ids": [
    "pypi_asyncpg",
    "pypi_langchain",
    "pypi_pgvector",
    "pypi_psycopg2",
    "pypi_python_dotenv"
  ]
}