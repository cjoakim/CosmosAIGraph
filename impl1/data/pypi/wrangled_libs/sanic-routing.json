{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# sanic routing\n\n## background\n\nbeginning in v21.3, sanic makes use of this new ast-style router in two use cases:\n\n1. routing paths; and\n2. routing signals.\n\ntherefore, this package comes with a `baserouter` that needs to be subclassed in order to be used for its specific needs. \n\nmost sanic users should never need to concern themselves with the details here.\n\n## basic example\n\na simple implementation:\n\n```python\nimport logging\n\nfrom sanic_routing import baserouter\n\nlogging.basicconfig(level=logging.debug)\n\n\nclass router(baserouter):\n    def get(self, path, *args, **kwargs):\n        return self.resolve(path, *args, **kwargs)\n\n\nrouter = router()\n\nrouter.add(\"/<foo>\", lambda: ...)\nrouter.finalize()\nrouter.tree.display()\nlogging.info(router.find_route_src)\n\nroute, handler, params = router.get(\"/matchme\", method=\"base\", extra=none)\n```\n\nthe above snippet uses `router.tree.display()` to show how the router has decided to arrange the routes into a tree. in this simple example:\n\n```\n<node: level=0>\n    <node: part=__dynamic__:str, level=1, groups=[<routegroup: path=<foo:str> len=1>], dynamic=true>\n```\n\nwe can can see the code that the router has generated for us. it is available as a string at `router.find_route_src`.\n\n```python\ndef find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=__dynamic__:str\n    if num == 1:  # check 1\n        try:\n            basket['__matches__'][0] = str(parts[0])\n        except valueerror:\n            pass\n        else:\n            # return 1\n            return router.dynamic_routes[('<__dynamic__:str>',)][0], basket\n    raise notfound\n```\n\n_fyi: if you are on python 3.9, you can see a representation of the source after compilation at `router.find_route_src_compiled`_\n\n## what's it doing?\n\ntherefore, in general implementation requires you to:\n\n1. define a router with a `get` method;\n2. add one or more routes;\n3. finalize the router (`router.finalize()`); and\n4. call the router's `get` method.\n\n_note: you can call `router.finalize(false)` if you do not want to compile the source code into executable form. this is useful if you only intend to review the generated output._\n\nevery time you call `router.add` you create one (1) new `route` instance. even if that one route is created with multiple methods, it generates a single instance. if you `add()` another `route` that has a similar path structure (but, perhaps has differen methods) they will be grouped together into a `routegroup`. it is worth also noting that a `routegroup` is created the first time you call `add()`, but subsequent similar routes will reuse the existing grouping instance.\n\n\nwhen you call `finalize()`, it is taking the defined route groups and arranging them into \"nodes\" in a hierarchical tree. a single node is a path segment. a `node` instance can have one or more `routegroup` on it where the `node` is the termination point for that path.\n\nperhaps an example is easier:\n\n```python\nrouter.add(\"/path/to/<foo>\", lambda: ...)\nrouter.add(\"/path/to/<foo:int>\", lambda: ...)\nrouter.add(\"/path/to/different/<foo>\", lambda: ...)\nrouter.add(\"/path/to/different/<foo>\", lambda: ..., methods=[\"one\", \"two\"])\n```\n\nthe generated `routegroup` instances (3):\n\n```\n<routegroup: path=path/to/<foo:str> len=1>\n<routegroup: path=path/to/<foo:int> len=1>\n<routegroup: path=path/to/different/<foo:str> len=2>\n```\n\nthe generated `route` instances (4):\n\n```\n<route: path=path/to/<foo:str>>\n<route: path=path/to/<foo:int>>\n<route: path=path/to/different/<foo:str>>\n<route: path=path/to/different/<foo:str>>\n```\n\nthe node tree:\n\n```\n<node: level=0>\n    <node: part=path, level=1>\n        <node: part=to, level=2>\n            <node: part=different, level=3>\n                <node: part=__dynamic__:str, level=4, groups=[<routegroup: path=path/to/different/<foo:str> len=2>], dynamic=true>\n            <node: part=__dynamic__:int, level=3, groups=[<routegroup: path=path/to/<foo:int> len=1>], dynamic=true>\n            <node: part=__dynamic__:str, level=3, groups=[<routegroup: path=path/to/<foo:str> len=1>], dynamic=true>\n```\n\nand, the generated source code:\n\n```python\ndef find_route(path, method, router, basket, extra):\n    parts = tuple(path[1:].split(router.delimiter))\n    num = len(parts)\n    \n    # node=1 // part=path\n    if num > 1:  # check 1\n        if parts[0] == \"path\":  # check 4\n            \n            # node=1.1 // part=to\n            if num > 2:  # check 1\n                if parts[1] == \"to\":  # check 4\n                    \n                    # node=1.1.1 // part=different\n                    if num > 3:  # check 1\n                        if parts[2] == \"different\":  # check 4\n                            \n                            # node=1.1.1.1 // part=__dynamic__:str\n                            if num == 4:  # check 1\n                                try:\n                                    basket['__matches__'][3] = str(parts[3])\n                                except valueerror:\n                                    pass\n                                else:\n                                    if method in frozenset({'one', 'two'}):\n                                        route_idx = 0\n                                    elif method in frozenset({'base'}):\n                                        route_idx = 1\n                                    else:\n                                        raise nomethod\n                                    # return 1.1.1.1\n                                    return router.dynamic_routes[('path', 'to', 'different', '<__dynamic__:str>')][route_idx], basket\n                    \n                    # node=1.1.2 // part=__dynamic__:int\n                    if num >= 3:  # check 1\n                        try:\n                            basket['__matches__'][2] = int(parts[2])\n                        except valueerror:\n                            pass\n                        else:\n                            if num == 3:  # check 5\n                                # return 1.1.2\n                                return router.dynamic_routes[('path', 'to', '<__dynamic__:int>')][0], basket\n                    \n                    # node=1.1.3 // part=__dynamic__:str\n                    if num >= 3:  # check 1\n                        try:\n                            basket['__matches__'][2] = str(parts[2])\n                        except valueerror:\n                            pass\n                        else:\n                            if num == 3:  # check 5\n                                # return 1.1.3\n                                return router.dynamic_routes[('path', 'to', '<__dynamic__:str>')][0], basket\n    raise notfound\n```\n\n## special cases\n\nthe above example only shows routes that have a dynamic path segment in them (example: `<foo>`). but, there are other use cases that are covered differently:\n\n1. *fully static paths* - these are paths with no parameters (example: `/user/login`). these are basically matched against a key/value store.\n2. *regex paths* - if a route as a single regular expression match, then the whole route will be matched via regex. in general, this happens inline not too dissimilar than what we see in the above example.\n3. *special regex paths* - the router comes with a special `path` type (example: `<foo:path>`) that can match on an expanded delimiter. this is also true for any regex that uses the path delimiter in it. these cannot be matched in the normal course since they are of unknown length.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "sanic-routing",
  "package_url": "https://pypi.org/project/sanic-routing/",
  "project_url": "https://pypi.org/project/sanic-routing/",
  "project_urls": {
    "Homepage": "https://github.com/sanic-org/sanic-routing/"
  },
  "release_url": "https://pypi.org/project/sanic-routing/23.6.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "core routing component for sanic",
  "version": "23.6.0",
  "releases": [],
  "developers": [
    "adam_hopkins",
    "admhpkns@gmail.com"
  ],
  "kwds": "sanic_routing find_route baserouter routes find_route_src",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_sanic_routing",
  "homepage": "https://github.com/sanic-org/sanic-routing/",
  "release_count": 24,
  "dependency_ids": []
}