{
  "classifiers": [
    "framework :: pytest",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: macos :: macos x",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "topic :: software development :: quality assurance",
    "topic :: software development :: testing",
    "topic :: utilities"
  ],
  "description": "# pytest-grpc\n\nwrite test for grpc with pytest.\n\n\n## example\n\nsee example dir and/or read 'usage'.\n\n## usage\n\nfor example you have some proto file with rpc declaration.\n\n\n```proto\nsyntax = \"proto3\";\n\npackage test.v1;\n\n\nservice echoservice {\n    rpc handler(echorequest) returns (echoresponse) {\n    }\n}\n\n\nmessage echorequest {\n    string name = 1;\n}\n\nmessage echoresponse {\n    string name = 1;\n}\n\n```\n\nafter compile it with grpcio-tools, you get *_pb2.py and *_pb2_grpc.py files, now you can write your service.\n\n```python\nfrom stub.test_pb2 import echorequest, echoresponse\nfrom stub.test_pb2_grpc import echoserviceservicer\n\n\nclass servicer(echoserviceservicer):\n    def handler(self, request: echorequest, context) -> echoresponse:\n        return echoresponse(name=f'test-{request.name}')\n\n    def error_handler(self, request: echorequest, context) -> echoresponse:\n        raise runtimeerror('some error')\n```\n\npoint pytest with your stubs and service:\n\n```python\nimport pytest\n\nfrom stub.test_pb2 import echorequest\n\n\n@pytest.fixture(scope='module')\ndef grpc_add_to_server():\n    from stub.test_pb2_grpc import add_echoserviceservicer_to_server\n\n    return add_echoserviceservicer_to_server\n\n\n@pytest.fixture(scope='module')\ndef grpc_servicer():\n    from servicer import servicer\n\n    return servicer()\n\n\n@pytest.fixture(scope='module')\ndef grpc_stub_cls(grpc_channel):\n    from stub.test_pb2_grpc import echoservicestub\n\n    return echoservicestub\n```\n\nwrite little test:\n```python\n\ndef test_some(grpc_stub):\n    request = echorequest()\n    response = grpc_stub.handler(request)\n\n    assert response.name == f'test-{request.name}'\n\ndef test_example(grpc_stub):\n    request = echorequest()\n    response = grpc_stub.error_handler(request)\n\n    assert response.name == f'test-{request.name}'\n``` \n\n#### testing secure server\n\n```python\nfrom pathlib import path\nimport pytest\nimport grpc\n\n@pytest.fixture(scope='module')\ndef grpc_add_to_server():\n    from stub.test_pb2_grpc import add_echoserviceservicer_to_server\n\n    return add_echoserviceservicer_to_server\n\n\n@pytest.fixture(scope='module')\ndef grpc_servicer():\n    from servicer import servicer\n\n    return servicer()\n\n\n@pytest.fixture(scope='module')\ndef grpc_stub_cls(grpc_channel):\n    from stub.test_pb2_grpc import echoservicestub\n\n    return echoservicestub\n\n\n@pytest.fixture(scope='session')\ndef my_ssl_key_path():\n    return path('/path/to/key.pem')\n\n\n@pytest.fixture(scope='session')\ndef my_ssl_cert_path():\n    return path('/path/to/cert.pem')\n\n\n@pytest.fixture(scope='module')\ndef grpc_server(_grpc_server, grpc_addr, my_ssl_key_path, my_ssl_cert_path):\n    \"\"\"\n    overwrites default `grpc_server` fixture with ssl credentials\n    \"\"\"\n    credentials = grpc.ssl_server_credentials([\n        (my_ssl_key_path.read_bytes(),\n         my_ssl_cert_path.read_bytes())\n    ])\n\n    _grpc_server.add_secure_port(grpc_addr, server_credentials=credentials)\n    _grpc_server.start()\n    yield _grpc_server\n    _grpc_server.stop(grace=none)\n\n\n@pytest.fixture(scope='module')\ndef my_channel_ssl_credentials(my_ssl_cert_path):\n    # if we're using self-signed certificate it's necessarily to pass root certificate to channel\n    return grpc.ssl_channel_credentials(\n        root_certificates=my_ssl_cert_path.read_bytes()\n    )\n\n\n@pytest.fixture(scope='module')\ndef grpc_channel(my_channel_ssl_credentials, create_channel):\n    \"\"\"\n    overwrites default `grpc_channel` fixture with ssl credentials\n    \"\"\"\n    with create_channel(my_channel_ssl_credentials) as channel:\n        yield channel\n\n\n@pytest.fixture(scope='module')\ndef grpc_authorized_channel(my_channel_ssl_credentials, create_channel):\n    \"\"\"\n    channel with authorization header passed\n    \"\"\"\n    grpc_channel_credentials = grpc.access_token_call_credentials(\"some_token\")\n    composite_credentials = grpc.composite_channel_credentials(\n        my_channel_ssl_credentials,\n        grpc_channel_credentials\n    )\n    with create_channel(composite_credentials) as channel:\n        yield channel\n\n\n@pytest.fixture(scope='module')\ndef my_authorized_stub(grpc_stub_cls, grpc_channel):\n    \"\"\"\n    stub with authorized channel\n    \"\"\"\n    return grpc_stub_cls(grpc_channel)\n\n```\n\n## run tests against real grpc server\nrun tests against read grpc server worked in another thread:\n\n```bash\npy.test\n```\n\n```\ncachedir: .pytest_cache\nplugins: grpc-0.0.0\ncollected 2 items\n\nexample/test_example.py::test_some passed\nexample/test_example.py::test_example failed\n\n=================================== failures ====================================\n_________________________________ test_example __________________________________\n\ngrpc_stub = <stub.test_pb2_grpc.echoservicestub object at 0x107a9b390>\n\n    def test_example(grpc_stub):\n        request = echorequest()\n>       response = grpc_stub.error_handler(request)\n\nexample/test_example.py:35:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n.env/lib/python3.7/site-packages/grpc/_channel.py:547: in __call__\n    return _end_unary_response_blocking(state, call, false, none)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nstate = <grpc._channel._rpcstate object at 0x107b263c8>\ncall = <grpc._cython.cygrpc.segregatedcall object at 0x107b323c8>\nwith_call = false, deadline = none\n\n    def _end_unary_response_blocking(state, call, with_call, deadline):\n        if state.code is grpc.statuscode.ok:\n            if with_call:\n                rendezvous = _rendezvous(state, call, none, deadline)\n                return state.response, rendezvous\n            else:\n                return state.response\n        else:\n>           raise _rendezvous(state, none, none, deadline)\ne           grpc._channel._rendezvous: <_rendezvous of rpc that terminated with:\ne           \tstatus = statuscode.unknown\ne           \tdetails = \"exception calling application: some error\"\ne           \tdebug_error_string = \"{\"created\":\"@1544451353.148337000\",\"description\":\"error received from peer\",\"file\":\"src/core/lib/surface/call.cc\",\"file_line\":1036,\"grpc_message\":\"exception calling application: some error\",\"grpc_status\":2}\"\ne           >\n\n.env/lib/python3.7/site-packages/grpc/_channel.py:466: _rendezvous\n------------------------------- captured log call -------------------------------\n_server.py                 397 error    exception calling application: some error\ntraceback (most recent call last):\n  file \"pytest-grpc/.env/lib/python3.7/site-packages/grpc/_server.py\", line 389, in _call_behavior\n    return behavior(argument, context), true\n  file \"pytest-grpc/example/src/servicer.py\", line 10, in error_handler\n    raise runtimeerror('some error')\nruntimeerror: some error\n================ 1 failed, 1 passed, 1 warnings in 0.16 seconds =================\n\n```\n\n## run tests directly to python code\ncall handlers directly, with fake grpc internals:\n\n```bash\npy.test --grpc-fake-server\n```\n\nin this case your get nice direct exceptions:\n\n```\n============================= test session starts =============================\ncachedir: .pytest_cache\nplugins: grpc-0.0.0\ncollected 2 items\n\nexample/test_example.py::test_some passed\nexample/test_example.py::test_example failed\n\n================================== failures ===================================\n________________________________ test_example _________________________________\n\ngrpc_stub = <stub.test_pb2_grpc.echoservicestub object at 0x10e06f518>\n\n    def test_example(grpc_stub):\n        request = echorequest()\n>       response = grpc_stub.error_handler(request)\n\nexample/test_example.py:35:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\npytest_grpc/plugin.py:42: in fake_handler\n    return real_method(request, context)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <servicer.servicer object at 0x10ce75278>, request =\ncontext = <pytest_grpc.plugin.fakecontext object at 0x10e083e48>\n\n    def error_handler(self, request: echorequest, context) -> echoresponse:\n>       raise runtimeerror('some error')\ne       runtimeerror: some error\n\nexample/src/servicer.py:10: runtimeerror\n=============== 1 failed, 1 passed, 1 warnings in 0.10 seconds ================\n```\n\n## run the servicer on multiple threads\nthe number of workers threads for grpc can be specified in two ways:\n\n  - add `--grpc-max-workers=<n>` to the arguments\n  - test modules can also use a `grpc_max_workers=<n>` variable\n\nsee `test_blocking` in example.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "pytest-grpc",
  "package_url": "https://pypi.org/project/pytest-grpc/",
  "project_url": "https://pypi.org/project/pytest-grpc/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/pytest-grpc/0.8.0/",
  "requires_dist": [
    "pytest (>=3.6.0)"
  ],
  "requires_python": "",
  "summary": "pytest plugin for grpc",
  "version": "0.8.0",
  "releases": [],
  "developers": [
    "denis.a.kataev@gmail.com",
    "denis_kataev"
  ],
  "kwds": "pytest_grpc test_pb2_grpc grpc_stub _pb2_grpc grpc_stub_cls",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytest_grpc",
  "homepage": "",
  "release_count": 6,
  "dependency_ids": [
    "pypi_pytest"
  ]
}