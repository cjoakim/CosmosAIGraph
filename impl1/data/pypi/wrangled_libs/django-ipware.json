{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# django ipware \n\n**a django application to retrieve client's ip address**\n\n[![status-image]][status-link]\n[![version-image]][version-link]\n[![coverage-image]][coverage-link]\n\n# alternative package\n\nif you prefer a python only version that does not integrate with django directly, but allows for more flexibility and advanced features, you can use the [python-ipware](https://github.com/un33k/python-ipware) package instead.  `django-ipware` is a wrapper using [python-ipware](https://github.com/un33k/python-ipware) under the hood staring from version `6.0.0`.\n\n# overview\n\n**best attempt** to get client's ip address while keeping it **dry**.\n\n# notice\n\nthere is no perfect `out-of-the-box` solution against fake ip addresses, aka `ip address spoofing`.\nyou are encouraged to read the ([advanced users](readme.md#advanced-users)) section of this page and\nuse `trusted_proxies_ips` and/or `proxy_count` features to match your needs, especially `if` you are\nplanning to include `ipware` in any authentication, security or `anti-fraud` related architecture.\n\nthis is an open source project, with the source code visible to all. therefore, it may be exploited through unimplemented, or improperly implemented features.\n\nplease use ipware `only` as a complement to your `firewall` security measures!\n\n# how to install\n\n    1. easy_install django-ipware\n    2. pip install django-ipware\n    3. git clone http://github.com/un33k/django-ipware\n        a. cd django-ipware\n        b. run python setup.py install\n    4. wget https://github.com/un33k/django-ipware/zipball/master\n        a. unzip the downloaded file\n        b. cd into django-ipware-* directory\n        c. run python setup.py install\n\n# how to use\n\n```python\n # in a view or a middleware where the `request` object is available\n\n from ipware import get_client_ip\n client_ip, is_routable = get_client_ip(request)\n if client_ip is none:\n    # unable to get the client's ip address\n else:\n     # we got the client's ip address\n     if is_routable:\n         # the client's ip address is publicly routable on the internet\n     else:\n         # the client's ip address is private\n```\n\n# advanced users:\n\n- ### precedence order\n\n  the default meta precedence order is top to bottom. you may customize the order\n  by providing your own `ipware_meta_precedence_order` by adding it to your project's settings.py\n\n  ```python\n   # the default meta precedence order (update as needed)\n   ipware_meta_precedence_order = (\n        \"x_forwarded_for\",  # aws elb (default client is `left-most` [`<client>, <proxy1>, <proxy2>`])\n        \"http_x_forwarded_for\",  # similar to x_forwarded_to\n        \"http_client_ip\",  # standard headers used by providers such as amazon ec2, heroku etc.\n        \"http_x_real_ip\",  # standard headers used by providers such as amazon ec2, heroku etc.\n        \"http_x_forwarded\",  # squid and others\n        \"http_x_cluster_client_ip\",  # rackspace lb and riverbed stingray\n        \"http_forwarded_for\",  # rfc 7239\n        \"http_forwarded\",  # rfc 7239\n        \"http_via\",  # squid and others\n        \"x-client-ip\",  # microsoft azure\n        \"x-real-ip\",  # nginx\n        \"x-cluster-client-ip\",  # rackspace cloud load balancers\n        \"x_forwarded\",  # squid\n        \"forwarded_for\",  # rfc 7239\n        \"cf-connecting-ip\",  # cloudflare\n        \"true-client-ip\",  # cloudflare enterprise,\n        \"fastly-client-ip\",  # firebase, fastly\n        \"forwarded\",  # rfc 7239\n        \"client-ip\",  # akamai and cloudflare: true-client-ip and fastly: fastly-client-ip\n        \"remote_addr\",  # default\n    )\n  ```\n\n  **alternatively**, you can provide your custom _request header meta precedence order_ when calling `get_client_ip()`.\n\n```python\nget_client_ip(request, request_header_order=['x_forwarded_for'])\nget_client_ip(request, request_header_order=['x_forwarded_for', 'http_x_forwarded_for'])\n```\n\n- ### proxy count\n\n  the default meta proxy count is 0 unless explictly provided as an argument to `get_client_ip()`. you may customize the order\n  by providing your own `ipware_meta_proxy_count` by adding it to your project's settings.py\n\n### trusted proxies\n\nif your django server is behind one or more known proxy server(s), you can filter out unwanted requests\nby providing the `trusted` proxy list when calling `get_client_ip(request, proxy_trusted_ips=['177.139.233.133'])`.\nin the following example, your load balancer (lb) can be seen as a `trusted` proxy.\n\n```\n `real` client  <public> <---> <public> lb (server) <private> <--------> <private> django server\n                                                                   ^\n                                                                   |\n `fake` client  <private> <---> <private> lb (server) <private> ---^\n```\n\n```python\n# in the above scenario, use your load balancer ip address as a way to filter out unwanted requests.\nclient_ip, is_routable = get_client_ip(request, proxy_trusted_ips=['177.139.233.133'])\n\n# if you have multiple proxies, simply add them to the list\nclient_ip, is_routable = get_client_ip(request, proxy_trusted_ips=['177.139.233.133', '177.139.233.134'])\n\n# for proxy servers with fixed sub-domain and dynamic ip, use the following pattern.\nclient_ip, is_routable = get_client_ip(request, proxy_trusted_ips=['177.139.', '177.140'])\nclient_ip, is_routable = get_client_ip(request, proxy_trusted_ips=['177.139.233.', '177.139.240'])\n```\n\n`please note:` by default, the `right-most` proxy in the chain is the `trusted` proxy and that is the one your django\nserver talks to. therefore, `ipware` checks to see if the `right-most` proxy address starts with any ip pattern that was\npassed in via the `proxy_trusted_ips` list.\n\n### proxy count\n\nif your django server is behind a `known` number of proxy server(s), you can filter out unwanted requests\nby providing the `number` of proxies when calling `get_client_ip(request, proxy_count=1)`.\nin the following example, your load balancer (lb) can be seen as the `only` proxy.\n\n```\n `real` client  <public> <---> <public> lb (server) <private> <--------> <private> django server\n                                                                   ^\n                                                                   |\n                                       `fake` client  <private> ---^\n```\n\n```python\n# in the above scenario, the total number of proxies can be used as a way to filter out unwanted requests.\nclient_ip, is_routable = get_client_ip(request, proxy_count=1)\n\n# the above may be very useful in cases where your proxy server's ip address is assigned dynamically.\n# however, if you have the proxy ip address, you can use it in combination to the proxy count.\nclient_ip, is_routable = get_client_ip(request, proxy_count=1, proxy_trusted_ips=['177.139.233.133'])\n```\n\n### originating request\n\nif your proxy server is configured such that the right-most ip address is that of the originating client, you\ncan indicate `right-most` as your `proxy_order` when calling `get_client_ip(request, proxy_order=\"right-most\")`.\nplease note that the [de-facto](https://developer.mozilla.org/en-us/docs/web/http/headers/x-forwarded-for) standard\nfor the originating client ip address is the `left-most` as per `<client>, <proxy1>, <proxy2>`.\n\n# running the tests\n\nto run the tests against the current environment:\n\n    python manage.py test\n\n# license\n\nreleased under a ([mit](license)) license.\n\n# version\n\nx.y.z version\n\n    `major` version -- when you make incompatible api changes,\n    `minor` version -- when you add functionality in a backwards-compatible manner, and\n    `patch` version -- when you make backwards-compatible bug fixes.\n\n[status-image]: https://github.com/un33k/django-ipware/actions/workflows/ci.yml/badge.svg\n[status-link]: https://github.com/un33k/django-ipware/actions/workflows/ci.yml\n[version-image]: https://img.shields.io/pypi/v/django-ipware.svg\n[version-link]: https://pypi.python.org/pypi/django-ipware\n[coverage-image]: https://coveralls.io/repos/un33k/django-ipware/badge.svg\n[coverage-link]: https://coveralls.io/r/un33k/django-ipware\n\n# sponsors\n\n[neekware inc.](http://neekware.com)\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "django-ipware",
  "package_url": "https://pypi.org/project/django-ipware/",
  "project_url": "https://pypi.org/project/django-ipware/",
  "project_urls": {
    "Homepage": "https://github.com/un33k/django-ipware"
  },
  "release_url": "https://pypi.org/project/django-ipware/6.0.3/",
  "requires_dist": [
    "python-ipware (>=2.0.0)"
  ],
  "requires_python": ">=3.8",
  "summary": "a django application to retrieve user's ip address",
  "version": "6.0.3",
  "releases": [],
  "developers": [
    "info@neekware.com",
    "val_neekman"
  ],
  "kwds": "get_client_ip http_client_ip client_ip ipware trusted_proxies_ips",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_django_ipware",
  "homepage": "https://github.com/un33k/django-ipware",
  "release_count": 40,
  "dependency_ids": [
    "pypi_python_ipware"
  ]
}