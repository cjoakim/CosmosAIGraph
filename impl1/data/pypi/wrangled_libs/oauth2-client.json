{
  "classifiers": [
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: communications"
  ],
  "description": "oauth2client\n============\n.. image:: https://img.shields.io/pypi/v/oauth2-client.svg\n    :target: https://pypi.python.org/pypi/oauth2-client\n\n.. image:: https://img.shields.io/github/license/antechrestos/oauth2client.svg\n    :target: https://raw.githubusercontent.com/antechrestos/oauth2client/master/license\n\n\npresentation\n------------\n\noauth2client is a simple python client library for oauth2. it is based on the requests_\n    .. _requests: https://pypi.python.org/pypi/requests/\n\n\n:warning: starting version `1.2.0`, versions older that python `3.6.0` will not be supported anymore. this late version was released by the end 2016.\n\nfor those that are still using python 2.7, it won't be supported by the end of 2020 and all library shall stop supporting it.\n\nlogin process\n-------------\nfor now it can handle two token process:\n\n* authorization code\n* user credentials\n* client credentials\n\nauthorization code\n~~~~~~~~~~~~~~~~~~\nsince authorization code process needs the user to accept the access to its data by the application, the library\nstarts locally a http server. you may put the host part of the ``redirect_uri`` parameter in your *hosts* file\npointing to your loop-back address. the server waits a ``get`` requests with the  ``code`` as a query parameter.\n\ngetting a couple of access token may be done like this:\n\n.. code-block:: python\n\n    scopes = ['scope_1', 'scope_2']\n\n    service_information = serviceinformation('https://authorization-server/oauth/authorize',\n                                             'https://token-server/oauth/token',\n                                             'client_id',\n                                             'client_secret',\n                                              scopes)\n    manager = credentialmanager(service_information,\n                                proxies=dict(http='http://localhost:3128', https='http://localhost:3128'))\n    redirect_uri = 'http://somewhere.io:8080/oauth/code'\n\n    # builds the authorization url and starts the local server according to the redirect_uri parameter\n    url = manager.init_authorize_code_process(redirect_uri, 'state_test')\n    _logger.info('open this url in your browser\\n%s', url)\n\n    code = manager.wait_and_terminate_authorize_code_process()\n    # from this point the http server is opened on 8080 port and wait to receive a single get request\n    # all you need to do is open the url and the process will go on\n    # (as long you put the host part of your redirect uri in your host file)\n    # when the server gets the request with the code (or error) in its query parameters\n    _logger.debug('code got = %s', code)\n    manager.init_with_authorize_code(redirect_uri, code)\n    _logger.debug('access got = %s', manager._access_token)\n    # here access and refresh token may be used with self.refresh_token\n\nauthorization code with proof key for code exchange (pkce)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nin case you can generate a couple of code verifier and code challenge as follows:\n\n.. code-block:: python\n\n    import base64\n    import hashlib\n    import logging\n    import secrets\n    from typing import tuple\n\n    def generate_sha256_pkce(length: int) -> tuple[str, str]:\n        if not (43 <= length <= 128):\n            raise exception(\"invalid length: \" % str(length))\n        verifier = secrets.token_urlsafe(length)\n        encoded = base64.urlsafe_b64encode(hashlib.sha256(verifier.encode('ascii')).digest())\n        challenge = encoded.decode('ascii')[:-1]\n        return verifier, challenge\n\n\nthen you can init authorization code workflow as follows\n\n.. code-block:: python\n\n    code_verifier, code_challenge = generate_sha256_pkce(64)\n    url = manager.init_authorize_code_process(redirect_uri, 'state_test',\n                                              code_challenge=code_challenge,\n                                              code_challenge_method=\"s256\")\n\n\nor either generate the url\n\n.. code-block:: python\n\n    url = manager.generate_authorize_url(redirect_uri, 'state_test',\n                                         code_challenge=code_challenge,\n                                         code_challenge_method=\"s256\")\n\n\nand once you obtains the ``code`` exchange it as follows\n\n.. code-block:: python\n\n    manager.init_with_authorize_code(redirect_uri, code, code_verifier=code_verifier)\n\n\nuser credentials\n~~~~~~~~~~~~~~~~\ngetting a couple of access and refresh token is much easier:\n\n.. code-block:: python\n\n    scopes = ['scope_1', 'scope_2']\n\n    service_information = serviceinformation('https://authorization-server/oauth/authorize',\n                                             'https://token-server/oauth/token',\n                                             'client_id',\n                                             'client_secret',\n                                              scopes)\n    manager = credentialmanager(service_information,\n                                proxies=dict(http='http://localhost:3128', https='http://localhost:3128'))\n    manager.init_with_user_credentials('login', 'password')\n    _logger.debug('access got = %s', manager._access_token)\n    # here access and refresh token may be used\n\nclient credentials\n~~~~~~~~~~~~~~~~~~\nyou can also get a token with client credentials process\n\n.. code-block:: python\n\n    manager = credentialmanager(service_information,\n                                proxies=dict(http='http://localhost:3128', https='http://localhost:3128'))\n    manager.init_with_client_credentials()\n    # here application admin operation may be called\n\nrefresh token\n~~~~~~~~~~~~~\nprovided that you kept a previous ``refresh_token``, you can initiate your credential manager with it:\n\n.. code-block:: python\n\n    manager = credentialmanager(service_information,\n                                proxies=dict(http='http://localhost:3128', https='http://localhost:3128'))\n    manager.init_with_token('my saved refreshed token')\n\ntoken expiration\n~~~~~~~~~~~~~~~~\n``credentialmanager`` class handle token expiration by calling the ``credentialmanager._is_token_expired`` static method.\nthis implementation is not accurate for all oauth server implementation. you'd better extend  ``credentialmanager`` class\nand override ``_is_token_expired`` method.\n\nread other fields from token response\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n``credentialmanager`` can be subclassed to handle other token response fields such as ``id_token`` in openid protocol.\n\n.. code-block:: python\n\n    class openidcredentialmanager(credentialmanager):\n        def __init__(self, service_information, proxies=none):\n            super(openidcredentialmanager, self).__init__(service_information, proxies)\n            self.id_token = none\n\n        def _process_token_response(self,  token_response, refresh_token_mandatory):\n            id_token = token_response.get('id_token')\n            openidcredentialmanager._check_id(id_token)\n            super(openidcredentialmanager, self)._process_token_response(token_response, refresh_token_mandatory)\n            self.id_token = id_token\n\n        @staticmethod\n        def _check_id(id_token):\n            # check that open id token is valid\n            pass\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "oauth2-client",
  "package_url": "https://pypi.org/project/oauth2-client/",
  "project_url": "https://pypi.org/project/oauth2-client/",
  "project_urls": {
    "Homepage": "http://github.com/antechrestos/OAuth2Client"
  },
  "release_url": "https://pypi.org/project/oauth2-client/1.4.2/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "a client library for oauth2",
  "version": "1.4.2",
  "releases": [],
  "developers": [
    "antechrestos@gmail.com",
    "benjamin_einaudi"
  ],
  "kwds": "oauth2client oauth2 oauth init_with_client_credentials _access_token",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_oauth2_client",
  "homepage": "http://github.com/antechrestos/oauth2client",
  "release_count": 30,
  "dependency_ids": []
}