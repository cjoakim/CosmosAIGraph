{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: utilities"
  ],
  "description": "|build status|_\n\n.. |build status| image:: https://github.com/matthewwithanm/django-imagekit/actions/workflows/python.yml/badge.svg?branch=develop\n.. _build status: https://github.com/matthewwithanm/django-imagekit/actions/workflows/python.yml\n\nimagekit is a django app for processing images. need a thumbnail? a\nblack-and-white version of a user-uploaded image? imagekit will make them for\nyou. if you need to programmatically generate one image from another, you need\nimagekit.\n\nimagekit comes with a bunch of image processors for common tasks like resizing\nand cropping, but you can also create your own. for an idea of what's possible,\ncheck out the `instakit`__ project.\n\n**for the complete documentation on the latest stable version of imagekit, see**\n`imagekit on rtd`_.\n\n.. _`imagekit on rtd`: http://django-imagekit.readthedocs.org\n__ https://github.com/fish2000/instakit\n\n\ninstallation\n============\n\n1. install `pillow`_. (if you're using an ``imagefield`` in django,\n   you should have already done this.)\n2. ``pip install django-imagekit``\n3. add ``'imagekit'`` to your ``installed_apps`` list in your project's ``settings.py``\n\n.. _`pillow`: http://pypi.python.org/pypi/pillow\n\n\nusage overview\n==============\n\n.. _specs:\n\nspecs\n-----\n\nyou have one image and you want to do something to it to create another image.\nbut how do you tell imagekit what to do? by defining an image spec.\n\nan **image spec** is a type of **image generator** that generates a new image\nfrom a source image.\n\n\ndefining specs in models\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe easiest way to use define an image spec is by using an imagespecfield on\nyour model class:\n\n.. code-block:: python\n\n    from django.db import models\n    from imagekit.models import imagespecfield\n    from imagekit.processors import resizetofill\n\n    class profile(models.model):\n        avatar = models.imagefield(upload_to='avatars')\n        avatar_thumbnail = imagespecfield(source='avatar',\n                                          processors=[resizetofill(100, 50)],\n                                          format='jpeg',\n                                          options={'quality': 60})\n\n    profile = profile.objects.all()[0]\n    print(profile.avatar_thumbnail.url)    # > /media/cache/images/982d5af84cddddfd0fbf70892b4431e4.jpg\n    print(profile.avatar_thumbnail.width)  # > 100\n\nas you can probably tell, imagespecfields work a lot like django's\nimagefields. the difference is that they're automatically generated by\nimagekit based on the instructions you give. in the example above, the avatar\nthumbnail is a resized version of the avatar image, saved as a jpeg with a\nquality of 60.\n\nsometimes, however, you don't need to keep the original image (the avatar in\nthe above example); when the user uploads an image, you just want to process it\nand save the result. in those cases, you can use the ``processedimagefield``\nclass:\n\n.. code-block:: python\n\n    from django.db import models\n    from imagekit.models import processedimagefield\n    from imagekit.processors import resizetofill\n\n    class profile(models.model):\n        avatar_thumbnail = processedimagefield(upload_to='avatars',\n                                               processors=[resizetofill(100, 50)],\n                                               format='jpeg',\n                                               options={'quality': 60})\n\n    profile = profile.objects.all()[0]\n    print(profile.avatar_thumbnail.url)    # > /media/avatars/my-avatar.jpg\n    print(profile.avatar_thumbnail.width)  # > 100\n\nthis is pretty similar to our previous example. we don't need to specify a\n\"source\" any more since we're not processing another image field, but we do need\nto pass an \"upload_to\" argument. this behaves exactly as it does for django\nimagefields.\n\n.. note::\n\n    you might be wondering why we didn't need an \"upload_to\" argument for our\n    imagespecfield. the reason is that processedimagefields really are just like\n    imagefields\u2014they save the file path in the database and you need to run\n    syncdb (or create a migration) when you add one to your model.\n\n    imagespecfields, on the other hand, are virtual\u2014they add no fields to your\n    database and don't require a database. this is handy for a lot of reasons,\n    but it means that the path to the image file needs to be programmatically\n    constructed based on the source image and the spec.\n\n\ndefining specs outside of models\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ndefining specs as models fields is one very convenient way to process images,\nbut it isn't the only way. sometimes you can't (or don't want to) add fields to\nyour models, and that's okay. you can define image spec classes and use them\ndirectly. this can be especially useful for doing image processing in views\u2014\nparticularly when the processing being done depends on user input.\n\n.. code-block:: python\n\n    from imagekit import imagespec\n    from imagekit.processors import resizetofill\n\n    class thumbnail(imagespec):\n        processors = [resizetofill(100, 50)]\n        format = 'jpeg'\n        options = {'quality': 60}\n\nit's probably not surprising that this class is capable of processing an image\nin the exact same way as our imagespecfield above. however, unlike with the\nimage spec model field, this class doesn't define what source the spec is acting\non, or what should be done with the result; that's up to you:\n\n.. code-block:: python\n\n    source_file = open('/path/to/myimage.jpg', 'rb')\n    image_generator = thumbnail(source=source_file)\n    result = image_generator.generate()\n\n.. note::\n\n    you don't have to use ``open``! you can use whatever file-like object you\n    want\u2014including a model's ``imagefield``.\n\nthe result of calling ``generate()`` on an image spec is a file-like object\ncontaining our resized image, with which you can do whatever you want. for\nexample, if you wanted to save it to disk:\n\n.. code-block:: python\n\n    dest = open('/path/to/dest.jpg', 'wb')\n    dest.write(result.read())\n    dest.close()\n\n\nusing specs in templates\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nif you have a model with an imagespecfield or processedimagefield, you can\neasily use those processed image just as you would a normal image field:\n\n.. code-block:: html\n\n    <img src=\"{{ profile.avatar_thumbnail.url }}\" />\n\n(this is assuming you have a view that's setting a context variable named\n\"profile\" to an instance of our profile model.)\n\nbut you can also generate processed image files directly in your template\u2014from\nany image\u2014without adding anything to your model. in order to do this, you'll\nfirst have to define an image generator class (remember, specs are a type of\ngenerator) in your app somewhere, just as we did in the last section. you'll\nalso need a way of referring to the generator in your template, so you'll need\nto register it.\n\n.. code-block:: python\n\n    from imagekit import imagespec, register\n    from imagekit.processors import resizetofill\n\n    class thumbnail(imagespec):\n        processors = [resizetofill(100, 50)]\n        format = 'jpeg'\n        options = {'quality': 60}\n\n    register.generator('myapp:thumbnail', thumbnail)\n\n.. note::\n\n    you can register your generator with any id you want, but choose wisely!\n    if you pick something too generic, you could have a conflict with another\n    third-party app you're using. for this reason, it's a good idea to prefix\n    your generator ids with the name of your app. also, imagekit recognizes\n    colons as separators when doing pattern matching (e.g. in the generateimages\n    management command), so it's a good idea to use those too!\n\n.. warning::\n\n    this code can go in any file you want\u2014but you need to make sure it's loaded!\n    in order to keep things simple, imagekit will automatically try to load an\n    module named \"imagegenerators\" in each of your installed apps. so why don't\n    you just save yourself the headache and put your image specs in there?\n\nnow that we've created an image generator class and registered it with imagekit,\nwe can use it in our templates!\n\n\ngenerateimage\n\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nthe most generic template tag that imagekit gives you is called \"generateimage\".\nit requires at least one argument: the id of a registered image generator.\nadditional keyword-style arguments are passed to the registered generator class.\nas we saw above, image spec constructors expect a source keyword argument, so\nthat's what we need to pass to use our thumbnail spec:\n\n.. code-block:: html\n\n    {% load imagekit %}\n\n    {% generateimage 'myapp:thumbnail' source=source_file %}\n\nthis will output the following html:\n\n.. code-block:: html\n\n    <img src=\"/media/cache/images/982d5af84cddddfd0fbf70892b4431e4.jpg\" width=\"100\" height=\"50\" />\n\nyou can also add additional html attributes; just separate them from your\nkeyword args using two dashes:\n\n.. code-block:: html\n\n    {% load imagekit %}\n\n    {% generateimage 'myapp:thumbnail' source=source_file -- alt=\"a picture of me\" id=\"mypicture\" %}\n\nnot generating html image tags? no problem. the tag also functions as an\nassignment tag, providing access to the underlying file object:\n\n.. code-block:: html\n\n    {% load imagekit %}\n\n    {% generateimage 'myapp:thumbnail' source=source_file as th %}\n    <a href=\"{{ th.url }}\">click to download a cool {{ th.width }} x {{ th.height }} image!</a>\n\n\nthumbnail\n\"\"\"\"\"\"\"\"\"\n\nbecause it's such a common use case, imagekit also provides a \"thumbnail\"\ntemplate tag:\n\n.. code-block:: html\n\n    {% load imagekit %}\n\n    {% thumbnail '100x50' source_file %}\n\nlike the generateimage tag, the thumbnail tag outputs an <img> tag:\n\n.. code-block:: html\n\n    <img src=\"/media/cache/images/982d5af84cddddfd0fbf70892b4431e4.jpg\" width=\"100\" height=\"50\" />\n\ncomparing this syntax to the generateimage tag above, you'll notice a few\ndifferences.\n\nfirst, we didn't have to specify an image generator id; unless we tell it\notherwise, thumbnail tag uses the generator registered with the id\n\"imagekit:thumbnail\". **it's important to note that this tag is *not* using the\nthumbnail spec class we defined earlier**; it's using the generator registered\nwith the id \"imagekit:thumbnail\" which, by default, is\n``imagekit.generatorlibrary.thumbnail``.\n\nsecond, we're passing two positional arguments (the dimensions and the source\nimage) as opposed to the keyword arguments we used with the generateimage tag.\n\nlike with the generateimage tag, you can also specify additional html attributes\nfor the thumbnail tag, or use it as an assignment tag:\n\n.. code-block:: html\n\n    {% load imagekit %}\n\n    {% thumbnail '100x50' source_file -- alt=\"a picture of me\" id=\"mypicture\" %}\n    {% thumbnail '100x50' source_file as th %}\n\n\nusing specs in forms\n^^^^^^^^^^^^^^^^^^^^\n\nin addition to the model field above, there's also a form field version of the\n``processedimagefield`` class. the functionality is basically the same (it\nprocesses an image once and saves the result), but it's used in a form class:\n\n.. code-block:: python\n\n    from django import forms\n    from imagekit.forms import processedimagefield\n    from imagekit.processors import resizetofill\n\n    class profileform(forms.form):\n        avatar_thumbnail = processedimagefield(spec_id='myapp:profile:avatar_thumbnail',\n                                               processors=[resizetofill(100, 50)],\n                                               format='jpeg',\n                                               options={'quality': 60})\n\nthe benefit of using ``imagekit.forms.processedimagefield`` (as opposed to\n``imagekit.models.processedimagefield`` above) is that it keeps the logic for\ncreating the image outside of your model (in which you would use a normal django\nimagefield). you can even create multiple forms, each with their own\nprocessedimagefield, that all store their results in the same image field.\n\n\nprocessors\n----------\n\nso far, we've only seen one processor: ``imagekit.processors.resizetofill``. but\nimagekit is capable of far more than just resizing images, and that power comes\nfrom its processors.\n\nprocessors take a pil image object, do something to it, and return a new one.\na spec can make use of as many processors as you'd like, which will all be run\nin order.\n\n.. code-block:: python\n\n    from imagekit import imagespec\n    from imagekit.processors import trimbordercolor, adjust\n\n    class myspec(imagespec):\n        processors = [\n            trimbordercolor(),\n            adjust(contrast=1.2, sharpness=1.1),\n        ]\n        format = 'jpeg'\n        options = {'quality': 60}\n\nthe ``imagekit.processors`` module contains processors for many common\nimage manipulations, like resizing, rotating, and color adjustments. however,\nif they aren't up to the task, you can create your own. all you have to do is\ndefine a class that implements a ``process()`` method:\n\n.. code-block:: python\n\n    class watermark(object):\n        def process(self, image):\n            # code for adding the watermark goes here.\n            return image\n\nthat's all there is to it! to use your fancy new custom processor, just include\nit in your spec's ``processors`` list:\n\n.. code-block:: python\n\n    from imagekit import imagespec\n    from imagekit.processors import trimbordercolor, adjust\n    from myapp.processors import watermark\n\n    class myspec(imagespec):\n        processors = [\n            trimbordercolor(),\n            adjust(contrast=1.2, sharpness=1.1),\n            watermark(),\n        ]\n        format = 'jpeg'\n        options = {'quality': 60}\n\nnote that when you import a processor from ``imagekit.processors``, imagekit\nin turn imports the processor from `pilkit`_. so if you are looking for\navailable processors, look at pilkit.\n\n.. _`pilkit`: https://github.com/matthewwithanm/pilkit\n\n\nadmin\n-----\n\nimagekit also contains a class named ``imagekit.admin.adminthumbnail``\nfor displaying specs (or even regular imagefields) in the\n`django admin change list`_. adminthumbnail is used as a property on\ndjango admin classes:\n\n.. code-block:: python\n\n    from django.contrib import admin\n    from imagekit.admin import adminthumbnail\n    from .models import photo\n\n    class photoadmin(admin.modeladmin):\n        list_display = ('__str__', 'admin_thumbnail')\n        admin_thumbnail = adminthumbnail(image_field='thumbnail')\n\n    admin.site.register(photo, photoadmin)\n\nto use specs defined outside of models:\n\n.. code-block:: python\n    \n    from django.contrib import admin\n    from imagekit.admin import adminthumbnail\n    from imagekit import imagespec\n    from imagekit.processors import resizetofill\n    from imagekit.cachefiles import imagecachefile\n\n    from .models import photo\n\n    class adminthumbnailspec(imagespec):\n        processors = [resizetofill(100, 30)]\n        format = 'jpeg'\n        options = {'quality': 60 }\n\n    def cached_admin_thumb(instance):\n        # `image` is the name of the image field on the model\n        cached = imagecachefile(adminthumbnailspec(instance.image))\n        # only generates the first time, subsequent calls use cache\n        cached.generate()\n        return cached\n\n    class photoadmin(admin.modeladmin):\n        list_display = ('__str__', 'admin_thumbnail')\n        admin_thumbnail = adminthumbnail(image_field=cached_admin_thumb)\n\n    admin.site.register(photo, photoadmin)\n\n \nadminthumbnail can even use a custom template. for more information, see\n``imagekit.admin.adminthumbnail``.\n\n.. _`django admin change list`: https://docs.djangoproject.com/en/dev/intro/tutorial02/#customize-the-admin-change-list\n\n\nmanagement commands\n-------------------\n\nimagekit has one management command\u2014``generateimages``\u2014which will generate cache\nfiles for all of your registered image generators. you can also pass it a list\nof generator ids in order to generate images selectively.\n\n\ncommunity\n=========\n\nplease use `the github issue tracker <https://github.com/matthewwithanm/django-imagekit/issues>`_\nto report bugs with django-imagekit. `a mailing list <https://groups.google.com/forum/#!forum/django-imagekit>`_\nalso exists to discuss the project and ask questions, as well as the official\n`#imagekit <irc://irc.freenode.net/imagekit>`_ channel on freenode.\n\n\ncontributing\n============\n\nwe love contributions! and you don't have to be an expert with the library\u2014or\neven django\u2014to contribute either: imagekit's processors are standalone classes\nthat are completely separate from the more intimidating internals of django's\norm. if you've written a processor that you think might be useful to other\npeople, open a pull request so we can take a look!\n\nyou can also check out our list of `open, contributor-friendly issues`__ for\nideas.\n\ncheck out our `contributing guidelines`_ for more information about pitching in\nwith imagekit.\n\n__ https://github.com/matthewwithanm/django-imagekit/issues?labels=contributor-friendly&state=open\n.. _`contributing guidelines`: https://github.com/matthewwithanm/django-imagekit/blob/develop/contributing.rst\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "django-imagekit",
  "package_url": "https://pypi.org/project/django-imagekit/",
  "project_url": "https://pypi.org/project/django-imagekit/",
  "project_urls": {
    "Homepage": "http://github.com/matthewwithanm/django-imagekit/"
  },
  "release_url": "https://pypi.org/project/django-imagekit/5.0.0/",
  "requires_dist": [
    "django-appconf",
    "pilkit",
    "django-celery >=3.0 ; extra == 'async'",
    "django-dramatiq >=0.4.0 ; extra == 'async_dramatiq'",
    "django-rq >=0.6.0 ; extra == 'async_rq'"
  ],
  "requires_python": "",
  "summary": "automated image processing for django models.",
  "version": "5.0.0",
  "releases": [],
  "developers": [
    "m@tthewwithanm.com",
    "matthew_tretter",
    "venelin.stoykov@industria.tech",
    "venelin_stoykov"
  ],
  "kwds": "image_generator imagekit djangoproject generateimage generateimages",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_django_imagekit",
  "homepage": "http://github.com/matthewwithanm/django-imagekit/",
  "release_count": 41,
  "dependency_ids": [
    "pypi_django_appconf",
    "pypi_django_celery",
    "pypi_django_dramatiq",
    "pypi_django_rq",
    "pypi_pilkit"
  ]
}