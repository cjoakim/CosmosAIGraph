{
  "classifiers": [],
  "description": "index\n=======\n\n* [description](#description)\n* [installation](#installation)\n    * [python pip](#python-pip)\n    * [debian way](#debian-way)\n    * [compiling from source](#compiling-from-source)\n* [usage](#usage)\n    * [discovering devices](#discovering-devices)\n    * [reading data](#reading-data)\n    * [reading data asynchronously](#reading-data-asynchronously)\n    * [writing data](#writing-data)\n    * [receiving notifications](#receiving-notifications)\n* [disclaimer](#disclaimer)\n\n\ndescription\n===========\n\nthis is a python library to use the gatt protocol for bluetooth le\ndevices. it is a wrapper around the implementation used by gatttool in\nbluez package. it does not call other binaries to do its job :)\n\n\ninstallation\n============\n\nthere are many ways of installing this library: using python pip,\nusing the debian package, or manually compiling it.\n\npython pip\n----------\n\nfirst, you need to install the depends. in debian/ubuntu this will be something like:\n\n    sudo apt install pkg-config libboost-python-dev libboost-thread-dev libbluetooth-dev libglib2.0-dev python-dev\n\nnow, install as ever:\n\n    pip install gattlib\n\ndebian way\n----------\n\nthere is a single debian package available from\n[https://github.com/oscaracena/pygattlib/releases](https://github.com/oscaracena/pygattlib/releases). just download it and install using the following command:\n\n    sudo apt install ./python3-gattlib*.deb\n\ncompiling from source\n---------------------\n\nyou should install the needed packages, which are described on `depends`\nfile. take special care about versions: libbluetooth-dev should be\n4.101 or greater. then, just type:\n\n    ./setup.py install --user\n\n\nusage\n=====\n\nthis library provides two ways of work: sync and async. the bluetooth\nle gatt protocol is asynchronous, so, when you need to read some\nvalue, you make a petition, and wait for response. from the\nperspective of the programmer, when you call a read method, you need\nto pass it a callback object, and it will return inmediatly. the\nresponse will be \"injected\" on that callback object.\n\nthis python library allows you to call using a callback object\n(async), or without it (sync). if you does not provide a callback\n(working sync.), the library internally will create one, and will wait\nuntil a response arrives, or a timeout expires. then, the call will\nreturn with the received data.\n\n\ndiscovering devices\n-------------------\n\nto discover ble devices, use the `discoveryservice` provided. you need\nto create an instance of it, indicating the bluetooth device you want\nto use. then call the method `discover`, with a timeout. it will\nreturn a dictionary with the address and name of all devices that\nresponded the discovery.\n\n**note**: it is very likely that you will need admin permissions to do\na discovery, so run this script using `sudo` (or something similar).\n\nas example:\n\n```python\nfrom gattlib import discoveryservice\n\nservice = discoveryservice(\"hci0\")\ndevices = service.discover(2)\n\nfor address, name in devices.items():\n    print(\"name: {}, address: {}\".format(name, address))\n```\n\n\nreading data\n------------\n\nfirst of all, you need to create a gattrequester, passing the address\nof the device to connect to. then, you can read a value defined by\neither by its handle or by its uuid. for example:\n\n```python\nfrom gattlib import gattrequester\n\nreq = gattrequester(\"00:11:22:33:44:55\")\nname = req.read_by_uuid(\"00002a00-0000-1000-8000-00805f9b34fb\")[0]\nsteps = req.read_by_handle(0x15)[0]\n```\n\n\nreading data asynchronously\n--------------------------\n\nthe process is almost the same: you need to create a gattrequester\npassing the address of the device to connect to. then, create a\ngattresponse object, on which receive the response from your\ndevice. this object will be passed to the `async` method used.\n\n**note**: it is important to maintain the python process alive, or the\nresponse will never arrive. you can `wait` on that response object, or you\ncan do other things meanwhile.\n\nthe following is an example of response waiting:\n\n```python\nfrom gattlib import gattrequester, gattresponse\n\nreq = gattrequester(\"00:11:22:33:44:55\")\nresponse = gattresponse()\n\nreq.read_by_handle_async(0x15, response)\nwhile not response.received():\n    time.sleep(0.1)\n\nsteps = response.received()[0]\n```\n\nand then, an example that inherits from gattresponse to be notified\nwhen the response arrives:\n\n```python\nfrom gattlib import gattrequester, gattresponse\n\nclass notifyyourname(gattresponse):\n    def on_response(self, name):\n        print(\"your name is: {}\".format(name))\n\nresponse = notifyyourname()\nreq = gattrequester(\"00:11:22:33:44:55\")\nreq.read_by_handle_async(0x15, response)\n\nwhile true:\n    # here, do other interesting things\n    sleep(1)\n```\n\n\nwriting data\n------------\n\nthe process to write data is the same as for read. create a gattrequest object,\nand use the method `write_by_handle` to send the data. this method will issue a\n`write request`. as a note, data must be a bytes object. see the following\nexample:\n\n```python\nfrom gattlib import gattrequester\n\nreq = gattrequester(\"00:11:22:33:44:55\")\nreq.write_by_handle(0x10, bytes([14, 4, 56]))\n```\n\nyou can also use the `write_cmd()` to send a write command instead. it has the\nsame parameters as `write_by_handle`: the handler id and a bytes object. as an\nexample:\n\n```python\nfrom gattlib import gattrequester\n\nreq = gattrequester(\"00:11:22:33:44:55\")\nreq.write_cmd(0x001e, bytes([16, 1, 4]))\n```\n\n\nreceiving notifications\n-----------------------\n\nto receive notifications from remote device, you need to overwrite the\n`on_notification` method of `gattrequester`. this method is called\neach time a notification arrives, and has two params: the handle where\nthe notification was produced, and a string with the data that came in\nthe notification event. the following is a brief example:\n\n```python\nfrom gattlib import gattrequester\n\nclass requester(gattrequester):\n    def on_notification(self, handle, data):\n        print(\"- notification on handle: {}\\n\".format(handle))\n```\n\nyou can receive indications as well. just overwrite the method\n`on_indication` of `gattrequester`.\n\n\ndisclaimer\n==========\n\nthis software may harm your device. use it at your own risk.\n\n    there is no warranty for the program, to the extent permitted by\n    applicable law. except when otherwise stated in writing the copyright\n    holders and/or other parties provide the program \u201cas is\u201d without\n    warranty of any kind, either expressed or implied, including, but not\n    limited to, the implied warranties of merchantability and fitness for\n    a particular purpose. the entire risk as to the quality and\n    performance of the program is with you. should the program prove\n    defective, you assume the cost of all necessary servicing, repair or\n    correction.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "gattlib",
  "package_url": "https://pypi.org/project/gattlib/",
  "project_url": "https://pypi.org/project/gattlib/",
  "project_urls": {
    "Homepage": "https://github.com/oscaracena/pygattlib"
  },
  "release_url": "https://pypi.org/project/gattlib/0.20210616/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "library to access bluetooth le devices",
  "version": "0.20210616",
  "releases": [],
  "developers": [
    "oscar.acena@gmail.com",
    "oscar_acena"
  ],
  "kwds": "gattlib bluetooth gattrequester gatttool gattrequest",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_gattlib",
  "homepage": "https://github.com/oscaracena/pygattlib",
  "release_count": 15,
  "dependency_ids": []
}