{
  "classifiers": [
    "development status :: 3 - alpha",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# javaobj-py3\n\n<p>\n    <a href=\"https://pypi.python.org/pypi/javaobj-py3/\">\n        <img src=\"https://img.shields.io/pypi/v/javaobj-py3.svg\" alt=\"latest version\" />\n        <img src=\"https://img.shields.io/pypi/l/javaobj-py3.svg\" alt=\"license\" />\n    </a>\n    <a href=\"https://travis-ci.org/tcalmant/python-javaobj\">\n    <img src=\"https://travis-ci.org/tcalmant/python-javaobj.svg?branch=master\"\n        alt=\"travis-ci status\" />\n    </a>\n    <a href=\"https://coveralls.io/r/tcalmant/python-javaobj?branch=master\">\n        <img src=\"https://coveralls.io/repos/tcalmant/python-javaobj/badge.svg?branch=master\"\n            alt=\"coveralls status\" />\n    </a>\n</p>\n\n*python-javaobj* is a python library that provides functions for reading and\nwriting (writing is wip currently) java objects serialized or will be\ndeserialized by `objectoutputstream`. this form of object representation is a\nstandard data interchange format in java world.\n\nthe `javaobj` module exposes an api familiar to users of the standard library\n`marshal`, `pickle` and `json` modules.\n\n## about this repository\n\nthis project is a fork of *python-javaobj* by volodymyr buell, originally from\n[google code](http://code.google.com/p/python-javaobj/) and now hosted on\n[github](https://github.com/vbuell/python-javaobj).\n\nthis fork intends to work both on python 2.7 and python 3.4+.\n\n## compatibility warnings\n\n### new implementation of the parser\n\n| implementations | version  |\n|-----------------|----------|\n| `v1`, `v2`      | `0.4.0+` |\n\nsince version 0.4.0, two implementations of the parser are available:\n\n* `v1`: the *classic* implementation of `javaobj`, with a work in progress\n  implementation of a writer.\n* `v2`: the *new* implementation, which is a port of the java project\n  [`jdeserialize`](https://github.com/frohoff/jdeserialize/),\n  with support of the object transformer (with a new api) and of the `numpy`\n  arrays loading.\n\nyou can use the `v1` parser to ensure that the behaviour of your scripts\ndoesn't change and to keep the ability to write down files.\n\nyou can use the `v2` parser for new developments\n*which won't require marshalling* and as a *fallback* if the `v1`\nfails to parse a file.\n\n### object transformers v1\n\n| implementations | version  |\n|-----------------|----------|\n| `v1`            | `0.2.0+` |\n\nas of version 0.2.0, the notion of *object transformer* from the original\nproject as been replaced by an *object creator*.\n\nthe *object creator* is called before the deserialization.\nthis allows to store the reference of the converted object before deserializing\nit, and avoids a mismatch between the referenced object and the transformed one.\n\n### object transformers v2\n\n| implementations | version  |\n|-----------------|----------|\n| `v2`            | `0.4.0+` |\n\nthe `v2` implementation provides a new api for the object transformers.\nplease look at the *usage (v2)* section in this file.\n\n### bytes arrays\n\n| implementations | version  |\n|-----------------|----------|\n| `v1`            | `0.2.3+` |\n\nas of version 0.2.3, bytes arrays are loaded as a `bytes` object instead of\nan array of integers.\n\n### custom transformer\n\n| implementations | version  |\n|-----------------|----------|\n| `v2`            | `0.4.2+` |\n\na new transformer api has been proposed to handle objects written with a custom\njava writer.\nyou can find a sample usage in the *custom transformer* section in this file.\n\n## features\n\n* java object instance un-marshalling\n* java classes un-marshalling\n* primitive values un-marshalling\n* automatic conversion of java collections to python ones\n  (`hashmap` => `dict`, `arraylist` => `list`, etc.)\n* basic marshalling of simple java objects (`v1` implementation only)\n* automatically uncompresses gzipped files\n\n## requirements\n\n* python >= 2.7 or python >= 3.4\n* `enum34` and `typing` when using python <= 3.4 (installable with `pip`)\n* maven 2+ (for building test data of serialized objects.\n  you can skip it if you do not plan to run `tests.py`)\n\n## usage (v1 implementation)\n\nun-marshalling of java serialised object:\n\n```python\nimport javaobj\n\nwith open(\"obj5.ser\", \"rb\") as fd:\n    jobj = fd.read()\n\npobj = javaobj.loads(jobj)\nprint(pobj)\n```\n\nor, you can use `javaobjectunmarshaller` object directly:\n\n```python\nimport javaobj\n\nwith open(\"objcollections.ser\", \"rb\") as fd:\n    marshaller = javaobj.javaobjectunmarshaller(fd)\n    pobj = marshaller.readobject()\n\n    print(pobj.value, \"should be\", 17)\n    print(pobj.next, \"should be\", true)\n\n    pobj = marshaller.readobject()\n```\n\n**note:** the objects and methods provided by `javaobj` module are shortcuts\nto the `javaobj.v1` package, for compatibility purpose.\nit is **recommended** to explicitly import methods and classes from the `v1`\n(or `v2`) package when writing new code, in order to be sure that your code\nwon't need import updates in the future.\n\n\n## usage (v2 implementation)\n\nthe following methods are provided by the `javaobj.v2` package:\n\n* `load(fd, *transformers, use_numpy_arrays=false)`:\n  parses the content of the given file descriptor, opened in binary mode (`rb`).\n  the method accepts a list of custom object transformers. the default object\n  transformer is always added to the list.\n\n  the `use_numpy_arrays` flag indicates that the arrays of primitive type\n  elements must be loaded using `numpy` (if available) instead of using the\n  standard parsing technic.\n\n* `loads(bytes, *transformers, use_numpy_arrays=false)`:\n  this the a shortcut to the `load()` method, providing it the binary data\n  using a `bytesio` object.\n\n**note:** the v2 parser doesn't have the marshalling capability.\n\nsample usage:\n\n```python\nimport javaobj.v2 as javaobj\n\nwith open(\"obj5.ser\", \"rb\") as fd:\n    pobj = javaobj.load(fd)\n\nprint(pobj.dump())\n```\n\n### object transformer\n\nan object transformer can be called during the parsing of a java object\ninstance or while loading an array.\n\nthe java object instance parsing works in two main steps:\n\n1. the transformer is called to create an instance of a bean that inherits\n   `javainstance`.\n1. the latter bean is then called:\n\n   * when the object is written with a custom block data\n   * after the fields and annotations have been parsed, to update the content\n   of the python bean.\n\nhere is an example for a java `hashmap` object. you can look at the code of\nthe `javaobj.v2.transformer` module to see the whole implementation.\n\n```python\nclass javamap(dict, javaobj.v2.beans.javainstance):\n    \"\"\"\n    inherits from dict for python usage, javainstance for parsing purpose\n    \"\"\"\n    def __init__(self):\n        # don't forget to call both constructors\n        dict.__init__(self)\n        javainstance.__init__(self)\n\n    def load_from_blockdata(self, parser, reader, indent=0):\n    \"\"\"\n    reads content stored in a block data.\n\n    this method is called only if the class description has both the\n    `sc_externalizable` and `sc_block_data` flags set.\n\n    the stream parsing will stop and fail if this method returns false.\n\n    :param parser: the javastreamparser in use\n    :param reader: the underlying data stream reader\n    :param indent: indentation to use in logs\n    :return: true on success, false on error\n    \"\"\"\n    # this kind of class is not supposed to have the sc_block_data flag set\n    return false\n\n    def load_from_instance(self, indent=0):\n        # type: (int) -> bool\n        \"\"\"\n        load content from the parsed instance object.\n\n        this method is called after the block data (if any), the fields and\n        the annotations have been loaded.\n\n        :param indent: indentation to use while logging\n        :return: true on success (currently ignored)\n        \"\"\"\n        # maps have their content in their annotations\n        for cd, annotations in self.annotations.items():\n            # annotations are associated to their definition class\n            if cd.name == \"java.util.hashmap\":\n                # we are in the annotation created by the handled class\n                # group annotation elements 2 by 2\n                # (storage is: key, value, key, value, ...)\n                args = [iter(annotations[1:])] * 2\n                for key, value in zip(*args):\n                    self[key] = value\n\n                # job done\n                return true\n\n        # couldn't load the data\n        return false\n\nclass mapobjecttransformer(javaobj.v2.api.objecttransformer):\n    \"\"\"\n    creates a javainstance object with custom loading methods for the\n    classes it can handle\n    \"\"\"\n    def create_instance(self, classdesc):\n        # type: (javaclassdesc) -> optional[javainstance]\n        \"\"\"\n        transforms a parsed java object into a python object\n\n        :param classdesc: the description of a java class\n        :return: the python form of the object, or the original javaobject\n        \"\"\"\n        if classdesc.name == \"java.util.hashmap\":\n            # we can handle this class description\n            return javamap()\n        else:\n            # return none if the class is not handled\n            return none\n```\n\n### custom object transformer\n\nthe custom transformer is called when the class is not handled by the default\nobject transformer.\na custom object transformer still inherits from the `objecttransformer` class,\nbut it also implements the `load_custom_writeobject` method.\n\nthe sample given here is used in the unit tests.\n\n#### java sample\n\non the java side, we create various classes and write them as we wish:\n\n```java\nclass customclass implements serializable {\n\n    private static final long serialversionuid = 1;\n\n    public void start(objectoutputstream out) throws exception {\n        this.writeobject(out);\n    }\n\n    private void writeobject(objectoutputstream out) throws ioexception {\n        customwriter custom = new customwriter(42);\n        out.writeobject(custom);\n        out.flush();\n    }\n}\n\nclass randomchild extends random {\n\n    private static final long serialversionuid = 1;\n    private int num = 1;\n    private double doub = 4.5;\n\n    randomchild(int seed) {\n        super(seed);\n    }\n}\n\nclass customwriter implements serializable {\n    protected randomchild custom_obj;\n\n    customwriter(int seed) {\n        custom_obj = new randomchild(seed);\n    }\n\n    private static final long serialversionuid = 1;\n    private static final int current_serial_version = 0;\n\n    private void writeobject(objectoutputstream out) throws ioexception {\n        out.writeint(current_serial_version);\n        out.writeobject(custom_obj);\n    }\n}\n```\n\nan here is a sample writing of that kind of object:\n\n```java\nobjectoutputstream oos = new objectoutputstream(\n    new fileoutputstream(\"custom_objects.ser\"));\ncustomclass writer = new customclass();\nwriter.start(oos);\noos.flush();\noos.close();\n```\n\n#### python sample\n\non the python side, the first step is to define the custom transformers.\nthey are children of the `javaobj.v2.transformers.objecttransformer` class.\n\n```python\nclass basetransformer(javaobj.v2.transformers.objecttransformer):\n    \"\"\"\n    creates a javainstance object with custom loading methods for the\n    classes it can handle\n    \"\"\"\n\n    def __init__(self, handled_classes=none):\n        self.instance = none\n        self.handled_classes = handled_classes or {}\n\n    def create_instance(self, classdesc):\n        \"\"\"\n        transforms a parsed java object into a python object\n\n        :param classdesc: the description of a java class\n        :return: the python form of the object, or the original javaobject\n        \"\"\"\n        if classdesc.name in self.handled_classes:\n            self.instance = self.handled_classes[classdesc.name]()\n            return self.instance\n\n        return none\n\nclass randomchildtransformer(basetransformer):\n    def __init__(self):\n        super(randomchildtransformer, self).__init__(\n            {\"randomchild\": randomchildinstance}\n        )\n\nclass customwritertransformer(basetransformer):\n    def __init__(self):\n        super(customwritertransformer, self).__init__(\n            {\"customwriter\": customwriterinstance}\n        )\n\nclass javarandomtransformer(basetransformer):\n    def __init__(self):\n        super(javarandomtransformer, self).__init__()\n        self.name = \"java.util.random\"\n        self.field_names = [\"havenextnextgaussian\", \"nextnextgaussian\", \"seed\"]\n        self.field_types = [\n            javaobj.v2.beans.fieldtype.boolean,\n            javaobj.v2.beans.fieldtype.double,\n            javaobj.v2.beans.fieldtype.long,\n        ]\n\n    def load_custom_writeobject(self, parser, reader, name):\n        if name != self.name:\n            return none\n\n        fields = []\n        values = []\n        for f_name, f_type in zip(self.field_names, self.field_types):\n            values.append(parser._read_field_value(f_type))\n            fields.append(javaobj.beans.javafield(f_type, f_name))\n\n        class_desc = javaobj.beans.javaclassdesc(\n            javaobj.beans.classdesctype.normalclass\n        )\n        class_desc.name = self.name\n        class_desc.desc_flags = javaobj.beans.classdatatype.external_contents\n        class_desc.fields = fields\n        class_desc.field_data = values\n        return class_desc\n```\n\nsecond step is defining the representation of the instances, where the real\nobject loading occurs. those classes inherit from\n`javaobj.v2.beans.javainstance`.\n\n```python\nclass customwriterinstance(javaobj.v2.beans.javainstance):\n    def __init__(self):\n        javaobj.v2.beans.javainstance.__init__(self)\n\n    def load_from_instance(self):\n        \"\"\"\n        updates the content of this instance\n        from its parsed fields and annotations\n        :return: true on success, false on error\n        \"\"\"\n        if self.classdesc and self.classdesc in self.annotations:\n            # here, we known there is something written before the fields,\n            # even if it's not declared in the class description\n            fields = [\"int_not_in_fields\"] + self.classdesc.fields_names\n            raw_data = self.annotations[self.classdesc]\n            int_not_in_fields = struct.unpack(\n                \">i\", bytesio(raw_data[0].data).read(4)\n            )[0]\n            custom_obj = raw_data[1]\n            values = [int_not_in_fields, custom_obj]\n            self.field_data = dict(zip(fields, values))\n            return true\n\n        return false\n\n\nclass randomchildinstance(javaobj.v2.beans.javainstance):\n    def load_from_instance(self):\n        \"\"\"\n        updates the content of this instance\n        from its parsed fields and annotations\n        :return: true on success, false on error\n        \"\"\"\n        if self.classdesc and self.classdesc in self.field_data:\n            fields = self.classdesc.fields_names\n            values = [\n                self.field_data[self.classdesc][self.classdesc.fields[i]]\n                for i in range(len(fields))\n            ]\n            self.field_data = dict(zip(fields, values))\n            if (\n                self.classdesc.super_class\n                and self.classdesc.super_class in self.annotations\n            ):\n                super_class = self.annotations[self.classdesc.super_class][0]\n                self.annotations = dict(\n                    zip(super_class.fields_names, super_class.field_data)\n                )\n            return true\n\n        return false\n```\n\nfinally we can use the transformers in the loading process.\nnote that even if it is not explicitly given, the `defaultobjecttransformer`\nwill be also be used, as it is added automatically by `javaobj` if it is\nmissing from the given list.\n\n```python\n# load the object using those transformers\ntransformers = [\n    customwritertransformer(),\n    randomchildtransformer(),\n    javarandomtransformer()\n]\npobj = javaobj.loads(\"custom_objects.ser\", *transformers)\n\n# here we show a field that isn't visible from the class description\n# the field belongs to the class but it's not serialized by default because\n# it's static. see: https://stackoverflow.com/a/16477421/12621168\nprint(pobj.field_data[\"int_not_in_fields\"])\n```\n\n\n",
  "docs_url": null,
  "keywords": "python java marshalling serialization",
  "license": "apache license 2.0",
  "name": "javaobj-py3",
  "package_url": "https://pypi.org/project/javaobj-py3/",
  "project_url": "https://pypi.org/project/javaobj-py3/",
  "project_urls": {
    "Homepage": "https://github.com/tcalmant/python-javaobj"
  },
  "release_url": "https://pypi.org/project/javaobj-py3/0.4.3/",
  "requires_dist": [
    "enum34 ; python_version <= \"3.4\"",
    "typing ; python_version <= \"3.4\""
  ],
  "requires_python": "",
  "summary": "module for serializing and de-serializing java objects.",
  "version": "0.4.3",
  "releases": [],
  "developers": [
    "thomas.calmant@gmail.com",
    "thomas_calmant",
    "vbuell@gmail.com",
    "volodymyr_buell"
  ],
  "kwds": "serialized serializing serialization serialised py3",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_javaobj_py3",
  "homepage": "https://github.com/tcalmant/python-javaobj",
  "release_count": 15,
  "dependency_ids": [
    "pypi_enum34",
    "pypi_typing"
  ]
}