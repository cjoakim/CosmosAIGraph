{
  "classifiers": [
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "<h1 align=\"center\">envier</h1>\n<h2 align=\"center\">python application configuration from the environment</h2>\n\n## synopsis\n\nenvier is a python library for extracting configuration from environment\nvariables in a declarative and (eventually) 12-factor-app-compliant way.\n\n\n## usage\n\nthe following example shows how to declare the configuration for an application\nthat uses the `myapp_debug`, `myapp_service_host` and `myapp_service_port`\nvariables from the environment.\n\n~~~ python\n>>> from envier import env\n>>> \n>>> class globalconfig(env):\n>>>     __prefix__ = \"myapp\"\n>>>     \n>>>     debug_mode = env.var(bool, \"debug\", default=false)\n>>> \n>>>     service_host = env.var(str, \"service.host\", default=\"localhost\")\n>>>     service_port = env.var(int, \"service.port\", default=3000)\n>>> \n>>>     _is_default_port = env.der(bool, lambda c: c.service_port == c.spec.service_port.default)\n>>> \n>>> config = globalconfig()\n>>> config.service_port\n3000\n>>> config._is_default_port\ntrue\n~~~\n\nconfigurations can also be nested to create namespaces:\n\n~~~ python\n>>> from envier import env\n>>> \n>>> class serviceconfig(env):\n>>>     __prefix__ = \"service\"\n>>> \n>>>     host = env.var(str, \"host\", default=\"localhost\")\n>>>     port = env.var(int, \"port\", default=3000)\n>>> \n>>> class globalconfig(env):\n>>>     __prefix__ = \"myapp\"\n>>>     \n>>>     debug_mode = env.var(bool, \"debug\", default=false)\n>>> \n>>>     service = serviceconfig\n>>> \n>>> config = globalconfig()\n>>> config.service.port\n3000\n~~~\n\nthe same configuration can be obtained with implicit nesting by declaring the\n`serviceconfig` subclass inside `globalconfig`, and setting the class attribute\n`__item__` to the name of the item the sub-configuration should be assigned to,\nviz.\n\n~~~ python\n>>> from envier import env\n>>> \n>>> class globalconfig(env):\n>>>     __prefix__ = \"myapp\"\n>>>     \n>>>     debug_mode = env.var(bool, \"debug\", default=false)\n>>> \n>>>     class serviceconfig(env):\n>>>         __item__ = __prefix__ = \"service\"\n>>>         \n>>>         host = env.var(str, \"host\", default=\"localhost\")\n>>>         port = env.var(int, \"port\", default=3000)\n>>> \n>>> config = globalconfig()\n>>> config.service.port\n3000\n~~~\n\n\n## type checking\n\nthe library ships with a `mypy` plugin to allow for type checking. if you want\nto use it, either install the library with the `mypy` extra or ensure that\n`mypy` is installed, and then add `envier.mypy` to the list of extra plugins in\nthe `mypy` configuration.\n\n\n## roadmap\n\n- add support for environment files.\n- rely on type hints as support for older versions of python is dropped.\n- derivations might require an evaluation order.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "envier",
  "package_url": "https://pypi.org/project/envier/",
  "project_url": "https://pypi.org/project/envier/",
  "project_urls": {
    "Homepage": "https://github.com/DataDog/envier"
  },
  "release_url": "https://pypi.org/project/envier/0.5.0/",
  "requires_dist": [
    "mypy; extra == 'mypy'"
  ],
  "requires_python": ">=3.7",
  "summary": "python application configuration via the environment",
  "version": "0.5.0",
  "releases": [],
  "developers": [
    "dev@datadoghq.com"
  ],
  "kwds": "myapp_service_port myapp_service_host envier myapp_debug globalconfig",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_envier",
  "homepage": "",
  "release_count": 6,
  "dependency_ids": [
    "pypi_mypy"
  ]
}