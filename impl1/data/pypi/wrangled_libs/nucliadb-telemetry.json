{
  "classifiers": [
    "development status :: 3 - alpha",
    "framework :: asyncio",
    "intended audience :: developers",
    "intended audience :: information technology",
    "license :: osi approved :: gnu affero general public license v3 or later (agplv3+)",
    "programming language :: python",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: system :: monitoring"
  ],
  "description": "# nucliadb telemetry\n\nopen telemetry compatible plugin to propagate traceid on fastapi, nats and grpc with asyncio.\n\nenv vars:\n\n```\n    jaeger_enabled = true\n    jaeger_host = \"127.0.0.1\"\n    jaeger_port = server.port\n```\n\non fastapi you should add:\n\n```python\n    tracer_provider = get_telemetry(\"http_service\")\n    app = fastapi(title=\"test api\")  # type: ignore\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    fastapiinstrumentor.instrument_app(app, tracer_provider=tracer_provider)\n\n    ..\n    await init_telemetry(tracer_provider)  # to start asyncio task\n    ..\n\n```\n\non grpc server you should add:\n\n```python\n    tracer_provider = get_telemetry(\"grpc_server_service\")\n    telemetry_grpc = grpctelemetry(\"grpc_client_service\", tracer_provider)\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    server = telemetry_grpc.init_server()\n    helloworld_pb2_grpc.add_greeterservicer_to_server(servicer, server)\n\n    ..\n    await init_telemetry(tracer_provider)  # to start asyncio task\n    ..\n```\n\non grpc client you should add:\n\n```python\n    tracer_provider = get_telemetry(\"grpc_client_service\")\n    telemetry_grpc = grpctelemetry(\"grpc_client_service\", tracer_provider)\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    channel = telemetry_grpc.init_client(f\"localhost:{grpc_service}\")\n    stub = helloworld_pb2_grpc.greeterstub(channel)\n\n    ..\n    await init_telemetry(tracer_provider)  # to start asyncio task\n    ..\n\n```\n\non nats jetstream push subscriber you should add:\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n    set_global_textmap(b3multiformat())\n    jsotel = jetstreamcontexttelemetry(\n        js, \"nats_service\", tracer_provider\n    )\n\n    subscription = await jsotel.subscribe(\n        subject=\"testing.telemetry\",\n        stream=\"testing\",\n        cb=handler,\n    )\n\n```\n\non nats publisher you should add:\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    jsotel = jetstreamcontexttelemetry(\n        js, \"nats_service\", tracer_provider\n    )\n\n     await jsotel.publish(\"testing.telemetry\", request.name.encode())\n\n```\n\n\non nats jetstream pull subscription you can use different patterns if you want to\njust get one message and exit or pull several ones. for just one message\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n    set_global_textmap(b3multiformat())\n    jsotel = jetstreamcontexttelemetry(\n        js, \"nats_service\", tracer_provider\n    )\n\n    # you can use either pull_subscribe or pull_subscribe_bind\n    subscription = await jsotel.pull_subscribe(\n        subject=\"testing.telemetry\",\n        durable=\"consumer_name\"\n        stream=\"testing\",\n    )\n\n    async def callback(message):\n        # do something with your message\n        # and optionally return something\n        return true\n\n    try:\n        result = await jsotel.pull_one(subscription, callback)\n    except errors.timeouterror\n        pass\n\n```\nfor multiple messages just wrap it in a loop:\n\n```python\n    while true:\n        try:\n            result = await jsotel.pull_one(subscription, callback)\n        except errors.timeouterror\n            pass\n\n```\n\n\non nats client (no jestream! ) publisher you should add:\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    ncotel = natsclienttelemetry(\n        nc, \"nats_service\", tracer_provider\n    )\n\n     await ncotel.publish(\"testing.telemetry\", request.name.encode())\n\n```\n\non nats client (no jestream! ) subscriber you should add:\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n    set_global_textmap(b3multiformat())\n    ncotel = natsclientcontexttelemetry(\n        js, \"nats_service\", tracer_provider\n    )\n\n    subscription = await ncotel.subscribe(\n        subject=\"testing.telemetry\",\n        queue=\"queue_nname\",\n        cb=handler,\n    )\n\n```\n\n\non nats client (no jestream! ) request you should add:\n\n```python\n    nc = await nats.connect(servers=[self.natsd])\n    js = self.nc.jetstream()\n    tracer_provider = get_telemetry(\"nats_service\")\n    if not tracer_provider.initialized:\n        await init_telemetry(tracer_provider)\n\n    set_global_textmap(b3multiformat())\n    ncotel = natsclienttelemetry(\n        nc, \"nats_service\", tracer_provider\n    )\n\n    response = await ncotel.request(\"testing.telemetry\", request.name.encode())\n\n```\n\nand to handle responses on the other side, you can use the same pattern as in plain nats client\nsubscriber, just adding the `msg.respond()` on the handler when done\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "nucliadb-telemetry",
  "package_url": "https://pypi.org/project/nucliadb-telemetry/",
  "project_url": "https://pypi.org/project/nucliadb-telemetry/",
  "project_urls": {
    "Homepage": "https://github.com/nuclia/nucliadb"
  },
  "release_url": "https://pypi.org/project/nucliadb-telemetry/2.37.0.post70/",
  "requires_dist": [
    "pydantic",
    "prometheus-client >=0.12.0",
    "orjson >=3.6.7",
    "wrapt >=1.14.1",
    "opentelemetry-api ==1.21.0 ; extra == 'all'",
    "fastapi ; extra == 'all'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'all'",
    "grpcio-status >=1.44.0 ; extra == 'all'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'all'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'all'",
    "tikv-client >=0.0.3 ; extra == 'all'",
    "grpcio-tools >=1.44.0 ; extra == 'all'",
    "grpcio >=1.44.0 ; extra == 'all'",
    "grpcio-channelz >=1.44.0 ; extra == 'all'",
    "nats-py[nkeys] >=2.5.0 ; extra == 'all'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'all'",
    "grpcio-reflection >=1.44.0 ; extra == 'all'",
    "grpcio-testing >=1.44.0 ; extra == 'all'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'all'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'all'",
    "opentelemetry-proto ==1.21.0 ; extra == 'all'",
    "grpcio-health-checking >=1.44.0 ; extra == 'all'",
    "fastapi ; extra == 'fastapi'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'fastapi'",
    "opentelemetry-api ==1.21.0 ; extra == 'fastapi'",
    "opentelemetry-proto ==1.21.0 ; extra == 'fastapi'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'fastapi'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'fastapi'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'fastapi'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'fastapi'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'fastapi'",
    "grpcio >=1.44.0 ; extra == 'grpc'",
    "grpcio-health-checking >=1.44.0 ; extra == 'grpc'",
    "grpcio-channelz >=1.44.0 ; extra == 'grpc'",
    "grpcio-status >=1.44.0 ; extra == 'grpc'",
    "grpcio-tools >=1.44.0 ; extra == 'grpc'",
    "grpcio-testing >=1.44.0 ; extra == 'grpc'",
    "grpcio-reflection >=1.44.0 ; extra == 'grpc'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'grpc'",
    "opentelemetry-api ==1.21.0 ; extra == 'grpc'",
    "opentelemetry-proto ==1.21.0 ; extra == 'grpc'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'grpc'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'grpc'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'grpc'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'grpc'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'grpc'",
    "nats-py[nkeys] >=2.5.0 ; extra == 'nats'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'nats'",
    "opentelemetry-api ==1.21.0 ; extra == 'nats'",
    "opentelemetry-proto ==1.21.0 ; extra == 'nats'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'nats'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'nats'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'nats'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'nats'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'nats'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'otel'",
    "opentelemetry-api ==1.21.0 ; extra == 'otel'",
    "opentelemetry-proto ==1.21.0 ; extra == 'otel'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'otel'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'otel'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'otel'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'otel'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'otel'",
    "tikv-client >=0.0.3 ; extra == 'tikv'",
    "opentelemetry-sdk ==1.21.0 ; extra == 'tikv'",
    "opentelemetry-api ==1.21.0 ; extra == 'tikv'",
    "opentelemetry-proto ==1.21.0 ; extra == 'tikv'",
    "opentelemetry-exporter-jaeger ==1.21.0 ; extra == 'tikv'",
    "opentelemetry-propagator-b3 ==1.21.0 ; extra == 'tikv'",
    "opentelemetry-instrumentation-fastapi ==0.42b0 ; extra == 'tikv'",
    "opentelemetry-instrumentation-aiohttp-client ==0.42b0 ; extra == 'tikv'",
    "opentelemetry-semantic-conventions ==0.42b0 ; extra == 'tikv'"
  ],
  "requires_python": ">=3.8",
  "summary": "nucliadb telemetry library python process",
  "version": "2.37.0.post70",
  "releases": [],
  "developers": [
    "nucliadb@nuclia.com",
    "nucliadb_authors"
  ],
  "kwds": "telemetry_grpc tracer_provider init_telemetry jaeger_port get_telemetry",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_nucliadb_telemetry",
  "homepage": "https://github.com/nuclia/nucliadb",
  "release_count": 315,
  "dependency_ids": [
    "pypi_fastapi",
    "pypi_grpcio",
    "pypi_grpcio_channelz",
    "pypi_grpcio_health_checking",
    "pypi_grpcio_reflection",
    "pypi_grpcio_status",
    "pypi_grpcio_testing",
    "pypi_grpcio_tools",
    "pypi_nats_py",
    "pypi_opentelemetry_api",
    "pypi_opentelemetry_exporter_jaeger",
    "pypi_opentelemetry_instrumentation_aiohttp_client",
    "pypi_opentelemetry_instrumentation_fastapi",
    "pypi_opentelemetry_propagator_b3",
    "pypi_opentelemetry_proto",
    "pypi_opentelemetry_sdk",
    "pypi_opentelemetry_semantic_conventions",
    "pypi_orjson",
    "pypi_prometheus_client",
    "pypi_pydantic",
    "pypi_tikv_client",
    "pypi_wrapt"
  ]
}