{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: text processing :: markup"
  ],
  "description": "mwparserfromhell\n================\n\n.. image:: https://api.travis-ci.com/earwig/mwparserfromhell.svg\n  :alt: build status\n  :target: https://travis-ci.org/earwig/mwparserfromhell\n\n.. image:: https://img.shields.io/coveralls/earwig/mwparserfromhell/main.svg\n  :alt: coverage status\n  :target: https://coveralls.io/r/earwig/mwparserfromhell\n\n**mwparserfromhell** (the *mediawiki parser from hell*) is a python package\nthat provides an easy-to-use and outrageously powerful parser for mediawiki_\nwikicode. it supports python 3.5+.\n\ndeveloped by earwig_ with contributions from `\u03c3`_, legoktm_, and others.\nfull documentation is available on readthedocs_. development occurs on github_.\n\ninstallation\n------------\n\nthe easiest way to install the parser is through the `python package index`_;\nyou can install the latest release with ``pip install mwparserfromhell``\n(`get pip`_). make sure your pip is up-to-date first, especially on windows.\n\nalternatively, get the latest development version::\n\n    git clone https://github.com/earwig/mwparserfromhell.git\n    cd mwparserfromhell\n    python setup.py install\n\nthe comprehensive unit testing suite requires `pytest`_ (``pip install pytest``)\nand can be run with ``python -m pytest``.\n\nusage\n-----\n\nnormal usage is rather straightforward (where ``text`` is page text):\n\n>>> import mwparserfromhell\n>>> wikicode = mwparserfromhell.parse(text)\n\n``wikicode`` is a ``mwparserfromhell.wikicode`` object, which acts like an\nordinary ``str`` object with some extra methods. for example:\n\n>>> text = \"i has a template! {{foo|bar|baz|eggs=spam}} see it?\"\n>>> wikicode = mwparserfromhell.parse(text)\n>>> print(wikicode)\ni has a template! {{foo|bar|baz|eggs=spam}} see it?\n>>> templates = wikicode.filter_templates()\n>>> print(templates)\n['{{foo|bar|baz|eggs=spam}}']\n>>> template = templates[0]\n>>> print(template.name)\nfoo\n>>> print(template.params)\n['bar', 'baz', 'eggs=spam']\n>>> print(template.get(1).value)\nbar\n>>> print(template.get(\"eggs\").value)\nspam\n\nsince nodes can contain other nodes, getting nested templates is trivial:\n\n>>> text = \"{{foo|{{bar}}={{baz|{{spam}}}}}}\"\n>>> mwparserfromhell.parse(text).filter_templates()\n['{{foo|{{bar}}={{baz|{{spam}}}}}}', '{{bar}}', '{{baz|{{spam}}}}', '{{spam}}']\n\nyou can also pass ``recursive=false`` to ``filter_templates()`` and explore\ntemplates manually. this is possible because nodes can contain additional\n``wikicode`` objects:\n\n>>> code = mwparserfromhell.parse(\"{{foo|this {{includes a|template}}}}\")\n>>> print(code.filter_templates(recursive=false))\n['{{foo|this {{includes a|template}}}}']\n>>> foo = code.filter_templates(recursive=false)[0]\n>>> print(foo.get(1).value)\nthis {{includes a|template}}\n>>> print(foo.get(1).value.filter_templates()[0])\n{{includes a|template}}\n>>> print(foo.get(1).value.filter_templates()[0].get(1).value)\ntemplate\n\ntemplates can be easily modified to add, remove, or alter params. ``wikicode``\nobjects can be treated like lists, with ``append()``, ``insert()``,\n``remove()``, ``replace()``, and more. they also have a ``matches()`` method\nfor comparing page or template names, which takes care of capitalization and\nwhitespace:\n\n>>> text = \"{{cleanup}} '''foo''' is a [[bar]]. {{uncategorized}}\"\n>>> code = mwparserfromhell.parse(text)\n>>> for template in code.filter_templates():\n...     if template.name.matches(\"cleanup\") and not template.has(\"date\"):\n...         template.add(\"date\", \"july 2012\")\n...\n>>> print(code)\n{{cleanup|date=july 2012}} '''foo''' is a [[bar]]. {{uncategorized}}\n>>> code.replace(\"{{uncategorized}}\", \"{{bar-stub}}\")\n>>> print(code)\n{{cleanup|date=july 2012}} '''foo''' is a [[bar]]. {{bar-stub}}\n>>> print(code.filter_templates())\n['{{cleanup|date=july 2012}}', '{{bar-stub}}']\n\nyou can then convert ``code`` back into a regular ``str`` object (for\nsaving the page!) by calling ``str()`` on it:\n\n>>> text = str(code)\n>>> print(text)\n{{cleanup|date=july 2012}} '''foo''' is a [[bar]]. {{bar-stub}}\n>>> text == code\ntrue\n\nlimitations\n-----------\n\nwhile the mediawiki parser generates html and has access to the contents of\ntemplates, among other things, mwparserfromhell acts as a direct interface to\nthe source code only. this has several implications:\n\n* syntax elements produced by a template transclusion cannot be detected. for\n  example, imagine a hypothetical page ``\"template:end-bold\"`` that contained\n  the text ``</b>``. while mediawiki would correctly understand that\n  ``<b>foobar{{end-bold}}`` translates to ``<b>foobar</b>``, mwparserfromhell\n  has no way of examining the contents of ``{{end-bold}}``. instead, it would\n  treat the bold tag as unfinished, possibly extending further down the page.\n\n* templates adjacent to external links, as in ``http://example.com{{foo}}``,\n  are considered part of the link. in reality, this would depend on the\n  contents of the template.\n\n* when different syntax elements cross over each other, as in\n  ``{{echo|''hello}}, world!''``, the parser gets confused because this cannot\n  be represented by an ordinary syntax tree. instead, the parser will treat the\n  first syntax construct as plain text. in this case, only the italic tag would\n  be properly parsed.\n\n  **workaround:** since this commonly occurs with text formatting and text\n  formatting is often not of interest to users, you may pass\n  *skip_style_tags=true* to ``mwparserfromhell.parse()``. this treats ``''``\n  and ``'''`` as plain text.\n\n  a future version of mwparserfromhell may include multiple parsing modes to\n  get around this restriction more sensibly.\n\nadditionally, the parser lacks awareness of certain wiki-specific settings:\n\n* `word-ending links`_ are not supported, since the linktrail rules are\n  language-specific.\n\n* localized namespace names aren't recognized, so file links (such as\n  ``[[file:...]]``) are treated as regular wikilinks.\n\n* anything that looks like an xml tag is treated as a tag, even if it is not a\n  recognized tag name, since the list of valid tags depends on loaded mediawiki\n  extensions.\n\nintegration\n-----------\n\n``mwparserfromhell`` is used by and originally developed for earwigbot_;\n``page`` objects have a ``parse`` method that essentially calls\n``mwparserfromhell.parse()`` on ``page.get()``.\n\nif you're using pywikibot_, your code might look like this:\n\n.. code-block:: python\n\n    import mwparserfromhell\n    import pywikibot\n\n    def parse(title):\n        site = pywikibot.site()\n        page = pywikibot.page(site, title)\n        text = page.get()\n        return mwparserfromhell.parse(text)\n\nif you're not using a library, you can parse any page with the following\npython 3 code (using the api_ and the requests_ library):\n\n.. code-block:: python\n\n    import mwparserfromhell\n    import requests\n\n    api_url = \"https://en.wikipedia.org/w/api.php\"\n\n    def parse(title):\n        params = {\n            \"action\": \"query\",\n            \"prop\": \"revisions\",\n            \"rvprop\": \"content\",\n            \"rvslots\": \"main\",\n            \"rvlimit\": 1,\n            \"titles\": title,\n            \"format\": \"json\",\n            \"formatversion\": \"2\",\n        }\n        headers = {\"user-agent\": \"my-bot-name/1.0\"}\n        req = requests.get(api_url, headers=headers, params=params)\n        res = req.json()\n        revision = res[\"query\"][\"pages\"][0][\"revisions\"][0]\n        text = revision[\"slots\"][\"main\"][\"content\"]\n        return mwparserfromhell.parse(text)\n\n.. _mediawiki:              https://www.mediawiki.org\n.. _readthedocs:            https://mwparserfromhell.readthedocs.io\n.. _earwig:                 https://en.wikipedia.org/wiki/user:the_earwig\n.. _\u03c3:                      https://en.wikipedia.org/wiki/user:%ce%a3\n.. _legoktm:                https://en.wikipedia.org/wiki/user:legoktm\n.. _github:                 https://github.com/earwig/mwparserfromhell\n.. _python package index:   https://pypi.org/\n.. _get pip:                https://pypi.org/project/pip/\n.. _pytest:                 https://docs.pytest.org/\n.. _word-ending links:      https://www.mediawiki.org/wiki/help:links#linktrail\n.. _earwigbot:              https://github.com/earwig/earwigbot\n.. _pywikibot:              https://www.mediawiki.org/wiki/manual:pywikibot\n.. _api:                    https://www.mediawiki.org/wiki/api:main_page\n.. _requests:               https://2.python-requests.org\n",
  "docs_url": null,
  "keywords": "earwig mwparserfromhell wikipedia wiki mediawiki wikicode template parsing",
  "license": "mit license",
  "name": "mwparserfromhell",
  "package_url": "https://pypi.org/project/mwparserfromhell/",
  "project_url": "https://pypi.org/project/mwparserfromhell/",
  "project_urls": {
    "Download": "https://github.com/earwig/mwparserfromhell/tarball/v0.6.5",
    "Homepage": "https://github.com/earwig/mwparserfromhell"
  },
  "release_url": "https://pypi.org/project/mwparserfromhell/0.6.5/",
  "requires_dist": [],
  "requires_python": ">= 3.7",
  "summary": "mwparserfromhell is a parser for mediawiki wikicode.",
  "version": "0.6.5",
  "releases": [],
  "developers": [
    "ben.kurtovic@gmail.com",
    "ben_kurtovic"
  ],
  "kwds": "mediawiki pywikibot pywikibot_ _pywikibot mediawiki_",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_mwparserfromhell",
  "homepage": "https://github.com/earwig/mwparserfromhell",
  "release_count": 22,
  "dependency_ids": []
}