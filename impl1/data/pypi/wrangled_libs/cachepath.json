{
  "classifiers": [
    "development status :: 2 - pre-alpha",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7"
  ],
  "description": "welcome to cachepath's documentation!\n======================================\n\n.. image:: https://img.shields.io/pypi/v/cachepath.svg\n        :target: https://pypi.python.org/pypi/cachepath\n\n.. image:: https://img.shields.io/travis/haydenflinner/cachepath.svg\n        :target: https://travis-ci.org/haydenflinner/cachepath\n\n.. image:: https://readthedocs.org/projects/cachepath/badge/?version=latest\n        :target: https://cachepath.readthedocs.io/en/latest/?badge=latest\n        :alt: documentation status\n\na small package for pythonic parameterized cache paths.\n\ngetting started\n----------------\n\n**install:** ``pip install cachepath``\n\n**import:** ``from cachepath import cachepath, temppath, path``\n\n**docs:** `readthedocs`_ | `api doc is here`_\n\n**why?**\n    1. integrates ``pathlib`` with ``tempfile.gettempdir`` and ``shutil.rmtree`` by providing ``temppath`` and ``path.rm()``::\n\n          path = temppath()\n          path.rm()\n          # or would you rather..\n          path = none\n          with tempfile.namedtemporaryfile(delete=false) as f:\n              path = path(f.name)\n          # only now can we use path. if we tried using it within the with\n          # (for example for path.read_text()), we'd break on windows\n          path.unlink()  # only if file, doesn't work on folders\n\n    2. wraps ``pathlib`` import for py2/3 compat. (not in ``six``!)::\n\n          from cachepath import path\n          # or\n          try: from pathlib import path; except importerror: from pathlib2 import path\n\n    3. provides `cachepath`_, which lets you quickly get a parameterized temp filename, with all folders automatically created::\n\n          r = cachepath(date, userid, 'expensive_results.txt')\n          assert (r == path('/tmp/', date, userid, 'expensive_results.txt')\n                  and r.parent.exists())\n          r.rm()  # file remove\n          r.parent.rm()  # symmetric with folder remove!\n\n          # without cachepath\n          p = path(tempfile.gettempdir(), date, userid, 'expensive_results.txt').\n          # don't update timestamp if it already exists so that we don't cause\n          # make-like tools to always think something's changed\n          if not p.parent.exists():\n              p.parent.mkdir(parents=true, exist_ok=true)\n\n          p.unlink()  # why is it .unlink() instead of .remove()?\n          # why .remove and .unlink, but mkdir instead of createdir?\n          p.parent.remove()\n          # .remove() might throw because there was another file in the folder,\n          # but we didn't care, they're tempfiles!\n          import shutil\n          shutil.rmtree(p.parent)\n\n**why, but longer:**\n\ndo you need a temp path to pass to some random tool for its logfile?\nbehold, a gaping hole in ``pathlib``::\n\n    import tempfile\n    import os\n    try: from pathlib import path; except importerror: from pathlib2 import path\n    def get_tempfile():\n        fd, loc = tempfile.mkstemp()\n        os.close(fd)  # if we forgot do this, it would stay open until process exit\n        return path(loc)\n\n    # easier way\n    from cachepath import temppath\n    def get_tempfile():\n        return temppath()  # path('/tmp/213kjdsrandom')\n\n\nbut this module is called cachepath, not temppath, what gives?\n\nsuppose i'm running that same imaginary tool pretty often, but i'd like to skip running\nit if i already have results for a certain day. just sticking some identifying info into a filename\nshould be good enough.\nsomething like ``path('/tmp/20181204_toolresults.txt')`` ::\n\n    # try: from pathlib import path; except importerror: from pathlib2 import path\n    # we'll cheat a little to get py2/3 compat without so much ugliness\n    from cachepath import path\n    import tempfile\n    def get_tempfile(date):\n        filename = '{}_toolresults.txt'.format(date)\n        return path(tempfile.gettempdir(), filename)\n\n    # easier to do this...\n    from cachepath import cachepath\n    def get_tempfile(date):\n        return cachepath(date, suffix='.txt')\n\nnot bad, but not great. but our requirements changed, let's go a step further.\n\nnow i'm running this tool *a lot*, over a tree of data that looks\nlike this::\n\n    2018-12-23\n        person1\n        person2\n    2018-12-24\n        person1\n    2018-12-25\n        person1\n\ni want my logs to be structured the same way.  how hard can it be? ::\n\n    2018-12-23/\n        person1_output.txt\n        person2_output.txt\n    2018-12-24/\n        person1_output.txt\n    2018-12-25/\n        person1_output.txt\n\nlet's find out::\n\n    # let's get the easy way out of the way first :)\n    def get_path(date, person):\n        return cachepath(date, person, suffix='_output.txt')\n        # automatically ensures /tmp/date/ exists when we create the cachepath!\n\n    # now the hard way\n    def get_path(date, person):\n        personfilename = '{p}_output.txt'.format(p=person)\n        returning = path(tempfile.gettempdir())/date/personfilename\n        # does this mkdir update the modified timestamp of the folders we're in?\n        # might matter if we're part of a larger toolset...\n        returning.parent.mkdir(exist_ok=true, parents=true)\n        return returning\n\nsuppose we hadn't remembered to make the ``$date/`` folders. when we passed the\npath out to another tool, or tried to .open it,\nwe may have gotten a permission denied\nerror on unix systems rather than the \"file/folder not found\" you might expect.\nwith cachepath, this can't happen. creating a cachepath implicitly creates all\nof the preceding directories necessary for your file to exist.\n\nnow, suppose we found a bug in this external tool we were using and we're going\nto re-run it for a day.\nhow do we clear out that day's results so that we can be sure we're looking\nat fresh output from the tool? well, with cachepath, it's just::\n\n  def easy_clear_date(date):\n      cachepath(date).clear()  # rm -r /tmp/date/*\n\nbut if you don't have cachepath, you'll find that most python libs play it\npretty safe when it comes to files. path.remove() requires the folder to be empty,\nand doesn't provide a way to empty the folder. not to mention, what if our results\nfolders had special permissions, or was actually a symlink, and we had write access\nbut not delete? oh well,\nlet's see what we can do::\n\n  def hard_clear_date(date):\n      # we happen to know that date is a folder and not a file (at least in our\n      # current design), so we know we need some form of .remove() rather than\n      # .unlink(). unfortunately, pathlib doesn't offer one for folders with\n      # files still in them. if you google how to do it, you will find plenty of\n      # answers, one of which is a pure pathlib recursive solution! but we're lazy,\n      # so lets bring in yet another module:\n      p = path(tempfile.gettempdir(), date)\n      import shutil\n      if p.exists():\n          shutil.rmtree(p)\n      p.mkdir(exist_ok=true, parents=true)\n      # this still isn't exactly equivalent to cachepath.clear(), because we've\n      # lost whatever permissions were set on the date folder, and if it were\n      # actually a symlink to somewhere else, that's gone now.\n\nconvinced yet? ``pip install cachepath`` or copy `the source`_ into your local\n``utils.py`` (you know you have one.)\n\n`api doc is here`_.\n\n\nby the way, as a side effect of importing ``cachepath``, all paths get the ability\nto do ``rm()`` and ``clear()``.\n\n\nshameless promo\n----------------\nfind yourself working with paths a lot in cmd-line tools? you might like\n`invoke`_ and/or `magicinvoke`_!\n\n\n\n.. [*] the source for cachepath can be downloaded from the `github repo`_.\n\n.. _github repo: https://github.com/haydenflinner/cachepath\n.. [*] this package was created with cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _`the source`: https://github.com/haydenflinner/cachepath/blob/master/cachepath/__init__.py\n.. _cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n.. _`invoke`: https://www.pyinvoke.org\n.. _`magicinvoke`: https://magicinvoke.readthedocs.io/en/latest/\n.. _`readthedocs`: https://cachepath.readthedocs.io/en/latest/\n.. _`api doc is here`: https://cachepath.readthedocs.io/en/latest/cachepath.html\n.. _`cachepath`: https://cachepath.readthedocs.io/en/latest/cachepath.html#cachepath.cachepath\n\n\n=======\nhistory\n=======\n\n1.0.0 (2018-12-08)\n------------------\n\n* big doc updates. 1.0.0 to symbolize semver adherence.\n\n0.1.0 (2018-12-08)\n------------------\n\n* first release on pypi. adds cachepath, temppath, path.\n\n\n",
  "docs_url": null,
  "keywords": "cachepath,paths,pathlib,cache,temp",
  "license": "mit license",
  "name": "cachepath",
  "package_url": "https://pypi.org/project/cachepath/",
  "project_url": "https://pypi.org/project/cachepath/",
  "project_urls": {
    "Homepage": "https://github.com/haydenflinner/cachepath"
  },
  "release_url": "https://pypi.org/project/cachepath/1.1.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "pythonic parameterized cache paths.",
  "version": "1.1.1",
  "releases": [],
  "developers": [
    "hayden@flinner.me",
    "hayden_flinner"
  ],
  "kwds": "cachepath pathlib2 pathlib temppath path",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_cachepath",
  "homepage": "https://github.com/haydenflinner/cachepath",
  "release_count": 5,
  "dependency_ids": []
}