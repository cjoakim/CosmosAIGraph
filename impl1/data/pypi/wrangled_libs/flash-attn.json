{
  "classifiers": [
    "license :: osi approved :: bsd license",
    "operating system :: unix",
    "programming language :: python :: 3"
  ],
  "description": "# flashattention\nthis repository provides the official implementation of flashattention and\nflashattention-2 from the\nfollowing papers.\n\n**flashattention: fast and memory-efficient exact attention with io-awareness**  \ntri dao, daniel y. fu, stefano ermon, atri rudra, christopher r\u00e9  \npaper: https://arxiv.org/abs/2205.14135  \nieee spectrum [article](https://spectrum.ieee.org/mlperf-rankings-2022) about our submission to the mlperf 2.0 benchmark using flashattention.\n![flashattention](assets/flashattn_banner.jpg)\n\n**flashattention-2: faster attention with better parallelism and work partitioning**  \ntri dao\n\npaper: https://tridao.me/publications/flash2/flash2.pdf\n\n![flashattention-2](assets/flashattention_logo.png)\n\n\n## usage\n\nwe've been very happy to see flashattention being widely adopted in such a short\ntime after its release. this [page](https://github.com/dao-ailab/flash-attention/blob/main/usage.md)\ncontains a partial list of places where flashattention is being used.\n\nflashattention and flashattention-2 are free to use and modify (see license).\nplease cite and credit flashattention if you use it.\n\n## installation and features\n\nrequirements:\n- cuda 11.6 and above.\n- pytorch 1.12 and above.\n- linux. might work for windows starting v2.3.2 (we've seen a few positive [reports](https://github.com/dao-ailab/flash-attention/issues/595)) but windows compilation still requires more testing. if you have ideas on how to set up prebuilt cuda wheels for windows, please reach out via github issue.\n\nwe recommend the\n[pytorch](https://catalog.ngc.nvidia.com/orgs/nvidia/containers/pytorch)\ncontainer from nvidia, which has all the required tools to install flashattention.\n\nto install:\n1. make sure that pytorch is installed.\n2. make sure that `packaging` is installed (`pip install packaging`)\n3. make sure that `ninja` is installed and that it works correctly (e.g. `ninja\n--version` then `echo $?` should return exit code 0). if not (sometimes `ninja\n--version` then `echo $?` returns a nonzero exit code), uninstall then reinstall\n`ninja` (`pip uninstall -y ninja && pip install ninja`). without `ninja`,\ncompiling can take a very long time (2h) since it does not use multiple cpu\ncores. with `ninja` compiling takes 3-5 minutes on a 64-core machine.\n4. then:\n```sh\npip install flash-attn --no-build-isolation\n```\nalternatively you can compile from source:\n```sh\npython setup.py install\n```\n\nif your machine has less than 96gb of ram and lots of cpu cores, `ninja` might\nrun too many parallel compilation jobs that could exhaust the amount of ram. to\nlimit the number of parallel compilation jobs, you can set the environment\nvariable `max_jobs`:\n```sh\nmax_jobs=4 pip install flash-attn --no-build-isolation\n```\n\ninterface: `src/flash_attention_interface.py`\n\nflashattention-2 currently supports:\n1. ampere, ada, or hopper gpus (e.g., a100, rtx 3090, rtx 4090, h100). support for turing\n   gpus (t4, rtx 2080) is coming soon, please use flashattention 1.x for turing\n   gpus for now.\n2. datatype fp16 and bf16 (bf16 requires ampere, ada, or hopper gpus).\n3. all head dimensions up to 256. head dim > 192 backward requires a100/a800 or h100/h800.\n\n\n## how to use flashattention\n\nthe main functions implement scaled dot product attention (softmax(q @ k^t *\nsoftmax_scale) @ v):\n```python\nfrom flash_attn import flash_attn_qkvpacked_func, flash_attn_func\n```\n\n```python\nflash_attn_qkvpacked_func(qkv, dropout_p=0.0, softmax_scale=none, causal=false,\n                          window_size=(-1, -1), alibi_slopes=none, deterministic=false):\n\"\"\"dropout_p should be set to 0.0 during evaluation\nif q, k, v are already stacked into 1 tensor, this function will be faster than\ncalling flash_attn_func on q, k, v since the backward pass avoids explicit concatenation\nof the gradients of q, k, v.\nif window_size != (-1, -1), implements sliding window local attention. query at position i\nwill only attend to keys between [i - window_size[0], i + window_size[1]] inclusive.\narguments:\n    qkv: (batch_size, seqlen, 3, nheads, headdim)\n    dropout_p: float. dropout probability.\n    softmax_scale: float. the scaling of qk^t before applying softmax.\n        default to 1 / sqrt(headdim).\n    causal: bool. whether to apply causal attention mask (e.g., for auto-regressive modeling).\n    window_size: (left, right). if not (-1, -1), implements sliding window local attention.\n    alibi_slopes: (nheads,) or (batch_size, nheads), fp32. a bias of (-alibi_slope * |i - j|) is added to\n        the attention score of query i and key j.\n    deterministic: bool. whether to use the deterministic implementation of the backward pass,\n        which is slightly slower and uses more memory. the forward pass is always deterministic.\nreturn:\n    out: (batch_size, seqlen, nheads, headdim).\n\"\"\"\n```\n\n```python\nflash_attn_func(q, k, v, dropout_p=0.0, softmax_scale=none, causal=false,\n                window_size=(-1, -1), alibi_slopes=none, deterministic=false):\n\"\"\"dropout_p should be set to 0.0 during evaluation\nsupports multi-query and grouped-query attention (mqa/gqa) by passing in kv with fewer heads\nthan q. note that the number of heads in q must be divisible by the number of heads in kv.\nfor example, if q has 6 heads and k, v have 2 heads, head 0, 1, 2 of q will attention to head\n0 of k, v, and head 3, 4, 5 of q will attention to head 1 of k, v.\nif window_size != (-1, -1), implements sliding window local attention. query at position i\nwill only attend to keys between\n[i + seqlen_k - seqlen_q - window_size[0], i + seqlen_k - seqlen_q + window_size[1]] inclusive.\n\narguments:\n    q: (batch_size, seqlen, nheads, headdim)\n    k: (batch_size, seqlen, nheads_k, headdim)\n    v: (batch_size, seqlen, nheads_k, headdim)\n    dropout_p: float. dropout probability.\n    softmax_scale: float. the scaling of qk^t before applying softmax.\n        default to 1 / sqrt(headdim).\n    causal: bool. whether to apply causal attention mask (e.g., for auto-regressive modeling).\n    window_size: (left, right). if not (-1, -1), implements sliding window local attention.\n    alibi_slopes: (nheads,) or (batch_size, nheads), fp32. a bias of\n        (-alibi_slope * |i + seqlen_k - seqlen_q - j|)\n        is added to the attention score of query i and key j.\n    deterministic: bool. whether to use the deterministic implementation of the backward pass,\n        which is slightly slower and uses more memory. the forward pass is always deterministic.\nreturn:\n    out: (batch_size, seqlen, nheads, headdim).\n\"\"\"\n```\n\n```python\ndef flash_attn_with_kvcache(\n    q,\n    k_cache,\n    v_cache,\n    k=none,\n    v=none,\n    rotary_cos=none,\n    rotary_sin=none,\n    cache_seqlens: optional[union[(int, torch.tensor)]] = none,\n    cache_batch_idx: optional[torch.tensor] = none,\n    softmax_scale=none,\n    causal=false,\n    window_size=(-1, -1),  # -1 means infinite context window\n    rotary_interleaved=true,\n    alibi_slopes=none,\n):\n    \"\"\"\n    if k and v are not none, k_cache and v_cache will be updated *inplace* with the new values from\n    k and v. this is useful for incremental decoding: you can pass in the cached keys/values from\n    the previous step, and update them with the new keys/values from the current step, and do\n    attention with the updated cache, all in 1 kernel.\n\n    also apply rotary embedding if rotary_cos and rotary_sin are passed in. the key @k will be\n    rotated by rotary_cos and rotary_sin at indices cache_seqlens, cache_seqlens + 1, etc.\n    if causal or local (i.e., window_size != (-1, -1)), the query @q will be rotated by rotary_cos\n    and rotary_sin at indices cache_seqlens, cache_seqlens + 1, etc.\n    if not causal and not local, the query @q will be rotated by rotary_cos and rotary_sin at\n    indices cache_seqlens only (i.e. we consider all tokens in @q to be at position cache_seqlens).\n\n    see tests/test_flash_attn.py::test_flash_attn_kvcache for examples of how to use this function.\n\n    note: does not support backward pass.\n\n    arguments:\n        q: (batch_size, seqlen, nheads, headdim)\n        k_cache: (batch_size_cache, seqlen_cache, nheads_k, headdim)\n        v_cache: (batch_size_cache, seqlen_cache, nheads_k, headdim)\n        k [optional]: (batch_size, seqlen_new, nheads_k, headdim). if not none, we concatenate\n            k with k_cache, starting at the indices specified by cache_seqlens.\n        v [optional]: (batch_size, seqlen_new, nheads_k, headdim). similar to k.\n        rotary_cos [optional]: (seqlen_ro, rotary_dim / 2). if not none, we apply rotary embedding\n            to k and q. only applicable if k and v are passed in. rotary_dim must be divisible by 16.\n        rotary_sin [optional]: (seqlen_ro, rotary_dim / 2). similar to rotary_cos.\n        cache_seqlens: int, or (batch_size,), dtype torch.int32. the sequence lengths of the\n            kv cache.\n        cache_batch_idx: (batch_size,), dtype torch.int32. the indices used to index into the kv cache.\n            if none, we assume that the batch indices are [0, 1, 2, ..., batch_size - 1].\n            if the indices are not distinct, and k and v are provided, the values updated in the cache\n                 might come from any of the duplicate indices.\n        softmax_scale: float. the scaling of qk^t before applying softmax.\n            default to 1 / sqrt(headdim).\n        causal: bool. whether to apply causal attention mask (e.g., for auto-regressive modeling).\n        window_size: (left, right). if not (-1, -1), implements sliding window local attention.\n        rotary_interleaved: bool. only applicable if rotary_cos and rotary_sin are passed in.\n            if true, rotary embedding will combine dimensions 0 & 1, 2 & 3, etc. if false,\n            rotary embedding will combine dimensions 0 & rotary_dim / 2, 1 & rotary_dim / 2 + 1\n            (i.e. gpt-neox style).\n        alibi_slopes: (nheads,) or (batch_size, nheads), fp32. a bias of\n            (-alibi_slope * |i + seqlen_k - seqlen_q - j|)\n            is added to the attention score of query i and key j.\n\n    return:\n        out: (batch_size, seqlen, nheads, headdim).\n    \"\"\"\n```\n\nto see how these functions are used in a multi-head attention layer (which\nincludes qkv projection, output projection), see the mha [implementation](https://github.com/dao-ailab/flash-attention/blob/main/flash_attn/modules/mha.py).\n\n## changelog\n\n### 2.0: complete rewrite, 2x faster\nupgrading from flashattention (1.x) to flashattention-2\n\nthese functions have been renamed:\n- `flash_attn_unpadded_func` -> `flash_attn_varlen_func`\n- `flash_attn_unpadded_qkvpacked_func` -> `flash_attn_varlen_qkvpacked_func`\n- `flash_attn_unpadded_kvpacked_func` -> `flash_attn_varlen_kvpacked_func`\n\nif the inputs have the same sequence lengths in the same batch, it is simpler\nand faster to use these functions:\n```python\nflash_attn_qkvpacked_func(qkv, dropout_p=0.0, softmax_scale=none, causal=false)\n```\n```python\nflash_attn_func(q, k, v, dropout_p=0.0, softmax_scale=none, causal=false)\n```\n### 2.1: change behavior of causal flag\n\nif seqlen_q != seqlen_k and causal=true, the causal mask is aligned to the\nbottom right corner of the attention matrix, instead of the top-left corner.\n\nfor example, if seqlen_q = 2 and seqlen_k = 5, the causal mask (1 = keep, 0 =\nmasked out) is:  \nv2.0:  \n    1 0 0 0 0  \n    1 1 0 0 0  \nv2.1:  \n    1 1 1 1 0  \n    1 1 1 1 1  \n\nif seqlen_q = 5 and seqlen_k = 2, the causal mask is:  \nv2.0:  \n    1 0  \n    1 1  \n    1 1  \n    1 1  \n    1 1  \nv2.1:  \n    0 0  \n    0 0  \n    0 0  \n    1 0  \n    1 1  \nif the row of the mask is all zero, the output will be zero.\n\n### 2.2: optimize for inference\n\noptimize for inference (iterative decoding) when query has very small sequence\nlength (e.g., query sequence length = 1). the bottleneck here is to load kv\ncache as fast as possible, and we split the loading across different thread\nblocks, with a separate kernel to combine results.\n\nsee the function `flash_attn_with_kvcache` with more features for inference\n(perform rotary embedding, updating kv cache inplace).\n\nthanks to the xformers team, and in particular daniel haziza, for this\ncollaboration.\n\n### 2.3: local (i.e., sliding window) attention\n\nimplement sliding window attention (i.e., local attention). thanks to [mistral\nai](https://mistral.ai/) and in particular timoth\u00e9e lacroix for this\ncontribution. sliding window was used in the [mistral 7b](https://mistral.ai/news/announcing-mistral-7b/) model.\n\n### 2.4: alibi (attention with linear bias), deterministic backward pass.\n\nimplement alibi (press et el., 2021). thanks to sanghun cho from kakao brain for this contribution.\n\nimplement deterministic backward pass. thanks to engineers from [meituan](www.meituan.com) for this contribution.\n\n## performance\n\nwe present expected speedup (combined forward + backward pass) and memory savings from using flashattention against pytorch standard attention, depending on sequence length, on different gpus (speedup depends on memory bandwidth - we see more speedup on slower gpu memory).\n\nwe currently have benchmarks for these gpus:\n* [a100](#a100)\n* [h100](#h100)\n<!-- * [rtx 3090](#rtx-3090) -->\n<!-- * [t4](#t4) -->\n\n### a100\n\nwe display flashattention speedup using these parameters:\n* head dimension 64 or 128, hidden dimension 2048 (i.e. either 32 or 16 heads).\n* sequence length 512, 1k, 2k, 4k, 8k, 16k.\n* batch size set to 16k / seqlen.\n\n#### speedup\n\n![flashattention speedup on a100 80gb sxm5 with fp16/bf16](assets/flash2_a100_fwd_bwd_benchmark.png)\n\n#### memory\n\n![flashattention memory](assets/flashattn_memory.jpg)\n\nwe show memory savings in this graph (note that memory footprint is the same no matter if you use dropout or masking).\nmemory savings are proportional to sequence length -- since standard attention has memory quadratic in sequence length, whereas flashattention has memory linear in sequence length.\nwe see 10x memory savings at sequence length 2k, and 20x at 4k.\nas a result, flashattention can scale to much longer sequence lengths.\n\n### h100\n\n![flashattention speedup on h100 sxm5 with fp16/bf16](assets/flash2_h100_fwd_bwd_benchmark.png)\n\n## full model code and training script\n\nwe have released the full gpt model\n[implementation](https://github.com/dao-ailab/flash-attention/blob/main/flash_attn/models/gpt.py).\nwe also provide optimized implementations of other layers (e.g., mlp, layernorm,\ncross-entropy loss, rotary embedding). overall this speeds up training by 3-5x\ncompared to the baseline implementation from huggingface, reaching up to 225\ntflops/sec per a100, equivalent to 72% model flops utilization (we don't need\nany activation checkpointing).\n\nwe also include a training\n[script](https://github.com/dao-ailab/flash-attention/tree/main/training) to\ntrain gpt2 on openwebtext and gpt3 on the pile.\n\n## triton implementation of flashattention\n\nphil tillet (openai) has an experimental implementation of flashattention in triton:\nhttps://github.com/openai/triton/blob/master/python/tutorials/06-fused-attention.py\n\nas triton is a higher-level language than cuda, it might be easier to understand\nand experiment with. the notations in the triton implementation are also closer\nto what's used in our paper.\n\nwe also have an experimental implementation in triton that support attention\nbias (e.g. alibi):\nhttps://github.com/dao-ailab/flash-attention/blob/main/flash_attn/flash_attn_triton.py\n\n\n## tests\nwe test that flashattention produces the same output and gradient as a reference\nimplementation, up to some numerical tolerance. in particular, we check that the\nmaximum numerical error of flashattention is at most twice the numerical error\nof a baseline implementation in pytorch (for different head dimensions, input\ndtype, sequence length, causal / non-causal).\n\nto run the tests:\n```sh\npytest -q -s tests/test_flash_attn.py\n```\n## when you encounter issues\n\nthis new release of flashattention-2 has been tested on several gpt-style\nmodels, mostly on a100 gpus.\n\nif you encounter bugs, please open a github issue!\n\n## citation\nif you use this codebase, or otherwise found our work valuable, please cite:\n```\n@inproceedings{dao2022flashattention,\n  title={flash{a}ttention: fast and memory-efficient exact attention with {io}-awareness},\n  author={dao, tri and fu, daniel y. and ermon, stefano and rudra, atri and r{\\'e}, christopher},\n  booktitle={advances in neural information processing systems},\n  year={2022}\n}\n@article{dao2023flashattention2,\n  title={flash{a}ttention-2: faster attention with better parallelism and work partitioning},\n  author={dao, tri},\n  year={2023}\n}\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "flash-attn",
  "package_url": "https://pypi.org/project/flash-attn/",
  "project_url": "https://pypi.org/project/flash-attn/",
  "project_urls": {
    "Homepage": "https://github.com/Dao-AILab/flash-attention"
  },
  "release_url": "https://pypi.org/project/flash-attn/2.4.1/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "flash attention: fast and memory-efficient exact attention",
  "version": "2.4.1",
  "releases": [],
  "developers": [
    "tri_dao",
    "trid@cs.stanford.edu"
  ],
  "kwds": "flashattention flash2_a100_fwd_bwd_benchmark flashattn_memory flash_attention_interface flash2_h100_fwd_bwd_benchmark",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_flash_attn",
  "homepage": "https://github.com/dao-ailab/flash-attention",
  "release_count": 50,
  "dependency_ids": []
}