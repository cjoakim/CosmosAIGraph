{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "license :: public domain",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: text processing :: markup :: html"
  ],
  "description": "# html5 generation with html5tagger: fast, pure python, no dependencies\n\nif you're looking for a more efficient and streamlined way to generate html5, look no further than html5tagger! this module provides a simplified html5 syntax, so you can create your entire document template using only python. say goodbye to the clunky and error-prone process of manually writing html tags.\n\nwith html5tagger, you can safely and quickly generate html5 without any dependencies, making it the perfect solution for developers who value speed and simplicity. and with its pure python implementation, you'll never have to worry about compatibility issues or adding extra libraries to your project.\n\nready to streamline your page rendering process? it is super fast to get started. trust us, once you try html5tagger, you'll never go back to jinja2 or manual html writing again!\n\n```sh\npip install html5tagger\n```\n\n## intro\n\nhtml5tagger provides two starting points for html generation: `e` as an empty builder for creating html snippets, or `document` for generating full html documents with a doctype declaration. both produce a `builder` object, in case you need that for type annotations.\n\ncreate a snippet and add tags by dot notation:\n```python\ne.p(\"powered by:\").br.a(href=\"...\")(\"html5tagger\")\n```\n```html\n<p>powered by:<br><a href=\"...\">html5tagger</a>\n```\n\na complete example with template variables and other features:\n\n```python\nfrom html5tagger import document, e\n\n# create a document\ndoc = document(\n    e.titletext_,           # the first argument is for <title>, adding variable titletext\n    lang=\"en\",              # keyword arguments for <html> attributes\n\n    # just list the resources you need, no need to remember link/script tags\n    _urls=[ \"style.css\", \"favicon.png\", \"manifest.json\" ]\n)\n\n# upper case names are template variables. you can modify them later.\ndoc.head_\ndoc.h1.titletext_(\"demo\")   # goes inside <h1> and updates <title> as well\n\n# this has been a hard problem for dom other such generators:\ndoc.p(\"a paragraph with \").a(\"a link\", href=\"/files\")(\" and \").em(\"formatting\")\n\n# use with for complex nesting (not often needed)\nwith doc.table(id=\"data\"):\n    doc.tr.th(\"first\").th(\"second\").th(\"third\")\n    doc.tablerows_\n\n# let's add something to the template variables\ndoc.head._script(\"console.log('</script> escaping is weird')\")\n\ntable = doc.tablerows\nfor row in range(10):\n    table.tr\n    for col in range(3):\n        table.td(row * col)\n\n# or remove the table data we just added\ndoc.tablerows = none\n```\n\nyou can `str(doc)` to get the html code, and using `doc` directly usually has the desired effect as well (e.g. giving html responses). jupyter notebooks render it as html. for debugging, use `repr(doc)` where the templating variables are visible:\n\n```html\n>>> doc\n\u300adocument builder\u300b\n<!doctype html><html lang=en><meta charset=\"utf-8\">\n<title>\u300atitletext:demo\u300b</title>\n<link href=\"style.css\" rel=stylesheet>\n<link href=\"favicon.png\" rel=icon type=\"image/png\">\n<link href=\"manifest.json\" rel=manifest>\n\u300ahead:<script>console.log('<\\/script> escaping is weird')</script>\u300b\n<h1>\u300atitletext:demo\u300b</h1>\n<p>a paragraph with <a href=\"/files\">a link</a> and <em>formatting</em>\n<table id=data>\n  <tr><th>first<th>second<th>third\n  \u300atablerows\u300b\n</table>\n```\n\nthe actual html output is similar. no whitespace is added to the document, it is all on one line unless the content contains newlines. you may notice that `body` and other familiar tags are missing and that the escaping is very minimal. this is html5: the document is standards-compliant with a lot less cruft.\n\n## templating\n\nuse template variables to build a document once and only update the dynamic parts at render time for faster performance. access template variables via doc.titletext and add content in parenthesis after the tag name. the underscore at the end of a tag name indicates the tag is added to the document and can have content in parenthesis, but any further tags on the same line go to the original document, not the template.\n\n## nesting\n\nin html5 elements such as `<p>` do not need any closing tag, so we can keep adding content without worrying of when it should close. this module does not use closing tags for any elements where those are optional or forbidden.\n\na tag is automatically closed when you add content to it or when another tag is added. setting attributes alone does not close an element. use `(none)` to close an empty element if any subsequent content is not meant to go inside it, e.g. `doc.script(none, src=\"...\")`.\n\nfor elements like `<table>` and `<ul>`, you can use `with` blocks, pass sub-snippet arguments, or add a template variable. unlike adding another tag, adding a template does not close its preceding tag but instead the variable goes inside any open element.\n\n```python\nwith doc.ul:  # nest using with\n    doc.li(\"write html in python\")\n    doc.li(\"simple syntax\").ul(id=\"inner\").innerlist_  # nest using template\n    doc.li(\"no need for brackets or closing tags\")\n    doc.ul(e.li(\"easy\").li(\"peasy\"))  # nest using (...)\n```\n\n## escaping\n\nall content and attributes are automatically escaped. for instance, we can put the entire document into an iframe's srcdoc attribute where only the minimal but necessary escaping is applied. use custom methods `_script`, `_style` and `_comment` for corresponding inline formats, to follow their custom escaping rules.\n\n```python\ndoc = document(\"escaping & context\")\ndoc._style('h1::after {content: \"</style>\"}').h1(\"<escape>\")\ndoc._comment(\"all-->ok\")\ndoc.iframe(srcdoc=document().p(\"&amp; is used for &\"))\n```\n\n```html\n<!doctype html><meta charset=\"utf-8\"><title>escaping &amp; context</title>\n<style>h1::after {content: \"<\\/style>\"}</style><h1>&lt;escape></h1>\n<!--all\u2012\u2012>ok-->\n<iframe srcdoc=\"<!doctype html><p>&amp;amp;amp; is used for &amp;amp;\"></iframe>\n```\n\nworks perfectly in browsers.\n\n## name mangling and boolean attributes\n\nunderscore at the end of name is ignored so that `class_` and `for_` among other attributes may be used despite being reserved words in python. other underscores convert into hyphens.\n\n\u26a0\ufe0f the above only is true for html elements and attributes, but template placeholders only use an ending underscore to denote that the it is to be placed on the document, rather than be fetched for use.\n\nboolean values convert into short attributes.\n\n```python\ne.input(type=\"checkbox\", id=\"somebox\", checked=true).label(for_=\"somebox\", aria_role=\"img\")(\"\ud83e\udd73\")\n```\n\n```html\n<input type=checkbox id=somebox checked><label for=somebox aria-role=img>\ud83e\udd73</label>\n```\n\n## preformatted html\n\nall content is automatically escaped, unless it provides an `__html__` method that returns a string in html format. similarly, the builder objects of this module expose `__html__` and `_repr_html_` accessors that allow them to be rendered as html in jupyter notebooks and various other systems that follow this convention.\n\nany preformatted html may be wrapped in `html5tagger.html(string_of_html)` to avoid it being escaped when included in a document, as the html class has those accessors.\n\n\u26a0\ufe0f do not use `html()` for text, in particular not on messages sent by users, that may contain html that you didn't intend to execute as html.\n\n## performance\n\n```python\n%timeit str(document(\"benchmarking\", lang=\"en\", _urls=(\"foo.js\", \"bar.js\")))\n14 \u00b5s \u00b1 153 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n```\n\njinja2 renders similar document from memory template within about 10 \u00b5s but it doesn't need to format any of the html. when templating is similarly used with html5tagger, the rendering times drop to about 4 \u00b5s.\n\nin the above benchmark html5tagger created the entire document from scratch, one element and attribute at a time. unless you are creating very large documents dynamically, this should be quite fast enough.\n\n\n## further development\n\nthere have been no changes to the tagging api since 2018 when this module was brought to production use, and thus the interface is considered stable.\n\nin 2023 support for templating was added, allowing documents to be preformatted for all their static parts (as long strings), with only templates filled in between. this is a work on progress and has not been optimized yet.\n\nadditionally, `_script` and `_style` special methods were added in 2023. these may eventually replace also the non-underscored automatic versions but for now a separate method was easier to implement.\n\npull requests are still welcome.\n",
  "docs_url": null,
  "keywords": "html,html5,templating,jinja2",
  "license": "",
  "name": "html5tagger",
  "package_url": "https://pypi.org/project/html5tagger/",
  "project_url": "https://pypi.org/project/html5tagger/",
  "project_urls": {
    "Homepage": "https://github.com/sanic-org/html5tagger"
  },
  "release_url": "https://pypi.org/project/html5tagger/1.3.0/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "pythonic html generation/templating (no template files)",
  "version": "1.3.0",
  "releases": [],
  "developers": [
    "sanic_community",
    "tronic@noreply.users.github.com"
  ],
  "kwds": "html5tagger html5 html string_of_html templating",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_html5tagger",
  "homepage": "https://github.com/sanic-org/html5tagger",
  "release_count": 7,
  "dependency_ids": []
}