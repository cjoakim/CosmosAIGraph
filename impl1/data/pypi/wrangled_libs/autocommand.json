{
  "classifiers": [
    "development status :: 6 - mature",
    "intended audience :: developers",
    "license :: osi approved :: gnu lesser general public license v3 (lgplv3)",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "topic :: software development",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "[![pypi version](https://badge.fury.io/py/autocommand.svg)](https://badge.fury.io/py/autocommand)\n\n# autocommand\n\na library to automatically generate and run simple argparse parsers from function signatures.\n\n## installation\n\nautocommand is installed via pip:\n\n```\n$ pip install autocommand\n```\n\n## usage\n\nautocommand turns a function into a command-line program. it converts the function's parameter signature into command-line arguments, and automatically runs the function if the module was called as `__main__`. in effect, it lets your create a smart main function.\n\n```python\nfrom autocommand import autocommand\n\n# this program takes exactly one argument and echos it.\n@autocommand(__name__)\ndef echo(thing):\n    print(thing)\n```\n\n```\n$ python echo.py hello\nhello\n$ python echo.py -h\nusage: echo [-h] thing\n\npositional arguments:\n  thing\n\noptional arguments:\n  -h, --help  show this help message and exit\n$ python echo.py hello world  # too many arguments\nusage: echo.py [-h] thing\necho.py: error: unrecognized arguments: world\n```\n\nas you can see, autocommand converts the signature of the function into an argument spec. when you run the file as a program, autocommand collects the command-line arguments and turns them into function arguments. the function is executed with these arguments, and then the program exits with the return value of the function, via `sys.exit`. autocommand also automatically creates a usage message, which can be invoked with `-h` or `--help`, and automatically prints an error message when provided with invalid arguments.\n\n### types\n\nyou can use a type annotation to give an argument a type. any type (or in fact any callable) that returns an object when given a string argument can be used, though there are a few special cases that are described later.\n\n```python\n@autocommand(__name__)\ndef net_client(host, port: int):\n    ...\n```\n\nautocommand will catch `typeerrors` raised by the type during argument parsing, so you can supply a callable and do some basic argument validation as well.\n\n### trailing arguments\n\nyou can add a `*args` parameter to your function to give it trailing arguments. the command will collect 0 or more trailing arguments and supply them to `args` as a tuple. if a type annotation is supplied, the type is applied to each argument.\n\n```python\n# write the contents of each file, one by one\n@autocommand(__name__)\ndef cat(*files):\n    for filename in files:\n        with open(filename) as file:\n            for line in file:\n                print(line.rstrip())\n```\n\n```\n$ python cat.py -h\nusage: ipython [-h] [file [file ...]]\n\npositional arguments:\n  file\n\noptional arguments:\n  -h, --help  show this help message and exit\n```\n\n### options\n\nto create `--option` switches, just assign a default. autocommand will automatically create `--long` and `-s`hort switches.\n\n```python\n@autocommand(__name__)\ndef do_with_config(argument, config='~/foo.conf'):\n    pass\n```\n\n```\n$ python example.py -h\nusage: example.py [-h] [-c config] argument\n\npositional arguments:\n  argument\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -c config, --config config\n```\n\nthe option's type is automatically deduced from the default, unless one is explicitly given in an annotation:\n\n```python\n@autocommand(__name__)\ndef http_connect(host, port=80):\n    print('{}:{}'.format(host, port))\n```\n\n```\n$ python http.py -h\nusage: http.py [-h] [-p port] host\n\npositional arguments:\n  host\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -p port, --port port\n$ python http.py localhost\nlocalhost:80\n$ python http.py localhost -p 8080\nlocalhost:8080\n$ python http.py localhost -p blah\nusage: http.py [-h] [-p port] host\nhttp.py: error: argument -p/--port: invalid int value: 'blah'\n```\n\n#### none\n\nif an option is given a default value of `none`, it reads in a value as normal, but supplies `none` if the option isn't provided.\n\n#### switches\n\nif an argument is given a default value of `true` or `false`, or\ngiven an explicit `bool` type, it becomes an option switch.\n\n```python\n    @autocommand(__name__)\n    def example(verbose=false, quiet=false):\n        pass\n```\n\n```\n$ python example.py -h\nusage: example.py [-h] [-v] [-q]\n\noptional arguments:\n  -h, --help     show this help message and exit\n  -v, --verbose\n  -q, --quiet\n```\n\nautocommand attempts to do the \"correct thing\" in these cases- if the default is `true`, then supplying the switch makes the argument `false`; if the type is `bool` and the default is some other `true` value, then supplying the switch makes the argument `false`, while not supplying the switch makes the argument the default value.\n\nautocommand also supports the creation of switch inverters. pass `add_nos=true` to `autocommand` to enable this.\n\n```\n    @autocommand(__name__, add_nos=true)\n    def example(verbose=false):\n        pass\n```\n\n```\n$ python example.py -h\nusage: ipython [-h] [-v] [--no-verbose]\n\noptional arguments:\n  -h, --help     show this help message and exit\n  -v, --verbose\n  --no-verbose\n```\n\nusing the `--no-` version of a switch will pass the opposite value in as a function argument. if multiple switches are present, the last one takes precedence.\n\n#### files\n\nif the default value is a file object, such as `sys.stdout`, then autocommand just looks for a string, for a file path. it doesn't do any special checking on the string, though (such as checking if the file exists); it's better to let the client decide how to handle errors in this case. instead, it provides a special context manager called `smart_open`, which behaves exactly like `open` if a filename or other openable type is provided, but also lets you use already open files:\n\n```python\nfrom autocommand import autocommand, smart_open\nimport sys\n\n# write the contents of stdin, or a file, to stdout\n@autocommand(__name__)\ndef write_out(infile=sys.stdin):\n    with smart_open(infile) as f:\n        for line in f:\n            print(line.rstrip())\n    # if a file was opened, it is closed here. if it was just stdin, it is untouched.\n```\n\n```\n$ echo \"hello world!\" | python write_out.py | tee hello.txt\nhello world!\n$ python write_out.py --infile hello.txt\nhello world!\n```\n\n### descriptions and docstrings\n\nthe `autocommand` decorator accepts `description` and `epilog` kwargs, corresponding to the `description <https://docs.python.org/3/library/argparse.html#description>`_ and `epilog <https://docs.python.org/3/library/argparse.html#epilog>`_ of the `argumentparser`. if no description is given, but the decorated function has a docstring, then it is taken as the `description` for the `argumentparser`. you can also provide both the description and epilog in the docstring by splitting it into two sections with 4 or more - characters.\n\n```python\n@autocommand(__name__)\ndef copy(infile=sys.stdin, outfile=sys.stdout):\n    '''\n    copy an the contents of a file (or stdin) to another file (or stdout)\n    ----------\n    some extra documentation in the epilog\n    '''\n    with smart_open(infile) as istr:\n        with smart_open(outfile, 'w') as ostr:\n            for line in istr:\n                ostr.write(line)\n```\n\n```\n$ python copy.py -h\nusage: copy.py [-h] [-i infile] [-o outfile]\n\ncopy an the contents of a file (or stdin) to another file (or stdout)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i infile, --infile infile\n  -o outfile, --outfile outfile\n\nsome extra documentation in the epilog\n$ echo \"hello world\" | python copy.py --outfile hello.txt\n$ python copy.py --infile hello.txt --outfile hello2.txt\n$ python copy.py --infile hello2.txt\nhello world\n```\n\n### parameter descriptions\n\nyou can also attach description text to individual parameters in the annotation. to attach both a type and a description, supply them both in any order in a tuple\n\n```python\n@autocommand(__name__)\ndef copy_net(\n    infile: 'the name of the file to send',\n    host: 'the host to send the file to',\n    port: (int, 'the port to connect to')):\n\n    '''\n    copy a file over raw tcp to a remote destination.\n    '''\n    # left as an exercise to the reader\n```\n\n### decorators and wrappers\n\nautocommand automatically follows wrapper chains created by `@functools.wraps`. this means that you can apply other wrapping decorators to your main function, and autocommand will still correctly detect the signature.\n\n```python\nfrom functools import wraps\nfrom autocommand import autocommand\n\ndef print_yielded(func):\n    '''\n    convert a generator into a function that prints all yielded elements\n    '''\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        for thing in func(*args, **kwargs):\n            print(thing)\n    return wrapper\n\n@autocommand(__name__,\n    description= 'print all the values from start to stop, inclusive, in steps of step',\n    epilog=      'stop and step default to 1')\n@print_yielded\ndef seq(stop, start=1, step=1):\n    for i in range(start, stop + 1, step):\n        yield i\n```\n\n```\n$ seq.py -h\nusage: seq.py [-h] [-s start] [-s step] stop\n\nprint all the values from start to stop, inclusive, in steps of step\n\npositional arguments:\n  stop\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -s start, --start start\n  -s step, --step step\n\nstop and step default to 1\n```\n\neven though autocommand is being applied to the `wrapper` returned by `print_yielded`, it still retreives the signature of the underlying `seq` function to create the argument parsing.\n\n### custom parser\n\nwhile autocommand's automatic parser generator is a powerful convenience, it doesn't cover all of the different features that argparse provides. if you need these features, you can provide your own parser as a kwarg to `autocommand`:\n\n```python\nfrom argparse import argumentparser\nfrom autocommand import autocommand\n\nparser = argumentparser()\n# autocommand can't do optional positonal parameters\nparser.add_argument('arg', nargs='?')\n# or mutually exclusive options\ngroup = parser.add_mutually_exclusive_group()\ngroup.add_argument('-v', '--verbose', action='store_true')\ngroup.add_argument('-q', '--quiet', action='store_true')\n\n@autocommand(__name__, parser=parser)\ndef main(arg, verbose, quiet):\n    print(arg, verbose, quiet)\n```\n\n```\n$ python parser.py -h\nusage: write_file.py [-h] [-v | -q] [arg]\n\npositional arguments:\n  arg\n\noptional arguments:\n  -h, --help     show this help message and exit\n  -v, --verbose\n  -q, --quiet\n$ python parser.py\nnone false false\n$ python parser.py hello\nhello false false\n$ python parser.py -v\nnone true false\n$ python parser.py -q\nnone false true\n$ python parser.py -vq\nusage: parser.py [-h] [-v | -q] [arg]\nparser.py: error: argument -q/--quiet: not allowed with argument -v/--verbose\n```\n\nany parser should work fine, so long as each of the parser's arguments has a corresponding parameter in the decorated main function. the order of parameters doesn't matter, as long as they are all present. note that when using a custom parser, autocommand doesn't modify the parser or the retrieved arguments. this means that no description/epilog will be added, and the function's type annotations and defaults (if present) will be ignored.\n\n## testing and library use\n\nthe decorated function is only called and exited from if the first argument to `autocommand` is `'__main__'` or `true`. if it is neither of these values, or no argument is given, then a new main function is created by the decorator. this function has the signature `main(argv=none)`, and is intended to be called with arguments as if via `main(sys.argv[1:])`. the function has the attributes `parser` and `main`, which are the generated `argumentparser` and the original main function that was decorated. this is to facilitate testing and library use of your main. calling the function triggers a `parse_args()` with the supplied arguments, and returns the result of the main function. note that, while it returns instead of calling `sys.exit`, the `parse_args()` function will raise a `systemexit` in the event of a parsing error or `-h/--help` argument.\n\n```python\n    @autocommand()\n    def test_prog(arg1, arg2: int, quiet=false, verbose=false):\n        if not quiet:\n            print(arg1, arg2)\n            if verbose:\n                print(\"loud noises\")\n\n        return 0\n\n    print(test_prog(['-v', 'hello', '80']))\n```\n\n```\n$ python test_prog.py\nhello 80\nloud noises\n0\n```\n\nif the function is called with no arguments, `sys.argv[1:]` is used. this is to allow the autocommand function to be used as a setuptools entry point.\n\n## exceptions and limitations\n\n- there are a few possible exceptions that `autocommand` can raise. all of them derive from `autocommand.autocommanderror`.\n\n  - if an invalid annotation is given (that is, it isn't a `type`, `str`, `(type, str)`, or `(str, type)`, an `annotationerror` is raised. the `type` may be any callable, as described in the `types`_ section.\n  - if the function has a `**kwargs` parameter, a `kwargerror` is raised.\n  - if, somehow, the function has a positional-only parameter, a `positionalargerror` is raised. this means that the argument doesn't have a name, which is currently not possible with a plain `def` or `lambda`, though many built-in functions have this kind of parameter.\n\n- there are a few argparse features that are not supported by autocommand.\n\n  - it isn't possible to have an optional positional argument (as opposed to a `--option`). posix thinks this is bad form anyway.\n  - it isn't possible to have mutually exclusive arguments or options\n  - it isn't possible to have subcommands or subparsers, though i'm working on a few solutions involving classes or nested function definitions to allow this.\n\n## development\n\nautocommand cannot be important from the project root; this is to enforce separation of concerns and prevent accidental importing of `setup.py` or tests. to develop, install the project in editable mode:\n\n```\n$ python setup.py develop\n```\n\nthis will create a link to the source files in the deployment directory, so that any source changes are reflected when it is imported.\n",
  "docs_url": null,
  "keywords": "",
  "license": "lgplv3",
  "name": "autocommand",
  "package_url": "https://pypi.org/project/autocommand/",
  "project_url": "https://pypi.org/project/autocommand/",
  "project_urls": {
    "Bug Tracker": "https://github.com/Lucretiel/autocommand/issues",
    "Homepage": "https://github.com/Lucretiel/autocommand"
  },
  "release_url": "https://pypi.org/project/autocommand/2.2.2/",
  "requires_dist": [],
  "requires_python": ">=3.7",
  "summary": "a library to create a command-line program from a function",
  "version": "2.2.2",
  "releases": [],
  "developers": [
    "nathan_west"
  ],
  "kwds": "argparse autocommand parse_args add_argument autocommanderror",
  "license_kwds": "lgplv3",
  "libtype": "pypi",
  "id": "pypi_autocommand",
  "homepage": "https://github.com/lucretiel/autocommand",
  "release_count": 16,
  "dependency_ids": []
}