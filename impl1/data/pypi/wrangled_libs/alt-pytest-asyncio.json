{
  "classifiers": [
    "framework :: pytest",
    "topic :: software development :: testing"
  ],
  "description": "alternative pytest asyncio\n==========================\n\nthis plugin allows you to have async pytest fixtures and tests.\n\nthis plugin only supports python 3.6 and above.\n\nthe code here is influenced by pytest-asyncio but with some differences:\n\n* error tracebacks from are from your tests, rather than asyncio internals\n* there is only one loop for all of the tests\n* you can manage the lifecycle of the loop yourself outside of pytest by using\n  this plugin with your own loop\n* no need to explicitly mark your tests as async. (pytest-asyncio requires you\n  mark your async tests because it also supports other event loops like curio\n  and trio)\n\nlike pytest-asyncio it supports async tests, coroutine fixtures and async\ngenerator fixtures.\n\nchangelog\n---------\n\n0.7.2 - 1 october 2023\n    * timeouts don't take affect if the debugger is active\n\n0.7.1 - 23 june 2023\n    * no functional changes, only fixing how hatchling understands the\n      license field in the pyproject.toml with thanks to @piotrm-nvidia\n\n0.7.0 - 12 april 2023\n    * changed the pytest dependency to be greater than pytest version 7\n    * using isort now\n    * went from setuptools to hatch\n    * ci now runs against python 3.11\n\n0.6.0 - 23 october 2021\n    * fix bug where it was possible for an async generator fixture to\n      be cleaned up even if it was never started.\n    * this library is now 3.7+ only\n    * added an equivalent ``shutdown_asyncgen`` to the overrideloop helper\n\n0.5.4 - 26 january 2021\n    * added a ``--default-async-timeout`` option from the cli. with many thanks\n      to @andredias.\n    * renamed existing pytest.ini option from ``default_alt_async_timeout`` to\n      be ``default_async_timeout``.\n\n0.5.3 - 25 july 2020\n    * make sure a keyboardinterrupt on running tests still shows errors from\n      failed tests\n\n0.5.2 - 6 february 2020\n    * added ability to make a different event loop for some tests\n\n0.5.1 - 15 december 2019\n    * added an ini option ``default_alt_async_timeout`` for the default async\n      timeout for fixtures and tests. the default is now 5 seconds. so say\n      you wanted the default to be 3.5 seconds, you would set\n      ``default_alt_async_timeout`` to be 3.5\n\n0.5 - 16 august 2019\n    * i made this functionality in a work project where i needed to run\n      pytest.main from an existing event loop. i decided to make this it's\n      own module so i can have tests for this code.\n\nrunning from your own event loop\n--------------------------------\n\nif you want to run pytest.main from with an existing event loop then you can\ndo something like:\n\n.. code-block:: python\n\n   from alt_pytest_asyncio.plugin import altpytestasyncioplugin, run_coro_as_main\n   import nest_asyncio\n   import asyncio\n   import pytest\n\n   async def my_tests():\n      await do_some_setup_before_pytest()\n\n      plugins = [altpytestasyncioplugin(loop)]\n\n      try:\n          code = pytest.main([], plugins=plugins)\n      finally:\n          # note that alt_pytest_asyncio will make sure all your async tests\n          # have been finalized by this point, even if you keyboardinterrupt\n          # the pytest.main\n          await do_any_teardown_after_pytest()\n\n      if code != 0:\n         raise exception(repr(code))\n\n   if __name__ == '__main__':\n      # nest asyncio is required so that we can do run_until_complete in an\n      # existing event loop - https://github.com/erdewit/nest_asyncio\n      loop = asyncio.get_event_loop()\n      nest_asyncio.apply(loop)\n\n      run_coro_as_main(loop, my_tests())\n\nnote that if you don't need to run pytest from an existing event loop, you don't\nneed to do anything other than have alt_pytest_asyncio installed in your\nenvironment and you'll be able to just use async keywords on your fixtures and\ntests.\n\ntimeouts\n--------\n\nalt_pytest_asyncio registers a ``pytest.mark.async_timeout(seconds)`` mark which\nyou can use to set a timeout for your test.\n\nfor example:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.mark.async_timeout(10)\n   async def test_something():\n      await something_that_may_take_a_while()\n\nthis test will be cancelled after 10 seconds and raise an assertion error saying\nthe test took too long and the file and line number where the test is.\n\nyou can also use the async_timeout mark on coroutine fixtures:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.fixture()\n   @pytest.mark.async_timeout(0.5)\n   async def my_amazing_fixture():\n      await asyncio.sleep(1)\n      return 1\n\nand you can have a timeout on generator fixtures:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.fixture()\n   @pytest.mark.async_timeout(0.5)\n   async def my_amazing_fixture():\n      try:\n         await asyncio.sleep(1)\n         yield 1\n      finally:\n         await asyncio.sleep(1)\n\nnote that for generator fixtures, the timeout is applied in whole to both the\nsetup and finalization of the fixture. as in the real timeout for the entire\nfixture is essentially double the single timeout specified.\n\nthe default timeout is 5 seconds. you can change this default by setting the\n``default_async_timeout`` option to the number of seconds you want.\n\nthis setting is also available from the cli using the ``--default-async-timeout``\noption.\n\nnote that if the timeout fires whilst you have the debugger active then the timeout\nwill not cancel the current test. this is determined by checking if ``sys.gettrace()``\nreturns a non-none value.\n\noverriding the loop\n-------------------\n\nsometimes it may be necessary to close the current loop in a test. for this to\nnot then break the rest of your tests, you will need to set a new event loop for\nyour test and then restore the old loop afterwards.\n\nfor this, we have a context manager that will install a new asyncio loop and\nthen restore the original loop on exit.\n\nusage looks like::\n\n    from alt_pytest_asyncio.plugin import overrideloop\n\n    class testthing:\n        @pytest.fixture(autouse=true)\n        def custom_loop(self):\n            with overrideloop() as custom_loop:\n                yield custom_loop\n\n        def test_thing(self, custom_loop):\n            custom_loop.run_until_complete(my_thing())\n\nby putting the loop into an autouse fixture, all fixtures used by the test\nwill have the custom loop. if you want to include module level fixtures too\nthen use the overrideloop in a module level fixture too.\n\noverrideloop takes in a ``new_loop`` boolean that will make it so no new\nloop is set and asyncio is left with no default loop.\n\nthe new loop itself (or none if new_loop is false) can be found in the\n``loop`` attribute of the object yielded by the context manager.\n\nthe ``run_until_complete`` on the ``custom_loop`` in the above example will\ndo a ``run_until_complete`` on the new loop, but in a way that means you\nwon't get ``unhandled exception during shutdown`` errors when the context\nmanager closes the new loop.\n\nwhen the context manager exits and closes the new loop, it will first cancel\nall tasks to ensure finally blocks are run.\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "alt-pytest-asyncio",
  "package_url": "https://pypi.org/project/alt-pytest-asyncio/",
  "project_url": "https://pypi.org/project/alt-pytest-asyncio/",
  "project_urls": {
    "Homepage": "https://github.com/delfick/alt-pytest-asyncio"
  },
  "release_url": "https://pypi.org/project/alt-pytest-asyncio/0.7.2/",
  "requires_dist": [
    "pytest>=7.0.0",
    "nest-asyncio==1.0.0; extra == 'tests'",
    "noseofyeti[black]==2.4.1; extra == 'tests'",
    "pytest==7.3.0; extra == 'tests'"
  ],
  "requires_python": ">=3.7",
  "summary": "alternative pytest plugin to pytest-asyncio",
  "version": "0.7.2",
  "releases": [],
  "developers": [
    "delfick755@gmail.com"
  ],
  "kwds": "alt_pytest_asyncio do_some_setup_before_pytest nest_asyncio do_any_teardown_after_pytest altpytestasyncioplugin",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_alt_pytest_asyncio",
  "homepage": "",
  "release_count": 9,
  "dependency_ids": [
    "pypi_nest_asyncio",
    "pypi_noseofyeti",
    "pypi_pytest"
  ]
}