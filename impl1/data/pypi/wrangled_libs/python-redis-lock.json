{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: microsoft :: windows",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: utilities"
  ],
  "description": "========\noverview\n========\n\n\n\nlock context manager implemented via redis setnx/blpop.\n\n* free software: bsd 2-clause license\n\ninterface targeted to be exactly like `threading.lock <https://docs.python.org/2/library/threading.html#threading.lock>`_.\n\nusage\n=====\n\nbecause we don't want to require users to share the lock instance across processes you will have to give them names.\n\n.. code-block:: python\n\n    from redis import redis\n    conn = redis()\n\n    import redis_lock\n    lock = redis_lock.lock(conn, \"name-of-the-lock\")\n    if lock.acquire(blocking=false):\n        print(\"got the lock.\")\n        lock.release()\n    else:\n        print(\"someone else has the lock.\")\n\nlocks as context managers\n=========================\n\n.. code-block:: python\n\n    conn = strictredis()\n    with redis_lock.lock(conn, \"name-of-the-lock\"):\n        print(\"got the lock. doing some work ...\")\n        time.sleep(5)\n\n\nyou can also associate an identifier along with the lock so that it can be retrieved later by the same process, or by a\ndifferent one. this is useful in cases where the application needs to identify the lock owner (find out who currently\nowns the lock).\n\n.. code-block:: python\n\n    import socket\n    host_id = \"owned-by-%s\" % socket.gethostname()\n    lock = redis_lock.lock(conn, \"name-of-the-lock\", id=host_id)\n    if lock.acquire(blocking=false):\n        assert lock.locked() is true\n        print(\"got the lock.\")\n        lock.release()\n    else:\n        if lock.get_owner_id() == host_id:\n            print(\"i already acquired this in another process.\")\n        else:\n            print(\"the lock is held on another machine.\")\n\n\navoid dogpile effect in django\n------------------------------\n\nthe dogpile is also known as the thundering herd effect or cache stampede. here's a pattern to avoid the problem\nwithout serving stale data. the work will be performed a single time and every client will wait for the fresh data.\n\nto use this you will need `django-redis <https://github.com/jazzband/django-redis>`_, however, ``python-redis-lock``\nprovides you a cache backend that has a cache method for your convenience. just install ``python-redis-lock`` like\nthis:\n\n.. code-block:: bash\n\n    pip install \"python-redis-lock[django]\"\n\nnow put something like this in your settings:\n\n.. code-block:: python\n\n    caches = {\n        'default': {\n            'backend': 'redis_lock.django_cache.rediscache',\n            'location': 'redis://127.0.0.1:6379/1',\n            'options': {\n                'client_class': 'django_redis.client.defaultclient'\n            }\n        }\n    }\n\n.. note::\n    if using a `django-redis` < `3.8.x`, you'll probably need `redis_cache`\n    which has been deprecated in favor to `django_redis`. the `redis_cache`\n    module is removed in `django-redis` versions > `3.9.x`. see `django-redis notes <https://github.com/jazzband/django-redis#configure-as-cache-backend>`_.\n\n\nthis backend just adds a convenient ``.lock(name, expire=none)`` function to django-redis's cache backend.\n\nyou would write your functions like this:\n\n.. code-block:: python\n\n    from django.core.cache import cache\n\n    def function():\n        val = cache.get(key)\n        if not val:\n            with cache.lock(key):\n                val = cache.get(key)\n                if not val:\n                    # do expensive work\n                    val = ...\n                    cache.set(key, value)\n        return val\n\ntroubleshooting\n---------------\n\nin some cases, the lock remains in redis forever (like a server blackout / redis or application crash / an unhandled\nexception). in such cases, the lock is not removed by restarting the application. one solution is to turn on the\n`auto_renewal` parameter in combination with `expire` to set a time-out on the lock, but let `lock()` automatically\nkeep resetting the expire time while your application code is executing:\n\n.. code-block:: python\n\n    # get a lock with a 60-second lifetime but keep renewing it automatically\n    # to ensure the lock is held for as long as the python process is running.\n    with redis_lock.lock(conn, name='my-lock', expire=60, auto_renewal=true):\n        # do work....\n\nanother solution is to use the ``reset_all()`` function when the application starts:\n\n.. code-block:: python\n\n    # on application start/restart\n    import redis_lock\n    redis_lock.reset_all()\n\nalternatively, you can reset individual locks via the ``reset`` method.\n\nuse these carefully, if you understand what you do.\n\n\nfeatures\n========\n\n* based on the standard setnx recipe\n* optional expiry\n* optional timeout\n* optional lock renewal (use a low expire but keep the lock active)\n* no spinloops at acquire\n\nimplementation\n==============\n\n``redis_lock`` will use 2 keys for each lock named ``<name>``:\n\n* ``lock:<name>`` - a string value for the actual lock\n* ``lock-signal:<name>`` - a list value for signaling the waiters when the lock is released\n\nthis is how it works:\n\n.. image:: https://raw.githubusercontent.com/ionelmc/python-redis-lock/master/docs/redis-lock%20diagram%20(v3.0).png\n    :alt: python-redis-lock flow diagram\n\ndocumentation\n=============\n\nhttps://python-redis-lock.readthedocs.io/en/latest/\n\ndevelopment\n===========\n\nto run the all tests run::\n\n    tox\n\nrequirements\n============\n\n:os: any\n:runtime: python 2.7, 3.3 or later, or pypy\n:services: redis 2.6.12 or later.\n\nsimilar projects\n================\n\n* `bbangert/retools <https://github.com/bbangert/retools/blob/0.4/retools/lock.py>`_ - acquire does spinloop\n* `distributing-locking-python-and-redis <https://chris-lamb.co.uk/posts/distributing-locking-python-and-redis>`_ - acquire does polling\n* `cezarsa/redis_lock <https://github.com/cezarsa/redis_lock/blob/0.2.0/redis_lock/__init__.py>`_ - acquire does not block\n* `andymccurdy/redis-py <https://github.com/andymccurdy/redis-py/blob/3.5.3/redis/lock.py>`_ - acquire does spinloop\n* `mpessas/python-redis-lock <https://github.com/mpessas/python-redis-lock/blob/b512eef0fc5e1e2e82a6a31f65cd88c2c37dfe4b/redislock/lock.py>`_ - blocks fine but no expiration\n* `brainix/pottery <https://github.com/brainix/pottery/blob/v1.1.5/pottery/redlock.py>`_ - acquire does spinloop\n\n\nchangelog\n=========\n\n4.0.0 (2022-10-17)\n------------------\n\n* dropped support for python 2.7 and 3.6.\n* switched from travis to github actions.\n* made logging messages more consistent.\n* replaced the ``redis_lock.refresh.thread.*`` loggers with a single ``redis_lock.refresh.thread`` logger.\n* various testing cleanup (mainly removal of hardcoded tmp paths).\n\n3.7.0 (2020-11-20)\n------------------\n\n* made logger names more specific. now can have granular filtering on these new logger names:\n\n  * ``redis_lock.acquire`` (emits `debug` messages)\n  * ``redis_lock.acquire`` (emits `warn` messages)\n  * ``redis_lock.acquire`` (emits `info` messages)\n  * ``redis_lock.refresh.thread.start`` (emits `debug` messages)\n  * ``redis_lock.refresh.thread.exit`` (emits `debug` messages)\n  * ``redis_lock.refresh.start`` (emits `debug` messages)\n  * ``redis_lock.refresh.shutdown`` (emits `debug` messages)\n  * ``redis_lock.refresh.exit`` (emits `debug` messages)\n  * ``redis_lock.release`` (emits `debug` messages)\n\n  contributed by salomon smeke cohen in ``80``.\n* fixed few ci issues regarding doc checks.\n  contributed by salomon smeke cohen in ``81``.\n\n3.6.0 (2020-07-23)\n------------------\n\n* improved ``timeout``/``expire`` validation so that:\n\n  - ``timeout`` and ``expire are converted to ``none`` if they are falsy. previously only ``none`` disabled these options, other falsy\n    values created buggy situations.\n  - using ``timeout`` greater than ``expire`` is now allowed, if ``auto_renewal`` is set to ``true``. previously a ``timeouttoolarge`` error\n    was raised.\n    see ``74``.\n  - negative ``timeout`` or ``expire`` are disallowed. previously such values were allowed, and created buggy situations.\n    see ``73``.\n* updated benchmark and examples.\n* removed the custom script caching code. now the ``register_script`` method from the redis client is used.\n  this will fix possible issue with redis clusters in theory, as the redis client has some specific handling for that.\n\n3.5.0 (2020-01-13)\n------------------\n\n* added a ``locked`` method. contributed by artem slobodkin in ``72``.\n\n3.4.0 (2019-12-06)\n------------------\n\n* fixed regression that can cause deadlocks or slowdowns in certain configurations.\n  see: ``71``.\n\n3.3.1 (2019-01-19)\n------------------\n\n* fixed failures when running python-redis-lock 3.3 alongside 3.2.\n  see: ``64``.\n\n3.3.0 (2019-01-17)\n------------------\n\n* fixed deprecated use of ``warnings`` api. contributed by julie macdonell in\n  ``54``.\n* added ``auto_renewal`` option in ``rediscache.lock`` (the django cache backend wrapper). contributed by c\n  in ``55``.\n* changed log level for \"%(script)s not cached\" from warning to info.\n* added support for using ``decode_responses=true``. lock keys are pure ascii now.\n\n3.2.0 (2016-10-29)\n------------------\n\n* changed the signal key cleanup operation do be done without any expires. this prevents lingering keys around for some time.\n  contributed by andrew pashkin in ``38``.\n* allow locks with given `id` to acquire. previously it assumed that if you specify the `id` then the lock was already\n  acquired. see ``44`` and\n  ``39``.\n* allow using other redis clients with a ``strict=false``. normally you're expected to pass in an instance\n  of ``redis.strictredis``.\n* added convenience method `locked_get_or_set` to django cache backend.\n\n3.1.0 (2016-04-16)\n------------------\n\n* changed the auto renewal to automatically stop the renewal thread if lock gets garbage collected. contributed by\n  andrew pashkin in ``33``.\n\n3.0.0 (2016-01-16)\n------------------\n\n* changed ``release`` so that it expires signal-keys immediately. contributed by andrew pashkin in ``28``.\n* resetting locks (``reset`` or ``reset_all``) will release the lock. if there's someone waiting on the reset lock now it will\n  acquire it. contributed by andrew pashkin in ``29``.\n* added the ``extend`` method on ``lock`` objects. contributed by andrew pashkin in ``24``.\n* documentation improvements on ``release`` method. contributed by andrew pashkin in ``22``.\n* fixed ``acquire(block=true)`` handling when ``expire`` option was used (it wasn't blocking indefinitely). contributed by\n  tero vuotila in ``35``.\n* changed ``release`` to check if lock was acquired with he same id. if not, ``notacquired`` will be raised.\n  previously there was just a check if it was acquired with the same instance (self._held).\n  **backwards incompatible**\n* removed the ``force`` option from ``release`` - it wasn't really necessary and it only encourages sloppy programming. see\n  ``25``.\n  **backwards incompatible**\n* dropped tests for python 2.6. it may work but it is unsupported.\n\n2.3.0 (2015-09-27)\n------------------\n\n* added the ``timeout`` option. contributed by victor torres in ``20``.\n\n2.2.0 (2015-08-19)\n------------------\n\n* added the ``auto_renewal`` option. contributed by nick groenen in ``18``.\n\n2.1.0 (2015-03-12)\n------------------\n\n* new specific exception classes: ``alreadyacquired`` and ``notacquired``.\n* slightly improved efficiency when non-waiting acquires are used.\n\n2.0.0 (2014-12-29)\n------------------\n\n* rename ``lock.token`` to ``lock.id``. now only allowed to be set via constructor. contributed by jardel weyrich in ``11``.\n\n1.0.0 (2014-12-23)\n------------------\n\n* fix django integration. (reported by jardel weyrich)\n* reorganize tests to use py.test.\n* add test for django integration.\n* add ``reset_all`` functionality. contributed by yokotoka in ``7``.\n* add ``lock.reset`` functionality.\n* expose the ``lock.token`` attribute.\n\n0.1.2 (2013-11-05)\n------------------\n\n* `?`\n\n0.1.1 (2013-10-26)\n------------------\n\n* `?`\n\n0.1.0 (2013-10-26)\n------------------\n\n* `?`\n\n0.0.1 (2013-10-25)\n------------------\n\n* first release on pypi.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-2-clause",
  "name": "python-redis-lock",
  "package_url": "https://pypi.org/project/python-redis-lock/",
  "project_url": "https://pypi.org/project/python-redis-lock/",
  "project_urls": {
    "Changelog": "https://python-redis-lock.readthedocs.io/en/latest/changelog.html",
    "Documentation": "https://python-redis-lock.readthedocs.io/",
    "Homepage": "https://github.com/ionelmc/python-redis-lock",
    "Issue Tracker": "https://github.com/ionelmc/python-redis-lock/issues"
  },
  "release_url": "https://pypi.org/project/python-redis-lock/4.0.0/",
  "requires_dist": [
    "redis (>=2.10.0)",
    "django-redis (>=3.8.0) ; extra == 'django'"
  ],
  "requires_python": ">=3.7",
  "summary": "lock context manager implemented via redis setnx/blpop.",
  "version": "4.0.0",
  "releases": [],
  "developers": [
    "contact@ionelmc.ro"
  ],
  "kwds": "redis_lock redislock redlock redis locking",
  "license_kwds": "bsd-2-clause",
  "libtype": "pypi",
  "id": "pypi_python_redis_lock",
  "homepage": "https://github.com/ionelmc/python-redis-lock",
  "release_count": 19,
  "dependency_ids": [
    "pypi_django_redis",
    "pypi_redis"
  ]
}