{
  "classifiers": [],
  "description": "=========\n pinject\n=========\n\n.. image:: https://badge.fury.io/py/pinject.svg\n    :target: https://pypi.org/project/pinject/\n.. image:: https://travis-ci.com/google/pinject.svg?branch=master\n    :target: https://travis-ci.com/google/pinject\n.. image:: https://pepy.tech/badge/pinject\n    :target: https://pepy.tech/badge/pinject\n.. image:: https://pepy.tech/badge/pinject/month\n    :target: https://pepy.tech/badge/pinject\n\npinject is a dependency injection library for python.\n\nthe primary goal of pinject is to help you assemble objects into graphs in an\neasy, maintainable way.\n\nif you are already familiar with other dependency injection libraries, you may\nwant to read the condensed summary section at the end, so that you get an idea\nof what pinject is like and how it might differ from libraries you're used to.\n\nthere is a changelog of differences between released versions near the end of\nthis readme.\n\nwhy pinject?\n============\n\nif you're wondering why to use a dependency injection library at all: if\nyou're writing a lot of object-oriented code in python, then it will make your\nlife easier.  see, for instance:\n\n* https://en.wikipedia.org/wiki/dependency_injection\n* http://lmgtfy.com/?q=dependency+injection\n\nif you're wondering why to use pinject instead of another python dependency\ninjection library, a few of reasons are:\n\n* pinject is much easier to get started with.  forget having to decorate your code with ``@inject_this`` and ``@annotate_that`` just to get started.  with pinject, you call ``new_object_graph()``, one line, and you're good to go.\n* pinject is a *pythonic* dependency injection library.  python ports of other libraries, like spring or guice, retain the feel (and verbosity) of being designed for a statically typed language.  pinject is designed from the ground up for python.\n* the design choices in pinject are informed by several dependency injection experts working at google, based on many years of experience.  several common confusing or misguided features are omitted altogether from pinject.\n* pinject has great error messages.  they tell you exactly what you did wrong, and exactly where.  this should be a welcome change from other dependency frameworks, with their voluminous and yet inscrutable stack traces.\n\nlook at the simplest getting-started examples for pinject and for other\nsimilar libraries.  pinject should be uniformly easier to use, clearer to\nread, and less boilerplate that you need to add.  if you don't find this to be\nthe case, email!\n\ninstallation\n============\n\nthe easiest way to install pinject is to get the latest released version from\npypi:\n\n.. code-block:: shell\n\n    sudo pip install pinject\n\nif you are interested in the developing version, you can install the next version from test pypi:\n\n.. code-block:: shell\n\n    sudo pip install \\\n        --no-deps \\\n        --no-cache \\\n        --upgrade \\\n        --index-url https://test.pypi.org/simple/ \\\n        pinject\n\nyou can also check out all the source code, including tests, designs, and\ntodos:\n\n.. code-block:: shell\n\n   git clone https://github.com/google/pinject\n\nbasic dependency injection\n==========================\n\nthe most important function in the ``pinject`` module is\n``new_object_graph()``.  this creates an ``objectgraph``, which you can use to\ninstantiate objects using dependency injection.  if you pass no args to\n``new_object_graph()``, it will return a reasonably configured default\n``objectgraph``.\n\n.. code-block:: python\n\n    >>> class outerclass(object):\n    ...     def __init__(self, inner_class):\n    ...         self.inner_class = inner_class\n    ...\n    >>> class innerclass(object):\n    ...     def __init__(self):\n    ...         self.forty_two = 42\n    ...\n    >>> obj_graph = pinject.new_object_graph()\n    >>> outer_class = obj_graph.provide(outerclass)\n    >>> print outer_class.inner_class.forty_two\n    42\n    >>>\n\nas you can see, you don't need to tell pinject how to construct its\n``objectgraph``, and you don't need to put decorators in your code.  pinject has\nreasonable defaults that allow it to work out of the box.\n\na pinject *binding* is an association between an *arg name* and a *provider*.\nin the example above, pinject created a binding between the arg name\n``inner_class`` and an implicitly created provider for the class\n``innerclass``.  the binding it had created was how pinject knew that it\nshould pass an instance of ``innerclass`` as the value of the ``inner_class``\narg when instantiating ``outerclass``.\n\nimplicit class bindings\n=======================\n\npinject creates implicit bindings for classes.  the implicit bindings assume\nyour code follows pep8 conventions: your classes are named in ``camelcase``,\nand your args are named in ``lower_with_underscores``.  pinject transforms\nclass names to injectable arg names by lowercasing words and connecting them\nwith underscores.  it will also ignore any leading underscore on the class\nname.\n\n+-------------+-------------+\n| class name  | arg name    |\n+=============+=============+\n| ``foo``     | ``foo``     |\n+-------------+-------------+\n| ``foobar``  | ``foo_bar`` |\n+-------------+-------------+\n| ``_foo``    | ``foo``     |\n+-------------+-------------+\n| ``_foobar`` | ``foo_bar`` |\n+-------------+-------------+\n\nif two classes map to the same arg name, whether those classes are in the same\nmodule or different modules, pinject will not create an implicit binding for\nthat arg name (though it will not raise an error).\n\nfinding classes and providers for implicit bindings\n===================================================\n\nso far, the examples have not told ``new_object_graph()`` the classes for\nwhich it should create implicit bindings.  ``new_object_graph()`` by default\nlooks in all imported modules, but you may occasionally want to restrict the\nclasses for which ``new_object_graph()`` creates implicit bindings.  if so,\n``new_object_graph()`` has two args for this purpose.\n\n* the ``modules`` arg specifies in which (python) modules to look for classes; this defaults to ``all_imported_modules``.\n* the ``classes`` arg specifies a exact list of classes; this defaults to ``none``.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class foo(object):\n    ...     pass\n    ...\n    >>> obj_graph = pinject.new_object_graph(modules=none, classes=[someclass])\n    >>> # obj_graph.provide(someclass)  # would raise a nothinginjectableforargerror\n    >>> obj_graph = pinject.new_object_graph(modules=none, classes=[someclass, foo])\n    >>> some_class = obj_graph.provide(someclass)\n    >>>\n\nauto-copying args to fields\n===========================\n\none thing that can get tedious about dependency injection via initializers is\nthat you need to write ``__init__()`` methods that copy args to fields.  these\n``__init__()`` methods can get repetitive, especially when you have several\ninitializer args.\n\n.. code-block:: python\n\n    >>> class classwithtediousinitializer(object):\n    ...     def __init__(self, foo, bar, baz, quux):\n    ...         self._foo = foo\n    ...         self._bar = bar\n    ...         self._baz = baz\n    ...         self._quux = quux\n    ...\n    >>>\n\npinject provides decorators that you can use to avoid repetitive initializer\nbodies.\n\n* ``@copy_args_to_internal_fields`` prepends an underscore, i.e., it copies an arg named ``foo`` to a field named ``_foo``.  it's useful for normal classes.\n* ``@copy_args_to_public_fields`` copies the arg named as-is, i.e., it copies an arg named ``foo`` to a field named ``foo``.  it's useful for data objects.\n\n.. code-block:: python\n\n    >>> class classwithtediousinitializer(object):\n    ...     @pinject.copy_args_to_internal_fields\n    ...     def __init__(self, foo, bar, baz, quux):\n    ...         pass\n    ...\n    >>> cwti = classwithtediousinitializer('a-foo', 'a-bar', 'a-baz', 'a-quux')\n    >>> print cwti._foo\n    'a-foo'\n    >>>\n\nwhen using these decorators, you'll normally ``pass`` in the body of the\ninitializer, but you can put other statements there if you need to.  the args\nwill be copied to fields before the initializer body is executed.\n\nthese decorators can be applied to initializers that take ``**kwargs`` but not\ninitializers that take ``*pargs`` (since it would be unclear what field name\nto use).\n\nbinding specs\n=============\n\nto create any bindings more complex than the implicit class bindings described\nabove, you use a *binding spec*.  a binding spec is any python class that\ninherits from ``bindingspec``.  a binding spec can do three things:\n\n* its ``configure()`` method can create explicit bindings to classes or instances, as well as requiring bindings without creating them.\n* its ``dependencies()`` method can return depended-on binding specs.\n* it can have provider methods, for which explicit bindings are created.\n\nthe ``new_object_graph()`` function takes a sequence of binding spec instances\nas its ``binding_specs`` arg.  ``new_object_graph()`` takes binding spec\ninstances, rather than binding spec classes, so that you can manually inject\nany initial dependencies into the binding specs as needed.\n\nbinding specs should generally live in files named ``binding_specs.py``, where\neach file is named in the plural even if there is exactly one binding spec in\nit.  ideally, a directory's worth of functionality should be coverable with a\nsingle binding spec.  if not, you can create multiple binding specs in the\nsame ``binding_specs.py`` file.  if you have so many binding specs that you\nneed to split them into multiple files, you should name them each with a\n``_binding_specs.py`` suffix.\n\nbinding spec ``configure()`` methods\n------------------------------------\n\npinject creates implicit bindings for classes, but sometimes the implicit\nbindings aren't what you want.  for instance, if you have\n``somereallylongclassname``, you may not want to name your initializer args\n``some_really_long_class_name`` but instead use something shorter like\n``long_name``, just for this class.\n\nfor such situations, you can create explicit bindings using the\n``configure()`` method of a binding spec.  the ``configure()`` method takes a\nfunction ``bind()`` as an arg and calls that function to create explicit\nbindings.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, long_name):\n    ...         self.long_name = long_name\n    ...\n    >>> class somereallylongclassname(object):\n    ...     def __init__(self):\n    ...         self.foo = 'foo'\n    ...\n    >>> class mybindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('long_name', to_class=somereallylongclassname)\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[mybindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.long_name.foo\n    'foo'\n    >>>\n\nthe ``bind()`` function passed to a binding function binds its first arg,\nwhich must be an arg name (as a ``str``), to exactly one of two kinds of\nthings.\n\n* using ``to_class`` binds to a class.  when the binding is used, pinject injects an instance of the class.\n* using ``to_instance`` binds to an instance of some object.  every time the binding is used, pinject uses that instance.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class mybindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='a-foo')\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[mybindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'a-foo'\n    >>>\n\nthe ``configure()`` method of a binding spec also may take a function\n``require()`` as an arg and use that function to require that a binding be\npresent without actually defining that binding.  ``require()`` takes as args\nthe name of the arg for which to require a binding.\n\n.. code-block:: python\n\n    >>> class mainbindingspec(pinject.bindingspec):\n    ...     def configure(self, require):\n    ...         require('foo')\n    ...\n    >>> class realfoobindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='a-real-foo')\n    ...\n    >>> class stubfoobindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='a-stub-foo')\n    ...\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[mainbindingspec(), realfoobindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'a-real-foo'\n    >>> # pinject.new_object_graph(\n    ... #    binding_specs=[mainbindingspec()])  # would raise a missingrequiredbindingerror\n    ...\n    >>>\n\nbeing able to require a binding without defining the binding is useful when\nyou know the code will need some dependency satisfied, but there is more than\none implementation that satisfies that dependency, e.g., there may be a real\nrpc client and a fake rpc client.  declaring the dependency means that any\nexpected but missing bindings will be detected early, when\n``new_object_graph()`` is called, rather than in the middle of running your\nprogram.\n\nyou'll notice that the ``configure()`` methods above have different\nsignatures, sometimes taking the arg ``bind`` and sometimes taking the arg\n``require``.  ``configure()`` methods must take at least one arg that is\neither ``bind`` or ``require``, and they may have both args.  pinject will\npass whichever arg or args your ``configure()`` method needs.\n\nbinding spec dependencies\n-------------------------\n\nbinding specs can declare dependencies.  a binding spec declares its\ndependencies by returning a sequence of instances of the dependent binding\nspecs from its ``dependencies()`` method.\n\n.. code-block:: python\n\n    >>> class classone(object):\n    ...    def __init__(self, foo):\n    ...        self.foo = foo\n    ....\n    >>> class bindingspecone(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='foo-')\n    ...\n    >>> class classtwo(object):\n    ...     def __init__(self, class_one, bar):\n    ...         self.foobar = class_one.foo + bar\n    ...\n    >>> class bindingspectwo(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('bar', to_instance='-bar')\n    ...     def dependencies(self):\n    ...         return [bindingspecone()]\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[bindingspectwo()])\n    >>> class_two = obj_graph.provide(classtwo)\n    >>> print class_two.foobar\n    'foo--bar'\n    >>>\n\nif classes from module a are injected as collaborators into classes from\nmodule b, then you should consider having the binding spec for module b depend\non the binding spec for module a.  in the example above, ``classone`` is\ninjected as a collaborator into ``classtwo``, and so ``bindingspectwo`` (the\nbinding spec for ``classtwo``) depends on ``bindingspecone`` (the binding spec\nfor ``classone``).\n\nin this way, you can build a graph of binding spec dependencies that mirrors\nthe graph of collaborator dependencies.\n\nsince explicit bindings cannot conflict (see the section below on binding\nprecedence), a binding spec should only have dependencies that there will\nnever be a choice about using.  if there may be a choice, then it is better to\nlist the binding specs separately and explicitly when calling\n``new_object_graph()``.\n\nthe binding spec dependencies can be a directed acyclic graph (dag); that is,\nbinding spec a can be a dependency of b and of c, and binding spec d can have\ndependencies on b and c.  even though there are multiple dependency paths from\nd to a, the bindings in binding spec a will only be evaluated once.\n\nthe binding spec instance of a that is a dependency of b is considered the\nsame as the instance that is a dependency of c if the two instances are equal\n(via ``__eq__()``).  the default implementation of ``__eq__()`` in\n``bindingspec`` says that two binding specs are equal if they are of exactly\nthe same python type.  you will need to override ``__eq__()`` (as well as\n``__hash__()``) if your binding spec is parameterized, i.e., if it takes one\nor more initializer args so that two instances of the binding spec may behave\ndifferently.\n\n.. code-block:: python\n\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def __init__(self, the_instance):\n    ...         self._the_instance = the_instance\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance=self._the_instance)\n    ...     def __eq__(self, other):\n    ...         return (type(self) == type(other) and\n    ...                 self._the_instance == other._the_instance)\n    ...     def __hash__(self):\n    ...         return hash(type(self)) ^ hash(self._the_instance)\n    ...\n    >>>\n\nprovider methods\n----------------\n\nif it takes more to instantiate a class than calling its initializer and\ninjecting initializer args, then you can write a *provider method* for it.\npinject can use provider methods to instantiate objects used to inject as the\nvalues of other args.\n\npinject looks on binding specs for methods named like provider methods and\nthen creates explicit bindings for them.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def provide_foo(self):\n    ...         return 'some-complex-foo'\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'some-complex-foo'\n    >>>\n\npinject looks on binding specs for methods whose names start with\n``provide_``, and it assumes that the methods are providers for whatever the\nrest of their method names are.  for instance, pinject assumes that the method\n``provide_foo_bar()`` is a provider method for the arg name ``foo_bar``.\n\npinject injects all args of provider methods that have no default when it\ncalls the provider method.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foobar):\n    ...         self.foobar = foobar\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def provide_foobar(self, bar, hyphen='-'):\n    ...         return 'foo' + hyphen + bar\n    ...     def provide_bar(self):\n    ...         return 'bar'\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foobar\n    'foo-bar'\n    >>>\n\nbinding precedence\n==================\n\nbindings have precedence: explicit bindings take precedence over implicit\nbindings.\n\n* explicit bindings are the bindings that come from binding specs.\n* implicit bindings are the bindings created for classes in the ``modules`` and ``classes`` args passed to ``new_object_graph()``.\n\npinject will prefer an explicit to an implicit binding.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class foo(object):\n    ...     pass\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='foo-instance')\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'foo-instance'\n    >>>\n\nif you have two classes named the same thing, pinject will have two different\n(and thus conflicting) implicit bindings.  but pinject will not complain\nunless you try to use those bindings.  pinject *will* complain if you try to\ncreate different (and thus conflicting) explicit bindings.\n\nsafety\n======\n\npinject tries to strike a balance between being helpful and being safe.\nsometimes, you may want or need to change this balance.\n\n``new_object_graph()`` uses implicit bindings by default.  if you worry that\nyou may accidentally inject a class or use a provider function\nunintentionally, then you can make ``new_object_graph()`` ignore implicit\nbindings, by setting ``only_use_explicit_bindings=true``.  if you do so, then\npinject will only use explicit bindings.\n\nif you want to promote an implicit binding to be an explicit binding, you can\nannotate the corresponding class with ``@inject()``.  the ``@inject()``\ndecorator lets you create explicit bindings without needing to create binding\nspecs, as long as you can live with the binding defaults (e.g., no annotations\non args, see below).\n\n.. code-block:: python\n\n    >>> class explicitlyboundclass(object):\n    ...     @pinject.inject()\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class implicitlyboundclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='explicit-foo')\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()],\n    ...     only_use_explicit_bindings=true)\n    >>> # obj_graph.provide(implicitlyboundclass)  # would raise a nonexplicitlyboundclasserror\n    >>> some_class = obj_graph.provide(explicitlyboundclass)\n    >>> print some_class.foo\n    'explicit-foo'\n    >>>\n\nyou can also promote an implicit binding to explicit by using\n``@annotated_arg()`` (see below), with or without ``@inject()`` as well.\n\n(previous versions of pinject included an ``@injectable`` decorator.  that is\ndeprecated in favor of ``@inject()``.  note that ``@inject()`` needs parens,\nwhereas ``@injectable`` didn't.)\n\non the opposite side of permissiveness, pinject by default will complain if a\nprovider method returns ``none``.  if you really want to turn off this default\nbehavior, you can pass ``allow_injecting_none=true`` to\n``new_object_graph()``.\n\nannotations\n===========\n\npinject *annotations* let you have different objects injected for the same arg\nname.  for instance, you may have two classes in different parts of your\ncodebase named the same thing, and you want to use the same arg name in\ndifferent parts of your codebase.\n\non the arg side, an annotation tells pinject only to inject using a binding\nwhose binding key includes the annotation object.  you can use\n``@annotate_arg()`` on an initializer, or on a provider method, to specify the\nannotation object.\n\non the binding side, an annotation changes the binding so that the key of the\nbinding includes the annotation object.  when using ``bind()`` in a binding\nspec's ``configure()`` method, you can pass an ``annotated_with`` arg to\nspecify the annotation object.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     @pinject.annotate_arg('foo', 'annot')\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', annotated_with='annot', to_instance='foo-with-annot')\n    ...         bind('foo', annotated_with=12345, to_instance='12345-foo')\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'foo-with-annot'\n    >>>\n\nalso on the binding side, when defining a provider method, you can use the\n``@provides()`` decorator.  the decorator lets you pass an ``annotated_with``\narg to specify the annotation object.  the decorator's first param,\n``arg_name`` also lets you override what arg name you want the provider to be\nfor.  this is optional but useful if you want the same binding spec to have\ntwo provider methods for the same arg name but annotated differently.\n(otherwise, the methods would need to be named the same, since they're for the\nsame arg name.)\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     @pinject.annotate_arg('foo', 'annot')\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     @pinject.provides('foo', annotated_with='annot')\n    ...     def provide_annot_foo(self):\n    ...         return 'foo-with-annot'\n    ...     @pinject.provides('foo', annotated_with=12345)\n    ...     def provide_12345_foo(self):\n    ...         return '12345-foo'\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'foo-with-annot'\n    >>>\n\nwhen requiring a binding, via the ``require`` arg passed into the\n``configure()`` method of a binding spec, you can pass the arg\n``annotated_with`` to require an annotated binding.\n\n.. code-block:: python\n\n    >>> class mainbindingspec(pinject.bindingspec):\n    ...     def configure(self, require):\n    ...         require('foo', annotated_with='annot')\n    ...\n    >>> class nonsatisfyingbindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_instance='an-unannotated-foo')\n    ...\n    >>> class satisfyingbindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', annotated_with='annot', to_instance='an-annotated-foo')\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[mainbindingspec(), satisfyingbindingspec()])  # works\n    >>> # obj_graph = pinject.new_object_graph(\n    ... #     binding_specs=[mainbindingspec(),\n    ... #                    nonsatisfyingbindingspec()])  # would raise a missingrequiredbindingerror\n    >>>\n\nyou can use any kind of object as an annotation object as long as it\nimplements ``__eq__()`` and ``__hash__()``.\n\nscopes\n======\n\nby default, pinject remembers the object it injected into a (possibly\nannotated) arg, so that it can inject the same object into other args with the\nsame name.  this means that, for each arg name, a single instance of the\nbound-to class, or a single instance returned by a provider method, is created\nby default.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def provide_foo(self):\n    ...         return object()\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class_1 = obj_graph.provide(someclass)\n    >>> some_class_2 = obj_graph.provide(someclass)\n    >>> print some_class_1.foo is some_class_2.foo\n    true\n    >>>\n\nin some cases, you may want to create new instances, always or sometimes,\ninstead of reusing them each time they're injected.  if so, you want to use\n*scopes*.\n\na scope controls memoization (i.e., caching).  a scope can choose to cache\nnever, sometimes, or always.\n\npinject has two built-in scopes.  *singleton scope* (``singleton``) is the\ndefault and always caches.  *prototype scope* (``prototype``) is the other\nbuilt-in option and does no caching whatsoever.\n\nevery binding is associated with a scope.  you can specify a scope for a\nbinding by decorating a provider method with ``@in_scope()``, or by passing an\n``in_scope`` arg to ``bind()`` in a binding spec's ``configure()`` method.\n\n.. code-block:: python\n\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     @pinject.provides(in_scope=pinject.prototype)\n    ...     def provide_foo(self):\n    ...         return object()\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> some_class_1 = obj_graph.provide(someclass)\n    >>> some_class_2 = obj_graph.provide(someclass)\n    >>> print some_class_1.foo is some_class_2.foo\n    false\n    >>>\n\nif a binding specifies no scope explicitly, then it is in singleton scope.\nimplicit class bindings are always in singleton scope.\n\nmemoization of class bindings works at the class level, not at the binding key\nlevel.  this means that, if you bind two arg names (or the same arg name with\ntwo different annotations) to the same class, and the class is in a memoizing\nscope, then the same class instance will be provided when you inject the\ndifferent arg names.\n\n.. code-block:: python\n\n    >>> class injectedclass(object):\n    ...     pass\n    ...\n    >>> class someobject(object):\n    ...     def __init__(self, foo, bar):\n    ...         self.foo = foo\n    ...         self.bar = bar\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_class=injectedclass)\n    ...         bind('bar', to_class=injectedclass)\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[somebindingspec()])\n    >>> some_object = obj_graph.provide(someobject)\n    >>> print some_object.foo is some_object.bar\n    true\n    >>>\n\npinject memoizes class bindings this way because this is more likely to be\nwhat you mean if you bind two different arg names to the same class in\nsingleton scope: you want only one instance of the class, even though it may\nbe injected in multiple places.\n\nprovider bindings\n=================\n\nsometimes, you need to inject not just a single instance of some class, but\nrather you need to inject the ability to create instances on demand.\n(clearly, this is most useful when the binding you're using is not in the\nsingleton scope, otherwise you'll always get the same instance, and you may as\nwell just inject that..)\n\nyou could inject the pinject object graph, but you'd have to do that\ndependency injection manually (pinject doesn't inject itself!), and you'd be\ninjecting a huge set of capabilities when your class really only needs to\ninstantiate objects of one type.\n\nto solve this, pinject creates *provider bindings* for each bound arg name.\nit will look at the arg name for the prefix ``provide_``, and if it finds that\nprefix, it assumes you want to inject a provider function for whatever the\nrest of the arg name is.  for instance, if you have an arg named\n``provide_foo_bar``, then pinject will inject a zero-arg function that, when\ncalled, provides whatever the arg name ``foo_bar`` is bound to.\n\n.. code-block:: python\n\n    >>> class foo(object):\n    ...   def __init__(self):\n    ...     self.forty_two = 42\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('foo', to_class=foo, in_scope=pinject.prototype)\n    ...\n    >>> class needsprovider(object):\n    ...     def __init__(self, provide_foo):\n    ...         self.provide_foo = provide_foo\n    ...\n    >>> obj_graph = pinject.new_object_graph(binding_specs=[somebindingspec()])\n    >>> needs_provider = obj_graph.provide(needsprovider)\n    >>> print needs_provider.provide_foo() is needs_provider.provide_foo()\n    false\n    >>> print needs_provider.provide_foo().forty_two\n    42\n    >>>\n\npinject will always look for the ``provide_`` prefix as a signal to inject a\nprovider function, anywhere it injects dependencies (initializer args, binding\nspec provider methods, etc.).  this does mean that it's quite difficult, say,\nto inject an instance of a class named ``providefoobar`` into an arg named\n``provide_foo_bar``, but assuming you're naming your classes as noun phrases\ninstead of verb phrases, this shouldn't be a problem.\n\nwatch out: don't confuse\n\n* *provider bindings*, which let you inject args named ``provide_something`` with provider functions; and\n* *provider methods*, which are methods of binding specs that provide instances of some arg name.\n\npartial injection\n=================\n\nprovider bindings are useful when you want to create instances of a class on\ndemand.  but a zero arg provider function will always return an instance\nconfigured the same way (within a given scope).  sometimes, you want the\nability to parameterize the provided instances, e.g., based on run-time user\nconfiguration.  you want the ability to create instances where part of the\ninitialization data is provided per-instance at run-time and part of the\ninitialization data is injected as dependencies.\n\nto do this, other dependency injection libraries have you define factory\nclasses.  you inject dependencies into the factory class's initializer\nfunction, and then you call the factory class's creation method with the\nper-instance data.\n\n.. code-block:: python\n\n    >>> class widgetfactory(object):\n    ...     def __init__(self, widget_polisher):\n    ...         self._widget_polisher = widget_polisher\n    ...     def new(self, color):  # normally would contain some non-trivial code...\n    ...         return some_function_of(self._widget_polisher, color)\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def provide_something_with_colored_widgets(self, colors, widget_factory):\n    ...         return somethingwithcoloredwidgets(\n    ...             [widget_factory.new(color) for color in colors])\n    ...\n    >>>\n\nyou can follow this pattern in pinject, but it involves boring boilerplate for\nthe factory class, saving away the initializer-injected dependencies to be\nused in the creation method.  plus, you have to create yet another\n``...factory`` class, which makes you feel like you're programming in java,\nnot python.\n\nas a less repetitive alternative, pinject lets you use *partial injection* on\nthe provider functions returned by provider bindings.  you use the\n``@inject()`` decorator to tell pinject ahead of time which args you expect to\npass directly (vs. automatic injection), and then you pass those args directly\nwhen calling the provider function.\n\n.. code-block:: python\n\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     @pinject.inject(['widget_polisher'])\n    ...     def provide_widget(self, color, widget_polisher):\n    ...         return some_function_of(widget_polisher, color)\n    ...     def provide_something_needing_widgets(self, colors, provide_widget):\n    ...         return somethingneedingwidgets(\n    ...             [provide_widget(color) for color in colors])\n    ...\n    >>>\n\nthe first arg to ``@inject()``, ``arg_names``, specifies which args of the\ndecorated method should be injected as dependencies.  if specified, it must be\na non-empty sequence of names of the decorated method's args.  the remaining\ndecorated method args will be passed directly.\n\nin the example above, note that, although there is a method called\n``provide_widget()`` and an arg of ``provide_something_needing_widgets()``\ncalled ``provide_widget``, these are not exactly the same!  the latter is a\ndependency-injected wrapper around the former.  the wrapper ensures that the\n``color`` arg is passed directly and then injects the ``widget_polisher``\ndependency.\n\nthe ``@inject()`` decorator works to specify args passed directly both for\nprovider bindings to provider methods (as in the example above) and for\nprovider bindings to classes (where you can pass args directly to the\ninitializer, as in the example below).\n\n.. code-block:: python\n\n    >>> class widget(object):\n    ...     @pinject.inject(['widget_polisher'])\n    ...     def __init__(self, color, widget_polisher):\n    ...         pass  # normally something involving color and widget_polisher\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def provide_something_needing_widgets(self, colors, provide_widget):\n    ...         return somethingneedingwidgets(\n    ...             [provide_widget(color) for color in colors])\n    ...\n    >>>\n\nthe ``@inject()`` decorator also takes an ``all_except`` arg.  you can use\nthis, instead of the (first positional) ``arg_names`` arg, if it's clearer and\nmore concise to say which args are *not* injected (i.e., which args are passed\ndirectly).\n\n.. code-block:: python\n\n    >>> class widget(object):\n    ...     # equivalent to @pinject.inject(['widget_polisher']):\n    ...     @pinject.inject(all_except=['color'])\n    ...     def __init__(self, color, widget_polisher):\n    ...         pass  # normally something involving color and widget_polisher\n    ...\n    >>>\n\nif both ``arg_names`` and ``all_except`` are omitted, then all args are\ninjected by pinject, and none are passed directly.  (both ``arg_names`` and\n``all_except`` may not be specified at the same time.)  wildcard positional\nand keyword args (i.e., ``*pargs`` and ``**kwargs``) are always passed\ndirectly, not injected.\n\nif you use ``@inject()`` to mark at least one arg of a provider method (or\ninitializer) as passed directly, then you may no longer directly inject that\nprovider method's corresponding arg name.  you must instead use a provider\nbinding to inject a provider function, and then pass the required direct\narg(s), as in the examples above.\n\ncustom scopes\n=============\n\nif you want to, you can create your own custom scope.  a custom scope is\nuseful when you have some objects that need to be reused (i.e., cached) but\nwhose lifetime is shorter than the entire lifetime of your program.\n\na custom scope is any class that implements the ``scope`` interface.\n\n.. code-block:: python\n\n    class scope(object):\n        def provide(self, binding_key, default_provider_fn):\n            raise notimplementederror()\n\nthe ``binding_key`` passed to ``provide()`` will be an object implementing\n``__eq__()`` and ``__hash__()`` but otherwise opaque (you shouldn't need to\nintrospect it).  you can think of the binding key roughly as encapsulating the\narg name and annotation (if any).  the ``default_provider_fn`` passed to\n``provide()`` is a zero-arg function that, when called, provides an instance\nof whatever should be provided.\n\nthe job of a scope's ``provide()`` function is to return a cached object if\navailable and appropriate, otherwise to return (and possibly cache) the result\nof calling the default provider function.\n\nscopes almost always have other methods that control clearing the scope's\ncache.  for instance, a scope may have \"enter scope\" and \"exit scope\" methods,\nor a single direct \"clear cache\" method.  when passing a custom scope to\npinject, your code should keep a handle to the custom scope and use that\nhandle to clear the scope's cache at the appropriate time.\n\nyou can use one or more custom scopes by passing a map from *scope identifier*\nto scope as the ``id_to_scope`` arg of ``new_object_graph()``.\n\n.. code-block:: python\n\n    >>> class myscope(pinject.scope):\n    ...     def __init__(self):\n    ...         self._cache = {}\n    ...     def provide(self, binding_key, default_provider_fn):\n    ...         if binding_key not in self._cache:\n    ...             self._cache[binding_key] = default_provider_fn()\n    ...         return self._cache[binding_key]\n    ...     def clear(self):\n    ...         self._cache = {}\n    ...\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     @pinject.provides(in_scope='my custom scope')\n    ...     def provide_foo(self):\n    ...         return object()\n    ...\n    >>> my_scope = myscope()\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[somebindingspec()],\n    ...     id_to_scope={'my custom scope': my_scope})\n    >>> some_class_1 = obj_graph.provide(someclass)\n    >>> some_class_2 = obj_graph.provide(someclass)\n    >>> my_scope.clear()\n    >>> some_class_3 = obj_graph.provide(someclass)\n    >>> print some_class_1.foo is some_class_2.foo\n    true\n    >>> print some_class_2.foo is some_class_3.foo\n    false\n    >>>\n\na scope identifier can be any object implementing ``__eq__()`` and\n``__hash__()``.\n\nif you plan to use pinject in a multi-threaded environment (and even if you\ndon't plan to now but may some day), you should make your custom scope\nthread-safe.  the example custom scope above could be trivially (but more\nverbosely) rewritten to be thread-safe, as in the example below.  the lock is\nreentrant so that something in ``myscope`` can be injected into something else\nin ``myscope``.\n\n.. code-block:: python\n\n    >>> class myscope(pinject.scope):\n    ...     def __init__(self):\n    ...         self._cache = {}\n    ...         self._rlock = threading.rlock()\n    ...     def provide(self, binding_key, default_provider_fn):\n    ...         with self._rlock:\n    ...             if binding_key not in self._cache:\n    ...                 self._cache[binding_key] = default_provider_fn()\n    ...             return self._cache[binding_key]\n    ...     def clear(self):\n    ...         with self._rlock:\n    ...             self._cache = {}\n    >>>\n\nscope accessibility\n===================\n\nto prevent yourself from injecting objects where they don't belong, you may\nwant to validate one object being injected into another w.r.t. scope.\n\nfor instance, you may have created a custom scope for http requests handled by\nyour program.  objects in request scope would be cached for the duration of a\nsingle http request.  you may want to verify that objects in request scope\nnever get injected into objects in singleton scope.  such an injection is\nlikely not to make semantic sense, since it would make something tied to one\nhttp request be used for the duration of your program.\n\npinject lets you pass a validation function as the\n``is_scope_usable_from_scope`` arg to ``new_object_graph()``.  this function\ntakes two scope identifiers and returns ``true`` iff an object in the first\nscope can be injected into an object of the second scope.\n\n.. code-block:: python\n\n    >>> class requestscope(pinject.scope):\n    ...     def start_request(self):\n    ...         self._cache = {}\n    ...     def provide(self, binding_key, default_provider_fn):\n    ...         if binding_key not in self._cache:\n    ...             self._cache[binding_key] = default_provider_fn()\n    ...         return self._cache[binding_key]\n    ...\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     @pinject.provides(in_scope=pinject.singleton)\n    ...     def provide_foo(bar):\n    ...         return 'foo-' + bar\n    ...     @pinject.provides(in_scope='request scope')\n    ...     def provide_bar():\n    ...         return '-bar'\n    ...\n    >>> def is_usable(scope_id_inner, scope_id_outer):\n    ...     return not (scope_id_inner == 'request scope' and\n    ...                 scope_id_outer == scoping.singleton)\n    ...\n    >>> my_request_scope = requestscope()\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[somebindingspec()],\n    ...     id_to_scope={'request scope': my_request_scope},\n    ...     is_scope_usable_from_scope=is_usable)\n    >>> my_request_scope.start_request()\n    >>> # obj_graph.provide(someclass)  # would raise a baddependencyscopeerror\n    >>>\n\nthe default scope accessibility validator allows objects from any scope to be\ninjected into objects from any other scope.\n\nchanging naming conventions\n===========================\n\nif your code follows pep8 naming coventions, then you're likely happy with the\ndefault implicit bindings (where the class ``foobar`` gets bound to the arg\nname ``foo_bar``) and where ``provide_foo_bar()`` is a binding spec's provider\nmethod for the arg name ``foo_bar``.\n\nbut if not, read on!\n\ncustomizing implicit bindings\n-----------------------------\n\n``new_object_graph()`` takes a ``get_arg_names_from_class_name`` arg.  this is\nthe function that is used to determine implicit class bindings.  this function\ntakes in a class name (e.g., ``foobar``) and returns the arg names to which\nthat class should be implicitly bound (e.g., ``['foo_bar']``).  its default\nbehavior is described in the \"implicit class bindings\" section above, but that\ndefault behavior can be overridden.\n\nfor instance, suppose that your code uses a library that names many classes\nwith the leading letter x (e.g., ``xfoobar``), and you'd like to be able to\nbind that to a corresponding arg name without the leading x (e.g.,\n``foo_bar``).\n\n.. code-block:: python\n\n    >>> import re\n    >>> def custom_get_arg_names(class_name):\n    ...     stripped_class_name = re.sub('^_?x?', '', class_name)\n    ...     return [re.sub('(?!^)([a-z]+)', r'_\\1', stripped_class_name).lower()]\n    ...\n    >>> print custom_get_arg_names('xfoobar')\n    ['foo_bar']\n    >>> print custom_get_arg_names('xlibraryclass')\n    ['library_class']\n    >>> class outerclass(object):\n    ...     def __init__(self, library_class):\n    ...         self.library_class = library_class\n    ...\n    >>> class xlibraryclass(object):\n    ...     def __init__(self):\n    ...         self.forty_two = 42\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     get_arg_names_from_class_name=custom_get_arg_names)\n    >>> outer_class = obj_graph.provide(outerclass)\n    >>> print outer_class.library_class.forty_two\n    42\n    >>>\n\nthe function passed as the ``get_arg_names_from_class_name`` arg to\n``new_object_graph()`` can return as many or as few arg names as it wants.  if\nit always returns the empty list (i.e., if it is ``lambda _: []``), then that\ndisables implicit class bindings.\n\ncustomizing binding spec method names\n-------------------------------------\n\nthe standard binding spec methods to configure bindings and declare\ndependencies are named ``configure`` and ``dependencies``, by default.  if you\nneed to, you can change their names by passing ``configure_method_name``\nand/or ``dependencies_method_name`` as args to ``new_object_graph()``.\n\n.. code-block:: python\n\n    >>> class nonstandardbindingspec(pinject.bindingspec):\n    ...     def configure(self, bind):\n    ...         bind('forty_two', to_instance=42)\n    ...\n    >>> class someclass(object):\n    ...     def __init__(self, forty_two):\n    ...         self.forty_two = forty_two\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[nonstandardbindingspec()],\n    ...     configure_method_name='configure')\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.forty_two\n    42\n    >>>\n\ncustomizing provider method names\n---------------------------------\n\n``new_object_graph()`` takes a ``get_arg_names_from_provider_fn_name`` arg.\nthis is the function that is used to identify provider methods on binding\nspecs.  this function takes in the name of a potential provider method (e.g.,\n``provide_foo_bar``) and returns the arg names for which the provider method\nis a provider, if any (e.g., ``['foo_bar']``).  its default behavior is\ndescribed in the \"provider methods\" section above, but that default behavior\ncan be overridden.\n\nfor instance, suppose that you work for a certain large corporation whose\npython style guide makes you name functions in ``camelcase``, and so you need\nto name the provider method for the arg name ``foo_bar`` more like\n``providefoobar`` than ``provide_foo_bar``.\n\n.. code-block:: python\n\n    >>> import re\n    >>> def customgetargnames(provider_fn_name):\n    ...     if provider_fn_name.startswith('provide'):\n    ...         provided_camelcase = provider_fn_name[len('provide'):]\n    ...         return [re.sub('(?!^)([a-z]+)', r'_\\1', provided_camelcase).lower()]\n    ...     else:\n    ...         return []\n    ...\n    >>> print customgetargnames('providefoobar')\n    ['foo_bar']\n    >>> print customgetargnames('providefoo')\n    ['foo']\n    >>> class someclass(object):\n    ...     def __init__(self, foo):\n    ...         self.foo = foo\n    ...\n    >>> class somebindingspec(pinject.bindingspec):\n    ...     def providefoo(self):\n    ...         return 'some-foo'\n    ...\n    >>> obj_graph = pinject.new_object_graph(\n    ...     binding_specs=[somebindingspec()],\n    ...     get_arg_names_from_provider_fn_name=customgetargnames)\n    >>> some_class = obj_graph.provide(someclass)\n    >>> print some_class.foo\n    'some-foo'\n    >>>\n\nthe function passed as the ``get_arg_names_from_provider_fn_name`` arg to\n``new_object_graph()`` can return as many or as few arg names as it wants.  if\nit returns an empty list, then that potential provider method is assumed not\nactually to be a provider method.\n\nmiscellaneous\n=============\n\npinject raises helpful exceptions whose messages include the file and line\nnumber of errors.  so, pinject by default will shorten the stack trace of\nexceptions that it raises, so that you don't see the many levels of function\ncalls within the pinject library.\n\nin some situations, though, the complete stack trace is helpful, e.g., when\ndebugging pinject, or when your code calls pinject, which calls back into your\ncode, which calls back into pinject.  in such cases, to disable exception\nstack shortening, you can pass ``use_short_stack_traces=false`` to\n``new_object_graph()``.\n\ngotchas\n=======\n\npinject has a few things to watch out for.\n\nthread safety\n-------------\n\npinject's default scope is ``singleton``.  if you have a multi-threaded\nprogram, it's likely that some or all of the things that pinject provides from\nsingleton scope will be used in multiple threads.  so, it's important that you\nensure that such classes are thread-safe.\n\nsimilarly, it's important that your custom scope classes are thread-safe.\neven if the objects they provide are only used in a single thread, it may be\nthat the object graph (and therefore the scope itself) will be used\nsimultaneously in multiple threads.\n\nremember to make locks re-entrant on your custom scope classes, or otherwise\ndeal with one object in your custom scope trying to inject another object in\nyour custom scope.\n\nthat's it for gotchas, for now.\n\ncondensed summary\n=================\n\nif you are already familiar with dependency injection libraries such as guice,\nthis section gives you a condensed high level summary of pinject and how it\nmight be similar to or different than other dependency injection libraries.\n(if you don't understand it, no problem.  the rest of the documentation covers\neverything listed here.)\n\n* pinject uses code and decorators to configure injection, not a separate config file.\n* bindings are keyed by arg name, (not class type, since python is dynamically typed).\n* pinject automatically creates bindings to ``some_class`` arg names for ``someclass`` classes.\n* you can ask pinject only to create bindings from binding specs and classes whose ``__init__()`` is marked with ``@inject()``.\n* a binding spec is a class that creates explicit bindings.\n* a binding spec can bind arg names to classes or to instances.\n* a binding spec can bind arg names ``foo`` to provider methods ``provide_foo()``.\n* binding specs can depend on (i.e., include) other binding specs.\n* you can annotate args and bindings to distinguish among args/bindings for the same arg name.\n* pinject has two built-in scopes: \"singleton\" (always memoized; the default) and \"prototype\" (never memoized).\n* you can define custom scopes, and you can configure which scopes are accessible from which other scopes.\n* pinject doesn't allow injecting ``none`` by default, but you can turn off that check.\n\nchangelog\n=========\n\nv0.13: master\n\nv0.12: 28 nov, 2018\n\n* support python 3\n* add two maintainers: @trein and @huan\n\nv0.10.2:\n\n* fixed bug: allows binding specs containing only provider methods.\n\nv0.10.1:\n\n* fixed bug: allows omitting custom named ``configure()`` binding spec method.\n\nv0.10:\n\n* added default ``__eq__()`` to ``bindingspec``, so that dag binding spec dependencies can have equal but not identical dependencies.\n* allowed customizing ``configure()`` and ``dependencies()`` binding spec method names.\n* deprecated ``@injectable`` in favor of ``@inject``.\n* added partial injection.\n* added ``require`` arg to allow binding spec ``configure`` methods to declare but not define bindings.\n* sped up tests (and probably general functionality) by 10x.\n* documented more design decisions.\n* added ``@copy_args_to_internal_fields`` and ``@copy_args_to_public_fields``.\n* renamed ``injectabledecoratorappliedtononiniterror`` to ``decoratorappliedtononiniterror``.\n\nv0.9:\n\n* added validation of python types of public args.\n* improved error messages for all pinject-raised exceptions.\n* added ``use_short_stack_traces`` arg to ``new_object_graph()``.\n* allowed multiple ``@provides`` on single provider method.\n\nv0.8:\n\n* first released version.\n\nmaintainers\n===========\n\n* kurt steinkraus @kurt\n* guilherme trein @trein\n* huan li @huan\n\nlicense\n=======\napache-2.0\n\npinject and google\n==================\n\nthough google owns this project's copyright, this project is not an official\ngoogle product.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache license 2.0",
  "name": "pinject",
  "package_url": "https://pypi.org/project/pinject/",
  "project_url": "https://pypi.org/project/pinject/",
  "project_urls": {
    "Homepage": "https://github.com/google/pinject"
  },
  "release_url": "https://pypi.org/project/pinject/0.14.1/",
  "requires_dist": [
    "six (>=1.7.3)",
    "decorator (>=4.3.0)"
  ],
  "requires_python": "",
  "summary": "a pythonic dependency injection library",
  "version": "0.14.1",
  "releases": [],
  "developers": [
    "kurt@steinkraus.us",
    "kurt_steinkraus"
  ],
  "kwds": "pinject dependency_injection objectgraph fury python",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_pinject",
  "homepage": "https://github.com/google/pinject",
  "release_count": 14,
  "dependency_ids": [
    "pypi_decorator",
    "pypi_six"
  ]
}