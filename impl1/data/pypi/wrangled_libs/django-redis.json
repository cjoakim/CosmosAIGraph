{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: django :: 3.2",
    "framework :: django :: 4.0",
    "framework :: django :: 4.1",
    "framework :: django :: 4.2",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries",
    "topic :: utilities"
  ],
  "description": "==============================\nredis cache backend for django\n==============================\n\n.. image:: https://jazzband.co/static/img/badge.svg\n    :target: https://jazzband.co/\n    :alt: jazzband\n\n.. image:: https://github.com/jazzband/django-redis/actions/workflows/ci.yml/badge.svg\n   :target: https://github.com/jazzband/django-redis/actions/workflows/ci.yml\n   :alt: github actions\n\n.. image:: https://codecov.io/gh/jazzband/django-redis/branch/master/graph/badge.svg\n   :target: https://codecov.io/gh/jazzband/django-redis\n   :alt: coverage\n\n.. image:: https://img.shields.io/pypi/v/django-redis.svg?style=flat\n    :target: https://pypi.org/project/django-redis/\n\nthis is a `jazzband <https://jazzband.co>`_ project. by contributing you agree\nto abide by the `contributor code of conduct\n<https://jazzband.co/about/conduct>`_ and follow the `guidelines\n<https://jazzband.co/about/guidelines>`_.\n\nintroduction\n------------\n\ndjango-redis is a bsd licensed, full featured redis cache and session backend\nfor django.\n\nwhy use django-redis?\n~~~~~~~~~~~~~~~~~~~~~\n\n- uses native redis-py url notation connection strings\n- pluggable clients\n- pluggable parsers\n- pluggable serializers\n- primary/secondary support in the default client\n- comprehensive test suite\n- used in production in several projects as cache and session storage\n- supports infinite timeouts\n- facilities for raw access to redis client/connection pool\n- highly configurable (can emulate memcached exception behavior, for example)\n- unix sockets supported by default\n\nrequirements\n~~~~~~~~~~~~\n\n- `python`_ 3.6+\n- `django`_ 2.2+\n- `redis-py`_ 3.0+\n- `redis server`_ 2.8+\n\n.. _python: https://www.python.org/downloads/\n.. _django: https://www.djangoproject.com/download/\n.. _redis-py: https://pypi.org/project/redis/\n.. _redis server: https://redis.io/download\n\nuser guide\n----------\n\ninstallation\n~~~~~~~~~~~~\n\ninstall with pip:\n\n.. code-block:: console\n\n    $ python -m pip install django-redis\n\nconfigure as cache backend\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nto start using django-redis, you should change your django cache settings to\nsomething like:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n            }\n        }\n    }\n\ndjango-redis uses the redis-py native url notation for connection strings, it\nallows better interoperability and has a connection string in more \"standard\"\nway. some examples:\n\n- ``redis://[[username]:[password]]@localhost:6379/0``\n- ``rediss://[[username]:[password]]@localhost:6379/0``\n- ``unix://[[username]:[password]]@/path/to/socket.sock?db=0``\n\nthree url schemes are supported:\n\n- ``redis://``: creates a normal tcp socket connection\n- ``rediss://``: creates a ssl wrapped tcp socket connection\n- ``unix://`` creates a unix domain socket connection\n\nthere are several ways to specify a database number:\n\n- a ``db`` querystring option, e.g. ``redis://localhost?db=0``\n- if using the ``redis://`` scheme, the path argument of the url, e.g.\n  ``redis://localhost/0``\n\nwhen using `redis' acls <https://redis.io/topics/acl>`_, you will need to add the\nusername to the url (and provide the password with the cache ``options``).\nthe login for the user ``django`` would look like this:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://django@localhost:6379/0\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"password\": \"mysecret\"\n            }\n        }\n    }\n\nan alternative would be write both username and password into the url:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://django:mysecret@localhost:6379/0\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n            }\n        }\n    }\n\nin some circumstances the password you should use to connect redis\nis not url-safe, in this case you can escape it or just use the\nconvenience option in ``options`` dict:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"password\": \"mysecret\"\n            }\n        }\n    }\n\ntake care, that this option does not overwrites the password in the uri, so if\nyou have set the password in the uri, this settings will be ignored.\n\nconfigure as session backend\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndjango can by default use any cache backend as session backend and you benefit\nfrom that by using django-redis as backend for session storage without\ninstalling any additional backends:\n\n.. code-block:: python\n\n    session_engine = \"django.contrib.sessions.backends.cache\"\n    session_cache_alias = \"default\"\n\ntesting with django-redis\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndjango-redis supports customizing the underlying redis client (see \"pluggable\nclients\"). this can be used for testing purposes.\n\nin case you want to flush all data from the cache after a test, add the\nfollowing lines to your test class:\n\n.. code-block:: python\n\n    from django_redis import get_redis_connection\n\n    def teardown(self):\n        get_redis_connection(\"default\").flushall()\n\nadvanced usage\n--------------\n\npickle version\n~~~~~~~~~~~~~~\n\nfor almost all values, django-redis uses pickle to serialize objects.\n\nthe ``pickle.default_protocol`` version of pickle is used by default to ensure safe upgrades and compatibility across python versions.\nif you want set a concrete version, you can do it, using ``pickle_version`` option:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"pickle_version\": -1  # will use highest protocol version available\n            }\n        }\n    }\n\nsocket timeout\n~~~~~~~~~~~~~~\n\nsocket timeout can be set using ``socket_timeout`` and\n``socket_connect_timeout`` options:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"socket_connect_timeout\": 5,  # seconds\n                \"socket_timeout\": 5,  # seconds\n            }\n        }\n    }\n\n``socket_connect_timeout`` is the timeout for the connection to be established\nand ``socket_timeout`` is the timeout for read and write operations after the\nconnection is established.\n\ncompression support\n~~~~~~~~~~~~~~~~~~~\n\ndjango-redis comes with compression support out of the box, but is deactivated\nby default. you can activate it setting up a concrete backend:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"compressor\": \"django_redis.compressors.zlib.zlibcompressor\",\n            }\n        }\n    }\n\nlet see an example, of how make it work with *lzma* compression format:\n\n.. code-block:: python\n\n    import lzma\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"compressor\": \"django_redis.compressors.lzma.lzmacompressor\",\n            }\n        }\n    }\n\n*lz4* compression support (requires the lz4 library):\n\n.. code-block:: python\n\n    import lz4\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"compressor\": \"django_redis.compressors.lz4.lz4compressor\",\n            }\n        }\n    }\n\n*zstandard (zstd)* compression support (requires the pyzstd library):\n\n.. code-block:: python\n\n    import pyzstd\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"compressor\": \"django_redis.compressors.zstd.zstdcompressor\",\n            }\n        }\n    }\n\nmemcached exceptions behavior\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin some situations, when redis is only used for cache, you do not want\nexceptions when redis is down. this is default behavior in the memcached\nbackend and it can be emulated in django-redis.\n\nfor setup memcached like behaviour (ignore connection exceptions), you should\nset ``ignore_exceptions`` settings on your cache configuration:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"ignore_exceptions\": true,\n            }\n        }\n    }\n\nalso, you can apply the same settings to all configured caches, you can set the global flag in\nyour settings:\n\n.. code-block:: python\n\n    django_redis_ignore_exceptions = true\n\nlog ignored exceptions\n~~~~~~~~~~~~~~~~~~~~~~\n\nwhen ignoring exceptions with ``ignore_exceptions`` or\n``django_redis_ignore_exceptions``, you may optionally log exceptions using the\nglobal variable ``django_redis_log_ignored_exceptions`` in your settings file::\n\n    django_redis_log_ignored_exceptions = true\n\nif you wish to specify the logger in which the exceptions are output, simply\nset the global variable ``django_redis_logger`` to the string name and/or path\nof the desired logger. this will default to ``__name__`` if no logger is\nspecified and ``django_redis_log_ignored_exceptions`` is ``true``::\n\n    django_redis_logger = 'some.specified.logger'\n\ninfinite timeout\n~~~~~~~~~~~~~~~~\n\ndjango-redis comes with infinite timeouts support out of the box. and it\nbehaves in same way as django backend contract specifies:\n\n- ``timeout=0`` expires the value immediately.\n- ``timeout=none`` infinite timeout\n\n.. code-block:: python\n\n    cache.set(\"key\", \"value\", timeout=none)\n\nget ttl (time-to-live) from key\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwith redis, you can access to ttl of any stored key, for it, django-redis\nexposes ``ttl`` function.\n\nit returns:\n\n- 0 if key does not exists (or already expired).\n- none for keys that exists but does not have any expiration.\n- ttl value for any volatile key (any key that has expiration).\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.set(\"foo\", \"value\", timeout=25)\n    >>> cache.ttl(\"foo\")\n    25\n    >>> cache.ttl(\"not-existent\")\n    0\n\nwith redis, you can access to ttl of any stored key in milliseconds, for it, django-redis\nexposes ``pttl`` function.\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.set(\"foo\", \"value\", timeout=25)\n    >>> cache.pttl(\"foo\")\n    25000\n    >>> cache.pttl(\"not-existent\")\n    0\n\nexpire & persist\n~~~~~~~~~~~~~~~~\n\nadditionally to the simple ttl query, you can send persist a concrete key or\nspecify a new expiration timeout using the ``persist`` and ``expire`` methods:\n\n.. code-block:: pycon\n\n    >>> cache.set(\"foo\", \"bar\", timeout=22)\n    >>> cache.ttl(\"foo\")\n    22\n    >>> cache.persist(\"foo\")\n    true\n    >>> cache.ttl(\"foo\")\n    none\n\n.. code-block:: pycon\n\n    >>> cache.set(\"foo\", \"bar\", timeout=22)\n    >>> cache.expire(\"foo\", timeout=5)\n    true\n    >>> cache.ttl(\"foo\")\n    5\n\nthe ``expire_at`` method can be used to make the key expire at a specific moment in time.\n\n.. code-block:: pycon\n\n    >>> cache.set(\"foo\", \"bar\", timeout=22)\n    >>> cache.expire_at(\"foo\", datetime.now() + timedelta(hours=1))\n    true\n    >>> cache.ttl(\"foo\")\n    3600\n\nthe ``pexpire_at`` method can be used to make the key expire at a specific moment in time with milliseconds precision:\n\n.. code-block:: pycon\n\n    >>> cache.set(\"foo\", \"bar\", timeout=22)\n    >>> cache.pexpire_at(\"foo\", datetime.now() + timedelta(milliseconds=900, hours=1))\n    true\n    >>> cache.ttl(\"foo\")\n    3601\n    >>> cache.pttl(\"foo\")\n    3600900\n\nthe ``pexpire`` method can be used to provide millisecond precision:\n\n.. code-block:: pycon\n\n    >>> cache.set(\"foo\", \"bar\", timeout=22)\n    >>> cache.pexpire(\"foo\", timeout=5500)\n    true\n    >>> cache.pttl(\"foo\")\n    5500\n\nlocks\n~~~~~\n\nit also supports the redis ability to create redis distributed named locks. the\nlock interface is identical to the ``threading.lock`` so you can use it as\nreplacement.\n\n.. code-block:: python\n\n    with cache.lock(\"somekey\"):\n        do_some_thing()\n\nscan & delete keys in bulk\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndjango-redis comes with some additional methods that help with searching or\ndeleting keys using glob patterns.\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.keys(\"foo_*\")\n    [\"foo_1\", \"foo_2\"]\n\na simple search like this will return all matched values. in databases with a\nlarge number of keys this isn't suitable method. instead, you can use the\n``iter_keys`` function that works like the ``keys`` function but uses redis\nserver side cursors. calling ``iter_keys`` will return a generator that you can\nthen iterate over efficiently.\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.iter_keys(\"foo_*\")\n    <generator object algo at 0x7ffa9c2713a8>\n    >>> next(cache.iter_keys(\"foo_*\"))\n    \"foo_1\"\n\nfor deleting keys, you should use ``delete_pattern`` which has the same glob\npattern syntax as the ``keys`` function and returns the number of deleted keys.\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.delete_pattern(\"foo_*\")\n\nto achieve the best performance while deleting many keys, you should set ``django_redis_scan_itersize`` to a relatively\nhigh number (e.g., 100_000) by default in django settings or pass it directly to the ``delete_pattern``.\n\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.delete_pattern(\"foo_*\", itersize=100_000)\n\nredis native commands\n~~~~~~~~~~~~~~~~~~~~~\n\ndjango-redis has limited support for some redis atomic operations, such as the\ncommands ``setnx`` and ``incr``.\n\nyou can use the ``setnx`` command through the backend ``set()`` method with the\n``nx`` parameter:\n\n.. code-block:: pycon\n\n    >>> from django.core.cache import cache\n    >>> cache.set(\"key\", \"value1\", nx=true)\n    true\n    >>> cache.set(\"key\", \"value2\", nx=true)\n    false\n    >>> cache.get(\"key\")\n    \"value1\"\n\nalso, the ``incr`` and ``decr`` methods use redis atomic operations when the\nvalue that a key contains is suitable for it.\n\nraw client access\n~~~~~~~~~~~~~~~~~\n\nin some situations your application requires access to a raw redis client to\nuse some advanced features that aren't exposed by the django cache interface.\nto avoid storing another setting for creating a raw connection, django-redis\nexposes functions with which you can obtain a raw client reusing the cache\nconnection string: ``get_redis_connection(alias)``.\n\n.. code-block:: pycon\n\n    >>> from django_redis import get_redis_connection\n    >>> con = get_redis_connection(\"default\")\n    >>> con\n    <redis.client.redis object at 0x2dc4510>\n\nwarning: not all pluggable clients support this feature.\n\nconnection pools\n~~~~~~~~~~~~~~~~\n\nbehind the scenes, django-redis uses the underlying redis-py connection pool\nimplementation, and exposes a simple way to configure it. alternatively, you\ncan directly customize a connection/connection pool creation for a backend.\n\nthe default redis-py behavior is to not close connections, recycling them when\npossible.\n\nconfigure default connection pool\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe default connection pool is simple. for example, you can customize the\nmaximum number of connections in the pool by setting ``connection_pool_kwargs``\nin the ``caches`` setting:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            # ...\n            \"options\": {\n                \"connection_pool_kwargs\": {\"max_connections\": 100}\n            }\n        }\n    }\n\nyou can verify how many connections the pool has opened with the following\nsnippet:\n\n.. code-block:: python\n\n    from django_redis import get_redis_connection\n\n    r = get_redis_connection(\"default\")  # use the name you have defined for redis in settings.caches\n    connection_pool = r.connection_pool\n    print(\"created connections so far: %d\" % connection_pool._created_connections)\n\nsince the default connection pool passes all keyword arguments it doesn't use\nto its connections, you can also customize the connections that the pool makes\nby adding those options to ``connection_pool_kwargs``:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            # ...\n            \"options\": {\n                \"connection_pool_kwargs\": {\"max_connections\": 100, \"retry_on_timeout\": true}\n            }\n        }\n    }\n\nuse your own connection pool subclass\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nsometimes you want to use your own subclass of the connection pool. this is\npossible with django-redis using the ``connection_pool_class`` parameter in the\nbackend options.\n\n.. code-block:: python\n\n    from redis.connection import connectionpool\n\n    class myownpool(connectionpool):\n        # just doing nothing, only for example purpose\n        pass\n\n.. code-block:: python\n\n    # omitting all backend declaration boilerplate code.\n\n    \"options\": {\n        \"connection_pool_class\": \"myproj.mypool.myownpool\",\n    }\n\ncustomize connection factory\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nif none of the previous methods satisfies you, you can get in the middle of the\ndjango-redis connection factory process and customize or completely rewrite it.\n\nby default, django-redis creates connections through the\n``django_redis.pool.connectionfactory`` class that is specified in the global\ndjango setting ``django_redis_connection_factory``.\n\n.. code-block:: python\n\n    class connectionfactory(object):\n        def get_connection_pool(self, params: dict):\n            # given connection parameters in the `params` argument, return new\n            # connection pool. it should be overwritten if you want do\n            # something before/after creating the connection pool, or return\n            # your own connection pool.\n            pass\n\n        def get_connection(self, params: dict):\n            # given connection parameters in the `params` argument, return a\n            # new connection. it should be overwritten if you want to do\n            # something before/after creating a new connection. the default\n            # implementation uses `get_connection_pool` to obtain a pool and\n            # create a new connection in the newly obtained pool.\n            pass\n\n        def get_or_create_connection_pool(self, params: dict):\n            # this is a high layer on top of `get_connection_pool` for\n            # implementing a cache of created connection pools. it should be\n            # overwritten if you want change the default behavior.\n            pass\n\n        def make_connection_params(self, url: str) -> dict:\n            # the responsibility of this method is to convert basic connection\n            # parameters and other settings to fully connection pool ready\n            # connection parameters.\n            pass\n\n        def connect(self, url: str):\n            # this is really a public api and entry point for this factory\n            # class. this encapsulates the main logic of creating the\n            # previously mentioned `params` using `make_connection_params` and\n            # creating a new connection using the `get_connection` method.\n            pass\n\nuse the sentinel connection factory\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nin order to facilitate using `redis sentinels`_, django-redis comes with a\nbuilt in sentinel connection factory, which creates sentinel connection pools.\nin order to enable this functionality you should add the following:\n\n\n.. code-block:: python\n\n    # enable the alternate connection factory.\n    django_redis_connection_factory = 'django_redis.pool.sentinelconnectionfactory'\n\n    # these sentinels are shared between all the examples, and are passed\n    # directly to redis sentinel. these can also be defined inline.\n    sentinels = [\n        ('sentinel-1', 26379),\n        ('sentinel-2', 26379),\n        ('sentinel-3', 26379),\n    ]\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            # the hostname in location is the primary (service / master) name\n            \"location\": \"redis://service_name/db\",\n            \"options\": {\n                # while the default client will work, this will check you\n                # have configured things correctly, and also create a\n                # primary and replica pool for the service specified by\n                # location rather than requiring two urls.\n                \"client_class\": \"django_redis.client.sentinelclient\",\n\n                # sentinels which are passed directly to redis sentinel.\n                \"sentinels\": sentinels,\n\n                # kwargs for redis sentinel (optional).\n                \"sentinel_kwargs\": {},\n\n                # you can still override the connection pool (optional).\n                \"connection_pool_class\": \"redis.sentinel.sentinelconnectionpool\",\n            },\n        },\n\n        # a minimal example using the sentinelclient.\n        \"minimal\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n\n            # the sentinelclient will use this location for both the primaries\n            # and replicas.\n            \"location\": \"redis://minimal_service_name/db\",\n\n            \"options\": {\n                \"client_class\": \"django_redis.client.sentinelclient\",\n                \"sentinels\": sentinels,\n            },\n        },\n\n        # a minimal example using the defaultclient.\n        \"other\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": [\n                # the defaultclient is [primary, replicas...], but with the\n                # sentinelconnectionpool it only requires one \"is_master=0\".\n                \"redis://other_service_name/db?is_master=1\",\n                \"redis://other_service_name/db?is_master=0\",\n            ],\n            \"options\": {\"sentinels\": sentinels},\n        },\n\n        # a minimal example only using only replicas in read only mode (and\n        # the defaultclient).\n        \"readonly\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://readonly_service_name/db?is_master=0\",\n            \"options\": {\"sentinels\": sentinels},\n        },\n    }\n\nit is also possible to set some caches as sentinels and some as not:\n\n.. code-block:: python\n\n    sentinels = [\n        ('sentinel-1', 26379),\n        ('sentinel-2', 26379),\n        ('sentinel-3', 26379),\n    ]\n    caches = {\n        \"sentinel\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://service_name/db\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.sentinelclient\",\n                \"sentinels\": sentinels,\n                \"connection_pool_class\": \"redis.sentinel.sentinelconnectionpool\",\n                \"connection_factory\": \"django_redis.pool.sentinelconnectionfactory\",\n            },\n        },\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n            },\n        },\n    }\n\n.. _redis sentinels: https://redis.io/topics/sentinel\n\npluggable parsers\n~~~~~~~~~~~~~~~~~\n\nredis-py (the python redis client used by django-redis) comes with a pure\npython redis parser that works very well for most common task, but if you want\nsome performance boost, you can use hiredis.\n\nhiredis is a redis client written in c and it has its own parser that can be\nused with django-redis.\n\n.. code-block:: python\n\n    \"options\": {\n        \"parser_class\": \"redis.connection.hiredisparser\",\n    }\n\nnote: if using version 5 of redis-py, use ``\"redis.connection._hiredisparser\"`` for the ``parser_class`` due to an internal rename of classes within that package.\n\npluggable clients\n~~~~~~~~~~~~~~~~~\n\ndjango-redis is designed for to be very flexible and very configurable. for it,\nit exposes a pluggable backends that make easy extend the default behavior, and\nit comes with few ones out the box.\n\ndefault client\n^^^^^^^^^^^^^^\n\nalmost all about the default client is explained, with one exception: the\ndefault client comes with replication support.\n\nto connect to a redis replication setup, you should change the ``location`` to\nsomething like:\n\n.. code-block:: python\n\n    \"location\": [\n        \"redis://127.0.0.1:6379/1\",\n        \"redis://127.0.0.1:6378/1\",\n    ]\n\nthe first connection string represents the primary server and the rest to\nreplica servers.\n\nwarning: replication setup is not heavily tested in production environments.\n\nshard client\n^^^^^^^^^^^^\n\nthis pluggable client implements client-side sharding. it inherits almost all\nfunctionality from the default client. to use it, change your cache settings to\nsomething like this:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": [\n                \"redis://127.0.0.1:6379/1\",\n                \"redis://127.0.0.1:6379/2\",\n            ],\n            \"options\": {\n                \"client_class\": \"django_redis.client.shardclient\",\n            }\n        }\n    }\n\nwarning: shard client is still experimental, so be careful when using it in\nproduction environments.\n\nherd client\n^^^^^^^^^^^\n\nthis pluggable client helps dealing with the thundering herd problem. you can read more about it\non link: `wikipedia <https://en.wikipedia.org/wiki/thundering_herd_problem>`_\n\nlike previous pluggable clients, it inherits all functionality from the default client, adding some\nadditional methods for getting/setting keys.\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.herdclient\",\n            }\n        }\n    }\n\nthis client exposes additional settings:\n\n- ``cache_herd_timeout``: set default herd timeout. (default value: 60s)\n\npluggable serializer\n~~~~~~~~~~~~~~~~~~~~\n\nthe pluggable clients serialize data before sending it to the server. by\ndefault, django-redis serializes the data using the python ``pickle`` module.\nthis is very flexible and can handle a large range of object types.\n\nto serialize using json instead, the serializer ``jsonserializer`` is also\navailable.\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"serializer\": \"django_redis.serializers.json.jsonserializer\",\n            }\n        }\n    }\n\nthere's also support for serialization using `msgpack`_ (that requires the\nmsgpack library):\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"serializer\": \"django_redis.serializers.msgpack.msgpackserializer\",\n            }\n        }\n    }\n\n.. _msgpack: https://msgpack.org/\n\npluggable redis client\n~~~~~~~~~~~~~~~~~~~~~~\n\ndjango-redis uses the redis client ``redis.client.strictclient`` by default. it\nis possible to use an alternative client.\n\nyou can customize the client used by setting ``redis_client_class`` in the\n``caches`` setting. optionally, you can provide arguments to this class by\nsetting ``redis_client_kwargs``.\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"options\": {\n                \"redis_client_class\": \"my.module.clientclass\",\n                \"redis_client_kwargs\": {\"some_setting\": true},\n            }\n        }\n    }\n\n\nclosing connections\n~~~~~~~~~~~~~~~~~~~\n\nthe default django-redis behavior on close() is to keep the connections to redis server.\n\nyou can change this default behaviour for all caches by the ``django_redis_close_connection = true``\nin the django settings (globally) or (at cache level) by setting ``close_connection: true`` in the ``options``\nfor each configured cache.\n\nsetting true as a value will instruct the django-redis to close all the connections (since v. 4.12.2), irrespectively of its current usage.\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"redis://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"close_connection\": true,\n            }\n        }\n    }\n\nssl/tls and self-signed certificates\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nin case you encounter a redis server offering a tls connection using a\nself-signed certificate you may disable certification verification with the\nfollowing:\n\n.. code-block:: python\n\n    caches = {\n        \"default\": {\n            \"backend\": \"django_redis.cache.rediscache\",\n            \"location\": \"rediss://127.0.0.1:6379/1\",\n            \"options\": {\n                \"client_class\": \"django_redis.client.defaultclient\",\n                \"connection_pool_kwargs\": {\"ssl_cert_reqs\": none}\n            }\n        }\n    }\n\n\nlicense\n-------\n\n.. code-block:: text\n\n    copyright (c) 2011-2015 andrey antukh <niwi@niwi.nz>\n    copyright (c) 2011 sean bleier\n\n    all rights reserved.\n\n    redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n    1. redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n    2. redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n    3. the name of the author may not be used to endorse or promote products\n       derived from this software without specific prior written permission.\n\n    this software is provided by the author ``as is`` and any express or\n    implied warranties, including, but not limited to, the implied warranties\n    of merchantability and fitness for a particular purpose are disclaimed.\n    in no event shall the author be liable for any direct, indirect,\n    incidental, special, exemplary, or consequential damages (including, but\n    not limited to, procurement of substitute goods or services; loss of use,\n    data, or profits; or business interruption) however caused and on any\n    theory of liability, whether in contract, strict liability, or tort\n    (including negligence or otherwise) arising in any way out of the use of\n    this software, even if advised of the possibility of such damage.\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-3-clause",
  "name": "django-redis",
  "package_url": "https://pypi.org/project/django-redis/",
  "project_url": "https://pypi.org/project/django-redis/",
  "project_urls": {
    "Homepage": "https://github.com/jazzband/django-redis"
  },
  "release_url": "https://pypi.org/project/django-redis/5.4.0/",
  "requires_dist": [
    "Django >=3.2",
    "redis !=4.0.0,!=4.0.1,>=3",
    "redis[hiredis] !=4.0.0,!=4.0.1,>=3 ; extra == 'hiredis'"
  ],
  "requires_python": ">=3.6",
  "summary": "full featured redis cache backend for django.",
  "version": "5.4.0",
  "releases": [],
  "developers": [
    "andrei_antoukh",
    "niwi@niwi.nz"
  ],
  "kwds": "django_redis redis_client_kwargs django_redis_logger redis django_redis_close_connection",
  "license_kwds": "bsd-3-clause",
  "libtype": "pypi",
  "id": "pypi_django_redis",
  "homepage": "https://github.com/jazzband/django-redis",
  "release_count": 68,
  "dependency_ids": [
    "pypi_django",
    "pypi_redis"
  ]
}