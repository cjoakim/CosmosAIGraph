{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "framework :: flask",
    "intended audience :: developers",
    "intended audience :: information technology",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http",
    "topic :: internet :: www/http :: dynamic content",
    "topic :: internet :: www/http :: wsgi",
    "topic :: security",
    "topic :: software development :: libraries :: application frameworks",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "lti 1.3 advantage tool implementation in python\n===============================================\n\n.. image:: https://img.shields.io/pypi/v/pylti1p3\n    :scale: 100%\n    :target: https://pypi.python.org/pypi/pylti1p3\n    :alt: pypi\n\n.. image:: https://img.shields.io/pypi/pyversions/pylti1p3\n    :scale: 100%\n    :target: https://www.python.org/\n    :alt: python\n\n.. image:: https://github.com/dmitry-viskov/pylti1.3/actions/workflows/tox.yml/badge.svg\n    :scale: 100%\n    :target: https://github.com/dmitry-viskov/pylti1.3/actions\n    :alt: build status\n\n.. image:: https://img.shields.io/github/license/dmitry-viskov/pylti1.3\n    :scale: 100%\n    :target: https://raw.githubusercontent.com/dmitry-viskov/pylti1.3/master/license\n    :alt: mit\n\n\nthis project is a python implementation of the similar `php tool`_.\nthis library contains adapters for use with the django and flask web frameworks. however, there are no difficulties with adapting it to other frameworks; you just need to re-implement the ``oidclogin`` and ``messagelaunch`` classes as it is already done in existing adapters.\n\n.. _php tool: https://github.com/imsglobal/lti-1-3-php-library\n\nusage examples\n=================\n\ndjango: https://github.com/dmitry-viskov/pylti1.3-django-example\n\nflask: https://github.com/dmitry-viskov/pylti1.3-flask-example\n\nconfiguration\n=============\n\nto configure your own tool, you may use built-in adapters:\n\n.. code-block:: python\n\n    from pylti1p3.tool_config import toolconfjsonfile\n    tool_conf = toolconfjsonfile('path/to/json')\n\n    from pylti1p3.tool_config import toolconfdict\n    settings = {\n        \"<issuer_1>\": { },  # one issuer ~ one client-id (outdated and not recommended)\n        \"<issuer_2>\": [{ }, { }]  # one issuer ~ many client-ids (recommended method)\n    }\n    private_key = '...'\n    public_key = '...'\n    tool_conf = toolconfdict(settings)\n\n    client_id = '...' # must be set if implementing the \"one issuer ~ many client-ids\" concept\n\n    tool_conf.set_private_key(iss, private_key, client_id=client_id)\n    tool_conf.set_public_key(iss, public_key, client_id=client_id)\n\nor create your own implementation. the ``pylti1p3.tool_config.toolconfabstract`` interface must be fully implemented for this to work.\nthe concept of ``one issuer ~ many client-ids`` is the recommended way to organize configs and may be useful in the case of integration with canvas (https://canvas.instructure.com)\nor other cloud lms-es where the platform doesn't change ``iss`` for each customer.\n\nin the case of the django framework, you may use ``djangodbtoolconf`` (see `configuration using django admin ui`_ section below).\n\n\nexample of a json config:\n\n.. code-block:: javascript\n\n    {\n        \"iss1\": [{\n            \"default\": true,\n            \"client_id\": \"client_id1\",\n            \"auth_login_url\": \"auth_login_url1\",\n            \"auth_token_url\": \"auth_token_url1\",\n            \"auth_audience\": null,\n            \"key_set_url\": \"key_set_url1\",\n            \"key_set\": null,\n            \"private_key_file\": \"private.key\",\n            \"public_key_file\": \"public.key\",\n            \"deployment_ids\": [\"deployment_id1\", \"deployment_id2\"]\n        }, {\n            \"default\": false,\n            \"client_id\": \"client_id2\",\n            \"auth_login_url\": \"auth_login_url2\",\n            \"auth_token_url\": \"auth_token_url2\",\n            \"auth_audience\": null,\n            \"key_set_url\": \"key_set_url2\",\n            \"key_set\": null,\n            \"private_key_file\": \"private.key\",\n            \"public_key_file\": \"public.key\",\n            \"deployment_ids\": [\"deployment_id3\", \"deployment_id4\"]\n        }],\n        \"iss2\": [ ],\n        \"iss3\": { }\n    }\n\n\n| ``default (bool)`` - this iss config will be used in case if client-id was not passed on the login step\n| ``client_id`` - this is the id received in the 'aud' during a launch\n| ``auth_login_url`` - the platform's oidc login endpoint\n| ``auth_token_url`` - the platform's service authorization endpoint\n| ``auth_audience`` - the platform's oauth2 audience (aud). is used to get platform's access token. usually the same as \"auth_token_url\" and could be skipped but in the common case could be a different url\n| ``key_set_url`` - the platform's jwks endpoint\n| ``key_set`` - in case if platform's jwks endpoint somehow unavailable you may paste jwks here\n| ``private_key_file`` - relative path to the tool's private key\n| ``public_key_file`` - relative path to the tool's public key\n| ``deployment_ids (list)`` - the deployment_id passed by the platform during launch\n\nusage with django\n=================\n\n.. _configuration:\n\nconfiguration using django admin ui\n-----------------------------------\n\n.. code-block:: python\n\n    # settings.py\n\n    installed_apps = [\n        'django.contrib.admin',\n        ...\n        'pylti1p3.contrib.django.lti1p3_tool_config'\n    ]\n\n    # urls.py\n\n    urlpatterns = [\n        ...\n        path('admin/', admin.site.urls),\n        ...\n    ]\n\n    # views.py\n\n    from pylti1p3.contrib.django import djangodbtoolconf\n\n    tool_conf = djangodbtoolconf()\n\n\nopen id connect login request\n-----------------------------\n\nlti 1.3 uses a modified version of the openid connect third party initiate login flow. this means that to do an lti 1.3 launch, you must first receive a login initialization request and return to the platform.\n\nto handle this request, you must first create a new ``oidclogin`` (or ``djangooidclogin``) object:\n\n.. code-block:: python\n\n    from pylti1p3.contrib.django import djangooidclogin\n\n    oidc_login = djangooidclogin(request, tool_conf)\n\nyou must now configure your login request with a return url (this must be preconfigured and white-listed in the tool).\nif a redirect url is not given or the registration does not exist, a ``pylti1p3.exception.oidc_exception`` will be thrown.\n\n.. code-block:: python\n\n    try:\n        oidc_login.redirect(get_launch_url(request))\n    except oidc_exception:\n        # display error page\n        log.error('error doing oidc login')\n\nwith the redirect, we can now redirect the user back to the tool.\nthere are three ways to do this:\n\nthis will add a http 302 location header:\n\n.. code-block:: python\n\n    oidc_login.redirect(get_launch_url(request))\n\nthis will display some javascript to do the redirect instead of using a http 302:\n\n.. code-block:: python\n\n    oidc_login.redirect(get_launch_url(request), js_redirect=true)\n\nyou can also get the url you need to redirect to, with all of the necessary query parameters (if you would prefer to redirect in a custom way):\n\n.. code-block:: python\n\n    redirect_obj = oidc_login.get_redirect_object()\n    redirect_url = redirect_obj.get_redirect_url()\n\nthe redirect is done and we can move on to the launch.\n\nlti message launches\n--------------------\n\nnow that we have done the oidc log, the platform will launch back to the tool. to handle this request, we first need to create a new ``messagelaunch`` (or ``djangomessagelaunch``) object.\n\n.. code-block:: python\n\n    message_launch = djangomessagelaunch(request, tool_conf)\n\nonce we have the message launch, we can validate it. validation is transparent - it's done once before you try to access the message body:\n\n.. code-block:: python\n\n    try:\n        launch_data = message_launch.get_launch_data()\n    except ltiexception:\n        log.error('launch validation failed')\n\nyou may do it more explicitly:\n\n.. code-block:: python\n\n    try:\n        launch_data = message_launch.set_auto_validation(enable=false).validate()\n    except ltiexception:\n        log.error('launch validation failed')\n\nnow that we know the launch is valid, we can find out more information about the launch.\n\nto check if we have a resource launch or a deep linking launch:\n\n.. code-block:: python\n\n    if message_launch.is_resource_launch():\n        # resource launch!\n    elif message_launch.is_deep_link_launch():\n        # deep linking launch!\n    else:\n        # unknown launch type\n\nto check which services we have access to:\n\n.. code-block:: python\n\n    if message_launch.has_ags():\n        # has assignments and grades service\n    if message_launch.has_nrps():\n        # has names and roles service\n\nusage with flask\n================\n\nopen id connect login request\n-----------------------------\n\nthis is a draft of an api endpoint. wrap it in a library of your choice.\n\ncreate a ``flaskrequest`` adapter. then create an instance of ``flaskoidclogin``. the ``redirect`` method will return an instance of ``werkzeug.wrappers.response`` that points to the lti platform if login was successful. make sure to handle exceptions.\n\n.. code-block:: python\n\n    from flask import request, session\n    from pylti1p3.flask_adapter import (flaskrequest, flaskoidclogin)\n\n    def login(request_params_dict):\n\n        tool_conf = ... # see configuration chapter above\n\n        # flaskrequest by default use flask.request and flask.session\n        # so in this case you may define request object without any arguments:\n\n        request = flaskrequest()\n\n        # in case of using different request object (for example webargs or something like this)\n        # you may pass your own values:\n\n        request = flaskrequest(\n            cookies=request.cookies,\n            session=session,\n            request_data=request_params_dict,\n            request_is_secure=request.is_secure\n        )\n\n        oidc_login = flaskoidclogin(\n            request=request,\n            tool_config=tool_conf,\n            session_service=flasksessionservice(request),\n            cookie_service=flaskcookieservice(request)\n        )\n\n        return oidc_login.redirect(request.get_param('target_link_uri'))\n\nlti message launches\n--------------------\n\nthis is a draft of an api endpoint. wrap it in a library of your choice.\n\ncreate a ``flaskrequest`` adapter. then create an instance of ``flaskmessagelaunch``. this lets you access data from the lti launch message if the launch was successful. make sure to handle exceptions.\n\n.. code-block:: python\n\n    from flask import request, session\n    from werkzeug.utils import redirect\n    from pylti1p3.flask_adapter import (flaskrequest, flaskmessagelaunch)\n\n    def launch(request_params_dict):\n\n        tool_conf = ... # see configuration chapter above\n\n        request = flaskrequest()\n\n        # or\n\n        request = flaskrequest(\n            cookies=...,\n            session=...,\n            request_data=...,\n            request_is_secure=...\n        )\n\n        message_launch = flaskmessagelaunch(\n            request=request,\n            tool_config=tool_conf\n        )\n\n        email = message_launch.get_launch_data().get('email')\n\n        # place your user creation/update/login logic\n        # and redirect to tool content here\n\naccessing cached launch requests\n================================\n\nit is likely that you will want to refer back to a launch later during subsequent requests. this is done using the launch id to identify a cached request. the launch id can be found using:\n\n.. code-block:: python\n\n    launch_id = message_launch.get_launch_id()\n\nonce you have the launch id, you can link it to your session and pass it along as a query parameter.\n\nretrieving a launch using the launch id can be done using:\n\n.. code-block:: python\n\n    message_launch = djangomessagelaunch.from_cache(launch_id, request, tool_conf)\n\nonce retrieved, you can call any of the methods on the launch object as normal, e.g.\n\n.. code-block:: python\n\n    if message_launch.has_ags():\n        # has assignments and grades service\n\ndeep linking responses\n======================\n\nif you receive a deep linking launch, it is very likely that you are going to want to respond to the deep linking request with resources for the platform.\n\nto create a deep link response, you will need to get the deep link for the current launch:\n\n.. code-block:: python\n\n    deep_link = message_launch.get_deep_link()\n\nwe now need to create ``pylti1p3.deep_link_resource.deeplinkresource`` to return:\n\n.. code-block:: python\n\n    resource = deeplinkresource()\n    resource.set_url(\"https://my.tool/launch\")\\\n        .set_custom_params({'my_param': my_param})\\\n        .set_title('my resource')\n\neverything is now set to return the resource to the platform. there are two methods of doing this.\n\nthe following method will output the html for an aut-posting form for you.\n\n.. code-block:: python\n\n    deep_link.output_response_form([resource1, resource2])\n\nalternatively you can just request the signed jwt that will need posting back to the platform by calling.\n\n.. code-block:: python\n\n    deep_link.get_response_jwt([resource1, resource2])\n\nnames and roles service\n=======================\n\nbefore using names and roles, you should check that you have access to it:\n\n.. code-block:: python\n\n    if not message_launch.has_nrps():\n        raise exception(\"don't have names and roles!\")\n\nonce we know we can access it, we can get an instance of the service from the launch.\n\n.. code-block:: python\n\n    nrps = message_launch.get_nrps()\n\nfrom the service we can get a list of all members by calling:\n\n.. code-block:: python\n\n    members = nrps.get_members()\n\nto get some specific page with the members:\n\n.. code-block:: python\n\n    members, next_page_url = nrps.get_members_page(page_url)\n\nassignments and grades service\n==============================\n\nbefore using assignments and grades, you should check that you have access to it:\n\n.. code-block:: python\n\n    if not launch.has_ags():\n        raise exception(\"don't have assignments and grades!\")\n\nonce we know we can access it, we can get an instance of the service from the launch:\n\n.. code-block:: python\n\n    ags = launch.get_ags()\n\nthere are few functions to check different ``ags`` permissions:\n\n.. code-block:: python\n\n    # ability to read line items\n    ags.can_read_lineitem()\n\n    # ability to create new line item\n    ags.can_create_lineitem()\n\n    # ability to read grades\n    ags.can_read_grades()\n\n    # ability to pass grades\n    ags.can_put_grade()\n\nto pass a grade back to the platform, you will need to create a ``pylti1p3.grade.grade`` object and populate it with the necessary information:\n\n.. code-block:: python\n\n    gr = grade()\n    gr.set_score_given(earned_score)\\\n         .set_score_maximum(100)\\\n         .set_timestamp(datetime.datetime.utcnow().strftime('%y-%m-%dt%h:%m:%s+0000'))\\\n         .set_activity_progress('completed')\\\n         .set_grading_progress('fullygraded')\\\n         .set_user_id(external_user_id)\n\nto send the grade to the platform we can call:\n\n.. code-block:: python\n\n    ags.put_grade(gr)\n\nthis will put the grade into the default provided lineitem.\n\nif you want to send multiple types of grade back, that can be done by specifying a ``pylti1p3.lineitem.lineitem``:\n\n.. code-block:: python\n\n    line_item = lineitem()\n    line_item.set_tag('grade')\\\n        .set_score_maximum(100)\\\n        .set_label('grade')\n\n    ags.put_grade(gr, line_item)\n\nif a lineitem with the same ``tag`` exists, that lineitem will be used, otherwise a new lineitem will be created.\nadditional methods:\n\n.. code-block:: python\n\n    # get one page with line items\n    items_lst, next_page = ags.get_lineitems_page()\n\n    # get list of all available line items\n    items_lst = ags.get_lineitems()\n\n    # find line item by id\n    item = ags.find_lineitem_by_id(ln_id)\n\n    # find line item by tag\n    item = ags.find_lineitem_by_tag(ln_tag)\n\n    # find line item by resource id\n    item = ags.find_lineitem_by_resource_id(ln_resource_id)\n\n    # find line item by resource link id\n    item = ags.find_lineitem_by_resource_link_id(ln_resource_link_id)\n\n    # return all grades for the passed lineitem (across all users enrolled in the line item's context)\n    grades = ags.get_grades(ln)\n\ndata privacy launch\n===================\n\ndata privacy launch is a new optional lti 1.3 message type that allows lti-enabled tools to assist administrative\nusers in managing and executing requests related to data privacy.\n\n.. code-block:: python\n\n    data_privacy_launch = message_launch.is_data_privacy_launch()\n    if data_privacy_launch:\n        user = message_launch.get_data_privacy_launch_user()\n\n\nsubmission review\n=================\n\nsubmission review provides a standard way for an instructor or student to launch back from a platform's gradebook\nto the tool where the interaction took place to display the learner's submission for a particular line item.\n\n.. code-block:: python\n\n    if launch.is_submission_review_launch()\n        user = launch.get_submission_review_user()\n        ags = launch.get_ags()\n        lineitem = ags.get_lineitem()\n        submission_review = lineitem.get_submission_review()\n\n\ncourse group service\n====================\n\ncommunicates to the tool the groups available in the course and their respective enrollment.\n\n.. code-block:: python\n\n    if launch.has_cgs()\n        cgs = launch.get_cgs()\n\n        # get all available groups\n        groups = cgs.get_groups()\n\n        # get groups for some user\n        user_id = '0ae836b9-7fc9-4060-006f-27b2066ac545'\n        groups = cgs.get_groups(user_id)\n\n        # get all sets\n        if cgs.has_sets():\n            sets = cgs.get_sets()\n            sets_with_groups = cgs.get_sets(include_groups=true)\n\n\ncheck user's role after lti launch\n==================================\n\n.. code-block:: python\n\n    user_is_staff = message_launch.check_staff_access()\n    user_is_student = message_launch.check_student_access())\n    user_is_teacher = message_launch.check_teacher_access()\n    user_is_teaching_assistant = message_launch.check_teaching_assistant_access()\n    user_is_designer = message_launch.check_designer_access()\n    user_is_observer = message_launch.check_observer_access()\n    user_is_transient = message_launch.check_transient()\n\ncookies issues in the iframes\n=============================\n\nsome browsers may deny requests to save cookies in the iframes. for example, `google chrome (from ver.80 onwards) denies requests to save`_ all cookies in\nthe iframes except cookies with the flags ``secure`` (i.e https usage) and ``samesite=none``. `safari denies requests to save`_\nall third-party cookies by default. the ``pylti1p3`` library contains workarounds for such behaviours:\n\n.. _google chrome (from ver.80 onwards) denies requests to save: https://blog.heroku.com/chrome-changes-samesite-cookie\n.. _safari denies requests to save: https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/\n\n.. code-block:: python\n\n    def login():\n        ...\n        return oidc_login\\\n            .enable_check_cookies()\\\n            .redirect(target_link_uri)\n\nafter this, the special js code will try to write and then read test cookie instead of redirect. the user will see a\n`special page`_ that will ask them to open the current url in the new window if cookies are unavailable. if\ncookies are allowed, the user will be transparently redirected to the next page. all texts are configurable with passing arguments:\n\n.. _special page: https://raw.githubusercontent.com/dmitry-viskov/repos-assets/master/pylti1p3/examples/cookies-check/001.png\n\n.. code-block:: python\n\n    oidc_login.enable_check_cookies(main_msg, click_msg, loading_msg)\n\nyou may also have troubles with the default framework sessions because the ``pylti1p3`` library can't control your framework\nsettings connected with the session id cookie. without necessary settings, the user's session could be unavailable in the\ncase of iframe usage. to avoid this, it is recommended to change the default session adapter to the new cache\nadapter (with a memcache/redis backend) and as a consequence, allow the library to set its own lti 1.3 session id cookie\nthat will be set with all necessary params like ``secure`` and ``samesite=none``.\n\ndjango cache data storage\n-------------------------\n\n.. code-block:: python\n\n    from pylti1p3.contrib.django import djangocachedatastorage\n\n    def login(request):\n        ...\n        launch_data_storage = djangocachedatastorage(cache_name='default')\n        oidc_login = djangooidclogin(request, tool_conf, launch_data_storage=launch_data_storage)\n\n    def launch(request):\n        ...\n        launch_data_storage = djangocachedatastorage(cache_name='default')\n        message_launch = djangomessagelaunch(request, tool_conf, launch_data_storage=launch_data_storage)\n\n    def restore_launch(request):\n        ...\n        launch_data_storage = get_launch_data_storage(cache_name='default')\n        message_launch = djangomessagelaunch.from_cache(launch_id, request, tool_conf,\n                                                        launch_data_storage=launch_data_storage)\n\nflask cache data storage\n-------------------------\n\n.. code-block:: python\n\n    from flask_caching import cache\n    from pylti1p3.contrib.flask import flaskcachedatastorage\n\n    cache = cache(app)\n\n    def login():\n        ...\n        launch_data_storage = flaskcachedatastorage(cache)\n        oidc_login = djangooidclogin(request, tool_conf, launch_data_storage=launch_data_storage)\n\n    def launch():\n        ...\n        launch_data_storage = flaskcachedatastorage(cache)\n        message_launch = djangomessagelaunch(request, tool_conf, launch_data_storage=launch_data_storage)\n\n    def restore_launch():\n        ...\n        launch_data_storage = flaskcachedatastorage(cache)\n        message_launch = djangomessagelaunch.from_cache(launch_id, request, tool_conf,\n                                                        launch_data_storage=launch_data_storage)\n\ncache for public key\n====================\n\nthe library will try to fetch the platform's public key every time on the message launch step. this public key may be stored in cache\n(memcache/redis) to speed-up the launch process:\n\n.. code-block:: python\n\n    # django cache storage:\n    launch_data_storage = djangocachedatastorage()\n\n    # flask cache storage:\n    launch_data_storage = flaskcachedatastorage(cache)\n\n    message_launch.set_public_key_caching(launch_data_storage, cache_lifetime=7200)\n\n\n**important note!** be careful with using this function because time period of rotating keys could be less than cache lifetime.\nfor example d2l appears to expire their keys approximately hourly.\nyou may pass custom ``requests.session`` objects during message launch which allows caching using http response headers:\n\n.. code-block:: python\n\n    import requests_cache\n\n    requests_session = requests_cache.cachedsession('cache')\n    message_launch = djangomessagelaunch(request, tool_conf, requests_session=requests_session)\n\n\napi to get jwks\n===============\n\nyou may generate jwks from a tool config object:\n\n.. code-block:: python\n\n    tool_conf.set_public_key(iss, public_key, client_id=client_id)\n    jwks_dict = tool_conf.get_jwks()  # {\"keys\": [{ ... }]}\n\n    # or you may specify iss and client_id:\n    jwks_dict = tool_conf.get_jwks(iss, client_id)  # {\"keys\": [{ ... }]}\n\ndo not forget to set a public key as without it, jwks cannot be generated.\nyou may also generate jwk for any public key using the construction below:\n\n.. code-block:: python\n\n    from pylti1p3.registration import registration\n\n    jwk_dict = registration.get_jwk(public_key)\n    # {\"e\": ..., \"kid\": ..., \"kty\": ..., \"n\": ..., \"alg\": ..., \"use\": ...}\n",
  "docs_url": null,
  "keywords": "pylti,pylti1p3,lti,lti1.3,lti1p3,django,flask",
  "license": "mit",
  "name": "pylti1p3",
  "package_url": "https://pypi.org/project/PyLTI1p3/",
  "project_url": "https://pypi.org/project/PyLTI1p3/",
  "project_urls": {
    "Homepage": "https://github.com/dmitry-viskov/pylti1.3"
  },
  "release_url": "https://pypi.org/project/PyLTI1p3/2.0.0/",
  "requires_dist": [
    "jwcrypto",
    "pyjwt (>=1.5)",
    "requests",
    "typing-extensions"
  ],
  "requires_python": "",
  "summary": "lti 1.3 advantage tool implementation in python",
  "version": "2.0.0",
  "releases": [],
  "developers": [
    "dmitry.viskov@webenterprise.ru",
    "dmitry_viskov"
  ],
  "kwds": "pylti1p3 pylti1 pylti flask pyversions",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pylti1p3",
  "homepage": "https://github.com/dmitry-viskov/pylti1.3",
  "release_count": 29,
  "dependency_ids": [
    "pypi_jwcrypto",
    "pypi_pyjwt",
    "pypi_requests",
    "pypi_typing_extensions"
  ]
}