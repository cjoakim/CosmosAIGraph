{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: c",
    "programming language :: python",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: software development"
  ],
  "description": "line_profiler and kernprof\n--------------------------\n\n|pypi| |readthedocs| |downloads| |circleci| |githubactions| |codecov|\n\n\nthis is the official ``line_profiler`` repository. the most recent version of\n`line-profiler <https://pypi.org/project/line_profiler/>`_ on pypi points to\nthis repo.\nthe original `line_profiler <https://github.com/rkern/line_profiler/>`_ package\nby `@rkern <https://github.com/rkern/>`_ is unmaintained.\nthis fork is the official continuation of the project.\n\n+---------------+--------------------------------------------+\n| github        | https://github.com/pyutils/line_profiler   |\n+---------------+--------------------------------------------+\n| pypi          | https://pypi.org/project/line_profiler     |\n+---------------+--------------------------------------------+\n| readthedocs   | https://kernprof.readthedocs.io/en/latest/ |\n+---------------+--------------------------------------------+\n\n----\n\n\n``line_profiler`` is a module for doing line-by-line profiling of functions.\nkernprof is a convenient script for running either ``line_profiler`` or the python\nstandard library's cprofile or profile modules, depending on what is available.\n\nthey are available under a `bsd license`_.\n\n.. _bsd license: https://raw.githubusercontent.com/pyutils/line_profiler/master/license.txt\n\n.. contents::\n\n\nquick start\n===========\nto profile a python script:\n\n* install line_profiler: ``pip install line_profiler``.\n\n* decorate function(s) you want to profile with @profile. the decorator will be made automatically available on run.\n\n* run ``kernprof -lv script_to_profile.py``.\n\ninstallation\n============\n\nreleases of ``line_profiler`` can be installed using pip::\n\n    $ pip install line_profiler\n\ninstallation while ensuring a compatible ipython version can also be installed using pip::\n\n    $ pip install line_profiler[ipython]\n\nto check out the development sources, you can use git_::\n\n    $ git clone https://github.com/pyutils/line_profiler.git\n\nyou may also download source tarballs of any snapshot from that url.\n\nsource releases will require a c compiler in order to build `line_profiler`.\nin addition, git checkouts will also require cython. source releases\non pypi should contain the pregenerated c sources, so cython should not be\nrequired in that case.\n\n``kernprof`` is a single-file pure python script and does not require\na compiler.  if you wish to use it to run cprofile and not line-by-line\nprofiling, you may copy it to a directory on your ``path`` manually and avoid\ntrying to build any c extensions.\n\nas of 2021-06-04 linux (x86_64 and i686), osx (10_9_x86_64), and win32 (win32,\nand amd64) binaries are available on pypi.\n\nthe last version of line profiler to support python 2.7 was 3.1.0 and the last\nversion to support python 3.5 was 3.3.1.\n\n.. _git: http://git-scm.com/\n.. _cython: http://www.cython.org\n.. _build and install: http://docs.python.org/install/index.html\n\n\nline_profiler\n=============\n\nthe current profiling tools supported in python only time\nfunction calls. this is a good first step for locating hotspots in one's program\nand is frequently all one needs to do to optimize the program. however,\nsometimes the cause of the hotspot is actually a single line in the function,\nand that line may not be obvious from just reading the source code. these cases\nare particularly frequent in scientific computing. functions tend to be larger\n(sometimes because of legitimate algorithmic complexity, sometimes because the\nprogrammer is still trying to write fortran code), and a single statement\nwithout function calls can trigger lots of computation when using libraries like\nnumpy. cprofile only times explicit function calls, not special methods called\nbecause of syntax. consequently, a relatively slow numpy operation on large\narrays like this, ::\n\n    a[large_index_array] = some_other_large_array\n\nis a hotspot that never gets broken out by cprofile because there is no explicit\nfunction call in that statement.\n\nlineprofiler can be given functions to profile, and it will time the execution\nof each individual line inside those functions. in a typical workflow, one only\ncares about line timings of a few functions because wading through the results\nof timing every single line of code would be overwhelming. however, lineprofiler\ndoes need to be explicitly told what functions to profile. the easiest way to\nget started is to use the ``kernprof`` script. ::\n\n    $ kernprof -l script_to_profile.py\n\n``kernprof`` will create an instance of lineprofiler and insert it into the\n``__builtins__`` namespace with the name ``profile``. it has been written to be\nused as a decorator, so in your script, you decorate the functions you want\nto profile with @profile. ::\n\n    @profile\n    def slow_function(a, b, c):\n        ...\n\nthe default behavior of ``kernprof`` is to put the results into a binary file\nscript_to_profile.py.lprof . you can tell ``kernprof`` to immediately view the\nformatted results at the terminal with the [-v/--view] option. otherwise, you\ncan view the results later like so::\n\n    $ python -m line_profiler script_to_profile.py.lprof\n\nfor example, here are the results of profiling a single function from\na decorated version of the pystone.py benchmark (the first two lines are output\nfrom ``pystone.py``, not ``kernprof``)::\n\n    pystone(1.1) time for 50000 passes = 2.48\n    this machine benchmarks at 20161.3 pystones/second\n    wrote profile results to pystone.py.lprof\n    timer unit: 1e-06 s\n\n    file: pystone.py\n    function: proc2 at line 149\n    total time: 0.606656 s\n\n    line #      hits         time  per hit   % time  line contents\n    ==============================================================\n       149                                           @profile\n       150                                           def proc2(intpario):\n       151     50000        82003      1.6     13.5      intloc = intpario + 10\n       152     50000        63162      1.3     10.4      while 1:\n       153     50000        69065      1.4     11.4          if char1glob == 'a':\n       154     50000        66354      1.3     10.9              intloc = intloc - 1\n       155     50000        67263      1.3     11.1              intpario = intloc - intglob\n       156     50000        65494      1.3     10.8              enumloc = ident1\n       157     50000        68001      1.4     11.2          if enumloc == ident1:\n       158     50000        63739      1.3     10.5              break\n       159     50000        61575      1.2     10.1      return intpario\n\n\nthe source code of the function is printed with the timing information for each\nline. there are six columns of information.\n\n    * line #: the line number in the file.\n\n    * hits: the number of times that line was executed.\n\n    * time: the total amount of time spent executing the line in the timer's\n      units. in the header information before the tables, you will see a line\n      \"timer unit:\" giving the conversion factor to seconds. it may be different\n      on different systems.\n\n    * per hit: the average amount of time spent executing the line once in the\n      timer's units.\n\n    * % time: the percentage of time spent on that line relative to the total\n      amount of recorded time spent in the function.\n\n    * line contents: the actual source code. note that this is always read from\n      disk when the formatted results are viewed, *not* when the code was\n      executed. if you have edited the file in the meantime, the lines will not\n      match up, and the formatter may not even be able to locate the function\n      for display.\n\nif you are using ipython, there is an implementation of an %lprun magic command\nwhich will let you specify functions to profile and a statement to execute. it\nwill also add its lineprofiler instance into the __builtins__, but typically,\nyou would not use it like that.\n\nfor ipython 0.11+, you can install it by editing the ipython configuration file\n``~/.ipython/profile_default/ipython_config.py`` to add the ``'line_profiler'``\nitem to the extensions list::\n\n    c.terminalipythonapp.extensions = [\n        'line_profiler',\n    ]\n\nor explicitly call::\n\n    %load_ext line_profiler\n\nto get usage help for %lprun, use the standard ipython help mechanism::\n\n    in [1]: %lprun?\n\nthese two methods are expected to be the most frequent user-level ways of using\nlineprofiler and will usually be the easiest. however, if you are building other\ntools with lineprofiler, you will need to use the api. there are two ways to\ninform lineprofiler of functions to profile: you can pass them as arguments to\nthe constructor or use the ``add_function(f)`` method after instantiation. ::\n\n    profile = lineprofiler(f, g)\n    profile.add_function(h)\n\nlineprofiler has the same ``run()``, ``runctx()``, and ``runcall()`` methods as\ncprofile.profile as well as ``enable()`` and ``disable()``. it should be noted,\nthough, that ``enable()`` and ``disable()`` are not entirely safe when nested.\nnesting is common when using lineprofiler as a decorator. in order to support\nnesting, use ``enable_by_count()`` and ``disable_by_count()``. these functions will\nincrement and decrement a counter and only actually enable or disable the\nprofiler when the count transitions from or to 0.\n\nafter profiling, the ``dump_stats(filename)`` method will pickle the results out\nto the given file. ``print_stats([stream])`` will print the formatted results to\nsys.stdout or whatever stream you specify. ``get_stats()`` will return linestats\nobject, which just holds two attributes: a dictionary containing the results and\nthe timer unit.\n\n\nkernprof\n========\n\n``kernprof`` also works with cprofile, its third-party incarnation lsprof, or the\npure-python profile module depending on what is available. it has a few main\nfeatures:\n\n    * encapsulation of profiling concerns. you do not have to modify your script\n      in order to initiate profiling and save the results. unless if you want to\n      use the advanced __builtins__ features, of course.\n\n    * robust script execution. many scripts require things like __name__,\n      __file__, and sys.path to be set relative to it. a naive approach at\n      encapsulation would just use execfile(), but many scripts which rely on\n      that information will fail. kernprof will set those variables correctly\n      before executing the script.\n\n    * easy executable location. if you are profiling an application installed on\n      your path, you can just give the name of the executable. if kernprof does\n      not find the given script in the current directory, it will search your\n      path for it.\n\n    * inserting the profiler into __builtins__. sometimes, you just want to\n      profile a small part of your code. with the [-b/--builtin] argument, the\n      profiler will be instantiated and inserted into your __builtins__ with the\n      name \"profile\". like lineprofiler, it may be used as a decorator, or\n      enabled/disabled with ``enable_by_count()`` and ``disable_by_count()``, or\n      even as a context manager with the \"with profile:\" statement.\n\n    * pre-profiling setup. with the [-s/--setup] option, you can provide\n      a script which will be executed without profiling before executing the\n      main script. this is typically useful for cases where imports of large\n      libraries like wxpython or vtk are interfering with your results. if you\n      can modify your source code, the __builtins__ approach may be\n      easier.\n\nthe results of profile script_to_profile.py will be written to\nscript_to_profile.py.prof by default. it will be a typical marshalled file that\ncan be read with pstats.stats(). they may be interactively viewed with the\ncommand::\n\n    $ python -m pstats script_to_profile.py.prof\n\n\nsuch files may also be viewed with graphical tools. a list of 3rd party tools\nbuilt on ``cprofile`` or ``line_profiler`` are as follows:\n\n* `pyprof2calltree <pyprof2calltree_>`_: converts profiling data to a format\n  that can be visualized using kcachegrind_ (linux only), wincachegrind_\n  (windows only, unmaintained), or  qcachegrind_.\n\n* `line profiler gui <qt_profiler_gui_>`_: qt gui for line_profiler.\n\n* `snakeviz <snakeviz_>`_: a web viewer for python profiling data.\n\n* `snakerunner <snakerunner_>`_: a fork of runsnakerun_, ported to python 3.\n\n* `pycharm plugin <pycharm_line_profiler_plugin_>`_: a pycharm plugin for line_profiler.\n\n* `spyder plugin <spyder_line_profiler_plugin_>`_: a plugin to run line_profiler from within the spyder ide.\n\n* `pprof <web_profiler_ui_>`_: a render web report for ``line_profiler``.\n\n.. _qcachegrind: https://sourceforge.net/projects/qcachegrindwin/\n.. _kcachegrind: https://kcachegrind.github.io/html/home.html\n.. _wincachegrind: https://github.com/ceefour/wincachegrind\n.. _pyprof2calltree: http://pypi.python.org/pypi/pyprof2calltree/\n.. _snakeviz: https://github.com/jiffyclub/snakeviz/\n.. _snakerunner: https://github.com/venthur/snakerunner\n.. _runsnakerun: https://pypi.org/project/runsnakerun/\n.. _qt_profiler_gui: https://github.com/nodd/lineprofilergui\n.. _pycharm_line_profiler_plugin: https://plugins.jetbrains.com/plugin/16536-line-profiler\n.. _spyder_line_profiler_plugin: https://github.com/spyder-ide/spyder-line-profiler\n.. _web_profiler_ui: https://github.com/mirecl/pprof\n\n\nrelated work\n============\n\ncheck out these other python profilers:\n\n* `scalene <https://github.com/plasma-umass/scalene>`_: a cpu+gpu+memory sampling based profiler.\n\n* `pyinstrument  <https://github.com/joerick/pyinstrument>`_: a call stack profiler.\n\n* `yappi <https://github.com/sumerc/yappi>`_: a tracing profiler that is multithreading, asyncio and gevent aware.\n\n* `profile / cprofile <https://docs.python.org/3/library/profile.html>`_: the builtin profile module.\n\n* `timeit <https://docs.python.org/3/library/timeit.html>`_: the builtin timeit module for profiling single statements.\n\n* `timerit <https://github.com/erotemic/timerit>`_: a multi-statements alternative to the builtin ``timeit`` module.\n\nfrequently asked questions\n==========================\n\n* why the name \"kernprof\"?\n\n    i didn't manage to come up with a meaningful name, so i named it after\n    myself.\n\n* the line-by-line timings don't add up when one profiled function calls\n  another. what's up with that?\n\n    let's say you have function f() calling function g(), and you are using\n    lineprofiler on both. the total time reported for g() is less than the time\n    reported on the line in f() that calls g(). the reason is that i'm being\n    reasonably clever (and possibly too clever) in recording the times.\n    basically, i try to prevent recording the time spent inside lineprofiler\n    doing all of the bookkeeping for each line. each time python's tracing\n    facility issues a line event (which happens just before a line actually gets\n    executed), lineprofiler will find two timestamps, one at the beginning\n    before it does anything (t_begin) and one as close to the end as possible\n    (t_end). almost all of the overhead of lineprofiler's data structures\n    happens in between these two times.\n\n    when a line event comes in, lineprofiler finds the function it belongs to.\n    if it's the first line in the function, we record the line number and\n    *t_end* associated with the function. the next time we see a line event\n    belonging to that function, we take t_begin of the new event and subtract\n    the old t_end from it to find the amount of time spent in the old line. then\n    we record the new t_end as the active line for this function. this way, we\n    are removing most of lineprofiler's overhead from the results. well almost.\n    when one profiled function f calls another profiled function g, the line in\n    f that calls g basically records the total time spent executing the line,\n    which includes the time spent inside the profiler while inside g.\n\n    the first time this question was asked, the questioner had the g() function\n    call as part of a larger expression, and he wanted to try to estimate how\n    much time was being spent in the function as opposed to the rest of the\n    expression. my response was that, even if i could remove the effect, it\n    might still be misleading. g() might be called elsewhere, not just from the\n    relevant line in f(). the workaround would be to modify the code to split it\n    up into two lines, one which just assigns the result of g() to a temporary\n    variable and the other with the rest of the expression.\n\n    i am open to suggestions on how to make this more robust. or simple\n    admonitions against trying to be clever.\n\n* why do my list comprehensions have so many hits when i use the lineprofiler?\n\n    lineprofiler records the line with the list comprehension once for each\n    iteration of the list comprehension.\n\n* why is kernprof distributed with line_profiler? it works with just cprofile,\n  right?\n\n    partly because kernprof.py is essential to using line_profiler effectively,\n    but mostly because i'm lazy and don't want to maintain the overhead of two\n    projects for modules as small as these. however, kernprof.py is\n    a standalone, pure python script that can be used to do function profiling\n    with just the python standard library. you may grab it and install it by\n    itself without ``line_profiler``.\n\n* do i need a c compiler to build ``line_profiler``? kernprof.py?\n\n    you do need a c compiler for line_profiler. kernprof.py is a pure python\n    script and can be installed separately, though.\n\n* do i need cython to build ``line_profiler``?\n\n    wheels for supported versions of python are available on pypi and support\n    linux, osx, and windows for x86-64 architectures. linux additionally ships\n    with i686 wheels for manylinux and musllinux. if you have a different cpu\n    architecture, or an unsupported python version, then you will need to build\n    from source.\n\n* what version of python do i need?\n\n    both ``line_profiler`` and ``kernprof`` have been tested with python 3.6-3.11.\n    older versions of ``line_profiler`` support older versions of python.\n\n\nto do\n=====\n\ncprofile uses a neat \"rotating trees\" data structure to minimize the overhead of\nlooking up and recording entries. lineprofiler uses python dictionaries and\nextension objects thanks to cython. this mostly started out as a prototype that\ni wanted to play with as quickly as possible, so i passed on stealing the\nrotating trees for now. as usual, i got it working, and it seems to have\nacceptable performance, so i am much less motivated to use a different strategy\nnow. maybe later. contributions accepted!\n\n\nbugs and such\n=============\n\nbugs and pull requested can be submitted on github_.\n\n.. _github: https://github.com/pyutils/line_profiler\n\n\nchanges\n=======\n\nsee `changelog`_.\n\n.. _changelog: changelog.rst\n\n\n.. |circleci| image:: https://circleci.com/gh/pyutils/line_profiler.svg?style=svg\n    :target: https://circleci.com/gh/pyutils/line_profiler\n.. |travis| image:: https://img.shields.io/travis/pyutils/line_profiler/master.svg?label=travis%20ci\n   :target: https://travis-ci.org/pyutils/line_profiler?branch=master\n.. |appveyor| image:: https://ci.appveyor.com/api/projects/status/github/pyutils/line_profiler?branch=master&svg=true\n   :target: https://ci.appveyor.com/project/pyutils/line_profiler/branch/master\n.. |codecov| image:: https://codecov.io/github/pyutils/line_profiler/badge.svg?branch=master&service=github\n   :target: https://codecov.io/github/pyutils/line_profiler?branch=master\n.. |pypi| image:: https://img.shields.io/pypi/v/line_profiler.svg\n   :target: https://pypi.python.org/pypi/line_profiler\n.. |downloads| image:: https://img.shields.io/pypi/dm/line_profiler.svg\n   :target: https://pypistats.org/packages/line_profiler\n.. |githubactions| image:: https://github.com/pyutils/line_profiler/actions/workflows/tests.yml/badge.svg?branch=main\n   :target: https://github.com/pyutils/line_profiler/actions?query=branch%3amain\n.. |readthedocs| image:: https://readthedocs.org/projects/kernprof/badge/?version=latest\n    :target: http://kernprof.readthedocs.io/en/latest/\n\n\n",
  "docs_url": "https://pythonhosted.org/line-profiler/",
  "keywords": "timing,timer,profiling,profiler,line_profiler",
  "license": "bsd",
  "name": "line-profiler",
  "package_url": "https://pypi.org/project/line-profiler/",
  "project_url": "https://pypi.org/project/line-profiler/",
  "project_urls": {
    "Homepage": "https://github.com/pyutils/line_profiler"
  },
  "release_url": "https://pypi.org/project/line-profiler/4.1.2/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "line-by-line profiler",
  "version": "4.1.2",
  "releases": [],
  "developers": [
    "robert.kern@enthought.com",
    "robert_kern"
  ],
  "kwds": "line_profiler _pycharm_line_profiler_plugin _spyder_line_profiler_plugin spyder_line_profiler_plugin_ pycharm_line_profiler_plugin_",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_line_profiler",
  "homepage": "https://github.com/pyutils/line_profiler",
  "release_count": 30,
  "dependency_ids": []
}