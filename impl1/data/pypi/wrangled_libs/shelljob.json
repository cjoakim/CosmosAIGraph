{
  "classifiers": [
    "development status :: 6 - mature",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: gnu general public license v3 (gplv3)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: build tools",
    "topic :: system",
    "topic :: terminals"
  ],
  "description": "# shelljob\n\nthis provides a clean way to execute subprocesses, either one or multiple in parallel, capture their output and monitor progress:\n\n- single sub process `call` with optional timeout\n- high level `filemonitor` to execute several processes in parallel and store output in a file\n- low level `group` execution to execute jobs in parallel and capture output\n\nadditional tools for working with the filesystem are also included: \n\n- `find` which offers much of the functionality of the shell find utility\n- `shelljob.fs.namedtempfile` provides a _with_ block wrapper for temporary named files\n\n[api documentation](https://mortoray.github.io/shelljob/)\n\n\n# install\n\n```\npip install shelljob\n```\n\n# parallel subprocesses\n\nusing the job system is the quickest approach to just run processes and log their output (by default in files named '/tmp/job_id.log')\n\n````\nfrom shelljob import job\n\njm = job.filemonitor()\njm.run([\n\t[ 'ls', '-alr', '/usr/local' ],\n\t'my_prog',\n\t'build output input',\n])\n````\n\nan array will passed directly to `subprocess.popen`, a string is first parsed with `shlex.split`.\n\nthe lower level `group` class provides a simple container for more manual job management.\n\n````\nfrom shelljob import proc\n\ng = proc.group()\np1 = g.run( [ 'ls', '-al', '/usr/local' ] )\np2 = g.run( [ 'program', 'arg1', 'arg2' ] )\n\nwhile g.is_pending():\n\tlines = g.readlines()\n\tfor proc, line in lines:\n\t\tsys.stdout.write( \"{}:{}\".format( proc.pid, line ) )\n````\n\n## encoding\n\nby default the output will be binary encoding. you can specify an `encoding='utf-8'` to the `run` command to use an encoded text stream instead. be aware that if the encoding fails (the program emits an invalid sequence) the running will be interrupted. you should also use the `on_error` function to check for this.\n\nline-endings will always be preserved.\n\n# simple subprocess calls\n\na simplified `call` function allows timeouts on subprocesses and easy acces to their output.\n\n````\nfrom shelljob import proc\n\n# capture the output\noutput = proc.call( 'ls /tmp' )\n# this raises a proc.timeout exception\nproc.call( 'sleep 10', timeout = 0.1 )\n````\n\n# find\n\nthe 'find' funtion is a multi-faceted approach to generating listings of files.\n\n````\nfrom shelljob import fs\n\nfiles = fs.find( '/usr/local', name_regex = '.*\\\\.so' )\nprint( \"\\n\".join(files) )\n````\n\nrefer to the [api docs](https://mortoray.github.io/shelljob/) for all parameters. just let me know if there is some additional option you need.\n\n\n\n\n",
  "docs_url": "https://pythonhosted.org/shelljob/",
  "keywords": "",
  "license": "gplv3",
  "name": "shelljob",
  "package_url": "https://pypi.org/project/shelljob/",
  "project_url": "https://pypi.org/project/shelljob/",
  "project_urls": {
    "Homepage": "https://github.com/mortoray/shelljob/"
  },
  "release_url": "https://pypi.org/project/shelljob/0.6.3/",
  "requires_dist": [],
  "requires_python": ">=3.6",
  "summary": "run multiple subprocesses asynchronous/in parallel with streamed output/non-blocking reading. also various tools to replace shell scripts.",
  "version": "0.6.3",
  "releases": [],
  "developers": [
    "eda",
    "eda-qa@disemia.com"
  ],
  "kwds": "subprocesses subprocess shelljob stdout pip",
  "license_kwds": "gplv3",
  "libtype": "pypi",
  "id": "pypi_shelljob",
  "homepage": "https://github.com/mortoray/shelljob/",
  "release_count": 21,
  "dependency_ids": []
}