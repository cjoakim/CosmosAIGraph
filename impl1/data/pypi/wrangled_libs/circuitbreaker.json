{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: macos",
    "operating system :: posix",
    "operating system :: unix",
    "programming language :: python",
    "programming language :: python :: 3"
  ],
  "description": "circuitbreaker\n--------------\n\n.. image:: https://badge.fury.io/py/circuitbreaker.svg\n    :target: https://badge.fury.io/py/circuitbreaker\n\n.. image:: https://github.com/fabfuel/circuitbreaker/actions/workflows/build.yml/badge.svg\n    :target: https://github.com/fabfuel/circuitbreaker/actions/workflows/build.yml\n\nthis is a python implementation of the \"circuit breaker\" pattern (https://martinfowler.com/bliki/circuitbreaker.html).\ninspired by michael t. nygard's highly recommendable book *release it!* (https://pragprog.com/titles/mnee2/release-it-second-edition/).\n\n\ninstallation\n------------\n\nthe project is available on pypi. simply run::\n\n    $ pip install circuitbreaker\n\n\nusage\n-----\n\nthis is the simplest example. just decorate a function with the ``@circuit`` decorator::\n\n    from circuitbreaker import circuit\n\n    @circuit\n    def external_call():\n        ...\n\nasync functions are also supported::\n\n    @circuit\n    async def external_call():\n        ...\n\nthis decorator sets up a circuit breaker with the default settings. the circuit breaker:\n\n- monitors the function execution and counts failures\n- resets the failure count after every successful execution (while it is closed)\n- opens and prevents further executions after 5 subsequent failures\n- switches to half-open and allows one test-execution after 30 seconds recovery timeout\n- closes if the test-execution succeeded\n- considers all raised exceptions (based on class ``exception``) as an expected failure\n- is named \"external_call\" - the name of the function it decorates\n\n\nwhat does *failure* mean?\n=========================\na *failure* is a raised exception, which was not caught during the function call.\nby default, the circuit breaker listens for all exceptions based on the class ``exception``.\nthat means, that all exceptions raised during the function call are considered as an\n\"expected failure\" and will increase the failure count.\n\nget specific about the expected failure\n=======================================\nit is important, to be **as specific as possible**, when defining the expected exception.\nthe main purpose of a circuit breaker is to protect your distributed system from a cascading failure.\nthat means, you probably want to open the circuit breaker only, if the integration point on the other\nend is unavailable. so e.g. if there is an ``connectionerror`` or a request ``timeout``.\n\nif you are e.g. using the requests library (https://docs.python-requests.org/) for making http calls,\nits ``requestexception`` class would be a great choice for the ``expected_exception`` parameter.\n\nthe logic for treating thrown exceptions as failures can also be customized by passing a callable. the\ncallable will be passed the exception type and value, and should return true if the exception should be\ntreated as a failure.\n\nall recognized exceptions will be re-raised anyway, but the goal is, to let the circuit breaker only\nrecognize those exceptions which are related to the communication to your integration point.\n\nwhen it comes to monitoring (see monitoring_), it may lead to falsy conclusions, if a\ncircuit breaker opened, due to a local ``oserror`` or ``keyerror``, etc.\n\n\nconfiguration\n-------------\nthe following configuration options can be adjusted via decorator parameters. for example::\n\n    from circuitbreaker import circuit\n\n    @circuit(failure_threshold=10, expected_exception=connectionerror)\n    def external_call():\n        ...\n\n\n\nfailure threshold\n=================\nby default, the circuit breaker opens after 5 subsequent failures. you can adjust this value with the ``failure_threshold`` parameter.\n\nrecovery timeout\n================\nby default, the circuit breaker stays open for 30 seconds to allow the integration point to recover.\nyou can adjust this value with the ``recovery_timeout`` parameter.\n\nexpected exception\n==================\nby default, the circuit breaker listens for all exceptions which are based on the ``exception`` class.\nyou can adjust this with the ``expected_exception`` parameter. it can be either an exception class, an iterable of an exception classes,\nor a callable.\n\nuse a callable if the logic to flag exceptions as failures is more complex than a type check. for example::\n\n    # assume we are using the requests library\n    def is_not_http_error(thrown_type, thrown_value):\n        return issubclass(thrown_type, requestexception) and not issubclass(thrown_type, httperror)\n\n    def is_rate_limited(thrown_type, thrown_value):\n        return issubclass(thrown_type, httperror) and thrown_value.status_code == 429\n\n    @circuit(expected_exception=is_not_http_error)\n    def call_flaky_api(...):\n        rsp = requests.get(...)\n        rsp.raise_for_status()\n        return rsp\n\n    @circuit(expected_exception=is_rate_limited)\n    def call_slow_server(...):\n        rsp = requests.get(...)\n        rsp.raise_for_status()\n        return rsp\n        ```\n\nname\n====\nby default, the circuit breaker name is the name of the function it decorates. you can adjust the name with parameter ``name``.\n\nfallback function\n=================\nby default, the circuit breaker will raise a ``circuitbreaker`` exception when the circuit is opened.\nyou can instead specify a function to be called when the circuit is opened. this function can be specified with the\n``fallback_function`` parameter and will be called with the same parameters as the decorated function would be.\n\nthe fallback type of call must also match the decorated function. for instance, if the decorated function is an\nasync generator, the ``fallback_function`` must be an async generator as well.\n\nadvanced usage\n--------------\nif you apply circuit breakers to a couple of functions and you always set specific options other than the default values,\nyou can extend the ``circuitbreaker`` class and create your own circuit breaker subclass instead::\n\n    from circuitbreaker import circuitbreaker\n\n    class mycircuitbreaker(circuitbreaker):\n        failure_threshold = 10\n        recovery_timeout = 60\n        expected_exception = requestexception\n\n\nnow you have two options to apply your circuit breaker to a function. as an object directly::\n\n    @mycircuitbreaker()\n    def external_call():\n        ...\n\nplease note, that the circuit breaker class has to be initialized, you have to use a class instance as decorator (``@mycircuitbreaker()``), not the class itself (``@mycircuitbreaker``).\n\nor via the decorator proxy::\n\n    @circuit(cls=mycircuitbreaker)\n    def external_call():\n        ...\n\n\n.. _monitoring:\n\nmonitoring\n----------\nto keep track of the health of your application and the state of your circuit breakers, every circuit breaker registers itself at the ``circuitbreakermonitor``. you can receive all registered circuit breakers via ``circuitbreakermonitor.get_circuits()``.\n\nto get an aggregated health status, you can ask the monitor via ``circuitbreakermonitor.all_closed()``. or you can retrieve the currently open circuits via ``circuitbreakermonitor.get_open()`` and the closed circuits via ``circuitbreakermonitor.get_closed()``.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd-3-clause",
  "name": "circuitbreaker",
  "package_url": "https://pypi.org/project/circuitbreaker/",
  "project_url": "https://pypi.org/project/circuitbreaker/",
  "project_urls": {
    "Download": "https://github.com/fabfuel/circuitbreaker/archive/2.0.0.tar.gz",
    "Homepage": "https://github.com/fabfuel/circuitbreaker"
  },
  "release_url": "https://pypi.org/project/circuitbreaker/2.0.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "python circuit breaker pattern implementation",
  "version": "2.0.0",
  "releases": [],
  "developers": [
    "fabian_fuelling",
    "pypi@fabfuel.de"
  ],
  "kwds": "circuitbreaker get_circuits circuitbreakermonitor breaker circuits",
  "license_kwds": "bsd-3-clause",
  "libtype": "pypi",
  "id": "pypi_circuitbreaker",
  "homepage": "https://github.com/fabfuel/circuitbreaker",
  "release_count": 9,
  "dependency_ids": []
}