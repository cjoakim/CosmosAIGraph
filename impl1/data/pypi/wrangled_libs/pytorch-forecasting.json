{
  "classifiers": [
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: artificial intelligence",
    "topic :: scientific/engineering :: mathematics",
    "topic :: software development",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "![pytorch forecasting](./docs/source/_static/logo.svg)\n\n[pypi-image]: https://badge.fury.io/py/pytorch-forecasting.svg\n[pypi-url]: https://pypi.python.org/pypi/pytorch-forecasting\n[conda-image]: https://img.shields.io/conda/v/conda-forge/pytorch-forecasting\n[conda-url]: https://anaconda.org/conda-forge/pytorch-forecasting\n[build-image]: https://github.com/jdb78/pytorch-forecasting/actions/workflows/test.yml/badge.svg?branch=master\n[build-url]: https://github.com/jdb78/pytorch-forecasting/actions/workflows/test.yml?query=branch%3amaster\n[linter-image]: https://github.com/jdb78/pytorch-forecasting/actions/workflows/code_quality.yml/badge.svg?branch=master\n[linter-url]: https://github.com/jdb78/pytorch-forecasting/actions/workflows/code_quality.yml?query=branch%3amaster\n[docs-image]: https://readthedocs.org/projects/pytorch-forecasting/badge/?version=latest\n[docs-url]: https://pytorch-forecasting.readthedocs.io\n[coverage-image]: https://codecov.io/gh/jdb78/pytorch-forecasting/branch/master/graph/badge.svg\n[coverage-url]: https://codecov.io/github/jdb78/pytorch-forecasting?branch=master\n\n[![pypi version][pypi-image]][pypi-url] [![conda version][conda-image]][conda-url] [![docs status][docs-image]][docs-url] [![linter status][linter-image]][linter-url] [![build status][build-image]][build-url] [![code coverage][coverage-image]][coverage-url]\n\n**[documentation](https://pytorch-forecasting.readthedocs.io)** | **[tutorials](https://pytorch-forecasting.readthedocs.io/en/latest/tutorials.html)** | **[release notes](https://pytorch-forecasting.readthedocs.io/en/latest/changelog.html)**\n\n_pytorch forecasting_ is a pytorch-based package for forecasting time series with state-of-the-art network architectures. it provides a high-level api for training networks on pandas data frames and leverages\n[pytorch lightning](https://pytorch-lightning.readthedocs.io/) for scalable training on (multiple) gpus, cpus and for automatic logging.\n\n---\n\nour article on [towards data science](https://towardsdatascience.com/introducing-pytorch-forecasting-64de99b9ef46) introduces the package and provides background information.\n\npytorch forecasting aims to ease state-of-the-art timeseries forecasting with neural networks for real-world cases and research alike. the goal is to provide a high-level api with maximum flexibility for professionals and reasonable defaults for beginners.\nspecifically, the package provides\n\n- a timeseries dataset class which abstracts handling variable transformations, missing values,\n  randomized subsampling, multiple history lengths, etc.\n- a base model class which provides basic training of timeseries models along with logging in tensorboard\n  and generic visualizations such actual vs predictions and dependency plots\n- multiple neural network architectures for timeseries forecasting that have been enhanced\n  for real-world deployment and come with in-built interpretation capabilities\n- multi-horizon timeseries metrics\n- hyperparameter tuning with [optuna](https://optuna.readthedocs.io/)\n\nthe package is built on [pytorch-lightning](https://pytorch-lightning.readthedocs.io/) to allow training on cpus, single and multiple gpus out-of-the-box.\n\n# installation\n\nif you are working on windows, you need to first install pytorch with\n\n`pip install torch -f https://download.pytorch.org/whl/torch_stable.html`.\n\notherwise, you can proceed with\n\n`pip install pytorch-forecasting`\n\nalternatively, you can install the package via conda\n\n`conda install pytorch-forecasting pytorch -c pytorch>=1.7 -c conda-forge`\n\npytorch forecasting is now installed from the conda-forge channel while pytorch is install from the pytorch channel.\n\nto use the mqf2 loss (multivariate quantile loss), also install\n`pip install pytorch-forecasting[mqf2]`\n\n# documentation\n\nvisit [https://pytorch-forecasting.readthedocs.io](https://pytorch-forecasting.readthedocs.io) to read the\ndocumentation with detailed tutorials.\n\n# available models\n\nthe documentation provides a [comparison of available models](https://pytorch-forecasting.readthedocs.io/en/latest/models.html).\n\n- [temporal fusion transformers for interpretable multi-horizon time series forecasting](https://arxiv.org/pdf/1912.09363.pdf)\n  which outperforms deepar by amazon by 36-69% in benchmarks\n- [n-beats: neural basis expansion analysis for interpretable time series forecasting](http://arxiv.org/abs/1905.10437)\n  which has (if used as ensemble) outperformed all other methods including ensembles of traditional statical\n  methods in the m4 competition. the m4 competition is arguably the most important benchmark for univariate time series forecasting.\n- [n-hits: neural hierarchical interpolation for time series forecasting](http://arxiv.org/abs/2201.12886) which supports covariates and has consistently beaten n-beats. it is also particularly well-suited for long-horizon forecasting.\n- [deepar: probabilistic forecasting with autoregressive recurrent networks](https://www.sciencedirect.com/science/article/pii/s0169207019301888)\n  which is the one of the most popular forecasting algorithms and is often used as a baseline\n- simple standard networks for baselining: lstm and gru networks as well as a mlp on the decoder\n- a baseline model that always predicts the latest known value\n\nto implement new models or other custom components, see the [how to implement new models tutorial](https://pytorch-forecasting.readthedocs.io/en/latest/tutorials/building.html). it covers basic as well as advanced architectures.\n\n# usage example\n\nnetworks can be trained with the [pytorch lighning trainer](https://pytorch-lightning.readthedocs.io/en/latest/common/trainer.html) on [pandas dataframes](https://pandas.pydata.org/pandas-docs/stable/user_guide/dsintro.html#dataframe) which are first converted to a [timeseriesdataset](https://pytorch-forecasting.readthedocs.io/en/latest/data.html).\n\n```python\n# imports for training\nimport lightning.pytorch as pl\nfrom lightning.pytorch.loggers import tensorboardlogger\nfrom lightning.pytorch.callbacks import earlystopping, learningratemonitor\n# import dataset, network to train and metric to optimize\nfrom pytorch_forecasting import timeseriesdataset, temporalfusiontransformer, quantileloss\nfrom lightning.pytorch.tuner import tuner\n\n# load data: this is pandas dataframe with at least a column for\n# * the target (what you want to predict)\n# * the timeseries id (which should be a unique string to identify each timeseries)\n# * the time of the observation (which should be a monotonically increasing integer)\ndata = ...\n\n# define the dataset, i.e. add metadata to pandas dataframe for the model to understand it\nmax_encoder_length = 36\nmax_prediction_length = 6\ntraining_cutoff = \"yyyy-mm-dd\"  # day for cutoff\n\ntraining = timeseriesdataset(\n    data[lambda x: x.date <= training_cutoff],\n    time_idx= ...,  # column name of time of observation\n    target= ...,  # column name of target to predict\n    group_ids=[ ... ],  # column name(s) for timeseries ids\n    max_encoder_length=max_encoder_length,  # how much history to use\n    max_prediction_length=max_prediction_length,  # how far to predict into future\n    # covariates static for a timeseries id\n    static_categoricals=[ ... ],\n    static_reals=[ ... ],\n    # covariates known and unknown in the future to inform prediction\n    time_varying_known_categoricals=[ ... ],\n    time_varying_known_reals=[ ... ],\n    time_varying_unknown_categoricals=[ ... ],\n    time_varying_unknown_reals=[ ... ],\n)\n\n# create validation dataset using the same normalization techniques as for the training dataset\nvalidation = timeseriesdataset.from_dataset(training, data, min_prediction_idx=training.index.time.max() + 1, stop_randomization=true)\n\n# convert datasets to dataloaders for training\nbatch_size = 128\ntrain_dataloader = training.to_dataloader(train=true, batch_size=batch_size, num_workers=2)\nval_dataloader = validation.to_dataloader(train=false, batch_size=batch_size, num_workers=2)\n\n# create pytorch lighning trainer with early stopping\nearly_stop_callback = earlystopping(monitor=\"val_loss\", min_delta=1e-4, patience=1, verbose=false, mode=\"min\")\nlr_logger = learningratemonitor()\ntrainer = pl.trainer(\n    max_epochs=100,\n    accelerator=\"auto\",  # run on cpu, if on multiple gpus, use strategy=\"ddp\"\n    gradient_clip_val=0.1,\n    limit_train_batches=30,  # 30 batches per epoch\n    callbacks=[lr_logger, early_stop_callback],\n    logger=tensorboardlogger(\"lightning_logs\")\n)\n\n# define network to train - the architecture is mostly inferred from the dataset, so that only a few hyperparameters have to be set by the user\ntft = temporalfusiontransformer.from_dataset(\n    # dataset\n    training,\n    # architecture hyperparameters\n    hidden_size=32,\n    attention_head_size=1,\n    dropout=0.1,\n    hidden_continuous_size=16,\n    # loss metric to optimize\n    loss=quantileloss(),\n    # logging frequency\n    log_interval=2,\n    # optimizer parameters\n    learning_rate=0.03,\n    reduce_on_plateau_patience=4\n)\nprint(f\"number of parameters in network: {tft.size()/1e3:.1f}k\")\n\n# find the optimal learning rate\nres = tuner(trainer).lr_find(\n    tft, train_dataloaders=train_dataloader, val_dataloaders=val_dataloader, early_stop_threshold=1000.0, max_lr=0.3,\n)\n# and plot the result - always visually confirm that the suggested learning rate makes sense\nprint(f\"suggested learning rate: {res.suggestion()}\")\nfig = res.plot(show=true, suggest=true)\nfig.show()\n\n# fit the model on the data - redefine the model with the correct learning rate if necessary\ntrainer.fit(\n    tft, train_dataloaders=train_dataloader, val_dataloaders=val_dataloader,\n)\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "pytorch-forecasting",
  "package_url": "https://pypi.org/project/pytorch-forecasting/",
  "project_url": "https://pypi.org/project/pytorch-forecasting/",
  "project_urls": {
    "Documentation": "https://pytorch-forecasting.readthedocs.io",
    "Homepage": "https://pytorch-forecasting.readthedocs.io",
    "Repository": "https://github.com/jdb78/pytorch-forecasting"
  },
  "release_url": "https://pypi.org/project/pytorch-forecasting/1.0.0/",
  "requires_dist": [
    "torch (>=2.0.0,<3.0.0)",
    "lightning (>=2.0.0,<3.0.0)",
    "optuna (>=3.1.0,<4.0.0)",
    "scipy (>=1.8,<2.0)",
    "pandas (>=1.3.0,<=3.0.0)",
    "scikit-learn (>=1.2,<2.0)",
    "matplotlib",
    "statsmodels",
    "pytest-github-actions-annotate-failures ; extra == \"github-actions\"",
    "networkx (>=3.0.0,<4.0.0) ; extra == \"graph\"",
    "cpflows (>=0.1.2,<0.2.0) ; extra == \"mqf2\"",
    "fastapi (>=0.80)",
    "pytorch-optimizer (>=2.5.1,<3.0.0)"
  ],
  "requires_python": ">=3.8,<3.11",
  "summary": "forecasting timeseries with pytorch - dataloaders, normalizers, metrics and models",
  "version": "1.0.0",
  "releases": [],
  "developers": [
    "jan_beitner"
  ],
  "kwds": "pytorch_forecasting pytorch _pytorch forecasting_ py",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_pytorch_forecasting",
  "homepage": "https://pytorch-forecasting.readthedocs.io",
  "release_count": 34,
  "dependency_ids": [
    "pypi_cpflows",
    "pypi_fastapi",
    "pypi_lightning",
    "pypi_matplotlib",
    "pypi_networkx",
    "pypi_optuna",
    "pypi_pandas",
    "pypi_pytest_github_actions_annotate_failures",
    "pypi_pytorch_optimizer",
    "pypi_scikit_learn",
    "pypi_scipy",
    "pypi_statsmodels",
    "pypi_torch"
  ]
}