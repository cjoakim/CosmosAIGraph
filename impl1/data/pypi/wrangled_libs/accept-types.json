{
  "classifiers": [
    "environment :: web environment",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python"
  ],
  "description": "========================================================\naccept-types - use the correct accept type for a request\n========================================================\n\n``accept-types`` helps your application respond to a http request in a way that a client prefers.\nthe ``accept`` header of an http request informs the server which mime types the client is expecting\nback from this request, with weighting to indicate the most prefered. if your server can respond in\nmultiple formats (e.g.: json, xml, html), the client can easily tell your server which is the\nprefered format without resorting to hacks like '&amp;format=json' on the end of query strings.\n\n\nusage\n=====\n\n``get_best_match``\n------------------\n\nwhen provided with an ``accept`` header and a list of types your server can respond with, this function\nreturns the clients most prefered type. this function will only return one of the acceptable types you\npassed in, or ``none`` if no suitable type was found:\n\n.. code:: python\n\n\tfrom accept_type import get_best_match\n\n\tdef get_the_info(request):\n\t\tinfo = gather_info()\n\n\t\treturn_type = get_best_match(request.meta.get('http_accept'), ['text/html', 'application/xml', 'text/json'])\n\n\t\tif return_type == 'application/xml':\n\t\t\treturn render_xml(info)\n\n\t\telif return_type == 'text/json':\n\t\t\treturn render_json(info)\n\n\t\telif return_type == 'text/html':\n\t\t\treturn render_html(info)\n\n\t\telif return_type == none:\n\t\t\treturn httpresponse406()\n\n``parse_header``\n----------------\n\nwhen provided with an ``accept`` header, this will parse it and return a sorted list of the clients\naccepted mime types. these will be instances of the ``acceptabletype`` class.\n\n.. code:: python\n\n\t>>> from accept_type import parse_header\n\t>>> parse_header('text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8')\n\t['text/html, weight 1', 'application/xhtml+xml, weight 1', 'application/xml, weight 0.9', '*/*, weight 0.8']\n\n``acceptabletype``\n------------------\n\n``acceptabletype`` instances represent one of the types that a client is willing to accept. this\ntype could include wildcards, to match more than one mime type.\n\n.. code:: python\n\n\t>>> from accept_type import acceptabletype\n\t>>> type = acceptabletype('image/*;q=0.9')\n\tacceptabletype\n\t>>> type.mime_type\n\t'image/*'\n\t>>> type.weight\n\t0.9\n\t>>> type.matches('image/png')\n\ttrue\n\t>>> type.matches('text/html')\n\tfalse\n\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "accept-types",
  "package_url": "https://pypi.org/project/accept-types/",
  "project_url": "https://pypi.org/project/accept-types/",
  "project_urls": {
    "Homepage": "https://bitbucket.org/tim_heap/python-accept-types"
  },
  "release_url": "https://pypi.org/project/accept-types/0.4.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "determine the best content to send in an http response",
  "version": "0.4.1",
  "releases": [],
  "developers": [
    "tim@timheap.me",
    "tim_heap"
  ],
  "kwds": "accept_type mime_type http_accept acceptabletype return_type",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_accept_types",
  "homepage": "https://bitbucket.org/tim_heap/python-accept-types",
  "release_count": 5,
  "dependency_ids": []
}