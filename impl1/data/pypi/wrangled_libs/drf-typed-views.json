{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6"
  ],
  "description": "## django rest framework - typed views\n\n[![package version](https://badge.fury.io/py/drf-typed-views.svg)](https://pypi.python.org/pypi/drf-typed-views)\n[![python versions](https://img.shields.io/pypi/status/drf-typed-views.svg)](https://img.shields.io/pypi/status/drf-typed-views.svg/)\n\nthis project extends [django rest framework](https://www.django-rest-framework.org/) to allow use of python's type annotations for automatically validating and casting view parameters. this pattern makes for code that is easier to read and write. view inputs are individually declared, not buried inside all-encompassing `request` objects. meanwhile, you get even more out of type annotations: they can replace repetitive validation/sanitization code. \n\nmore features:\n- [pydantic](https://pydantic-docs.helpmanual.io/) models and [marshmallow](https://marshmallow.readthedocs.io) schemas are compatible types for view parameters. annotate your post/put functions with them to automatically validate incoming request bodies.\n- advanced validators for more than just the type: `min_value`/`max_value` for numbers\n- validate string formats: `email`, `uuid` and `ipv4/6`; use python's native `enum` for \"choices\" validation\n\nquick example:\n```python\nfrom rest_typed_views import typed_api_view\n\n@typed_api_view([\"get\"])\ndef get_users(registered_on: date = none, groups: list[int] = none, is_staff: bool = none):\n    print(registered_on, groups, is_staff)\n```\n\nget `/users/registered/?registered_on=2019-03-03&groups=4,5&is_staff=yes`<br>\nstatus code: 200\n```\n    date(2019, 3, 3)   [4, 5]  true\n```\n\nget `/users/?registered_on=9999&groups=admin&is_staff=maybe`<br>\n:no_entry_sign: status code: 400 *validationerror raised* \n```json\n    {\n        \"registered_on\": \"'9999' is not a valid date\",\n        \"groups\": \"'admin' is not a valid integer\",\n        \"is_staff\": \"'maybe' is not a valid boolean\"\n    }\n```\n## table of contents\n* [install & decorators](#install--decorators)\n* [how it works: simple usage](#how-it-works-simple-usage)\n  * [basic get request](#basic-get-request)\n  * [basic post request](#basic-post-request)\n* [how it works: advanced usage](#how-it-works-advanced-usage)\n  * [additional validation rules](#additional-validation-rules)\n  * [nested body fields](#nested-body-fields)\n  * [list validation](#list-validation)\n  * [accessing the request object](#accessing-the-request-object)\n  * [interdependent query parameter validation](#interdependent-query-parameter-validation)\n  * [(simple) access control](#simple-access-control)\n* [enabling marshmallow, pydantic schemas](#enabling-3rd-party-validators)\n* [request element classes](#request-element-classes)\n  * [query](#query)\n  * [body](#body)\n  * [path](#path)\n  * [header](#header)\n  * [currentuser](#currentuser)\n* [supported types/validator rules](#supported-types-and-validator-rules)\n  * [int](#int)\n  * [float](#float)\n  * [decimal](#decimal)\n  * [str](#str)\n  * [bool](#bool)\n  * [datetime](#datetime)\n  * [date](#date)\n  * [time](#time)\n  * [timedelta](#timedelta)\n  * [list](#list)\n  * [enum](#enum)\n  * [marshmallow.schema](#marshmallowschema)\n  * [pydantic.basemodel](#pydanticbasemodel)\n* [change log](#changes)\n* [motivation & inspiration](#motivation)\n\n## install & decorators\n\n```\npip install drf-typed-views\n```\n\nyou can add type annotation-enabled features to either `viewset` methods or function-based views using the `typed_action` and `typed_api_view` decorators. they take the exact same arguments as django rest's [`api_view`](https://www.django-rest-framework.org/api-guide/views/#api_view) and [`action`](https://www.django-rest-framework.org/api-guide/viewsets/#marking-extra-actions-for-routing) decorators.\n\n## how it works: simple usage\n\nfor many cases, you can rely on implicit behavior for how different parts of the request (url path variables, query parameters, body) map to the parameters of a view function/method. \n\nthe value of a view parameter will come from...\n- the url path if the path variable and the view argument have the same name, *or*:\n- the request body if the view argument is annotated using a class from a supported library for complex object validation (pydantic, marshmallow), *or*:\n- a query parameter with the same name\n\nunless a default value is given, the parameter is **required** and a [`validationerror`](https://www.django-rest-framework.org/api-guide/exceptions/#validationerror) will be raised if not set.\n\n### basic get request\n```python\nurlpatterns = [\n    url(r\"^(?p<city>[\\w+])/restaurants/\", search_restaurants)\n]\n\nfrom rest_typed_views import typed_api_view\n\n# example request: /chicago/restaurants?delivery=yes\n@typed_api_view([\"get\"])\ndef search_restaurants(city: str, rating: float = none, offers_delivery: bool = none):\n    restaurants = restaurant.objects.filter(city=city)\n\n    if rating is not none:\n        restaurants = restaurants.filter(rating__gte=rating)\n\n    if offers_delivery is not none:\n        restaurants = restaurants.filter(delivery=offers_delivery)\n```\n\nin this example, `city` is required and must be its string. its value comes from the url path variable with the same name. the other parameters, `rating` and `offers_delivery`, are not part of the path parameters and are assumed to be query parameters. they both have a default value, so they are optional.\n\n### basic post request \n```python\n# urls.py\nurlpatterns = [url(r\"^(?p<city>[\\w+])/bookings/\", create_booking)]\n\n# settings.py\ndrf_typed_views = {\"schema_packages\": [\"pydantic\"]}\n\n# views.py\nfrom pydantic import basemodel\nfrom rest_typed_views import typed_api_view\n\n\nclass roomenum(str, enum):\n    double = 'double'\n    twin = 'twin'\n    single = 'single'\n\n\nclass bookingschema(basemodel):\n    start_date: date\n    end_date: date\n    room: roomenum = roomenum.double\n    include_breakfast: bool = false\n\n# example request: /chicago/bookings/\n@typed_api_view([\"post\"])\ndef create_booking(city: str, booking: bookingschema):\n    # do something with the validated booking...\n```\n\nin this example, `city` will again be populated using the url path variable. the `booking` parameter is annotated using a supported complex schema class (pydantic), so it's assumed to come from the request body, which will be read in as json, used to hydrate the pydantic `bookingschema` and then validated. if validation fails a `validationerror` will be raised.\n\n## how it works: advanced usage\n\nfor more advanced use cases, you can explicitly declare how each parameter's value is sourced from the request -- from the query parameters, path, body or headers -- as well as define additional validation rules. you import a class named after the request element that is expected to hold the value and assign it to the parameter's default.\n\n```python\nfrom rest_typed_views import typed_api_view, query, path\n\n@typed_api_view([\"get\"])\ndef list_documents(year: date = path(), title: str = query(default=none)):\n    # orm logic here...\n```\n\nin this example, `year` is required and must come from the url path and `title` is an optional query parameter because the `default` is set. this is similar to django rest's [serializer fields](https://www.django-rest-framework.org/api-guide/fields/#core-arguments):  passing a default implies that the filed is not required. \n\n```python\nfrom rest_typed_views import typed_api_view, header\n\n@typed_api_view([\"get\"])\ndef get_cache_header(cache: str = header()):\n    # orm logic here...\n```\n\nin this example, `cache` is required and must come from the headers. \n\n### additional validation rules\n\nyou can use the request element class (`query`, `path`, `body`, `header`) to set additional validation constraints. you'll find that these keywords are consistent with django rest's serializer fields.\n\n```python\nfrom rest_typed_views import typed_api_view, query, path\n\n@typed_api_view([\"get\"])\ndef search_restaurants(\n    year: date = path(), \n    rating: int = query(default=none, min_value=1, max_value=5)\n):\n    # orm logic here...\n\n\n@typed_api_view([\"get\"])\ndef get_document(id: str = path(format=\"uuid\")):\n    # orm logic here...\n\n\n@typed_api_view([\"get\"])\ndef search_users(\n    email: str = query(default=none, format=\"email\"), \n    ip_address: str = query(default=none, format=\"ip\"), \n):\n    # orm logic here...\n```\n\nview a [full list](#supported-types-and-validator-rules) of supported types and additional validation rules.\n\n### nested body fields\n\nsimilar to how `source` is used in django rest to control field mappings during serialization, you can use it to specify the exact path to the request data.\n\n```python\nfrom pydantic import basemodel\nfrom rest_typed_views import typed_api_view, query, path\n\nclass document(basemodel):\n    title: str\n    body: str\n\n\"\"\"\n    post\n    {\n        \"strict\": false,\n        \"data\": {\n            \"title\": \"a dark and stormy night\",\n            \"body\": \"once upon a time\"\n        }\n    }\n\"\"\"\n@typed_api_view([\"post\"])\ndef create_document(\n    strict_mode: bool = body(source=\"strict\"), \n    item: document = body(source=\"data\")\n):\n    # orm logic here...\n```\nyou can also use dot-notation to source data multiple levels deep in the json payload.\n\n### list validation\n\nfor the basic case of list validation - validating types within a comma-delimited string - declare the type to get automatic validation/coercion:\n\n```python\nfrom rest_typed_views import typed_api_view, query\n\n@typed_api_view([\"get\"])\ndef search_movies(item_ids: list[int] = [])):\n    print(item_ids)\n\n# get /movies?items_ids=41,64,3\n# [41, 64, 3]\n```\n\nbut you can also specify `min_length` and `max_length`, as well as the `delimiter` and specify additional rules for the child items -- think django rest's [listfield](https://www.django-rest-framework.org/api-guide/fields/#listfield).\n\nimport the generic `param` class and use it to set the rules for the `child` elements:\n\n```python\nfrom rest_typed_views import typed_api_view, query, param\n\n@typed_api_view([\"get\"])\ndef search_outcomes(\n    scores: list[int] = query(delimiter=\"|\", child=param(min_value=0, max_value=100))\n):\n    # orm logic ...\n\n@typed_api_view([\"get\"])\ndef search_message(\n    recipients: list[str] = query(min_length=1, max_length=10, child=param(format=\"email\"))\n):\n    # orm logic ...\n```\n\n### accessing the request object\n\nyou probably won't need to access the `request` object directly, as this package will provide its relevant properties as view arguments. however, you can include it as a parameter annotated with its type and it will be injected:\n\n```python\nfrom rest_framework.request import request\nfrom rest_typed_views import typed_api_view\n\n@typed_api_view([\"get\"])\ndef search_documens(request: request, q: str = none):\n    # orm logic ...\n```\n\n### interdependent query parameter validation\noften, it's useful to validate a combination of query parameters - for instance, a `start_date` shouldn't come after an `end_date`. you can use complex schema object (pydantic or marshmallow) for this scenario. in the example below, `query(source=\"*\")` is instructing an instance of `searchparamsschema` to be populated/validated using all of the query parameters together: `request.query_params.dict()`.  \n\n```python\nfrom marshmallow import schema, fields, validates_schema, validationerror\nfrom rest_typed_views import typed_api_view\n\nclass searchparamsschema(schema):\n    start_date = fields.date()\n    end_date = fields.date()\n\n    @validates_schema\n    def validate_numbers(self, data, **kwargs):\n        if data[\"start_date\"] >= data[\"end_date\"]:\n            raise validationerror(\"end_date must come after start_date\")\n\n@typed_api_view([\"get\"])\ndef search_documens(search_params: searchparamsschema = query(source=\"*\")):\n    # orm logic ...\n```\n\n### (simple) access control\n\nyou can apply some very basic access control by applying some validation rules to a view parameter sourced from the `currentuser` request element class. in the example below, a `validationerror` will be raised if the `request.user` is not a member of either `super_users` or `admins`.\n\n```python\n    from my_pydantic_schemas import bookingschema\n    from rest_typed_views import typed_api_view, currentuser\n\n    @typed_api_view([\"post\"])\n    def create_booking(\n        booking: bookingschema, \n        user: user = currentuser(member_of_any=[\"super_users\", \"admins\"])\n    ):\n        # do something with the request.user\n```\n\nread more about the [`current user` request element class](#current-user-keywords).\n\n## enabling marshmallow, pydantic schemas <a id=\"enabling-3rd-party-validators\"></a>\n\nas an alternative to django rest's serializers, you can annotate views with [pydantic](https://pydantic-docs.helpmanual.io/) models or [marshmallow](https://marshmallow.readthedocs.io/en/stable/) schemas to have their parameters automatically validated and pass an instance of the pydantic/marshmallow class to your method/function.\n\nto enable support for third-party libraries for complex object validation, modify your settings:\n\n```python\ndrf_typed_views = {\n    \"schema_packages\": [\"pydantic\", \"marshmallow\"]\n}\n```\n\nthese third-party packages must be installed in your virtual environment/runtime.\n\n## request element classes\n\nyou can specify the part of the request that holds each view parameter by using default function arguments, for example:\n```python\n    from rest_typed_views import body, query\n\n    @typed_api_view([\"put\"])\n    def update_user(\n        user: userschema = body(), \n        optimistic_update: bool = query(default=false)\n    ):\n```\n\nthe `user` parameter will come from the request body and is required because no default is provided. meanwhile, `optimistic_update` is not required and will be populated from a query parameter with the same name. \n\nthe core keyword arguments to these classes are:\n- `default` the default value for the parameter, which is required unless set\n- `source` if the view parameter has a different name than its key embedded in the request\n\npassing keywords for additional validation constraints is a *powerful capability* that gets you *almost the same feature set* as django rest's flexible [serializer fields](https://www.django-rest-framework.org/api-guide/fields/). see a [complete list](#supported-types-and-validator-rule) of validation keywords.\n\n\n### query\nuse the `source` argument to alias the parameter value and pass keywords to set additional constraints. for example, your query parameters can have dashes, but be mapped to a parameter that have underscores:\n\n```python\n    from rest_typed_views import typed_api_view, query\n\n    @typed_api_view([\"get\"])\n    def search_events(\n        starting_after: date = query(source=\"starting-after\"),\n        available_tickets: int = query(default=0, min_value=0)\n    ):\n        # orm logic here...\n```\n\n### body\nby default, the entire request body is used to populate parameters marked with this class (`source=\"*\"`):\n\n```python\n    from rest_typed_views import typed_api_view, body\n    from my_pydantic_schemas import residencelisting\n\n    @typed_api_view([\"post\"])\n    def create_listing(residence: residencelisting = body()):\n        # orm logic ...\n```\n\nhowever, you can also specify nested fields in the request body, with support for dot notation.\n\n```python\n    \"\"\"\n        post  /users/\n        {\n            \"first_name\": \"homer\",\n            \"last_name\": \"simpson\",\n            \"contact\": {\n                \"phone\" : \"800-123-456\",\n                \"fax\": \"13235551234\"\n            }\n        }\n    \"\"\"\n    from rest_typed_views import typed_api_view, body\n\n    @typed_api_view([\"post\"])\n    def create_user(\n        first_name: str = body(source=\"first_name\"),\n        last_name: str = body(source=\"last_name\"),\n        phone: str = body(source=\"contact.phone\", min_length=10, max_length=20)\n    ):\n        # orm logic ...\n```\n\n### path\nuse the `source` argument to alias a view parameter name. more commonly, though, you can set additional validation rules for parameters coming from the url path. \n\n```python\n    from rest_typed_views import typed_api_view, query\n\n    @typed_api_view([\"get\"])\n    def retrieve_event(id: int = path(min_value=0, max_value=1000)):\n        # orm logic here...\n```\n\n### header\nuse the `header` request element class to automatically retrieve a value from a header. underscores in variable names are automatically converted to dashes. \n\n```python\n    from rest_typed_views import typed_api_view, header\n\n    @typed_api_view([\"get\"])\n    def retrieve_event(id: int, cache_control: str = header(default=\"no-cache\")):\n        # orm logic here...\n```\n\nif you prefer, you can explicitly specify the exact header key:\n```python\n    from rest_typed_views import typed_api_view, header\n\n    @typed_api_view([\"get\"])\n    def retrieve_event(id: int, cache_control: str = header(source=\"cache-control\", default=\"no-cache\")):\n        # orm logic here...\n```\n\n### currentuser <a id=\"current-user-keywords\"></a>\n\nuse this class to have a view parameter populated with the current user of the request. you can even extract fields from the current user using the `source` option.\n\n```python\n    from my_pydantic_schemas import bookingschema\n    from rest_typed_views import typed_api_view, currentuser\n\n    @typed_api_view([\"post\"])\n    def create_booking(booking: bookingschema, user: user = currentuser()):\n        # do something with the request.user\n\n    @typed_api_view([\"get\"])\n    def retrieve_something(first_name: str = currentuser(source=\"first_name\")):\n        # do something with the request.user's first name\n```\nyou can also pass some additional parameters to the `currentuser` request element class to implement simple access control:\n- `member_of` (str) validates that the current `request.user` is a member of a group with this name\n- `member_of_any` (list[str]) validates that the current `request.user` is a member of one of these groups\n\n*using these keyword validators assumes that your `user` model has a many-to-many relationship with `django.contrib.auth.models.group` via `user.groups`.*\n\nan example:\n\n```python\nfrom django.contrib.auth.models import user\nfrom rest_typed_views import typed_api_view, currentuser\n\n@typed_api_view([\"get\"])\ndef do_something(user: user = currentuser(member_of=\"admin\")):\n    # now have a user instance (assuming validationerror wasn't raised)\n```\n## supported types and validator rules\n\nthe following native python types are supported. depending on the type, you can pass additional validation rules to the request element class (`query`, `path`, `body`). you can think of the type combining with the validation rules to create a django rest serializer field on the fly -- in fact, that's what happens behind the scenes.\n\n### str\nadditional arguments:\n- `max_length` validates that the input contains no more than this number of characters.\n- `min_length` validates that the input contains no fewer than this number of characters.\n- `trim_whitespace` (bool; default `true`) whether to trim leading and trailing white space.\n- `format` validates that the string matches a common format; supported values:\n    - `email` validates the text to be a valid e-mail address.\n    - `slug` validates the input against the pattern `[a-za-z0-9_-]+`.\n    - `uuid` validates the input is a valid uuid string\n    - `url` validates fully qualified urls of the form `http://<host>/<path>`\n    - `ip` validates input is a valid ipv4 or ipv6 string\n    - `ipv4` validates input is a valid ipv4 string\n    - `ipv6` validates input is a valid ipv6 string\n    - `file_path` validates that the input corresponds to filenames in a certain directory on the filesystem; allows all the same keyword arguments as django rest's [`filepathfield`](https://www.django-rest-framework.org/api-guide/fields/#filepathfield)\n\nsome examples:\n\n```python\nfrom rest_typed_views import typed_api_view, query\n\n@typed_api_view([\"get\"])\ndef search_users(email: str = query(format='email')):\n    # orm logic here...\n    return response(data)\n\n@typed_api_view([\"get\"])\ndef search_shared_links(url: str = query(default=none, format='url')):\n    # orm logic here...\n    return response(data)\n\n@typed_api_view([\"get\"])\ndef search_request_logs(ip_address: str = query(default=none, format='ip')):\n    # orm logic here...\n    return response(data)\n```\n\n### int\nadditional arguments:\n- `max_value` validate that the number provided is no greater than this value.\n- `min_value` validate that the number provided is no less than this value.\n\nan example:\n```python\nfrom rest_typed_views import typed_api_view, query\n\n@typed_api_view([\"get\"])\ndef search_products(inventory: int = query(min_value=0)):\n    # orm logic here...\n```\n\n### float\nadditional arguments:\n- `max_value` validate that the number provided is no greater than this value.\n- `min_value` validate that the number provided is no less than this value.\n\nan example:\n```python\nfrom rest_typed_views import typed_api_view, query\n\n@typed_api_view([\"get\"])\ndef search_products(price: float = query(min_value=0)):\n    # orm logic here...\n```\n\n### decimal\nadditional arguments:\n- `max_value` validate that the number provided is no greater than this value.\n- `min_value` validate that the number provided is no less than this value.\n- .. even more ... accepts the same arguments as [django rest's `decimalfield`](https://www.django-rest-framework.org/api-guide/fields/#decimalfield)\n\n### bool\nview parameters annotated with this type will validate and coerce the same values as django rest's `booleanfield`, including but not limited to the following:\n```python\n    true_values = [\"yes\", 1, \"on\", \"y\", \"true\"]\n    false_values = [\"no\", 0, \"off\", \"n\", \"false\"]\n```\n\n### datetime\nadditional arguments:\n- `input_formats` a list of input formats which may be used to parse the date-time, defaults to django's `datetime_input_formats` settings, which defaults to `['iso-8601']`\n- `default_timezone`  a `pytz.timezone` of the timezone. if not specified, falls back to django's `use_tz` setting.\n\n### date\nadditional arguments:\n- `input_formats` a list of input formats which may be used to parse the date, defaults to django's `datetime_input_formats` settings, which defaults to `['iso-8601']`\n\n### time\nadditional arguments:\n- `input_formats` a list of input formats which may be used to parse the time, defaults to django's `time_input_formats` settings, which defaults to `['iso-8601']`\n\n### timedelta\nvalidates strings of the format `'[dd] [hh:[mm:]]ss[.uuuuuu]'` and converts them to a `datetime.timedelta` instance.\n\nadditional arguments:\n- `max_value` validate that the input duration is no greater than this value.\n- `min_value` validate that the input duration is no less than this value.\n\n### list\nvalidates strings of the format `'[dd] [hh:[mm:]]ss[.uuuuuu]'` and converts them to a `datetime.timedelta` instance.\n\nadditional arguments:\n- `min_length` validates that the list contains no fewer than this number of elements.\n- `max_length` validates that the list contains no more than this number of elements.\n- `child` pass keyword constraints via a `param` instance to to validate the members of the list.\n\nan example:\n```python\nfrom rest_typed_views import typed_api_view, param, query\n\n@typed_api_view([\"get\"])\ndef search_contacts(emails: list[str] = query(max_length=10, child=param(format=\"email\"))):\n    # orm logic here...\n```\n\n### enum\nvalidates that the value of the input is one of a limited set of choices. think of this as mapping to a django rest [`choicefield`](https://www.django-rest-framework.org/api-guide/fields/#choicefield).\n\nan example:\n```python\nfrom rest_typed_views import typed_api_view, query\n\nclass straws(str, enum):\n    paper = \"paper\"\n    plastic = \"plastic\"\n\n@typed_api_view([\"get\"])\ndef search_straws(type: straws = none):\n    # orm logic here...\n```\n\n### marshmallow.schema\nyou can annotate view parameters with [marshmallow schemas](https://marshmallow.readthedocs.io/en/stable/) to validate request data and pass an instance of the schema to the view.\n\n```python\nfrom marshmallow import schema, fields\nfrom rest_typed_views import typed_api_view, query\n\nclass artistschema(schema):\n    name = fields.str()\n\nclass albumschema(schema):\n    title = fields.str()\n    release_date = fields.date()\n    artist = fields.nested(artistschema())\n\n\"\"\"\n    post \n    {\n        \"title\": \"michael scott's greatest hits\",\n        \"release_date\": \"2019-03-03\",\n        \"artist\": {\n            \"name\": \"michael scott\"\n        }\n    }\n\"\"\"\n@typed_api_view([\"post\"])\ndef create_album(album: albumschema):\n    # now have an album instance (assuming validationerror wasn't raised)\n```\n\n### pydantic.basemodel\nyou can annotate view parameters with [pydantic models](https://pydantic-docs.helpmanual.io/) to validate request data and pass an instance of the model to the view.\n\n```python\nfrom pydantic import basemodel\nfrom rest_typed_views import typed_api_view, query\n\nclass user(basemodel):\n    id: int\n    name: str\n    signup_ts: datetime = none\n    friends: list[int] = []\n\n\"\"\"\n    post \n    {\n        \"id\": 24529782,\n        \"name\": \"michael scott\",\n        \"friends\": [24529782]\n    }\n\"\"\"\n@typed_api_view([\"post\"])\ndef create_user(user: user):\n    # now have a user instance (assuming validationerror wasn't raised)\n```\n\n## change log\n\n* june 7, 2020\n  * fixes compatability with drf decorator. thanks @sjquant!\n  * makes django's querydict work with marshmallow and pydantic validators. thanks @filwaline!\n* february 2, 2020: adds support for `header` request parameter. thanks @bbkgh!\n\n## motivation\n\nwhile rest framework's modelviewsets and modelserializers are very productive when building out crud resources, i've felt less productive in the framework when developing other types of operations. serializers are a powerful and flexible way to validate incoming request data, but are not as self-documenting as type annotations. furthermore, the django ecosystem is hugely productive and i see no reason why rest framework cannot take advantage of more python 3 features.\n\n## inspiration\n\ni first came across type annotations for validation in [api star](https://github.com/encode/apistar), which has since evolved into an openapi toolkit. this pattern has also been offered by [hug](https://hugapi.github.io/hug/) and [molten](https://github.com/bogdanp/molten) (i believe in that order). furthermore, i've borrowed ideas from [fastapi](https://github.com/tiangolo/fastapi), specifically its use of default values to declare additional validation rules. finally, this [blog post](https://instagram-engineering.com/types-for-python-http-apis-an-instagram-story-d3c3a207fdb7) from instagram's engineering team showed me how decorators can be used to implement these features on view functions.",
  "docs_url": null,
  "keywords": "django rest type annotations automatic validation validate",
  "license": "mit",
  "name": "drf-typed-views",
  "package_url": "https://pypi.org/project/drf-typed-views/",
  "project_url": "https://pypi.org/project/drf-typed-views/",
  "project_urls": {
    "Homepage": "https://github.com/rsinger86/drf-typed-views"
  },
  "release_url": "https://pypi.org/project/drf-typed-views/0.3.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "use type annotations for automatic request validation in django rest framework",
  "version": "0.3.0",
  "releases": [],
  "developers": [
    "robert_singer",
    "robertgsinger@gmail.com"
  ],
  "kwds": "rest_typed_views drf_typed_views typed_api_view django rest_framework",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_drf_typed_views",
  "homepage": "https://github.com/rsinger86/drf-typed-views",
  "release_count": 8,
  "dependency_ids": []
}