{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# aws identity and access management construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\ndefine a role and add permissions to it. this will automatically create and\nattach an iam policy to the role:\n\n```python\nrole = role(self, \"myrole\",\n    assumed_by=serviceprincipal(\"sns.amazonaws.com\")\n)\n\nrole.add_to_policy(policystatement(\n    resources=[\"*\"],\n    actions=[\"lambda:invokefunction\"]\n))\n```\n\ndefine a policy and attach it to groups, users and roles. note that it is possible to attach\nthe policy either by calling `xxx.attachinlinepolicy(policy)` or `policy.attachtoxxx(xxx)`.\n\n```python\nuser = user(self, \"myuser\", password=cdk.secretvalue.unsafe_plain_text(\"1234\"))\ngroup = group(self, \"mygroup\")\n\npolicy = policy(self, \"mypolicy\")\npolicy.attach_to_user(user)\ngroup.attach_inline_policy(policy)\n```\n\nmanaged policies can be attached using `xxx.addmanagedpolicy(managedpolicy.fromawsmanagedpolicyname(policyname))`:\n\n```python\ngroup = group(self, \"mygroup\")\ngroup.add_managed_policy(managedpolicy.from_aws_managed_policy_name(\"administratoraccess\"))\n```\n\n## granting permissions to resources\n\nmany of the aws cdk resources have `grant*` methods that allow you to grant other resources access to that resource. as an example, the following code gives a lambda function write permissions (put, update, delete) to a dynamodb table.\n\n```python\n# fn: lambda.function\n# table: dynamodb.table\n\n\ntable.grant_write_data(fn)\n```\n\nthe more generic `grant` method allows you to give specific permissions to a resource:\n\n```python\n# fn: lambda.function\n# table: dynamodb.table\n\n\ntable.grant(fn, \"dynamodb:putitem\")\n```\n\nthe `grant*` methods accept an `igrantable` object. this interface is implemented by iam principlal resources (groups, users and roles) and resources that assume a role such as a lambda function, ec2 instance or a codebuild project.\n\nyou can find which `grant*` methods exist for a resource in the [aws cdk api reference](https://docs.aws.amazon.com/cdk/api/latest/docs/aws-construct-library.html).\n\n## roles\n\nmany aws resources require *roles* to operate. these roles define the aws api\ncalls an instance or other aws service is allowed to make.\n\ncreating roles and populating them with the right permissions *statements* is\na necessary but tedious part of setting up aws infrastructure. in order to\nhelp you focus on your business logic, cdk will take care of creating\nroles and populating them with least-privilege permissions automatically.\n\nall constructs that require roles will create one for you if don't specify\none at construction time. permissions will be added to that role\nautomatically if you associate the construct with other constructs from the\naws construct library (for example, if you tell an *aws codepipeline* to trigger\nan *aws lambda function*, the pipeline's role will automatically get\n`lambda:invokefunction` permissions on that particular lambda function),\nor if you explicitly grant permissions using `grant` functions (see the\nprevious section).\n\n### opting out of automatic permissions management\n\nyou may prefer to manage a role's permissions yourself instead of having the\ncdk automatically manage them for you. this may happen in one of the\nfollowing cases:\n\n* you don't like the permissions that cdk automatically generates and\n  want to substitute your own set.\n* the least-permissions policy that the cdk generates is becoming too\n  big for iam to store, and you need to add some wildcards to keep the\n  policy size down.\n\nto prevent constructs from updating your role's policy, pass the object\nreturned by `myrole.withoutpolicyupdates()` instead of `myrole` itself.\n\nfor example, to have an aws codepipeline *not* automatically add the required\npermissions to trigger the expected targets, do the following:\n\n```python\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"codepipeline.amazonaws.com\"),\n    # custom description if desired\n    description=\"this is a custom role...\"\n)\n\ncodepipeline.pipeline(self, \"pipeline\",\n    # give the pipeline an immutable view of the role\n    role=role.without_policy_updates()\n)\n\n# you now have to manage the role policies yourself\nrole.add_to_policy(iam.policystatement(\n    actions=[],\n    resources=[]\n))\n```\n\n### using existing roles\n\nif there are roles in your account that have already been created which you\nwould like to use in your cdk application, you can use `role.fromrolearn` to\nimport them, as follows:\n\n```python\nrole = iam.role.from_role_arn(self, \"role\", \"arn:aws:iam::123456789012:role/myexistingrole\",\n    # set 'mutable' to 'false' to use the role as-is and prevent adding new\n    # policies to it. the default is 'true', which means the role may be\n    # modified as part of the deployment.\n    mutable=false\n)\n```\n\n## configuring an externalid\n\nif you need to create roles that will be assumed by third parties, it is generally a good idea to [require an `externalid`\nto assume them](https://docs.aws.amazon.com/iam/latest/userguide/id_roles_create_for-user_externalid.html).  configuring\nan `externalid` works like this:\n\n```python\nrole = iam.role(self, \"myrole\",\n    assumed_by=iam.accountprincipal(\"123456789012\"),\n    external_ids=[\"supply-me\"]\n)\n```\n\n## principals vs identities\n\nwhen we say *principal*, we mean an entity you grant permissions to. this\nentity can be an aws service, a role, or something more abstract such as \"all\nusers in this account\" or even \"all users in this organization\". an\n*identity* is an iam representing a single iam entity that can have\na policy attached, one of `role`, `user`, or `group`.\n\n## iam principals\n\nwhen defining policy statements as part of an assumerole policy or as part of a\nresource policy, statements would usually refer to a specific iam principal\nunder `principal`.\n\niam principals are modeled as classes that derive from the `iam.policyprincipal`\nabstract class. principal objects include principal type (string) and value\n(array of string), optional set of conditions and the action that this principal\nrequires when it is used in an assume role policy document.\n\nto add a principal to a policy statement you can either use the abstract\n`statement.addprincipal`, one of the concrete `addxxxprincipal` methods:\n\n* `addawsprincipal`, `addarnprincipal` or `new arnprincipal(arn)` for `{ \"aws\": arn }`\n* `addawsaccountprincipal` or `new accountprincipal(accountid)` for `{ \"aws\": account-arn }`\n* `addserviceprincipal` or `new serviceprincipal(service)` for `{ \"service\": service }`\n* `addaccountrootprincipal` or `new accountrootprincipal()` for `{ \"aws\": { \"ref: \"aws::accountid\" } }`\n* `addcanonicaluserprincipal` or `new canonicaluserprincipal(id)` for `{ \"canonicaluser\": id }`\n* `addfederatedprincipal` or `new federatedprincipal(federated, conditions, assumeaction)` for\n  `{ \"federated\": arn }` and a set of optional conditions and the assume role action to use.\n* `addanyprincipal` or `new anyprincipal` for `{ \"aws\": \"*\" }`\n\nif multiple principals are added to the policy statement, they will be merged together:\n\n```python\nstatement = iam.policystatement()\nstatement.add_service_principal(\"cloudwatch.amazonaws.com\")\nstatement.add_service_principal(\"ec2.amazonaws.com\")\nstatement.add_arn_principal(\"arn:aws:boom:boom\")\n```\n\nwill result in:\n\n```json\n{\n  \"principal\": {\n    \"service\": [ \"cloudwatch.amazonaws.com\", \"ec2.amazonaws.com\" ],\n    \"aws\": \"arn:aws:boom:boom\"\n  }\n}\n```\n\nthe `compositeprincipal` class can also be used to define complex principals, for example:\n\n```python\nrole = iam.role(self, \"myrole\",\n    assumed_by=iam.compositeprincipal(\n        iam.serviceprincipal(\"ec2.amazonaws.com\"),\n        iam.accountprincipal(\"1818188181818187272\"))\n)\n```\n\nthe `principalwithconditions` class can be used to add conditions to a\nprincipal, especially those that don't take a `conditions` parameter in their\nconstructor. the `principal.withconditions()` method can be used to create a\n`principalwithconditions` from an existing principal, for example:\n\n```python\nprincipal = iam.accountprincipal(\"123456789000\").with_conditions({\"stringequals\": {\"foo\": \"baz\"}})\n```\n\n> note: if you need to define an iam condition that uses a token (such as a\n> deploy-time attribute of another resource) in a json map key, use `cfnjson` to\n> render this condition. see [this test](./test/integ.condition-with-ref.ts) for\n> an example.\n\nthe `webidentityprincipal` class can be used as a principal for web identities like\ncognito, amazon, google or facebook, for example:\n\n```python\nprincipal = iam.webidentityprincipal(\"cognito-identity.amazonaws.com\", {\n    \"stringequals\": {\"cognito-identity.amazonaws.com:aud\": \"us-east-2:12345678-abcd-abcd-abcd-123456\"},\n    \"foranyvalue:stringlike\": {\"cognito-identity.amazonaws.com:amr\": \"unauthenticated\"}\n})\n```\n\nif your identity provider is configured to assume a role with [session\ntags](https://docs.aws.amazon.com/iam/latest/userguide/id_session-tags.html), you\nneed to call `.withsessiontags()` to add the required permissions to the role's\npolicy document:\n\n```python\niam.role(self, \"role\",\n    assumed_by=iam.webidentityprincipal(\"cognito-identity.amazonaws.com\", {\n        \"stringequals\": {\n            \"cognito-identity.amazonaws.com:aud\": \"us-east-2:12345678-abcd-abcd-abcd-123456\"\n        },\n        \"foranyvalue:stringlike\": {\n            \"cognito-identity.amazonaws.com:amr\": \"unauthenticated\"\n        }\n    }).with_session_tags()\n)\n```\n\n## parsing json policy documents\n\nthe `policydocument.fromjson` and `policystatement.fromjson` static methods can be used to parse json objects. for example:\n\n```python\npolicy_document = {\n    \"version\": \"2012-10-17\",\n    \"statement\": [{\n        \"sid\": \"firststatement\",\n        \"effect\": \"allow\",\n        \"action\": [\"iam:changepassword\"],\n        \"resource\": \"*\"\n    }, {\n        \"sid\": \"secondstatement\",\n        \"effect\": \"allow\",\n        \"action\": \"s3:listallmybuckets\",\n        \"resource\": \"*\"\n    }, {\n        \"sid\": \"thirdstatement\",\n        \"effect\": \"allow\",\n        \"action\": [\"s3:list*\", \"s3:get*\"\n        ],\n        \"resource\": [\"arn:aws:s3:::confidential-data\", \"arn:aws:s3:::confidential-data/*\"\n        ],\n        \"condition\": {\"bool\": {\"aws:_multi_factor_auth_present\": \"true\"}}\n    }\n    ]\n}\n\ncustom_policy_document = iam.policydocument.from_json(policy_document)\n\n# you can pass this document as an initial document to a managedpolicy\n# or inline policy.\nnew_managed_policy = iam.managedpolicy(self, \"mynewmanagedpolicy\",\n    document=custom_policy_document\n)\nnew_policy = iam.policy(self, \"mynewpolicy\",\n    document=custom_policy_document\n)\n```\n\n## permissions boundaries\n\n[permissions\nboundaries](https://docs.aws.amazon.com/iam/latest/userguide/access_policies_boundaries.html)\ncan be used as a mechanism to prevent privilege esclation by creating new\n`role`s. permissions boundaries are a managed policy, attached to roles or\nusers, that represent the *maximum* set of permissions they can have. the\neffective set of permissions of a role (or user) will be the intersection of\nthe identity policy and the permissions boundary attached to the role (or\nuser). permissions boundaries are typically created by account\nadministrators, and their use on newly created `role`s will be enforced by\niam policies.\n\nit is possible to attach permissions boundaries to all roles created in a construct\ntree all at once:\n\n```python\n# directly apply the boundary to a role you create\n# role: iam.role\n\n# apply the boundary to an role that was implicitly created for you\n# fn: lambda.function\n\n# remove a permissions boundary that is inherited, for example from the stack level\n# custom_resource: customresource\n# this imports an existing policy.\nboundary = iam.managedpolicy.from_managed_policy_arn(self, \"boundary\", \"arn:aws:iam::123456789012:policy/boundary\")\n\n# this creates a new boundary\nboundary2 = iam.managedpolicy(self, \"boundary2\",\n    statements=[\n        iam.policystatement(\n            effect=iam.effect.deny,\n            actions=[\"iam:*\"],\n            resources=[\"*\"]\n        )\n    ]\n)\niam.permissionsboundary.of(role).apply(boundary)\niam.permissionsboundary.of(fn).apply(boundary)\n\n# apply the boundary to all roles in a stack\niam.permissionsboundary.of(self).apply(boundary)\niam.permissionsboundary.of(custom_resource).clear()\n```\n\n## openid connect providers\n\noidc identity providers are entities in iam that describe an external identity\nprovider (idp) service that supports the [openid connect](http://openid.net/connect) (oidc) standard, such\nas google or salesforce. you use an iam oidc identity provider when you want to\nestablish trust between an oidc-compatible idp and your aws account. this is\nuseful when creating a mobile app or web application that requires access to aws\nresources, but you don't want to create custom sign-in code or manage your own\nuser identities. for more information about this scenario, see [about web\nidentity federation] and the relevant documentation in the [amazon cognito\nidentity pools developer guide].\n\nthe following examples defines an openid connect provider. two client ids\n(audiences) are will be able to send authentication requests to\n[https://openid/connect](https://openid/connect).\n\n```python\nprovider = iam.openidconnectprovider(self, \"myprovider\",\n    url=\"https://openid/connect\",\n    client_ids=[\"myclient1\", \"myclient2\"]\n)\n```\n\nyou can specify an optional list of `thumbprints`. if not specified, the\nthumbprint of the root certificate authority (ca) will automatically be obtained\nfrom the host as described\n[here](https://docs.aws.amazon.com/iam/latest/userguide/id_roles_providers_create_oidc_verify-thumbprint.html).\n\nonce you define an openid connect provider, you can use it with aws services\nthat expect an iam oidc provider. for example, when you define an [amazon\ncognito identity\npool](https://docs.aws.amazon.com/cognito/latest/developerguide/open-id.html)\nyou can reference the provider's arn as follows:\n\n```python\nimport aws_cdk.aws_cognito as cognito\n\n# my_provider: iam.openidconnectprovider\n\ncognito.cfnidentitypool(self, \"identitypool\",\n    open_id_connect_provider_arns=[my_provider.open_id_connect_provider_arn],\n    # and the other properties for your identity pool\n    allow_unauthenticated_identities=false\n)\n```\n\nthe `openidconnectprincipal` class can be used as a principal used with a `openidconnectprovider`, for example:\n\n```python\nprovider = iam.openidconnectprovider(self, \"myprovider\",\n    url=\"https://openid/connect\",\n    client_ids=[\"myclient1\", \"myclient2\"]\n)\nprincipal = iam.openidconnectprincipal(provider)\n```\n\n## saml provider\n\nan iam saml 2.0 identity provider is an entity in iam that describes an external\nidentity provider (idp) service that supports the saml 2.0 (security assertion\nmarkup language 2.0) standard. you use an iam identity provider when you want\nto establish trust between a saml-compatible idp such as shibboleth or active\ndirectory federation services and aws, so that users in your organization can\naccess aws resources. iam saml identity providers are used as principals in an\niam trust policy.\n\n```python\niam.samlprovider(self, \"provider\",\n    metadata_document=iam.samlmetadatadocument.from_file(\"/path/to/saml-metadata-document.xml\")\n)\n```\n\nthe `samlprincipal` class can be used as a principal with a `samlprovider`:\n\n```python\nprovider = iam.samlprovider(self, \"provider\",\n    metadata_document=iam.samlmetadatadocument.from_file(\"/path/to/saml-metadata-document.xml\")\n)\nprincipal = iam.samlprincipal(provider, {\n    \"stringequals\": {\n        \"saml:iss\": \"issuer\"\n    }\n})\n```\n\nwhen creating a role for programmatic and aws management console access, use the `samlconsoleprincipal`\nclass:\n\n```python\nprovider = iam.samlprovider(self, \"provider\",\n    metadata_document=iam.samlmetadatadocument.from_file(\"/path/to/saml-metadata-document.xml\")\n)\niam.role(self, \"role\",\n    assumed_by=iam.samlconsoleprincipal(provider)\n)\n```\n\n## users\n\niam manages users for your aws account. to create a new user:\n\n```python\nuser = iam.user(self, \"myuser\")\n```\n\nto import an existing user by name [with path](https://docs.aws.amazon.com/iam/latest/userguide/reference_identifiers.html#identifiers-friendly-names):\n\n```python\nuser = iam.user.from_user_name(self, \"myimporteduserbyname\", \"johnsmith\")\n```\n\nto import an existing user by arn:\n\n```python\nuser = iam.user.from_user_arn(self, \"myimporteduserbyarn\", \"arn:aws:iam::123456789012:user/johnsmith\")\n```\n\nto import an existing user by attributes:\n\n```python\nuser = iam.user.from_user_attributes(self, \"myimporteduserbyattributes\",\n    user_arn=\"arn:aws:iam::123456789012:user/johnsmith\"\n)\n```\n\n### access keys\n\nthe ability for a user to make api calls via the cli or an sdk is enabled by the user having an\naccess key pair. to create an access key:\n\n```python\nuser = iam.user(self, \"myuser\")\naccess_key = iam.accesskey(self, \"myaccesskey\", user=user)\n```\n\nyou can force cloudformation to rotate the access key by providing a monotonically increasing `serial`\nproperty. simply provide a higher serial value than any number used previously:\n\n```python\nuser = iam.user(self, \"myuser\")\naccess_key = iam.accesskey(self, \"myaccesskey\", user=user, serial=1)\n```\n\nan access key may only be associated with a single user and cannot be \"moved\" between users. changing\nthe user associated with an access key replaces the access key (and its id and secret value).\n\n## groups\n\nan iam user group is a collection of iam users. user groups let you specify permissions for multiple users.\n\n```python\ngroup = iam.group(self, \"mygroup\")\n```\n\nto import an existing group by arn:\n\n```python\ngroup = iam.group.from_group_arn(self, \"myimportedgroupbyarn\", \"arn:aws:iam::account-id:group/group-name\")\n```\n\nto import an existing group by name [with path](https://docs.aws.amazon.com/iam/latest/userguide/reference_identifiers.html#identifiers-friendly-names):\n\n```python\ngroup = iam.group.from_group_name(self, \"myimportedgroupbyname\", \"group-name\")\n```\n\nto add a user to a group (both for a new and imported user/group):\n\n```python\nuser = iam.user(self, \"myuser\") # or user.fromusername(stack, 'user', 'johnsmith');\ngroup = iam.group(self, \"mygroup\") # or group.fromgrouparn(stack, 'group', 'arn:aws:iam::account-id:group/group-name');\n\nuser.add_to_group(group)\n# or\ngroup.add_user(user)\n```\n\n## features\n\n* policy name uniqueness is enforced. if two policies by the same name are attached to the same\n  principal, the attachment will fail.\n* policy names are not required - the cdk logical id will be used and ensured to be unique.\n* policies are validated during synthesis to ensure that they have actions, and that policies\n  attached to iam principals specify relevant resources, while policies attached to resources\n  specify which iam principals they apply to.\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-iam",
  "package_url": "https://pypi.org/project/aws-cdk.aws-iam/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-iam/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-iam/1.204.0/",
  "requires_dist": [
    "aws-cdk.core (==1.204.0)",
    "aws-cdk.cx-api (==1.204.0)",
    "aws-cdk.region-info (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "cdk routines for easily assigning correct and minimal iam permissions",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_cdk from_aws_managed_policy_name aws_cognito cdk aws",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_iam",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.core",
    "pypi_aws_cdk.cx_api",
    "pypi_aws_cdk.region_info",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}