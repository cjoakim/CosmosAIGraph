{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "intended audience :: science/research",
    "license :: osi approved :: bsd license",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4"
  ],
  "description": "simpledbf\n#########\n\n*simpledbf* is a python library for converting basic dbf files (see\n`limitations`_) to csv files, pandas dataframes, sql tables, or hdf5 tables.\nthis package is fully compatible with python >=3.4, with almost complete\n`python 2.7 support`_ as well. the conversion to csv and sql (see\n``to_textsql`` below) is entirely written in python, so no additional\ndependencies are necessary. for other export formats, see `optional\nrequirements`_.  this code was designed to be very simple, fast and memory\nefficient for convenient interactive or batch file processing; therefore, it\nlacks many features, such as the ability to write dbf files, that other\npackages might provide. \n\nbug fixes, questions, and update requests are encouraged and can be filed at\nthe `github repo`_. \n\nthis code is derived from an  `activestate dbf example`_ that works with\npython2 and is distributed under a psf license.\n\n\n.. _optional requirements:\n\noptional requirements\n---------------------\n\n* pandas >= 0.15.2 (required for dataframe)\n\n* pytables >= 3.1 (with pandas required for hdf tables)\n\n* sqlalchemy >= 0.9 (with pandas required for dataframe-sql tables)\n\ninstallation\n------------\n\nthe most recent release of *simpledbf* can be installed using ``pip`` or\n``conda``, if you happen to be using the `anaconda python distribution`_.\n\nusing ``conda``::\n\n    $ conda install -c https://conda.binstar.org/rnelsonchem simpledbf\n\nusing ``pip``::\n\n    $ pip install simpledbf\n\nthe development version can be installed from github::\n\n    $ pip install git+https://github.com/rnelsonchem/simpledbf.git\n\nas an alternative, this package only contains a single file, so in principle,\nyou could download the ``simpledbf.py`` file from github and put it in any\nfolder of your choosing.\n\n\n.. _limitations:\n\ndbf file limitations\n--------------------\n\nthis package currently supports a subset of `dbase iii through 5`_ dbf files.\nin particular, support is missing for linked memo (i.e. dbt) files. this is\nmostly due to limitations in the types of files available to the author.  feel\nfree to request an update if you can supply a dbf file with an associated memo\nfile. `dbf version 7`_, the most recent dbf file spec, is not currently\nsupported by this package.\n\n\n.. _python 2.7 support:\n\npython 2 support \n----------------\n\nexcept for hdf file export, this code should work fine with python >=2.7.\nhowever, hdf files created in python3 are compatible with all python2 hdf\npackages, so in principle, you could make any hdf files in a temporary python3\nenvironment. if you are using the `anaconda python distribution`_\n(recommended), then you can make a small python3 working environment as\nfollows:\n\n.. code::\n\n    $ conda create -n dbf python=3 pandas pytables sqlalchemy\n    # lots of output...\n    \n    $ source activate dbf\n\n    dbf>$ conda install -c https://conda.binstar.org/rnelsonchem simpledbf\n\n    dbf>$ python my_py3_hdf_creation_script.py\n    # this is using python3\n\n    dbf>$ source deactivate\n\n    $ python my_py2_stuff_with_hdf.py\n    # this is using python2 again\n\nhdf file export is currently broken in python2 due to a `limitation in pandas\nhdf export with unicode`_. this issue may be fixed future versions of\npandas/pytables.\n\n\nexample usage\n#############\n\n.. _loading:\n\nload a dbf file\n---------------\n\nthis module currently only defines a single class, ``dbf5``, which is\ninstantiated with a dbf file name, which can contain path info as well. an\noptional 'codec' keyword argument that controls the codec used for\nreading/writing files. the default is 'utf-8'. see the documentation for\npython's `codec standard library module`_ for more codec options.\n\n.. code::\n\n    in : from simpledbf import dbf5\n\n    in : dbf = dbf5('fake_file_name.dbf', codec='utf-8')\n\nthe ``dbf5`` object initially only reads the header information from the file,\nso you can inspect some of the properties. for example, ``numrec`` is the\nnumber of records in the dbf file, and ``fields`` is a list of tuples with\ninformation about the data columns. see the dbf file spec for info on the\ncolumn type characters. the \"deletionflag\" column is always present as a check\nfor deleted records; however, it is never exported during conversion.\n\n.. code::\n\n    in : dbf.numrec\n    out: 10000\n\n    in : dbf.fields\n    out: [('deletionflag', 'c', 1), ('col_1', 'c', 15), ('col_2', 'n', 2)]\n\nthe docstring for this object contains a complete listing of attributes and\ntheir descriptions.\n\nthe ``mem`` method gives an approximate memory requirement for processing this\ndbf file. (~2x the total file size, which could be wildly inaccurate.) in\naddition, all of the output methods in this object take a ``chunksize``\nkeyword argument, which lets you split up the processing of large files into\nsmaller chunks to limit the total memory usage of the conversion process. when\nthis keyword argument is passed into ``mem``, the approximate memory footprint\nof the chunk will also be given, which can be useful when trying to determine\nthe maximum chunksize your memory will allow.\n\n.. code::\n\n    in : dbf.mem()\n    this total process would require more than 350.2 mb of ram. \n\n    in : dbf.mem(chunksize=1000)\n    each chunk will require 4.793 mb of ram.\n    this total process would require more than 350.2 mb of ram.\n\n\nexport the data\n---------------\n\nthe ``ddb5`` object behaves like python's file object in that it will be\n\"exhausted\" after export. to re-export the dbf data to a different format,\nfirst create a new ``dbf5`` instance using the same file name. this procedure\nis followed in the documentation below.\n\n    \nnote on empty/bad data\n++++++++++++++++++++++\n\nthis package attempts to convert most blank strings and poorly formatted\nvalues to an empty value of your choosing. this is controlled by the ``na``\nkeyword argument to all export functions. the default for csv is an empty\nstring (''), and for all other exports, it is 'nan' which converts empty/bad\nvalues to ``float('nan')``. *note* the exception here is that float/int\ncolumns always use ``float('nan')`` for all missing values for\ndbf->sql->dataframe conversion purposes. pandas has very powerful functions\nfor `working with missing data`_, including converting nan to other values\n(e.g.  empty strings). \n\n        \nto csv\n++++++\n\nuse the ``to_csv`` method to export the data to a csv file. this method\nrequires the name of a csv file as an input. the default behavior is to append\nnew data to an existing file, so be careful if the file already exists. the\n``chunksize`` keyword argument controls the frequency that  the file buffer\nwill be flushed, which may not be necessary. the ``na`` keyword changes the\nvalue used for missing/bad entries (default is ''). the keyword ``header`` is\na boolean that controls writing of the column names as the first row of the\ncsv file. the encoding of the resulting csv file is determined by the codec\nthat is set when opening the dbf file, see `loading`_. \n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_csv('junk.csv')\n\nif you are unhappy with the default csv output of this module, pandas also has\nvery `powerful csv export capabilities`_ for dataframes.\n\n\nto sql (csv-based)\n++++++++++++++++++\n\nmost sql databases can create tables directly from local csv files. the\npure-python ``to_textsql`` method creates two files: 1) a header-less csv file\ncontaining the dbf contents, and 2) a sql file containing the appropriate\ntable creation and csv import code. it is up to you to run the sql file as a\nseparate step. this function takes two mandatory arguments, which are simply\nthe names of the sql and csv files, respectively. in addition, there are a\nnumber of optional keyword arguments as well. ``sqltype`` controls the output\ndialect. the default is 'sqlite', but 'postgres' is also accepted.  ``table``\nsets the name of the sql table that will be created. by default, this will be\nthe name of the dbf file without the file extension. you should escape quote\ncharacters (\") in the csv file. this is controlled with the ``escapeqoute``\nkeyword, which defaults to ``'\"'``. (this changes '\"' in text strings to '\"\"',\nwhich the sql server should ignore.) the ``chunksize``, ``na``, and ``header``\nkeywords are used to control the csv file. see above.\n\nhere's an example for sqlite:\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_textsql('junk.sql', 'junk.csv')\n\n    # exit python\n    $ sqlite3 junk.db < junk.sql\n\nhere's an example for postgresql:\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_textsql('junk.sql', 'junk.csv', sqltype='postgres')\n\n    # exit python\n    $ psql -u username -f junk.sql db_name\n\nto dataframe \n++++++++++++\n\nthe ``to_dataframe`` method returns the dbf records as a pandas dataframe.  if\nthe size of the dbf file exceeds available memory, then passing the\n``chunksize`` keyword argument will return a generator function. this\ngenerator yields dataframes of len(<=chunksize) until all of the records have\nbeen processed. the ``na`` keyword changes the value used for missing/bad\nentries (default is 'nan' which inserts ``float('nan')``).\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : df = dbf.to_dataframe()\n    # df is a dataframe with all records\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : for df in dbf.to_dataframe(chunksize=10000)\n    ....     do_cool_stuff(df)\n    # here a generator is returned\n\n.. _chunksize issue:\n\nissue with dataframe chunksize\n++++++++++++++++++++++++++++++\n\nwhen a dataframe is constructed, it attempts to determine the dtype of each\ncolumn. if you chunk the dataframe output, it turns out that the dtype for a\ncolumn can change. for example, if one chunk has a column with all strings,\nthe dtype will be ``np.object``; however, if in the next chunk that same\ncolumn is full of ``float('nan')``, the resulting dtype will be set as\n``float``. this has some consequences for writing to sql and hdf tables as\nwell. in principle, this behavior could be changed, but it is currently\nnon-trivial to set the dtypes for dataframe columns on construction. please\nfile a pr through github if this is a big problem.\n\n\nto an sql table using pandas\n++++++++++++++++++++++++++++\n\nthe ``to_pandassql`` method will transfer the dbf entries to an sql database\ntable of your choice using a combination of pandas dataframes and sqlalchemy.\na valid `sqlalchemy engine string`_ argument is required to connect with the\ndatabase. database support will be limited to those supported by sqlalchemy.\n(this has been tested with sqlite and postgresql.) note, if you are\ntransferring a large amount of data, this method will be very slow. if you\nhave direct access to the sql server, you might want to use the text-based sql\nexport instead.\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_pandassql('sqlite:///foo.db')\n\nthis method accepts three optional arguments. ``table`` is the name of the\ntable you'd like to use. if this is not passed, your new table will have the\nsame name as the dbf file without file extension. again, the default here is\nto append to an existing table. if you want to start fresh, delete the\nexisting table before using this function. the ``chunksize`` keyword processes\nthe dbf file in chunks of records no larger than this size. the ``na`` keyword\nchanges the value used for missing/bad entries (default is 'nan' which inserts\n``float('nan')``).\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_pandassql('sqlite:///foo.db', table=\"fake_tbl\",\n    ....                    chunksize=100000)\n    \n\nto an hdf5 table\n++++++++++++++++\n\nthe ``to_pandashdf`` method transfers the dbf entries to an hdf5 table of your\nchoice. this method uses a combination of pandas dataframes and pytables, so\nboth of these packages must be installed. this method requires a file name\nstring for the hdf file, which will be created if it does not exist.  again,\nthe default behavior is to append to an existing file of that name, so be\ncareful here.  the hdf file will be created using the highest level of\ncompression (9) with the 'blosc' compression lib. this saves an enormous\namount of disk space, with little degradation of performance; however, this\ncompression library is non-standard, which can cause problems with other hdf\nlibraries. compression options are controlled use the ``complib`` and\n``complevel`` keyword arguments, which are identical to the ones described in\nthe `pandas hdf compression docs`_.\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_pandashdf('fake.h5')\n\nthis method uses the same optional arguments, and corresponding defaults, as\n``to_pandassql`` (see above). a example with ``chunksize`` is shown below. in\naddition, a ``data_columns`` keyword argument is also available, which sets\nthe columns that will be used as data columns in the hdf table. data columns\ncan be used for advanced searching and selection; however, there is some\ndegredation of preformance for large numbers of data columns. see the `pandas\ndata columns docs`_ for a more detailed explanation.\n\n.. code::\n\n    in : dbf = dbf5('fake_file_name.dbf')\n\n    in : dbf.to_pandashdf('fake.h5', table=\"fake_tbl\", chunksize=100000)\n\nsee the `chunksize issue`_ for dataframe export for information on a potential\nproblem you may encounter with chunksize.\n\n\nbatch export\n++++++++++++\n\nbatch file export is trivial using *simpledbf*. for example, the following\ncode processes all dbf files in the current directory into separate tables in\na single hdf file.\n\n.. code:: \n\n    in : import os\n\n    in : from simpledbf import dbf5\n\n    in : files = os.listdir('.')\n\n    in : for f in files:\n    ....     if f[-3:].lower() == 'dbf':\n    ....         dbf = dbf5(f)\n    ....         dbf.to_pandashdf('all_data.h5')\n\n   \n.. external hyperlinks\n\n.. _activestate dbf example: http://code.activestate.com/recipes/\n        362715-dbf-reader-and-writer/\n.. _github repo: https://github.com/rnelsonchem/simpledbf\n.. _dbase iii through 5: http://ulisse.elettra.trieste.it/services/doc/\n        dbase/dbfstruct.htm\n.. _dbf version 7: http://www.dbase.com/knowledgebase/int/db7_file_fmt.htm\n.. _anaconda python distribution: http://continuum.io/downloads\n.. _limitation in pandas hdf export with unicode: http://pandas.pydata.org/\n        pandas-docs/stable/io.html#datatypes\n.. _codec standard library module: https://docs.python.org/3.4/library/\n        codecs.html \n.. _working with missing data: http://pandas.pydata.org/pandas-docs/stable/\n        missing_data.html\n.. _powerful csv export capabilities: http://pandas.pydata.org/pandas-docs/\n        stable/io.html#writing-to-csv-format\n.. _sqlalchemy engine string: http://docs.sqlalchemy.org/en/rel_0_9/core/\n        engines.html\n.. _pandas hdf compression docs: http://pandas.pydata.org/pandas-docs/stable/\n        io.html#compression\n.. _pandas data columns docs: http://pandas.pydata.org/pandas-docs/stable/\n        io.html#query-via-data-columns",
  "docs_url": null,
  "keywords": "dbf csv pandas sqlalchemy pytables dataframe sql hdf",
  "license": "bsd",
  "name": "simpledbf",
  "package_url": "https://pypi.org/project/simpledbf/",
  "project_url": "https://pypi.org/project/simpledbf/",
  "project_urls": {
    "Homepage": "https://github.com/rnelsonchem/simpledbf"
  },
  "release_url": "https://pypi.org/project/simpledbf/0.2.6/",
  "requires_dist": [],
  "requires_python": null,
  "summary": "convert dbf files to csv, dataframes, hdf5 tables, and sql tables. python3 compatible.",
  "version": "0.2.6",
  "releases": [],
  "developers": [
    "rnelsonchem@gmail.com",
    "ryan_nelson"
  ],
  "kwds": "to_pandassql simpledbf sqlalchemy _sqlalchemy _dbf",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_simpledbf",
  "homepage": "https://github.com/rnelsonchem/simpledbf",
  "release_count": 8,
  "dependency_ids": []
}