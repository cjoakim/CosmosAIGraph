{
  "classifiers": [
    "license :: osi approved :: apache software license"
  ],
  "description": "# policyuniverse\n\n[![version](http://img.shields.io/pypi/v/policyuniverse.svg?style=flat)](https://pypi.python.org/pypi/policyuniverse/)\n\n[![build status](https://github.com/netflix-skunkworks/policyuniverse/workflows/python%20package/badge.svg)](https://github.com/netflix-skunkworks/policyuniverse/actions)\n\n[![updater status](https://github.com/netflix-skunkworks/policyuniverse/actions/workflows/updater.yml/badge.svg)](https://github.com/netflix-skunkworks/policyuniverse/actions/workflows/updater.yml)\n\n[![coverage status](https://coveralls.io/repos/github/netflix-skunkworks/policyuniverse/badge.svg?branch=master&1)](https://coveralls.io/github/netflix-skunkworks/policyuniverse?branch=master)\n\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/python/black)\n\nthis package provides classes to parse aws iam and resource policies.\n\nadditionally, this package can expand wildcards in aws policies using permissions obtained from the aws policy generator.\n\nsee the [service and permissions data](policyuniverse/data.json).\n\n_this package can also minify an aws policy to help you stay under policy size limits. avoid doing this if possible, as it creates ugly policies._ \ud83d\udca9\n\n# install:\n\n`pip install policyuniverse`\n\n# usage:\n\n- [arn class](#reading-arns)\n- [policy class](#iam-and-resource-policies)\n- [statement class](#statements)\n- [action categories](#action-categories)\n- [expanding and minification](#expanding-and-minification)\n\n## reading arns\n\n```python\nfrom policyuniverse.arn import arn\narn = arn('arn:aws:iam::012345678910:role/sometestrolefortesting')\nassert arn.error == false\nassert arn.tech == 'iam'\nassert arn.region == ''  # iam is universal/global\nassert arn.account_number == '012345678910'\nassert arn.name == 'role/sometestrolefortesting'\nassert arn.partition == 'aws'\nassert arn.root == false  # not the root arn\nassert arn.service == false  # not an aws service like lambda.amazonaws.com\n\narn = arn('012345678910')\nassert arn.account_number == '012345678910'\n\narn = arn('lambda.amazonaws.com')\nassert arn.service == true\nassert arn.tech == 'lambda'\n```\n\n## iam and resource policies\n\n### policy with multiple statements\n```python\n# two statements, both with conditions\npolicy05 = dict(\n    version='2010-08-14',\n    statement=[\n        dict(\n            effect='allow',\n            principal='arn:aws:iam::012345678910:root',\n            action=['s3:*'],\n            resource='*',\n            condition={\n                'ipaddress': {\n                    'aws:sourceip': ['0.0.0.0/0']\n                }}),\n        dict(\n            effect='allow',\n            principal='arn:aws:iam::*:role/hello',\n            action=['ec2:*'],\n            resource='*',\n            condition={\n                'stringlike': {\n                    'aws:sourceowner': '012345678910'\n                }})\n        ])\n\nfrom policyuniverse.policy import policy\nfrom policyuniverse.statement import conditiontuple, principaltuple\n\npolicy = policy(policy05)\nassert policy.whos_allowed() == set([\n    principaltuple(category='principal', value='arn:aws:iam::*:role/hello'),\n    principaltuple(category='principal', value='arn:aws:iam::012345678910:root'),\n    conditiontuple(category='cidr', value='0.0.0.0/0'),\n    conditiontuple(category='account', value='012345678910')\n])\n\n# the given policy is not internet accessible.\n# the first statement is limited by the principal, and the condition is basically a no-op.\n# the second statement has a wildcard principal, but uses the condition to lock it down.\nassert policy.is_internet_accessible() == false\n```\n\n### internet accessible policy:\n\n```python\n# an internet accessible policy:\npolicy01 = dict(\n    version='2012-10-08',\n    statement=dict(\n        effect='allow',\n        principal='*',\n        action=['rds:*'],\n        resource='*',\n        condition={\n            'ipaddress': {\n                'aws:sourceip': ['0.0.0.0/0']\n            }\n        }))\n\npolicy = policy(policy01)\nassert policy.is_internet_accessible() == true\nassert policy.internet_accessible_actions() == set(['rds:*'])\n```\n\n## statements\n\na policy is simply a collection of statements.\n\n```python\nstatement12 = dict(\n    effect='allow',\n    principal='*',\n    action=['rds:*'],\n    resource='*',\n    condition={\n        'stringequals': {\n            'aws:sourcevpc': 'vpc-111111',\n            'aws:sourcevpce': 'vpce-111111',\n            'aws:sourceowner': '012345678910',\n            'aws:sourceaccount': '012345678910'\n        },\n        'stringlike': {\n            'aws:userid': 'aroai1111111111111111:*'\n        },\n        'arnlike': {\n            'aws:sourcearn': 'arn:aws:iam::012345678910:role/admin'\n        },\n        'ipaddressifexists': {\n            'aws:sourceip': [\n                '123.45.67.89',\n                '10.0.7.0/24',\n                '172.16.0.0/16']\n        }\n    })\n\nfrom policyuniverse.statement import statement\nfrom policyuniverse.statement import conditiontuple, principaltuple\n\nstatement = statement(statement12)\nassert statement.effect == 'allow'\nassert statement.actions == set(['rds:*'])\n\n# rds:* expands out to ~88 individual permissions\nassert len(statement.actions_expanded) == 88\n\nassert statement.uses_not_principal() == false\nassert statement.principals == set(['*'])\nassert statement.condition_arns == set(['arn:aws:iam::012345678910:role/admin'])\nassert statement.condition_accounts == set(['012345678910'])\nassert statement.condition_userids == set(['aroai1111111111111111:*'])\nassert statement.condition_cidrs == set(['10.0.7.0/24', '172.16.0.0/16', '123.45.67.89'])\nassert statement.condition_vpcs == set(['vpc-111111'])\nassert statement.condition_vpces == set(['vpce-111111'])\nassert statement.is_internet_accessible() == false\nassert statement.whos_allowed() == set([\n    principaltuple(category='principal', value='*'),\n    conditiontuple(category='cidr', value='123.45.67.89'),\n    conditiontuple(category='account', value='012345678910'),\n    conditiontuple(category='userid', value='aroai1111111111111111:*'),\n    conditiontuple(category='vpc', value='vpc-111111'),\n    conditiontuple(category='arn', value='arn:aws:iam::012345678910:role/admin'),\n    conditiontuple(category='cidr', value='172.16.0.0/16'),\n    conditiontuple(category='vpce', value='vpce-111111'),\n    conditiontuple(category='cidr', value='10.0.7.0/24')])\n\n```\n\n\n## action categories\n```python\npolicy = {\n        \"statement\": [{\n            \"action\": [\"s3:put*\", \"sqs:get*\", \"sns:*\"],\n            \"resource\": \"*\",\n            \"effect\": \"allow\"\n          }]\n      }\n\nfrom policyuniverse.policy import policy\np = policy(policy)\nfor k, v in p.action_summary().items():\n    print(k,v)\n>>> ('s3', set([u'write', u'permissions', u'tagging']))\n>>> ('sqs', set([u'list']))\n>>> ('sns', set([u'list', u'read', u'write', u'permissions']))\n```\npossible categories are `permissions`, `write`, `read`, `tagging`, and `list`.  this data can be used to summarize statements and policies and to look for sensitive permissions.\n\n## expanding and minification\n```python\nfrom policyuniverse.expander_minimizer import expand_policy\nfrom policyuniverse.expander_minimizer import minimize_policy\n\npolicy = {\n        \"statement\": [{\n            \"action\": [\"swf:res*\"],\n            \"resource\": \"*\",\n            \"effect\": \"allow\"\n          }]\n      }\n\nexpanded_policy = expand_policy(policy=policy)\n>>> start size: 131. end size: 286\nprint(expanded_policy == {\n        \"statement\": [{\n            \"action\": [\n              \"swf:respondactivitytaskcanceled\",\n              \"swf:respondactivitytaskcompleted\",\n              \"swf:respondactivitytaskfailed\",\n              \"swf:responddecisiontaskcompleted\"\n            ],\n            \"resource\": \"*\",\n            \"effect\": \"allow\"\n          }]\n      })\n>>> true\n\nminimized_policy = minimize_policy(policy=expanded_policy, minchars=3)\n>>> skipping prefix r because length of 1\n>>> skipping prefix re because length of 2\n>>> skipping prefix r because length of 1\n>>> skipping prefix re because length of 2\n>>> skipping prefix r because length of 1\n>>> skipping prefix re because length of 2\n>>> skipping prefix r because length of 1\n>>> skipping prefix re because length of 2\n>>> start size: 286. end size: 131\n\nprint(minimized_policy == policy)\n>>> true\n```\n\n",
  "docs_url": null,
  "keywords": "iam,arn,action_groups,condition,policy,statement,wildcard",
  "license": "",
  "name": "policyuniverse",
  "package_url": "https://pypi.org/project/policyuniverse/",
  "project_url": "https://pypi.org/project/policyuniverse/",
  "project_urls": {
    "Homepage": "https://github.com/Netflix-Skunkworks/policyuniverse"
  },
  "release_url": "https://pypi.org/project/policyuniverse/1.5.1.20231109/",
  "requires_dist": [
    "pre-commit ; extra == 'dev'",
    "black ; extra == 'dev'",
    "pytest ; extra == 'tests'",
    "coveralls ; extra == 'tests'",
    "bandit ; extra == 'tests'"
  ],
  "requires_python": ">=3.7",
  "summary": "parse and process aws iam policies, statements, arns, and wildcards.",
  "version": "1.5.1.20231109",
  "releases": [],
  "developers": [
    "patrick_kelley",
    "patrickbarrettkelley@gmail.com"
  ],
  "kwds": "expanded_policy policy01 policies status policy05",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_policyuniverse",
  "homepage": "https://github.com/netflix-skunkworks/policyuniverse",
  "release_count": 107,
  "dependency_ids": [
    "pypi_bandit",
    "pypi_black",
    "pypi_coveralls",
    "pypi_pre_commit",
    "pypi_pytest"
  ]
}