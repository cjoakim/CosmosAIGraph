{
  "classifiers": [
    "license :: osi approved :: apache software license",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.6"
  ],
  "description": "![higher logo](https://github.com/facebookresearch/higher/raw/master/resources/higher_logo.png)\n--------------------------------------------------------------------------------\n\n`higher` is a library providing support for higher-order optimization, e.g. through unrolled first-order optimization loops, of \"meta\" aspects of these loops. it provides tools for turning existing `torch.nn.module` instances \"stateless\", meaning that changes to the parameters thereof can be tracked, and gradient with regard to intermediate parameters can be taken. it also provides a suite of differentiable optimizers, to facilitate the implementation of various meta-learning approaches.\n\nfull documentation is available at https://higher.readthedocs.io/en/latest/.\n\n# requirements and installation\n\n* python version >= 3.5\n* pytorch version >= 1.3\n\nto install `higher` from [pypi](https://pypi.org/project/higher/):\n```bash\npip install higher\n```\n\nto install `higher` from source:\n```bash\ngit clone git@github.com:facebookresearch/higher.git\ncd higher\npip install .\n```\n\nalternatively `python setup.py install` will do the same thing.\n\n# citation\n\nif you use `higher` in your research and found it helpful, please consider citing the following paper:\n\n```bib\n@article{grefenstette2019generalized,\n  title={generalized inner loop meta-learning},\n  author={grefenstette, edward and amos, brandon and yarats, denis and htut, phu mon and molchanov, artem and meier, franziska and kiela, douwe and cho, kyunghyun and chintala, soumith},\n  journal={arxiv preprint arxiv:1910.01727},\n  year={2019}\n}\n```\n\n# use case\n\n## your needs\nyou have a `model` with parameters `p`, where `p[t]` denotes the parameters at update timestep `t`.\nyou want to update the model through `k` steps of optimization, and compute gradients through the optimization process,\ni.e. compute `torch.autograd.grad(p[k], p[0])` or obtain gradients that depend on this gradient pathway existing.\n\n## your obstacles\n\nyou are using some existing code for your `model`, so the parameters are stateful, preventing you from forming a graph with `p[t]` as nodes.\neven if you roll your own solution, you want to use optimization techniques beyond normal sgd, and `torch.optim` optimizers don't let you optimize \"through\" them.\n\n## your solution\ngood news: `higher` has got you covered! using our growing set of tools and utility functions, you can backpropagate through an unbounded number of model update steps for all your meta-learning needs.\nthis library includes:\n\n* helper functions for monkey-patching `torch.nn` modules to make them functional (non-stateful), i.e. feed their parameters as an extra argument during the forward pass.\n* classes implementing differentiable versions of `torch.optim.adam` (and sgd), designed to track or branch out from the state of a \"normal\" `adam` instance.\n\n# example usage\n\nsay your training code looks like this:\n\n```python\nmodel = mymodel()\nopt = torch.optim.adam(model.parameters())\n\nfor xs, ys in data:\n    opt.zero_grad()\n    logits = model(xs)\n    loss = loss_function(logits, ys)\n    loss.backward()\n    opt.step()\n```\n\nto turn this into a differentiable version, the following changes should be introduced:\n\n```python\nmodel = mymodel()\nopt = torch.optim.adam(model.parameters())\n\n# when you want to branch from the current state of your model and unroll\n# optimization, follow this example. this context manager gets a snapshot of the\n# current version of the model and optimizer at the point where you want to\n# start unrolling and create a functional version `fmodel` which executes the\n# forward pass of `model` with implicit fast weights which can be read by doing\n# `fmodel.parameters()`, and a differentiable optimizer `diffopt` which ensures\n# that at each step, gradient of `fmodel.parameters()` with regard to initial\n# fast weights `fmodel.parameters(time=0)` (or any other part of the unrolled\n# model history) is defined.\n\nwith higher.innerloop_ctx(model, opt) as (fmodel, diffopt):\n    for xs, ys in data:\n        logits = fmodel(xs)  # modified `params` can also be passed as a kwarg\n        loss = loss_function(logits, ys)  # no need to call loss.backwards()\n        diffopt.step(loss)  # note that `step` must take `loss` as an argument!\n        # the line above gets p[t+1] from p[t] and loss[t]. `step` also returns\n        # these new parameters, as an alternative to getting them from\n        # `fmodel.fast_params` or `fmodel.parameters()` after calling\n        # `diffopt.step`.\n\n        # at this point, or at any point in the iteration, you can take the\n        # gradient of `fmodel.parameters()` (or equivalently\n        # `fmodel.fast_params`) w.r.t. `fmodel.parameters(time=0)` (equivalently\n        # `fmodel.init_fast_params`). i.e. `fast_params` will always have\n        # `grad_fn` as an attribute, and be part of the gradient tape.\n\n    # at the end of your inner loop you can obtain these e.g. ...\n    grad_of_grads = torch.autograd.grad(\n        meta_loss_fn(fmodel.parameters()), fmodel.parameters(time=0))\n```\n\n**beware** that when unrolling your optimisation like this for `k`, all gradients and all activations of your model at each step is kept in memory,\nmeaning the memory footprint of your model is `k` times greater.\n\n# adding your own optimizers\n\nit is possible to use optimizers other that those found in `torch.optim`. a differentiable version must be implemented first. this can be done by subclassing `higher.optim.differentiableoptimizer` and overriding the `_update` method, following the arguments of the original. assuming the logic of the optimizer being added follows the logic of those found in `torch.optim`, the steps to follow are more or less:\n\n1. remove the following code (no support for closures).\n    ```\n    loss = none\n    if closure is not none:\n        loss = closure()\n    ```\n2. replace\n    ```\n    for group in self.param_groups:\n        for p in group['params']:\n            if p.grad is none:\n                continue\n            grad = p.grad.data\n    ```\n    with\n    ```\n    zipped = zip(self.param_groups, grouped_grads)\n    for group_idx, (group, grads) in enumerate(zipped):\n        for p_idx, (p, g) in enumerate(zip(group['params'], grads)):\n          if g is none:\n              continue\n    ```\n3. replace `state = self.state[p]` with `state = self.state[group_idx][p_idx]`.\n4. replace any in-place op with a non in-place op, e.g. `t.add_(a, x).mul_(y)` should become `t = t.add(a, x).mul(y)` (note the assignment). be careful to also track where dictionaries are being implicitly updated by such ops, e.g. if there is code of the form:\n    ```\n    p = state['k']\n    ...\n    p.add_(a, x)\n    ```\n    in the original optimizer, this code should be converted to\n    ```\n    p = state['k']\n    ...\n    state['k'] = p = p.add(a, x)\n    ```\n    to ensure the corresponding dictionary is.\n5. except where used for shape inference, replace instances of `t.data` with `t` for all `t`.\n6. be sure to update `group['params'][p_idx]` for each `p_idx` in need of update (those ignored will yield the original parameters in the fast weight collection). the latest fast weights will be returned by the inherited `step` function.\n7. **importantly**, you need to register your new differentiable optimizer with `higher` using `higher.register_optim` to ensure that it is recognized as an option by the library's methods. you can do this at any point after the definition of an optimizer, and before any `higher` code involving that optimizer is called. for example, if you have implemented `mydiffopt` as a differentiable version of some optimizer `myopt`, register it by adding the line `higher.register_optim(myopt, mydiffopt)` after the classes are defined.\n\nyou can find examples of how to test for gradient correctness using finite difference methods in `tests/test_optim.py`. please note that some stability tricks may be needed to avoid `nan`s in the gradients. see the `higher.optim.differentiableadam` implementation for examples of mitigation strategies, e.g. identify operations that yield exploding gradients, e.g. typically those taking the square roots of moving averages (which are intially zero), and register a backward hook using `x.register_hook` on the inputs `x` to those functions, using the helper function `_get_mask_closure` from `higher.optim`.\n\n# release notes\nsee the [changelog](https://github.com/facebookresearch/higher/blob/master/changelog.md) for release notes.\n\n# known/possible issues\n* see the [issues tracker](https://github.com/facebookresearch/higher/issues) for an up-to-date list.\n* no support (or planned support) for `torch.nn.dataparallel` at this time. this would require a rewrite of `dataparallel`. please raise an issue on the pytorch issue tracker if this matters to you.\n* some of the adaptative gradient-style differentiable optimizers may be unstable and yield nans when taking higher order gradients. some tricks have been used to mitigate this risk. please raise an issue if these are not sufficient in practice.\n* second-order gradients may not work with some cudnn modules (mostly rnns). from pytorch v1.3 onwards, wrapping the code where models are used with `higher` using the following context manager should solve the issue:\n```python\nwith torch.backends.cudnn.flags(enabled=false):\n    # your meta-learning code here...\n```\n\n# license\n`higher` is released under apache license version 2.0.\n\n# thanks\nthanks to [adam paszke](https://gist.github.com/apaszke)\nwhose [gist](https://gist.github.com/apaszke/4c8ead6f17a781d589f6655692e7f6f0)\nwas the source of inspiration (and starting point) for our method for monkey\npatching arbitrary `torch.nn` modules.\n\nthanks for the many interns, researchers, and engineers who helped road-test early versions of this library.\n\n\n",
  "docs_url": null,
  "keywords": "second-order,gradient descent,optimization,meta-learning",
  "license": "apache",
  "name": "higher",
  "package_url": "https://pypi.org/project/higher/",
  "project_url": "https://pypi.org/project/higher/",
  "project_urls": {
    "Homepage": "https://github.com/facebookresearch/higher"
  },
  "release_url": "https://pypi.org/project/higher/0.2.1/",
  "requires_dist": [
    "torch"
  ],
  "requires_python": ">=3.6.0",
  "summary": "a pytorch library allowing users to obtain higher order gradients over losses spanning training loops rather than individual training steps.",
  "version": "0.2.1",
  "releases": [],
  "developers": [
    "edward_grefenstette",
    "egrefen@fb.com"
  ],
  "kwds": "optimizers optimizer optimization optimize optimisation",
  "license_kwds": "apache",
  "libtype": "pypi",
  "id": "pypi_higher",
  "homepage": "https://github.com/facebookresearch/higher",
  "release_count": 2,
  "dependency_ids": [
    "pypi_torch"
  ]
}