{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: web environment",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 2",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "topic :: internet :: www/http :: dynamic content",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "# tableschema-py\n\n[![travis](https://travis-ci.org/frictionlessdata/tableschema-py.svg?branch=master)](https://travis-ci.org/frictionlessdata/tableschema-py)\n[![coveralls](http://img.shields.io/coveralls/frictionlessdata/tableschema-py.svg?branch=master)](https://coveralls.io/r/frictionlessdata/tableschema-py?branch=master)\n[![pypi](https://img.shields.io/pypi/v/tableschema.svg)](https://pypi.python.org/pypi/tableschema)\n[![github](https://img.shields.io/badge/github-master-brightgreen)](https://github.com/frictionlessdata/tableschema-py)\n[![gitter](https://img.shields.io/gitter/room/frictionlessdata/chat.svg)](https://gitter.im/frictionlessdata/chat)\n\na python implementation of the [table schema](http://specs.frictionlessdata.io/table-schema/) standard.\n\n> **[important notice]** we have released [frictionless framework](https://github.com/frictionlessdata/frictionless-py). this framework provides improved `tableschema` functionality extended to be a complete data solution. the change in not breaking for the existing software so no actions are required. please read the [migration guide](https://framework.frictionlessdata.io/docs/development/migration) from `tableschema` to frictionless framework.\n> - we continue to bug-fix `tableschema@1.x` in this [repository](https://github.com/frictionlessdata/tableschema-py) as well as it's available on [pypi](https://pypi.org/project/tableschema/) as it was before\n> - please note that `frictionless@3.x` version's api, we're working on at the moment, is not stable\n> - we will release `frictionless@4.x` by the end of 2020 to be the first semver/stable version\n\n## features\n\n- `table` to work with data tables described by table schema\n- `schema` representing table schema\n- `field` representing table schema field\n- `validate` to validate table schema\n- `infer` to infer table schema from data\n- built-in command-line interface to validate and infer schemas\n- storage/plugins system to connect tables to different storage backends like sql database\n\n## contents\n\n<!--toc-->\n\n  - [getting started](#getting-started)\n    - [installation](#installation)\n  - [documentation](#documentation)\n    - [introduction](#introduction)\n    - [working with table](#working-with-table)\n    - [working with schema](#working-with-schema)\n    - [working with field](#working-with-field)\n  - [api reference](#api-reference)\n    - [`cli`](#cli)\n    - [`table`](#table)\n    - [`schema`](#schema)\n    - [`field`](#field)\n    - [`storage`](#storage)\n    - [`validate`](#validate)\n    - [`infer`](#infer)\n    - [`failedcast`](#failedcast)\n    - [`datapackageexception`](#datapackageexception)\n    - [`tableschemaexception`](#tableschemaexception)\n    - [`loaderror`](#loaderror)\n    - [`validationerror`](#validationerror)\n    - [`casterror`](#casterror)\n    - [`integrityerror`](#integrityerror)\n    - [`uniquekeyerror`](#uniquekeyerror)\n    - [`relationerror`](#relationerror)\n    - [`unresolvedfkerror`](#unresolvedfkerror)\n    - [`storageerror`](#storageerror)\n  - [experimental](#experimental)\n  - [contributing](#contributing)\n  - [changelog](#changelog)\n\n<!--toc-->\n\n## getting started\n\n### installation\n\nthe package uses semantic versioning. it means that major versions  could include breaking changes. it's highly recommended to specify `tableschema` version range in your `setup/requirements` file e.g. `tableschema>=1.0,<2.0`.\n\n```bash\n$ pip install tableschema\n```\n\n## documentation\n\n### introduction\n\nlet's start with a simple example:\n\n```python\nfrom tableschema import table\n\n# create table\ntable = table('path.csv', schema='schema.json')\n\n# print schema descriptor\nprint(table.schema.descriptor)\n\n# print cast rows in a dict form\nfor keyed_row in table.iter(keyed=true):\n    print(keyed_row)\n```\n\n### working with table\n\na table is a core concept in a tabular data world. it represents data with metadata (table schema). let's see how we can use it in practice.\n\nconsider we have some local csv file. it could be inline data or from a remote link - all supported by the `table` class (except local files for in-brower usage of course). but say it's `data.csv` for now:\n\n```csv\ncity,location\nlondon,\"51.50,-0.11\"\nparis,\"48.85,2.30\"\nrome,n/a\n```\n\nlet's create and read a table instance. we use the static `table.load` method and the `table.read` method with the `keyed` option to get an array of keyed rows:\n\n```python\ntable = table('data.csv')\ntable.headers # ['city', 'location']\ntable.read(keyed=true)\n# [\n#   {city: 'london', location: '51.50,-0.11'},\n#   {city: 'paris', location: '48.85,2.30'},\n#   {city: 'rome', location: 'n/a'},\n# ]\n```\n\nas we can see, our locations are just strings. but they should be geopoints. also, rome's location is not available, but it's just a string `n/a` instead of `none`. first we have to infer table schema:\n\n```python\ntable.infer()\ntable.schema.descriptor\n# { fields:\n#   [ { name: 'city', type: 'string', format: 'default' },\n#     { name: 'location', type: 'geopoint', format: 'default' } ],\n#  missingvalues: [ '' ] }\ntable.read(keyed=true)\n# fails with a data validation error\n```\n\nlet's fix the \"not available\" location. there is a `missingvalues` property in table schema specification. as a first try we set `missingvalues` to `n/a` in `table.schema.descriptor`. the schema descriptor can be changed in-place, but all changes should also be committed using `table.schema.commit()`:\n\n```python\ntable.schema.descriptor['missingvalues'] = 'n/a'\ntable.schema.commit()\ntable.schema.valid # false\ntable.schema.errors\n# [<validationerror: \"'n/a' is not of type 'array'\">]\n```\n\nas a good citizens we've decided to check our schema descriptor's validity. and it's not valid! we should use an array for the `missingvalues` property. also, don't forget to include \"empty string\" as a valid missing value:\n\n```python\ntable.schema.descriptor['missingvalues'] = ['', 'n/a']\ntable.schema.commit()\ntable.schema.valid # true\n```\n\nall good. it looks like we're ready to read our data again:\n\n```python\ntable.read(keyed=true)\n# [\n#   {city: 'london', location: [51.50,-0.11]},\n#   {city: 'paris', location: [48.85,2.30]},\n#   {city: 'rome', location: null},\n# ]\n```\n\nnow we see that:\n- locations are arrays with numeric latitude and longitude\n- rome's location is a native python `none`\n\nand because there are no errors after reading, we can be sure that our data is valid against our schema. let's save it:\n\n```python\ntable.schema.save('schema.json')\ntable.save('data.csv')\n```\n\nour `data.csv` looks the same because it has been stringified back to `csv` format. but now we have `schema.json`:\n\n```json\n{\n    \"fields\": [\n        {\n            \"name\": \"city\",\n            \"type\": \"string\",\n            \"format\": \"default\"\n        },\n        {\n            \"name\": \"location\",\n            \"type\": \"geopoint\",\n            \"format\": \"default\"\n        }\n    ],\n    \"missingvalues\": [\n        \"\",\n        \"n/a\"\n    ]\n}\n\n```\n\nif we decide to improve it even more we could update the schema file and then open it again. but now providing a schema path:\n\n```python\ntable = table('data.csv', schema='schema.json')\n# continue the work\n```\n\nas already mentioned a given schema can be used to *validate* data (see the [schema](#schema) section for schema specification details). in default mode invalid data rows immediately trigger an [exception](#exceptions) in the `table.iter()`/`table.write()` methods.\n\nsuppose this schema-invalid local file `invalid_data.csv`:\n```csv\nkey,value\nzero,0\none,not_an_integer\ntwo,2\n```\n\nwe're going to validate the data against the following schema:\n```python\ntable = table(\n    'invalid_data.csv',\n    schema={'fields': [{'name': 'key'}, {'name': 'value', 'type': 'integer'}]})\n```\n\niterating over the data triggers an exception due to the failed cast of `'not_an_integer'` to `int`:\n```python\nfor row in table.iter():\n    print(row)\n\n# traceback (most recent call last):\n# ...\n# tableschema.exceptions.casterror: there are 1 cast errors (see exception.errors) for row \"3\"\n```\n\nhint: the row number count starts with 1 and also includes header lines.\n\n(note: you can optionally switch off `iter()`/`read()` value casting using the cast parameter, see reference below.)\n\nby providing a custom exception handler (a callable) to those methods you can treat occurring exceptions at your own discretion, i.e. to \"fail late\" and e.g. gather a validation report on the whole data:\n\n```python\nerrors = []\ndef exc_handler(exc, row_number=none, row_data=none, error_data=none):\n    errors.append((exc, row_number, row_data, error_data))\n\nfor row in table.iter(exc_handler=exc_handler):\n    print(row)\n\n# ['zero', 0]\n# ['one', failedcast('not_an_integer')]\n# ['two', 2]\n\nprint(errors)\n\n# [(casterror('there are 1 cast errors (see exception.errors) for row \"3\"',),\n#   3,\n#   ordereddict([('key', 'one'), ('value', 'not_an_integer')]),\n#   ordereddict([('value', 'not_an_integer')]))]\n```\n\nnote that\n\n- data rows are yielded even though the data is schema-invalid; this is due to our custom expression handler choosing not to raise exceptions (but rather collect them in the errors list).\n- data field values that can't get casted properly (if `iter()`/`read()` cast parameter is set to true, which is the default) are wrapped into a `failedcast` \"value holder\". this allows for distinguishing uncasted values from successfully casted values on the data consumer side. `failedcast` instances can only get yielded when custom exception handling is in place.\n- the custom exception handler callable must support a function signature as specified in the `iter()`/`read()` sections of the `table` class api reference.\n\n### working with schema\n\na model of a schema with helpful methods for working with the schema and supported data. schema instances can be initialized with a schema source as a url to a json file or a json object. the schema is initially validated (see [validate](#validate) below). by default validation errors will be stored in `schema.errors` but in a strict mode it will be instantly raised.\n\nlet's create a blank schema. it's not valid because `descriptor.fields` property is required by the [table schema](http://specs.frictionlessdata.io/table-schema/) specification:\n\n```python\nschema = schema()\nschema.valid # false\nschema.errors\n# [<validationerror: \"'fields' is a required property\">]\n```\n\nto avoid creating a schema descriptor by hand we will use a `schema.infer` method to infer the descriptor from given data:\n\n```python\nschema.infer([\n  ['id', 'age', 'name'],\n  ['1','39','paul'],\n  ['2','23','jimmy'],\n  ['3','36','jane'],\n  ['4','28','judy'],\n])\nschema.valid # true\nschema.descriptor\n#{ fields:\n#   [ { name: 'id', type: 'integer', format: 'default' },\n#     { name: 'age', type: 'integer', format: 'default' },\n#     { name: 'name', type: 'string', format: 'default' } ],\n#  missingvalues: [ '' ] }\n```\n\nnow we have an inferred schema and it's valid. we can cast data rows against our schema. we provide a string input which will be cast correspondingly:\n\n```python\nschema.cast_row(['5', '66', 'sam'])\n# [ 5, 66, 'sam' ]\n```\n\nbut if we try provide some missing value to the `age` field, the cast will fail because the only valid \"missing\" value is an empty string. let's update our schema:\n\n```python\nschema.cast_row(['6', 'n/a', 'walt'])\n# cast error\nschema.descriptor['missingvalues'] = ['', 'n/a']\nschema.commit()\nschema.cast_row(['6', 'n/a', 'walt'])\n# [ 6, none, 'walt' ]\n```\n\nwe can save the schema to a local file, and resume work on it at any time by loading it from that file:\n\n```python\nschema.save('schema.json')\nschema = schema('schema.json')\n```\n\n### working with field\n\n```python\nfrom tableschema import field\n\n# init field\nfield = field({'name': 'name', 'type': 'number'})\n\n# cast a value\nfield.cast_value('12345') # -> 12345\n```\n\ndata values can be cast to native python objects with a field instance. type instances can be initialized with [field descriptors](https://specs.frictionlessdata.io/table-schema/). this allows formats and constraints to be defined.\n\ncasting a value will check the value is of the expected type, is in the correct format, and complies with any constraints imposed by a schema. e.g. a date value (in iso 8601 format) can be cast with a datetype instance. values that can't be cast will raise an `invalidcasterror` exception.\n\ncasting a value that doesn't meet the constraints will raise a `constrainterror` exception.\n\n## api reference\n\n### `cli`\n```python\ncli()\n```\ncommand-line interface\n\n```\nusage: tableschema [options] command [args]...\n\noptions:\n  --help  show this message and exit.\n\ncommands:\n  infer     infer a schema from data.\n  info      return info on this version of table schema\n  validate  validate that a supposed schema is in fact a table schema.\n```\n\n\n### `table`\n```python\ntable(self,\n      source,\n      schema=none,\n      strict=false,\n      post_cast=[],\n      storage=none,\n      **options)\n```\ntable representation\n\n__arguments__\n- __source (str/list[])__: data source one of:\n    - local file (path)\n    - remote file (url)\n    - array of arrays representing the rows\n- __schema (any)__: data schema in all forms supported by `schema` class\n- __strict (bool)__: strictness option to pass to `schema` constructor\n- __post_cast (function[])__: list of post cast processors\n- __storage (none)__: storage name like `sql` or `bigquery`\n- __options (dict)__: `tabulator` or storage's options\n\n__raises__\n- `tableschemaexception`: raises on any error\n\n\n\n#### `table.hash`\ntable's sha256 hash if it's available.\n\nif it's already read using e.g. `table.read`, otherwise returns `none`.\nin the middle of an iteration it returns hash of already read contents\n\n__returns__\n\n`str/none`: sha256 hash\n\n\n\n#### `table.headers`\ntable's headers is available\n\n__returns__\n\n`str[]`: headers\n\n\n\n#### `table.schema`\nreturns schema class instance if available\n\n__returns__\n\n`schema`: schema\n\n\n\n#### `table.size`\ntable's size in bytes if it's available\n\nif it's already read using e.g. `table.read`, otherwise returns `none`.\nin the middle of an iteration it returns size of already read contents\n\n__returns__\n\n`int/none`: size in bytes\n\n\n\n#### `table.iter`\n```python\ntable.iter(keyed=false,\n           extended=false,\n           cast=true,\n           integrity=false,\n           relations=false,\n           foreign_keys_values=false,\n           exc_handler=none)\n```\niterates through the table data and emits rows cast based on table schema.\n\n__arguments__\n\n\n    keyed (bool):\n        yield keyed rows in a form of `{header1: value1, header2: value2}`\n        (default is false; the form of rows is `[value1, value2]`)\n\n    extended (bool):\n        yield extended rows in a for of `[rownumber, [header1, header2], [value1, value2]]`\n        (default is false; the form of rows is `[value1, value2]`)\n\n    cast (bool):\n        disable data casting if false\n        (default is true)\n\n    integrity (dict):\n        dictionary in a form of `{'size': <bytes>, 'hash': '<sha256>'}`\n        to check integrity of the table when it's read completely.\n        both keys are optional.\n\n    relations (dict):\n        dictionary of foreign key references in a form\n        of `{resource1: [{field1: value1, field2: value2}, ...], ...}`.\n        if provided, foreign key fields will checked and resolved\n        to one of their references (/!\\ one-to-many fk are not completely resolved).\n\n    foreign_keys_values (dict):\n        three-level dictionary of foreign key references optimized\n        to speed up validation process in a form of\n        `{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}}`.\n        if not provided but relations is true, it will be created\n        before the validation process by *index_foreign_keys_values* method\n\n    exc_handler (func):\n        optional custom exception handler callable.\n        can be used to defer raising errors (i.e. \"fail late\"), e.g.\n        for data validation purposes. must support the signature below\n\n__custom exception handler__\n\n\n```python\ndef exc_handler(exc, row_number=none, row_data=none, error_data=none):\n    '''custom exception handler (example)\n\n    # arguments:\n        exc(exception):\n            deferred exception instance\n        row_number(int):\n            data row number that triggers exception exc\n        row_data(ordereddict):\n            invalid data row source data\n        error_data(ordereddict):\n            data row source data field subset responsible for the error, if\n            applicable (e.g. invalid primary or foreign key fields). may be\n            identical to row_data.\n    '''\n    # ...\n```\n\n__raises__\n- `tableschemaexception`: base class of any error\n- `casterror`: data cast error\n- `integrityerror`: integrity checking error\n- `uniquekeyerror`: unique key constraint violation\n- `unresolvedfkerror`: unresolved foreign key reference error\n\n__returns__\n\n`iterator[list]`: yields rows\n\n\n\n#### `table.read`\n```python\ntable.read(keyed=false,\n           extended=false,\n           cast=true,\n           limit=none,\n           integrity=false,\n           relations=false,\n           foreign_keys_values=false,\n           exc_handler=none)\n```\nread the whole table and return as array of rows\n\n> it has the same api as `table.iter` except for\n\n__arguments__\n- __limit (int)__: limit count of rows to read and return\n\n__returns__\n\n`list[]`: returns rows\n\n\n\n#### `table.infer`\n```python\ntable.infer(limit=100,\n            confidence=0.75,\n            missing_values=[''],\n            guesser_cls=none,\n            resolver_cls=none)\n```\ninfer a schema for the table.\n\nit will infer and set table schema to `table.schema` based on table data.\n\n__arguments__\n- __limit (int)__: limit rows sample size\n- __confidence (float)__: how many casting errors are allowed (as a ratio, between 0 and 1)\n- __missing_values (str[])__: list of missing values (by default `['']`)\n- __guesser_cls (class)__: you can implement inferring strategies by\n         providing type-guessing and type-resolving classes [experimental]\n- __resolver_cls (class)__: you can implement inferring strategies by\n         providing type-guessing and type-resolving classes [experimental]\n\n__returns__\n\n`dict`: table schema descriptor\n\n\n\n#### `table.save`\n```python\ntable.save(target, storage=none, **options)\n```\nsave data source to file locally in csv format with `,` (comma) delimiter\n\n> to save schema use `table.schema.save()`\n\n__arguments__\n- __target (str)__: saving target (e.g. file path)\n- __storage (none/str)__: storage name like `sql` or `bigquery`\n- __options (dict)__: `tabulator` or storage options\n\n__raises__\n- `tableschemaexception`: raises an error if there is saving problem\n\n__returns__\n\n`true/storage`: returns true or storage instance\n\n\n\n#### `table.index_foreign_keys_values`\n```python\ntable.index_foreign_keys_values(relations)\n```\ncreates a three-level dictionary of foreign key references\n\nwe create them optimized to speed up validation process in a form of\n`{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}}`.\n\nfor each foreign key of the schema it will iterate through the corresponding\n`relations['resource']` to create an index (i.e. a dict) of existing values\nfor the foreign fields and store on keyed row for each value combination.\n\nthe optimization relies on the indexation of possible values for one foreign key\nin a hashmap to later speed up resolution.\n\nthis method is public to allow creating the index once to apply it\non multiple tables charing the same schema\n(typically [grouped resources in datapackage](https://github.com/frictionlessdata/datapackage-py#group))\n\n__notes__\n\n- the second key of the output is a tuple of the foreign fields,\n    a proxy identifier of the foreign key\n- the same relation resource can be indexed multiple times\n    as a schema can contain more than one foreign keys\n    pointing to the same resource\n\n__arguments__\n- __relations (dict)__:\n        dict of foreign key references in a form of\n        `{resource1: [{field1: value1, field2: value2}, ...], ...}`.\n        it must contain all resources pointed in the foreign keys schema definition.\n\n__returns__\n\n`dict`:\n        returns a three-level dictionary of foreign key references\n        optimized to speed up validation process in a form of\n        `{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}})`\n\n\n### `schema`\n```python\nschema(self, descriptor={}, strict=false)\n```\nschema representation\n\n__arguments__\n- __descriptor (str/dict)__: schema descriptor one of:\n        - local path\n        - remote url\n        - dictionary\n- __strict (bool)__: flag to specify validation behaviour:\n        - if false, errors will not be raised but instead collected in `schema.errors`\n        - if true, validation errors are raised immediately\n\n__raises__\n- `tableschemaexception`: raise any error that occurs during the process\n\n\n\n#### `schema.descriptor`\nschema's descriptor\n\n__returns__\n\n`dict`: descriptor\n\n\n\n#### `schema.errors`\nvalidation errors\n\nalways empty in strict mode.\n\n__returns__\n\n`exception[]`: validation errors\n\n\n\n#### `schema.field_names`\nschema's field names\n\n__returns__\n\n`str[]`: an array of field names\n\n\n\n#### `schema.fields`\nschema's fields\n\n__returns__\n\n`field[]`: an array of field instances\n\n\n\n#### `schema.foreign_keys`\nschema's foreign keys\n\n__returns__\n\n`dict[]`: foreign keys\n\n\n\n#### `schema.headers`\nschema's field names\n\n__returns__\n\n`str[]`: an array of field names\n\n\n\n#### `schema.missing_values`\nschema's missing values\n\n__returns__\n\n`str[]`: missing values\n\n\n\n#### `schema.primary_key`\nschema's primary keys\n\n__returns__\n\n`str[]`: primary keys\n\n\n\n#### `schema.valid`\nvalidation status\n\nalways true in strict mode.\n\n__returns__\n\n`bool`: validation status\n\n\n\n#### `schema.get_field`\n```python\nschema.get_field(name)\n```\nget schema's field by name.\n\n> use `table.update_field` if you want to modify the field descriptor\n\n__arguments__\n- __name (str)__: schema field name\n\n__returns__\n\n`field/none`: `field` instance or `none` if not found\n\n\n\n#### `schema.get_field`\n```python\nschema.get_field(name)\n```\nget schema's field by name.\n\n> use `table.update_field` if you want to modify the field descriptor\n\n__arguments__\n- __name (str)__: schema field name\n\n__returns__\n\n`field/none`: `field` instance or `none` if not found\n\n\n\n#### `schema.add_field`\n```python\nschema.add_field(descriptor)\n```\nadd new field to schema.\n\nthe schema descriptor will be validated with newly added field descriptor.\n\n__arguments__\n- __descriptor (dict)__: field descriptor\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`field/none`: added `field` instance or `none` if not added\n\n\n\n#### `schema.update_field`\n```python\nschema.update_field(name, update)\n```\nupdate existing descriptor field by name\n\n__arguments__\n- __name (str)__: schema field name\n- __update (dict)__: update to apply to field's descriptor\n\n__returns__\n\n`bool`: true on success and false if no field is found to be modified\n\n\n\n#### `schema.remove_field`\n```python\nschema.remove_field(name)\n```\nremove field resource by name.\n\nthe schema descriptor will be validated after field descriptor removal.\n\n__arguments__\n- __name (str)__: schema field name\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`field/none`: removed `field` instances or `none` if not found\n\n\n\n#### `schema.cast_row`\n```python\nschema.cast_row(row, fail_fast=false, row_number=none, exc_handler=none)\n```\ncast row based on field types and formats.\n\n__arguments__\n- __row (any[]__: data row as an array of values\n\n__returns__\n\n`any[]`: returns cast data row\n\n\n\n#### `schema.infer`\n```python\nschema.infer(rows,\n             headers=1,\n             confidence=0.75,\n             guesser_cls=none,\n             resolver_cls=none)\n```\ninfer and set `schema.descriptor` based on data sample.\n\n__arguments__\n- __rows (list[])__: array of arrays representing rows.\n- __headers (int/str[])__: data sample headers (one of):\n      - row number containing headers (`rows` should contain headers rows)\n      - array of headers (`rows` should not contain headers rows)\n- __confidence (float)__: how many casting errors are allowed (as a ratio, between 0 and 1)\n- __guesser_cls (class)__: you can implement inferring strategies by\n         providing type-guessing and type-resolving classes [experimental]\n- __resolver_cls (class)__: you can implement inferring strategies by\n         providing type-guessing and type-resolving classes [experimental]\n\n__returns__\n\n`dict`: table schema descriptor\n\n\n\n#### `schema.commit`\n```python\nschema.commit(strict=none)\n```\nupdate schema instance if there are in-place changes in the descriptor.\n\n__example__\n\n\n```python\nfrom tableschema import schema\ndescriptor = {'fields': [{'name': 'my_field', 'title': 'my field', 'type': 'string'}]}\nschema = schema(descriptor)\nprint(schema.get_field('my_field').descriptor['type']) # string\n\n# update descriptor by field position\nschema.descriptor['fields'][0]['type'] = 'number'\n# update descriptor by field name\nschema.update_field('my_field', {'title': 'my pretty field'}) # true\n\n# change are not committed\nprint(schema.get_field('my_field').descriptor['type']) # string\nprint(schema.get_field('my_field').descriptor['title']) # my field\n\n# commit change\nschema.commit()\nprint(schema.get_field('my_field').descriptor['type']) # number\nprint(schema.get_field('my_field').descriptor['title']) # my pretty field\n\n```\n\n__arguments__\n- __strict (bool)__: alter `strict` mode for further work\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`bool`: true on success and false if not modified\n\n\n\n#### `schema.save`\n```python\nschema.save(target, ensure_ascii=true)\n```\nsave schema descriptor to target destination.\n\n__arguments__\n- __target (str)__: path where to save a descriptor\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`bool`: true on success\n\n\n\n### `field`\n```python\nfield(self, descriptor, missing_values=[''], schema=none)\n```\nfield representaion\n\n__arguments__\n- __descriptor (dict)__: schema field descriptor\n- __missingvalues (str[])__: an array with string representing missing values\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n\n\n#### `field.constraints`\nfield constraints\n\n__returns__\n\n`dict`: dict of field constraints\n\n\n\n#### `field.descriptor`\nfields's descriptor\n\n__returns__\n\n`dict`: descriptor\n\n\n\n#### `field.format`\nfield format\n\n__returns__\n\n`str`: field format\n\n\n\n#### `field.missing_values`\nfield's missing values\n\n__returns__\n\n`str[]`: missing values\n\n\n\n#### `field.name`\nfield name\n\n__returns__\n\n`str`: field name\n\n\n\n#### `field.required`\nwhether field is required\n\n__returns__\n\n`bool`: true if required\n\n\n\n#### `field.schema`\nreturns a schema instance if the field belongs to some schema\n\n__returns__\n\n`schema`: field's schema\n\n\n\n#### `field.type`\nfield type\n\n__returns__\n\n`str`: field type\n\n\n\n#### `field.cast_value`\n```python\nfield.cast_value(value, constraints=true)\n```\ncast given value according to the field type and format.\n\n__arguments__\n- __value (any)__: value to cast against field\n- __constraints (boll/str[])__: gets constraints configuration\n        - it could be set to true to disable constraint checks\n        - it could be an array of constraints to check e.g. ['minimum', 'maximum']\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`any`: returns cast value\n\n\n\n#### `field.test_value`\n```python\nfield.test_value(value, constraints=true)\n```\ntest whether value is compliant to the field.\n\n__arguments__\n- __value (any)__: value to cast against field\n- __constraints (bool/str[])__: constraints configuration\n\n__returns__\n\n`bool`: returns if value is compliant to the field\n\n\n### `storage`\n```python\nstorage(self, **options)\n```\nstorage factory/interface\n\n__for users__\n\n\n> use `storage.connect` to instantiate a storage\n\nfor instantiation of concrete storage instances,\n`tableschema.storage` provides a unified factory method `connect`\n(which uses the plugin system under the hood):\n\n```python\n# pip install tableschema_sql\nfrom tableschema import storage\n\nstorage = storage.connect('sql', **options)\nstorage.create('bucket', descriptor)\nstorage.write('bucket', rows)\nstorage.read('bucket')\n```\n\n__for integrators__\n\n\nthe library includes interface declaration to implement tabular `storage`.\nthis interface allow to use different data storage systems like sql\nwith `tableschema.table` class (load/save) as well as on the data package level:\n\n![storage](https://raw.githubusercontent.com/frictionlessdata/tableschema-py/master/data/storage.png)\n\nan implementor must follow `tableschema.storage` interface\nto write his own storage backend. concrete storage backends\ncould include additional functionality specific to conrete storage system.\nsee `plugins` below to know how to integrate custom storage plugin into your workflow.\n\n\n\n#### `storage.buckets`\nreturn list of storage bucket names.\n\na `bucket` is a special term which has almost the same meaning as `table`.\nyou should consider `bucket` as a `table` stored in the `storage`.\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n__returns__\n\n`str[]`: return list of bucket names\n\n\n\n#### `storage.connect`\n```python\nstorage.connect(name, **options)\n```\ncreate tabular `storage` based on storage name.\n\n> this method is statis: `storage.connect()`\n\n__arguments__\n- __name (str)__: storage name like `sql`\n- __options (dict)__: concrete storage options\n\n__raises__\n- `storageerror`: raises on any error\n\n__returns__\n\n`storage`: returns `storage` instance\n\n\n\n#### `storage.create`\n```python\nstorage.create(bucket, descriptor, force=false)\n```\ncreate one/multiple buckets.\n\n__arguments__\n- __bucket (str/list)__: bucket name or list of bucket names\n- __descriptor (dict/dict[])__: schema descriptor or list of descriptors\n- __force (bool)__: whether to delete and re-create already existing buckets\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n\n\n#### `storage.delete`\n```python\nstorage.delete(bucket=none, ignore=false)\n```\ndelete one/multiple/all buckets.\n\n__arguments__\n- __bucket (str/list/none)__: bucket name or list of bucket names to delete.\n        if `none`, all buckets will be deleted\n- __descriptor (dict/dict[])__: schema descriptor or list of descriptors\n- __ignore (bool)__: don't raise an error on non-existent bucket deletion\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n\n\n#### `storage.describe`\n```python\nstorage.describe(bucket, descriptor=none)\n```\nget/set bucket's table schema descriptor\n\n__arguments__\n- __bucket (str)__: bucket name\n- __descriptor (dict/none)__: schema descriptor to set\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n__returns__\n\n`dict`: returns table schema descriptor\n\n\n\n#### `storage.iter`\n```python\nstorage.iter(bucket)\n```\nreturn an iterator of typed values based on the schema of this bucket.\n\n__arguments__\n- __bucket (str)__: bucket name\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n__returns__\n\n`list[]`: yields data rows\n\n\n\n#### `storage.read`\n```python\nstorage.read(bucket)\n```\nread typed values based on the schema of this bucket.\n\n__arguments__\n- __bucket (str)__: bucket name\n__raises__\n- `exceptions.storageerror`: raises on any error\n__returns__\n\n`list[]`: returns data rows\n\n\n\n#### `storage.write`\n```python\nstorage.write(bucket, rows)\n```\nthis method writes data rows into `storage`.\n\nit should store values of unsupported types as strings internally (like csv does).\n\n__arguments__\n- __bucket (str)__: bucket name\n- __rows (list[])__: data rows to write\n\n__raises__\n- `exceptions.storageerror`: raises on any error\n\n\n### `validate`\n```python\nvalidate(descriptor)\n```\nvalidate descriptor\n\n__arguments__\n- __dict__: descriptor\n\n__raises__\n- `validationerror`: on validation errors\n\n__returns__\n\n`bool`: true\n\n\n### `infer`\n```python\ninfer(source,\n      headers=1,\n      limit=100,\n      confidence=0.75,\n      missing_values=[''],\n      guesser_cls=none,\n      resolver_cls=none,\n      **options)\n```\ninfer source schema.\n\n__arguments__\n- __source (any)__: source as path, url or inline data\n- __headers (int/str[])__: headers rows number or headers list\n- __confidence (float)__: how many casting errors are allowed (as a ratio, between 0 and 1)\n- __missing_values (str[])__: list of missing values (by default `['']`)\n- __guesser_cls (class)__: you can implement inferring strategies by\n        providing type-guessing and type-resolving classes [experimental]\n- __resolver_cls (class)__: you can implement inferring strategies by\n        providing type-guessing and type-resolving classes [experimental]\n\n__raises__\n- `tableschemaexception`: raises any error that occurs during the process\n\n__returns__\n\n`dict`: returns schema descriptor\n\n\n### `failedcast`\n```python\nfailedcast(self, value)\n```\nwrap an original data field value that failed to be properly casted.\n\nfailedcast allows for further processing/yielding values but still be able\nto distinguish uncasted values on the consuming side.\n\ndelegates attribute access and the basic rich comparison methods to the\nunderlying object. supports default user-defined classes hashability i.e.\nis hashable based on object identity (not based on the wrapped value).\n\n__arguments__\n- __value (any)__: value\n\n\n### `datapackageexception`\n```python\ndatapackageexception(self, message, errors=[])\n```\nbase class for all datapackage/tableschema exceptions.\n\nif there are multiple errors, they can be read from the exception object:\n\n```python\ntry:\n    # lib action\nexcept datapackageexception as exception:\n    if exception.multiple:\n        for error in exception.errors:\n            # handle error\n```\n\n\n\n#### `datapackageexception.errors`\nlist of nested errors\n\n__returns__\n\n`datapackageexception[]`: list of nested errors\n\n\n\n#### `datapackageexception.multiple`\nwhether it's a nested exception\n\n__returns__\n\n`bool`: whether it's a nested exception\n\n\n\n### `tableschemaexception`\n```python\ntableschemaexception(self, message, errors=[])\n```\nbase class for all tableschema exceptions.\n\n\n### `loaderror`\n```python\nloaderror(self, message, errors=[])\n```\nall loading errors.\n\n\n### `validationerror`\n```python\nvalidationerror(self, message, errors=[])\n```\nall validation errors.\n\n\n### `casterror`\n```python\ncasterror(self, message, errors=[])\n```\nall value cast errors.\n\n\n### `integrityerror`\n```python\nintegrityerror(self, message, errors=[])\n```\nall integrity errors.\n\n\n### `uniquekeyerror`\n```python\nuniquekeyerror(self, message, errors=[])\n```\nunique key constraint violation (casterror subclass)\n\n\n### `relationerror`\n```python\nrelationerror(self, message, errors=[])\n```\nall relations errors.\n\n\n### `unresolvedfkerror`\n```python\nunresolvedfkerror(self, message, errors=[])\n```\nunresolved foreign key reference error (relationerror subclass).\n\n\n### `storageerror`\n```python\nstorageerror(self, message, errors=[])\n```\nall storage errors.\n\n## experimental\n\n> this api is experimental and can be changed/removed in the future\n\nthere is an experimental environment variable `tableschema_preserve_missing_values` which, if it is set, affects how data casting works.\n\nby default, missing values are resolved to `none` values. when this flag is set, missing values are passed through as it is. for example:\n\n> missing_values.py\n\n```python\nfrom tableschema import field\n\nfield = field({'type': 'number'}, missing_values=['-'])\nprint(field.cast_value('3'))\nprint(field.cast_value('-'))\n```\n\nrunning this script in different modes:\n\n```bash\n$ python missing_values.py\n3\nnone\n$ tableschema_preserve_missing_values=1 python missing_values.py\n3\n-\n```\n\nthe flags affects all the library's apis and software built on top of `tableschema`. for example, data package pipelines:\n\n```bash\n$ tableschema_preserve_missing_values=1 dpp run ./my_pipeline\n```\n\n## contributing\n\n> the project follows the [open knowledge international coding standards](https://github.com/okfn/coding-standards).\n\nrecommended way to get started is to create and activate a project virtual environment.\nto install package and development dependencies into active environment:\n\n```bash\n$ make install\n```\n\nto run tests with linting and coverage:\n\n```bash\n$ make test\n```\n\n## changelog\n\nhere described only breaking and the most important changes. the full changelog and documentation for all released versions can be found in the nicely formatted [commit history](https://github.com/frictionlessdata/tableschema-py/commits/master).\n\n#### v1.20\n\n- added --json flag to the cli (#287)\n\n#### v1.19\n\n- deduplicate field names if guessing in infer\n\n#### v1.18\n\n- publish `field.error/cast_function/check_functions`\n\n#### v1.17\n\n- added `schema.missing_values` and `field.missing_values`\n\n#### v1.16\n\n- fixed the way we parse `geopoint`:\n    - as a string it can be in 3 forms (\"default\", \"array\", \"object\") but\n    - as native object it can only be a list/tuple\n\n#### v1.15\n\n- added an experimental `tableschema_preserve_missing_values` environment variable flag\n\n#### v1.14\n\n- allow providing custom guesser and resolver to `table.infer` and `infer`\n\n#### v1.13\n\n- added `missing_values` argument to the `infer` function (#269)\n\n#### v1.12\n\n- support optional custom exception handling for table.iter/read (#259)\n\n#### v1.11\n\n- added `preserve_missing_values` parameter to `field.cast_value`\n\n#### v1.10\n\n- added an ability to check table's integrity while reading\n\n#### v1.9\n\n- implemented the `table.size` and `table.hash` properties\n\n#### v1.8\n\n- added `table.index_foreign_keys_values` and improved foreign key checks performance\n\n#### v1.7\n\n- added `field.schema` property\n\n#### v1.6\n\n- in `strict` mode raise an exception if there are problems in field construction\n\n#### v1.5\n\n- allow providing custom guesser and resolver to schema infer\n\n#### v1.4\n\n- added `schema.update_field` method\n\n#### v1.3\n\n- support datetime with no time for date casting\n\n#### v1.2\n\n- support floats like 1.0 for integer casting\n\n#### v1.1\n\n- added the `confidence` parameter to `infer`\n\n#### v1.0\n\n- the library has been rebased on the frictionless data specs v1 - https://frictionlessdata.io/specs/table-schema/\n\n",
  "docs_url": null,
  "keywords": "frictionless data,open data,json schema,table schema,data package,tabular data package",
  "license": "mit",
  "name": "tableschema",
  "package_url": "https://pypi.org/project/tableschema/",
  "project_url": "https://pypi.org/project/tableschema/",
  "project_urls": {
    "Homepage": "https://github.com/frictionlessdata/tableschema-py"
  },
  "release_url": "https://pypi.org/project/tableschema/1.20.2/",
  "requires_dist": [
    "six (>=1.9)",
    "click (>=3.3)",
    "requests (>=2.5)",
    "cached-property (>=1.5)",
    "python-dateutil (>=2.4)",
    "jsonschema (>=2.5)",
    "unicodecsv (>=0.14)",
    "isodate (>=0.5.4)",
    "rfc3986 (>=1.1.0)",
    "tabulator (>=1.51.3)",
    "mock ; extra == 'develop'",
    "pylama ; extra == 'develop'",
    "pytest ; extra == 'develop'",
    "pytest-cov ; extra == 'develop'"
  ],
  "requires_python": "",
  "summary": "a utility library for working with table schema in python",
  "version": "1.20.2",
  "releases": [],
  "developers": [
    "info@okfn.org",
    "open_knowledge_foundation"
  ],
  "kwds": "tableschema frictionlessdata tableschema_sql tableschema_preserve_missing_values tables",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_tableschema",
  "homepage": "https://github.com/frictionlessdata/tableschema-py",
  "release_count": 79,
  "dependency_ids": [
    "pypi_cached_property",
    "pypi_click",
    "pypi_isodate",
    "pypi_jsonschema",
    "pypi_mock",
    "pypi_pylama",
    "pypi_pytest",
    "pypi_pytest_cov",
    "pypi_python_dateutil",
    "pypi_requests",
    "pypi_rfc3986",
    "pypi_six",
    "pypi_tabulator",
    "pypi_unicodecsv"
  ]
}