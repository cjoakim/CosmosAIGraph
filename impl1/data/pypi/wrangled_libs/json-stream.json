{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries"
  ],
  "description": "# json-stream\n\n[![tests](https://github.com/daggaz/json-stream/actions/workflows/tests.yml/badge.svg)](https://github.com/daggaz/json-stream/actions/workflows/tests.yml)\n[![pypi package and version badge](https://img.shields.io/pypi/v/json-stream)](https://pypi.org/project/json-stream)\n[![supported python versions badge](https://img.shields.io/pypi/pyversions/json-stream)](https://pypi.org/project/json-stream/)\n[![donate](https://img.shields.io/badge/buy%20me%20a%20coffee-donate-blue.svg)](https://www.buymeacoffee.com/daggaz)\n\nsimple streaming json parser and encoder.\n\nwhen [reading](#reading) json data, `json-stream` can decode json data in \na streaming manner, providing a pythonic dict/list-like interface, or a\n[visitor-based interfeace](#visitor). can stream from files, [urls](#urls) \nor [iterators](#iterators).\n\nwhen [writing](#writing) json data, `json-stream` can stream json objects \nas you generate them.\n\nthese techniques allow you to [reduce memory consumption and \nlatency](#standard-json-problems).\n\n# <a id=\"reading\"></a> reading\n\n`json-stream` is a json parser just like the standard library's\n [`json.load()`](https://docs.python.org/3/library/json.html#json.load). it \n will read a json document and convert it into native python types.\n\n```python\nimport json_stream\ndata = json_stream.load(f)\n```\n\nfeatures:\n* stream all json data types (objects, lists and simple types)\n* stream nested data\n* simple pythonic `list`-like/`dict`-like interface\n* stream truncated or malformed json data (up to the first error)\n* [native code parsing speedups](#rust-tokenizer) for most common platforms \n* pure python fallback if native extensions not available\n\nunlike `json.load()`, `json-stream` can _stream_ json data from any file-like or\n[iterable](#iterators) object. this has the following benefits:\n\n* it does not require the whole json document to be read into memory up-front\n* it can start producing data before the entire document has finished loading\n* it only requires enough memory to hold the data currently being parsed\n\nthere are specific integrations for streaming json data from [urls](#urls) using the \n[`requests`](#requests), [`httpx`](#httpx), or [`urllib`](#urllib).\n\nthe objects that `json-stream` produces can be [re-output](#encoding-json-stream-objects)\nusing `json.dump()` with a little work.\n\n## usage\n\n### `json_stream.load()`\n\n`json_stream.load()` has two modes of operation, controlled by\nthe `persistent` argument (default false).\n\nit is also possible to \"mix\" the modes as you consume the data.\n\n#### transient mode (default)\n\nthis mode is appropriate if you can consume the data iteratively. you cannot \nmove backwards through the stream to read data that has already been skipped\nover. it is the mode you **must** use if you want to process large amounts of\njson data without consuming large amounts of memory.\n\nin transient mode, only the data currently being read is stored in memory. any\ndata previously read from the stream is discarded (it's up to you what to do \nwith it) and attempting to access this data results in a\n`transientaccessexception`.\n\n```python\nimport json_stream\n\n# json: {\"count\": 3, \"results\": [\"a\", \"b\", \"c\"]}\ndata = json_stream.load(f)  # data is a transient dict-like object \n# stream has been read up to \"{\"\n\n# use data like a dict\nresults = data[\"results\"]  # results is a transient list-like object\n# stream has been read up to \"[\", we now cannot read \"count\"\n\n# iterate transient list\nfor result in results:\n    print(result)  # prints a, b, c\n# stream has been read up to \"]\"\n\n# attempt to read \"count\" from earlier in stream\ncount = data[\"count\"]  # will raise exception\n# stream is now exhausted\n\n# attempt to read from list that has already been iterated\nfor result in results:  # will raise exception\n    pass\n```\n\n#### persistent mode\n\nin persistent mode all previously read data is stored in memory as\nit is parsed. the returned `dict`-like or `list`-like objects\ncan be used just like normal data structures.\n\nif you request an index or key that has already been read from the stream\nthen it is retrieved from memory. if you request an index or key that has\nnot yet been read from the stream, then the request blocks until that item\nis found in the stream.\n\n```python\nimport json_stream\n\n# json: {\"count\": 1, \"results\": [\"a\", \"b\", \"c\"]}\ndata = json_stream.load(f, persistent=true)\n# data is a streaming  dict-like object \n# stream has been read up to \"{\"\n\n# use data like a dict\nresults = data[\"results\"]  # results is a streaming list-like object\n# stream has been read up to \"[\"\n# count has been stored data\n\n# use results like a list\na_result = results[1]  # a_result = \"b\"\n# stream has been read up to the middle of list\n# \"a\" and \"b\" have been stored in results\n\n# read earlier data from memory\ncount = data[\"count\"]  # count = 1\n\n# consume rest of list\nresults.read_all()\n# stream has been read up to \"}\"\n# \"c\" is now stored in results too\n# results.is_streaming() == false\n\n# consume everything\ndata.read_all()\n# stream is now exhausted\n# data.is_streaming() == false\n```\n\npersistent mode is not appropriate if you care about memory consumption, but\nprovides an identical experience compared to `json.load()`.\n\n#### mixed mode\n\nin some cases you will need to be able to randomly access some part of the \ndata, but still only have that specific data taking up memory resources.\n\nfor example, you might have a very long list of objects, but you cannot always \naccess the keys of the objects in stream order. you want to be able to iterate\nthe list transiently, but access the result objects persistently.\n\nthis can be achieved using the `persistent()` method of all the `list` or\n`dict`-like objects json_stream produces. calling `persistent()` causes the existing\ntransient object to produce persistent child objects.\n\nnote that the `persistent()` method makes the children of the object it\nis called on persistent, not the object it is called on.\n\n```python\nimport json_stream\n\n# json: {\"results\": [{\"x\": 1, \"y\": 3}, {\"y\": 4, \"x\": 2}]}\n# note that the keys of the inner objects are not ordered \ndata = json_stream.load(f)  # data is a transient dict-like object \n\n# iterate transient list, but produce persistent items\nfor result in data['results'].persistent():\n    # result is a persistent dict-like object\n    print(result['x'])  # print x\n    print(result['y'])  # print y (error on second result without .persistent())\n    print(result['x'])  # print x again (error without .persistent())\n```\n\nthe opposite is also possible, going from persistent mode to transient mode, though \nthe use cases for this are more esoteric.\n\n```python\n# json: {\"a\": 1, \"x\": [\"long\", \"list\", \"i\", \"don't\", \"want\", \"in\", \"memory\"], \"b\": 2}\ndata = load(stringio(json), persistent=true).transient()\n# data is a persistent dict-list object that produces transient children\n\nprint(data[\"a\"])  # prints 1\nx = data[\"x\"]  # x is a transient list, you can use it accordingly\nprint(x[0])  # prints long\n\n# access earlier data from memory\nprint(data[\"a\"])  # this would have raised an exception if data was transient\n\nprint(data[\"b\"])  # prints 2\n\n# we have now moved past all the data in the transient list\nprint(x[0])  # will raise exception\n```\n\n### <a id=\"visitor\"></a>visitor pattern\n\nyou can also parse using a visitor-style approach where a function you supply\nis called for each data item as it is parsed (depth-first).\n\nthis uses a transient parser under the hood, so does not consume memory for\nthe whole document.\n\n```python\nimport json_stream\n\n# json: {\"x\": 1, \"y\": {}, \"xxxx\": [1,2, {\"yyyy\": 1}, \"z\", 1, []]}\n\ndef visitor(item, path):\n    print(f\"{item} at path {path}\")\n\njson_stream.visit(f, visitor)\n```\n\noutput:\n```\n1 at path ('x',)\n{} at path ('y',)\n1 at path ('xxxx', 0)\n2 at path ('xxxx', 1)\n1 at path ('xxxx', 2, 'yyyy')\nz at path ('xxxx', 3)\n1 at path ('xxxx', 4)\n[] at path ('xxxx', 5)\n```\n\n### <a id=\"urls\"></a> stream a url\n\n`json_stream` knows how to stream directly from a url using a variety of packages.\nsupported packages include:\n- python's batteries-included [`urllib`](#urllib) package\n- the popular [`requests`](#requests) library\n- the newer [`httpx`](#httpx) library\n\n#### <a id=\"urllib\"></a> urllib\n\n[`urllib`](https://docs.python.org/3/library/urllib.html)'s response objects are already\nfile-like objects, so we can just pass them directly to `json-stream`.\n\n```python\nimport urllib.request\nimport json_stream\n\nwith urllib.request.urlopen('http://example.com/data.json') as response:\n    data = json_stream.load(response)\n```\n\n#### <a id=\"requests\"></a>requests\n\nto stream json data from [`requests`](https://requests.readthedocs.io/en/latest/), you must\npass `stream=true` when making a request, and call `json_stream.requests.load()` passing the response. \n\n```python\nimport requests\nimport json_stream.requests\n\nwith requests.get('http://example.com/data.json', stream=true) as response:\n    data = json_stream.requests.load(response)\n```\n\n<a id=\"requests-chunk-size\"></a>\nnote: these functions use\n[`response.iter_content()`](https://requests.readthedocs.io/en/latest/api/#requests.response.iter_content) under the\nhood with a `chunk_size` of 10k bytes. this default allows us to perform effective reads from the response stream and \nlower cpu usage. the drawback to this is that `requests` will buffer each read until up to 10k bytes have been read \nbefore passing the data back to `json_stream`. if you need to consume data more responsively the only option is to tune\n`chunk_size` back to 1 to disable buffering.\n\n#### <a id=\"httpx\"></a> httpx\n\nto stream json data from [`httpx`](https://www.python-httpx.org/), you must call\n[`stream()`](https://www.python-httpx.org/quickstart/#streaming-responses) when\nmaking your request, and call `json_stream.httpx.load()` passing the response.\n\n```python\nimport httpx\nimport json_stream.httpx\n\nwith httpx.client() as client, client.stream('get', 'http://example.com/data.json') as response:\n    data = json_stream.httpx.load(response)\n```\n\nunder the hood, this works similarly to the [`requests`](#requests) version above, including \nthe caveat about [`chunk_size`](#requests-chunk-size).\n\n### stream a url (with visitor)\n\nthe visitor pattern also works with url streams.\n\n#### urllib\n\n```python\nimport urllib.request\nimport json_stream\n\ndef visitor(item, path):\n    print(f\"{item} at path {path}\")\n    \nwith urllib.request.urlopen('http://example.com/data.json') as response:\n    json_stream.visit(response, visitor)\n```\n\n#### requests\n\n```python\nimport requests\nimport json_stream.requests\n\ndef visitor(item, path):\n    print(f\"{item} at path {path}\")\n    \nwith requests.get('http://example.com/data.json', stream=true) as response:\n    json_stream.requests.visit(response, visitor)\n```\n\nthe [`chunk_size`](#requests-chunk-size) note also applies to `visit()`.\n\n#### httpx\n\n```python\nimport httpx\nimport json_stream.httpx\n\ndef visitor(item, path):\n    print(f\"{item} at path {path}\")\n    \nwith httpx.client() as client, client.stream('get', 'http://example.com/data.json') as response:\n    json_stream.httpx.visit(response, visitor)\n```\n\n### <a id=\"iterators\"></a> stream an iterable\n\n`json-stream`'s parsing functions can take any iterable object that produces encoded json as\n`byte` objects.\n\n```python\nimport json_stream\n\ndef some_iterator():\n    yield b'{\"some\":'\n    yield b' \"json\"}'\n\ndata = json_stream.load(some_iterator())\nassert data['some'] == \"json\"\n```\n\nthis is actually how the [`requests`](#requests) and [`httpx`](#httpx) extensions work, as\nboth libraries provide methods to iterate over the response content.\n\n### <a id=\"encoding-json-stream-objects\"></a> encoding json-stream objects\n\nyou can re-output (encode) _persistent_ json-stream `dict`-like and `list`-like object back to json using the built-in\n`json.dump()` or `json.dumps()` functions, but with a little additional work:\n\n```python\nimport json\n\nimport json_stream\nfrom json_stream.dump import jsonstreamencoder, default\n\ndata = json_stream.load(f, persistent=true)\n\n# option 1: supply json_stream.encoding.default as the default argument\nprint(json.dumps(data, default=default))\n\n# option 2: supply json_stream.encoding.jsonstreamencoder as the cls argument\n# this allows you to create your own subclass to further customise encoding\nprint(json.dumps(data, cls=jsonstreamencoder))\n```\n\nif you are using a library that internally takes data you pass it and encodes\nit using `json.dump()`. you can also use jsonstreamencoder() as a context manager.\n\nit works by monkey-patching the built-in `jsonencoder.default` method during the\nscope of the `with` statement.\n\n```python \n# library code\ndef some_library_function_out_of_your_control(arg):\n    json.dumps(arg)\n\n# your code\nwith jsonstreamencoder():\n    some_library_function_out_of_your_control(data)\n```\n\n### converting to standard python types\n\nto convert a json-stream `dict`-like or `list`-like object and all its\ndescendants to a standard `list` and `dict`, you can use the\n`json_stream.to_standard_types` utility:\n\n```python\n# json: {\"round\": 1, \"results\": [1, 2, 3]}\ndata = json_stream.load(f)\nresults = data[\"results\"]\nprint(results)  # prints <transientstreamingjsonlist: transient, streaming>\nconverted = json_stream.to_standard_types(results)\nprint(converted)  # prints [1, 2, 3]\n```\n\n#### thread safety (experimental)\n\nthere is also a thread-safe version of the `json.dump` context manager:\n\n```python\nfrom json_stream.dump.threading import threadsafejsonstreamencoder\n\n# your code\nwith threadsafejsonstreamencoder():\n   some_library_function_out_of_your_control(data)\n```\n\nthe thread-safe implementation will ensure that concurrent uses of the \ncontext manager will only apply the patch for the first thread entering\nthe patched section(s) and will only remove the patch when the last\nthread exits the patched sections(s)\n\nadditionally, if the patch is somehow called by a thread that is _not_\ncurrently in a patched section (i.e. some other thread calling \n`json.dump`) then that thread will block until the patch has been\nremoved. while such an un-patched thread is active, any thread attempting\nto apply the patch is blocked.\n\n### <a id=\"rust-tokenizer\"></a> rust tokenizer speedups\n\nby default `json-stream` uses the \n[`json-stream-rs-tokenizer`](https://pypi.org/project/json-stream-rs-tokenizer/)\nnative extension.\n\nthis is a 3rd party rust-based tokenizer implementations that provides\nsignificant parsing speedup compared to pure python implementation.\n\n`json-stream` will fallback to its pure python tokenizer implementation\nif `json-stream-rs-tokenizer` is not available.\n\n### custom tokenizer\n\nyou can supply an alternative json tokenizer implementation. simply pass \na tokenizer to the `load()` or `visit()` methods.\n\n```python\njson_stream.load(f, tokenizer=some_tokenizer)\n```\n\nthe requests methods also accept a customer tokenizer parameter.\n\n\n# writing\n\nthe standard library's `json.dump()` function can only accept standard\npython types such as `dict`, `list`, `str`.\n\n`json-stream` allows you to write streaming json output based on python\ngenerators instead.\n\nfor actually encoding and writing to the stream, `json-stream` \nstill uses the standard library's `json.dump()` function, but provides\nwrappers that adapt python generators into `dict`/`list` subclasses \nthat `json.dump()` can use.\n\nthe means that you do not have to generate all of your data upfront\nbefore calling `json.dump()`.\n\n## usage\n\nto use `json-stream` to generate json data iteratively, you must first \nwrite python generators (or use any other iterable).\n\nto output json objects, the iterable must yield key/value pairs.\n\nto output json lists, the iterable must yield individual items.\n\nthe values yielded can be either be standard python types or another other\n`streamable` object, allowing lists and object to be arbitrarily nested.\n\n`streamable_list`/`streamable_dict` can be used to wrap an existing\niterable:\n```python\nimport sys\nimport json\n\nfrom json_stream import streamable_list\n\n# wrap existing iterable\ndata = streamable_list(range(10))\n\n# consume iterable with standard json.dump()\njson.dump(data, sys.stdout)\n```\n\nor they can be used as decorators on generator functions:\n```python\nimport json\nimport sys\n\nfrom json_stream import streamable_dict\n\n# declare a new streamable dict generator function\n@streamable_dict\ndef generate_dict_of_squares(n):\n    for i in range(n):\n        # this could be some memory intensive operation\n        # or just a really large value of n\n        yield i, i ** 2\n\n# data is will already be streamable because\n# of the decorator\ndata = generate_dict_of_squares(10)\njson.dump(data, sys.stdout)\n```\n\n## example\n\nthe following example generates a json object with a nested json list.\nit uses `time.sleep()` to slow down the generation and show that the\noutput is indeed written as the data is created.\n\n```python\nimport sys\nimport json\nimport time\n\nfrom json_stream.writer import streamable_dict, streamable_list\n\n\n# define a list data generator that (slowly) yields \n# items that will be written as a json list\n@streamable_list\ndef generate_list(n):\n    # output n numbers and their squares\n    for i in range(n):  # range is itself a generator\n        yield i\n        time.sleep(1)\n\n\n# define a dictionary data generator that (slowly) yields \n# key/value pairs that will be written as a json dict\n@streamable_dict\ndef generate_dict(n):\n    # output n numbers and their squares\n    for i in range(n):  # range is itself a generator\n        yield i, i ** 2\n        time.sleep(1)\n\n    # yield another dictionary item key, with the value\n    # being a streamed nested list\n    yield \"a list\", generate_list(n)\n\n\n# get a streamable generator\ndata = generate_dict(5)\n\n# use json.dump() to write dict generator to stdout\njson.dump(data, sys.stdout, indent=2)\n\n# if you already have an iterable object, you can just\n# call streamable_* on it to make it writable\ndata = streamable_list(range(10))\njson.dump(data, sys.stdout)\n\n```\n\noutput:\n```json\n{\n  \"0\": 0,\n  \"1\": 1,\n  \"2\": 4,\n  \"3\": 9,\n  \"4\": 16,\n  \"a list\": [\n    0,\n    1,\n    2,\n    3,\n    4\n  ]\n}\n```\n\n# <a id=\"standard-json-problems\"></a> what are the problems with the standard `json` package?\n\n## reading with `json.load()`\nthe problem with the `json.load()` stem from the fact that it must read\nthe whole json document into memory before parsing it.\n\n### memory usage\n\n`json.load()` first reads the whole document into memory as a string. it\nthen starts parsing that string and converting the whole document into python\ntypes again stored in memory. for a very large document, this could be more\nmemory than you have available to your system.\n\n`json_stream.load()` does not read the whole document into memory, it only\nbuffers enough from the stream to produce the next item of data.\n\nadditionally, in the default transient mode (see below) `json-stream` doesn't store \nup all of the parsed data in memory.\n\n### latency\n\n`json.load()` produces all the data after parsing the whole document. if you\nonly care about the first 10 items in a list of 2 million items, then you\nhave wait until all 2 million items have been parsed first.\n\n`json_stream.load()` produces data as soon as it is available in the stream.\n\n## <a id=\"writing\"></a> writing\n\n### memory usage\n\nwhile `json.dump()` does iteratively write json data to the given\nfile-like object, you must first produce the entire document to be \nwritten as standard python types (`dict`, `list`, etc). for a very\nlarge document, this could be more memory than you have available \nto your system.\n\n`json-stream` allows you iteratively generate your data one item at\na time, and thus consumes only the memory required to generate that\none item.\n\n### latency\n\n`json.dump()` can only start writing to the output file once all the\ndata has been generated up front at standard python types.\n\nthe iterative generation of json items provided by `json-stream`\nallows the data to be written as it is produced.\n\n# future improvements\n\n* allow long strings in the json to be read as streams themselves\n* allow transient mode on seekable streams to seek to data earlier in\nthe stream instead of raising a `transientaccessexception`\n* a more efficient tokenizer?\n\n# alternatives\n\n## naya\n\n[naya](https://github.com/danielyule/naya) is a pure python json parser for\nparsing a simple json list as a stream.\n\n### why not naya?\n\n* it can only stream json containing a top-level list \n* it does not provide a pythonic `dict`/`list`-like interface \n\n## yajl-py\n\n[yajl-py](https://pykler.github.io/yajl-py/) is a wrapper around the c yajl json library that can be used to \ngenerate sax style events while parsing json.\n\n### why not yajl-py?\n\n* no pure python implementation\n* it does not provide a pythonic `dict`/`list`-like interface \n\n## jsonslicer\n\n[jsonslicer](https://github.com/amdmi3/jsonslicer) is another wrapper around the yajl c library with a\npath lookup based interface.\n\n### why not jsonslicer?\n\n* no pure python implementation\n* it does not provide a pythonic `dict`/`list`-like interface\n* must know all data paths lookup in advance (or make multiple passes)\n\n# contributing\n\nsee the project [contribution guide](https://github.com/daggaz/json-stream/blob/master/contributing.md).\n\n# donations\n\n[![paypal](https://www.paypalobjects.com/webstatic/mktg/logo/pp-logo-100px.png)](https://paypal.me/jcockburn307?country.x=gb&locale.x=en_gb)\n\nor\n\n[![\"buy me a coffee\"](https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png)](https://www.buymeacoffee.com/daggaz)\n\n# acknowledgements\n\nthe json tokenizer used in the project was taken from the\n[naya](https://github.com/danielyule/naya) project.\n",
  "docs_url": null,
  "keywords": "json,stream,decoder,encoder,parsing",
  "license": "copyright (c) 2020 jamie cockburn  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software. ",
  "name": "json-stream",
  "package_url": "https://pypi.org/project/json-stream/",
  "project_url": "https://pypi.org/project/json-stream/",
  "project_urls": {
    "Funding": "https://www.buymeacoffee.com/daggaz",
    "Homepage": "https://github.com/daggaz/json-stream",
    "Repository": "https://github.com/daggaz/json-stream",
    "Tracker": "https://github.com/daggaz/json-stream/issues"
  },
  "release_url": "https://pypi.org/project/json-stream/2.3.2/",
  "requires_dist": [
    "json-stream-rs-tokenizer (>=0.4.17)",
    "httpx ; extra == 'httpx'",
    "requests ; extra == 'requests'"
  ],
  "requires_python": "<4,>=3.5",
  "summary": "streaming json encoder and decoder",
  "version": "2.3.2",
  "releases": [],
  "developers": [
    "jamie_cockburn@hotmail.co.uk"
  ],
  "kwds": "json_stream jsonstreamencoder jsonencoder streamable_dict pyversions",
  "license_kwds": "copyright liable liability copies noninfringement",
  "libtype": "pypi",
  "id": "pypi_json_stream",
  "homepage": "",
  "release_count": 24,
  "dependency_ids": [
    "pypi_httpx",
    "pypi_json_stream_rs_tokenizer",
    "pypi_requests"
  ]
}