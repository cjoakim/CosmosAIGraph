{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "unidiff\n=======\n\nsimple python library to parse and interact with unified diff data.\n\n.. image:: https://www.travis-ci.com/matiasb/python-unidiff.svg?branch=master\n    :target: https://travis-ci.com/matiasb/python-unidiff\n\ninstalling unidiff\n------------------\n\n::\n\n    $ pip install unidiff\n\n\nquick start\n-----------\n\n::\n\n    >>> import urllib.request\n    >>> from unidiff import patchset\n    >>> diff = urllib.request.urlopen('https://github.com/matiasb/python-unidiff/pull/3.diff')\n    >>> encoding = diff.headers.get_charsets()[0]\n    >>> patch = patchset(diff, encoding=encoding)\n    >>> patch\n    <patchset: [<patchedfile: .gitignore>, <patchedfile: unidiff/patch.py>, <patchedfile: unidiff/utils.py>]>\n    >>> patch[0]\n    <patchedfile: .gitignore>\n    >>> patch[0].is_added_file\n    true\n    >>> patch[0].added\n    6\n    >>> patch[1]\n    <patchedfile: unidiff/patch.py>\n    >>> patch[1].added, patch[1].removed\n    (20, 11)\n    >>> len(patch[1])\n    6\n    >>> patch[1][2]\n    <hunk: @@ 109,14 110,21 @@ def __repr__(self):>\n    >>> patch[2]\n    <patchedfile: unidiff/utils.py>\n    >>> print(patch[2])\n    diff --git a/unidiff/utils.py b/unidiff/utils.py\n    index eae63e6..29c896a 100644\n    --- a/unidiff/utils.py\n    +++ b/unidiff/utils.py\n    @@ -37,4 +37,3 @@\n    # - deleted line\n    # \\ no newline case (ignore)\n    re_hunk_body_line = re.compile(r'^([- \\+\\\\])')\n    -\n\n\nload unified diff data by instantiating :code:`patchset` with a file-like object as\nargument, or using :code:`patchset.from_filename` class method to read diff from file.\n\na :code:`patchset` is a list of files updated by the given patch. for each :code:`patchedfile`\nyou can get stats (if it is a new, removed or modified file; the source/target\nlines; etc), besides having access to each hunk (also like a list) and its\nrespective info.\n\nat any point you can get the string representation of the current object, and\nthat will return the unified diff data of it.\n\nas a quick example of what can be done, check bin/unidiff file.\n\nalso, once installed, unidiff provides a command-line program that displays\ninformation from diff data (a file, or stdin). for example:\n\n::\n\n    $ git diff | unidiff\n    summary\n    -------\n    readme.md: +6 additions, -0 deletions\n\n    1 modified file(s), 0 added file(s), 0 removed file(s)\n    total: 6 addition(s), 0 deletion(s)\n\n\nload a local diff file\n----------------------\n\nto instantiate :code:`patchset` from a local file, you can use:\n\n::\n\n    >>> from unidiff import patchset\n    >>> patch = patchset.from_filename('tests/samples/bzr.diff', encoding='utf-8')\n    >>> patch\n    <patchset: [<patchedfile: added_file>, <patchedfile: modified_file>, <patchedfile: removed_file>]>\n\nnotice the (optional) :code:`encoding` parameter. if not specified, unicode input will be expected. or alternatively:\n\n::\n\n    >>> import codecs\n    >>> from unidiff import patchset\n    >>> with codecs.open('tests/samples/bzr.diff', 'r', encoding='utf-8') as diff:\n    ...     patch = patchset(diff)\n    ...\n    >>> patch\n    <patchset: [<patchedfile: added_file>, <patchedfile: modified_file>, <patchedfile: removed_file>]>\n\nfinally, you can also instantiate :code:`patchset` passing any iterable (and encoding, if needed):\n\n::\n\n    >>> from unidiff import patchset\n    >>> with open('tests/samples/bzr.diff', 'r') as diff:\n    ...     data = diff.readlines()\n    ...\n    >>> patch = patchset(data)\n    >>> patch\n    <patchset: [<patchedfile: added_file>, <patchedfile: modified_file>, <patchedfile: removed_file>]>\n\nif you don't need to be able to rebuild the original unified diff input, you can pass\n:code:`metadata_only=true` (defaults to :code:`false`), which should help making the\nparsing more efficient:\n\n::\n\n    >>> from unidiff import patchset\n    >>> patch = patchset.from_filename('tests/samples/bzr.diff', encoding='utf-8', metadata_only=true)\n\n\nreferences\n----------\n\n* http://en.wikipedia.org/wiki/diff_utility\n* http://www.artima.com/weblogs/viewpost.jsp?thread=164293\n",
  "docs_url": null,
  "keywords": "unified,diff,parse,metadata",
  "license": "mit",
  "name": "unidiff",
  "package_url": "https://pypi.org/project/unidiff/",
  "project_url": "https://pypi.org/project/unidiff/",
  "project_urls": {
    "Homepage": "http://github.com/matiasb/python-unidiff"
  },
  "release_url": "https://pypi.org/project/unidiff/0.7.5/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "unified diff parsing/metadata extraction library.",
  "version": "0.7.5",
  "releases": [],
  "developers": [
    "matias_bordese",
    "mbordese@gmail.com"
  ],
  "kwds": "diff_utility unidiff patchedfile urllib pip",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_unidiff",
  "homepage": "http://github.com/matiasb/python-unidiff",
  "release_count": 13,
  "dependency_ids": []
}