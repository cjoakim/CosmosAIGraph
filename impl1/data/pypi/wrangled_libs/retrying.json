{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "topic :: internet",
    "topic :: utilities"
  ],
  "description": "retrying\n=========================\nretrying is an apache 2.0 licensed general-purpose retrying library, written in\npython, to simplify the task of adding retry behavior to just about anything.\n\n\nthe simplest use case is retrying a flaky function whenever an exception occurs\nuntil a value is returned.\n\n.. code-block:: python\n\n    import random\n    from retrying import retry\n\n    @retry\n    def do_something_unreliable():\n        if random.randint(0, 10) > 1:\n            raise ioerror(\"broken sauce, everything is hosed!!!111one\")\n        else:\n            return \"awesome sauce!\"\n\n    print do_something_unreliable()\n\n\nfeatures\n--------\n\n- generic decorator api\n- specify stop condition (i.e. limit by number of attempts)\n- specify wait condition (i.e. exponential backoff sleeping between attempts)\n- customize retrying on exceptions\n- customize retrying on expected returned result\n\n\nexamples\n----------\n\nas you saw above, the default behavior is to retry forever without waiting.\n\n.. code-block:: python\n\n    @retry\n    def never_give_up_never_surrender():\n        print \"retry forever ignoring exceptions, don't wait between retries\"\n\n\nlet's be a little less persistent and set some boundaries, such as the number of attempts before giving up.\n\n.. code-block:: python\n\n    @retry(stop_max_attempt_number=7)\n    def stop_after_7_attempts():\n        print \"stopping after 7 attempts\"\n\nwe don't have all day, so let's set a boundary for how long we should be retrying stuff.\n\n.. code-block:: python\n\n    @retry(stop_max_delay=10000)\n    def stop_after_10_s():\n        print \"stopping after 10 seconds\"\n\nmost things don't like to be polled as fast as possible, so let's just wait 2 seconds between retries.\n\n.. code-block:: python\n\n    @retry(wait_fixed=2000)\n    def wait_2_s():\n        print \"wait 2 second between retries\"\n\n\nsome things perform best with a bit of randomness injected.\n\n.. code-block:: python\n\n    @retry(wait_random_min=1000, wait_random_max=2000)\n    def wait_random_1_to_2_s():\n        print \"randomly wait 1 to 2 seconds between retries\"\n\nthen again, it's hard to beat exponential backoff when retrying distributed services and other remote endpoints.\n\n.. code-block:: python\n\n    @retry(wait_exponential_multiplier=1000, wait_exponential_max=10000)\n    def wait_exponential_1000():\n        print \"wait 2^x * 1000 milliseconds between each retry, up to 10 seconds, then 10 seconds afterwards\"\n\n\nwe have a few options for dealing with retries that raise specific or general exceptions, as in the cases here.\n\n.. code-block:: python\n\n    def retry_if_io_error(exception):\n        \"\"\"return true if we should retry (in this case when it's an ioerror), false otherwise\"\"\"\n        return isinstance(exception, ioerror)\n\n    @retry(retry_on_exception=retry_if_io_error)\n    def might_io_error():\n        print \"retry forever with no wait if an ioerror occurs, raise any other errors\"\n\n    @retry(retry_on_exception=retry_if_io_error, wrap_exception=true)\n    def only_raise_retry_error_when_not_io_error():\n        print \"retry forever with no wait if an ioerror occurs, raise any other errors wrapped in retryerror\"\n\nwe can also use the result of the function to alter the behavior of retrying.\n\n.. code-block:: python\n\n    def retry_if_result_none(result):\n        \"\"\"return true if we should retry (in this case when result is none), false otherwise\"\"\"\n        return result is none\n\n    @retry(retry_on_result=retry_if_result_none)\n    def might_return_none():\n        print \"retry forever ignoring exceptions with no wait if return value is none\"\n\n\nany combination of stop, wait, etc. is also supported to give you the freedom to mix and match.\n\ncontribute\n----------\n\n#. check for open issues or open a fresh issue to start a discussion around a feature idea or a bug.\n#. fork `the repository`_ on github to start making your changes to the **master** branch (or branch off of it).\n#. write a test which shows that the bug was fixed or that the feature works as expected.\n#. send a pull request and bug the maintainer until it gets merged and published. :) make sure to add yourself to authors_.\n\n.. _`the repository`: http://github.com/groodt/retrying\n.. _authors: https://github.com/groodt/retrying/blob/master/authors.rst\n\n\n.. :changelog:\n\nhistory\n-------\n1.3.4 (2022-09-03)\n++++++++++++++++++\n- added greg roodt as maintainer\n- formatted code with black\n- updated repository references\n\n1.3.3 (2014-12-14)\n++++++++++++++++++\n- add minimum six version of 1.7.0 since anything less will break things\n\n1.3.2 (2014-11-09)\n++++++++++++++++++\n- ensure we wrap the decorated functions to prevent information loss\n- allow a jitter value to be passed in\n\n1.3.1 (2014-09-30)\n++++++++++++++++++\n- add requirements.txt to manifest.in to fix pip installs\n\n1.3.0 (2014-09-30)\n++++++++++++++++++\n- add upstream six dependency, remove embedded six functionality\n\n1.2.3 (2014-08-25)\n++++++++++++++++++\n- add support for custom wait and stop functions\n\n1.2.2 (2014-06-20)\n++++++++++++++++++\n- bug fix to not raise a retryerror on failure when exceptions aren't being wrapped\n\n1.2.1 (2014-05-05)\n++++++++++++++++++\n- bug fix for explicitly passing in a wait type\n\n1.2.0 (2014-05-04)\n++++++++++++++++++\n- remove the need for explicit specification of stop/wait types when they can be inferred\n- add a little checking for exception propagation\n\n1.1.0 (2014-03-31)\n++++++++++++++++++\n- added proper exception propagation through reraising with python 2.6, 2.7, and 3.2 compatibility\n- update test suite for behavior changes\n\n1.0.1 (2013-03-20)\n++++++++++++++++++\n- fixed a bug where classes not extending from the python exception hierarchy could slip through\n- update test suite for custom python exceptions\n\n1.0.0 (2013-01-21)\n++++++++++++++++++\n- first stable, tested version now exists\n- apache 2.0 license applied\n- sanitizing some setup.py and test suite running\n- added travis ci support\n",
  "docs_url": null,
  "keywords": "decorator decorators retry retrying exception exponential backoff",
  "license": "apache 2.0",
  "name": "retrying",
  "package_url": "https://pypi.org/project/retrying/",
  "project_url": "https://pypi.org/project/retrying/",
  "project_urls": {
    "Homepage": "https://github.com/groodt/retrying"
  },
  "release_url": "https://pypi.org/project/retrying/1.3.4/",
  "requires_dist": [
    "six (>=1.7.0)"
  ],
  "requires_python": "",
  "summary": "retrying",
  "version": "1.3.4",
  "releases": [],
  "developers": [
    "greg_roodt"
  ],
  "kwds": "retry_on_exception retry_if_result_none retry_on_result only_raise_retry_error_when_not_io_error retrying",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_retrying",
  "homepage": "https://github.com/groodt/retrying",
  "release_count": 12,
  "dependency_ids": [
    "pypi_six"
  ]
}