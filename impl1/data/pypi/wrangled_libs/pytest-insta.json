{
  "classifiers": [
    "framework :: pytest",
    "license :: osi approved :: mit license",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# pytest-insta\n\n![build status](https://github.com/vberlier/pytest-insta/workflows/ci/badge.svg)\n[![pypi](https://img.shields.io/pypi/v/pytest-insta.svg)](https://pypi.org/project/pytest-insta/)\n[![pypi - python version](https://img.shields.io/pypi/pyversions/pytest-insta.svg)](https://pypi.org/project/pytest-insta/)\n[![code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\n> a practical snapshot testing plugin for pytest.\n\n<img align=\"right\" width=\"50%\" src=\"https://raw.githubusercontent.com/vberlier/pytest-insta/main/demo.svg?sanitize=true\">\n\n```python\nassert snapshot() == \"awesome!\"\n```\n\n## introduction\n\nsnapshot testing makes it easy to monitor and approve changes by comparing the result of an operation against a previous reference value.\n\nthis project borrows from a lot of other implementations to provide a pythonic, batteries included snapshot testing solution. it also tries to feel as native to [`pytest`](https://docs.pytest.org/en/stable/) as possible with its integrated review tool.\n\n### features\n\n- expressive and familiar assertion syntax\n- can format text, binary, hexdump, json and pickle snapshots out-of-the-box\n- can be extended with custom snapshot formats\n- interactive review tool for inspecting and approving changes\n\n### credits\n\n- [`insta`](https://github.com/mitsuhiko/insta) (rust)\n\n  armin's work was the initial motivation for this project and inspired the reviewing workflow.\n\n- [`jest`](https://jestjs.io/docs/en/snapshot-testing) (javascript)\n\n  jest enabled the mass adoption of snapshot testing throughout the javascript ecosystem and now basically stands as the reference when it comes to what snapshot testing is supposed to look like.\n\n## installation\n\nthe package can be installed with `pip`.\n\n```bash\n$ pip install pytest-insta\n```\n\n## getting started\n\nthe `snapshot` fixture is a function that returns the current value of a snapshot.\n\n```python\ndef test_hello_world(snapshot):\n    assert snapshot() == \"hello\"\n```\n\n```bash\n$ pytest\n...\ncreate snapshots/<prefix>__hello_world__0.txt\n```\n\nrunning this test will create a new text file in the `snapshots` directory. the next time pytest runs, the test will load the snapshot and compare it to the actual value.\n\nthe return value of the `snapshot` function can be assigned to a variable and used multiple times.\n\n```python\ndef test_hello_world(snapshot):\n    expected = snapshot()\n    assert expected == \"hello\"\n    assert expected.upper() == \"hello\"\n```\n\nby default, each invocation of the `snapshot` function will generate its own snapshot.\n\n```python\ndef test_hello_world(snapshot):\n    assert snapshot() == \"hello\"\n    assert snapshot() == \"world\"\n```\n\n```bash\n$ pytest\n...\ncreate snapshots/<prefix>__hello_world__0.txt\ncreate snapshots/<prefix>__hello_world__1.txt\n```\n\nyou can also name snapshots explicitly. this makes it possible to load a snapshot multiple times during the same test.\n\n```python\ndef test_hello_world(snapshot):\n    assert snapshot(\"message.txt\") == \"hello\"\n    assert snapshot(\"message.txt\") == \"hello\"\n```\n\n```bash\n$ pytest\n...\ncreate snapshots/<prefix>__hello_world__message.txt\n```\n\n## snapshot formats\n\nby default, the `snapshot` fixture will store snapshots as `.txt` files. by providing a filename or just a specific file extension, you can create snapshots using various formats supported out-of-the-box.\n\n```python\ndef test_hello_world(snapshot):\n    assert snapshot(\"json\") == {\"hello\": \"world\"}\n    assert snapshot(\"expected.json\") == {\"hello\": \"world\"}\n```\n\n```bash\n$ pytest\n...\ncreate snapshots/<prefix>__hello_world__0.json\ncreate snapshots/<prefix>__hello_world__expected.json\n```\n\nnote that the plugin doesn't diff the snapshot files themselves but actually loads snapshots back into the interpreter and performs comparisons on live python objects. this makes it possible to use snapshot formats that aren't directly human-readable like pure binary files and pickle.\n\n| built-in formats | extension  | supported types                              |\n| ---------------- | ---------- | -------------------------------------------- |\n| plain text       | `.txt`     | `str`                                        |\n| binary           | `.bin`     | `bytes`                                      |\n| hexdump          | `.hexdump` | `bytes`                                      |\n| json             | `.json`    | any object serializable by the json module   |\n| pickle           | `.pickle`  | any object serializable by the pickle module |\n\nthe built-in formats should get you covered most of the time but you can also really easily implement your own snapshot formats.\n\n```python\nfrom dataclasses import dataclass\nfrom pathlib import path\n\nfrom pytest_insta import fmt\n\n@dataclass\nclass point:\n    x: int\n    y: int\n\nclass fmtpoint(fmt[point]):\n    extension = \".pt\"\n\n    def load(self, path: path) -> point:\n        return point(*map(int, path.read_text().split()))\n\n    def dump(self, path: path, value: point):\n        path.write_text(f\"{value.x} {value.y}\")\n\ndef test_hello_world(snapshot):\n    assert snapshot(\"pt\") == point(4, 2)\n```\n\nyou can create a custom formatter by inheriting from the `fmt` class and defining custom `load` and `dump` methods. the `extension` attribute associates the custom formatter to the specified file extension.\n\ncustom formatters can be defined anywhere in your test suite but it's recommended to keep them in `conftest.py` if they're meant to be used across multiple files.\n\n## command-line options\n\nthe plugin extends the `pytest` cli with a new `--insta` option that accommodates the snapshot-testing workflow. the option can be set to one of the following strategies:\n\n- `update` - record and update differing snapshots\n- `update-new` - record and create snapshots that don't already exist\n- `update-none` - don't record or update anything\n- `record` - record and save differing snapshots to be reviewed later\n- `review` - record and save differing snapshots then bring up the review tool\n- `review-only` - don't run tests and only bring up the review tool\n- `clear` - don't run tests and clear all the snapshots to review\n\nif the option is not specified, the strategy will default to `update-none` if `pytest` is running in a ci environment and `update-new` otherwise. this makes sure that your pipeline properly catches any snapshot you might forget to push while keeping the development experience seamless by automatically creating snapshots as you're writing tests.\n\nthe `record` option is useful if you're in the middle of something and your snapshots keep changing. differing snapshots won't cause tests to fail and will instead be recorded and saved.\n\n```bash\n$ pytest --insta record\n...\nrecord .pytest_cache/d/insta/<prefix>__hello_world__0.txt\n\nnotice 1 snapshot to review\n```\n\nwhen you're done making changes you can use the `review` option to bring up the review tool after running your tests. each differing snapshot will display a diff and let you inspect the new value and the old value in a python repl.\n\n```bash\n$ pytest --insta review\n...\n_____________________________ [1/1] _____________________________\n\nold: snapshots/example_hello_world__0.txt\nnew: .pytest_cache/d/insta/example_hello_world__0.txt\n\n>       assert old == new\ne       assert 'hello' == 'world'\ne         - world\ne         + hello\n\ntest_example.py:1: test_hello_world\n\na: accept, r: reject, s: skip\n>>>\n```\n\nfinally, the `update` option will let you update any differing snapshot according to the current test run, without going through the review tool.\n\n```bash\n$ pytest --insta update\n...\nupdate snapshots/<prefix>__hello_world__0.txt\n```\n\nit's worth mentioning that the updating, recording and reviewing strategies take into account any filter you might specify with the `-k` or `-m` options.\n\n## caveats\n\nthe `snapshot` fixture hijacks equality checks to record changes. this keeps assertions expressive and readable but introduces two caveats that you need to be aware of.\n\n- **right-sided snapshots \u274c**\n\n  if an object's `__eq__` method doesn't return `notimplemented` when its type doesn't match the compared object, the snapshot won't be able to record the updated value if it's placed on the right side of the comparison.\n\n  <details>\n  <summary>\n  explanation\n  </summary>\n\n  ***\n\n  strings return `notimplemented` when compared to non-string objects so the following test will behave as expected.\n\n  ```python\n  def test_bad(snapshot):\n      assert \"hello\" == snapshot()  # this works\n  ```\n\n  however, dataclasses return `false` when compared to objects of different types and won't let the snapshot record any changes when placed on the left-side of the comparison.\n\n  ```python\n  from dataclasses import dataclass\n  from pathlib import path\n\n  from pytest_insta import fmt\n\n  @dataclass\n  class point:\n      x: int\n      y: int\n\n  class fmtpoint(fmt[point]):\n      extension = \".pt\"\n\n      def load(self, path: path) -> point:\n          return point(*map(int, path.read_text().split()))\n\n      def dump(self, path: path, value: point):\n          path.write_text(f\"{value.x} {value.y}\")\n\n  def test_bad(snapshot):\n      assert point(4, 2) == snapshot(\"pt\")  # this doesn't work\n  ```\n\n  </details>\n\n  **recommendation \u2705**\n\n  to avoid confusion and keep things consistent, always put snapshots on the left-side of the comparison.\n\n  ```python\n  def test_good(snapshot):\n      assert snapshot() == \"hello\"\n  ```\n\n  ```python\n  def test_good(snapshot):\n      assert snapshot(\"pt\") == point(4, 2)\n  ```\n\n- **not comparing snapshots \u274c**\n\n  snapshots should first be compared to their actual value before being used in other expressions and assertions.\n\n  <details>\n  <summary>\n  explanation\n  </summary>\n\n  ***\n\n  the comparison records the current value if the snapshot doesn't exist yet. in the following example, the test will fail before the actual comparison and the snapshot will not be generated.\n\n  ```python\n  def test_bad(snapshot):\n      expected = snapshot()\n      assert expected.upper() == \"hello\"  # this doesn't work\n      assert expected == \"hello\"\n  ```\n\n  ```bash\n  $ pytest\n  ...\n  >       assert expected.upper() == \"hello\"\n  e       attributeerror: 'snapshotnotfound' object has no attribute 'upper'\n  ```\n\n  </details>\n\n  **recommendation \u2705**\n\n  always compare the snapshot to its actual value first and only perform additional operations afterwards.\n\n  ```python\n  def test_good(snapshot):\n      expected = snapshot()\n      assert expected == \"hello\"\n      assert expected.upper() == \"hello\"\n  ```\n\n## contributing\n\ncontributions are welcome. make sure to first open an issue discussing the problem or the new feature before creating a pull request. the project uses [`poetry`](https://python-poetry.org).\n\n```bash\n$ poetry install\n```\n\nyou can run the tests with `poetry run pytest`.\n\n```bash\n$ poetry run pytest\n```\n\nthe project must type-check with [`pyright`](https://github.com/microsoft/pyright). if you're using vscode the [`pylance`](https://marketplace.visualstudio.com/items?itemname=ms-python.vscode-pylance) extension should report diagnostics automatically. you can also install the type-checker locally with `npm install` and run it from the command-line.\n\n```bash\n$ npm run watch\n$ npm run check\n```\n\nthe code follows the [`black`](https://github.com/psf/black) code style. import statements are sorted with [`isort`](https://pycqa.github.io/isort/).\n\n```bash\n$ poetry run isort pytest_insta tests\n$ poetry run black pytest_insta tests\n$ poetry run black --check pytest_insta tests\n```\n\n---\n\nlicense - [mit](https://github.com/vberlier/pytest-insta/blob/master/license)\n\n",
  "docs_url": null,
  "keywords": "pytest-plugin,pytest,testing,snapshot,snapshot-testing",
  "license": "mit",
  "name": "pytest-insta",
  "package_url": "https://pypi.org/project/pytest-insta/",
  "project_url": "https://pypi.org/project/pytest-insta/",
  "project_urls": {
    "Documentation": "https://github.com/vberlier/pytest-insta",
    "Homepage": "https://github.com/vberlier/pytest-insta",
    "Repository": "https://github.com/vberlier/pytest-insta"
  },
  "release_url": "https://pypi.org/project/pytest-insta/0.2.0/",
  "requires_dist": [
    "pytest (>=7.2.0,<8.0.0)",
    "wrapt (>=1.14.1,<2.0.0)"
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "a practical snapshot testing plugin for pytest",
  "version": "0.2.0",
  "releases": [],
  "developers": [
    "berlier.v@gmail.com",
    "valentin_berlier"
  ],
  "kwds": "pytest_insta pytest pytest_cache pyversions pypi",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_pytest_insta",
  "homepage": "https://github.com/vberlier/pytest-insta",
  "release_count": 15,
  "dependency_ids": [
    "pypi_pytest",
    "pypi_wrapt"
  ]
}