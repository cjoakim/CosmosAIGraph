{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "\nopentracing api for python\n==========================\n\n|gitterchat| |buildstatus| |pypi| |readthedocs|\n\nthis library is a python platform api for opentracing.\n\nrequired reading\n----------------\n\nin order to understand the python platform api, one must first be familiar with\nthe `opentracing project <http://opentracing.io>`_ and\n`terminology <http://opentracing.io/documentation/pages/spec.html>`_ more\nspecifically.\n\nstatus\n------\n\nin the current version, ``opentracing-python`` provides only the api and a\nbasic no-op implementation that can be used by instrumentation libraries to\ncollect and propagate distributed tracing context.\n\nfuture versions will include a reference implementation utilizing an\nabstract recorder interface, as well as a\n`zipkin <http://openzipkin.github.io>`_-compatible tracer.\n\nusage\n-----\n\nthe work of instrumentation libraries generally consists of three steps:\n\n1. when a service receives a new request (over http or some other protocol),\n   it uses opentracing's inject/extract api to continue an active trace, creating a\n   span object in the process. if the request does not contain an active trace,\n   the service starts a new trace and a new *root* span.\n2. the service needs to store the current span in some request-local storage,\n   (called ``span`` *activation*) where it can be retrieved from when a child span must\n   be created, e.g. in case of the service making an rpc to another service.\n3. when making outbound calls to another service, the current span must be\n   retrieved from request-local storage, a child span must be created (e.g., by\n   using the ``start_child_span()`` helper), and that child span must be embedded\n   into the outbound request (e.g., using http headers) via opentracing's\n   inject/extract api.\n\nbelow are the code examples for the previously mentioned steps. implementation\nof request-local storage needed for step 2 is specific to the service and/or frameworks /\ninstrumentation libraries it is using, exposed as a ``scopemanager`` child contained\nas ``tracer.scope_manager``. see details below.\n\ninbound request\n^^^^^^^^^^^^^^^\n\nsomewhere in your server's request handler code:\n\n.. code-block:: python\n\n   def handle_request(request):\n       span = before_request(request, opentracing.global_tracer())\n       # store span in some request-local storage using tracer.scope_manager,\n       # using the returned `scope` as context manager to ensure\n       # `span` will be cleared and (in this case) `span.finish()` be called.\n       with tracer.scope_manager.activate(span, true) as scope:\n           # actual business logic\n           handle_request_for_real(request)\n\n\n   def before_request(request, tracer):\n       span_context = tracer.extract(\n           format=format.http_headers,\n           carrier=request.headers,\n       )\n       span = tracer.start_span(\n           operation_name=request.operation,\n           child_of=span_context)\n       span.set_tag('http.url', request.full_url)\n\n       remote_ip = request.remote_ip\n       if remote_ip:\n           span.set_tag(tags.peer_host_ipv4, remote_ip)\n\n       caller_name = request.caller_name\n       if caller_name:\n           span.set_tag(tags.peer_service, caller_name)\n\n       remote_port = request.remote_port\n       if remote_port:\n           span.set_tag(tags.peer_port, remote_port)\n\n       return span\n\noutbound request\n----------------\n\nsomewhere in your service that's about to make an outgoing call:\n\n.. code-block:: python\n\n   from opentracing import tags\n   from opentracing.propagation import format\n   from opentracing_instrumentation import request_context\n\n   # create and serialize a child span and use it as context manager\n   with before_http_request(\n       request=out_request,\n       current_span_extractor=request_context.get_current_span):\n\n       # actual call\n       return urllib2.urlopen(request)\n\n\n   def before_http_request(request, current_span_extractor):\n       op = request.operation\n       parent_span = current_span_extractor()\n       outbound_span = opentracing.global_tracer().start_span(\n           operation_name=op,\n           child_of=parent_span\n       )\n\n       outbound_span.set_tag('http.url', request.full_url)\n       service_name = request.service_name\n       host, port = request.host_port\n       if service_name:\n           outbound_span.set_tag(tags.peer_service, service_name)\n       if host:\n           outbound_span.set_tag(tags.peer_host_ipv4, host)\n       if port:\n           outbound_span.set_tag(tags.peer_port, port)\n\n       http_header_carrier = {}\n       opentracing.global_tracer().inject(\n           span_context=outbound_span,\n           format=format.http_headers,\n           carrier=http_header_carrier)\n\n       for key, value in http_header_carrier.iteritems():\n           request.add_header(key, value)\n\n       return outbound_span\n\nscope and within-process propagation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nfor getting/setting the current active ``span`` in the used request-local storage,\nopentracing requires that every ``tracer`` contains a ``scopemanager`` that grants\naccess to the active ``span`` through a ``scope``. any ``span`` may be transferred to\nanother task or thread, but not ``scope``.\n\n.. code-block:: python\n\n       # access to the active span is straightforward.\n       scope = tracer.scope_manager.active()\n       if scope is not none:\n           scope.span.set_tag('...', '...')\n\nthe common case starts a ``scope`` that's automatically registered for intra-process\npropagation via ``scopemanager``.\n\nnote that ``start_active_span('...')`` automatically finishes the span on ``scope.close()``\n(``start_active_span('...', finish_on_close=false)`` does not finish it, in contrast).\n\n.. code-block:: python\n\n       # manual activation of the span.\n       span = tracer.start_span(operation_name='somework')\n       with tracer.scope_manager.activate(span, true) as scope:\n           # do things.\n\n       # automatic activation of the span.\n       # finish_on_close is a required parameter.\n       with tracer.start_active_span('somework', finish_on_close=true) as scope:\n           # do things.\n\n       # handling done through a try construct:\n       span = tracer.start_span(operation_name='somework')\n       scope = tracer.scope_manager.activate(span, true)\n       try:\n           # do things.\n       except exception as e:\n           span.set_tag('error', '...')\n       finally:\n           scope.close()\n\n**if there is a scope, it will act as the parent to any newly started span** unless\nthe programmer passes ``ignore_active_span=true`` at ``start_span()``/``start_active_span()``\ntime or specified parent context explicitly:\n\n.. code-block:: python\n\n       scope = tracer.start_active_span('somework', ignore_active_span=true)\n\neach service/framework ought to provide a specific ``scopemanager`` implementation\nthat relies on their own request-local storage (thread-local storage, or coroutine-based storage\nfor asynchronous frameworks, for example).\n\nscope managers\n^^^^^^^^^^^^^^\n\nthis project includes a set of ``scopemanager`` implementations under the ``opentracing.scope_managers`` submodule, which can be imported on demand:\n\n.. code-block:: python\n\n   from opentracing.scope_managers import threadlocalscopemanager\n\nthere exist implementations for ``thread-local`` (the default instance of the submodule ``opentracing.scope_managers``), ``gevent``, ``tornado``, ``asyncio`` and ``contextvars``:\n\n.. code-block:: python\n\n   from opentracing.scope_managers.gevent import geventscopemanager # requires gevent\n   from opentracing.scope_managers.tornado import tornadoscopemanager # requires tornado<6\n   from opentracing.scope_managers.asyncio import asyncioscopemanager # fits for old asyncio applications, requires python 3.4 or newer.\n   from opentracing.scope_managers.contextvars import contextvarsscopemanager # for asyncio applications, requires python 3.7 or newer.\n\n\n**note** that for asyncio applications it's preferable to use ``contextvarsscopemanager`` instead of ``asyncioscopemanager`` because of automatic parent span propagation to children coroutines, tasks or scheduled callbacks.\n\n\ndevelopment\n-----------\n\ntests\n^^^^^\n\n.. code-block:: sh\n\n   virtualenv env\n   . ./env/bin/activate\n   make bootstrap\n   make test\n\nyou can use `tox <https://tox.readthedocs.io>`_ to run tests as well.\n\n.. code-block:: sh\n\n    tox\n\ntestbed suite\n^^^^^^^^^^^^^\n\na testbed suite designed to test api changes and experimental features is included under the *testbed* directory. for more information, see the `testbed readme <testbed/readme.md>`_.\n\ninstrumentation tests\n---------------------\n\nthis project has a working design of interfaces for the opentracing api. there is a mocktracer to\nfacilitate unit-testing of opentracing python instrumentation.\n\n.. code-block:: python\n\n       from opentracing.mocktracer import mocktracer\n\n       tracer = mocktracer()\n       with tracer.start_span('somework') as span:\n           pass\n\n       spans = tracer.finished_spans()\n       someworkspan = spans[0]\n\n\ndocumentation\n^^^^^^^^^^^^^\n\n.. code-block:: sh\n\n   virtualenv env\n   . ./env/bin/activate\n   make bootstrap\n   make docs\n\nthe documentation is written to *docs/_build/html*.\n\nlicense\n^^^^^^^\n\n`apache 2.0 license <./license>`__.\n\nreleases\n^^^^^^^^\n\nbefore new release, add a summary of changes since last version to changelog.rst\n\n.. code-block:: sh\n\n   pip install zest.releaser[recommended]\n   prerelease\n   release\n   git push origin master --follow-tags\n   python setup.py sdist upload -r pypi upload_docs -r pypi\n   postrelease\n   git push\n\n.. |gitterchat| image:: http://img.shields.io/badge/gitter-join%20chat%20%e2%86%92-brightgreen.svg\n   :target: https://gitter.im/opentracing/public\n.. |buildstatus| image:: https://travis-ci.org/opentracing/opentracing-python.svg?branch-master\n   :target: https://travis-ci.org/opentracing/opentracing-python\n.. |pypi| image:: https://badge.fury.io/py/opentracing.svg\n   :target: https://badge.fury.io/py/opentracing\n.. |readthedocs| image:: http://readthedocs.org/projects/opentracing-python/badge/?version=latest\n   :target: https://opentracing-python.readthedocs.io/en/latest/?badge=latest\n   :alt: documentation status\n",
  "docs_url": null,
  "keywords": "opentracing",
  "license": "apache license 2.0",
  "name": "opentracing",
  "package_url": "https://pypi.org/project/opentracing/",
  "project_url": "https://pypi.org/project/opentracing/",
  "project_urls": {
    "Homepage": "https://github.com/opentracing/opentracing-python"
  },
  "release_url": "https://pypi.org/project/opentracing/2.4.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "opentracing api for python. see documentation at http://opentracing.io",
  "version": "2.4.0",
  "releases": [],
  "developers": [
    "opentracing@googlegroups.com",
    "the_opentracing_authors"
  ],
  "kwds": "opentracing_instrumentation opentracing python tracing openzipkin",
  "license_kwds": "apache license 2.0",
  "libtype": "pypi",
  "id": "pypi_opentracing",
  "homepage": "https://github.com/opentracing/opentracing-python",
  "release_count": 24,
  "dependency_ids": []
}