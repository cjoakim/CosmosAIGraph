{
  "classifiers": [],
  "description": "overview\n--------\n*waiting* is a small library for waiting for stuff to happen. it basically waits for a function to return **true**, in various modes.\n\n*waiting* is compatible with `flux <http://flux.readthedocs.org>`_ for simulated timelines.\n\nusage\n-----\n\nthe most basic usage is when you have a function you want to wait for::\n\n >>> predicate = lambda : true\n\nwaiting forever is very simple::\n\n >>> from waiting import wait, timeoutexpired\n >>> wait(predicate)\n true\n\nif your predicate returns a value, it will be returned as the result of wait()::\n\n >>> result = object()\n >>> wait(lambda: result) is result\n true\n\na *timeout* parameter can also be specified::\n\n >>> wait(predicate, timeout_seconds=10.5)\n true\n\nwhen a timeout expires without the predicate being fullfilled, an exception is thrown::\n\n\n >>> try:\n ...     wait(lambda : false, timeout_seconds=0)\n ... except timeoutexpired:\n ...     # expired!\n ...     pass\n ... else:\n ...     assert false\n\n\nsleeping polls the predicate at a certain interval (by default 1 second). the interval can be changed with the *sleep_seconds* argument::\n\n >>> wait(predicate, sleep_seconds=20)\n true\n\nwhen waiting for multiple predicates, *waiting* provides two simple facilities to help aggregate them: **any** and **all**. they resemble python's built-in *any()* and *all()*, except that they don't call a predicate once it has been satisfied (this is useful when the predicates are inefficient and take time to complete)::\n\n >>> from waiting import wait, any, all\n >>> wait(any([predicate, predicate]))\n true\n >>> wait(all([predicate, predicate]))\n true\n\ntimeoutexpired exceptions, by default, don't tell you much about what didn't happen that you were expecting. to fix that, use the *waiting_for* argument::\n\n >>> try:\n ...     wait(lambda : false, timeout_seconds=0, waiting_for=\"something that will never happen\") #doctest: +ellipsis\n ... except timeoutexpired as e:\n ...     print(e)\n timeout of 0 seconds expired waiting for something that will never happen\n\nexponential backoff is supported for the sleep interval::\n\n >>> from waiting import wait\n >>> wait(predicate, sleep_seconds=(1, 100)) # sleep 1, 2, 4, 8, 16, 32, 64, 100, 100, ....\n true\n >>> wait(predicate, sleep_seconds=(1, 100, 3)) # sleep 1, 3, 9, 27, 81, 100, 100, 100 ....\n true\n >>> wait(predicate, sleep_seconds=(1, none)) # sleep 1, 2, 4, 6, .... (infinity)\n true\n >>> wait(predicate, sleep_seconds=(1, none, 4)) # sleep 1, 4, 16, 64, ... (infinity)\n true\n\nif your predicate might raise certain exceptions you wish to ignore, you may use ``expected_exceptions`` to ignore them::\n\n >>> from waiting import wait\n >>> wait(predicate, expected_exceptions=valueerror)\n true\n >>> wait(predicate, expected_exceptions=(valueerror, attributeerror))\n true\n\nif you'd like to maintain updates while waiting for a predicate to complete, you may use ``on_poll`` to pass a function to perform some behavior after every sleep. by default, this is a no-op.\n\n >>> import logging\n >>> from waiting import wait\n >>> try:\n ...    wait(lambda: false, timeout_seconds=5,               # timeout after 5 seconds\n ...          on_poll=lambda: logging.warn(\"waiting...\")) # log \"waiting...\" six times.\n ... except timeoutexpired:\n ...    pass\n ... else:\n ...    assert false\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "waiting",
  "package_url": "https://pypi.org/project/waiting/",
  "project_url": "https://pypi.org/project/waiting/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/waiting/1.4.1/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "utility for waiting for stuff to happen",
  "version": "1.4.1",
  "releases": [],
  "developers": [
    "rotem_yaari",
    "vmalloc@gmail.com"
  ],
  "kwds": "waits flux waiting_for timeoutexpired timeout_seconds",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_waiting",
  "homepage": "",
  "release_count": 15,
  "dependency_ids": []
}