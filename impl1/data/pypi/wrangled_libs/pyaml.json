{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: public domain",
    "programming language :: python",
    "programming language :: python :: 3.8",
    "topic :: software development",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "pretty-yaml (or pyaml)\n======================\n\npyyaml_-based python module to produce a bit more pretty and human-readable yaml-serialized data.\n\nthis module is for serialization only, see `ruamel.yaml`_ module for literate\nyaml parsing (keeping track of comments, spacing, line/column numbers of values, etc).\n\n(side-note: to dump stuff parsed by ruamel.yaml with this module, use only ``yaml(typ='safe')`` there)\n\nit's a small module, and for projects that only need part of its functionality,\ni'd recommend copy-pasting that in, instead of adding janky dependency.\n\n.. _pyyaml: http://pyyaml.org/\n.. _ruamel.yaml: https://bitbucket.org/ruamel/yaml/\n\n.. contents::\n  :backlinks: none\n\nrepository urls:\n\n- https://github.com/mk-fg/pretty-yaml\n- https://codeberg.org/mk-fg/pretty-yaml\n- https://fraggod.net/code/git/pretty-yaml\n\n\nwarning\n-------\n\nprime goal of this module is to produce human-readable output that can be\neasily diff'ed, manipulated and re-used, but maybe with occasional issues.\n\nso please do not rely on the thing to produce output that can always be\ndeserialized exactly to what was exported, at least - use pyyaml directly\nfor that (but maybe with options from the next section).\n\n\nwhat this module does and why\n-----------------------------\n\nyaml is generally nice and easy format to read *if* it was written by humans.\n\npyyaml can a do fairly decent job of making stuff readable, and the best\ncombination of parameters for such output that i've seen so far is probably this one::\n\n  >>> m = [123, 45.67, {1: none, 2: false}, 'some text']\n  >>> data = dict(a='asldnsa\\nasldp\u00e1knsa\\n', b='whatever text', ma=m, mb=m)\n  >>> yaml.safe_dump( data, sys.stdout,\n    width=100, allow_unicode=true, default_flow_style=false )\n  a: 'asldnsa\n\n    asldp\u00e1knsa\n\n    '\n  b: whatever text\n  ma: &id001\n  - 123\n  - 45.67\n  - 1: null\n    2: false\n  - some text\n  mb: *id001\n\npyaml (this module) tries to improve on that a bit, with the following tweaks:\n\n* most human-friendly representation options in pyyaml (that i know of)\n  are used as defaults - unicode, flow-style, width=100 (old default is 80).\n\n* dump \"null\" values as empty values, if possible, which have the same meaning\n  but reduce visual clutter and are easier to edit.\n\n* dicts, sets, ordereddicts, defaultdicts, namedtuples, enums, dataclasses, etc\n  are represented as their safe yaml-compatible base (like int, list or mapping),\n  with mappings key-sorted by default for more diff-friendly output.\n\n* use shorter and simplier yes/no for booleans.\n\n* list items get indented, as they should be.\n\n* attempt is made to pick more readable string representation styles, depending\n  on the value, e.g.::\n\n    >>> yaml.safe_dump(cert, sys.stdout)\n    cert: '-----begin certificate-----\n\n      miih3jccbcagawibagijaji7ajq4z87oma0gcsqgsib3dqebcwuamihbmrcwfqyd\n\n      vqqkfa52ywxlcm9ulm5vx2lzcdeembwga1uecxmvq2vydglmawnhdgugqxv0ag9y\n    ...\n\n    >>> pyaml.p(cert):\n    cert: |\n      -----begin certificate-----\n      miih3jccbcagawibagijaji7ajq4z87oma0gcsqgsib3dqebcwuamihbmrcwfqyd\n      vqqkfa52ywxlcm9ulm5vx2lzcdeembwga1uecxmvq2vydglmawnhdgugqxv0ag9y\n    ...\n\n* \"force_embed\" option (default=yes) to avoid having &id stuff scattered all\n  over the output. might be more useful to disable it in some specific cases though.\n\n* \"&idxyz\" anchors, when needed, get labels from the keys they get attached to,\n  not just meaningless enumerators, e.g. \"&users_-_admin\" instead.\n\n* \"string_val_style\" option to only apply to strings that are values, not keys,\n  i.e::\n\n    >>> pyaml.p(data, string_val_style='\"')\n    key: \"value\\nasldp\u00e1knsa\\n\"\n    >>> yaml.safe_dump(data, sys.stdout, allow_unicode=true, default_style='\"')\n    \"key\": \"value\\nasldp\u00e1knsa\\n\"\n\n* add vertical spacing (empty lines) between keys on different depths,\n  to separate long yaml sections in the output visually, make it more seekable.\n\n* discard end-of-document \"...\" indicators for simple values.\n\nresult for the (rather meaningless) example above::\n\n  >>> pyaml.p(data, force_embed=false, vspacing=dict(split_lines=10))\n\n  a: |\n    asldnsa\n    asldp\u00e1knsa\n\n  b: whatever text\n\n  ma: &ma\n    - 123\n    - 45.67\n    - 1:\n      2: no\n    - some text\n\n  mb: *ma\n\n(force_embed=false enabled deduplication with ``&ma`` anchor,\nvspacing is adjusted to split even this tiny output)\n\n----------\n\nextended example::\n\n  >>> pyaml.dump(data, vspacing=dict(split_lines=10))\n\n  destination:\n\n    encoding:\n      xz:\n        enabled: yes\n        min_size: 5120\n        options:\n        path_filter:\n          - \\.(gz|bz2|t[gb]z2?|xz|lzma|7z|zip|rar)$\n          - \\.(rpm|deb|iso)$\n          - \\.(jpe?g|gif|png|mov|avi|ogg|mkv|webm|mp[34g]|flv|flac|ape|pdf|djvu)$\n          - \\.(sqlite3?|fossil|fsl)$\n          - \\.git/objects/[0-9a-f]+/[0-9a-f]+$\n\n    result:\n      append_to_file:\n      append_to_lafs_dir:\n      print_to_stdout: yes\n\n    url: http://localhost:3456/uri\n\n  filter:\n    - /(cvs|rcs|sccs|_darcs|\\{arch\\})/$\n    - /\\.(git|hg|bzr|svn|cvs)(/|ignore|attributes|tags)?$\n    - /=(release-id|meta-update|update)$\n\n  http:\n    ca_certs_files: /etc/ssl/certs/ca-certificates.crt\n    debug_requests: no\n    request_pool_options:\n      cachedconnectiontimeout: 600\n      maxpersistentperhost: 10\n      retryautomatically: yes\n\n  logging:\n\n    formatters:\n      basic:\n        datefmt: '%y-%m-%d %h:%m:%s'\n        format: '%(asctime)s :: %(name)s :: %(levelname)s: %(message)s'\n\n    handlers:\n      console:\n        class: logging.streamhandler\n        formatter: basic\n        level: custom\n        stream: ext://sys.stderr\n\n    loggers:\n      twisted:\n        handlers:\n          - console\n        level: 0\n\n    root:\n      handlers:\n        - console\n      level: custom\n\nnote that unless there are many moderately wide and deep trees of data,\nwhich are expected to be read and edited by people, it might be preferrable\nto directly use pyyaml regardless, as it won't introduce another\n(rather pointless in that case) dependency and a point of failure.\n\n\nfeatures and tricks\n-------------------\n\n* pretty-print any yaml or json (yaml subset) file from the shell::\n\n    % python -m pyaml /path/to/some/file.yaml\n    % pyaml < myfile.yml\n    % curl -s https://www.githubstatus.com/api/v2/summary.json | pyaml\n\n  ``pipx install pyaml`` can be a good way to only install \"pyaml\" command-line script.\n\n* process and replace json/yaml file in-place::\n\n    % python -m pyaml -r mydata.yml\n\n* easier \"debug printf\" for more complex data (all funcs below are aliases to same thing)::\n\n    pyaml.p(stuff)\n    pyaml.pprint(my_data)\n    pyaml.pprint('----- how does that breaks!?!?', input_data, some_var, more_stuff)\n    pyaml.print(data, file=sys.stderr) # needs \"from __future__ import print_function\"\n\n* force all string values to a certain style (see info on these in `pyyaml docs`_)::\n\n    pyaml.dump(many_weird_strings, string_val_style='|')\n    pyaml.dump(multiline_words, string_val_style='>')\n    pyaml.dump(no_want_quotes, string_val_style='plain')\n\n  using ``pyaml.add_representer()`` (note \\*p\\*yaml) as suggested in\n  `this so thread`_ (or `github-issue-7`_) should also work.\n\n  see also this `amazing reply to stackoverflow#3790454`_ for everything about\n  the many different string styles in yaml.\n\n* control indent and width of the results::\n\n    pyaml.dump(wide_and_deep, indent=4, width=120)\n\n  these are actually keywords for pyyaml emitter (passed to it from dumper),\n  see more info on these in `pyyaml docs`_.\n\n* dump multiple yaml documents into a file: ``pyaml.dump_all([data1, data2, data3], dst_file)``\n\n  explicit_start=true is implied, unless overidden by explicit_start=false.\n\n* control thresholds for vertical spacing of values (0 = always space stuff out),\n  and clump all oneliner ones at the top::\n\n    >>> pyaml.dump( data,\n      sort_dicts=pyaml.pyamlsort.oneline_group,\n      vspacing=dict(split_lines=0, split_count=0) )\n\n    chart:\n      axiscenteredzero: no\n      axiscolormode: text\n      axislabel: ''\n      axisplacement: auto\n      baralignment: 0\n      drawstyle: line\n      ...\n\n      hidefrom:\n        legend: no\n        tooltip: no\n        viz: no\n\n      scaledistribution:\n        type: linear\n\n      stacking:\n        group: a\n        mode: none\n\n  or same thing with cli tool ``-v/--vspacing`` option: ``pyaml -v 0/0g mydata.yaml``\n\n.. _pyyaml docs: http://pyyaml.org/wiki/pyyamldocumentation#scalars\n.. _this so thread: http://stackoverflow.com/a/7445560\n.. _github-issue-7: https://github.com/mk-fg/pretty-yaml/issues/7\n.. _amazing reply to stackoverflow#3790454:\n  https://stackoverflow.com/questions/3790454/how-do-i-break-a-string-in-yaml-over-multiple-lines/21699210#21699210\n\n\ninstallation\n------------\n\nit's a regular python 3.8+ module/package, published on pypi (as pyaml_).\n\nmodule uses pyyaml_ for processing of the actual yaml files\nand should pull it in as a dependency.\n\ndependency on unidecode_ module is optional and should only be necessary\nwith force_embed=false keyword, and same-id objects or recursion is used\nwithin serialized data.\n\nusing pip_ is how you generally install it, usually coupled with venv_ usage\n(which will also provide \"pip\" tool itself)::\n\n  % pip install pyaml\n\ncurrent-git version can be installed like this::\n\n  % pip install git+https://github.com/mk-fg/pretty-yaml\n\npip will default to installing into currently-active venv, then user's home\ndirectory (under ``~/.local/lib/python...``), and maybe system-wide when running\nas root (only useful in specialized environments like docker containers).\n\nthere are many other python packaging tools - pipenv_, poetry_, pdm_, etc -\nuse whatever is most suitable for specific project/environment.\npipx_ can be used to install command-line script without a module.\n\nmore general info on python packaging can be found at `packaging.python.org`_.\n\nwhen changing code, unit tests can be run with ``python -m unittest``\nfrom the local repository checkout.\n\n.. _pyaml: https://pypi.org/project/pyaml/\n.. _unidecode: https://pypi.python.org/pypi/unidecode\n.. _pip: https://pip.pypa.io/en/stable/\n.. _venv: https://docs.python.org/3/library/venv.html\n.. _poetry: https://python-poetry.org/\n.. _pipenv: https://pipenv.pypa.io/\n.. _pdm: https://pdm.fming.dev/\n.. _pipx: https://pypa.github.io/pipx/\n.. _packaging.python.org: https://packaging.python.org/installing/\n",
  "docs_url": null,
  "keywords": "yaml,serialization,pretty-print,formatter,human,readability",
  "license": "wtfpl",
  "name": "pyaml",
  "package_url": "https://pypi.org/project/pyaml/",
  "project_url": "https://pypi.org/project/pyaml/",
  "project_urls": {
    "Homepage": "https://github.com/mk-fg/pretty-yaml"
  },
  "release_url": "https://pypi.org/project/pyaml/23.9.7/",
  "requires_dist": [
    "PyYAML",
    "unidecode ; extra == 'anchors'"
  ],
  "requires_python": ">=3.8",
  "summary": "pyyaml-based module to produce a bit more pretty and readable yaml-serialized data",
  "version": "23.9.7",
  "releases": [],
  "developers": [
    "mike_kazantsev",
    "mk.fraggod@gmail.com"
  ],
  "kwds": "yaml pyyamldocumentation pyyaml _pyyaml pyyaml_",
  "license_kwds": "wtfpl",
  "libtype": "pypi",
  "id": "pypi_pyaml",
  "homepage": "https://github.com/mk-fg/pretty-yaml",
  "release_count": 71,
  "dependency_ids": [
    "pypi_pyyaml",
    "pypi_unidecode"
  ]
}