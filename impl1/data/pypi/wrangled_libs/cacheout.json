{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: database",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules",
    "topic :: utilities"
  ],
  "description": "cacheout\n********\n\n|version| |build| |coveralls| |license|\n\n\na caching library for python.\n\n\nlinks\n=====\n\n- project: https://github.com/dgilland/cacheout\n- documentation: https://cacheout.readthedocs.io\n- pypi: https://pypi.python.org/pypi/cacheout/\n- github actions: https://github.com/dgilland/cacheout/actions\n\n\nfeatures\n========\n\n- in-memory caching using dictionary backend\n- cache manager for easily accessing multiple cache objects\n- reconfigurable cache settings for runtime setup when using module-level cache objects\n- maximum cache size enforcement\n- default cache ttl (time-to-live) as well as custom ttls per cache entry\n- bulk set, get, and delete operations\n- bulk get and delete operations filtered by string, regex, or function\n- memoization decorators\n- thread safe\n- multiple cache implementations:\n\n  - fifo (first in, first out)\n  - lifo (last in, first out)\n  - lru (least recently used)\n  - mru (most recently used)\n  - lfu (least frequently used)\n  - rr (random replacement)\n\n\nroadmap\n=======\n\n- layered caching (multi-level caching)\n\n\nrequirements\n============\n\n- python >= 3.7\n\n\nquickstart\n==========\n\ninstall using pip:\n\n\n::\n\n    pip install cacheout\n\n\nlet's start with some basic caching by creating a cache object:\n\n.. code-block:: python\n\n    from cacheout import cache\n\n    cache = cache()\n\n\nby default the ``cache`` object will have a maximum size of ``256``, default ttl (time-to-live) expiration turned off, ttl timer that uses ``time.time`` (meaning ttl is in seconds), and the default for missing keys as ``none``. these values can be set with:\n\n.. code-block:: python\n\n    cache = cache(maxsize=256, ttl=0, timer=time.time, default=none)  # defaults\n\n\nset a cache key using ``cache.set()``:\n\n.. code-block:: python\n\n    cache.set(1, 'foobar')\n\n\nget the value of a cache key with ``cache.get()``:\n\n.. code-block:: python\n\n    assert cache.get(1) == 'foobar'\n\n\nget a default value when cache key isn't set:\n\n.. code-block:: python\n\n    assert cache.get(2) is none\n    assert cache.get(2, default=false) is false\n    assert 2 not in cache\n\n\nprovide cache values using a default callable:\n\n.. code-block:: python\n\n    assert 2 not in cache\n    assert cache.get(2, default=lambda key: key) == 2\n    assert cache.get(2) == 2\n    assert 2 in cache\n\n\nprovide a global default:\n\n.. code-block:: python\n\n    cache2 = cache(default=true)\n    assert cache2.get('missing') is true\n    assert 'missing' not in cache2\n\n    cache3 = cache(default=lambda key: key)\n    assert cache3.get('missing') == 'missing'\n    assert 'missing' in cache3\n\n\nset the ttl (time-to-live) expiration per entry (default ttl units are in seconds when ``cache.timer`` is set to the default ``time.time``; otherwise, the units are determined by the custom timer function):\n\n.. code-block:: python\n\n    cache.set(3, {'data': {}}, ttl=1)\n    assert cache.get(3) == {'data': {}}\n    time.sleep(1)\n    assert cache.get(3) is none\n\n\nmemoize a function where cache keys are generated from the called function parameters:\n\n.. code-block:: python\n\n    @cache.memoize()\n    def func(a, b):\n        pass\n\n\nprovide a ttl for the memoized function and incorporate argument types into generated cache keys:\n\n.. code-block:: python\n\n    @cache.memoize(ttl=5, typed=true)\n    def func(a, b):\n        pass\n\n    # func(1, 2) has different cache key than func(1.0, 2.0), whereas,\n    # with \"typed=false\" (the default), they would have the same key\n\n\naccess the original memoized function:\n\n.. code-block:: python\n\n    @cache.memoize()\n    def func(a, b):\n        pass\n\n    func.uncached(1, 2)\n\n\nget a copy of the entire cache with ``cache.copy()``:\n\n.. code-block:: python\n\n    assert cache.copy() == {1: 'foobar', 2: ('foo', 'bar', 'baz')}\n\n\ndelete a cache key with ``cache.delete()``:\n\n.. code-block:: python\n\n    cache.delete(1)\n    assert cache.get(1) is none\n\n\nclear the entire cache with ``cache.clear()``:\n\n.. code-block:: python\n\n    cache.clear()\n    assert len(cache) == 0\n\n\nperform bulk operations with ``cache.set_many()``, ``cache.get_many()``, and ``cache.delete_many()``:\n\n.. code-block:: python\n\n    cache.set_many({'a': 1, 'b': 2, 'c': 3})\n    assert cache.get_many(['a', 'b', 'c']) == {'a': 1, 'b': 2, 'c': 3}\n    cache.delete_many(['a', 'b', 'c'])\n    assert cache.count() == 0\n\n\nuse complex filtering in ``cache.get_many()`` and ``cache.delete_many()``:\n\n.. code-block:: python\n\n    import re\n    cache.set_many({'a_1': 1, 'a_2': 2, '123': 3, 'b': 4})\n\n    cache.get_many('a_*') == {'a_1': 1, 'a_2': 2}\n    cache.get_many(re.compile(r'\\d')) == {'123': 3}\n    cache.get_many(lambda key: '2' in key) == {'a_2': 2, '123': 3}\n\n    cache.delete_many('a_*')\n    assert dict(cache.items()) == {'123': 3, 'b': 4}\n\n\nreconfigure the cache object after creation with ``cache.configure()``:\n\n.. code-block:: python\n\n    cache.configure(maxsize=1000, ttl=5 * 60)\n\n\nget keys, values, and items from the cache with ``cache.keys()``, ``cache.values()``, and ``cache.items()``:\n\n.. code-block:: python\n\n    cache.set_many({'a': 1, 'b': 2, 'c': 3})\n    assert list(cache.keys()) == ['a', 'b', 'c']\n    assert list(cache.values()) == [1, 2, 3]\n    assert list(cache.items()) == [('a', 1), ('b', 2), ('c', 3)]\n\n\niterate over cache keys:\n\n.. code-block:: python\n\n    for key in cache:\n        print(key, cache.get(key))\n        # 'a' 1\n        # 'b' 2\n        # 'c' 3\n\n\ncheck if key exists with ``cache.has()`` and ``key in cache``:\n\n.. code-block:: python\n\n    assert cache.has('a')\n    assert 'a' in cache\n\n\nuse callbacks to be notified of on-get, on-set, and on-delete events:\n\n.. code-block:: python\n\n    def on_get(key, value, exists):\n        pass\n\n    def on_set(key, new_value, old_value):\n        pass\n\n    def on_delete(key, value, cause):\n        pass\n\n\nenable cache statistics:\n\n.. code-block:: python\n\n    cache_with_stats = cache(enable_stats=true)\n\n    # or via configure()\n    cache.configure(enable_stats=true)\n\n    # or directly via cache.stats\n    cache.stats.enable()\n\n\nget cache statistics:\n\n.. code-block:: python\n\n    print(cache.stats.info())\n\n\nmanage tracking of statistics:\n\n.. code-block:: python\n\n    # pause tracking (collected stats will not be affected)\n    cache.stats.pause()\n\n    # resume tracking\n    cache.stats.resume()\n\n    # reset stats\n    cache.stats.reset()\n\n    # disable stats (warning: this resets stats)\n    cache.stats.disable()\n\n    # disable via configure() (warning: this resets stats)\n    cache.configure(enable_stats=false)\n\n\nmanage multiple caches using ``cachemanager``:\n\n.. code-block:: python\n\n    from cacheout import cachemanager\n\n    cacheman = cachemanager({'a': {'maxsize': 100},\n                             'b': {'maxsize': 200, 'ttl': 900},\n                             'c': {})\n\n    cacheman['a'].set('key1', 'value1')\n    value = cacheman['a'].get('key')\n\n    cacheman['b'].set('key2', 'value2')\n    assert cacheman['b'].maxsize == 200\n    assert cacheman['b'].ttl == 900\n\n    cacheman['c'].set('key3', 'value3')\n\n    cacheman.clear_all()\n    for name, cache in cacheman:\n        assert name in cacheman\n        assert len(cache) == 0\n\n\nfor more details, see the full documentation at https://cacheout.readthedocs.io.\n\n\n\n.. |version| image:: https://img.shields.io/pypi/v/cacheout.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/cacheout/\n\n.. |build| image:: https://img.shields.io/github/actions/workflow/status/dgilland/cacheout/main.yml?branch=master&style=flat-square\n    :target: https://github.com/dgilland/cacheout/actions\n\n.. |coveralls| image:: https://img.shields.io/coveralls/dgilland/cacheout/master.svg?style=flat-square\n    :target: https://coveralls.io/r/dgilland/cacheout\n\n.. |license| image:: https://img.shields.io/pypi/l/cacheout.svg?style=flat-square\n    :target: https://pypi.python.org/pypi/cacheout/\n\nchangelog\n=========\n\n\nv0.16.0 (2023-12-22)\n--------------------\n\n- add ``cache.on_get`` callback hook. thanks uncle-lv_!\n- add ``cache.on_set`` callback hook. thanks uncle-lv_!\n\n\nv0.15.0 (2023-11-03)\n--------------------\n\n- add cache statistics. thanks uncle-lv_!\n- add ``cache.get_ttl``. thanks uncle-lv_!\n- add ``cache.on_delete`` callback hook. thanks uncle-lv_!\n- add support for python 3.11 and 3.12.\n\n\nv0.14.1 (2022-08-16)\n--------------------\n\n- set minimum python version to 3.7 in setup.cfg.\n\n\nv0.14.0 (2022-08-16)\n--------------------\n\n- add support for python 3.10.\n- drop support for python 3.6. minimum supported version is 3.7.\n- clarify docs around ttl to make it explicit what time units it uses by default.\n\n\nv0.13.1 (2021-04-28)\n--------------------\n\n- minor optimization in ``cache.get_many|delete_many``.\n\n\nv0.13.0 (2021-04-27)\n--------------------\n\n- add ``cache_key`` attribute to memoized functions that can be used to generate the cache key used for a given set of function arguments. thanks johnbergvall_!\n- fix bug in ``cache.full`` that would result in an exception if cache created with ``maxsize=none`` like ``cache(maxsize=none)``. thanks allinolcp_!\n- fix bug in ``cache.get_many`` that resulted in ``runtimeerror: ordereddict mutated during iteration`` when cache keys expire during the ``get_many`` call.\n- remove ``default`` argument from ``cache.get_many``. a default value on missing cache key was only ever returned if a list of keys was passed in and those keys happened to expire during the ``get_many`` call. **breaking change**\n\n\nv0.12.1 (2021-04-19)\n--------------------\n\n- fix regression in ``0.12.0`` that resulted in missing docstrings for some methods of ``lfucache`` and ``lrucache``.\n\n\nv0.12.0 (2021-04-19)\n--------------------\n\n- fix bug in ``cache.__contains__`` where it would return ``true`` for an expired key.\n- add type annotations.\n- add official support for python 3.8 and 3.9.\n- drop support for python 3.4 and 3.5.\n\n\nv0.11.2 (2019-09-30)\n--------------------\n\n- fix bug in ``lfucache`` that would result cache growing beyond ``maxsize`` limit.\n\n\nv0.11.1 (2019-01-09)\n--------------------\n\n- fix issue with asyncio support in memoization decorators that caused a ``runtimeerror: await wasn't used with future`` when certain types of async functions were used inside the memoized function.\n\n\nv0.11.0 (2018-10-19)\n--------------------\n\n- add asyncio support to memoization decorators so they can decorate coroutines.\n\n\nv0.10.3 (2018-08-01)\n--------------------\n\n- expose ``typed`` argument of underlying ``*cache.memoize()`` in ``memoize()`` and ``*_memoize()`` decorators.\n\n\nv0.10.2 (2018-07-31)\n--------------------\n\n- fix bug in ``lrucache.get()`` where supplying a ``default`` value would result in a ``keyerror``.\n\n\nv0.10.1 (2018-07-15)\n--------------------\n\n- support python 3.7.\n\n\nv0.10.0 (2018-04-03)\n--------------------\n\n- modify behavior of ``default`` argument to ``cache.get()`` so that if ``default`` is a callable and the cache key is missing, then it will be called and its return value will be used as the value for cache key and subsequently be set as the value for the key in the cache. (**breaking change**)\n- add ``default`` argument to ``cache()`` that can be used to override the value for ``default`` in ``cache.get()``.\n\n\nv0.9.0 (2018-03-31)\n-------------------\n\n- merge functionality of ``cache.get_many_by()`` into ``cache.get_many()`` and remove ``cache.get_many_by()``. (**breaking change**).\n- merge functionality of ``cache.delete_many_by()`` into ``cache.delete_many()`` and remove ``cache.delete_many_by()``. (**breaking change**).\n\n\nv0.8.0 (2018-03-30)\n-------------------\n\n- add ``cache.get_many_by()``.\n- add ``cache.delete_many_by()``.\n- make ``cache.keys()`` and ``cache.values()`` return dictionary view objects instead of yielding items. (**breaking change**)\n\n\nv0.7.0 (2018-02-22)\n-------------------\n\n- changed default cache ``maxsize`` from ``300`` to ``256``. (**breaking change**)\n- add ``cache.memoize()`` decorator.\n- add standalone memoization decorators:\n\n  - ``memoize``\n  - ``fifo_memoize``\n  - ``lfu_memoize``\n  - ``lifo_memoize``\n  - ``lru_memoize``\n  - ``mru_memoize``\n  - ``rr_memoize``\n\n\nv0.6.0 (2018-02-05)\n-------------------\n\n- add ``lifocache``\n- add ``fifocache`` as an alias of ``cache``.\n\n\nv0.5.0 (2018-02-04)\n-------------------\n\n- add ``lfucache``\n- delete expired items before popping an item in ``cache.popitem()``.\n\n\nv0.4.0 (2018-02-02)\n-------------------\n\n- add ``mrucache``\n- add ``rrcache``\n- add ``cache.popitem()``.\n- rename ``cache.expirations()`` to ``cache.expire_times()``. (**breaking change**)\n- rename ``cache.count()`` to ``cache.size()``. (**breaking change**)\n- remove ``minimum`` arguement from ``cache.evict()``. (**breaking change**)\n\n\nv0.3.0 (2018-01-31)\n-------------------\n\n- add ``lrucache``.\n- add ``cachemanager.__repr__()``.\n- make threading lock usage in ``cache`` more fine-grained and eliminate redundant locking.\n- fix missing thread-safety in ``cache.__len__()`` and ``cache.__contains__()``.\n\n\nv0.2.0 (2018-01-30)\n-------------------\n\n- rename ``cache.setup()`` to ``cache.configure()``. (**breaking change**)\n- add ``cachemanager`` class.\n\n\nv0.1.0 (2018-01-28)\n-------------------\n\n- add ``cache`` class.\n\n\n.. _johnbergvall: https://github.com/johnbergvall\n.. _allinolcp: https://github.com/allinolcp\n.. _uncle-lv: https://github.com/uncle-lv\n\nmit license\n\ncopyright (c) 2020 derrick gilland\n\npermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:\n\nthe above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.\n\nthe software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.\n",
  "docs_url": null,
  "keywords": "cacheout cache caching memoize memoization fifo lifo lfu lru mru",
  "license": "mit license",
  "name": "cacheout",
  "package_url": "https://pypi.org/project/cacheout/",
  "project_url": "https://pypi.org/project/cacheout/",
  "project_urls": {
    "Homepage": "https://github.com/dgilland/cacheout"
  },
  "release_url": "https://pypi.org/project/cacheout/0.16.0/",
  "requires_dist": [
    "black ; extra == 'dev'",
    "build ; extra == 'dev'",
    "coverage ; extra == 'dev'",
    "docformatter ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "flake8-black ; extra == 'dev'",
    "flake8-bugbear ; extra == 'dev'",
    "flake8-isort ; extra == 'dev'",
    "furo ; extra == 'dev'",
    "invoke ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "mypy ; extra == 'dev'",
    "pylint ; extra == 'dev'",
    "pytest ; extra == 'dev'",
    "pytest-asyncio ; extra == 'dev'",
    "pytest-cov ; extra == 'dev'",
    "sphinx ; extra == 'dev'",
    "sphinx-autodoc-typehints ; extra == 'dev'",
    "tox ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "wheel ; extra == 'dev'",
    "importlib-metadata <5 ; (python_version == \"3.7\") and extra == 'dev'"
  ],
  "requires_python": ">=3.7",
  "summary": "a caching library for python",
  "version": "0.16.0",
  "releases": [],
  "developers": [
    "derrick_gilland",
    "dgilland@gmail.com"
  ],
  "kwds": "cache lfu_memoize cachemanager lifo_memoize lru_memoize",
  "license_kwds": "mit license",
  "libtype": "pypi",
  "id": "pypi_cacheout",
  "homepage": "https://github.com/dgilland/cacheout",
  "release_count": 24,
  "dependency_ids": [
    "pypi_black",
    "pypi_build",
    "pypi_coverage",
    "pypi_docformatter",
    "pypi_flake8",
    "pypi_flake8_black",
    "pypi_flake8_bugbear",
    "pypi_flake8_isort",
    "pypi_furo",
    "pypi_importlib_metadata",
    "pypi_invoke",
    "pypi_isort",
    "pypi_mypy",
    "pypi_pylint",
    "pypi_pytest",
    "pypi_pytest_asyncio",
    "pypi_pytest_cov",
    "pypi_sphinx",
    "pypi_sphinx_autodoc_typehints",
    "pypi_tox",
    "pypi_twine",
    "pypi_wheel"
  ]
}