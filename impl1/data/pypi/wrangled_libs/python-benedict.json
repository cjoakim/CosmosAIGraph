{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: macos x",
    "environment :: other environment",
    "environment :: web environment",
    "environment :: win32 (ms windows)",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: information technology",
    "intended audience :: science/research",
    "intended audience :: system administrators",
    "license :: osi approved :: mit license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: education :: testing",
    "topic :: software development :: build tools",
    "topic :: system :: filesystems",
    "topic :: text processing :: markup :: xml",
    "topic :: utilities"
  ],
  "description": "[![](https://img.shields.io/pypi/pyversions/python-benedict.svg?color=blue&logo=python&logocolor=white)](https://www.python.org/)\n[![](https://img.shields.io/pypi/v/python-benedict.svg?color=blue&logo=pypi&logocolor=white)](https://pypi.org/project/python-benedict/)\n[![](https://static.pepy.tech/badge/python-benedict/month)](https://pepy.tech/project/python-benedict)\n[![](https://img.shields.io/github/stars/fabiocaccamo/python-benedict?logo=github)](https://github.com/fabiocaccamo/python-benedict/stargazers)\n[![](https://img.shields.io/pypi/l/python-benedict.svg?color=blue)](https://github.com/fabiocaccamo/python-benedict/blob/main/license.txt)\n\n[![](https://results.pre-commit.ci/badge/github/fabiocaccamo/python-benedict/main.svg)](https://results.pre-commit.ci/latest/github/fabiocaccamo/python-benedict/main)\n[![](https://img.shields.io/github/actions/workflow/status/fabiocaccamo/python-benedict/test-package.yml?branch=main&label=build&logo=github)](https://github.com/fabiocaccamo/python-benedict)\n[![](https://img.shields.io/codecov/c/gh/fabiocaccamo/python-benedict?logo=codecov)](https://codecov.io/gh/fabiocaccamo/python-benedict)\n[![](https://img.shields.io/codeclimate/maintainability/fabiocaccamo/python-benedict?logo=code-climate)](https://codeclimate.com/github/fabiocaccamo/python-benedict/)\n[![](https://img.shields.io/codacy/grade/0dbd5cc2089f4dce80a0e49e6822be3c?logo=codacy)](https://www.codacy.com/app/fabiocaccamo/python-benedict)\n[![](https://img.shields.io/scrutinizer/quality/g/fabiocaccamo/python-benedict?logo=scrutinizer)](https://scrutinizer-ci.com/g/fabiocaccamo/python-benedict/?branch=main)\n[![](https://img.shields.io/badge/code%20style-black-000000.svg?logo=python&logocolor=black)](https://github.com/psf/black)\n[![](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/ruff/main/assets/badge/v2.json)](https://github.com/astral-sh/ruff)\n\n# python-benedict\npython-benedict is a dict subclass with **keylist/keypath/keyattr** support, **i/o** shortcuts (`base64`, `cli`, `csv`, `html`, `ini`, `json`, `pickle`, `plist`, `query-string`, `toml`, `xls`, `xml`, `yaml`) and many **utilities**... for humans, obviously.\n\n## features\n-   100% **backward-compatible**, you can safely wrap existing dictionaries.\n-   `new` **keyattr** support for get/set items using **keys as attributes**.\n-   **keylist** support using **list of keys** as key.\n-   **keypath** support using **keypath-separator** *(dot syntax by default)*.\n-   keypath **list-index** support  *(also negative)* using the standard `[n]` suffix.\n-   normalized **i/o operations** with most common formats: `base64`, `cli`, `csv`, `html`, `ini`, `json`, `pickle`, `plist`, `query-string`, `toml`, `xls`, `xml`, `yaml`.\n-   multiple **i/o operations** backends: `file-system` *(read/write)*, `url` *(read-only)*, `s3` *(read/write)*.\n-   many **utility** and **parse methods** to retrieve data as needed *(check the [api](#api) section)*.\n-   well **tested**. ;)\n\n## index\n-   [installation](#installation)\n    -   [optional requirements](#optional-requirements)\n-   [usage](#usage)\n    -   [basics](#basics)\n    -   [keyattr](#keyattr) `my_dict.x.y.z`\n    -   [keylist](#keylist) `my_dict[\"x\", \"y\", \"z\"]`\n    -   [keypath](#keypath) `my_dict[\"x.y.z\"]`\n        -   [custom keypath separator](#custom-keypath-separator)\n        -   [change keypath separator](#change-keypath-separator)\n        -   [disable keypath functionality](#disable-keypath-functionality)\n        -   [list index support](#list-index-support)\n    -   [i/o](#io)\n    -   [api](#api)\n        -   [utility methods](#utility-methods)\n        -   [i/o methods](#io-methods)\n        -   [parse methods](#parse-methods)\n-   [testing](#testing)\n-   [license](#license)\n\n## installation\nif you want to install **everything**:\n-   run `pip install \"python-benedict[all]\"`\n\nalternatively you can install the main package:\n-   run `pip install python-benedict`, then install only the [optional requirements](#optional-requirements) you need.\n\n### optional requirements\nhere the hierarchy of possible installation targets available when running `pip install \"python-benedict[...]\"` *(each target installs all its sub-targets)*:\n- `[all]`\n    - `[io]`\n        - `[html]`\n        - `[toml]`\n        - `[xls]`\n        - `[xml]`\n        - `[yaml]`\n    - `[parse]`\n    - `[s3]`\n\n## usage\n\n### basics\n`benedict` is a `dict` subclass, so it is possible to use it as a normal dictionary *(you can just cast an existing dict)*.\n\n```python\nfrom benedict import benedict\n\n# create a new empty instance\nd = benedict()\n\n# or cast an existing dict\nd = benedict(existing_dict)\n\n# or create from data source (filepath, url or data-string) in a supported format:\n# base64, csv, json, toml, xml, yaml, query-string\nd = benedict(\"https://localhost:8000/data.json\", format=\"json\")\n\n# or in a django view\nparams = benedict(request.get.items())\npage = params.get_int(\"page\", 1)\n```\n\n### keyattr\nit is possible to get/set items using **keys as attributes** (dotted notation).\n\n```python\nd = benedict(keyattr_dynamic=true) # default false\nd.profile.firstname = \"fabio\"\nd.profile.lastname = \"caccamo\"\nprint(d) # -> { \"profile\":{ \"firstname\":\"fabio\", \"lastname\":\"caccamo\" } }\n```\n\nby default, if the `keyattr_dynamic` is not explicitly set to `true`, this functionality works for get/set only already existing items.\n\n#### disable keyattr functionality\nyou can disable the keyattr functionality passing `keyattr_enabled=false` option in the constructor.\n\n```python\nd = benedict(existing_dict, keyattr_enabled=false) # default true\n```\n\nor using the `getter/setter` property.\n\n```python\nd.keyattr_enabled = false\n```\n\n#### dynamic keyattr functionality\nyou can enable the dynamic attributes access functionality passing `keyattr_dynamic=true` in the constructor.\n\n```python\nd = benedict(existing_dict, keyattr_dynamic=true) # default false\n```\n\nor using the `getter/setter` property.\n\n```python\nd.keyattr_dynamic = true\n```\n\n> **warning** - even if this feature is very useful, it has some obvious limitations: it works only for string keys that are *unprotected* (not starting with an `_`) and that don't clash with the currently supported methods names.\n\n### keylist\nwherever a **key** is used, it is possible to use also a **list (or a tuple) of keys**.\n\n```python\nd = benedict()\n\n# set values by keys list\nd[\"profile\", \"firstname\"] = \"fabio\"\nd[\"profile\", \"lastname\"] = \"caccamo\"\nprint(d) # -> { \"profile\":{ \"firstname\":\"fabio\", \"lastname\":\"caccamo\" } }\nprint(d[\"profile\"]) # -> { \"firstname\":\"fabio\", \"lastname\":\"caccamo\" }\n\n# check if keypath exists in dict\nprint([\"profile\", \"lastname\"] in d) # -> true\n\n# delete value by keys list\ndel d[\"profile\", \"lastname\"]\nprint(d[\"profile\"]) # -> { \"firstname\":\"fabio\" }\n```\n\n### keypath\n`.` is the default keypath separator.\n\nif you cast an existing dict and its keys contain the keypath separator a `valueerror` will be raised.\n\nin this case you should use a [custom keypath separator](#custom-keypath-separator) or [disable keypath functionality](#disable-keypath-functionality).\n\n```python\nd = benedict()\n\n# set values by keypath\nd[\"profile.firstname\"] = \"fabio\"\nd[\"profile.lastname\"] = \"caccamo\"\nprint(d) # -> { \"profile\":{ \"firstname\":\"fabio\", \"lastname\":\"caccamo\" } }\nprint(d[\"profile\"]) # -> { \"firstname\":\"fabio\", \"lastname\":\"caccamo\" }\n\n# check if keypath exists in dict\nprint(\"profile.lastname\" in d) # -> true\n\n# delete value by keypath\ndel d[\"profile.lastname\"]\n```\n\n#### custom keypath separator\nyou can customize the keypath separator passing the `keypath_separator` argument in the constructor.\n\nif you pass an existing dict to the constructor and its keys contain the keypath separator an `exception` will be raised.\n\n```python\nd = benedict(existing_dict, keypath_separator=\"/\")\n```\n\n#### change keypath separator\nyou can change the `keypath_separator` at any time using the `getter/setter` property.\n\nif any existing key contains the new `keypath_separator` an `exception` will be raised.\n\n```python\nd.keypath_separator = \"/\"\n```\n\n#### disable keypath functionality\nyou can disable the keypath functionality passing `keypath_separator=none` option in the constructor.\n\n```python\nd = benedict(existing_dict, keypath_separator=none)\n```\n\nor using the `getter/setter` property.\n\n```python\nd.keypath_separator = none\n```\n\n#### list index support\nlist index are supported, keypaths can include indexes *(also negative)* using `[n]`, to perform any operation very fast:\n\n```python\n# eg. get last location cordinates of the first result:\nloc = d[\"results[0].locations[-1].coordinates\"]\nlat = loc.get_decimal(\"latitude\")\nlng = loc.get_decimal(\"longitude\")\n```\n\n### i/o\n\nfor simplifying i/o operations, `benedict` supports a variety of input/output methods with most common formats: `base64`, `cli`, `csv`, `html`, `ini`, `json`, `pickle`, `plist`, `query-string`, `toml`, `xls`, `xml`, `yaml`.\n\n#### input via constructor\n\nit is possible to create a `benedict` instance directly from data-source (`filepath`, `url`, `s3` or `data` string) by passing the data source and the data format (optional, default \"json\") in the constructor.\n\n```python\n# filepath\nd = benedict(\"/root/data.yml\", format=\"yaml\")\n\n# url\nd = benedict(\"https://localhost:8000/data.xml\", format=\"xml\")\n\n# s3\nd = benedict(\"s3://my-bucket/data.xml\", s3_options={\"aws_access_key_id\": \"...\", \"aws_secret_access_key\": \"...\"})\n\n# data\nd = benedict('{\"a\": 1, \"b\": 2, \"c\": 3, \"x\": 7, \"y\": 8, \"z\": 9}')\n```\n\n#### input methods\n\n- all *input* methods can be accessed as class methods and are prefixed by `from_*` followed by the format name.\n- in all *input* methods, the first argument can represent a source: **file** path, **url**, **s3** url, or **data** string.\n\n#### input sources\n\nall supported sources (**file**, **url**, **s3**, **data**) are allowed by default, but in certains situations when the input data comes from **untrusted sources** it may be useful to restrict the allowed sources using the `sources` argument:\n\n```python\n# url\nd = benedict(\"https://localhost:8000/data.json\", sources=[\"url\"]) # -> ok\nd = benedict.from_json(\"https://localhost:8000/data.json\", sources=[\"url\"]) # -> ok\n\n# s3\nd = benedict(\"s3://my-bucket/data.json\", sources=[\"url\"]) # -> raise valueerror\nd = benedict.from_json(\"s3://my-bucket/data.json\", sources=[\"url\"]) # -> raise valueerror\n```\n\n#### output methods\n\n- all *output* methods can be accessed as instance methods and are prefixed by `to_*` followed by the format name.\n- in all *output* methods, if `filepath=\"...\"` kwarg is specified, the output will be also **saved** at the specified filepath.\n\n#### supported formats\n\nhere are the details of the supported formats, operations and extra options docs.\n\n| **format**     | **input**          | **output**         | **extra options docs**                                                                |\n|----------------|--------------------|--------------------|---------------------------------------------------------------------------------------|\n| `base64`       | :white_check_mark: | :white_check_mark: | -                                                                                     |\n| `cli`          | :white_check_mark: | :x:                | [argparse](https://docs.python.org/3/library/argparse.html#argparse.argumentparser)   |\n| `csv`          | :white_check_mark: | :white_check_mark: | [csv](https://docs.python.org/3/library/csv.html)                                     |\n| `html`         | :white_check_mark: | :x:                | [bs4](https://beautiful-soup-4.readthedocs.io) *(beautiful soup 4)*                   |\n| `ini`          | :white_check_mark: | :white_check_mark: | [configparser](https://docs.python.org/3/library/configparser.html)                   |\n| `json`         | :white_check_mark: | :white_check_mark: | [json](https://docs.python.org/3/library/json.html)                                   |\n| `pickle`       | :white_check_mark: | :white_check_mark: | [pickle](https://docs.python.org/3/library/pickle.html)                               |\n| `plist`        | :white_check_mark: | :white_check_mark: | [plistlib](https://docs.python.org/3/library/plistlib.html)                           |\n| `query-string` | :white_check_mark: | :white_check_mark: | -                                                                                     |\n| `toml`         | :white_check_mark: | :white_check_mark: | [toml](https://pypi.org/project/toml/)                                                |\n| `xls`          | :white_check_mark: | :x:                | [openpyxl](https://openpyxl.readthedocs.io/) - [xlrd](https://pypi.org/project/xlrd/) |\n| `xml`          | :white_check_mark: | :white_check_mark: | [xmltodict](https://github.com/martinblech/xmltodict)                                 |\n| `yaml`         | :white_check_mark: | :white_check_mark: | [pyyaml](https://pyyaml.org/wiki/pyyamldocumentation)                                 |\n\n### api\n\n-   **utility methods**\n\n    -   [`clean`](#clean)\n    -   [`clone`](#clone)\n    -   [`dump`](#dump)\n    -   [`filter`](#filter)\n    -   [`find`](#find)\n    -   [`flatten`](#flatten)\n    -   [`groupby`](#groupby)\n    -   [`invert`](#invert)\n    -   [`items_sorted_by_keys`](#items_sorted_by_keys)\n    -   [`items_sorted_by_values`](#items_sorted_by_values)\n    -   [`keypaths`](#keypaths)\n    -   [`match`](#match)\n    -   [`merge`](#merge)\n    -   [`move`](#move)\n    -   [`nest`](#nest)\n    -   [`remove`](#remove)\n    -   [`rename`](#rename)\n    -   [`search`](#search)\n    -   [`standardize`](#standardize)\n    -   [`subset`](#subset)\n    -   [`swap`](#swap)\n    -   [`traverse`](#traverse)\n    -   [`unflatten`](#unflatten)\n    -   [`unique`](#unique)\n\n-   **i/o methods**\n\n    -   [`from_base64`](#from_base64)\n    -   [`from_cli`](#from_cli)\n    -   [`from_csv`](#from_csv)\n    -   [`from_ini`](#from_ini)\n    -   [`from_html`](#from_html)\n    -   [`from_json`](#from_json)\n    -   [`from_pickle`](#from_pickle)\n    -   [`from_plist`](#from_plist)\n    -   [`from_query_string`](#from_query_string)\n    -   [`from_toml`](#from_toml)\n    -   [`from_xls`](#from_xls)\n    -   [`from_xml`](#from_xml)\n    -   [`from_yaml`](#from_yaml)\n    -   [`to_base64`](#to_base64)\n    -   [`to_csv`](#to_csv)\n    -   [`to_ini`](#to_ini)\n    -   [`to_json`](#to_json)\n    -   [`to_pickle`](#to_pickle)\n    -   [`to_plist`](#to_plist)\n    -   [`to_query_string`](#to_query_string)\n    -   [`to_toml`](#to_toml)\n    -   [`to_xml`](#to_xml)\n    -   [`to_yaml`](#to_yaml)\n\n-   **parse methods**\n\n    -   [`get_bool`](#get_bool)\n    -   [`get_bool_list`](#get_bool_list)\n    -   [`get_date`](#get_date)\n    -   [`get_date_list`](#get_date_list)\n    -   [`get_datetime`](#get_datetime)\n    -   [`get_datetime_list`](#get_datetime_list)\n    -   [`get_decimal`](#get_decimal)\n    -   [`get_decimal_list`](#get_decimal_list)\n    -   [`get_dict`](#get_dict)\n    -   [`get_email`](#get_email)\n    -   [`get_float`](#get_float)\n    -   [`get_float_list`](#get_float_list)\n    -   [`get_int`](#get_int)\n    -   [`get_int_list`](#get_int_list)\n    -   [`get_list`](#get_list)\n    -   [`get_list_item`](#get_list_item)\n    -   [`get_phonenumber`](#get_phonenumber)\n    -   [`get_slug`](#get_slug)\n    -   [`get_slug_list`](#get_slug_list)\n    -   [`get_str`](#get_str)\n    -   [`get_str_list`](#get_str_list)\n    -   [`get_uuid`](#get_uuid)\n    -   [`get_uuid_list`](#get_uuid_list)\n\n### utility methods\n\nthese methods are common utilities that will speed up your everyday work.\n\nutilities that accept key argument(s) also support keypath(s).\n\nutilities that return a dictionary always return a new `benedict` instance.\n\n#### `clean`\n\n```python\n# clean the current dict instance removing all empty values: none, \"\", {}, [], ().\n# if strings or collections (dict, list, set, tuple) flags are false,\n# related empty values will not be deleted.\nd.clean(strings=true, collections=true)\n```\n\n#### `clone`\n\n```python\n# return a clone (deepcopy) of the dict.\nc = d.clone()\n```\n\n#### `dump`\n\n```python\n# return a readable representation of any dict/list.\n# this method can be used both as static method or instance method.\ns = benedict.dump(d.keypaths())\nprint(s)\n# or\nd = benedict()\nprint(d.dump())\n```\n\n#### `filter`\n\n```python\n# return a filtered dict using the given predicate function.\n# predicate function receives key, value arguments and should return a bool value.\npredicate = lambda k, v: v is not none\nf = d.filter(predicate)\n```\n\n#### `find`\n\n```python\n# return the first match searching for the given keys/keypaths.\n# if no result found, default value is returned.\nkeys = [\"a.b.c\", \"m.n.o\", \"x.y.z\"]\nf = d.find(keys, default=0)\n```\n\n#### `flatten`\n\n```python\n# return a new flattened dict using the given separator to join nested dict keys to flatten keypaths.\nf = d.flatten(separator=\"_\")\n```\n\n#### `groupby`\n\n```python\n# group a list of dicts at key by the value of the given by_key and return a new dict.\ng = d.groupby(\"cities\", by_key=\"country_code\")\n```\n\n#### `invert`\n\n```python\n# return an inverted dict where values become keys and keys become values.\n# since multiple keys could have the same value, each value will be a list of keys.\n# if flat is true each value will be a single value (use this only if values are unique).\ni = d.invert(flat=false)\n```\n\n#### `items_sorted_by_keys`\n\n```python\n# return items (key/value list) sorted by keys.\n# if reverse is true, the list will be reversed.\nitems = d.items_sorted_by_keys(reverse=false)\n```\n\n#### `items_sorted_by_values`\n\n```python\n# return items (key/value list) sorted by values.\n# if reverse is true, the list will be reversed.\nitems = d.items_sorted_by_values(reverse=false)\n```\n\n#### `keypaths`\n\n```python\n# return a list of all keypaths in the dict.\n# if indexes is true, the output will include list values indexes.\nk = d.keypaths(indexes=false)\n```\n\n#### `match`\n\n```python\n# return a list of all values whose keypath matches the given pattern (a regex or string).\n# if pattern is string, wildcard can be used (eg. [*] can be used to match all list indexes).\n# if indexes is true, the pattern will be matched also against list values.\nm = d.match(pattern, indexes=true)\n```\n\n#### `merge`\n\n```python\n# merge one or more dictionary objects into current instance (deepupdate).\n# sub-dictionaries keys will be merged together.\n# if overwrite is false, existing values will not be overwritten.\n# if concat is true, list values will be concatenated together.\nd.merge(a, b, c, overwrite=true, concat=false)\n```\n\n#### `move`\n\n```python\n# move an item from key_src to key_dst.\n# it can be used to rename a key.\n# if key_dst exists, its value will be overwritten.\nd.move(\"a\", \"b\", overwrite=true)\n```\n\n#### `nest`\n\n```python\n# nest a list of dicts at the given key and return a new nested list\n# using the specified keys to establish the correct items hierarchy.\nd.nest(\"values\", id_key=\"id\", parent_id_key=\"parent_id\", children_key=\"children\")\n```\n\n#### `remove`\n\n```python\n# remove multiple keys from the dict.\n# it is possible to pass a single key or more keys (as list or *args).\nd.remove([\"firstname\", \"lastname\", \"email\"])\n```\n\n#### `rename`\n\n```python\n# rename a dict item key from \"key\" to \"key_new\".\n# if key_new exists, a keyerror will be raised.\nd.rename(\"first_name\", \"firstname\")\n```\n\n#### `search`\n\n```python\n# search and return a list of items (dict, key, value, ) matching the given query.\nr = d.search(\"hello\", in_keys=true, in_values=true, exact=false, case_sensitive=false)\n```\n\n#### `standardize`\n\n```python\n# standardize all dict keys, e.g. \"location latitude\" -> \"location_latitude\".\nd.standardize()\n```\n\n#### `subset`\n\n```python\n# return a dict subset for the given keys.\n# it is possible to pass a single key or more keys (as list or *args).\ns = d.subset([\"firstname\", \"lastname\", \"email\"])\n```\n\n#### `swap`\n\n```python\n# swap items values at the given keys.\nd.swap(\"firstname\", \"lastname\")\n```\n\n#### `traverse`\n\n```python\n# traverse a dict passing each item (dict, key, value) to the given callback function.\ndef f(d, key, value):\n    print(f\"dict: {d} - key: {key} - value: {value}\")\nd.traverse(f)\n```\n\n#### `unflatten`\n\n```python\n# return a new unflattened dict using the given separator to split dict keys to nested keypaths.\nu = d.unflatten(separator=\"_\")\n```\n\n#### `unique`\n\n```python\n# remove duplicated values from the dict.\nd.unique()\n```\n\n### i/o methods\n\nthese methods are available for input/output operations.\n\n#### `from_base64`\n\n```python\n# try to load/decode a base64 encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to choose the subformat used under the hood:\n# ('csv', 'json', 'query-string', 'toml', 'xml', 'yaml'), default: 'json'.\n# it's possible to choose the encoding, default 'utf-8'.\n# a valueerror is raised in case of failure.\nd = benedict.from_base64(s, subformat=\"json\", encoding=\"utf-8\", **kwargs)\n```\n\n#### `from_cli`\n\n```python\n# load and decode data from a string of cli arguments.\n# argumentparser specific options can be passed using kwargs:\n# https://docs.python.org/3/library/argparse.html#argparse.argumentparser\n# return a new dict instance. a valueerror is raised in case of failure.\nd = benedict.from_cli(s, **kwargs)\n```\n\n#### `from_csv`\n\n```python\n# try to load/decode a csv encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to specify the columns list, default: none (in this case the first row values will be used as keys).\n# it's possible to pass decoder specific options using kwargs:\n# https://docs.python.org/3/library/csv.html\n# a valueerror is raised in case of failure.\nd = benedict.from_csv(s, columns=none, columns_row=true, **kwargs)\n```\n\n#### `from_html`\n\n```python\n# try to load/decode a html data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://beautiful-soup-4.readthedocs.io/\n# a valueerror is raised in case of failure.\nd = benedict.from_html(s, **kwargs)\n```\n\n#### `from_ini`\n\n```python\n# try to load/decode a ini encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://docs.python.org/3/library/configparser.html\n# a valueerror is raised in case of failure.\nd = benedict.from_ini(s, **kwargs)\n```\n\n#### `from_json`\n\n```python\n# try to load/decode a json encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://docs.python.org/3/library/json.html\n# a valueerror is raised in case of failure.\nd = benedict.from_json(s, **kwargs)\n```\n\n#### `from_pickle`\n\n```python\n# try to load/decode a pickle encoded in base64 format and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://docs.python.org/3/library/pickle.html\n# a valueerror is raised in case of failure.\nd = benedict.from_pickle(s, **kwargs)\n```\n\n#### `from_plist`\n\n```python\n# try to load/decode a p-list encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://docs.python.org/3/library/plistlib.html\n# a valueerror is raised in case of failure.\nd = benedict.from_plist(s, **kwargs)\n```\n\n#### `from_query_string`\n\n```python\n# try to load/decode a query-string and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# a valueerror is raised in case of failure.\nd = benedict.from_query_string(s, **kwargs)\n```\n\n#### `from_toml`\n\n```python\n# try to load/decode a toml encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://pypi.org/project/toml/\n# a valueerror is raised in case of failure.\nd = benedict.from_toml(s, **kwargs)\n```\n\n#### `from_xls`\n\n```python\n# try to load/decode a xls file (\".xls\", \".xlsx\", \".xlsm\") from url, filepath or data-string.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# - https://openpyxl.readthedocs.io/ (for .xlsx and .xlsm files)\n# - https://pypi.org/project/xlrd/ (for .xls files)\n# a valueerror is raised in case of failure.\nd = benedict.from_xls(s, sheet=0, columns=none, columns_row=true, **kwargs)\n```\n\n#### `from_xml`\n\n```python\n# try to load/decode a xml encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://github.com/martinblech/xmltodict\n# a valueerror is raised in case of failure.\nd = benedict.from_xml(s, **kwargs)\n```\n\n#### `from_yaml`\n\n```python\n# try to load/decode a yaml encoded data and return it as benedict instance.\n# accept as first argument: url, filepath or data-string.\n# it's possible to pass decoder specific options using kwargs:\n# https://pyyaml.org/wiki/pyyamldocumentation\n# a valueerror is raised in case of failure.\nd = benedict.from_yaml(s, **kwargs)\n```\n\n#### `to_base64`\n\n```python\n# return the dict instance encoded in base64 format and optionally save it at the specified 'filepath'.\n# it's possible to choose the subformat used under the hood:\n# ('csv', json', 'query-string', 'toml', 'xml', 'yaml'), default: 'json'.\n# it's possible to choose the encoding, default 'utf-8'.\n# it's possible to pass decoder specific options using kwargs.\n# a valueerror is raised in case of failure.\ns = d.to_base64(subformat=\"json\", encoding=\"utf-8\", **kwargs)\n```\n\n#### `to_csv`\n\n```python\n# return a list of dicts in the current dict encoded in csv format and optionally save it at the specified filepath.\n# it's possible to specify the key of the item (list of dicts) to encode, default: 'values'.\n# it's possible to specify the columns list, default: none (in this case the keys of the first item will be used).\n# a valueerror is raised in case of failure.\ns = d.to_csv(key=\"values\", columns=none, columns_row=true, **kwargs)\n```\n\n#### `to_ini`\n\n```python\n# return the dict instance encoded in ini format and optionally save it at the specified filepath.\n# it's possible to pass encoder specific options using kwargs:\n# https://docs.python.org/3/library/configparser.html\n# a valueerror is raised in case of failure.\ns = d.to_ini(**kwargs)\n```\n\n#### `to_json`\n\n```python\n# return the dict instance encoded in json format and optionally save it at the specified filepath.\n# it's possible to pass encoder specific options using kwargs:\n# https://docs.python.org/3/library/json.html\n# a valueerror is raised in case of failure.\ns = d.to_json(**kwargs)\n```\n\n#### `to_pickle`\n\n```python\n# return the dict instance as pickle encoded in base64 format and optionally save it at the specified filepath.\n# the pickle protocol used by default is 2.\n# it's possible to pass encoder specific options using kwargs:\n# https://docs.python.org/3/library/pickle.html\n# a valueerror is raised in case of failure.\ns = d.to_pickle(**kwargs)\n```\n\n#### `to_plist`\n\n```python\n# return the dict instance encoded in p-list format and optionally save it at the specified filepath.\n# it's possible to pass encoder specific options using kwargs:\n# https://docs.python.org/3/library/plistlib.html\n# a valueerror is raised in case of failure.\ns = d.to_plist(**kwargs)\n```\n\n#### `to_query_string`\n\n```python\n# return the dict instance as query-string and optionally save it at the specified filepath.\n# a valueerror is raised in case of failure.\ns = d.to_query_string(**kwargs)\n```\n\n#### `to_toml`\n\n```python\n# return the dict instance encoded in toml format and optionally save it at the specified filepath.\n# it's possible to pass encoder specific options using kwargs:\n# https://pypi.org/project/toml/\n# a valueerror is raised in case of failure.\ns = d.to_toml(**kwargs)\n```\n\n#### `to_xml`\n\n```python\n# return the dict instance encoded in xml format and optionally save it at the specified filepath.\n# it's possible to pass encoder specific options using kwargs:\n# https://github.com/martinblech/xmltodict\n# a valueerror is raised in case of failure.\ns = d.to_xml(**kwargs)\n```\n\n#### `to_yaml`\n\n```python\n# return the dict instance encoded in yaml format.\n# if filepath option is passed the output will be saved ath\n# it's possible to pass encoder specific options using kwargs:\n# https://pyyaml.org/wiki/pyyamldocumentation\n# a valueerror is raised in case of failure.\ns = d.to_yaml(**kwargs)\n```\n\n### parse methods\n\nthese methods are wrappers of the `get` method, they parse data trying to return it in the expected type.\n\n#### `get_bool`\n\n```python\n# get value by key or keypath trying to return it as bool.\n# values like `1`, `true`, `yes`, `on`, `ok` will be returned as `true`.\nd.get_bool(key, default=false)\n```\n\n#### `get_bool_list`\n\n```python\n# get value by key or keypath trying to return it as list of bool values.\n# if separator is specified and value is a string it will be splitted.\nd.get_bool_list(key, default=[], separator=\",\")\n```\n\n#### `get_date`\n\n```python\n# get value by key or keypath trying to return it as date.\n# if format is not specified it will be autodetected.\n# if choices and value is in choices return value otherwise default.\nd.get_date(key, default=none, format=none, choices=[])\n```\n\n#### `get_date_list`\n\n```python\n# get value by key or keypath trying to return it as list of date values.\n# if separator is specified and value is a string it will be splitted.\nd.get_date_list(key, default=[], format=none, separator=\",\")\n```\n\n#### `get_datetime`\n\n```python\n# get value by key or keypath trying to return it as datetime.\n# if format is not specified it will be autodetected.\n# if choices and value is in choices return value otherwise default.\nd.get_datetime(key, default=none, format=none, choices=[])\n```\n\n#### `get_datetime_list`\n\n```python\n# get value by key or keypath trying to return it as list of datetime values.\n# if separator is specified and value is a string it will be splitted.\nd.get_datetime_list(key, default=[], format=none, separator=\",\")\n```\n\n#### `get_decimal`\n\n```python\n# get value by key or keypath trying to return it as decimal.\n# if choices and value is in choices return value otherwise default.\nd.get_decimal(key, default=decimal(\"0.0\"), choices=[])\n```\n\n#### `get_decimal_list`\n\n```python\n# get value by key or keypath trying to return it as list of decimal values.\n# if separator is specified and value is a string it will be splitted.\nd.get_decimal_list(key, default=[], separator=\",\")\n```\n\n#### `get_dict`\n\n```python\n# get value by key or keypath trying to return it as dict.\n# if value is a json string it will be automatically decoded.\nd.get_dict(key, default={})\n```\n\n#### `get_email`\n\n```python\n# get email by key or keypath and return it.\n# if value is blacklisted it will be automatically ignored.\n# if check_blacklist is false, it will be not ignored even if blacklisted.\nd.get_email(key, default=\"\", choices=none, check_blacklist=true)\n```\n\n#### `get_float`\n\n```python\n# get value by key or keypath trying to return it as float.\n# if choices and value is in choices return value otherwise default.\nd.get_float(key, default=0.0, choices=[])\n```\n\n#### `get_float_list`\n\n```python\n# get value by key or keypath trying to return it as list of float values.\n# if separator is specified and value is a string it will be splitted.\nd.get_float_list(key, default=[], separator=\",\")\n```\n\n#### `get_int`\n\n```python\n# get value by key or keypath trying to return it as int.\n# if choices and value is in choices return value otherwise default.\nd.get_int(key, default=0, choices=[])\n```\n\n#### `get_int_list`\n\n```python\n# get value by key or keypath trying to return it as list of int values.\n# if separator is specified and value is a string it will be splitted.\nd.get_int_list(key, default=[], separator=\",\")\n```\n\n#### `get_list`\n\n```python\n# get value by key or keypath trying to return it as list.\n# if separator is specified and value is a string it will be splitted.\nd.get_list(key, default=[], separator=\",\")\n```\n\n#### `get_list_item`\n\n```python\n# get list by key or keypath and return value at the specified index.\n# if separator is specified and list value is a string it will be splitted.\nd.get_list_item(key, index=0, default=none, separator=\",\")\n```\n\n#### `get_phonenumber`\n\n```python\n#\u00a0get phone number by key or keypath and return a dict with different formats (e164, international, national).\n# if country code is specified (alpha 2 code), it will be used to parse phone number correctly.\nd.get_phonenumber(key, country_code=none, default=none)\n```\n\n#### `get_slug`\n\n```python\n# get value by key or keypath trying to return it as slug.\n# if choices and value is in choices return value otherwise default.\nd.get_slug(key, default=\"\", choices=[])\n```\n\n#### `get_slug_list`\n\n```python\n# get value by key or keypath trying to return it as list of slug values.\n# if separator is specified and value is a string it will be splitted.\nd.get_slug_list(key, default=[], separator=\",\")\n```\n\n#### `get_str`\n\n```python\n# get value by key or keypath trying to return it as string.\n# encoding issues will be automatically fixed.\n# if choices and value is in choices return value otherwise default.\nd.get_str(key, default=\"\", choices=[])\n```\n\n#### `get_str_list`\n\n```python\n# get value by key or keypath trying to return it as list of str values.\n# if separator is specified and value is a string it will be splitted.\nd.get_str_list(key, default=[], separator=\",\")\n```\n\n#### `get_uuid`\n\n```python\n# get value by key or keypath trying to return it as valid uuid.\n# if choices and value is in choices return value otherwise default.\nd.get_uuid(key, default=\"\", choices=[])\n```\n\n#### `get_uuid_list`\n\n```python\n#\u00a0get value by key or keypath trying to return it as list of valid uuid values.\n# if separator is specified and value is a string it will be splitted.\nd.get_uuid_list(key, default=[], separator=\",\")\n```\n\n## testing\n```bash\n# clone repository\ngit clone https://github.com/fabiocaccamo/python-benedict.git && cd python-benedict\n\n# create virtualenv and activate it\npython -m venv venv && . venv/bin/activate\n\n# upgrade pip\npython -m pip install --upgrade pip\n\n# install requirements\npip install -r requirements.txt -r requirements-test.txt\n\n# install pre-commit to run formatters and linters\npre-commit install --install-hooks\n\n# run tests using tox\ntox\n\n# or run tests using unittest\npython -m unittest\n```\n\n## license\nreleased under [mit license](license.txt).\n\n---\n\n## supporting\n\n- :star: star this project on [github](https://github.com/fabiocaccamo/python-benedict)\n- :octocat: follow me on [github](https://github.com/fabiocaccamo)\n- :blue_heart: follow me on [twitter](https://twitter.com/fabiocaccamo)\n- :moneybag: sponsor me on [github](https://github.com/sponsors/fabiocaccamo)\n\n## see also\n\n- [`python-fontbro`](https://github.com/fabiocaccamo/python-fontbro) - \ud83e\udde2 friendly font operations on top of `fonttools`.\n\n- [`python-fsutil`](https://github.com/fabiocaccamo/python-fsutil) - \ud83e\udddf\u200d\u2642\ufe0f high-level file-system operations for lazy devs.\n",
  "docs_url": null,
  "keywords": "python,dictionary,dictionaries,dict,benedict,subclass,extended,keylist,keypath,utility,io,data,file,url,read,write,parse,configparser,config,cfg,pickle,plist,base64,csv,html,ini,json,query-string,toml,xml,yaml,clean,clone,deepclone,deepupdate,dump,filter,flatten,groupby,invert,merge,move,nest,remove,rename,search,standardize,subset,swap,traverse,unflatten,unique",
  "license": "mit license  copyright (c) 2019-present fabio caccamo  permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"software\"), to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:  the above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.  the software is provided \"as is\", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. in no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software. ",
  "name": "python-benedict",
  "package_url": "https://pypi.org/project/python-benedict/",
  "project_url": "https://pypi.org/project/python-benedict/",
  "project_urls": {
    "Documentation": "https://github.com/fabiocaccamo/python-benedict#readme",
    "Download": "https://github.com/fabiocaccamo/python-benedict/releases",
    "Funding": "https://github.com/sponsors/fabiocaccamo/",
    "Homepage": "https://github.com/fabiocaccamo/python-benedict",
    "Issues": "https://github.com/fabiocaccamo/python-benedict/issues",
    "Twitter": "https://twitter.com/fabiocaccamo"
  },
  "release_url": "https://pypi.org/project/python-benedict/0.33.0/",
  "requires_dist": [
    "python-fsutil <1.0.0,>=0.9.3",
    "python-slugify <9.0.0,>=7.0.0",
    "requests <3.0.0,>=2.26.0",
    "python-benedict[io,parse,s3] ; extra == 'all'",
    "beautifulsoup4 <5.0.0,>=4.12.0 ; extra == 'html'",
    "python-benedict[html,toml,xls,xml,yaml] ; extra == 'io'",
    "ftfy <7.0.0,>=6.0.0 ; extra == 'parse'",
    "mailchecker <6.0.0,>=4.1.0 ; extra == 'parse'",
    "phonenumbers <9.0.0,>=8.12.0 ; extra == 'parse'",
    "python-dateutil <3.0.0,>=2.8.0 ; extra == 'parse'",
    "boto3 <2.0.0,>=1.24.89 ; extra == 's3'",
    "toml <1.0.0,>=0.10.2 ; extra == 'toml'",
    "openpyxl <4.0.0,>=3.0.0 ; extra == 'xls'",
    "xlrd <3.0.0,>=2.0.0 ; extra == 'xls'",
    "xmltodict <1.0.0,>=0.12.0 ; extra == 'xml'",
    "pyyaml <7.0,>=6.0 ; extra == 'yaml'"
  ],
  "requires_python": "",
  "summary": "python-benedict is a dict subclass with keylist/keypath/keyattr support, normalized i/o operations (base64, csv, ini, json, pickle, plist, query-string, toml, xls, xml, yaml) and many utilities... for humans, obviously.",
  "version": "0.33.0",
  "releases": [],
  "developers": [
    "fabio.caccamo@gmail.com"
  ],
  "kwds": "python dictionaries dict dicts xmltodict",
  "license_kwds": "copyright license liable liability mit",
  "libtype": "pypi",
  "id": "pypi_python_benedict",
  "homepage": "",
  "release_count": 63,
  "dependency_ids": [
    "pypi_beautifulsoup4",
    "pypi_boto3",
    "pypi_ftfy",
    "pypi_mailchecker",
    "pypi_openpyxl",
    "pypi_phonenumbers",
    "pypi_python_benedict",
    "pypi_python_dateutil",
    "pypi_python_fsutil",
    "pypi_python_slugify",
    "pypi_pyyaml",
    "pypi_requests",
    "pypi_toml",
    "pypi_xlrd",
    "pypi_xmltodict"
  ]
}