{
  "classifiers": [
    "development status :: 4 - beta",
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "============\nrq scheduler\n============\n\n`rq scheduler <https://github.com/rq/rq-scheduler>`_ is a small package that\nadds job scheduling capabilities to `rq <https://github.com/nvie/rq>`_,\na `redis <http://redis.io/>`_ based python queuing library.\n\n.. image:: https://travis-ci.org/rq/rq-scheduler.svg?branch=master\n    :target: https://travis-ci.org/rq/rq-scheduler\n\n====================\nsupport rq scheduler\n====================\n\nif you find ``rq-scheduler`` useful, please consider supporting its development via `tidelift <https://tidelift.com/subscription/pkg/pypi-rq_scheduler?utm_source=pypi-rq-scheduler&utm_medium=referral&utm_campaign=readme>`_.\n\n============\nrequirements\n============\n\n* `rq`_\n\n============\ninstallation\n============\n\nyou can install `rq scheduler`_ via pip::\n\n    pip install rq-scheduler\n\nor you can download the latest stable package from `pypi <http://pypi.python.org/pypi/rq-scheduler>`_.\n\n=====\nusage\n=====\n\nschedule a job involves doing two different things:\n\n1. putting a job in the scheduler\n2. running a scheduler that will move scheduled jobs into queues when the time comes\n\n----------------\nscheduling a job\n----------------\n\nthere are two ways you can schedule a job. the first is using rq scheduler's ``enqueue_at``\n\n.. code-block:: python\n\n    from redis import redis\n    from rq import queue\n    from rq_scheduler import scheduler\n    from datetime import datetime\n\n    scheduler = scheduler(connection=redis()) # get a scheduler for the \"default\" queue\n    scheduler = scheduler('foo', connection=redis()) # get a scheduler for the \"foo\" queue\n\n    # you can also instantiate a scheduler using an rq queue\n    queue = queue('bar', connection=redis())\n    scheduler = scheduler(queue=queue, connection=queue.connection)\n\n    # puts a job into the scheduler. the api is similar to rq except that it\n    # takes a datetime object as first argument. so for example to schedule a\n    # job to run on jan 1st 2020 we do:\n    scheduler.enqueue_at(datetime(2020, 1, 1), func) # date time should be in utc\n\n    # here's another example scheduling a job to run at a specific date and time (in utc),\n    # complete with args and kwargs.\n    scheduler.enqueue_at(datetime(2020, 1, 1, 3, 4), func, foo, bar=baz)\n\n    # you can choose the queue type where jobs will be enqueued by passing the name of the type to the scheduler\n    # used to enqueue\n    scheduler = scheduler('foo', queue_class=\"rq.queue\")\n    scheduler.enqueue_at(datetime(2020, 1, 1), func) # the job will be enqueued at the queue named \"foo\" using the queue type \"rq.queue\"\n\n\nthe second way is using ``enqueue_in``. instead of taking a ``datetime`` object,\nthis method expects a ``timedelta`` and schedules the job to run at\nx seconds/minutes/hours/days/weeks later. for example, if we want to monitor how\npopular a tweet is a few times during the course of the day, we could do something like\n\n.. code-block:: python\n\n    from datetime import timedelta\n\n    # schedule a job to run 10 minutes, 1 hour and 1 day later\n    scheduler.enqueue_in(timedelta(minutes=10), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(hours=1), count_retweets, tweet_id)\n    scheduler.enqueue_in(timedelta(days=1), count_retweets, tweet_id)\n\n**important**: you should always use utc datetime when working with `rq scheduler`_.\n\n------------------------\nperiodic & repeated jobs\n------------------------\n\nas of version 0.3, `rq scheduler`_ also supports creating periodic and repeated jobs.\nyou can do this via the ``schedule`` method. note that this feature needs\n`rq`_ >= 0.3.1.\n\nthis is how you do it\n\n.. code-block:: python\n\n    scheduler.schedule(\n        scheduled_time=datetime.utcnow(), # time for first execution, in utc timezone\n        func=func,                     # function to be queued\n        args=[arg1, arg2],             # arguments passed into function when executed\n        kwargs={'foo': 'bar'},         # keyword arguments passed into function when executed\n        interval=60,                   # time before the function is called again, in seconds\n        repeat=10,                     # repeat this number of times (none means repeat forever)\n        meta={'foo': 'bar'}            # arbitrary pickleable data on the job itself\n    )\n\n**important note**: if you set up a repeated job, you must make sure that you\neither do not set a `result_ttl` value or you set a value larger than the interval.\notherwise, the entry with the job details will expire and the job will not get re-scheduled.\n\n------------------------\ncron jobs\n------------------------\n\nas of version 0.6.0, `rq scheduler`_ also supports creating cron jobs, which you can use for\nrepeated jobs to run periodically at fixed times, dates or intervals, for more info check\nhttps://en.wikipedia.org/wiki/cron. you can do this via the ``cron`` method.\n\nthis is how you do it\n\n.. code-block:: python\n\n    scheduler.cron(\n        cron_string,                # a cron string (e.g. \"0 0 * * 0\")\n        func=func,                  # function to be queued\n        args=[arg1, arg2],          # arguments passed into function when executed\n        kwargs={'foo': 'bar'},      # keyword arguments passed into function when executed\n        repeat=10,                  # repeat this number of times (none means repeat forever)\n        result_ttl=300              # specify how long (in seconds) successful jobs and their results are kept. defaults to -1 (forever)\n        ttl=200                     # specifies the maximum queued time (in seconds) before it's discarded. defaults to none (infinite ttl).\n        queue_name=queue_name,      # in which queue the job should be put in\n        meta={'foo': 'bar'},        # arbitrary pickleable data on the job itself\n        use_local_timezone=false    # interpret hours in the local timezone\n    )\n\n-------------------------\nretrieving scheduled jobs\n-------------------------\n\nsometimes you need to know which jobs have already been scheduled. you can get a\nlist of enqueued jobs with the ``get_jobs`` method\n\n.. code-block:: python\n\n    list_of_job_instances = scheduler.get_jobs()\n\nin it's simplest form (as seen in the above example) this method returns a list\nof all job instances that are currently scheduled for execution.\n\nadditionally the method takes two optional keyword arguments ``until`` and\n``with_times``. the first one specifies up to which point in time scheduled jobs\nshould be returned. it can be given as either a datetime / timedelta instance\nor an integer denoting the number of seconds since epoch (1970-01-01 00:00:00).\nthe second argument is a boolean that determines whether the scheduled execution\ntime should be returned along with the job instances.\n\nexample\n\n.. code-block:: python\n\n    # get all jobs until 2012-11-30 10:00:00\n    list_of_job_instances = scheduler.get_jobs(until=datetime(2012, 10, 30, 10))\n\n    # get all jobs for the next hour\n    list_of_job_instances = scheduler.get_jobs(until=timedelta(hours=1))\n\n    # get all jobs with execution times\n    jobs_and_times = scheduler.get_jobs(with_times=true)\n    # returns a list of tuples:\n    # [(<rq.job.job object at 0x123456789>, datetime.datetime(2012, 11, 25, 12, 30)), ...]\n\n------------------------------\nchecking if a job is scheduled\n------------------------------\n\nyou can check whether a specific job instance or job id is scheduled for\nexecution using the familiar python ``in`` operator\n\n.. code-block:: python\n\n    if job_instance in scheduler:\n        # do something\n    # or\n    if job_id in scheduler:\n        # do something\n\n---------------\ncanceling a job\n---------------\n\nto cancel a job, simply pass a ``job`` or a job id to ``scheduler.cancel``\n\n.. code-block:: python\n\n    scheduler.cancel(job)\n\nnote that this method returns ``none`` whether the specified job was found or not.\n\n---------------------\nrunning the scheduler\n---------------------\n\n`rq scheduler`_ comes with a script ``rqscheduler`` that runs a scheduler\nprocess that polls redis once every minute and move scheduled jobs to the\nrelevant queues when they need to be executed\n\n.. code-block:: bash\n\n    # this runs a scheduler process using the default redis connection\n    rqscheduler\n\nif you want to use a different redis server you could also do\n\n.. code-block:: bash\n\n    rqscheduler --host localhost --port 6379 --db 0\n\nthe script accepts these arguments:\n\n* ``-h`` or ``--host``: redis server to connect to\n* ``-p`` or ``--port``: port to connect to\n* ``-d`` or ``--db``: redis db to use\n* ``-p`` or ``--password``: password to connect to redis\n* ``-b`` or ``--burst``: runs in burst mode (enqueue scheduled jobs whose execution time is in the past and quit)\n* ``-i interval`` or ``--interval interval``: how often the scheduler checks for new jobs to add to the queue (in seconds, can be floating-point for more precision).\n* ``-j`` or ``--job-class``: specify custom job class for rq to use (python module.class)\n* ``-q`` or ``--queue-class``: specify custom queue class for rq to use (python module.class)\n\nthe arguments pull default values from environment variables with the\nsame names but with a prefix of ``rq_redis_``.\n\nrunning the scheduler as a service on ubuntu\n--------------------------------------------\n\nsudo /etc/systemd/system/rqscheduler.service\n\n.. code-block:: bash\n\n    [unit]\n    description=rqscheduler\n    after=network.target\n\n    [service]\n    execstart=/home/<<user>>/.virtualenvs/<<yourvirtualenv>>/bin/python \\\n        /home/<<user>>/.virtualenvs/<<yourvirtualenv>>/lib/<<yourpythonversion>>/site-packages/rq_scheduler/scripts/rqscheduler.py\n\n    [install]\n    wantedby=multi-user.target\n\nyou will also want to add any command line parameters if your configuration is not localhost or not set in the environment variables.\n\nstart, check status and enable the service\n\n.. code-block:: bash\n\n    sudo systemctl start rqscheduler.service\n    sudo systemctl status rqscheduler.service\n    sudo systemctl enable rqscheduler.service\n\n---------------------------\nrunning multiple schedulers\n---------------------------\n\nmultiple instances of the rq-scheduler can be run simultaneously. it allows for\n\n* reliability (no single point of failure)\n* failover (scheduler instances automatically retry to attain lock and schedule jobs)\n* running scheduler on multiple server instances to make deployment identical and easier\n\nmultiple schedulers can be run in any way you want. typically you'll only want to run one scheduler per server/instance.\n\n.. code-block:: bash\n\n   rqscheduler -i 5\n\n   # another shell/systemd service or ideally another server\n   rqscheduler -i 5\n\n   # different parameters can be provided to different schedulers\n   rqscheduler -i 10\n\n**practical example**:\n\n- ``scheduler_a`` is running on ``ec2_instance_a``\n- if ``scheduler_a`` crashes or ``ec2_instance_a`` goes down, then our tasks won't be scheduled at all\n- instead we can simply run 2 schedulers. another scheduler called ``scheduler_b`` can be run on ``ec2_instance_b``\n- now both ``scheduler_a`` and ``scheduler_b`` will periodically check and schedule the jobs\n- if one fails, the other still works\n\nyou can read more about multiple schedulers in `#212 <https://github.com/rq/rq-scheduler/pull/212>`_ and `#195 <https://github.com/rq/rq-scheduler/issues/195>`_\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "rq-scheduler",
  "package_url": "https://pypi.org/project/rq-scheduler/",
  "project_url": "https://pypi.org/project/rq-scheduler/",
  "project_urls": {
    "Homepage": "https://github.com/rq/rq-scheduler"
  },
  "release_url": "https://pypi.org/project/rq-scheduler/0.13.1/",
  "requires_dist": [
    "crontab (>=0.23.0)",
    "rq (>=0.13)",
    "python-dateutil",
    "freezegun"
  ],
  "requires_python": "",
  "summary": "provides job scheduling capabilities to rq (redis queue)",
  "version": "0.13.1",
  "releases": [],
  "developers": [
    "selwin.ong@gmail.com",
    "selwin_ong"
  ],
  "kwds": "rq_scheduler scheduling scheduler_a scheduler schedulers",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_rq_scheduler",
  "homepage": "https://github.com/rq/rq-scheduler",
  "release_count": 25,
  "dependency_ids": [
    "pypi_crontab",
    "pypi_freezegun",
    "pypi_python_dateutil",
    "pypi_rq"
  ]
}