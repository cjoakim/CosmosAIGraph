{
  "classifiers": [],
  "description": "# atheris: a coverage-guided, native python fuzzer\n\natheris is a coverage-guided python fuzzing engine. it supports fuzzing of python code, but also native extensions written for cpython. atheris is based off of libfuzzer. when fuzzing native code, atheris can be used in combination with address sanitizer or undefined behavior sanitizer to catch extra bugs.\n\n## installation instructions\n\natheris supports linux (32- and 64-bit) and mac os x, python versions 3.6-3.10.\n\nyou can install prebuilt versions of atheris with pip:\n\n```bash\npip3 install atheris\n```\n\nthese wheels come with a built-in libfuzzer, which is fine for fuzzing python\ncode. if you plan to fuzz native extensions, you may need to build from source\nto ensure the libfuzzer version in atheris matches your clang version.\n\n### building from source\n\natheris relies on libfuzzer, which is distributed with clang. if you have a sufficiently new version of `clang` on your path, installation from source is as simple as:\n\n```bash\n# build latest release from source\npip3 install --no-binary atheris atheris\n# build development code from source\ngit clone https://github.com/google/atheris.git\ncd atheris\npip3 install .\n```\n\nif you don't have `clang` installed or it's too old, you'll need to download and build the latest version of llvm. follow the instructions in installing against new llvm below.\n\n#### mac\n\napple clang doesn't come with libfuzzer, so you'll need to install a new version of llvm from head. follow the instructions in installing against new llvm below.\n\n#### installing against new llvm\n\n```bash\n# building llvm\ngit clone https://github.com/llvm/llvm-project.git\ncd llvm-project\nmkdir build\ncd build\ncmake -dllvm_enable_projects='clang;compiler-rt' -g \"unix makefiles\" ../llvm\nmake -j 10  # this step is very slow\n\n# installing atheris\nclang_bin=\"$(pwd)/bin/clang\" pip3 install <whatever>\n```\n\n## using atheris\n\n### example\n\n```python\n#!/usr/bin/python3\n\nimport atheris\n\nwith atheris.instrument_imports():\n  import some_library\n  import sys\n\ndef testoneinput(data):\n  some_library.parse(data)\n\natheris.setup(sys.argv, testoneinput)\natheris.fuzz()\n```\n\nwhen fuzzing python, atheris will report a failure if the python code under test throws an uncaught exception.\n\n### python coverage\n\natheris collects python coverage information by instrumenting bytecode.\nthere are 3 options for adding this instrumentation to the bytecode:\n\n - you can instrument the libraries you import:\n\n   ```python\n   with atheris.instrument_imports():\n     import foo\n     from bar import baz\n   ```\n   this will cause instrumentation to be added to `foo` and `bar`, as well as\n   any libraries they import.\n - or, you can instrument individual functions:\n\n   ```python\n   @atheris.instrument_func\n   def my_function(foo, bar):\n     print(\"instrumented\")\n   ```\n - or finally, you can instrument everything:\n\n   ```python\n   atheris.instrument_all()\n   ```\n   put this right before `atheris.setup()`. this will find every python function\n   currently loaded in the interpreter, and instrument it.\n   this might take a while.\n\natheris can additionally instrument regular expression checks, e.g. `re.search`.\nto enable this feature, you will need to add:\n`atheris.enabled_hooks.add(\"regex\")`\nto your script before your code calls `re.compile`.\ninternally this will import the `re` module and instrument the necessary functions.\nthis is currently an experimental feature.\n\nsimilarly, atheris can instrument str methods; currently only `str.startswith`\nand `str.endswith` are supported. to enable this feature, add\n`atheris.enabled_hooks.add(\"str\")`. this is currently an experimental feature.\n\n#### why am i getting \"no interesting inputs were found\"?\n\nyou might see this error:\n\n```\nerror: no interesting inputs were found. is the code instrumented for coverage? exiting.\n```\n\nyou'll get this error if the first 2 calls to `testoneinput` didn't produce any\ncoverage events. even if you have instrumented some python code,\nthis can happen if the instrumentation isn't reached in those first 2 calls.\n(for example, because you have a nontrivial `testoneinput`). you can resolve\nthis by adding an `atheris.instrument_func` decorator to `testoneinput`,\nusing `atheris.instrument_all()`, or moving your `testoneinput` function into an\ninstrumented module.\n\n\n### visualizing python code coverage\nexamining which lines are executed is helpful for understanding the\neffectiveness of your fuzzer. atheris is compatible with\n[`coverage.py`](https://coverage.readthedocs.io/): you can run your fuzzer using\nthe `coverage.py` module as you would for any other python program. here's an\nexample:\n\n```bash\npython3 -m coverage run your_fuzzer.py -atheris_runs=10000  # times to run\npython3 -m coverage html\n(cd htmlcov && python3 -m http.server 8000)\n```\n\ncoverage reports are only generated when your fuzzer exits gracefully. this\nhappens if:\n\n - you specify `-atheris_runs=<number>`, and that many runs have elapsed.\n - your fuzzer exits by python exception.\n - your fuzzer exits by `sys.exit()`.\n\nno coverage report will be generated if your fuzzer exits due to a\ncrash in native code, or due to libfuzzer's `-runs` flag (use `-atheris_runs`).\nif your fuzzer exits via other methods, such as sigint (ctrl+c), atheris will\nattempt to generate a report but may be unable to (depending on your code).\nfor consistent reports, we recommend always using\n`-atheris_runs=<number>`.\n\nif you'd like to examine coverage when running with your corpus, you can do\nthat with the following command:\n\n```\npython3 -m coverage run your_fuzzer.py corpus_dir/* -atheris_runs=$(( 1 + $(ls corpus_dir | wc -l) ))\n```\n\nthis will cause atheris to run on each file in `<corpus-dir>`, then exit.\nnote: atheris use empty data set as the first input even if there is no empty file in `<corpus_dir>`.\nimportantly, if you leave off the `-atheris_runs=$(ls corpus_dir | wc -l)`, no\ncoverage report will be generated.\n\nusing coverage.py will significantly slow down your fuzzer, so only use it for\nvisualizing coverage; don't use it all the time.\n\n### fuzzing native extensions\n\nin order for fuzzing native extensions to be effective, your native extensions\nmust be instrumented. see [native extension fuzzing](https://github.com/google/atheris/blob/master/native_extension_fuzzing.md)\nfor instructions.\n\n### structure-aware fuzzing\n\natheris is based on a coverage-guided mutation-based fuzzer (libfuzzer). this\nhas the advantage of not requiring any grammar definition for generating inputs,\nmaking its setup easier. the disadvantage is that it will be harder for the\nfuzzer to generate inputs for code that parses complex data types. often the\ninputs will be rejected early, resulting in low coverage.\n\natheris supports custom mutators\n[(as offered by libfuzzer)](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md)\nto produce grammar-aware inputs.\n\nexample (atheris-equivalent of the\n[example in the libfuzzer docs](https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md#example-compression)):\n\n```python\n@atheris.instrument_func\ndef testoneinput(data):\n  try:\n    decompressed = zlib.decompress(data)\n  except zlib.error:\n    return\n\n  if len(decompressed) < 2:\n    return\n\n  try:\n    if decompressed.decode() == 'fu':\n      raise runtimeerror('boom')\n  except unicodedecodeerror:\n    pass\n```\n\nto reach the `runtimeerror` crash, the fuzzer needs to be able to produce inputs\nthat are valid compressed data and satisfy the checks after decompression.\nit is very unlikely that atheris will be able to produce such inputs: mutations\non the input data will most probably result in invalid data that will fail at\ndecompression-time.\n\nto overcome this issue, you can define a custom mutator function (equivalent to\n`llvmfuzzercustommutator`).\nthis example produces valid compressed data. to enable atheris to make use of\nit, pass the custom mutator function to the invocation of `atheris.setup`.\n\n```python\ndef custommutator(data, max_size, seed):\n  try:\n    decompressed = zlib.decompress(data)\n  except zlib.error:\n    decompressed = b'hi'\n  else:\n    decompressed = atheris.mutate(decompressed, len(decompressed))\n  return zlib.compress(decompressed)\n\natheris.setup(sys.argv, testoneinput, custom_mutator=custommutator)\natheris.fuzz()\n```\n\nas seen in the example, the custom mutator may request atheris to mutate data\nusing `atheris.mutate()` (this is equivalent to `llvmfuzzermutate`).\n\nyou can experiment with [custom_mutator_example.py](example_fuzzers/custom_mutator_example.py)\nand see that without the mutator atheris would not be able to find the crash,\nwhile with the mutator this is achieved in a matter of seconds.\n\n```shell\n$ python3 example_fuzzers/custom_mutator_example.py --no_mutator\n[...]\n#2      inited cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 37mb\n#524288 pulse  cov: 2 ft: 2 corp: 1/1b lim: 4096 exec/s: 262144 rss: 37mb\n#1048576        pulse  cov: 2 ft: 2 corp: 1/1b lim: 4096 exec/s: 349525 rss: 37mb\n#2097152        pulse  cov: 2 ft: 2 corp: 1/1b lim: 4096 exec/s: 299593 rss: 37mb\n#4194304        pulse  cov: 2 ft: 2 corp: 1/1b lim: 4096 exec/s: 279620 rss: 37mb\n[...]\n\n$ python3 example_fuzzers/custom_mutator_example.py\n[...]\ninfo: found llvmfuzzercustommutator (0x7f9c989fb0d0). disabling -len_control by default.\n[...]\n#2      inited cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 37mb\n#3      new    cov: 4 ft: 4 corp: 2/11b lim: 4096 exec/s: 0 rss: 37mb l: 10/10 ms: 1 custom-\n#12     new    cov: 5 ft: 5 corp: 3/21b lim: 4096 exec/s: 0 rss: 37mb l: 10/10 ms: 7 custom-crossover-custom-crossover-custom-changebit-custom-\n === uncaught python exception: ===\nruntimeerror: boom\ntraceback (most recent call last):\n  file \"example_fuzzers/custom_mutator_example.py\", line 62, in testoneinput\n    raise runtimeerror('boom')\n[...]\n```\n\ncustom crossover functions (equivalent to `llvmfuzzercustomcrossover`) are also\nsupported. you can pass the custom crossover function to the invocation of\n`atheris.setup`. see its usage in [custom_crossover_fuzz_test.py](src/custom_crossover_fuzz_test.py).\n\n#### structure-aware fuzzing with protocol buffers\n\n[libprotobuf-mutator](https://github.com/google/libprotobuf-mutator) has\nbindings to use it together with atheris to perform structure-aware fuzzing\nusing protocol buffers.\n\nsee the documentation for\n[atheris_libprotobuf_mutator](contrib/libprotobuf_mutator/readme.md).\n\n## integration with oss-fuzz\n\natheris is fully supported by [oss-fuzz](https://github.com/google/oss-fuzz), google's continuous fuzzing service for open source projects. for integrating with oss-fuzz, please see [https://google.github.io/oss-fuzz/getting-started/new-project-guide/python-lang](https://google.github.io/oss-fuzz/getting-started/new-project-guide/python-lang).\n\n## api\n\nthe `atheris` module provides three key functions: `instrument_imports()`, `setup()` and `fuzz()`.\n\nin your source file, import all libraries you wish to fuzz inside a `with atheris.instrument_imports():`-block, like this:\n\n```python\n# library_a will not get instrumented\nimport library_a\n\nwith atheris.instrument_imports():\n    # library_b will get instrumented\n    import library_b\n```\n\ngenerally, it's best to import `atheris` first and then import all other libraries inside of a `with atheris.instrument_imports()` block.\n\nnext, define a fuzzer entry point function and pass it to `atheris.setup()` along with the fuzzer's arguments (typically `sys.argv`). finally, call `atheris.fuzz()` to start fuzzing. you must call `atheris.setup()` before `atheris.fuzz()`.\n\n#### `instrument_imports(include=[], exclude=[])`\n- `include`: a list of fully-qualified module names that shall be instrumented.\n- `exclude`: a list of fully-qualified module names that shall not be instrumented.\n\nthis should be used together with a `with`-statement. all modules imported in\nsaid statement will be instrumented. however, because python imports all modules\nonly once, this cannot be used to instrument any previously imported module,\nincluding modules required by atheris. to add coverage to those modules, use\n`instrument_all()` instead.\n\na full list of unsupported modules can be retrieved as follows:\n\n```python\nimport sys\nimport atheris\nprint(sys.modules.keys())\n```\n\n\n#### `instrument_func(func)`\n - `func`: the function to instrument.\n\nthis will instrument the specified python function and then return `func`. this\nis typically used as a decorator, but can be used to instrument individual\nfunctions too. note that the `func` is instrumented in-place, so this will\naffect all call points of the function.\n\nthis cannot be called on a bound method - call it on the unbound version.\n\n#### `instrument_all()`\n\nthis will scan over all objects in the interpreter and call `instrument_func` on\nevery python function. this works even on core python interpreter functions,\nsomething which `instrument_imports` cannot do.\n\nthis function is experimental.\n\n\n#### `setup(args, test_one_input, internal_libfuzzer=none)`\n - `args`: a list of strings: the process arguments to pass to the fuzzer, typically `sys.argv`. this argument list may be modified in-place, to remove arguments consumed by the fuzzer.\n   see [the libfuzzer docs](https://llvm.org/docs/libfuzzer.html#options) for a list of such options.\n - `test_one_input`: your fuzzer's entry point. must take a single `bytes` argument. this will be repeatedly invoked with a single bytes container.\n - `internal_libfuzzer`: indicates whether libfuzzer will be provided by atheris or by an external library (see [native_extension_fuzzing.md](./native_extension_fuzzing.md)). if unspecified, atheris will determine this\n   automatically. if fuzzing pure python, leave this as `true`.\n\n#### `fuzz()`\n\nthis starts the fuzzer. you must have called `setup()` before calling this function. this function does not return.\n\nin many cases `setup()` and `fuzz()` could be combined into a single function, but they are\nseparated because you may want the fuzzer to consume the command-line arguments it handles\nbefore passing any remaining arguments to another setup function.\n\n#### `fuzzeddataprovider`\n\noften, a `bytes` object is not convenient input to your code being fuzzed. similar to libfuzzer, we provide a fuzzeddataprovider to translate these bytes into other input forms.\n\nyou can construct the fuzzeddataprovider with:\n\n```python\nfdp = atheris.fuzzeddataprovider(input_bytes)\n```\n\nthe fuzzeddataprovider then supports the following functions:\n\n```python\ndef consumebytes(count: int)\n```\nconsume `count` bytes.\n\n\n```python\ndef consumeunicode(count: int)\n```\n\nconsume unicode characters. might contain surrogate pair characters, which according to the specification are invalid in this situation. however, many core software tools (e.g. windows file paths) support them, so other software often needs to too.\n\n```python\ndef consumeunicodenosurrogates(count: int)\n```\n\nconsume unicode characters, but never generate surrogate pair characters.\n\n```python\ndef consumestring(count: int)\n```\n\nalias for `consumebytes` in python 2, or `consumeunicode` in python 3.\n\n```python\ndef consumeint(int: bytes)\n```\n\nconsume a signed integer of the specified size (when written in two's complement notation).\n\n```python\ndef consumeuint(int: bytes)\n```\n\nconsume an unsigned integer of the specified size.\n\n```python\ndef consumeintinrange(min: int, max: int)\n```\n\nconsume an integer in the range [`min`, `max`].\n\n```python\ndef consumeintlist(count: int, bytes: int)\n```\n\nconsume a list of `count` integers of `size` bytes.\n\n```python\ndef consumeintlistinrange(count: int, min: int, max: int)\n```\n\nconsume a list of `count` integers in the range [`min`, `max`].\n\n```python\ndef consumefloat()\n```\n\nconsume an arbitrary floating-point value. might produce weird values like `nan` and `inf`.\n\n```python\ndef consumeregularfloat()\n```\n\nconsume an arbitrary numeric floating-point value; never produces a special type like `nan` or `inf`.\n\n```python\ndef consumeprobability()\n```\n\nconsume a floating-point value in the range [0, 1].\n\n```python\ndef consumefloatinrange(min: float, max: float)\n```\n\nconsume a floating-point value in the range [`min`, `max`].\n\n```python\ndef consumefloatlist(count: int)\n```\n\nconsume a list of `count` arbitrary floating-point values. might produce weird values like `nan` and `inf`.\n\n```python\ndef consumeregularfloatlist(count: int)\n```\n\nconsume a list of `count` arbitrary numeric floating-point values; never produces special types like `nan` or `inf`.\n\n```python\ndef consumeprobabilitylist(count: int)\n```\n\nconsume a list of `count` floats in the range [0, 1].\n\n```python\ndef consumefloatlistinrange(count: int, min: float, max: float)\n```\n\nconsume a list of `count` floats in the range [`min`, `max`]\n\n```python\ndef pickvalueinlist(l: list)\n```\n\ngiven a list, pick a random value\n\n```python\ndef consumebool()\n```\n\nconsume either `true` or `false`.\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "atheris",
  "package_url": "https://pypi.org/project/atheris/",
  "project_url": "https://pypi.org/project/atheris/",
  "project_urls": {
    "Homepage": "https://github.com/google/atheris/"
  },
  "release_url": "https://pypi.org/project/atheris/2.3.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "a coverage-guided fuzzer for python and python extensions.",
  "version": "2.3.0",
  "releases": [],
  "developers": [
    "atheris@google.com",
    "bitshift"
  ],
  "kwds": "atheris_libprotobuf_mutator atheris_runs native_extension_fuzzing atheris fuzzing",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_atheris",
  "homepage": "https://github.com/google/atheris/",
  "release_count": 29,
  "dependency_ids": []
}