{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment",
    "framework :: django",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "rules\n^^^^^\n\n``rules`` is a tiny but powerful app providing object-level permissions to\ndjango, without requiring a database. at its core, it is a generic framework\nfor building rule-based systems, similar to `decision trees`_. it can also be\nused as a standalone library in other contexts and frameworks.\n\n.. image:: https://img.shields.io/github/workflow/status/dfunckt/django-rules/ci/master\n    :target: https://github.com/dfunckt/django-rules/actions\n.. image:: https://coveralls.io/repos/dfunckt/django-rules/badge.svg\n    :target: https://coveralls.io/r/dfunckt/django-rules\n.. image:: https://img.shields.io/pypi/v/rules.svg\n    :target: https://pypi.org/project/rules/\n.. image:: https://img.shields.io/pypi/pyversions/rules.svg\n    :target: https://pypi.org/project/rules/\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/psf/black\n.. image:: https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logocolor=white\n    :target: https://github.com/pre-commit/pre-commit\n\n.. _decision trees: http://wikipedia.org/wiki/decision_tree\n\n\nfeatures\n========\n\n``rules`` has got you covered. ``rules`` is:\n\n-   **documented**, **tested**, **reliable** and **easy to use**.\n-   **versatile**. decorate callables to build complex graphs of predicates.\n    predicates can be any type of callable -- simple functions, lambdas,\n    methods, callable class objects, partial functions, decorated functions,\n    anything really.\n-   **a good django citizen**. seamless integration with django views,\n    templates and the admin for testing for object-level permissions.\n-   **efficient** and **smart**. no need to mess around with a database to figure\n    out whether john really wrote that book.\n-   **simple**. dive in the code. you'll need 10 minutes to figure out how it\n    works.\n-   **powerful**. ``rules`` comes complete with advanced features, such as\n    invocation context and storage for arbitrary data, skipping evaluation of\n    predicates under specific conditions, logging of evaluated predicates and more!\n\n\ntable of contents\n=================\n\n- `requirements`_\n- `upgrading from 2.x`_\n- `upgrading from 1.x`_\n- `how to install`_\n\n  - `configuring django`_\n\n- `using rules`_\n\n  - `creating predicates`_\n  - `setting up rules`_\n  - `combining predicates`_\n\n- `using rules with django`_\n\n  - `permissions`_\n  - `permissions in models`_\n  - `permissions in views`_\n  - `permissions and rules in templates`_\n  - `permissions in the admin`_\n  - `permissions in django rest framework`_\n\n- `advanced features`_\n\n  - `custom rule sets`_\n  - `invocation context`_\n  - `binding \"self\"`_\n  - `skipping predicates`_\n  - `logging predicate evaluation`_\n\n- `best practices`_\n- `api reference`_\n- `licence`_\n\n\nrequirements\n============\n\n``rules`` requires python 3.7 or newer. the last version to support python 2.7\nis ``rules`` 2.2. it can optionally integrate with django, in which case\nrequires django 2.2 or newer.\n\n*note*: at any given moment in time, ``rules`` will maintain support for all\ncurrently supported django versions, while dropping support for those versions\nthat reached end-of-life in minor releases. see the `supported versions`_\nsection on django project website for the current state and timeline.\n\n.. _supported versions: https://www.djangoproject.com/download/#supported-versions\n\n\nupgrading from 2.x\n==================\n\nthe are no significant changes between ``rules`` 2.x and 3.x except dropping\nsupport for python 2, so before upgrading to 3.x you just need to make sure\nyou're running a supported python 3 version.\n\n\nupgrading from 1.x\n==================\n\n*   support for python 2.6 and 3.3, and django versions before 1.11 has been\n    dropped.\n\n*   the ``skippredicate`` exception and ``skip()`` method of ``predicate``,\n    that were used to signify that a predicate should be skipped, have been\n    removed. you may return ``none`` from your predicate to achieve this.\n\n*   the apis to replace a rule's predicate have been renamed and their\n    behaviour changed. ``replace_rule`` and ``replace_perm`` functions and\n    ``replace_rule`` method of ``ruleset`` have been renamed to ``set_rule``,\n    ``set_perm`` and ``ruleset.set_perm`` respectively. the old behaviour was\n    to raise a ``keyerror`` if a rule by the given name did not exist. since\n    version 2.0 this has changed and you can safely use ``set_*`` to set a\n    rule's predicate without having to ensure the rule exists first.\n\n\nhow to install\n==============\n\nusing pip:\n\n.. code:: bash\n\n    $ pip install rules\n\nmanually:\n\n.. code:: bash\n\n    $ git clone https://github.com/dfunckt/django-rules.git\n    $ cd django-rules\n    $ python setup.py install\n\nrun tests with:\n\n.. code:: bash\n\n    $ ./runtests.sh\n\nyou may also want to read `best practices`_ for general advice on how to\nuse ``rules``.\n\n\nconfiguring django\n------------------\n\nadd ``rules`` to ``installed_apps``:\n\n.. code:: python\n\n    installed_apps = (\n        # ...\n        'rules',\n    )\n\nadd the authentication backend:\n\n.. code:: python\n\n    authentication_backends = (\n        'rules.permissions.objectpermissionbackend',\n        'django.contrib.auth.backends.modelbackend',\n    )\n\n\nusing rules\n===========\n\n``rules`` is based on the idea that you maintain a dict-like object that maps\nstring keys used as identifiers of some kind, to callables, called\n*predicates*. this dict-like object is actually an instance of ``ruleset`` and\nthe predicates are instances of ``predicate``.\n\n\ncreating predicates\n-------------------\n\nlet's ignore rule sets for a moment and go ahead and define a predicate. the\neasiest way is with the ``@predicate`` decorator:\n\n.. code:: python\n\n    >>> @rules.predicate\n    >>> def is_book_author(user, book):\n    ...     return book.author == user\n    ...\n    >>> is_book_author\n    <predicate:is_book_author object at 0x10eeaa490>\n\nthis predicate will return ``true`` if the book's author is the given user,\n``false`` otherwise.\n\npredicates can be created from any callable that accepts anything from zero to\ntwo positional arguments:\n\n*   ``fn(obj, target)``\n*   ``fn(obj)``\n*   ``fn()``\n\nthis is their generic form. if seen from the perspective of authorization in\ndjango, the equivalent signatures are:\n\n*   ``fn(user, obj)``\n*   ``fn(user)``\n*   ``fn()``\n\npredicates can do pretty much anything with the given arguments, but must\nalways return ``true`` if the condition they check is true, ``false``\notherwise. ``rules`` comes with several predefined predicates that you may\nread about later on in `api reference`_, that are mostly useful when dealing\nwith `authorization in django`_.\n\n\nsetting up rules\n----------------\n\nlet's pretend that we want to let authors edit or delete their books, but not\nbooks written by other authors. so, essentially, what determines whether an\nauthor *can edit* or *can delete* a given book is *whether they are its\nauthor*.\n\nin ``rules``, such requirements are modelled as *rules*. a *rule* is a map of\na unique identifier (eg. \"can edit\") to a predicate. rules are grouped\ntogether into a *rule set*. ``rules`` has two predefined rule sets:\n\n*   a default rule set storing shared rules.\n*   another rule set storing rules that serve as permissions in a django\n    context.\n\nso, let's define our first couple of rules, adding them to the shared rule\nset. we can use the ``is_book_author`` predicate we defined earlier:\n\n.. code:: python\n\n    >>> rules.add_rule('can_edit_book', is_book_author)\n    >>> rules.add_rule('can_delete_book', is_book_author)\n\nassuming we've got some data, we can now test our rules:\n\n.. code:: python\n\n    >>> from django.contrib.auth.models import user\n    >>> from books.models import book\n    >>> guidetodjango = book.objects.get(isbn='978-1-4302-1936-1')\n    >>> guidetodjango.author\n    <user: adrian>\n    >>> adrian = user.objects.get(username='adrian')\n    >>> rules.test_rule('can_edit_book', adrian, guidetodjango)\n    true\n    >>> rules.test_rule('can_delete_book', adrian, guidetodjango)\n    true\n\nnice... but not awesome.\n\n\ncombining predicates\n--------------------\n\npredicates by themselves are not so useful -- not more useful than any other\nfunction would be. predicates, however, can be combined using binary operators\nto create more complex ones. predicates support the following operators:\n\n*   ``p1 & p2``: returns a new predicate that returns ``true`` if *both*\n    predicates return ``true``, otherwise ``false``. if p1 returns ``false``,\n    p2 will not be evaluated.\n*   ``p1 | p2``: returns a new predicate that returns ``true`` if *any* of the\n    predicates returns ``true``, otherwise ``false``. if p1 returns ``true``,\n    p2 will not be evaluated.\n*   ``p1 ^ p2``: returns a new predicate that returns ``true`` if one of the\n    predicates returns ``true`` and the other returns ``false``, otherwise\n    ``false``.\n*   ``~p``: returns a new predicate that returns the negated result of the\n    original predicate.\n\nsuppose the requirement for allowing a user to edit a given book was for them\nto be either the book's author, or a member of the \"editors\" group. allowing\nusers to delete a book should still be determined by whether the user is the\nbook's author.\n\nwith ``rules`` that's easy to implement. we'd have to define another\npredicate, that would return ``true`` if the given user is a member of the\n\"editors\" group, ``false`` otherwise. the built-in ``is_group_member`` factory\nwill come in handy:\n\n.. code:: python\n\n    >>> is_editor = rules.is_group_member('editors')\n    >>> is_editor\n    <predicate:is_group_member:editors object at 0x10eee1350>\n\nwe could combine it with the ``is_book_author`` predicate to create a new one\nthat checks for either condition:\n\n.. code:: python\n\n    >>> is_book_author_or_editor = is_book_author | is_editor\n    >>> is_book_author_or_editor\n    <predicate:(is_book_author | is_group_member:editors) object at 0x10eee1390>\n\nwe can now update our ``can_edit_book`` rule:\n\n.. code:: python\n\n    >>> rules.set_rule('can_edit_book', is_book_author_or_editor)\n    >>> rules.test_rule('can_edit_book', adrian, guidetodjango)\n    true\n    >>> rules.test_rule('can_delete_book', adrian, guidetodjango)\n    true\n\nlet's see what happens with another user:\n\n.. code:: python\n\n    >>> martin = user.objects.get(username='martin')\n    >>> list(martin.groups.values_list('name', flat=true))\n    ['editors']\n    >>> rules.test_rule('can_edit_book', martin, guidetodjango)\n    true\n    >>> rules.test_rule('can_delete_book', martin, guidetodjango)\n    false\n\nawesome.\n\nso far, we've only used the underlying, generic framework for defining and\ntesting rules. this layer is not at all specific to django; it may be used in\nany context. there's actually no import of anything django-related in the\nwhole app (except in the ``rules.templatetags`` module). ``rules`` however can\nintegrate tightly with django to provide authorization.\n\n\n.. _authorization in django:\n\nusing rules with django\n=======================\n\n``rules`` is able to provide object-level permissions in django. it comes\nwith an authorization backend and a couple template tags for use in your\ntemplates.\n\n\npermissions\n-----------\n\nin ``rules``, permissions are a specialised type of rules. you still define\nrules by creating and combining predicates. these rules however, must be added\nto a permissions-specific rule set that comes with ``rules`` so that they can\nbe picked up by the ``rules`` authorization backend.\n\n\ncreating permissions\n++++++++++++++++++++\n\nthe convention for naming permissions in django is ``app_label.action_object``,\nand we like to adhere to that. let's add rules for the ``books.change_book``\nand ``books.delete_book`` permissions:\n\n.. code:: python\n\n    >>> rules.add_perm('books.change_book', is_book_author | is_editor)\n    >>> rules.add_perm('books.delete_book', is_book_author)\n\nsee the difference in the api? ``add_perm`` adds to a permissions-specific\nrule set, whereas ``add_rule`` adds to a default shared rule set. it's\nimportant to know however, that these two rule sets are separate, meaning that\nadding a rule in one does not make it available to the other.\n\n\nchecking for permission\n+++++++++++++++++++++++\n\nlet's go ahead and check whether ``adrian`` has change permission to the\n``guidetodjango`` book:\n\n.. code:: python\n\n    >>> adrian.has_perm('books.change_book', guidetodjango)\n    false\n\nwhen you call the ``user.has_perm`` method, django asks each backend in\n``settings.authentication_backends`` whether a user has the given permission\nfor the object. when queried for object permissions, django's default\nauthentication backend always returns ``false``. ``rules`` comes with an\nauthorization backend, that is able to provide object-level permissions by\nlooking into the permissions-specific rule set.\n\nlet's add the ``rules`` authorization backend in settings:\n\n.. code:: python\n\n    authentication_backends = (\n        'rules.permissions.objectpermissionbackend',\n        'django.contrib.auth.backends.modelbackend',\n    )\n\nnow, checking again gives ``adrian`` the required permissions:\n\n.. code:: python\n\n    >>> adrian.has_perm('books.change_book', guidetodjango)\n    true\n    >>> adrian.has_perm('books.delete_book', guidetodjango)\n    true\n    >>> martin.has_perm('books.change_book', guidetodjango)\n    true\n    >>> martin.has_perm('books.delete_book', guidetodjango)\n    false\n\n**note:** calling `has_perm` on a superuser will always return `true`.\n\npermissions in models\n---------------------\n\n**note:** the features described in this section work on python 3+ only.\n\nit is common to have a set of permissions for a model, like what django offers with\nits default model permissions (such as *add*, *change* etc.). when using ``rules``\nas the permission checking backend, you can declare object-level permissions for\nany model in a similar way, using a new ``meta`` option.\n\nfirst, you need to switch your model's base and metaclass to the slightly extended\nversions provided in ``rules.contrib.models``. there are several classes and mixins\nyou can use, depending on whether you're already using a custom base and/or metaclass\nfor your models or not. the extensions are very slim and don't affect the models'\nbehavior in any way other than making it register permissions.\n\n* if you're using the stock ``django.db.models.model`` as base for your models,\n  simply switch over to ``rulesmodel`` and you're good to go.\n\n* if you already have a custom base class adding common functionality to your models,\n  add ``rulesmodelmixin`` to the classes it inherits from and set ``rulesmodelbase``\n  as its metaclass, like so::\n\n      from django.db.models import model\n      from rules.contrib.models import rulesmodelbase, rulesmodelmixin\n\n      class mymodel(rulesmodelmixin, model, metaclass=rulesmodelbase):\n          ...\n\n* if you're using a custom metaclass for your models, you'll already know how to\n  make it inherit from ``rulesmodelbasemixin`` yourself.\n\nthen, create your models like so, assuming you're using ``rulesmodel`` as base\ndirectly::\n\n    import rules\n    from rules.contrib.models import rulesmodel\n\n    class book(rulesmodel):\n        class meta:\n            rules_permissions = {\n                \"add\": rules.is_staff,\n                \"read\": rules.is_authenticated,\n            }\n\nthis would be equivalent to the following calls::\n\n    rules.add_perm(\"app_label.add_book\", rules.is_staff)\n    rules.add_perm(\"app_label.read_book\", rules.is_authenticated)\n\nthere are methods in ``rulesmodelmixin`` that you can overwrite in order to customize\nhow a model's permissions are registered. see the documented source code for details\nif you need this.\n\nof special interest is the ``get_perm`` classmethod of ``rulesmodelmixin``, which can\nbe used to convert a permission type to the corresponding full permission name. if\nyou need to query for some type of permission on a given model programmatically,\nthis is handy::\n\n    if user.has_perm(book.get_perm(\"read\")):\n        ...\n\n\npermissions in views\n--------------------\n\n``rules`` comes with a set of view decorators to help you enforce\nauthorization in your views.\n\nusing the function-based view decorator\n+++++++++++++++++++++++++++++++++++++++\n\nfor function-based views you can use the ``permission_required`` decorator:\n\n.. code:: python\n\n    from django.shortcuts import get_object_or_404\n    from rules.contrib.views import permission_required\n    from posts.models import post\n\n    def get_post_by_pk(request, post_id):\n        return get_object_or_404(post, pk=post_id)\n\n    @permission_required('posts.change_post', fn=get_post_by_pk)\n    def post_update(request, post_id):\n        # ...\n\nusage is straight-forward, but there's one thing in the example above that\nstands out and this is the ``get_post_by_pk`` function. this function, given\nthe current request and all arguments passed to the view, is responsible for\nfetching and returning the object to check permissions against -- i.e. the\n``post`` instance with pk equal to the given ``post_id`` in the example.\nthis specific use-case is quite common so, to save you some typing, ``rules``\ncomes with a generic helper function that you can use to do this declaratively.\nthe example below is equivalent to the one above:\n\n.. code:: python\n\n    from rules.contrib.views import permission_required, objectgetter\n    from posts.models import post\n\n    @permission_required('posts.change_post', fn=objectgetter(post, 'post_id'))\n    def post_update(request, post_id):\n        # ...\n\nfor more information on the decorator and helper function, refer to the\n``rules.contrib.views`` module.\n\nusing the class-based view mixin\n++++++++++++++++++++++++++++++++\n\ndjango includes a set of access mixins that you can use in your class-based\nviews to enforce authorization. ``rules`` extends this framework to provide\nobject-level permissions via a mixin, ``permissionrequiredmixin``.\n\nthe following example will automatically test for permission against the\ninstance returned by the view's ``get_object`` method:\n\n.. code:: python\n\n    from django.views.generic.edit import updateview\n    from rules.contrib.views import permissionrequiredmixin\n    from posts.models import post\n\n    class postupdate(permissionrequiredmixin, updateview):\n        model = post\n        permission_required = 'posts.change_post'\n\nyou can customise the object either by overriding ``get_object`` or\n``get_permission_object``.\n\nfor more information refer to the `django documentation`_ and the\n``rules.contrib.views`` module.\n\n.. _django documentation: https://docs.djangoproject.com/en/1.9/topics/auth/default/#limiting-access-to-logged-in-users\n\nchecking permission automatically based on view type\n++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nif you use the mechanisms provided by ``rules.contrib.models`` to register permissions\nfor your models as described in `permissions in models`_, there's another convenient\nmixin for class-based views available for you.\n\n``rules.contrib.views.autopermissionrequiredmixin`` can recognize the type of view\nit's used with and check for the corresponding permission automatically.\n\nthis example view would, without any further configuration, automatically check for\nthe ``\"posts.change_post\"`` permission, given that the app label is ``\"posts\"``::\n\n    from django.views.generic import updateview\n    from rules.contrib.views import autopermissionrequiredmixin\n    from posts.models import post\n\n    class updatepostview(autopermissionrequiredmixin, updateview):\n        model = post\n\nby default, the generic crud views from ``django.views.generic`` are mapped to the\nnative django permission types (*add*, *change*, *delete* and *view*). however,\nthe pre-defined mappings can be extended, changed or replaced altogether when\nsubclassing ``autopermissionrequiredmixin``. see the fully documented source code\nfor details on how to do that properly.\n\n\npermissions and rules in templates\n----------------------------------\n\n``rules`` comes with two template tags to allow you to test for rules and\npermissions in templates.\n\nadd ``rules`` to your ``installed_apps``:\n\n.. code:: python\n\n    installed_apps = (\n        # ...\n        'rules',\n    )\n\nthen, in your template::\n\n    {% load rules %}\n\n    {% has_perm 'books.change_book' author book as can_edit_book %}\n    {% if can_edit_book %}\n        ...\n    {% endif %}\n\n    {% test_rule 'has_super_feature' user as has_super_feature %}\n    {% if has_super_feature %}\n        ...\n    {% endif %}\n\n\npermissions in the admin\n------------------------\n\nif you've setup ``rules`` to be used with permissions in django, you're almost\nset to also use ``rules`` to authorize any add/change/delete actions in the\nadmin. the admin asks for *four* different permissions, depending on action:\n\n- ``<app_label>.add_<modelname>``\n- ``<app_label>.view_<modelname>``\n- ``<app_label>.change_<modelname>``\n- ``<app_label>.delete_<modelname>``\n- ``<app_label>``\n\n*note:* view permission is new in django v2.1 and should not be added in versions before that.\n\nthe first four are obvious. the fifth is the required permission for an app\nto be displayed in the admin's \"dashboard\". overriding it does not restrict access to the add,\nchange or delete views. here's some rules for our imaginary ``books`` app as an example:\n\n.. code:: python\n\n    >>> rules.add_perm('books', rules.always_allow)\n    >>> rules.add_perm('books.add_book', is_staff)\n    >>> rules.add_perm('books.view_book', is_staff | has_secret_access_code)\n    >>> rules.add_perm('books.change_book', is_staff)\n    >>> rules.add_perm('books.delete_book', is_staff)\n\ndjango admin does not support object-permissions, in the sense that it will\nnever ask for permission to perform an action *on an object*, only whether a\nuser is allowed to act on (*any*) instances of a model.\n\nif you'd like to tell django whether a user has permissions on a specific\nobject, you'd have to override the following methods of a model's\n``modeladmin``:\n\n- ``has_view_permission(user, obj=none)``\n- ``has_change_permission(user, obj=none)``\n- ``has_delete_permission(user, obj=none)``\n\n``rules`` comes with a custom ``modeladmin`` subclass,\n``rules.contrib.admin.objectpermissionsmodeladmin``, that overrides these\nmethods to pass on the edited model instance to the authorization backends,\nthus enabling permissions per object in the admin:\n\n.. code:: python\n\n    # books/admin.py\n    from django.contrib import admin\n    from rules.contrib.admin import objectpermissionsmodeladmin\n    from .models import book\n\n    class bookadmin(objectpermissionsmodeladmin):\n        pass\n\n    admin.site.register(book, bookadmin)\n\nnow this allows you to specify permissions like this:\n\n.. code:: python\n\n    >>> rules.add_perm('books', rules.always_allow)\n    >>> rules.add_perm('books.add_book', has_author_profile)\n    >>> rules.add_perm('books.change_book', is_book_author_or_editor)\n    >>> rules.add_perm('books.delete_book', is_book_author)\n\nto preserve backwards compatibility, django will ask for either *view* or\n*change* permission. for maximum flexibility, ``rules`` behaves subtly\ndifferent: ``rules`` will ask for the change permission if and only if no rule\nexists for the view permission.\n\n\npermissions in django rest framework\n------------------------------------\n\nsimilar to ``rules.contrib.views.autopermissionrequiredmixin``, there is a\n``rules.contrib.rest_framework.autopermissionviewsetmixin`` for viewsets in django\nrest framework. the difference is that it doesn't derive permission from the type\nof view but from the api action (*create*, *retrieve* etc.) that's tried to be\nperformed. of course, it also requires you to declare your models as described in\n`permissions in models`_.\n\nhere is a possible ``modelviewset`` for the ``post`` model with fully automated crud\npermission checking::\n\n    from rest_framework.serializers import modelserializer\n    from rest_framework.viewsets import modelviewset\n    from rules.contrib.rest_framework import autopermissionviewsetmixin\n    from posts.models import post\n\n    class postserializer(modelserializer):\n        class meta:\n            model = post\n            fields = \"__all__\"\n\n    class postviewset(autopermissionviewsetmixin, modelviewset):\n        queryset = post.objects.all()\n        serializer_class = postserializer\n\nby default, the crud actions of ``modelviewset`` are mapped to the native\ndjango permission types (*add*, *change*, *delete* and *view*). the ``list``\naction has no permission checking enabled. however, the pre-defined mappings\ncan be extended, changed or replaced altogether when using (or subclassing)\n``autopermissionviewsetmixin``. custom api actions defined via the ``@action``\ndecorator may then be mapped as well. see the fully documented source code for\ndetails on how to properly customize the default behavior.\n\n\nadvanced features\n=================\n\ncustom rule sets\n----------------\n\nyou may create as many rule sets as you need:\n\n.. code:: python\n\n    >>> features = rules.ruleset()\n\nand manipulate them by adding, removing, querying and testing rules:\n\n.. code:: python\n\n    >>> features.rule_exists('has_super_feature')\n    false\n    >>> is_special_user = rules.is_group_member('special')\n    >>> features.add_rule('has_super_feature', is_special_user)\n    >>> 'has_super_feature' in features\n    true\n    >>> features['has_super_feature']\n    <predicate:is_group_member:special object at 0x10eeaa500>\n    >>> features.test_rule('has_super_feature', adrian)\n    true\n    >>> features.remove_rule('has_super_feature')\n\nnote however that custom rule sets are *not available* in django templates --\nyou need to provide integration yourself.\n\n\ninvocation context\n------------------\n\na new context is created as a result of invoking ``predicate.test()`` and is\nonly valid for the duration of the invocation. a context is a simple ``dict``\nthat you can use to store arbitrary data, (eg. caching computed values,\nsetting flags, etc.), that can be used by predicates later on in the chain.\ninside a predicate function it can be used like so:\n\n.. code:: python\n\n    >>> @predicate\n    ... def mypred(a, b):\n    ...     value = compute_expensive_value(a)\n    ...     mypred.context['value'] = value\n    ...     return true\n\nother predicates can later use stored values:\n\n.. code:: python\n\n    >>> @predicate\n    ... def myotherpred(a, b):\n    ...     value = myotherpred.context.get('value')\n    ...     if value is not none:\n    ...         return do_something_with_value(value)\n    ...     else:\n    ...         return do_something_without_value()\n\n``predicate.context`` provides a single ``args`` attribute that contains the\narguments as given to ``test()`` at the beginning of the invocation.\n\n\nbinding \"self\"\n--------------\n\nin a predicate's function body, you can refer to the predicate instance itself\nby its name, eg. ``is_book_author``. passing ``bind=true`` as a keyword\nargument to the ``predicate`` decorator will let you refer to the predicate\nwith ``self``, which is more convenient. binding ``self`` is just syntactic\nsugar. as a matter of fact, the following two are equivalent:\n\n.. code:: python\n\n    >>> @predicate\n    ... def is_book_author(user, book):\n    ...     if is_book_author.context.args:\n    ...         return user == book.author\n    ...     return false\n\n    >>> @predicate(bind=true)\n    ... def is_book_author(self, user, book):\n    ...     if self.context.args:\n    ...         return user == book.author\n    ...     return false\n\n\nskipping predicates\n-------------------\n\nyou may skip evaluation by returning ``none`` from your predicate:\n\n.. code:: python\n\n    >>> @predicate(bind=true)\n    ... def is_book_author(self, user, book):\n    ...     if len(self.context.args) > 1:\n    ...         return user == book.author\n    ...     else:\n    ...         return none\n\nreturning ``none`` signifies that the predicate need not be evaluated, thus\nleaving the predicate result up to that point unchanged.\n\n\nlogging predicate evaluation\n----------------------------\n\n``rules`` can optionally be configured to log debug information as rules are\nevaluated to help with debugging your predicates. messages are sent at the\ndebug level to the ``'rules'`` logger. the following `dictconfig`_ configures\na console logger (place this in your project's `settings.py` if you're using\n`rules` with django):\n\n.. code:: python\n\n    logging = {\n        'version': 1,\n        'disable_existing_loggers': false,\n        'handlers': {\n            'console': {\n                'level': 'debug',\n                'class': 'logging.streamhandler',\n            },\n        },\n        'loggers': {\n            'rules': {\n                'handlers': ['console'],\n                'level': 'debug',\n                'propagate': true,\n            },\n        },\n    }\n\nwhen this logger is active each individual predicate will have a log message\nprinted when it is evaluated.\n\n.. _dictconfig: https://docs.python.org/3.6/library/logging.config.html#logging-config-dictschema\n\n\nbest practices\n==============\n\nbefore you can test for rules, these rules must be registered with a rule set,\nand for this to happen the modules containing your rule definitions must be\nimported.\n\nfor complex projects with several predicates and rules, it may not be\npractical to define all your predicates and rules inside one module. it might\nbe best to split them among any sub-components of your project. in a django\ncontext, these sub-components could be the apps for your project.\n\non the other hand, because importing predicates from all over the place in\norder to define rules can lead to circular imports and broken hearts, it's\nbest to further split predicates and rules in different modules.\n\n``rules`` may optionally be configured to autodiscover ``rules.py`` modules in\nyour apps and import them at startup. to have ``rules`` do so, just edit your\n``installed_apps`` setting:\n\n.. code:: python\n\n    installed_apps = (\n        # replace 'rules' with:\n        'rules.apps.autodiscoverrulesconfig',\n    )\n\n**note:** on python 2, you must also add the following to the top of your\n``rules.py`` file, or you'll get import errors trying to import ``rules``\nitself:\n\n.. code:: python\n\n    from __future__ import absolute_import\n\n\napi reference\n=============\n\nthe core apis are accessible from the root ``rules`` module. django-specific\nfunctionality for the admin and views is available from ``rules.contrib``.\n\n\nclass ``rules.predicate``\n-------------------------\n\nyou create ``predicate`` instances by passing in a callable:\n\n.. code:: python\n\n    >>> def is_book_author(user, book):\n    ...     return book.author == user\n    ...\n    >>> pred = predicate(is_book_author)\n    >>> pred\n    <predicate:is_book_author object at 0x10eeaa490>\n\nyou may optionally provide a different name for the predicate that is used\nwhen inspecting it:\n\n.. code:: python\n\n    >>> pred = predicate(is_book_author, name='another_name')\n    >>> pred\n    <predicate:another_name object at 0x10eeaa490>\n\nalso, you may optionally provide ``bind=true`` in order to be able to access\nthe predicate instance with ``self``:\n\n.. code:: python\n\n    >>> def is_book_author(self, user, book):\n    ...     if self.context.args:\n    ...         return user == book.author\n    ...     return false\n    ...\n    >>> pred = predicate(is_book_author, bind=true)\n    >>> pred\n    <predicate:is_book_author object at 0x10eeaa490>\n\n\ninstance methods\n++++++++++++++++\n\n``test(obj=none, target=none)``\n    returns the result of calling the passed in callable with zero, one or two\n    positional arguments, depending on how many it accepts.\n\n\nclass ``rules.ruleset``\n-----------------------\n\n``ruleset`` extends python's built-in `dict`_ type. therefore, you may create\nand use a rule set any way you'd use a dict.\n\n.. _dict: http://docs.python.org/library/stdtypes.html#mapping-types-dict\n\n\ninstance methods\n++++++++++++++++\n\n``add_rule(name, predicate)``\n    adds a predicate to the rule set, assigning it to the given rule name.\n    raises ``keyerror`` if another rule with that name already exists.\n\n``set_rule(name, predicate)``\n    set the rule with the given name, regardless if one already exists.\n\n``remove_rule(name)``\n    remove the rule with the given name. raises ``keyerror`` if a rule with\n    that name does not exist.\n\n``rule_exists(name)``\n    returns ``true`` if a rule with the given name exists, ``false`` otherwise.\n\n``test_rule(name, obj=none, target=none)``\n    returns the result of calling ``predicate.test(obj, target)`` where\n    ``predicate`` is the predicate for the rule with the given name. returns\n    ``false`` if a rule with the given name does not exist.\n\ndecorators\n----------\n\n``@predicate``\n    decorator that creates a predicate out of any callable:\n\n    .. code:: python\n\n        >>> @predicate\n        ... def is_book_author(user, book):\n        ...     return book.author == user\n        ...\n        >>> is_book_author\n        <predicate:is_book_author object at 0x10eeaa490>\n\n    customising the predicate name:\n\n    .. code:: python\n\n        >>> @predicate(name='another_name')\n        ... def is_book_author(user, book):\n        ...     return book.author == user\n        ...\n        >>> is_book_author\n        <predicate:another_name object at 0x10eeaa490>\n\n    binding ``self``:\n\n    .. code:: python\n\n        >>> @predicate(bind=true)\n        ... def is_book_author(self, user, book):\n        ...     if 'user_has_special_flag' in self.context:\n        ...         return self.context['user_has_special_flag']\n        ...     return book.author == user\n\n\npredefined predicates\n---------------------\n\n``always_allow()``, ``always_true()``\n    always returns ``true``.\n\n``always_deny()``, ``always_false()``\n    always returns ``false``.\n\n``is_authenticated(user)``\n    returns the result of calling ``user.is_authenticated()``. returns\n    ``false`` if the given user does not have an ``is_authenticated`` method.\n\n``is_superuser(user)``\n    returns the result of calling ``user.is_superuser``. returns ``false``\n    if the given user does not have an ``is_superuser`` property.\n\n``is_staff(user)``\n    returns the result of calling ``user.is_staff``. returns ``false`` if the\n    given user does not have an ``is_staff`` property.\n\n``is_active(user)``\n    returns the result of calling ``user.is_active``. returns ``false`` if the\n    given user does not have an ``is_active`` property.\n\n``is_group_member(*groups)``\n    factory that creates a new predicate that returns ``true`` if the given\n    user is a member of *all* the given groups, ``false`` otherwise.\n\n\nshortcuts\n---------\n\nmanaging the shared rule set\n++++++++++++++++++++++++++++\n\n``add_rule(name, predicate)``\n    adds a rule to the shared rule set. see ``ruleset.add_rule``.\n\n``set_rule(name, predicate)``\n    set the rule with the given name from the shared rule set. see\n    ``ruleset.set_rule``.\n\n``remove_rule(name)``\n    remove a rule from the shared rule set. see ``ruleset.remove_rule``.\n\n``rule_exists(name)``\n    returns whether a rule exists in the shared rule set. see\n    ``ruleset.rule_exists``.\n\n``test_rule(name, obj=none, target=none)``\n    tests the rule with the given name. see ``ruleset.test_rule``.\n\n\nmanaging the permissions rule set\n+++++++++++++++++++++++++++++++++\n\n``add_perm(name, predicate)``\n    adds a rule to the permissions rule set. see ``ruleset.add_rule``.\n\n``set_perm(name, predicate)``\n    replace a rule from the permissions rule set. see ``ruleset.set_rule``.\n\n``remove_perm(name)``\n    remove a rule from the permissions rule set. see ``ruleset.remove_rule``.\n\n``perm_exists(name)``\n    returns whether a rule exists in the permissions rule set. see\n    ``ruleset.rule_exists``.\n\n``has_perm(name, user=none, obj=none)``\n    tests the rule with the given name. see ``ruleset.test_rule``.\n\n\nlicence\n=======\n\n``django-rules`` is distributed under the mit licence.\n\ncopyright (c) 2014 akis kesoglou\n\npermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"software\"), to deal in the software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the software, and to permit persons to whom the\nsoftware is furnished to do so, subject to the following\nconditions:\n\nthe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the software.\n\nthe software is provided \"as is\", without warranty of any kind,\nexpress or implied, including but not limited to the warranties\nof merchantability, fitness for a particular purpose and\nnoninfringement. in no event shall the authors or copyright\nholders be liable for any claim, damages or other liability,\nwhether in an action of contract, tort or otherwise, arising\nfrom, out of or in connection with the software or the use or\nother dealings in the software.\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "rules",
  "package_url": "https://pypi.org/project/rules/",
  "project_url": "https://pypi.org/project/rules/",
  "project_urls": {
    "Homepage": "http://github.com/dfunckt/django-rules"
  },
  "release_url": "https://pypi.org/project/rules/3.3/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "awesome django authorization, without the database",
  "version": "3.3",
  "releases": [],
  "developers": [
    "akis_kesoglou",
    "akiskesoglou@gmail.com"
  ],
  "kwds": "rules_permissions django rulesmodelbase rulesmodel _django",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_rules",
  "homepage": "http://github.com/dfunckt/django-rules",
  "release_count": 20,
  "dependency_ids": []
}