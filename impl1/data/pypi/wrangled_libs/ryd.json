{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "operating system :: os independent",
    "programming language :: python"
  ],
  "description": "\n# ryd\n\n[![image](https://sourceforge.net/p/ryd/code/ci/default/tree/_doc/_static/license.svg?format=raw)](https://opensource.org/licenses/mit)\n[![image](https://sourceforge.net/p/ryd/code/ci/default/tree/_doc/_static/pypi.svg?format=raw)](https://pypi.org/project/ryd/)\n[![image](https://sourceforge.net/p/oitnb/code/ci/default/tree/_doc/_static/oitnb.svg?format=raw)](https://pypi.org/project/oitnb/)\n[![image](https://sourceforge.net/p/ryd/code/ci/default/tree/_doc/_static/ryd.svg?format=raw)](https://pypi.org/project/ryd/)\n\n`ryd` ( /r\u0251\u026at/, pronounced like the verb \\\"write\\\" ) is a preprocessor\nfor text based documents, that builds upon the multi-document\ncapabilities of yaml files/streams.\n\nthe use of multiple-documents in `ryd` allows for clear separation\nbetween document text and any programs referenced in those text. thereby\nmaking it possible to run (c.q. compile) the program parts of a\ndocument, e.g. to check whether they are syntactically correct. it can\nalso capture the *actual* output of those programs to be included in the\ndocument. it is also possible to recognise different documents and thus\nrun different formatters then recombining the documents.\n\nthis allows for easier maintenance of (correct) program sources, in\ndocument source texts like restructuredtext, latex, markdown, etc.\n\nthe first of the documents in a `ryd` file has, at the root-level, a\nmapping. this mapping is the **ryd configuration metadata** for the rest\nof the stream of documents in the file. the metadata is used to define\n`ryd` document version used, what the basic **text style** is (currently\n`rst` for restructuredtext, `so` for stackoverflow-markdown), if any\npostprocessing (pdf, html) needs to be done, and other configuration\ninformation. this first document doesn\\'t normally have any directives.\nthat the document is yaml 1.2 is implicit, so no `%yaml 1.2` directive\nis needed and without directive and no preceding document, you do not\nhave a directives-end marker line (`---`) at the top.\n\nthe documents following the first document are normally block style\nliteral scalars with an optional tag. the tag influences how the scalar\nstring is processed within the selected output text style.\n\n## example\n\n    version: 0.2\n    text: rst\n    fix_inline_single_backquotes: true\n    --- |\n    example python program\n    ++++++++++++++++++++++\n\n    this is an example of a python program:\n    --- !python |\n    n = 7\n    print(n**2 - n)\n    --- !stdout |\n    the answer is:\n\nthis will generate (using: `ryd convert test.ryd`) the following\n`test.rst`:\n\n    example python program\n    ++++++++++++++++++++++\n\n    this is an example of a python program:\n\n    .. code:: python\n\n      n = 7\n      print(n**2 - n)\n\n    the answer is:\n\n    .. code::\n\n      42\n\n## postprocessing\n\nthe output can be converted to pdf using `rst2pdf` or html using\n`rst2html` with images embedded using `webpage2html`. invocation of\nthese programs can be specified in the metatada (e.g. `post: pdf`).\n\nthe (image embedded) html output has the indent of indented lines of\nincluded code fragments inserted as actual spaces. so you copy and paste\nprogram code (or yaml) from html without a problem, something not\npossible with pdf files generated by `rst2pdf`.\n\n`ryd` generates its text output stand-alone, but the programs actually\nused for postprocessing have to be installed seperately and available in\nyour path.\n\n(there is currently no postprocessing for markdown, as pandoc is not\nworking on arch (mark 2022))\n\n## config\n\nyou can create a file `~/.config/ryd/ryd.yaml` with defaults for the\ncommandline options. to always embed images when converting to html and\nalways run the (global) verbose option:\n\n> global:\n>\n> :   verbose: true\n>\n> convert:\n>\n> :   embed: true\n\n### command-line options\n\nthe command-line of `ryd` consists of multiple components:\n\n    ryd [--global-option] command [--options] [arguments]\n\nalthough not indicated most global options can occur after the command\nas well.\n\n#### commands\n\n    convert             generate output as per first yaml document\n    roundtrip           roundtrip .ryd file, updating sections\n    from-rst (fromrst)  convert .rst to .ryd\n\nyou\\'ll most often use `convert` it takes one or more filenames as\nargument and generates output as specified in the ryd configuration\ndata. some options allow you to override settings there (e.g. `--pdf`\nand `-no-pdf`)\n\nthe command `from-rst` converts a `.rst` file into `.ryd` doing some\nsection underline checking and adding the ryd configuration data\ndocument.\n\nthe `roundtrip` command updates sections by running in place\ncode-formatting on the `!python` (using `oitnb`) and `!zig` sections of\nthe `.ryd` file. ( there is currently no config option to use `blue` or\n`black`, but you can copy `ryd/_tag/python.tag` to your\n`.config/ryd/tag` directory and make the minor adjustment to use those,\nsee the section on making our own tag).\n\ndoing `ryd command --help` might indicate extra options that have not\nyet made it into the documentation and/or that are incompletely\nimplemented.\n\n# documents and document tags\n\neach yaml document has to be separated from other documents in the\nstream by at least the end of directive marker `---`. apart from the\nfirst document, most documents contain a single, multi-line,\nnon-indented, scalar. the end of directives marker is therefor followed\nby the pipe (`|`) symbol, which is the yaml indication for a multi-line\nliteral scalar.\n\nthat scalar can be \\\"typed\\\" in the normal way of yaml by inserting a\ntag before the `|`. e.g. a document that is a type of python program has\na tag `!python` and thus starts with:\n\n    --- !python |\n\nwhat a document tag exactly does, depends on the tag, but, potentially,\nalso, on the output file format selected, on previously processed tagged\ndocuments, other `.ryd` files processed previously and the environment.\n\nin addition to the basic tag (like `!python`), a tag can have\nsubfunctions such as `!python-pre`. if an unknown subfunction is\nspecified you\\'ll get a runtime error.\n\nthe following are short descriptions for all tags, independent of the selected\noutput format:\n\n`!changelog`<br>  input is a mapping keys are (version, date) tuples, or the word next\n\n`!code`<br>  include program in text. do not mark as executable, doesn't influence ``!stdout``.\n\n`!comment`<br>  the whole document will be discarded, i.e. not included in the output.\n\n`!inc`<br>  include the content of the listed files (indented), without other processing,          into the output. preceed with ``::`` if necessary\n\n`!inc-raw`<br>  include the content of the listed files (indented), without other processing,          into the output. preceed with ``::`` if necessary\n\n`!lastcompile`<br>  include output from last compilation as code.\n\n`!nim`<br>  include nim program in text. prefix and mark as executable.\n\n`!nim-pre`<br>  include nim program in text. prefix and mark as executable.\n\n`!python`<br>  include python program in text. prefix and mark as executable.\n\n`!python-hidden`<br>  include python program in text. prefix and mark as executable.\n\n`!python-hiddenstdoutraw`<br>  include python program in text. prefix and mark as executable.\n\n`!python-pre`<br>  include python program in text. prefix and mark as executable.\n\n`!stdout`<br>  include output from last executable document (e.g. ``!python``) as code.\n\n`!stdout-raw`<br>  include output from last executable document (e.g. ``!python``) as code.\n\n`!table`<br>  create a table, for now headerless\n\n`!toc`<br>  insert an index\n\n`!yamlout`<br>  include output from last executable document (e.g. ``!python``) as code tagged as         yaml document.\n\n`!zig`<br>  include zig program in text. prefix and execute setting !stdout.\n\n`!zig-pre`<br>  include zig program in text. prefix and execute setting !stdout.\n\n`!zsh`<br>  run each line in zsh, interspacing the lines with the output\n\n# md\n\nthe output to `.md` expects non-code yaml documents to be valid\nmarkdown.\n\nbecause of the special meaning of `---` (and `...`) at the beginning of\na line, followed by newline or space, these should not be used. either\nuse a longer sequence ( e.g. for divider lines use `----` ), or\nindent the whole document:\n\n```\n  --- |\n    line followed by divider\n    ---\n    another line\n```\n\n## mkdocs\n\nif you have a file `_doc/readme.ryd`, you can use `ryd serve` to\nconvert and serve this with mkdocs. the contents of the necessary\nmkdocs configuration file will be written from the mkdocs entry in the metadata\nof the `readme.ryd` file (so you don't need to put more cruft in your packages root\ndirectory):\n\n```\n version: 0.2\n text: md\n pdf: false\n mkdocs:\n   # if site_name key not provided set to current directory name\n   site_name: your_project_name\n   docs_dir: _doc\n   site_author: anthon van der neut\n\n   theme:\n     name: readthedocs\n\n   exclude_docs: |\n     *.ryd\n     *.rst\n\n   markdown_extensions:\n   - toc:\n       permalink: true\n```\n\n \n# rst\n\nthe output to `.rst` expects non-code yaml documents to be valid\nrestructuredtext. any non-tagged documents, i.e. those starting with:\n\n    --- |\n\nare assumed to be text input, in the format specified in the ryd\nconfiguration data.\n\n## section underlining\n\nbecause of the special meaning of `---` (and `...`) at the beginning of\na line, followed by newline or space, the section under/over-line\ncharacters used in `.ryd` files that are source for `.rst` should not\nuse `-` or `.` sequences if a any of those section names consist of\nthree letters (e.g. a section named api or rst). it is recommended to\nuse the following scheme:\n\n    sections, subsections, etc. in .ryd files\n     # with over-line, for parts\n     * with over-line, for chapters\n     =, for sections\n     +, for subsections\n     ^, for sub-subsections\n     \", for paragraphs\n\n## single backquotes\n\nthe `fix_inline_single_backquotes: true` tells `ryd` to indicate lines\nthat have single backquotes, that need fixing (by replacing them with\ndouble backquotes):\n\n    readme.ryd\n    47: this will generate (`ryd convert test.ryd`) the following\n                          --^\n                                               --^\n\n(if you are used to other inline code markup editing e.g. on stack\noverflow, that uses single backquotes, you\\'ll come to appreciate this.)\n\n## python\n\npython code is indicated by:\n\n    --- !python |\n\nthe document is inserted into the `.rst` preceded by `.. code:: python`\nand each line with a two space indent.\n\nif your program relies on specific packages, those packages, need to be\navailable in the environment in which `ryd` is started (which can e.g.\nbe a specifically set up `virtualenv`)\n\nit is possible to have \\\"partial programs\\\" by preceding a python\ndocument with e.g.:\n\n    --- !python-pre |\n    from __future__ import print_function\n    import sys\n    import ruamel.yaml\n    from ruamel.std.pathlib import path, pushd, popd, pathlibconversionhelper\n    pl = pathlibconversionhelper()\n\nsuch a block is pre-pended to all following `--- !python |` documents\n(until superseded by another `--- !python-pre |` block)\n\n## captured output\n\nthe output from the last program that was run (`--- !python |`) is\nstored and can be post-pended to a restructuredtext document by tagging\nit with `!stdout` (i.e. `--- !stdout |`)\n\n## non-running code\n\na document tagged `!code` will be represented as one tagged `!python`,\nbut the code will not be run (and hence the output used for `!stdout`\nnot changed).\n\n## zig\n\nzig code is indicated by:\n\n    --- !zig |\n\nthe document is inserted as with python, there can be a `!zig-pre`\ndocument, and output is captured and displayed with `--- !stdout |`):\n\n```zig\n// const std = @import(\"std\");   is defined in zig-pre\n\npub fn main() !void {\n    const stdout = std.io.getstdout().writer();\n    try stdout.print(\"hello, {s}!\\n\", .{\"world\"});\n}\n```\n\nwhich outputs:\n\n```lang-none\nhello, world!\n```\n\nthe compilation is done with option `build-exe`.\n\n\ncompiler output\n^^^^^^^^^^^^^^^\n\nif you are interested in the textual output of the compiler you can use\n``--- !lastcompile |``:\n\n# nim\n\nnim code is indicated by:\n\n    --- !nim |\n\nthe document is inserted as with python, there can be a `!nim-pre`\ndocument, and output is captured and displayed with `--- !stdout |`):\n\n```lang-none\nlet a = 123\nlet x = 0b0010_1010\necho(fmt\"the answer to the question: {x}\")\n```\n\nwhich outputs:\n\n    the answer to the question: 42\n\nthe compilation is done with options\n`--verbosity:0 --hint[processing]:off` .\n\n# compiler output\n\nif you are interested in the textual output of the compiler you can use\n`--- !lastcompile |`:\n\n    /tmp/ryd-of-anthon/ryd-1169/tmp_02.nim(4, 5) hint: 'a' is declared but not used [xdeclaredbutnotused]\n\n# comments\n\nblock style literal scalars do not allow yaml comments. to insert\ncomments in a text, either use the format acceptable by the output, e.g.\nwhen generating `.rst` use:\n\n    ..\n       this will show up in the resulting .rst file, but will\n       not render\n\nalternatively you can create a comment yaml document (`--- !comment |`),\nfor which the text will not be represented in the output file format\n**at all**.\n\nif you already have a tagged document, e.g. `--- !python |` document,\nyou can make it into a comment by inserting `comment-`:\n\n    --- !comment-python |\n\nthis has been implemented by **not** reporting an error when an unkown\nsubfunction on `!comment` is invoked.\n\n# tasklists\n\nif you set `tasklist: true` in the metadata, then lines that *start*\nwith one of the following tasklist patterns, are transformed to their\nunicode counterpart:\n\n    [ ] not done yet\n    [v] done\n    [x] no longer going to do\n\nresulting in\n\n\u2610 not done yet\n\n\u2611 done\n\n\u2612 no longer going to do\n\n(it would be nice to know if there is a way to create a real list with\nuser specified bullet items)\n\n# making your own tag\n\nbefore trying to load a tag `!yourtag` from its know files, `ryd` tries\nto load them from `~/.config/ryd/tag/`. this mechanism can be used to\nimplement your improvements over existing tags or extendeding the tags\nwith your own.\n\nlet\\'s assume you want to explain the use of `mypy` in your `ryd`\ndocument, including output of a `mypy` run on some source. first create\na file `~/.config/ryd/tag/mypy.tag` with the following content:\n\n    # coding: 'utf-8'\n\n    from __future__ import annotations\n\n    import os\n    import subprocess\n    from typing import any, type_checking\n    from ryd._tag._handler import programhandler\n\n    if type_checking:\n        from ryd._convertor._base import convertorbase\n    else:\n        convertorbase = any\n\n\n    class mypy(programhandler):   # class name is capitalization of the stem of the filename\n        def __init__(self, convertor: convertorbase) -> none:\n            super().__init__(convertor)\n            self._pre = ''\n\n        def pre(self, d: any) -> none:  # like !python-pre you can have !mypy-pre\n            self._pre = str(d)\n\n        def __call__(self, d: any) -> none:\n            \"\"\"\n            include python program in text. prefix, save and run mypy, setting !stdout.\n            \"\"\"\n            s = str(d)\n            # depending on the util, you may not need to do a chdir to the tempdir\n            old_dir = os.getcwd()\n            self.c.temp_dir.chdir()\n            path = self.c.temp_file_path('.py')\n            path.write_text(self._pre + s)\n            self.c.last_output = subprocess.run([\n                'mypy',\n                '--strict', '--follow-imports', 'silent', '--implicit-reexport',\n                str(path),\n            ], stderr=subprocess.stdout, stdout=subprocess.pipe, encoding='utf-8').stdout\n            os.chdir(old_dir)\n            self.c.add_code(s, 'python')  # format the code as python\n\nand you include in your `ryd` document:\n\n    --- !mypy |\n    def main(arg1, arg2):\n        return arg1\n\n    --- !stdout |\n    which gives:\n\n    --- |\n\n    from the mypy output you can see ....\n\nyour `.rst` will then contain the python source and the mypy output:\n\n    .. code:: python\n\n      def main(arg1, arg2):\n          return arg1\n\n    which gives:\n\n    .. code::\n\n      tmp_03.py:2: error: function is missing a type annotation\n      found 1 error in 1 file (checked 1 source file)\n\n    from the mypy output you can see ....\n\n# history\n\n`ryd` grew out of a in-house solution where sections of restructuredtext\nfiles were updated, in-place, by running python programs specified in\nseparate files. also allowing the inclusion of the (error) output.\n\nan example of this can be seen in\n[this](https://bitbucket.org/ruamel/yaml/raw/0be7d3cb8449b15d9ac9b097322f09e52b92f868/_doc/example.rst)\nold version of the `example.rst` file of the `ruamel.yaml` package:\n\n    basic round trip of parsing yaml to python objects, modifying\n    and generating yaml::\n\n      import sys\n      from ruamel.yaml import yaml\n\n      inp = \"\"\"\\\n      # example\n      name:\n        # details\n        family: smith   # very common\n        given: alice    # one of the siblings\n      \"\"\"\n\n      yaml = yaml()\n      code = yaml.load(inp)\n      code['name']['given'] = 'bob'\n\n      yaml.dump(code, sys.stdout)\n\n    .. example code small.py\n\n    resulting in ::\n\n      # example\n      name:\n        # details\n        family: smith   # very common\n        given: bob      # one of the siblings\n\n\n    .. example output small.py\n\nthe program was inserted before the `.. example code` line and its\noutput before `.. example output`, replacing all the text starting after\nthe previous `::`\n\nthe `small.py` referenced a separate file for this piece of code. this\nresulted in multiple source files that were associated with a single\n`.rst` file. there was no mechanism to have partial programs that could\nbe tested by execution, which precluded getting output from such program\nas well.\n\nalthough the code could have been edited in place, and used to get the\noutput, this would force one to use the extra indentation required for\nlines following rest\\'s `::`.\n\nonce this system came under review, the solution with a structured yaml\nheader, as used with various file formats, combined with multiple\ndocument consisting of (tagged) top level, non-indented, block style\nliteral scalars, was chosen instead.\n\nin early 2022 an update of the 0.1 format was implemented to make tags\nand convertors into seperate files, thereby making them more easily\nupgradable and extensible.\n",
  "docs_url": null,
  "keywords": "restructuredtext markdown markup preprocessing",
  "license": "mit",
  "name": "ryd",
  "package_url": "https://pypi.org/project/ryd/",
  "project_url": "https://pypi.org/project/ryd/",
  "project_urls": {
    "Home": "https://sourceforge.net/p/ryd/",
    "Source": "https://sourceforge.net/p/ryd/code/ci/default/tree/",
    "Tracker": "https://sourceforge.net/p/ryd/tickets/"
  },
  "release_url": "https://pypi.org/project/ryd/0.9.2/",
  "requires_dist": [
    "ruamel.std.pathlib",
    "ruamel.yaml",
    "ruamel.yaml.split"
  ],
  "requires_python": ">=3",
  "summary": "ruamel yaml doc preprocessor (pronounced: /r\u0251\u026at/, like the verb \"write\")",
  "version": "0.9.2",
  "releases": [],
  "developers": [
    "a.van.der.neut@ruamel.eu",
    "anthon_van_der_neut"
  ],
  "kwds": "markdown markup markdown_extensions restructuredtext svg",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_ryd",
  "homepage": "",
  "release_count": 20,
  "dependency_ids": [
    "pypi_ruamel.std.pathlib",
    "pypi_ruamel.yaml",
    "pypi_ruamel.yaml.split"
  ]
}