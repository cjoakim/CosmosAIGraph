{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "natural language :: english",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries",
    "topic :: utilities"
  ],
  "description": "# plac: parsing the command line the easy way\n\n`plac` is a python package that can generate command line parameters\nfrom function signatures.\n\n`plac` works on python 2.6 through all versions of python 3.\n\n`plac` has no dependencies beyond modules already present in the python\nstandard library.\n\n`plac` implements most of its functionality in a single file that may be\nincluded in your source code.\n\n## quickstart\n\n`plac` automatically generates the command line parameters from the function signature. \n        \nit offers three decorators to describe positional, option and flag type parameters:\n\n```python\nimport plac\n\n# add decorators to the function\n@plac.pos('model', help=\"model name\", choices=['a', 'b', 'c'])\n@plac.opt('iter', help=\"iterations\", type=int)\n@plac.flg('debug', help=\"debug mode\")\ndef main(model, iter=100, debug=false):\n    \"\"\"\n    a script for machine learning\n    \"\"\"\n    print (model, iter, debug)\n\nif __name__ == '__main__':\n    # execute function via plac.call()\n    plac.call(main)\n```\n\nand that's it! the program can now take parameters from the command line like so:\n\n    python example.py -d -i 1000 b \n\nrunning the script with `python example.py -h` will give you the following help message: :\n\n```\nusage: example.py [-h] [-i 100] [-d] {a,b,c}\n\na script for machine learning\n\npositional arguments:\n  {a,b,c}             model name\n\noptions:\n  -h, --help          show this help message and exit\n  -i 100, --iter 100  iterations\n  -d, --debug         debug mode\n```\n\nrunning the script with no parameters `python example.py` would print:\n\n```\nusage: example.py [-h] [-i 100] [-d] {a,b,c}\nexample.py: error: the following arguments are required: model\n```\n\n## decorator reference\n\nto use `plac` all you need to know are the following three decorators:\n\n* `@plac.pos` - for positional parameters `model`\n* `@plac.opt` - for key value options `--iter 100`\n* `@plac.flg` - for flags `--debug`\n\nthat have the following signatures:\n\n```python\n# positional parameters.\npos(arg, help=none, type=none, choices=none, metavar=none):\n\n# option parameters.\nopt(arg, help=none, type=none, abbrev=none, choices=none, metavar=none):\n\n# flag parameters.\nflg(arg, help=none, abbrev=none):\n```\n\n## zero dependencies ... not even plac :-)\n\nnotably, the main functionality of `plac` is implemented in a single\npython module called `plac_core.py` that, if necessary, may be included and\ndistributed with your source code thus reducing external dependencies in\nyour code.\n\ncopy `plac_core.py` to your package then use it like so:\n\n```python\nfrom mypackage import plac_core as plac\n```\n\n## avoiding name clashes\n\npython syntax, or your variable naming may impose constraints on what\nwords may be used as parameters. to circumvent that limitation append a\ntrailing underscore to the name. `plac` will strip that underscore from\nthe command line parameter name:\n\n```python\nimport plac\n\n@plac.flg('list_')   # avoid clash with builtin\n@plac.flg('yield_')  # avoid clash with keyword\n@plac.opt('sys_')    # avoid clash with a very common name\ndef main(list_, yield_=false, sys_=100):\n    print(list_)\n    print(yield_)\n    print(sys_)\n\nif __name__ == '__main__':\n    plac.call(main)\n```\n\nproduces the usage:\n\n```\nusage: example13.py [-h] [-l] [-y] [-s 100]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  -l, --list\n  -y, --yield        [false]\n  -s 100, --sys 100  [100]\n```\n\n## variable arguments\n\n`plac` may accept multiple positional arguments and even additional key=value pairs:\n\n```python\nimport plac\n\n@plac.pos('args', help=\"words\")\n@plac.opt('kwds', help=\"key=value\", )\ndef main(*args, **kwds):\n    print(args)\n    print(kwds)\n\nif __name__ == '__main__':\n    plac.call(main)\n```\n\nthe usage will be:\n\n```\nusage: example15.py [-h] [args ...] [kwds ...]\n\npositional arguments:\n  args        words\n  kwds        key=value\n\noptional arguments:\n  -h, --help  show this help message and exit\n```\n\nwhen running it as:\n\n    python example15.py a b x=10 y=20\n\nthe program prints:\n\n    ('a', 'b')\n    {'x': '10', 'y': '20'}\n\n## installation\n\n    pip install plac\n\n## testing\n\nrun\n\n    python doc/test_plac.py\n\nyou will see several apparent errors, but this is right, since the tests\nare checking for several error conditions. the important thing is that\nyou get a line like\n\n`executed xx tests ok`\n\n## code\n\n-   <https://github.com/ialbert/plac>\n\nauthor: michele simionato, <michele.simionato@gmail.com>\n\nmaintainer: istvan albert, <istvan.albert@gmail.com>\n\n## issues\n\n-   <https://github.com/ialbert/plac/issues>\n\n## license\n\nbsd license\n",
  "docs_url": null,
  "keywords": "command line arguments parser",
  "license": "bsd license",
  "name": "plac",
  "package_url": "https://pypi.org/project/plac/",
  "project_url": "https://pypi.org/project/plac/",
  "project_urls": {
    "Homepage": "https://github.com/ialbert/plac"
  },
  "release_url": "https://pypi.org/project/plac/1.4.2/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "the smartest command line arguments parser in the world",
  "version": "1.4.2",
  "releases": [],
  "developers": [
    "michele.simionato@gmail.com",
    "michele_simionato"
  ],
  "kwds": "test_plac plac plac_core python parameters",
  "license_kwds": "bsd license",
  "libtype": "pypi",
  "id": "pypi_plac",
  "homepage": "https://github.com/ialbert/plac",
  "release_count": 36,
  "dependency_ids": []
}