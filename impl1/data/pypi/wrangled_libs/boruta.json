{
  "classifiers": [],
  "description": "# boruta_py #\n\nthis project hosts python implementations of the [boruta all-relevant feature selection method](https://m2.icm.edu.pl/boruta/).\n\n[related blog post] (http://danielhomola.com/2015/05/08/borutapy-an-all-relevant-feature-selection-method/)\n\n## dependencies ##\n\n* numpy\n* scipy\n* scikit-learn\n\n## how to use ##\ndownload, import and do as you would with any other scikit-learn method:\n* fit(x, y)\n* transform(x)\n* fit_transform(x, y)\n\n## description ##\n\npython implementations of the boruta r package.\n\nthis implementation tries to mimic the scikit-learn interface, so use fit,\ntransform or fit_transform, to run the feature selection.\n\nfor more, see the docs of these functions, and the examples below.\n\noriginal code and method by: miron b kursa, https://m2.icm.edu.pl/boruta/\n\nboruta is an all relevant feature selection method, while most other are\nminimal optimal; this means it tries to find all features carrying\ninformation usable for prediction, rather than finding a possibly compact\nsubset of features on which some classifier has a minimal error.\n\nwhy bother with all relevant feature selection?\nwhen you try to understand the phenomenon that made your data, you should\ncare about all factors that contribute to it, not just the bluntest signs\nof it in context of your methodology (yes, minimal optimal set of features\nby definition depends on your classifier choice).\n\n\n## what's different in borutapy? ##\n\nit is the original r package recoded in python with a few added extra features.\nsome improvements include:  \n\n* faster run times, thanks to scikit-learn\n\n* scikit-learn like interface\n\n* compatible with any ensemble method from scikit-learn\n\n* automatic n_estimator selection\n\n* ranking of features\n\nfor more details, please check the top of the docstring.\n\nwe highly recommend using pruned trees with a depth between 3-7.\n\nalso, after playing around a lot with the original code i identified a few areas\nwhere the core algorithm could be improved/altered to make it less strict and\nmore applicable to biological data, where the bonferroni correction might be\noverly harsh.\n\n__percentile as threshold__  \nthe original method uses the maximum of the shadow features as a threshold in\ndeciding which real feature is doing better than the shadow ones. this could be\noverly harsh.\n\nto control this, i added the perc parameter, which sets the\npercentile of the shadow features' importances, the algorithm uses as the\nthreshold. the default of 100 which is equivalent to taking the maximum as the\nr version of boruta does, but it could be relaxed. note, since this is the\npercentile, it changes with the size of the dataset. with several thousands of\nfeatures it isn't as stringent as with a few dozens at the end of a boruta run.\n\n\n__two step correction for multiple testing__  \nthe correction for multiple testing was relaxed by making it a two step\nprocess, rather than a harsh one step bonferroni correction.\n\nwe need to correct firstly because in each iteration we test a number of\nfeatures against the null hypothesis (does a feature perform better than\nexpected by random). for this the bonferroni correction is used in the original\ncode which is known to be too stringent in such scenarios (at least for\nbiological data), and also the original code corrects for n features, even if\nwe are in the 50th iteration where we only have k<<n features left. for this\nreason the first step of correction is the widely used benjamini hochberg fdr.\n\nfollowing that however we also need to account for the fact that we have been\ntesting the same features over and over again in each iteration with the\nsame test. for this scenario the bonferroni is perfect, so it is applied by\ndeviding the p-value threshold with the current iteration index.\n\nif this two step correction is not required, the two_step parameter has to be\nset to false, then (with perc=100) borutapy behaves exactly as the r version.\n\n## parameters ##\n\n__estimator__ : object\n   > a supervised learning estimator, with a 'fit' method that returns the\n   > feature_importances_ attribute. important features must correspond to\n   > high absolute values in the feature_importances_.\n\n__n_estimators__ : int or string, default = 1000\n   > if int sets the number of estimators in the chosen ensemble method.\n   > if 'auto' this is determined automatically based on the size of the\n   > dataset. the other parameters of the used estimators need to be set\n   > with initialisation.\n\n__perc__ : int, default = 100\n   > instead of the max we use the percentile defined by the user, to pick\n   > our threshold for comparison between shadow and real features. the max\n   > tend to be too stringent. this provides a finer control over this. the\n   > lower perc is the more false positives will be picked as relevant but\n   > also the less relevant features will be left out. the usual trade-off.\n   > the default is essentially the vanilla boruta corresponding to the max.\n\n__alpha__ : float, default = 0.05\n   > level at which the corrected p-values will get rejected in both correction\n   steps.\n\n__two_step__ : boolean, default = true\n  > if you want to use the original implementation of boruta with bonferroni\n  > correction only set this to false.\n\n__max_iter__ : int, default = 100\n   > the number of maximum iterations to perform.\n\n__verbose__ : int, default=0\n   > controls verbosity of output.\n\n\n## attributes ##\n\n**n_features_** : int\n   > the number of selected features.\n\n**support_** : array of shape [n_features]\n   > the mask of selected features - only confirmed ones are true.\n\n**support_weak_** : array of shape [n_features]\n  >  the mask of selected tentative features, which haven't gained enough\n  >  support during the max_iter number of iterations..\n\n**ranking_** : array of shape [n_features]\n  >  the feature ranking, such that ``ranking_[i]`` corresponds to the\n  >  ranking position of the i-th feature. selected (i.e., estimated\n  >  best) features are assigned rank 1 and tentative features are assigned\n  >  rank 2.\n\n\n## examples ##\n\n    import pandas as pd\n    from sklearn.ensemble import randomforestclassifier\n    from boruta import borutapy\n\n    # load x and y\n    # note borutapy accepts numpy arrays only, hence the .values attribute\n    x = pd.read_csv('examples/test_x.csv', index_col=0).values\n    y = pd.read_csv('examples/test_y.csv', header=none, index_col=0).values\n    y = y.ravel()\n\n    # define random forest classifier, with utilising all cores and\n    # sampling in proportion to y labels\n    rf = randomforestclassifier(n_jobs=-1, class_weight='balanced', max_depth=5)\n\n    # define boruta feature selection method\n    feat_selector = borutapy(rf, n_estimators='auto', verbose=2, random_state=1)\n\n    # find all relevant features - 5 features should be selected\n    feat_selector.fit(x, y)\n\n    # check selected features - first 5 features are selected\n    feat_selector.support_\n\n    # check ranking of features\n    feat_selector.ranking_\n\n    # call transform() on x to filter it down to selected features\n    x_filtered = feat_selector.transform(x)\n\n## references ##\n\n1. kursa m., rudnicki w., \"feature selection with the boruta package\" journal of statistical software, vol. 36, issue 11, sep 2010\n\n\n",
  "docs_url": null,
  "keywords": "feature selection,machine learning,random forest",
  "license": "bsd 3 clause",
  "name": "boruta",
  "package_url": "https://pypi.org/project/Boruta/",
  "project_url": "https://pypi.org/project/Boruta/",
  "project_urls": {
    "Homepage": "https://github.com/danielhomola/boruta_py"
  },
  "release_url": "https://pypi.org/project/Boruta/0.3/",
  "requires_dist": [
    "numpy (>=1.10.4)",
    "scikit-learn (>=0.17.1)",
    "scipy (>=0.17.0)"
  ],
  "requires_python": "",
  "summary": "python implementation of boruta feature selection",
  "version": "0.3",
  "releases": [],
  "developers": [
    "dani.homola@gmail.com",
    "daniel_homola"
  ],
  "kwds": "scikit fit_transform sklearn classifier randomforestclassifier",
  "license_kwds": "bsd 3 clause",
  "libtype": "pypi",
  "id": "pypi_boruta",
  "homepage": "https://github.com/danielhomola/boruta_py",
  "release_count": 9,
  "dependency_ids": [
    "pypi_numpy",
    "pypi_scikit_learn",
    "pypi_scipy"
  ]
}