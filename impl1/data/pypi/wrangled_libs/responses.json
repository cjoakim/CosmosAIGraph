{
  "classifiers": [
    "intended audience :: developers",
    "intended audience :: system administrators",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: software development"
  ],
  "description": "responses\n=========\n\n.. image:: https://img.shields.io/pypi/v/responses.svg\n    :target: https://pypi.python.org/pypi/responses/\n\n.. image:: https://img.shields.io/pypi/pyversions/responses.svg\n    :target: https://pypi.org/project/responses/\n\n.. image:: https://img.shields.io/pypi/dm/responses\n   :target: https://pypi.python.org/pypi/responses/\n\n.. image:: https://codecov.io/gh/getsentry/responses/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/getsentry/responses/\n\na utility library for mocking out the ``requests`` python library.\n\n..  note::\n\n    responses requires python 3.8 or newer, and requests >= 2.30.0\n\n\ntable of contents\n-----------------\n\n.. contents::\n\n\ninstalling\n----------\n\n``pip install responses``\n\n\ndeprecations and migration path\n-------------------------------\n\nhere you will find a list of deprecated functionality and a migration path for each.\nplease ensure to update your code according to the guidance.\n\n.. list-table:: deprecation and migration\n   :widths: 50 25 50\n   :header-rows: 1\n\n   * - deprecated functionality\n     - deprecated in version\n     - migration path\n   * - ``responses.json_params_matcher``\n     - 0.14.0\n     - ``responses.matchers.json_params_matcher``\n   * - ``responses.urlencoded_params_matcher``\n     - 0.14.0\n     - ``responses.matchers.urlencoded_params_matcher``\n   * - ``stream`` argument in ``response`` and ``callbackresponse``\n     - 0.15.0\n     - use ``stream`` argument in request directly.\n   * - ``match_querystring`` argument in ``response`` and ``callbackresponse``.\n     - 0.17.0\n     - use ``responses.matchers.query_param_matcher`` or ``responses.matchers.query_string_matcher``\n   * - ``responses.assert_all_requests_are_fired``, ``responses.passthru_prefixes``, ``responses.target``\n     - 0.20.0\n     - use ``responses.mock.assert_all_requests_are_fired``,\n       ``responses.mock.passthru_prefixes``, ``responses.mock.target`` instead.\n\nbeta features\n-------------\nbelow you can find a list of beta features. although we will try to keep the api backwards compatible\nwith released version, we reserve the right to change these apis before they are considered stable. please share your feedback via\n`github issues <https://github.com/getsentry/responses/issues>`_.\n\nrecord responses to files\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nyou can perform real requests to the server and ``responses`` will automatically record the output to the\nfile. recorded data is stored in `yaml <https://yaml.org>`_ format.\n\napply ``@responses._recorder.record(file_path=\"out.yaml\")`` decorator to any function where you perform\nrequests to record responses to ``out.yaml`` file.\n\nfollowing code\n\n.. code-block:: python\n\n    import requests\n    from responses import _recorder\n\n\n    def another():\n        rsp = requests.get(\"https://httpstat.us/500\")\n        rsp = requests.get(\"https://httpstat.us/202\")\n\n\n    @_recorder.record(file_path=\"out.yaml\")\n    def test_recorder():\n        rsp = requests.get(\"https://httpstat.us/404\")\n        rsp = requests.get(\"https://httpbin.org/status/wrong\")\n        another()\n\nwill produce next output:\n\n.. code-block:: yaml\n\n    responses:\n    - response:\n        auto_calculate_content_length: false\n        body: 404 not found\n        content_type: text/plain\n        method: get\n        status: 404\n        url: https://httpstat.us/404\n    - response:\n        auto_calculate_content_length: false\n        body: invalid status code\n        content_type: text/plain\n        method: get\n        status: 400\n        url: https://httpbin.org/status/wrong\n    - response:\n        auto_calculate_content_length: false\n        body: 500 internal server error\n        content_type: text/plain\n        method: get\n        status: 500\n        url: https://httpstat.us/500\n    - response:\n        auto_calculate_content_length: false\n        body: 202 accepted\n        content_type: text/plain\n        method: get\n        status: 202\n        url: https://httpstat.us/202\n\n\nreplay responses (populate registry) from files\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nyou can populate your active registry from a ``yaml`` file with recorded responses.\n(see `record responses to files`_ to understand how to obtain a file).\nto do that you need to execute ``responses._add_from_file(file_path=\"out.yaml\")`` within\nan activated decorator or a context manager.\n\nthe following code example registers a ``patch`` response, then all responses present in\n``out.yaml`` file and a ``post`` response at the end.\n\n.. code-block:: python\n\n    import responses\n\n\n    @responses.activate\n    def run():\n        responses.patch(\"http://httpbin.org\")\n        responses._add_from_file(file_path=\"out.yaml\")\n        responses.post(\"http://httpbin.org/form\")\n\n\n    run()\n\nbasics\n------\n\nthe core of ``responses`` comes from registering mock responses and covering test function\nwith ``responses.activate`` decorator. ``responses`` provides similar interface as ``requests``.\n\nmain interface\n^^^^^^^^^^^^^^\n\n* responses.add(``response`` or ``response args``) - allows either to register ``response`` object or directly\n  provide arguments of ``response`` object. see `response parameters`_\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        # register via 'response' object\n        rsp1 = responses.response(\n            method=\"put\",\n            url=\"http://example.com\",\n        )\n        responses.add(rsp1)\n        # register via direct arguments\n        responses.add(\n            responses.get,\n            \"http://twitter.com/api/1/foobar\",\n            json={\"error\": \"not found\"},\n            status=404,\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp2 = requests.put(\"http://example.com\")\n\n        assert resp.json() == {\"error\": \"not found\"}\n        assert resp.status_code == 404\n\n        assert resp2.status_code == 200\n        assert resp2.request.method == \"put\"\n\n\nif you attempt to fetch a url which doesn't hit a match, ``responses`` will raise\na ``connectionerror``:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n    from requests.exceptions import connectionerror\n\n\n    @responses.activate\n    def test_simple():\n        with pytest.raises(connectionerror):\n            requests.get(\"http://twitter.com/api/1/foobar\")\n\n\nshortcuts\n^^^^^^^^^\n\nshortcuts provide a shorten version of ``responses.add()`` where method argument is prefilled\n\n* responses.delete(``response args``) - register delete response\n* responses.get(``response args``) - register get response\n* responses.head(``response args``) - register head response\n* responses.options(``response args``) - register options response\n* responses.patch(``response args``) - register patch response\n* responses.post(``response args``) - register post response\n* responses.put(``response args``) - register put response\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"get\"},\n        )\n\n        responses.post(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"post\"},\n        )\n\n        responses.patch(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"type\": \"patch\"},\n        )\n\n        resp_get = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp_post = requests.post(\"http://twitter.com/api/1/foobar\")\n        resp_patch = requests.patch(\"http://twitter.com/api/1/foobar\")\n\n        assert resp_get.json() == {\"type\": \"get\"}\n        assert resp_post.json() == {\"type\": \"post\"}\n        assert resp_patch.json() == {\"type\": \"patch\"}\n\nresponses as a context manager\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\ninstead of wrapping the whole function with decorator you can use a context manager.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def test_my_api():\n        with responses.requestsmock() as rsps:\n            rsps.add(\n                responses.get,\n                \"http://twitter.com/api/1/foobar\",\n                body=\"{}\",\n                status=200,\n                content_type=\"application/json\",\n            )\n            resp = requests.get(\"http://twitter.com/api/1/foobar\")\n\n            assert resp.status_code == 200\n\n        # outside the context manager requests will hit the remote server\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        resp.status_code == 404\n\n\nresponse parameters\n-------------------\n\nthe following attributes can be passed to a response mock:\n\nmethod (``str``)\n    the http method (get, post, etc).\n\nurl (``str`` or ``compiled regular expression``)\n    the full resource url.\n\nmatch_querystring (``bool``)\n    deprecated: use ``responses.matchers.query_param_matcher`` or\n    ``responses.matchers.query_string_matcher``\n\n    include the query string when matching requests.\n    enabled by default if the response url contains a query string,\n    disabled if it doesn't or the url is a regular expression.\n\nbody (``str`` or ``bufferedreader`` or ``exception``)\n    the response body. read more `exception as response body`_\n\njson\n    a python object representing the json response body. automatically configures\n    the appropriate content-type.\n\nstatus (``int``)\n    the http status code.\n\ncontent_type (``content_type``)\n    defaults to ``text/plain``.\n\nheaders (``dict``)\n    response headers.\n\nstream (``bool``)\n    deprecated: use ``stream`` argument in request directly\n\nauto_calculate_content_length (``bool``)\n    disabled by default. automatically calculates the length of a supplied string or json body.\n\nmatch (``tuple``)\n    an iterable (``tuple`` is recommended) of callbacks to match requests\n    based on request attributes.\n    current module provides multiple matchers that you can use to match:\n\n    * body contents in json format\n    * body contents in url encoded data format\n    * request query parameters\n    * request query string (similar to query parameters but takes string as input)\n    * kwargs provided to request e.g. ``stream``, ``verify``\n    * 'multipart/form-data' content and headers in request\n    * request headers\n    * request fragment identifier\n\n    alternatively user can create custom matcher.\n    read more `matching requests`_\n\n\nexception as response body\n--------------------------\n\nyou can pass an ``exception`` as the body to trigger an error on the request:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_simple():\n        responses.get(\"http://twitter.com/api/1/foobar\", body=exception(\"...\"))\n        with pytest.raises(exception):\n            requests.get(\"http://twitter.com/api/1/foobar\")\n\n\nmatching requests\n-----------------\n\nmatching request body contents\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwhen adding responses for endpoints that are sent request data you can add\nmatchers to ensure your code is sending the right parameters and provide\ndifferent responses based on the request body contents. ``responses`` provides\nmatchers for json and url-encoded request bodies.\n\nurl-encoded data\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        responses.post(\n            url=\"http://calc.com/sum\",\n            body=\"4\",\n            match=[matchers.urlencoded_params_matcher({\"left\": \"1\", \"right\": \"3\"})],\n        )\n        requests.post(\"http://calc.com/sum\", data={\"left\": 1, \"right\": 3})\n\n\njson encoded data\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nmatching json encoded data can be done with ``matchers.json_params_matcher()``.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        responses.post(\n            url=\"http://example.com/\",\n            body=\"one\",\n            match=[\n                matchers.json_params_matcher({\"page\": {\"name\": \"first\", \"type\": \"json\"}})\n            ],\n        )\n        resp = requests.request(\n            \"post\",\n            \"http://example.com/\",\n            headers={\"content-type\": \"application/json\"},\n            json={\"page\": {\"name\": \"first\", \"type\": \"json\"}},\n        )\n\n\nquery parameters matcher\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nquery parameters as a dictionary\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nyou can use the ``matchers.query_param_matcher`` function to match\nagainst the ``params`` request parameter. just use the same dictionary as you\nwill use in ``params`` argument in ``request``.\n\nnote, do not use query parameters as part of the url. avoid using ``match_querystring``\ndeprecated argument.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_calc_api():\n        url = \"http://example.com/test\"\n        params = {\"hello\": \"world\", \"i am\": \"a big test\"}\n        responses.get(\n            url=url,\n            body=\"test\",\n            match=[matchers.query_param_matcher(params)],\n        )\n\n        resp = requests.get(url, params=params)\n\n        constructed_url = r\"http://example.com/test?i+am=a+big+test&hello=world\"\n        assert resp.url == constructed_url\n        assert resp.request.url == constructed_url\n        assert resp.request.params == params\n\nby default, matcher will validate that all parameters match strictly.\nto validate that only parameters specified in the matcher are present in original request\nuse ``strict_match=false``.\n\nquery parameters as a string\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nas alternative, you can use query string value in ``matchers.query_string_matcher`` to match\nquery parameters in your request\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses import matchers\n\n\n    @responses.activate\n    def my_func():\n        responses.get(\n            \"https://httpbin.org/get\",\n            match=[matchers.query_string_matcher(\"didi=pro&test=1\")],\n        )\n        resp = requests.get(\"https://httpbin.org/get\", params={\"test\": 1, \"didi\": \"pro\"})\n\n\n    my_func()\n\n\nrequest keyword arguments matcher\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nto validate request arguments use the ``matchers.request_kwargs_matcher`` function to match\nagainst the request kwargs.\n\nonly following arguments are supported: ``timeout``, ``verify``, ``proxies``, ``stream``, ``cert``.\n\nnote, only arguments provided to ``matchers.request_kwargs_matcher`` will be validated.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n    with responses.requestsmock(assert_all_requests_are_fired=false) as rsps:\n        req_kwargs = {\n            \"stream\": true,\n            \"verify\": false,\n        }\n        rsps.add(\n            \"get\",\n            \"http://111.com\",\n            match=[matchers.request_kwargs_matcher(req_kwargs)],\n        )\n\n        requests.get(\"http://111.com\", stream=true)\n\n        # >>>  arguments don't match: {stream: true, verify: true} doesn't match {stream: true, verify: false}\n\n\nrequest multipart/form-data data validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nto validate request body and headers for ``multipart/form-data`` data you can use\n``matchers.multipart_matcher``. the ``data``, and ``files`` parameters provided will be compared\nto the request:\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses.matchers import multipart_matcher\n\n\n    @responses.activate\n    def my_func():\n        req_data = {\"some\": \"other\", \"data\": \"fields\"}\n        req_files = {\"file_name\": b\"old world!\"}\n        responses.post(\n            url=\"http://httpbin.org/post\",\n            match=[multipart_matcher(req_files, data=req_data)],\n        )\n        resp = requests.post(\"http://httpbin.org/post\", files={\"file_name\": b\"new world!\"})\n\n\n    my_func()\n    # >>> raises connectionerror: multipart/form-data doesn't match. request body differs.\n\nrequest fragment identifier validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nto validate request url fragment identifier you can use ``matchers.fragment_identifier_matcher``.\nthe matcher takes fragment string (everything after ``#`` sign) as input for comparison:\n\n.. code-block:: python\n\n    import requests\n    import responses\n    from responses.matchers import fragment_identifier_matcher\n\n\n    @responses.activate\n    def run():\n        url = \"http://example.com?ab=xy&zed=qwe#test=1&foo=bar\"\n        responses.get(\n            url,\n            match=[fragment_identifier_matcher(\"test=1&foo=bar\")],\n            body=b\"test\",\n        )\n\n        # two requests to check reversed order of fragment identifier\n        resp = requests.get(\"http://example.com?ab=xy&zed=qwe#test=1&foo=bar\")\n        resp = requests.get(\"http://example.com?zed=qwe&ab=xy#foo=bar&test=1\")\n\n\n    run()\n\nrequest headers validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwhen adding responses you can specify matchers to ensure that your code is\nsending the right headers and provide different responses based on the request\nheaders.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_content_type():\n        responses.get(\n            url=\"http://example.com/\",\n            body=\"hello world\",\n            match=[matchers.header_matcher({\"accept\": \"text/plain\"})],\n        )\n\n        responses.get(\n            url=\"http://example.com/\",\n            json={\"content\": \"hello world\"},\n            match=[matchers.header_matcher({\"accept\": \"application/json\"})],\n        )\n\n        # request in reverse order to how they were added!\n        resp = requests.get(\"http://example.com/\", headers={\"accept\": \"application/json\"})\n        assert resp.json() == {\"content\": \"hello world\"}\n\n        resp = requests.get(\"http://example.com/\", headers={\"accept\": \"text/plain\"})\n        assert resp.text == \"hello world\"\n\nbecause ``requests`` will send several standard headers in addition to what was\nspecified by your code, request headers that are additional to the ones\npassed to the matcher are ignored by default. you can change this behaviour by\npassing ``strict_match=true`` to the matcher to ensure that only the headers\nthat you're expecting are sent and no others. note that you will probably have\nto use a ``preparedrequest`` in your code to ensure that ``requests`` doesn't\ninclude any additional headers.\n\n.. code-block:: python\n\n    import responses\n    import requests\n    from responses import matchers\n\n\n    @responses.activate\n    def test_content_type():\n        responses.get(\n            url=\"http://example.com/\",\n            body=\"hello world\",\n            match=[matchers.header_matcher({\"accept\": \"text/plain\"}, strict_match=true)],\n        )\n\n        # this will fail because requests adds its own headers\n        with pytest.raises(connectionerror):\n            requests.get(\"http://example.com/\", headers={\"accept\": \"text/plain\"})\n\n        # a prepared request where you overwrite the headers before sending will work\n        session = requests.session()\n        prepped = session.prepare_request(\n            requests.request(\n                method=\"get\",\n                url=\"http://example.com/\",\n            )\n        )\n        prepped.headers = {\"accept\": \"text/plain\"}\n\n        resp = session.send(prepped)\n        assert resp.text == \"hello world\"\n\n\ncreating custom matcher\n^^^^^^^^^^^^^^^^^^^^^^^\n\nif your application requires other encodings or different data validation you can build\nyour own matcher that returns ``tuple[matches: bool, reason: str]``.\nwhere boolean represents ``true`` or ``false`` if the request parameters match and\nthe string is a reason in case of match failure. your matcher can\nexpect a ``preparedrequest`` parameter to be provided by ``responses``.\n\nnote, ``preparedrequest`` is customized and has additional attributes ``params`` and ``req_kwargs``.\n\nresponse registry\n---------------------------\n\ndefault registry\n^^^^^^^^^^^^^^^^\n\nby default, ``responses`` will search all registered ``response`` objects and\nreturn a match. if only one ``response`` is registered, the registry is kept unchanged.\nhowever, if multiple matches are found for the same request, then first match is returned and\nremoved from registry.\n\nordered registry\n^^^^^^^^^^^^^^^^\n\nin some scenarios it is important to preserve the order of the requests and responses.\nyou can use ``registries.orderedregistry`` to force all ``response`` objects to be dependent\non the insertion order and invocation index.\nin following example we add multiple ``response`` objects that target the same url. however,\nyou can see, that status code will depend on the invocation order.\n\n\n.. code-block:: python\n\n    import requests\n\n    import responses\n    from responses.registries import orderedregistry\n\n\n    @responses.activate(registry=orderedregistry)\n    def test_invocation_index():\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"not found\"},\n            status=404,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"ok\"},\n            status=200,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"ok\"},\n            status=200,\n        )\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            json={\"msg\": \"not found\"},\n            status=404,\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 404\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 404\n\n\ncustom registry\n^^^^^^^^^^^^^^^\n\nbuilt-in ``registries`` are suitable for most of use cases, but to handle special conditions, you can\nimplement custom registry which must follow interface of ``registries.firstmatchregistry``.\nredefining the ``find`` method will allow you to create custom search logic and return\nappropriate ``response``\n\nexample that shows how to set custom registry\n\n.. code-block:: python\n\n    import responses\n    from responses import registries\n\n\n    class customregistry(registries.firstmatchregistry):\n        pass\n\n\n    print(\"before tests:\", responses.mock.get_registry())\n    \"\"\" before tests: <responses.registries.firstmatchregistry object> \"\"\"\n\n\n    # using function decorator\n    @responses.activate(registry=customregistry)\n    def run():\n        print(\"within test:\", responses.mock.get_registry())\n        \"\"\" within test: <__main__.customregistry object> \"\"\"\n\n\n    run()\n\n    print(\"after test:\", responses.mock.get_registry())\n    \"\"\" after test: <responses.registries.firstmatchregistry object> \"\"\"\n\n    # using context manager\n    with responses.requestsmock(registry=customregistry) as rsps:\n        print(\"in context manager:\", rsps.get_registry())\n        \"\"\" in context manager: <__main__.customregistry object> \"\"\"\n\n    print(\"after exit from context manager:\", responses.mock.get_registry())\n    \"\"\"\n    after exit from context manager: <responses.registries.firstmatchregistry object>\n    \"\"\"\n\ndynamic responses\n-----------------\n\nyou can utilize callbacks to provide dynamic responses. the callback must return\na tuple of (``status``, ``headers``, ``body``).\n\n.. code-block:: python\n\n    import json\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_calc_api():\n        def request_callback(request):\n            payload = json.loads(request.body)\n            resp_body = {\"value\": sum(payload[\"numbers\"])}\n            headers = {\"request-id\": \"728d329e-0e86-11e4-a748-0c84dc037c13\"}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.post,\n            \"http://calc.com/sum\",\n            callback=request_callback,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.post(\n            \"http://calc.com/sum\",\n            json.dumps({\"numbers\": [1, 2, 3]}),\n            headers={\"content-type\": \"application/json\"},\n        )\n\n        assert resp.json() == {\"value\": 6}\n\n        assert len(responses.calls) == 1\n        assert responses.calls[0].request.url == \"http://calc.com/sum\"\n        assert responses.calls[0].response.text == '{\"value\": 6}'\n        assert (\n            responses.calls[0].response.headers[\"request-id\"]\n            == \"728d329e-0e86-11e4-a748-0c84dc037c13\"\n        )\n\nyou can also pass a compiled regex to ``add_callback`` to match multiple urls:\n\n.. code-block:: python\n\n    import re, json\n\n    from functools import reduce\n\n    import responses\n    import requests\n\n    operators = {\n        \"sum\": lambda x, y: x + y,\n        \"prod\": lambda x, y: x * y,\n        \"pow\": lambda x, y: x**y,\n    }\n\n\n    @responses.activate\n    def test_regex_url():\n        def request_callback(request):\n            payload = json.loads(request.body)\n            operator_name = request.path_url[1:]\n\n            operator = operators[operator_name]\n\n            resp_body = {\"value\": reduce(operator, payload[\"numbers\"])}\n            headers = {\"request-id\": \"728d329e-0e86-11e4-a748-0c84dc037c13\"}\n            return (200, headers, json.dumps(resp_body))\n\n        responses.add_callback(\n            responses.post,\n            re.compile(\"http://calc.com/(sum|prod|pow|unsupported)\"),\n            callback=request_callback,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.post(\n            \"http://calc.com/prod\",\n            json.dumps({\"numbers\": [2, 3, 4]}),\n            headers={\"content-type\": \"application/json\"},\n        )\n        assert resp.json() == {\"value\": 24}\n\n\n    test_regex_url()\n\n\nif you want to pass extra keyword arguments to the callback function, for example when reusing\na callback function to give a slightly different result, you can use ``functools.partial``:\n\n.. code-block:: python\n\n    from functools import partial\n\n\n    def request_callback(request, id=none):\n        payload = json.loads(request.body)\n        resp_body = {\"value\": sum(payload[\"numbers\"])}\n        headers = {\"request-id\": id}\n        return (200, headers, json.dumps(resp_body))\n\n\n    responses.add_callback(\n        responses.post,\n        \"http://calc.com/sum\",\n        callback=partial(request_callback, id=\"728d329e-0e86-11e4-a748-0c84dc037c13\"),\n        content_type=\"application/json\",\n    )\n\n\nintegration with unit test frameworks\n-------------------------------------\n\nresponses as a ``pytest`` fixture\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n.. code-block:: python\n\n    @pytest.fixture\n    def mocked_responses():\n        with responses.requestsmock() as rsps:\n            yield rsps\n\n\n    def test_api(mocked_responses):\n        mocked_responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            body=\"{}\",\n            status=200,\n            content_type=\"application/json\",\n        )\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n\nadd default responses for each test\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwhen run with ``unittest`` tests, this can be used to set up some\ngeneric class-level responses, that may be complemented by each test.\nsimilar interface could be applied in ``pytest`` framework.\n\n.. code-block:: python\n\n    class testmyapi(unittest.testcase):\n        def setup(self):\n            responses.get(\"https://example.com\", body=\"within setup\")\n            # here go other self.responses.add(...)\n\n        @responses.activate\n        def test_my_func(self):\n            responses.get(\n                \"https://httpbin.org/get\",\n                match=[matchers.query_param_matcher({\"test\": \"1\", \"didi\": \"pro\"})],\n                body=\"within test\",\n            )\n            resp = requests.get(\"https://example.com\")\n            resp2 = requests.get(\n                \"https://httpbin.org/get\", params={\"test\": \"1\", \"didi\": \"pro\"}\n            )\n            print(resp.text)\n            # >>> within setup\n            print(resp2.text)\n            # >>> within test\n\n\nrequestmock methods: start, stop, reset\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n``responses`` has ``start``, ``stop``, ``reset`` methods very analogous to\n`unittest.mock.patch <https://docs.python.org/3/library/unittest.mock.html#patch-methods-start-and-stop>`_.\nthese make it simpler to do requests mocking in ``setup`` methods or where\nyou want to do multiple patches without nesting decorators or with statements.\n\n.. code-block:: python\n\n    class testunittestpatchsetup:\n        def setup(self):\n            \"\"\"creates ``requestsmock`` instance and starts it.\"\"\"\n            self.r_mock = responses.requestsmock(assert_all_requests_are_fired=true)\n            self.r_mock.start()\n\n            # optionally some default responses could be registered\n            self.r_mock.get(\"https://example.com\", status=505)\n            self.r_mock.put(\"https://example.com\", status=506)\n\n        def teardown(self):\n            \"\"\"stops and resets requestsmock instance.\n\n            if ``assert_all_requests_are_fired`` is set to ``true``, will raise an error\n            if some requests were not processed.\n            \"\"\"\n            self.r_mock.stop()\n            self.r_mock.reset()\n\n        def test_function(self):\n            resp = requests.get(\"https://example.com\")\n            assert resp.status_code == 505\n\n            resp = requests.put(\"https://example.com\")\n            assert resp.status_code == 506\n\n\nassertions on declared responses\n--------------------------------\n\nwhen used as a context manager, responses will, by default, raise an assertion\nerror if a url was registered but not accessed. this can be disabled by passing\nthe ``assert_all_requests_are_fired`` value:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def test_my_api():\n        with responses.requestsmock(assert_all_requests_are_fired=false) as rsps:\n            rsps.add(\n                responses.get,\n                \"http://twitter.com/api/1/foobar\",\n                body=\"{}\",\n                status=200,\n                content_type=\"application/json\",\n            )\n\nassert request call count\n-------------------------\n\nassert based on ``response`` object\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\neach ``response`` object has ``call_count`` attribute that could be inspected\nto check how many times each request was matched.\n\n.. code-block:: python\n\n    @responses.activate\n    def test_call_count_with_matcher():\n        rsp = responses.get(\n            \"http://www.example.com\",\n            match=(matchers.query_param_matcher({}),),\n        )\n        rsp2 = responses.get(\n            \"http://www.example.com\",\n            match=(matchers.query_param_matcher({\"hello\": \"world\"}),),\n            status=777,\n        )\n        requests.get(\"http://www.example.com\")\n        resp1 = requests.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com?hello=world\")\n        resp2 = requests.get(\"http://www.example.com?hello=world\")\n\n        assert resp1.status_code == 200\n        assert resp2.status_code == 777\n\n        assert rsp.call_count == 2\n        assert rsp2.call_count == 2\n\nassert based on the exact url\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nassert that the request was called exactly n times.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_assert_call_count():\n        responses.get(\"http://example.com\")\n\n        requests.get(\"http://example.com\")\n        assert responses.assert_call_count(\"http://example.com\", 1) is true\n\n        requests.get(\"http://example.com\")\n        with pytest.raises(assertionerror) as excinfo:\n            responses.assert_call_count(\"http://example.com\", 1)\n        assert (\n            \"expected url 'http://example.com' to be called 1 times. called 2 times.\"\n            in str(excinfo.value)\n        )\n\n\n    @responses.activate\n    def test_assert_call_count_always_match_qs():\n        responses.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com\")\n        requests.get(\"http://www.example.com?hello=world\")\n\n        # one call on each url, querystring is matched by default\n        responses.assert_call_count(\"http://www.example.com\", 1) is true\n        responses.assert_call_count(\"http://www.example.com?hello=world\", 1) is true\n\n\nassert request calls data\n-------------------------\n\n``request`` object has ``calls`` list which elements correspond to ``call`` objects\nin the global list of ``registry``. this can be useful when the order of requests is not\nguaranteed, but you need to check their correctness, for example in multithreaded\napplications.\n\n.. code-block:: python\n\n    import concurrent.futures\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_assert_calls_on_resp():\n        rsp1 = responses.patch(\"http://www.foo.bar/1/\", status=200)\n        rsp2 = responses.patch(\"http://www.foo.bar/2/\", status=400)\n        rsp3 = responses.patch(\"http://www.foo.bar/3/\", status=200)\n\n        def update_user(uid, is_active):\n            url = f\"http://www.foo.bar/{uid}/\"\n            response = requests.patch(url, json={\"is_active\": is_active})\n            return response\n\n        with concurrent.futures.threadpoolexecutor(max_workers=3) as executor:\n            future_to_uid = {\n                executor.submit(update_user, uid, is_active): uid\n                for (uid, is_active) in [(\"3\", true), (\"2\", true), (\"1\", false)]\n            }\n            for future in concurrent.futures.as_completed(future_to_uid):\n                uid = future_to_uid[future]\n                response = future.result()\n                print(f\"{uid} updated with {response.status_code} status code\")\n\n        assert len(responses.calls) == 3  # total calls count\n\n        assert rsp1.call_count == 1\n        assert rsp1.calls[0] in responses.calls\n        assert rsp1.calls[0].response.status_code == 200\n        assert json.loads(rsp1.calls[0].request.body) == {\"is_active\": false}\n\n        assert rsp2.call_count == 1\n        assert rsp2.calls[0] in responses.calls\n        assert rsp2.calls[0].response.status_code == 400\n        assert json.loads(rsp2.calls[0].request.body) == {\"is_active\": true}\n\n        assert rsp3.call_count == 1\n        assert rsp3.calls[0] in responses.calls\n        assert rsp3.calls[0].response.status_code == 200\n        assert json.loads(rsp3.calls[0].request.body) == {\"is_active\": true}\n\nmultiple responses\n------------------\n\nyou can also add multiple responses for the same url:\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_my_api():\n        responses.get(\"http://twitter.com/api/1/foobar\", status=500)\n        responses.get(\n            \"http://twitter.com/api/1/foobar\",\n            body=\"{}\",\n            status=200,\n            content_type=\"application/json\",\n        )\n\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 500\n        resp = requests.get(\"http://twitter.com/api/1/foobar\")\n        assert resp.status_code == 200\n\n\nurl redirection\n---------------\n\nin the following example you can see how to create a redirection chain and add custom exception that will be raised\nin the execution chain and contain the history of redirects.\n\n..  code-block::\n\n    a -> 301 redirect -> b\n    b -> 301 redirect -> c\n    c -> connection issue\n\n.. code-block:: python\n\n    import pytest\n    import requests\n\n    import responses\n\n\n    @responses.activate\n    def test_redirect():\n        # create multiple response objects where first two contain redirect headers\n        rsp1 = responses.response(\n            responses.get,\n            \"http://example.com/1\",\n            status=301,\n            headers={\"location\": \"http://example.com/2\"},\n        )\n        rsp2 = responses.response(\n            responses.get,\n            \"http://example.com/2\",\n            status=301,\n            headers={\"location\": \"http://example.com/3\"},\n        )\n        rsp3 = responses.response(responses.get, \"http://example.com/3\", status=200)\n\n        # register above generated responses in ``response`` module\n        responses.add(rsp1)\n        responses.add(rsp2)\n        responses.add(rsp3)\n\n        # do the first request in order to generate genuine ``requests`` response\n        # this object will contain genuine attributes of the response, like ``history``\n        rsp = requests.get(\"http://example.com/1\")\n        responses.calls.reset()\n\n        # customize exception with ``response`` attribute\n        my_error = requests.connectionerror(\"custom error\")\n        my_error.response = rsp\n\n        # update body of the 3rd response with exception, this will be raised during execution\n        rsp3.body = my_error\n\n        with pytest.raises(requests.connectionerror) as exc_info:\n            requests.get(\"http://example.com/1\")\n\n        assert exc_info.value.args[0] == \"custom error\"\n        assert rsp1.url in exc_info.value.response.history[0].url\n        assert rsp2.url in exc_info.value.response.history[1].url\n\n\nvalidate ``retry`` mechanism\n----------------------------\n\nif you are using the ``retry`` features of ``urllib3`` and want to cover scenarios that test your retry limits, you can test those scenarios with ``responses`` as well. the best approach will be to use an `ordered registry`_\n\n.. code-block:: python\n\n    import requests\n\n    import responses\n    from responses import registries\n\n\n    @responses.activate(registry=registries.orderedregistry)\n    def test_max_retries():\n        url = \"https://example.com\"\n        rsp1 = responses.get(url, body=\"error\", status=500)\n        rsp2 = responses.get(url, body=\"error\", status=500)\n        rsp3 = responses.get(url, body=\"error\", status=500)\n        rsp4 = responses.get(url, body=\"ok\", status=200)\n\n        session = requests.session()\n\n        adapter = requests.adapters.httpadapter(\n            max_retries=retry(\n                total=4,\n                backoff_factor=0.1,\n                status_forcelist=[500],\n                method_whitelist=[\"get\", \"post\", \"patch\"],\n            )\n        )\n        session.mount(\"https://\", adapter)\n\n        resp = session.get(url)\n\n        assert resp.status_code == 200\n        assert rsp1.call_count == 1\n        assert rsp2.call_count == 1\n        assert rsp3.call_count == 1\n        assert rsp4.call_count == 1\n\n\nusing a callback to modify the response\n---------------------------------------\n\nif you use customized processing in ``requests`` via subclassing/mixins, or if you\nhave library tools that interact with ``requests`` at a low level, you may need\nto add extended processing to the mocked response object to fully simulate the\nenvironment for your tests.  a ``response_callback`` can be used, which will be\nwrapped by the library before being returned to the caller.  the callback\naccepts a ``response`` as it's single argument, and is expected to return a\nsingle ``response`` object.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    def response_callback(resp):\n        resp.callback_processed = true\n        return resp\n\n\n    with responses.requestsmock(response_callback=response_callback) as m:\n        m.add(responses.get, \"http://example.com\", body=b\"test\")\n        resp = requests.get(\"http://example.com\")\n        assert resp.text == \"test\"\n        assert hasattr(resp, \"callback_processed\")\n        assert resp.callback_processed is true\n\n\npassing through real requests\n-----------------------------\n\nin some cases you may wish to allow for certain requests to pass through responses\nand hit a real server. this can be done with the ``add_passthru`` methods:\n\n.. code-block:: python\n\n    import responses\n\n\n    @responses.activate\n    def test_my_api():\n        responses.add_passthru(\"https://percy.io\")\n\nthis will allow any requests matching that prefix, that is otherwise not\nregistered as a mock response, to passthru using the standard behavior.\n\npass through endpoints can be configured with regex patterns if you\nneed to allow an entire domain or path subtree to send requests:\n\n.. code-block:: python\n\n    responses.add_passthru(re.compile(\"https://percy.io/\\\\w+\"))\n\n\nlastly, you can use the ``passthrough`` argument of the ``response`` object\nto force a response to behave as a pass through.\n\n.. code-block:: python\n\n    # enable passthrough for a single response\n    response = response(\n        responses.get,\n        \"http://example.com\",\n        body=\"not used\",\n        passthrough=true,\n    )\n    responses.add(response)\n\n    # use passthroughresponse\n    response = passthroughresponse(responses.get, \"http://example.com\")\n    responses.add(response)\n\nviewing/modifying registered responses\n--------------------------------------\n\nregistered responses are available as a public method of the requestmock\ninstance. it is sometimes useful for debugging purposes to view the stack of\nregistered responses which can be accessed via ``responses.registered()``.\n\nthe ``replace`` function allows a previously registered ``response`` to be\nchanged. the method signature is identical to ``add``. ``response`` s are\nidentified using ``method`` and ``url``. only the first matched ``response`` is\nreplaced.\n\n.. code-block:: python\n\n    import responses\n    import requests\n\n\n    @responses.activate\n    def test_replace():\n        responses.get(\"http://example.org\", json={\"data\": 1})\n        responses.replace(responses.get, \"http://example.org\", json={\"data\": 2})\n\n        resp = requests.get(\"http://example.org\")\n\n        assert resp.json() == {\"data\": 2}\n\n\nthe ``upsert`` function allows a previously registered ``response`` to be\nchanged like ``replace``. if the response is registered, the ``upsert`` function\nwill registered it like ``add``.\n\n``remove`` takes a ``method`` and ``url`` argument and will remove **all**\nmatched responses from the registered list.\n\nfinally, ``reset`` will reset all registered responses.\n\ncoroutines and multithreading\n-----------------------------\n\n``responses`` supports both coroutines and multithreading out of the box.\nnote, ``responses`` locks threading on ``requestmock`` object allowing only\nsingle thread to access it.\n\n.. code-block:: python\n\n    async def test_async_calls():\n        @responses.activate\n        async def run():\n            responses.get(\n                \"http://twitter.com/api/1/foobar\",\n                json={\"error\": \"not found\"},\n                status=404,\n            )\n\n            resp = requests.get(\"http://twitter.com/api/1/foobar\")\n            assert resp.json() == {\"error\": \"not found\"}\n            assert responses.calls[0].request.url == \"http://twitter.com/api/1/foobar\"\n\n        await run()\n\n\ncontributing\n------------\n\nenvironment configuration\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\nresponses uses several linting and autoformatting utilities, so it's important that when\nsubmitting patches you use the appropriate toolchain:\n\nclone the repository:\n\n.. code-block:: shell\n\n    git clone https://github.com/getsentry/responses.git\n\ncreate an environment (e.g. with ``virtualenv``):\n\n.. code-block:: shell\n\n    virtualenv .env && source .env/bin/activate\n\nconfigure development requirements:\n\n.. code-block:: shell\n\n    make develop\n\n\ntests and code quality validation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nthe easiest way to validate your code is to run tests via ``tox``.\ncurrent ``tox`` configuration runs the same checks that are used in\ngithub actions ci/cd pipeline.\n\nplease execute the following command line from the project root to validate\nyour code against:\n\n* unit tests in all python versions that are supported by this project\n* type validation via ``mypy``\n* all ``pre-commit`` hooks\n\n.. code-block:: shell\n\n    tox\n\nalternatively, you can always run a single test. see documentation below.\n\nunit tests\n\"\"\"\"\"\"\"\"\"\"\n\nresponses uses `pytest <https://docs.pytest.org/en/latest/>`_ for\ntesting. you can run all tests by:\n\n.. code-block:: shell\n\n    tox -e py37\n    tox -e py310\n\nor manually activate required version of python and run\n\n.. code-block:: shell\n\n    pytest\n\nand run a single test by:\n\n.. code-block:: shell\n\n    pytest -k '<test_function_name>'\n\ntype validation\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nto verify ``type`` compliance, run `mypy <https://github.com/python/mypy>`_ linter:\n\n.. code-block:: shell\n\n    tox -e mypy\n\nor\n\n.. code-block:: shell\n\n    mypy --config-file=./mypy.ini -p responses\n\ncode quality and style\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nto check code style and reformat it run:\n\n.. code-block:: shell\n\n    tox -e precom\n\nor\n\n.. code-block:: shell\n\n    pre-commit run --all-files\n\n\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache 2.0",
  "name": "responses",
  "package_url": "https://pypi.org/project/responses/",
  "project_url": "https://pypi.org/project/responses/",
  "project_urls": {
    "Bug Tracker": "https://github.com/getsentry/responses/issues",
    "Changes": "https://github.com/getsentry/responses/blob/master/CHANGES",
    "Documentation": "https://github.com/getsentry/responses/blob/master/README.rst",
    "Homepage": "https://github.com/getsentry/responses",
    "Source Code": "https://github.com/getsentry/responses"
  },
  "release_url": "https://pypi.org/project/responses/0.24.1/",
  "requires_dist": [],
  "requires_python": ">=3.8",
  "summary": "a utility library for mocking out the `requests` python library.",
  "version": "0.24.1",
  "releases": [],
  "developers": [
    "david_cramer"
  ],
  "kwds": "mocked_responses pyversions request_kwargs_matcher response_callback requestsmock",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_responses",
  "homepage": "https://github.com/getsentry/responses",
  "release_count": 54,
  "dependency_ids": []
}