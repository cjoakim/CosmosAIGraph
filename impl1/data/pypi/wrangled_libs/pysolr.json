{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 3",
    "topic :: internet :: www/http :: indexing/search"
  ],
  "description": "======\npysolr\n======\n\n``pysolr`` is a lightweight python client for `apache solr`_. it provides an\ninterface that queries the server and returns results based on the query.\n\n.. _`apache solr`: http://lucene.apache.org/solr/\n\nstatus\n======\n\n.. image:: https://secure.travis-ci.org/django-haystack/pysolr.png\n   :target: https://secure.travis-ci.org/django-haystack/pysolr\n\n`changelog <https://github.com/django-haystack/pysolr/blob/master/changelog.rst>`_\n\nfeatures\n========\n\n* basic operations such as selecting, updating & deleting.\n* index optimization.\n* `\"more like this\" <http://wiki.apache.org/solr/morelikethis>`_ support (if set up in solr).\n* `spelling correction <http://wiki.apache.org/solr/spellcheckcomponent>`_ (if set up in solr).\n* timeout support.\n* solrcloud awareness\n\nrequirements\n============\n\n* python 2.7 - 3.7\n* requests 2.9.1+\n* **optional** - ``simplejson``\n* **optional** - ``kazoo`` for solrcloud mode\n\ninstallation\n============\n\npysolr is on pypi:\n\n.. code-block:: console\n\n   $ pip install pysolr\n\nor if you want to install directly from the repository:\n\n.. code-block:: console\n\n    $ python setup.py install\n\nusage\n=====\n\nbasic usage looks like:\n\n.. code-block:: python\n\n    # if on python 2.x\n    from __future__ import print_function\n\n    import pysolr\n\n    # create a client instance. the timeout and authentication options are not required.\n    solr = pysolr.solr('http://localhost:8983/solr/', always_commit=true, [timeout=10], [auth=<type of authentication>])\n\n    # note that auto_commit defaults to false for performance. you can set\n    # `auto_commit=true` to have commands always update the index immediately, make\n    # an update call with `commit=true`, or use solr's `autocommit` / `commitwithin`\n    # to have your data be committed following a particular policy.\n\n    # do a health check.\n    solr.ping()\n\n    # how you'd index data.\n    solr.add([\n        {\n            \"id\": \"doc_1\",\n            \"title\": \"a test document\",\n        },\n        {\n            \"id\": \"doc_2\",\n            \"title\": \"the banana: tasty or dangerous?\",\n            \"_doc\": [\n                { \"id\": \"child_doc_1\", \"title\": \"peel\" },\n                { \"id\": \"child_doc_2\", \"title\": \"seed\" },\n            ]\n        },\n    ])\n\n    # you can index a parent/child document relationship by\n    # associating a list of child documents with the special key '_doc'. this\n    # is helpful for queries that join together conditions on children and parent\n    # documents.\n\n    # later, searching is easy. in the simple case, just a plain lucene-style\n    # query is fine.\n    results = solr.search('bananas')\n\n    # the ``results`` object stores total results found, by default the top\n    # ten most relevant results and any additional data like\n    # facets/highlighting/spelling/etc.\n    print(\"saw {0} result(s).\".format(len(results)))\n\n    # just loop over it to access the results.\n    for result in results:\n        print(\"the title is '{0}'.\".format(result['title']))\n\n    # for a more advanced query, say involving highlighting, you can pass\n    # additional options to solr.\n    results = solr.search('bananas', **{\n        'hl': 'true',\n        'hl.fragsize': 10,\n    })\n\n    # you can also perform more like this searches, if your solr is configured\n    # correctly.\n    similar = solr.more_like_this(q='id:doc_2', mltfl='text')\n\n    # finally, you can delete either individual documents,\n    solr.delete(id='doc_1')\n\n    # also in batches...\n    solr.delete(id=['doc_1', 'doc_2'])\n\n    # ...or all documents.\n    solr.delete(q='*:*')\n\n.. code-block:: python\n\n    # for solrcloud mode, initialize your solr like this:\n\n    zookeeper = pysolr.zookeeper(\"zkhost1:2181,zkhost2:2181,zkhost3:2181\")\n    solr = pysolr.solrcloud(zookeeper, \"collection1\", auth=<type of authentication>)\n\n\nmulticore index\n~~~~~~~~~~~~~~~\n\nsimply point the url to the index core:\n\n.. code-block:: python\n\n    # setup a solr instance. the timeout is optional.\n    solr = pysolr.solr('http://localhost:8983/solr/core_0/', timeout=10)\n\n\ncustom request handlers\n~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # setup a solr instance. the trailing slash is optional.\n    solr = pysolr.solr('http://localhost:8983/solr/core_0/', search_handler='/autocomplete', use_qt_param=false)\n\n\nif ``use_qt_param`` is ``true`` it is essential that the name of the handler is\nexactly what is configured in ``solrconfig.xml``, including the leading slash\nif any. if ``use_qt_param`` is ``false`` (default), the leading and trailing\nslashes can be omitted.\n\nif ``search_handler`` is not specified, pysolr will default to ``/select``.\n\nthe handlers for morelikethis, update, terms etc. all default to the values set\nin the ``solrconfig.xml`` solr ships with: ``mlt``, ``update``, ``terms`` etc.\nthe specific methods of pysolr's ``solr`` class (like ``more_like_this``,\n``suggest_terms`` etc.) allow for a kwarg ``handler`` to override that value.\nthis includes the ``search`` method. setting a handler in ``search`` explicitly\noverrides the ``search_handler`` setting (if any).\n\n\ncustom authentication\n~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # setup a solr instance in a kerborized enviornment\n    from requests_kerberos import httpkerberosauth, optional\n    kerberos_auth = httpkerberosauth(mutual_authentication=optional, sanitize_mutual_error_response=false)\n\n    solr = pysolr.solr('http://localhost:8983/solr/', auth=kerberos_auth)\n\n.. code-block:: python\n\n    # setup a cloudsolr instance in a kerborized environment\n    from requests_kerberos import httpkerberosauth, optional\n    kerberos_auth = httpkerberosauth(mutual_authentication=optional, sanitize_mutual_error_response=false)\n\n    zookeeper = pysolr.zookeeper(\"zkhost1:2181/solr, zkhost2:2181,...,zkhostn:2181\")\n    solr = pysolr.solrcloud(zookeeper, \"collection\", auth=kerberos_auth)\n\n\nif your solr servers run off https\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # setup a solr instance in an https environment\n    solr = pysolr.solr('http://localhost:8983/solr/', verify=path/to/cert.pem)\n\n.. code-block:: python\n\n    # setup a cloudsolr instance in a kerborized environment\n\n    zookeeper = pysolr.zookeeper(\"zkhost1:2181/solr, zkhost2:2181,...,zkhostn:2181\")\n    solr = pysolr.solrcloud(zookeeper, \"collection\", verify=path/to/cert.perm)\n\n\ncustom commit policy\n~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    # setup a solr instance. the trailing slash is optional.\n    # all requests to solr will be immediately committed because `always_commit=true`:\n    solr = pysolr.solr('http://localhost:8983/solr/core_0/', search_handler='/autocomplete', always_commit=true)\n\n``always_commit`` signals to the solr object to either commit or not commit by\ndefault for any solr request. be sure to change this to ``true`` if you are\nupgrading from a version where the default policy was always commit by default.\n\nfunctions like ``add`` and ``delete`` also still provide a way to override the\ndefault by passing the ``commit`` kwarg.\n\nit is generally good practice to limit the amount of commits to solr as\nexcessive commits risk opening too many searchers or excessive system\nresource consumption. see the solr documentation for more information and\ndetails about the ``autocommit`` and ``commitwithin`` options:\n\nhttps://lucene.apache.org/solr/guide/7_7/updatehandlers-in-solrconfig.html#updatehandlersinsolrconfig-autocommit\n\n\nlicense\n=======\n\n``pysolr`` is licensed under the new bsd license.\n\ncontributing to pysolr\n======================\n\nfor consistency, this project uses `pre-commit <https://pre-commit.com/>`_ to manage git commit hooks:\n\n#. install the `pre-commit` package: e.g. `brew install pre-commit`,\n   `pip install pre-commit`, etc.\n#. run `pre-commit install` each time you check out a new copy of this git\n   repository to ensure that every subsequent commit will be processed by\n   running `pre-commit run`, which you may also do as desired. to test the\n   entire repository or in a ci scenario, you can check every file rather than\n   just the staged ones using `pre-commit run --all`.\n\n\nrunning tests\n=============\n\nthe ``run-tests.py`` script will automatically perform the steps below and is\nrecommended for testing by default unless you need more control.\n\nrunning a test solr instance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\ndownloading, configuring and running solr 4 looks like this::\n\n    ./start-solr-test-server.sh\n\nrunning the tests\n~~~~~~~~~~~~~~~~~\n\n.. code-block:: console\n\n    $ python -m unittest tests\n",
  "docs_url": null,
  "keywords": "",
  "license": "bsd",
  "name": "pysolr",
  "package_url": "https://pypi.org/project/pysolr/",
  "project_url": "https://pypi.org/project/pysolr/",
  "project_urls": {
    "Homepage": "https://github.com/django-haystack/pysolr/"
  },
  "release_url": "https://pypi.org/project/pysolr/3.9.0/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "lightweight python client for apache solr",
  "version": "3.9.0",
  "releases": [],
  "developers": [
    "daniel@toastdriven.com",
    "daniel_lindsley"
  ],
  "kwds": "solr lucene search_handler django haystack",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_pysolr",
  "homepage": "https://github.com/django-haystack/pysolr/",
  "release_count": 37,
  "dependency_ids": []
}