{
  "classifiers": [
    "environment :: console",
    "intended audience :: developers",
    "license :: osi approved :: isc license (iscl)",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 2",
    "programming language :: python :: 2.6",
    "programming language :: python :: 2.7",
    "programming language :: python :: 3",
    "programming language :: python :: 3.3",
    "programming language :: python :: 3.4",
    "programming language :: python :: 3.5",
    "programming language :: python :: 3.6",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "\n| |travisci| |version| |versions| |impls| |wheel| |coverage| |br-coverage|\n\n.. |travisci| image:: https://api.travis-ci.org/jonathaneunice/colors.svg\n    :target: http://travis-ci.org/jonathaneunice/colors\n\n.. |version| image:: http://img.shields.io/pypi/v/ansicolors.svg?style=flat\n    :alt: pypi package latest release\n    :target: https://pypi.python.org/pypi/ansicolors\n\n.. |versions| image:: https://img.shields.io/pypi/pyversions/ansicolors.svg\n    :alt: supported versions\n    :target: https://pypi.python.org/pypi/ansicolors\n\n.. |impls| image:: https://img.shields.io/pypi/implementation/ansicolors.svg\n    :alt: supported implementations\n    :target: https://pypi.python.org/pypi/ansicolors\n\n.. |wheel| image:: https://img.shields.io/pypi/wheel/ansicolors.svg\n    :alt: wheel packaging support\n    :target: https://pypi.python.org/pypi/ansicolors\n\n.. |coverage| image:: https://img.shields.io/badge/test_coverage-100%25-6600cc.svg\n    :alt: test line coverage\n    :target: https://pypi.python.org/pypi/ansicolors\n\n.. |br-coverage| image:: https://img.shields.io/badge/branch_coverage-100%25-6600cc.svg\n    :alt: test branch coverage\n    :target: https://pypi.python.org/pypi/ansicolors\n\nansi colors for python\n======================\n\nadd ansi colors and decorations to your strings.\n\nexample usage\n-------------\n\n::\n\n    from __future__ import print_function  # accomodate python 2\n    from colors import *\n\n    print(color('my string', fg='blue'))\n    print(color('some text', fg='red', bg='yellow', style='underline'))\n\nthe strings returned by ``color`` will have embedded\n`ansi code sequences <https://en.wikipedia.org/wiki/ansi_escape_code>`_\nstipulating text colors and styles. for example, the above\ncode will print the strings::\n\n    '\\x1b[34mmy string\\x1b[0m'\n    '\\x1b[31;43;4msome text\\x1b[0m'\n\nyou can choose the foreground (text) color with the ``fg`` parameter,\nthe background color with ``bg``, and the style with ``style``.\n\nyou can choose one of the 8 basic ansi colors: ``black``, ``red``, ``green``,\n``yellow``, ``blue``, ``magenta``, ``cyan``, and ``white``, plus a special\n``default`` which is display-specific, but usually a rational \"no special\ncolor\" setting.\n\nthere are other ways to specify colors. many devices support\nan idiosyncratic 256-color scheme developed as an extension to\nthe original ansi codes for the\n`xterm terminal emulator <https://en.wikipedia.org/wiki/xterm>`_.\ncolors (or grays) from this larger palette can be specified via ``int``\nvalue (0-255).\n\nto see them all::\n\n    from __future__ import print_function\n    from colors import color\n\n    for i in range(256):\n        print(color('color #%d' % i, fg=i))\n\n\nthe included ``show_colors.py`` program is a much-expanded version of this idea\nthat can be used to explore available color and style combinations on your\nterminal or output device.\n\n24-bit color and css compatibility\n----------------------------------\n\nmodern terminals go even further than the ``xterm`` 256, often supporting a\nfull 24-bit rgb color scheme. you can provide a full rgb value several ways:\n\n* with a 3-element ``tuple`` or ``list`` of ``int``, each valued 0 to 255 (e.g. ``(255, 218, 185)``),\n* a string containing a css-compatible color name (e.g. ``'peachpuff'``),\n* a string containing a css-style hex value (e.g. ``'#aaa'`` or ``'#8a2be2'``)\n* a string containing a css-style rgb notation (e.g. ``'rgb(102,51,153)'``)\n\nthese forms can be mixed and matched at will::\n\n    print(color('orange on gray', 'orange', 'gray'))\n    print(color('nice color', 'white', '#8a2be2'))\n\nnote that any color name defined in the basic ansi color set takes\nprimacy over the css color names. combined with the fact that\nterminals do not always agree which precise tone of blue should\nqualify as ansi ``blue``, there can be some ambiguity regarding\nthe named colors. if you need full precision, specify the rgb\ncolor exactly. the ``parse_rgb`` function can be used to identify\nthe correct definition according to the css standards.\n\ncaveats\n-------\n\nunfortunately there is no guarantee that every terminal will support all the\ncolors and styles ansi ostensibly defines. in fact, most implement a rather\nsmall subset. colors are better supported than styles, for which you *might* get\none or two of the most popular such as ``bold`` or ``underline``.\n*might.*\n\nwhatever colors and styles are supported, there is no guarantee they will be\naccurately rendered. even at this late date, over **fifty years** after the codes\nbegan to be standardized, support from terminals and output devices is limited,\nfragemented, and piecemeal.\n\nansi codes evolved in an entirely different historical context from today's.\nboth the web and the idea of broad standardization were decades in the future.\ndisplay technology was low-resolution, colors were limited on the rare occasions\nthey were present, and color/style fidelity was not a major consideration.\nvendors thought little or nothing of creating their own proprietary codes,\nimplementing functions differently from other vendors, and/or co-opting codes\npreviously in use for something else. practical ansi reference materials\ninclude *many* phrases such as 'hardly ever supported' and 'non-standard.'\n\nwe still use ansi codes today not because they're especially good, but because\nthey're the best, most-standard approach that pre-web displays even remotely\nagreed upon. even deep into the web era, text output endures as an important\nmeans of human-computer interaction. the good news, such is it is: ansi's color\nand style specifications (\"sgr\" or \"select graphic rendition\" in ansi\nterminology) are the most-used and best-adhered-to portion of the whole ansi\nshow.\n\nmore examples\n-------------\n\n::\n\n    # use some partial functions\n\n    from __future__ import print_function # so works on python 2 and 3 alike\n    from colors import red, green, blue\n\n    print(red('this is red'))\n    print(green('this is green'))\n    print(blue('this is blue'))\n\noptionally you can add a background color and/or styles.::\n\n    print(red('red on blue', bg='blue'))\n    print(green('green on black', bg='black', style='underline'))\n\nyou can use multiple styles at once. separate them with\na ``+``.::\n\n    print(red('very important', style='bold+underline'))\n\nyou can additionally specify one of the supported styles: ``none``, ``bold``,\n``faint``, ``italic``, ``underline``, ``blink``, ``blink2``, ``negative``,\n``concealed``, ``crossed``. while most devices support only a few styles,\nunsupported styles are generally ignored, so the only harm done is your text is\nless pretty and/or formatted than you might like. a good general rule is\nto enjoy the formatting if you get it, but don't depend on it--especially\ndon't depend on styles like ``blink`` (e.g. to highlight critical data) or\n``concealed`` (e.g. to hide data). most likely, they won't.\n\nif you use a style often, you may want to create your own\nnamed style::\n\n    from functools import partial\n    from colors import color\n\n    important = partial(color, fg='red', style='bold+underline'))\n\n    print(important('this is very important!'))\n\nutility functions\n-----------------\n\nin deailing with ansi-styled text, it can be necessary to determine the\n\"equivalent\" text minus the styling. the function ``strip_color(s)`` does that,\nremoving ansi codes from ``s``, returning its \"plain text equivalent.\"\n\nyou may also wish to determine the effective length of a string. if it contains\nansi codes, the builtin ``len()`` function will return the length including\nthose codes, even though they are logically 0-length. so plain ``len(s)`` is\nprobably not what you need. ``ansilen(s)`` in contrast returns the \"effective\"\nlength of the string, including only the non-ansi characters. ``ansilen(s)`` is\nequivalent to ``len(strip_color(s))``,\n\nlicense\n-------\n\n``colors`` is licensed under the `isc license <https://en.wikipedia.org/wiki/isc_license>`_.\n",
  "docs_url": null,
  "keywords": "asni color style console",
  "license": "isc",
  "name": "ansicolors",
  "package_url": "https://pypi.org/project/ansicolors/",
  "project_url": "https://pypi.org/project/ansicolors/",
  "project_urls": {
    "Homepage": "http://github.com/jonathaneunice/colors/"
  },
  "release_url": "https://pypi.org/project/ansicolors/1.1.8/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "ansi colors for python",
  "version": "1.1.8",
  "releases": [],
  "developers": [
    "jonathan.eunice@gmail.com",
    "jonathan_eunice"
  ],
  "kwds": "ansicolors show_colors pyversions strip_color asni",
  "license_kwds": "isc",
  "libtype": "pypi",
  "id": "pypi_ansicolors",
  "homepage": "http://github.com/jonathaneunice/colors/",
  "release_count": 7,
  "dependency_ids": []
}