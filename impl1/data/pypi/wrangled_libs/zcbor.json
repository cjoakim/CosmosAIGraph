{
  "classifiers": [
    "development status :: 4 - beta",
    "license :: osi approved :: apache software license",
    "programming language :: python :: 3",
    "topic :: software development :: build tools"
  ],
  "description": "zcbor\n=====\n\nzcbor is a low footprint [cbor](https://en.wikipedia.org/wiki/cbor) library in the c language (c++ compatible), tailored for use in microcontrollers.\nit comes with a schema-driven script tool that can validate your data, or even generate code.\nthe schema language (cddl) allows creating very advanced and detailed schemas.\n\nthe validation and conversion part of the tool works with yaml and json data, in addition to cbor.\nit can for example validate a yaml file against a schema and convert it into cbor.\n\nthe code generation part of the tool generates c code based on the given schema.\nthe generated code performs cbor encoding and decoding using the c library, while also validating the data against all the rules in the schema.\n\nthe schema language used by zcbor is cddl (consise data definition language) which is a powerful human-readable data description language defined in [ietf rfc 8610](https://datatracker.ietf.org/doc/rfc8610/).\n\n\nfeatures\n========\n\nhere are some possible ways zcbor can be used:\n\n - c code:\n   - as a low-footprint cbor decoding/encoding library similar to tinycbor/qcbor/nanocbor. the library can be used independently of the python script. ([more information](#cbor-decodingencoding-library))\n   - to generate c code (using the python script) for validating and decoding or encoding cbor, for use in optimized or constrained environments, such as microcontrollers. ([more information](#code-generation))\n - python script and module ([more information](#python-script-and-module)):\n   - validate a yaml/json file and translate it into cbor e.g. for transmission.\n   - validate a yaml/json/cbor file before processing it with some other tool\n   - decode and validate incoming cbor data into human-readable yaml/json.\n   - as part of a python script that processes yaml/json/cbor files.\n     - uses the same internal representation used by the pyyaml/json/cbor2 libraries.\n     - do validation against a cddl schema.\n     - create a read-only representation via named tuples (with names taken from the cddl schema).\n\n\ngetting started\n===============\n\nthere are samples in the [samples](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/samples) directory that demonstrate different ways to use zcbor, both the script tool and the c code.\n\n1. the [hello_world sample](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/samples/hello_world/readme.md) is a minimum examples of encoding and decoding using the c library.\n2. the [pet sample](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/samples/pet/readme.md) shows a how to use the c library together with generated code, and how to use the script tool to do code generation and data conversion.\n\nthe [tests](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests) also demonstrate how to use zcbor in different ways. the [encoding](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/encode), [decoding](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/decode), and [unit](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/unit) tests run using [zephyr](https://github.com/zephyrproject-rtos/zephyr) (the samples do not use zephyr).\n\nshould i use code generation or the library directly?\n-----------------------------------------------------\n\nthe benefit of using code generation is greater for decoding than encoding.\nthis is because decoding is generally more complex than encoding, since when decoding you have to gracefully handle all possible payloads.\nthe code generation will provide a number of checks that are tedious to write manually.\nthese checks ensure that the payload is well-formed.\n\n\ncbor decoding/encoding library\n==============================\n\nthe cbor library can be found in [include/](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/include) and [src/](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/src) and can be used directly, by including the files in your project.\nif using zcbor with zephyr, the library will be available when the [config_zcbor](https://docs.zephyrproject.org/latest/kconfig.html#config_zcbor) config is enabled.\n\nthe library is also used by generated code. see the the [code generation](#code-generation) section for more info about code generation.\n\nthe c library is c++ compatible.\n\nthe zcbor state object\n----------------------\n\nto do encoding or decoding with the library, instantiate a `zcbor_state_t` object, which is most easily done using the `zcbor_state_*()` macros, look below or in the [hello_world](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/samples/hello_world/src/main.c) sample for example code.\n\nthe `elem_count` member refers to the number of encoded objects in the current list or map.\n`elem_count` starts again when entering a nested list or map, and is restored when exiting.\n\n`elem_count` is one reason for needing \"backup\" states (the other is to allow rollback of the payload).\nbackups are needed for _decoding_ if there are any lists, maps, or cbor-encoded strings (`zcbor_bstr_*_decode`) in the data.\nbackups are needed for _encoding_ if there are any lists or maps *and* you are using canonical encoding (`zcbor_canonical`), or when using the `zcbor_bstr_*_encode` functions.\n\n```c\n/** initialize a decoding state (could include an array of backup states).\n *  after calling this, decode_state[0] is ready to be used with the decoding apis. */\nzcbor_state_d(decode_state, n, payload, payload_len, elem_count);\n\n/** initialize an encoding state (could include an array of backup states).\n *  after calling this, encode_state[0] is ready to be used with the encoding apis. */\nzcbor_state_e(encode_state, n, payload, payload_len, 0);\n```\n\nconfiguration\n-------------\n\nthe c library has a few compile-time configuration options.\nthese configuration options can be enabled by adding them as compile definitions to the build.\nif using zcbor with zephyr, use the [kconfig options](https://github.com/zephyrproject-rtos/zephyr/blob/main/modules/zcbor/kconfig) instead.\n\nname                      | description\n------------------------- | -----------\n`zcbor_canonical`         | when encoding lists and maps, do not use indefinite length encoding. enabling `zcbor_canonical` increases code size and makes the encoding library more often use state backups.\n`zcbor_verbose`           | print messages on encoding/decoding errors (`zcbor_print()`), and also a trace message (`zcbor_trace()`) for each decoded value, and in each generated function (when using code generation). requires `printk` as found in zephyr.\n`zcbor_asserts`           | enable asserts (`zcbor_assert()`). when they fail, the assert statements instruct the current function to return a `zcbor_err_assertion` error. if `zcbor_verbose` is enabled, a message is printed.\n`zcbor_stop_on_error`     | enable the `stop_on_error` functionality. this makes all functions abort their execution if called when an error has already happened.\n`zcbor_big_endian`        | all decoded values are returned as big-endian. the default is little-endian.\n\n\npython script and module\n========================\n\nthe zcbor.py script can directly read cbor, yaml, or json data and validate it against a cddl description.\nit can also freely convert the data between cbor/yaml/json.\nit can also output the data to a c file formatted as a byte array.\n\ninvoking zcbor.py from the command line\n---------------------------------------\n\nzcbor.py can be installed via [`pip`](https://pypi.org/project/zcbor/), or alternatively invoked directly from its location in this repo.\n\nfollowing are some generalized examples for validating, and for converting (which also validates) data from the command line.\nthe script infers the data format from the file extension, but the format can also be specified explicitly.\nsee `zcbor validate --help` and `zcbor convert --help` for more information.\n\n```sh\nzcbor validate -c <cddl description file> -t <which cddl type to expect> -i <input data file>\nzcbor convert -c <cddl description file> -t <which cddl type to expect> -i <input data file> -o <output data file>\n```\n\nor directly from within the repo.\n\n```sh\npython3 <zcbor base>/zcbor/zcbor.py validate -c <cddl description file> -t <which cddl type to expect> -i <input data file>\npython3 <zcbor base>/zcbor/zcbor.py convert -c <cddl description file> -t <which cddl type to expect> -i <input data file> -o <output data file>\n```\n\nyou can see an example of the conversions in [tests/cases/yaml_compatibility.yaml](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/cases/yaml_compatibility.yaml) and its cddl file [tests/cases/yaml_compatibility.cddl](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/cases/yaml_compatibility.cddl).\n\nimporting zcbor in a python script\n----------------------------------\n\nimporting zcbor gives access to the datatranslator class which is used to implement the command line conversion features.\ndatatranslator can be used to programmatically perform the translations, or to manipulate the data.\nwhen accessing the data, you can choose between two internal formats:\n\n 1. the format provided by the [cbor2](https://pypi.org/project/cbor2/), [yaml (pyyaml)](https://pypi.org/project/pyyaml/), and [json](https://docs.python.org/3/library/json.html) packages.\n    this is a format where the serialization types (map, list, string, number etc.) are mapped directly to the corresponding python types.\n    this format is common between these packages, which makes translation very simple.\n    when returning this format, datatranslator hides the idiomatic representations for bytestrings, tags, and non-text keys described above.\n 2. a custom format which allows accessing the data via the names from the cddl description file.\n    this format is implemented using named tuples, and is immutable, meaning that it can be used for inspecting data, but not for changing or creating data.\n\nmaking cbor yaml-/json-compatible\n---------------------------------\n\nsince cbor supports more data types than yaml and json, zcbor can optionally use a bespoke format when converting to/from yaml/json.\nthis is controlled with the `--yaml-compatibility` option to `convert` and `validate`.\nthis is relevant when handling yaml/json conversions of data that uses the unsupported features.\nthe following data types are supported by cbor, but not by yaml (or json which is a subset of yaml):\n\n 1. bytestrings: yaml supports only text strings. in yaml, bytestrings are represented as `{\"zcbor_bstr\": \"<hex-formatted bytestring>\"}`, or as `{\"zcbor_bstr\": <any type>}` if the cbor bytestring contains cbor-formatted data, in which the data is decoded into `<any type>`.\n 2. map keys other than text string: in yaml, such key value pairs are represented as `{\"zcbor_keyval<unique int>\": {\"key\": <key, not text>, \"val\": <value>}}`.\n 3. tags: in cbor2, tags are represented by a special type, `cbor2.cbortag`. in yaml, these are represented as `{\"zcbor_tag\": <tag number>, \"zcbor_tag_val\": <tagged data>}`.\n 4. undefined: in cbor2, undefined has its own value `cbor2.types.undefined`. in yaml, undefined is represented as: `[\"zcbor_undefined\"]`.\n\nyou can see an example of the conversions in [tests/cases/yaml_compatibility.yaml](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/cases/yaml_compatibility.yaml) and its cddl file [tests/cases/yaml_compatibility.cddl](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/cases/yaml_compatibility.cddl).\n\n\ncode generation\n===============\n\ncode generation is invoked with the `zcbor code` command:\n\n```sh\nzcbor code <--decode or --encode or both> -c <cddl description file(s)> -t <which cddl type(s) to expose in the api> --output-cmake <path to place the generated cmake file at>\nzcbor code <--decode or --encode or both> -c <cddl description file(s)> -t <which cddl type(s) to expose in the api> --oc <path to the generated c file> --oh <path to the generated header file> --oht <path to the generated types header>\n```\n\nwhen you call this, zcbor reads the cddl files and creates c struct types to match the types described in the cddl.\nit then creates code that uses the c library to decode cbor data into the structs, and/or encode cbor from the data in the structs.\nfinally, it takes the \"entry types\" (`-t`) and creates a public api function for each of them.\nwhile doing these things, it will make a number of optimizations, e.g. inlining code for small types and removing ununsed functions.\nit outputs the generated code into header and source files and optionally creates a cmake file to build them.\n\nthe `zcbor code` command reads one or more cddl file(s) and generates some or all of these files:\n - a header file with types (always)\n - a header file with declarations for decoding functions (if `--decode`/`-d` is specified)\n - a c file with decoding functions (if `--decode`/`-d` is specified)\n - a header file with declarations for encoding functions (if `--encode`/`-e` is specified)\n - a c file with encoding functions (if `--encode`/`-e` is specified)\n - a cmake file that creates a library with the generated code and the c library (if `--output-cmake` is specified).\n\ncddl allows placing restrictions on the members of your data.\nrestrictions can be on type (int/string/list/bool etc.), on content (e.g. values/sizes of ints or strings), and repetition (e.g. the number of members in a list).\nthe generated code will validate the input, which means that it will check all the restriction set in the cddl description, and fail if a restriction is broken.\n\nthere are tests for the code generation in [tests/decode](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/decode) and [tests/encode](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/encode).\nthe tests require [zephyr](https://github.com/zephyrproject-rtos/zephyr) (if your system is set up to build zephyr samples, the tests should also build).\n\nthe generated c code is c++ compatible.\n\nbuild system\n------------\n\nwhen calling zcbor with the argument `--output-cmake <file path>`, a cmake file will be created at that location.\nthe generated cmake file creates a target library and adds the generated and non-generated source files as well as required include directories to it.\nthis cmake file can then be included in your project's `cmakelists.txt` file, and the target can be linked into your project.\nthis is demonstrated in the tests, e.g. at [tests/decode/test3_simple/cmakelists.txt](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/decode/test3_simple/cmakelists.txt).\nzcbor can be instructed to copy the non-generated sources to the same location as the generated sources with `--copy-sources`.\n\n\nusage example\n=============\n\nthere are buildable examples in the [samples](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/samples) directory.\n\nto see how to use the c library directly, see the (hello_world)[samples/hello_world/src/main.c] sample, or the (pet)[samples/pet/src/main.c] sample (look for calls to functions prefixed with `zcbor_`).\n\nto see how to use code generation, see the (pet)[samples/pet/src/main.c] sample.\n\nlook at the (cmakelists.txt)[samples/pet/cmakelists.txt] file to see how zcbor is invoked for code generation (and for conversion).\n\nto see how to do conversion, see the (pet)[samples/pet/cmakelists.txt] sample.\n\nbelow are some additional examples of how to invoke zcbor for code generation and for converting/validating\n\ncode generation\n---------------\n\n```sh\npython3 <zcbor base>/zcbor/zcbor.py code -c pet.cddl -d -t pet --oc pet_decode.c --oh pet_decode.h\n# or\nzcbor code -c pet.cddl -d -t pet --oc pet_decode.c --oh pet_decode.h\n```\n\nconverting\n----------\n\nhere is an example call for converting from yaml to cbor:\n\n```sh\npython3 <zcbor base>/zcbor/zcbor.py convert -c pet.cddl -t pet -i mypet.yaml -o mypet.cbor\n# or\nzcbor convert -c pet.cddl -t pet -i mypet.yaml -o mypet.cbor\n```\n\nwhich takes a yaml structure from mypet.yaml, validates it against the pet type in the cddl description in pet.cddl, and writes binary cbor data to mypet.cbor.\n\nvalidating\n----------\n\nhere is an example call for validating a json file:\n\n```sh\npython3 <zcbor base>/zcbor/zcbor.py validate -c pet.cddl -t pet --yaml-compatibility -i mypet.json\n# or\nzcbor validate -c pet.cddl -t pet --yaml-compatibility -i mypet.json\n```\n\nwhich takes the json structure in mypet.json, converts any [yaml-compatible](#making-cbor-yaml-json-compatible) values to their original form, and validates that against the pet type in the cddl description in pet.cddl.\n\n\nrunning tests\n=============\n\nthe tests for the generated code are based on the zephyr ztest library.\nthese tests can be found in [tests/decode](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/decode) and [tests/encode](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/tests/encode).\nto set up the environment to run the ztest tests, follow [zephyr's getting started guide](https://docs.zephyrproject.org/latest/getting_started/index.html), or see the workflow in the [`.github`](https://github.com/nordicsemiconductor/zcbor/tree/0.7.0/.github) directory.\n\ntests for `convert` and `verify` are implemented with the unittest module.\nthese tests can be found in [tests/scripts/test_zcbor.py](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/scripts/test_zcbor.py).\nin this file there are also tests for code style of all python scripts, using the `pycodestyle` library.\n\ntests for the docs, samples, etc. can be found in [tests/scripts/test_repo_files.py](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/scripts/test_repo_files.py).\n\nfor running the tests locally, there is [`tests/test.sh`](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/test.sh) which runs all above tests.\n\n\nintroduction to cddl\n====================\n\nin cddl you define types from other types.\ntypes can be defined from base types, or from other types you define.\ntypes are declared with '`=`', e.g. `foo = int` which declares the type `foo` to be an integer, analogous to `typedef int foo;` in c.\ncddl defines the following base types (this is not an exhaustive list):\n\n - `int`: positive or negative integer\n - `uint`: positive integer\n - `bstr`: byte string\n - `tstr`: text string\n - `bool`: boolean\n - `nil`: nil/null value\n - `float`: floating point value\n - `any`: any single element\n\ncddl allows creating aggregate types:\n\n - `[]`: list. elements don't need to have the same type.\n - `{}`: map. key/value pairs as are declared as `<key> => <value>` or `<key>: <value>`. note that `:` is also used for labels.\n - `()`: groups. grouping with no enclosing type, which means that e.g. `foo = [(int, bstr)]` is equivalent to `foo = [int, bstr]`.\n - `/`: unions. analogous to unions in c. e.g. `foo = int/bstr/bar` where foo is either an int, a bstr, or bar (some custom type).\n\nliterals can be used instead of the base type names:\n\n - number: `foo = 3`, where foo is a uint with the additional requirement that it must have the value 3.\n - number range: `foo = -100..100`, where foo is an int with value between -100 and 100.\n - text string: `foo = \"hello\"`, where foo is a tstr with the requirement that it must be \"hello\".\n - true/false: `foo = false`, where foo is a bool which is always false.\n\nbase types can also be restricted in other ways:\n\n - `.size`: works for integers and strings. e.g. `foo = uint .size 4` where foo is a uint exactly 4 bytes long.\n - `.cbor`/`.cborseq`: e.g. `foo = bstr .cbor bar` where foo is a bstr whose contents must be cbor data decodeable as the bar type.\n\nan element can be repeated:\n\n - `?`: 0 or 1 time. e.g. `foo = [int, ?bstr]`, where foo is a list with an int possibly followed by a bstr.\n - `*`: 0 or more times. e.g. `foo = [*tstr]`, where foo is a list containing 0 or more tstrs.\n - `+`: 1 or more times. e.g. `foo = [+bar]`.\n - `x*y`: between x and y times, inclusive. e.g. `foo = {4*8(int => bstr)}` where foo is a map with 4 to 8 key/value pairs where each key is an int and each value is a bstr.\n\nnote that in the zcbor script and its generated code, the number of entries supported via `*` and `+` is affected by the default_max_qty value.\n\nany element can be labeled with `:`.\nthe label is only for readability and does not impact the data structure in any way.\ne.g. `foo = [name: tstr, age: uint]` is equivalent to `foo = [tstr, uint]`.\n\nsee [pet.cddl](https://github.com/nordicsemiconductor/zcbor/blob/0.7.0/tests/cases/pet.cddl) for cddl example code.\n\n\nintroduction to cbor\n====================\n\ncbor's format is described well on [wikipedia](https://en.wikipedia.org/wiki/cbor), but here's a synopsis:\n\nencoded cbor data elements look like this.\n\n```\n| header                       | value                  | payload                   |\n| 1 byte                       | 0, 1, 2, 4, or 8 bytes | 0 - 2^64-1 bytes/elements |\n| 3 bits     | 5 bits          |\n| major type | additional info |\n```\n\nthe available major types can be seen in `zcbor_major_type_t`.\n\nfor all major types, values 0-23 are encoded directly in the _additional info_, meaning that the _value_ field is 0 bytes long.\nif _additional info_ is 24, 25, 26, or 27, the _value_ field is 1, 2, 4, or 8 bytes long, respectively.\n\nmajor types `pint` (0), `nint` (1), `tag` (6), and `simple` (7) elements have no payload, only _value_.\n\n * `pint`: interpret the _value_ as a positive integer.\n * `nint`: interpret the _value_ as a positive integer, then multiply by -1 and subtract 1.\n * `tag`: the _value_ says something about the next non-tag element.\n   see the [cbor tag documentation](https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml) for details.\n * `simple`: different _additional info_ mean different things:\n    * 0-19: unassigned simple values.\n    * 20: `false` simple value\n    * 21: `true` simple value\n    * 22: `null` simple value\n    * 23: `undefined` simple value\n    * 24: interpret the _value_ as a 1 byte simple value. these simple values are currently unassigned.\n    * 25: interpret the _value_ as an ieee 754 float16.\n    * 26: interpret the _value_ as an ieee 754 float32.\n    * 27: interpret the _value_ as an ieee 754 float64.\n    * 31: end of an indefinite-length `list` or `map`.\n\nfor `bstr` (2), `tstr` (3), `list` (4), and `map` (5), the _value_ describes the length of the _payload_.\nfor `bstr` and `tstr`, the length is in bytes, for `list`, the length is in number of elements, and for `map`, the length is in number of key/value element pairs.\n\nfor `list` and `map`, sub elements are regular cbor elements with their own _header_, _value_ and _payload_. `list`s and `map`s can be recursively encoded.\nif a `list` or `map` has _additional info_ 31, it is \"indefinite-length\", which means it has an \"unknown\" number of elements.\ninstead, its end is marked by a `simple` with _additional info_ 31 (byte value 0xff).\n\n\nhistory\n=======\n\nzcbor (then \"cddl-gen\") was initially conceived as a code generation project.\nit was inspired by the need to securely decode the complex manifest data structures in the [ietf suit specification](https://datatracker.ietf.org/doc/draft-ietf-suit-manifest/).\nthis is reflected in the fact that there are multiple zcbor tests that use the cddl and examples from various revisions of that specification.\ndecoding/deserializing data securely requires doing some quite repetitive checks on each data element, to be sure that you are not decoding gibberish.\nthis is where code generation could pull a lot of weight.\nlater it was discovered that the cbor library that was designed to used by generated code could be useful by itself.\nthe script was also expanded so it could directly manipulate cbor data.\nsince cbor, yaml, and json are all represented in roughly the same way internally in python, it was easy to expand that data manipulation to support yaml and json.\n\nsome places where zcbor is currently used:\n- [mcuboot's serial recovery mechanism](https://github.com/mcu-tools/mcuboot/blob/main/boot/boot_serial/src/boot_serial.c)\n- [zephyr's mcumgr](https://github.com/zephyrproject-rtos/zephyr/blob/main/subsys/mgmt/mcumgr/grp/img_mgmt/src/img_mgmt.c)\n- [zephyr's lwm2m senml](https://github.com/zephyrproject-rtos/zephyr/blob/main/subsys/net/lib/lwm2m/lwm2m_rw_senml_cbor.c)\n- [nrf connect sdk's full modem update mechanism](https://github.com/nrfconnect/sdk-nrf/blob/main/subsys/mgmt/fmfu/src/fmfu_mgmt.c)\n- [nrf connect sdk's nrf_rpc](https://github.com/nrfconnect/sdk-nrfxlib/blob/main/nrf_rpc/nrf_rpc_cbor.c)\n\n\ncommand line documentation\n==========================\n\nadded via `add_helptext.py`\n\nzcbor --help\n------------\n\n```\nusage: zcbor [-h] [--version] {code,validate,convert} ...\n\nparse a cddl file and validate/convert between yaml, json, and cbor. can also\ngenerate c code for validation/encoding/decoding of cbor.\n\npositional arguments:\n  {code,validate,convert}\n\noptions:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n\n```\n\nzcbor code --help\n-----------------\n\n```\nusage: zcbor code [-h] -c cddl [--no-prelude] [-v]\n                  [--default-max-qty default_max_qty] [--output-c output_c]\n                  [--output-h output_h] [--output-h-types output_h_types]\n                  [--copy-sources] [--output-cmake output_cmake] -t\n                  entry_types [entry_types ...] [-d] [-e] [--time-header]\n                  [--git-sha-header] [-b {32,64}]\n                  [--include-prefix include_prefix] [-s]\n                  [--file-header file_header]\n\nparse a cddl file and produce c code that validates and xcodes cbor.\nthe output from this script is a c file and a header file. the header file\ncontains typedefs for all the types specified in the cddl input file, as well\nas declarations to xcode functions for the types designated as entry types when\nrunning the script. the c file contains all the code for decoding and validating\nthe types in the cddl input file. all types are validated as they are xcoded.\n\nwhere a `bstr .cbor <type>` is specified in the cddl, and the type is an entry\ntype, the xcoder will not xcode the string, only provide a pointer into the\npayload buffer. this is useful to reduce the size of typedefs, or to break up\ndecoding. using this mechanism is necessary when the cddl contains self-\nreferencing types, since the c type cannot be self referencing.\n\nthis script requires 'regex' for lookaround functionality not present in 're'.\n\noptions:\n  -h, --help            show this help message and exit\n  -c cddl, --cddl cddl  path to one or more input cddl file(s). passing\n                        multiple files is equivalent to concatenating them.\n  --no-prelude          exclude the standard cddl prelude from the build. the\n                        prelude can be viewed at zcbor/cddl/prelude.cddl in\n                        the repo, or together with the script.\n  -v, --verbose         print more information while parsing cddl and\n                        generating code.\n  --default-max-qty default_max_qty, --dq default_max_qty\n                        default maximum number of repetitions when no maximum\n                        is specified. this is needed to construct complete c\n                        types. the default_max_qty can usually be set to a\n                        text symbol if desired, to allow it to be configurable\n                        when building the code. this is not always possible,\n                        as sometimes the value is needed for internal\n                        computations. if so, the script will raise an\n                        exception.\n  --output-c output_c, --oc output_c\n                        path to output c file. if both --decode and --encode\n                        are specified, _decode and _encode will be appended to\n                        the filename when creating the two files. if not\n                        specified, the path and name will be based on the\n                        --output-cmake file. a 'src' directory will be created\n                        next to the cmake file, and the c file will be placed\n                        there with the same name (except the file extension)\n                        as the cmake file.\n  --output-h output_h, --oh output_h\n                        path to output header file. if both --decode and\n                        --encode are specified, _decode and _encode will be\n                        appended to the filename when creating the two files.\n                        if not specified, the path and name will be based on\n                        the --output-cmake file. an 'include' directory will\n                        be created next to the cmake file, and the c file will\n                        be placed there with the same name (except the file\n                        extension) as the cmake file.\n  --output-h-types output_h_types, --oht output_h_types\n                        path to output header file with typedefs (shared\n                        between decode and encode). if not specified, the path\n                        and name will be taken from the output header file\n                        (--output-h), with '_types' added to the file name.\n  --copy-sources        copy the non-generated source files (zcbor_*.c/h) into\n                        the same directories as the generated files.\n  --output-cmake output_cmake\n                        path to output cmake file. the filename of the cmake\n                        file without '.cmake' is used as the name of the cmake\n                        target in the file. the cmake file defines a cmake\n                        target with the zcbor source files and the generated\n                        file as sources, and the zcbor header files' and\n                        generated header files' folders as\n                        include_directories. add it to your project via\n                        include() in your cmakelists.txt file, and link the\n                        target to your program. this option works with or\n                        without the --copy-sources option.\n  -t entry_types [entry_types ...], --entry-types entry_types [entry_types ...]\n                        names of the types which should have their xcode\n                        functions exposed.\n  -d, --decode          generate decoding code. either --decode or --encode or\n                        both must be specified.\n  -e, --encode          generate encoding code. either --decode or --encode or\n                        both must be specified.\n  --time-header         put the current time in a comment in the generated\n                        files.\n  --git-sha-header      put the current git sha of zcbor in a comment in the\n                        generated files.\n  -b {32,64}, --default-bit-size {32,64}\n                        default bit size of integers in code. when integers\n                        have no explicit bounds, assume they have this bit\n                        width. should follow the bit width of the architecture\n                        the code will be running on.\n  --include-prefix include_prefix\n                        when #include'ing generated files, add this path\n                        prefix to the filename.\n  -s, --short-names     attempt to make most generated struct member names\n                        shorter. this might make some names identical which\n                        will cause a compile error. if so, tweak the cddl\n                        labels or layout, or disable this option. this might\n                        also make enum names different from the corresponding\n                        union members.\n  --file-header file_header\n                        header to be included in the comment at the top of\n                        generated c files, e.g. copyright.\n\n```\n\nzcbor validate --help\n---------------------\n\n```\nusage: zcbor validate [-h] -c cddl [--no-prelude] [-v] -i input\n                      [--input-as {yaml,json,cbor,cborhex}] -t entry_type\n                      [--default-max-qty default_max_qty]\n                      [--yaml-compatibility]\n\nread cbor, yaml, or json data from file or stdin and validate it against a\ncddl schema file.\n\noptions:\n  -h, --help            show this help message and exit\n  -c cddl, --cddl cddl  path to one or more input cddl file(s). passing\n                        multiple files is equivalent to concatenating them.\n  --no-prelude          exclude the standard cddl prelude from the build. the\n                        prelude can be viewed at zcbor/cddl/prelude.cddl in\n                        the repo, or together with the script.\n  -v, --verbose         print more information while parsing cddl and\n                        generating code.\n  -i input, --input input\n                        input data file. the option --input-as specifies how\n                        to interpret the contents. use \"-\" to indicate stdin.\n  --input-as {yaml,json,cbor,cborhex}\n                        which format to interpret the input file as. if\n                        omitted, the format is inferred from the file name.\n                        .yaml, .yml => yaml, .json => json, .cborhex => cbor\n                        as hex string, everything else => cbor\n  -t entry_type, --entry-type entry_type\n                        name of the type (from the cddl) to interpret the data\n                        as.\n  --default-max-qty default_max_qty, --dq default_max_qty\n                        default maximum number of repetitions when no maximum\n                        is specified. it is only relevant when handling data\n                        that will be decoded by generated code. if omitted, a\n                        large number will be used.\n  --yaml-compatibility  whether to convert cbor-only values to yaml-compatible\n                        ones (when converting from cbor), or vice versa (when\n                        converting to cbor). when this is enabled, all cbor\n                        data is guaranteed to convert into yaml/json. json and\n                        yaml do not support all data types that cbor/cddl\n                        supports. bytestrings (bstr), tags, undefined, and\n                        maps with non-text keys need special handling. see the\n                        zcbor readme for more information.\n\n```\n\nzcbor convert --help\n--------------------\n\n```\nusage: zcbor convert [-h] -c cddl [--no-prelude] [-v] -i input\n                     [--input-as {yaml,json,cbor,cborhex}] -t entry_type\n                     [--default-max-qty default_max_qty]\n                     [--yaml-compatibility] -o output\n                     [--output-as {yaml,json,cbor,cborhex,c_code}]\n                     [--c-code-var-name c_code_var_name]\n                     [--c-code-columns c_code_columns]\n\nparse a cddl file and validate/convert between cbor and yaml/json. the script\ndecodes the cbor/yaml/json data from a file or stdin and verifies that it\nconforms to the cddl description. the script fails if the data does not\nconform. 'zcbor validate' can be used if only validate is needed.\n\noptions:\n  -h, --help            show this help message and exit\n  -c cddl, --cddl cddl  path to one or more input cddl file(s). passing\n                        multiple files is equivalent to concatenating them.\n  --no-prelude          exclude the standard cddl prelude from the build. the\n                        prelude can be viewed at zcbor/cddl/prelude.cddl in\n                        the repo, or together with the script.\n  -v, --verbose         print more information while parsing cddl and\n                        generating code.\n  -i input, --input input\n                        input data file. the option --input-as specifies how\n                        to interpret the contents. use \"-\" to indicate stdin.\n  --input-as {yaml,json,cbor,cborhex}\n                        which format to interpret the input file as. if\n                        omitted, the format is inferred from the file name.\n                        .yaml, .yml => yaml, .json => json, .cborhex => cbor\n                        as hex string, everything else => cbor\n  -t entry_type, --entry-type entry_type\n                        name of the type (from the cddl) to interpret the data\n                        as.\n  --default-max-qty default_max_qty, --dq default_max_qty\n                        default maximum number of repetitions when no maximum\n                        is specified. it is only relevant when handling data\n                        that will be decoded by generated code. if omitted, a\n                        large number will be used.\n  --yaml-compatibility  whether to convert cbor-only values to yaml-compatible\n                        ones (when converting from cbor), or vice versa (when\n                        converting to cbor). when this is enabled, all cbor\n                        data is guaranteed to convert into yaml/json. json and\n                        yaml do not support all data types that cbor/cddl\n                        supports. bytestrings (bstr), tags, undefined, and\n                        maps with non-text keys need special handling. see the\n                        zcbor readme for more information.\n  -o output, --output output\n                        output data file. the option --output-as specifies how\n                        to interpret the contents. use \"-\" to indicate stdout.\n  --output-as {yaml,json,cbor,cborhex,c_code}\n                        which format to interpret the output file as. if\n                        omitted, the format is inferred from the file name.\n                        .yaml, .yml => yaml, .json => json, .c, .h => c code,\n                        .cborhex => cbor as hex string, everything else =>\n                        cbor\n  --c-code-var-name c_code_var_name\n                        only relevant together with '--output-as c_code' or .c\n                        files.\n  --c-code-columns c_code_columns\n                        only relevant together with '--output-as c_code' or .c\n                        files. the number of bytes per line in the variable\n                        instantiation. if omitted, the entire declaration is a\n                        single line.\n\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache software license",
  "name": "zcbor",
  "package_url": "https://pypi.org/project/zcbor/",
  "project_url": "https://pypi.org/project/zcbor/",
  "project_urls": {
    "Homepage": "https://github.com/NordicSemiconductor/zcbor"
  },
  "release_url": "https://pypi.org/project/zcbor/0.7.0/",
  "requires_dist": [
    "cbor2 (>=5.4.2.post1)",
    "pyyaml (>=5.4.1)",
    "regex (>=2022.3.15)"
  ],
  "requires_python": ">=3.7",
  "summary": "zcbor",
  "version": "0.7.0",
  "releases": [],
  "developers": [
    "nordic_semiconductor_asa"
  ],
  "kwds": "zcbor_asserts zcbor_assert zcbor_err_assertion zcbor_keyval test_zcbor",
  "license_kwds": "apache software license",
  "libtype": "pypi",
  "id": "pypi_zcbor",
  "homepage": "https://github.com/nordicsemiconductor/zcbor",
  "release_count": 5,
  "dependency_ids": [
    "pypi_cbor2",
    "pypi_pyyaml",
    "pypi_regex"
  ]
}