{
  "classifiers": [
    "development status :: 7 - inactive",
    "framework :: aws cdk",
    "framework :: aws cdk :: 1",
    "intended audience :: developers",
    "license :: osi approved",
    "operating system :: os independent",
    "programming language :: javascript",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "typing :: typed"
  ],
  "description": "# aws step functions construct library\n\n<!--begin stability banner-->---\n\n\n![end-of-support](https://img.shields.io/badge/end--of--support-critical.svg?style=for-the-badge)\n\n> aws cdk v1 has reached end-of-support on 2023-06-01.\n> this package is no longer being updated, and users should migrate to aws cdk v2.\n>\n> for more information on how to migrate, see the [*migrating to aws cdk v2* guide](https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html).\n\n---\n<!--end stability banner-->\n\nthe `@aws-cdk/aws-stepfunctions` package contains constructs for building\nserverless workflows using objects. use this in conjunction with the\n`@aws-cdk/aws-stepfunctions-tasks` package, which contains classes used\nto call other aws services.\n\ndefining a workflow looks like this (for the [step functions job poller\nexample](https://docs.aws.amazon.com/step-functions/latest/dg/job-status-poller-sample.html)):\n\n## example\n\n```python\nimport aws_cdk.aws_lambda as lambda_\n\n# submit_lambda: lambda.function\n# get_status_lambda: lambda.function\n\n\nsubmit_job = tasks.lambdainvoke(self, \"submit job\",\n    lambda_function=submit_lambda,\n    # lambda's result is in the attribute `payload`\n    output_path=\"$.payload\"\n)\n\nwait_x = sfn.wait(self, \"wait x seconds\",\n    time=sfn.waittime.seconds_path(\"$.waitseconds\")\n)\n\nget_status = tasks.lambdainvoke(self, \"get job status\",\n    lambda_function=get_status_lambda,\n    # pass just the field named \"guid\" into the lambda, put the\n    # lambda's result in a field called \"status\" in the response\n    input_path=\"$.guid\",\n    output_path=\"$.payload\"\n)\n\njob_failed = sfn.fail(self, \"job failed\",\n    cause=\"aws batch job failed\",\n    error=\"describejob returned failed\"\n)\n\nfinal_status = tasks.lambdainvoke(self, \"get final job status\",\n    lambda_function=get_status_lambda,\n    # use \"guid\" field as input\n    input_path=\"$.guid\",\n    output_path=\"$.payload\"\n)\n\ndefinition = submit_job.next(wait_x).next(get_status).next(sfn.choice(self, \"job complete?\").when(sfn.condition.string_equals(\"$.status\", \"failed\"), job_failed).when(sfn.condition.string_equals(\"$.status\", \"succeeded\"), final_status).otherwise(wait_x))\n\nsfn.statemachine(self, \"statemachine\",\n    definition=definition,\n    timeout=duration.minutes(5)\n)\n```\n\nyou can find more sample snippets and learn more about the service integrations\nin the `@aws-cdk/aws-stepfunctions-tasks` package.\n\n## state machine\n\na `stepfunctions.statemachine` is a resource that takes a state machine\ndefinition. the definition is specified by its start state, and encompasses\nall states reachable from the start state:\n\n```python\nstart_state = sfn.pass(self, \"startstate\")\n\nsfn.statemachine(self, \"statemachine\",\n    definition=start_state\n)\n```\n\nstate machines execute using an iam role, which will automatically have all\npermissions added that are required to make all state machine tasks execute\nproperly (for example, permissions to invoke any lambda functions you add to\nyour workflow). a role will be created by default, but you can supply an\nexisting one as well.\n\n## accessing state (the jsonpath class)\n\nevery state machine execution has [state machine\ndata](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-state-machine-data.html):\na json document containing keys and values that is fed into the state machine,\ngets modified as the state machine progresses, and finally is produced as output.\n\nyou can pass fragments of this state machine data into tasks of the state machine.\nto do so, use the static methods on the `jsonpath` class. for example, to pass\nthe value that's in the data key of `orderid` to a lambda function as you invoke\nit, use `jsonpath.stringat('$.orderid')`, like so:\n\n```python\nimport aws_cdk.aws_lambda as lambda_\n\n# order_fn: lambda.function\n\n\nsubmit_job = tasks.lambdainvoke(self, \"invokeorderprocessor\",\n    lambda_function=order_fn,\n    payload=sfn.taskinput.from_object({\n        \"orderid\": sfn.jsonpath.string_at(\"$.orderid\")\n    })\n)\n```\n\nthe following methods are available:\n\n| method | purpose |\n|--------|---------|\n| `jsonpath.stringat('$.field')` | reference a field, return the type as a `string`. |\n| `jsonpath.listat('$.field')` | reference a field, return the type as a list of strings. |\n| `jsonpath.numberat('$.field')` | reference a field, return the type as a number. use this for functions that expect a number argument. |\n| `jsonpath.objectat('$.field')` | reference a field, return the type as an `iresolvable`. use this for functions that expect an object argument. |\n| `jsonpath.entirepayload` | reference the entire data object (equivalent to a path of `$`). |\n| `jsonpath.tasktoken` | reference the [task token](https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html#connect-wait-token), used for integration patterns that need to run for a long time. |\n\nyou can also call [intrinsic functions](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-intrinsic-functions.html) using the methods on `jsonpath`:\n\n| method | purpose |\n|--------|---------|\n| `jsonpath.array(jsonpath.stringat('$.field'), ...)` | make an array from other elements. |\n| `jsonpath.format('the value is {}.', jsonpath.stringat('$.value'))` | insert elements into a format string. |\n| `jsonpath.stringtojson(jsonpath.stringat('$.objstr'))` | parse a json string to an object |\n| `jsonpath.jsontostring(jsonpath.objectat('$.obj'))` | stringify an object to a json string |\n\n## amazon states language\n\nthis library comes with a set of classes that model the [amazon states\nlanguage](https://states-language.net/spec.html). the following state classes\nare supported:\n\n* [`task`](#task)\n* [`pass`](#pass)\n* [`wait`](#wait)\n* [`choice`](#choice)\n* [`parallel`](#parallel)\n* [`succeed`](#succeed)\n* [`fail`](#fail)\n* [`map`](#map)\n* [`custom state`](#custom-state)\n\nan arbitrary json object (specified at execution start) is passed from state to\nstate and transformed during the execution of the workflow. for more\ninformation, see the states language spec.\n\n### task\n\na `task` represents some work that needs to be done. the exact work to be\ndone is determine by a class that implements `istepfunctionstask`, a collection\nof which can be found in the `@aws-cdk/aws-stepfunctions-tasks` module.\n\nthe tasks in the `@aws-cdk/aws-stepfunctions-tasks` module support the\n[service integration pattern](https://docs.aws.amazon.com/step-functions/latest/dg/connect-to-resource.html) that integrates step functions with services\ndirectly in the amazon states language.\n\n### pass\n\na `pass` state passes its input to its output, without performing work.\npass states are useful when constructing and debugging state machines.\n\nthe following example injects some fixed data into the state machine through\nthe `result` field. the `result` field will be added to the input and the result\nwill be passed as the state's output.\n\n```python\n# makes the current json state { ..., \"subobject\": { \"hello\": \"world\" } }\npass = sfn.pass(self, \"add hello world\",\n    result=sfn.result.from_object({\"hello\": \"world\"}),\n    result_path=\"$.subobject\"\n)\n\n# set the next state\nnext_state = sfn.pass(self, \"nextstate\")\npass.next(next_state)\n```\n\nthe `pass` state also supports passing key-value pairs as input. values can\nbe static, or selected from the input with a path.\n\nthe following example filters the `greeting` field from the state input\nand also injects a field called `otherdata`.\n\n```python\npass = sfn.pass(self, \"filter input and inject data\",\n    parameters={ # input to the pass state\n        \"input\": sfn.jsonpath.string_at(\"$.input.greeting\"),\n        \"other_data\": \"some-extra-stuff\"}\n)\n```\n\nthe object specified in `parameters` will be the input of the `pass` state.\nsince neither `result` nor `resultpath` are supplied, the `pass` state copies\nits input through to its output.\n\nlearn more about the [pass state](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-pass-state.html)\n\n### wait\n\na `wait` state waits for a given number of seconds, or until the current time\nhits a particular time. the time to wait may be taken from the execution's json\nstate.\n\n```python\n# wait until it's the time mentioned in the the state object's \"triggertime\"\n# field.\nwait = sfn.wait(self, \"wait for trigger time\",\n    time=sfn.waittime.timestamp_path(\"$.triggertime\")\n)\n\n# set the next state\nstart_the_work = sfn.pass(self, \"startthework\")\nwait.next(start_the_work)\n```\n\n### choice\n\na `choice` state can take a different path through the workflow based on the\nvalues in the execution's json state:\n\n```python\nchoice = sfn.choice(self, \"did it work?\")\n\n# add conditions with .when()\nsuccess_state = sfn.pass(self, \"successstate\")\nfailure_state = sfn.pass(self, \"failurestate\")\nchoice.when(sfn.condition.string_equals(\"$.status\", \"success\"), success_state)\nchoice.when(sfn.condition.number_greater_than(\"$.attempts\", 5), failure_state)\n\n# use .otherwise() to indicate what should be done if none of the conditions match\ntry_again_state = sfn.pass(self, \"tryagainstate\")\nchoice.otherwise(try_again_state)\n```\n\nif you want to temporarily branch your workflow based on a condition, but have\nall branches come together and continuing as one (similar to how an `if ... then ... else` works in a programming language), use the `.afterwards()` method:\n\n```python\nchoice = sfn.choice(self, \"what color is it?\")\nhandle_blue_item = sfn.pass(self, \"handleblueitem\")\nhandle_red_item = sfn.pass(self, \"handlereditem\")\nhandle_other_item_color = sfn.pass(self, \"hanldeotheritemcolor\")\nchoice.when(sfn.condition.string_equals(\"$.color\", \"blue\"), handle_blue_item)\nchoice.when(sfn.condition.string_equals(\"$.color\", \"red\"), handle_red_item)\nchoice.otherwise(handle_other_item_color)\n\n# use .afterwards() to join all possible paths back together and continue\nship_the_item = sfn.pass(self, \"shiptheitem\")\nchoice.afterwards().next(ship_the_item)\n```\n\nif your `choice` doesn't have an `otherwise()` and none of the conditions match\nthe json state, a `nochoicematched` error will be thrown. wrap the state machine\nin a `parallel` state if you want to catch and recover from this.\n\n#### available conditions\n\nsee [step function comparison operators](https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-choice-state.html#amazon-states-language-choice-state-rules)\n\n* `condition.ispresent` - matches if a json path is present\n* `condition.isnotpresent` - matches if a json path is not present\n* `condition.isstring` - matches if a json path contains a string\n* `condition.isnotstring` - matches if a json path is not a string\n* `condition.isnumeric` - matches if a json path is numeric\n* `condition.isnotnumeric` - matches if a json path is not numeric\n* `condition.isboolean` - matches if a json path is boolean\n* `condition.isnotboolean` - matches if a json path is not boolean\n* `condition.istimestamp` - matches if a json path is a timestamp\n* `condition.isnottimestamp` - matches if a json path is not a timestamp\n* `condition.isnotnull` - matches if a json path is not null\n* `condition.isnull` - matches if a json path is null\n* `condition.booleanequals` - matches if a boolean field has a given value\n* `condition.booleanequalsjsonpath` - matches if a boolean field equals a value in a given mapping path\n* `condition.stringequalsjsonpath` - matches if a string field equals a given mapping path\n* `condition.stringequals` - matches if a field equals a string value\n* `condition.stringlessthan` - matches if a string field sorts before a given value\n* `condition.stringlessthanjsonpath` - matches if a string field sorts before a value at given mapping path\n* `condition.stringlessthanequals` - matches if a string field sorts equal to or before a given value\n* `condition.stringlessthanequalsjsonpath` - matches if a string field sorts equal to or before a given mapping\n* `condition.stringgreaterthan` - matches if a string field sorts after a given value\n* `condition.stringgreaterthanjsonpath` - matches if a string field sorts after a value at a given mapping path\n* `condition.stringgreaterthanequalsjsonpath` - matches if a string field sorts after or equal to value at a given mapping path\n* `condition.stringgreaterthanequals` - matches if a string field sorts after or equal to a given value\n* `condition.numberequals` - matches if a numeric field has the given value\n* `condition.numberequalsjsonpath` - matches if a numeric field has the value in a given mapping path\n* `condition.numberlessthan` - matches if a numeric field is less than the given value\n* `condition.numberlessthanjsonpath` - matches if a numeric field is less than the value at the given mapping path\n* `condition.numberlessthanequals` - matches if a numeric field is less than or equal to the given value\n* `condition.numberlessthanequalsjsonpath` - matches if a numeric field is less than or equal to the numeric value at given mapping path\n* `condition.numbergreaterthan` - matches if a numeric field is greater than the given value\n* `condition.numbergreaterthanjsonpath` - matches if a numeric field is greater than the value at a given mapping path\n* `condition.numbergreaterthanequals` - matches if a numeric field is greater than or equal to the given value\n* `condition.numbergreaterthanequalsjsonpath` - matches if a numeric field is greater than or equal to the value at a given mapping path\n* `condition.timestampequals` - matches if a timestamp field is the same time as the given timestamp\n* `condition.timestampequalsjsonpath` - matches if a timestamp field is the same time as the timestamp at a given mapping path\n* `condition.timestamplessthan` - matches if a timestamp field is before the given timestamp\n* `condition.timestamplessthanjsonpath` - matches if a timestamp field is before the timestamp at a given mapping path\n* `condition.timestamplessthanequals` - matches if a timestamp field is before or equal to the given timestamp\n* `condition.timestamplessthanequalsjsonpath` - matches if a timestamp field is before or equal to the timestamp at a given mapping path\n* `condition.timestampgreaterthan` - matches if a timestamp field is after the timestamp at a given mapping path\n* `condition.timestampgreaterthanjsonpath` - matches if a timestamp field is after the timestamp at a given mapping path\n* `condition.timestampgreaterthanequals` - matches if a timestamp field is after or equal to the given timestamp\n* `condition.timestampgreaterthanequalsjsonpath` - matches if a timestamp field is after or equal to the timestamp at a given mapping path\n* `condition.stringmatches` - matches if a field matches a string pattern that can contain a wild card (*) e.g: log-*.txt or *latest*. no other characters other than \"*\" have any special meaning - * can be escaped: \\\\*\n\n### parallel\n\na `parallel` state executes one or more subworkflows in parallel. it can also\nbe used to catch and recover from errors in subworkflows.\n\n```python\nparallel = sfn.parallel(self, \"do the work in parallel\")\n\n# add branches to be executed in parallel\nship_item = sfn.pass(self, \"shipitem\")\nsend_invoice = sfn.pass(self, \"sendinvoice\")\nrestock = sfn.pass(self, \"restock\")\nparallel.branch(ship_item)\nparallel.branch(send_invoice)\nparallel.branch(restock)\n\n# retry the whole workflow if something goes wrong\nparallel.add_retry(max_attempts=1)\n\n# how to recover from errors\nsend_failure_notification = sfn.pass(self, \"sendfailurenotification\")\nparallel.add_catch(send_failure_notification)\n\n# what to do in case everything succeeded\nclose_order = sfn.pass(self, \"closeorder\")\nparallel.next(close_order)\n```\n\n### succeed\n\nreaching a `succeed` state terminates the state machine execution with a\nsuccessful status.\n\n```python\nsuccess = sfn.succeed(self, \"we did it!\")\n```\n\n### fail\n\nreaching a `fail` state terminates the state machine execution with a\nfailure status. the fail state should report the reason for the failure.\nfailures can be caught by encompassing `parallel` states.\n\n```python\nsuccess = sfn.fail(self, \"fail\",\n    error=\"workflowfailure\",\n    cause=\"something went wrong\"\n)\n```\n\n### map\n\na `map` state can be used to run a set of steps for each element of an input array.\na `map` state will execute the same steps for multiple entries of an array in the state input.\n\nwhile the `parallel` state executes multiple branches of steps using the same input, a `map` state will\nexecute the same steps for multiple entries of an array in the state input.\n\n```python\nmap = sfn.map(self, \"map state\",\n    max_concurrency=1,\n    items_path=sfn.jsonpath.string_at(\"$.inputformap\")\n)\nmap.iterator(sfn.pass(self, \"pass state\"))\n```\n\n### custom state\n\nit's possible that the high-level constructs for the states or `stepfunctions-tasks` do not have\nthe states or service integrations you are looking for. the primary reasons for this lack of\nfunctionality are:\n\n* a [service integration](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-service-integrations.html) is available through amazon states langauge, but not available as construct\n  classes in the cdk.\n* the state or state properties are available through step functions, but are not configurable\n  through constructs\n\nif a feature is not available, a `customstate` can be used to supply any amazon states language\njson-based object as the state definition.\n\n[code snippets](https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-code-snippet.html#tutorial-code-snippet-1) are available and can be plugged in as the state definition.\n\ncustom states can be chained together with any of the other states to create your state machine\ndefinition. you will also need to provide any permissions that are required to the `role` that\nthe state machine uses.\n\nthe following example uses the `dynamodb` service integration to insert data into a dynamodb table.\n\n```python\nimport aws_cdk.aws_dynamodb as dynamodb\n\n\n# create a table\ntable = dynamodb.table(self, \"montable\",\n    partition_key=dynamodb.attribute(\n        name=\"id\",\n        type=dynamodb.attributetype.string\n    )\n)\n\nfinal_status = sfn.pass(self, \"final step\")\n\n# states language json to put an item into dynamodb\n# snippet generated from https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-code-snippet.html#tutorial-code-snippet-1\nstate_json = {\n    \"type\": \"task\",\n    \"resource\": \"arn:aws:states:::dynamodb:putitem\",\n    \"parameters\": {\n        \"tablename\": table.table_name,\n        \"item\": {\n            \"id\": {\n                \"s\": \"myentry\"\n            }\n        }\n    },\n    \"resultpath\": null\n}\n\n# custom state which represents a task to insert data into dynamodb\ncustom = sfn.customstate(self, \"my custom task\",\n    state_json=state_json\n)\n\nchain = sfn.chain.start(custom).next(final_status)\n\nsm = sfn.statemachine(self, \"statemachine\",\n    definition=chain,\n    timeout=duration.seconds(30)\n)\n\n# don't forget permissions. you need to assign them\ntable.grant_write_data(sm)\n```\n\n## task chaining\n\nto make defining work flows as convenient (and readable in a top-to-bottom way)\nas writing regular programs, it is possible to chain most methods invocations.\nin particular, the `.next()` method can be repeated. the result of a series of\n`.next()` calls is called a **chain**, and can be used when defining the jump\ntargets of `choice.on` or `parallel.branch`:\n\n```python\nstep1 = sfn.pass(self, \"step1\")\nstep2 = sfn.pass(self, \"step2\")\nstep3 = sfn.pass(self, \"step3\")\nstep4 = sfn.pass(self, \"step4\")\nstep5 = sfn.pass(self, \"step5\")\nstep6 = sfn.pass(self, \"step6\")\nstep7 = sfn.pass(self, \"step7\")\nstep8 = sfn.pass(self, \"step8\")\nstep9 = sfn.pass(self, \"step9\")\nstep10 = sfn.pass(self, \"step10\")\nchoice = sfn.choice(self, \"choice\")\ncondition1 = sfn.condition.string_equals(\"$.status\", \"success\")\nparallel = sfn.parallel(self, \"parallel\")\nfinish = sfn.pass(self, \"finish\")\n\ndefinition = step1.next(step2).next(choice.when(condition1, step3.next(step4).next(step5)).otherwise(step6).afterwards()).next(parallel.branch(step7.next(step8)).branch(step9.next(step10))).next(finish)\n\nsfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n```\n\nif you don't like the visual look of starting a chain directly off the first\nstep, you can use `chain.start`:\n\n```python\nstep1 = sfn.pass(self, \"step1\")\nstep2 = sfn.pass(self, \"step2\")\nstep3 = sfn.pass(self, \"step3\")\n\ndefinition = sfn.chain.start(step1).next(step2).next(step3)\n```\n\n## state machine fragments\n\nit is possible to define reusable (or abstracted) mini-state machines by\ndefining a construct that implements `ichainable`, which requires you to define\ntwo fields:\n\n* `startstate: state`, representing the entry point into this state machine.\n* `endstates: inextable[]`, representing the (one or more) states that outgoing\n  transitions will be added to if you chain onto the fragment.\n\nsince states will be named after their construct ids, you may need to prefix the\nids of states if you plan to instantiate the same state machine fragment\nmultiples times (otherwise all states in every instantiation would have the same\nname).\n\nthe class `statemachinefragment` contains some helper functions (like\n`prefixstates()`) to make it easier for you to do this. if you define your state\nmachine as a subclass of this, it will be convenient to use:\n\n```python\nfrom aws_cdk.core import stack\nfrom constructs import construct\nimport aws_cdk.aws_stepfunctions as sfn\n\nclass myjob(sfn.statemachinefragment):\n\n    def __init__(self, parent, id, *, jobflavor):\n        super().__init__(parent, id)\n\n        choice = sfn.choice(self, \"choice\").when(sfn.condition.string_equals(\"$.branch\", \"left\"), sfn.pass(self, \"left branch\")).when(sfn.condition.string_equals(\"$.branch\", \"right\"), sfn.pass(self, \"right branch\"))\n\n        # ...\n\n        self.start_state = choice\n        self.end_states = choice.afterwards().end_states\n\nclass mystack(stack):\n    def __init__(self, scope, id):\n        super().__init__(scope, id)\n        # do 3 different variants of myjob in parallel\n        parallel = sfn.parallel(self, \"all jobs\").branch(myjob(self, \"quick\", job_flavor=\"quick\").prefix_states()).branch(myjob(self, \"medium\", job_flavor=\"medium\").prefix_states()).branch(myjob(self, \"slow\", job_flavor=\"slow\").prefix_states())\n\n        sfn.statemachine(self, \"mystatemachine\",\n            definition=parallel\n        )\n```\n\na few utility functions are available to parse state machine fragments.\n\n* `state.findreachablestates`: retrieve the list of states reachable from a given state.\n* `state.findreachableendstates`: retrieve the list of end or terminal states reachable from a given state.\n\n## activity\n\n**activities** represent work that is done on some non-lambda worker pool. the\nstep functions workflow will submit work to this activity, and a worker pool\nthat you run yourself, probably on ec2, will pull jobs from the activity and\nsubmit the results of individual jobs back.\n\nyou need the arn to do so, so if you use activities be sure to pass the activity\narn into your worker pool:\n\n```python\nactivity = sfn.activity(self, \"activity\")\n\n# read this cloudformation output from your application and use it to poll for work on\n# the activity.\ncfnoutput(self, \"activityarn\", value=activity.activity_arn)\n```\n\n### activity-level permissions\n\ngranting iam permissions to an activity can be achieved by calling the `grant(principal, actions)` api:\n\n```python\nactivity = sfn.activity(self, \"activity\")\n\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"lambda.amazonaws.com\")\n)\n\nactivity.grant(role, \"states:sendtasksuccess\")\n```\n\nthis will grant the iam principal the specified actions onto the activity.\n\n## metrics\n\n`task` object expose various metrics on the execution of that particular task. for example,\nto create an alarm on a particular task failing:\n\n```python\n# task: sfn.task\n\ncloudwatch.alarm(self, \"taskalarm\",\n    metric=task.metric_failed(),\n    threshold=1,\n    evaluation_periods=1\n)\n```\n\nthere are also metrics on the complete state machine:\n\n```python\n# state_machine: sfn.statemachine\n\ncloudwatch.alarm(self, \"statemachinealarm\",\n    metric=state_machine.metric_failed(),\n    threshold=1,\n    evaluation_periods=1\n)\n```\n\nand there are metrics on the capacity of all state machines in your account:\n\n```python\ncloudwatch.alarm(self, \"throttledalarm\",\n    metric=sfn.statetransitionmetric.metric_throttled_events(),\n    threshold=10,\n    evaluation_periods=2\n)\n```\n\n## error names\n\nstep functions identifies errors in the amazon states language using case-sensitive strings, known as error names.\nthe amazon states language defines a set of built-in strings that name well-known errors, all beginning with the `states.` prefix.\n\n* `states.all` - a wildcard that matches any known error name.\n* `states.runtime` - an execution failed due to some exception that could not be processed. often these are caused by errors at runtime, such as attempting to apply inputpath or outputpath on a null json payload. a `states.runtime` error is not retriable, and will always cause the execution to fail. a retry or catch on `states.all` will not catch states.runtime errors.\n* `states.datalimitexceeded` - a states.datalimitexceeded exception will be thrown for the following:\n\n  * when the output of a connector is larger than payload size quota.\n  * when the output of a state is larger than payload size quota.\n  * when, after parameters processing, the input of a state is larger than the payload size quota.\n  * see [the aws documentation](https://docs.aws.amazon.com/step-functions/latest/dg/limits-overview.html) to learn more about aws step functions quotas.\n* `states.heartbeattimeout` - a task state failed to send a heartbeat for a period longer than the heartbeatseconds value.\n* `states.timeout` - a task state either ran longer than the timeoutseconds value, or failed to send a heartbeat for a period longer than the heartbeatseconds value.\n* `states.taskfailed`- a task state failed during the execution. when used in a retry or catch, `states.taskfailed` acts as a wildcard that matches any known error name except for `states.timeout`.\n\n## logging\n\nenable logging to cloudwatch by passing a logging configuration with a\ndestination loggroup:\n\n```python\nimport aws_cdk.aws_logs as logs\n\n\nlog_group = logs.loggroup(self, \"myloggroup\")\n\nsfn.statemachine(self, \"mystatemachine\",\n    definition=sfn.chain.start(sfn.pass(self, \"pass\")),\n    logs=sfn.logoptions(\n        destination=log_group,\n        level=sfn.loglevel.all\n    )\n)\n```\n\n## x-ray tracing\n\nenable x-ray tracing for statemachine:\n\n```python\nsfn.statemachine(self, \"mystatemachine\",\n    definition=sfn.chain.start(sfn.pass(self, \"pass\")),\n    tracing_enabled=true\n)\n```\n\nsee [the aws documentation](https://docs.aws.amazon.com/step-functions/latest/dg/concepts-xray-tracing.html)\nto learn more about aws step functions's x-ray support.\n\n## state machine permission grants\n\niam roles, users, or groups which need to be able to work with a state machine should be granted iam permissions.\n\nany object that implements the `igrantable` interface (has an associated principal) can be granted permissions by calling:\n\n* `statemachine.grantstartexecution(principal)` - grants the principal the ability to execute the state machine\n* `statemachine.grantread(principal)` - grants the principal read access\n* `statemachine.granttaskresponse(principal)` - grants the principal the ability to send task tokens to the state machine\n* `statemachine.grantexecution(principal, actions)` - grants the principal execution-level permissions for the iam actions specified\n* `statemachine.grant(principal, actions)` - grants the principal state-machine-level permissions for the iam actions specified\n\n### start execution permission\n\ngrant permission to start an execution of a state machine by calling the `grantstartexecution()` api.\n\n```python\n# definition: sfn.ichainable\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"lambda.amazonaws.com\")\n)\nstate_machine = sfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n\n# give role permission to start execution of state machine\nstate_machine.grant_start_execution(role)\n```\n\nthe following permission is provided to a service principal by the `grantstartexecution()` api:\n\n* `states:startexecution` - to state machine\n\n### read permissions\n\ngrant `read` access to a state machine by calling the `grantread()` api.\n\n```python\n# definition: sfn.ichainable\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"lambda.amazonaws.com\")\n)\nstate_machine = sfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n\n# give role read access to state machine\nstate_machine.grant_read(role)\n```\n\nthe following read permissions are provided to a service principal by the `grantread()` api:\n\n* `states:listexecutions` - to state machine\n* `states:liststatemachines` - to state machine\n* `states:describeexecution` - to executions\n* `states:describestatemachineforexecution` - to executions\n* `states:getexecutionhistory` - to executions\n* `states:listactivities` - to `*`\n* `states:describestatemachine` - to `*`\n* `states:describeactivity` - to `*`\n\n### task response permissions\n\ngrant permission to allow task responses to a state machine by calling the `granttaskresponse()` api:\n\n```python\n# definition: sfn.ichainable\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"lambda.amazonaws.com\")\n)\nstate_machine = sfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n\n# give role task response permissions to the state machine\nstate_machine.grant_task_response(role)\n```\n\nthe following read permissions are provided to a service principal by the `grantread()` api:\n\n* `states:sendtasksuccess` - to state machine\n* `states:sendtaskfailure` - to state machine\n* `states:sendtaskheartbeat` - to state machine\n\n### execution-level permissions\n\ngrant execution-level permissions to a state machine by calling the `grantexecution()` api:\n\n```python\n# definition: sfn.ichainable\nrole = iam.role(self, \"role\",\n    assumed_by=iam.serviceprincipal(\"lambda.amazonaws.com\")\n)\nstate_machine = sfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n\n# give role permission to get execution history of all executions for the state machine\nstate_machine.grant_execution(role, \"states:getexecutionhistory\")\n```\n\n### custom permissions\n\nyou can add any set of permissions to a state machine by calling the `grant()` api.\n\n```python\n# definition: sfn.ichainable\nuser = iam.user(self, \"myuser\")\nstate_machine = sfn.statemachine(self, \"statemachine\",\n    definition=definition\n)\n\n# give user permission to send task success to the state machine\nstate_machine.grant(user, \"states:sendtasksuccess\")\n```\n\n## import\n\nany step functions state machine that has been created outside the stack can be imported\ninto your cdk stack.\n\nstate machines can be imported by their arn via the `statemachine.fromstatemachinearn()` api\n\n```python\napp = app()\nstack = stack(app, \"mystack\")\nsfn.statemachine.from_state_machine_arn(stack, \"importedstatemachine\", \"arn:aws:states:us-east-1:123456789012:statemachine:statemachine2e01a3a5-n5tjppzoevkq\")\n```\n",
  "docs_url": null,
  "keywords": "",
  "license": "apache-2.0",
  "name": "aws-cdk.aws-stepfunctions",
  "package_url": "https://pypi.org/project/aws-cdk.aws-stepfunctions/",
  "project_url": "https://pypi.org/project/aws-cdk.aws-stepfunctions/",
  "project_urls": {
    "Homepage": "https://github.com/aws/aws-cdk",
    "Source": "https://github.com/aws/aws-cdk.git"
  },
  "release_url": "https://pypi.org/project/aws-cdk.aws-stepfunctions/1.204.0/",
  "requires_dist": [
    "aws-cdk.aws-cloudwatch (==1.204.0)",
    "aws-cdk.aws-events (==1.204.0)",
    "aws-cdk.aws-iam (==1.204.0)",
    "aws-cdk.aws-logs (==1.204.0)",
    "aws-cdk.aws-s3 (==1.204.0)",
    "aws-cdk.core (==1.204.0)",
    "constructs (<4.0.0,>=3.3.69)",
    "jsii (<2.0.0,>=1.84.0)",
    "publication (>=0.0.3)",
    "typeguard (~=2.13.3)"
  ],
  "requires_python": "~=3.7",
  "summary": "the cdk construct library for aws::stepfunctions",
  "version": "1.204.0",
  "releases": [],
  "developers": [
    "amazon_web_services"
  ],
  "kwds": "aws_stepfunctions aws_cdk aws_lambda aws cdk",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aws_cdk.aws_stepfunctions",
  "homepage": "https://github.com/aws/aws-cdk",
  "release_count": 258,
  "dependency_ids": [
    "pypi_aws_cdk.aws_cloudwatch",
    "pypi_aws_cdk.aws_events",
    "pypi_aws_cdk.aws_iam",
    "pypi_aws_cdk.aws_logs",
    "pypi_aws_cdk.aws_s3",
    "pypi_aws_cdk.core",
    "pypi_constructs",
    "pypi_jsii",
    "pypi_publication",
    "pypi_typeguard"
  ]
}