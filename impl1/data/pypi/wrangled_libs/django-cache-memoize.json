{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: web environment :: mozilla",
    "framework :: django",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "license :: osi approved :: mozilla public license 2.0 (mpl 2.0)",
    "programming language :: python :: 3",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "topic :: internet :: www/http"
  ],
  "description": "====================\ndjango-cache-memoize\n====================\n\n* license: mpl 2.0\n\n.. image:: https://github.com/peterbe/django-cache-memoize/workflows/python/badge.svg\n   :alt: build status\n   :target: https://github.com/peterbe/django-cache-memoize/actions?query=workflow%3apython\n\n.. image:: https://readthedocs.org/projects/django-cache-memoize/badge/?version=latest\n   :alt: documentation status\n   :target: https://django-cache-memoize.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n  :target: https://github.com/ambv/black\n\ndjango utility for a memoization decorator that uses the django cache framework.\n\nfor versions of python and django, check out `the tox.ini file`_.\n\n.. _`the tox.ini file`: https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini\n\nkey features\n------------\n\n* memoized function calls can be invalidated.\n\n* works with non-trivial arguments and keyword arguments\n\n* insight into cache hits and cache missed with a callback.\n\n* ability to use as a \"guard\" for repeated execution when storing the function\n  result isn't important or needed.\n\n\ninstallation\n============\n\n.. code-block:: python\n\n    pip install django-cache-memoize\n\nusage\n=====\n\n.. code-block:: python\n\n    # import the decorator\n    from cache_memoize import cache_memoize\n\n    # attach decorator to cacheable function with a timeout of 100 seconds.\n    @cache_memoize(100)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    # just a regular django view\n    def myview(request):\n        # if you run this view repeatedly you'll get the same\n        # output every time for 100 seconds.\n        return http.httpresponse(str(expensive_function(0, 100)))\n\n\nthe caching uses `django's default cache framework`_. ultimately, it calls\n``django.core.cache.cache.set(cache_key, function_out, expiration)``.\nso if you have a function that returns something that can't be pickled and\ncached it won't work.\n\n    for cases like this, django exposes a simple, low-level cache api. you can\n    use this api to store objects in the cache with any level of granularity\n    you like. you can cache any python object that can be pickled safely:\n    strings, dictionaries, lists of model objects, and so forth. (most\n    common python objects can be pickled; refer to the python documentation\n    for more information about pickling.)\n\nsee `documentation`_.\n\n\n.. _`django's default cache framework`: https://docs.djangoproject.com/en/1.11/topics/cache/\n.. _`documentation`: https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api\n\n\nexample usage\n=============\n\nthis blog post: `how to use django-cache-memoize`_\n\nit demonstrates similarly to the above usage example but with a little more\ndetail. in particular it demonstrates the difference between *not* using\n``django-cache-memoize`` and then adding it to your code after.\n\n.. _`how to use django-cache-memoize`: https://www.peterbe.com/plog/how-to-use-django-cache-memoize\n\nadvanced usage\n==============\n\n``args_rewrite``\n~~~~~~~~~~~~~~~~\n\ninternally the decorator rewrites every argument and keyword argument to\nthe function it wraps into a concatenated string. the first thing you\nmight want to do is help the decorator rewrite the arguments to something\nmore suitable as a cache key string. for example, suppose you have instances\nof a class whose ``__str__`` method doesn't return a unique value. for example:\n\n.. code-block:: python\n\n    class record(models.model):\n        name = models.charfield(max_length=100)\n        lastname = models.charfield(max_length=100)\n        friends = models.manytomanyfield(someothermodel)\n\n        def __str__(self):\n            return self.name\n\n    # example use:\n    >>> record = record.objects.create(name='peter', lastname='bengtsson')\n    >>> print(record)\n    peter\n    >>> record2 = record.objects.create(name='peter', lastname='different')\n    >>> print(record2)\n    peter\n\nthis is a contrived example, but basically *you know* that the ``str()``\nconversion of certain arguments isn't safe. then you can pass in a callable\ncalled ``args_rewrite``. it gets the same positional and keyword arguments\nas the function you're decorating. here's an example implementation:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def count_friends_args_rewrite(record):\n        # the 'id' is always unique. use that instead of the default __str__\n        return record.id\n\n    @cache_memoize(100, args_rewrite=count_friends_args_rewrite)\n    def count_friends(record):\n        # assume this is an expensive function that can be memoize cached.\n        return record.friends.all().count()\n\n\n``prefix``\n~~~~~~~~~~\n\nby default the prefix becomes the name of the function. consider:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10, prefix='randomness')\n    def function1():\n        return random.random()\n\n    @cache_memoize(10, prefix='randomness')\n    def function2():  # different name, same arguments, same functionality\n        return random.random()\n\n    # example use\n    >>> function1()\n    0.39403406043780986\n    >>> function1()\n    0.39403406043780986\n    >>> # ^ repeated of course\n    >>> function2()\n    0.39403406043780986\n    >>> # ^ because the prefix was forcibly the same, the cache key is the same\n\n\n``hit_callable``\n~~~~~~~~~~~~~~~~\n\nif set, a function that gets called with the original argument and keyword\narguments **if** the cache was able to find and return a cache hit.\nfor example, suppose you want to tell your ``statsd`` server every time\nthere's a cache hit.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def _cache_hit(user, **kwargs):\n        statsdthing.incr(f'cachehit:{user.id}', 1)\n\n    @cache_memoize(10, hit_callable=_cache_hit)\n    def calculate_tax(user, tax=0.1):\n        return ...\n\n\n``miss_callable``\n~~~~~~~~~~~~~~~~~\n\nexact same functionality as ``hit_callable`` except the obvious difference\nthat it gets called if it was *not* a cache hit.\n\n``store_result``\n~~~~~~~~~~~~~~~~\n\nthis is useful if you have a function you want to make sure only gets called\nonce per timeout expiration but you don't actually care that much about\nwhat the function return value was. perhaps because you know that the\nfunction returns something that would quickly fill up your ``memcached`` or\nperhaps you know it returns something that can't be pickled. then you\ncan set ``store_result`` to ``false``. this is equivalent to your function\nreturning ``true``.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(1000, store_result=false)\n    def send_tax_returns(user):\n        # something something time consuming\n        ...\n        return some_none_pickleable_thing\n\n    def myview(request):\n        # view this view as much as you like the 'send_tax_returns' function\n        # won't be called more than once every 1000 seconds.\n        send_tax_returns(request.user)\n\n``cache_exceptions``\n~~~~~~~~~~~~~~~~~~~~\n\nthis is useful if you have a function that can raise an exception as valid\nresult. if the cached function raises any of specified exceptions is the\nexception cached and raised as normal. subsequent cached calls will\nimmediately re-raise the exception and the function will not be executed.\n``cache_exceptions`` accepts an exception or a tuple of exceptions.\n\n\nthis option allows you to cache said exceptions like any other result.\nonly exceptions raised from the list of classes provided as cache_exceptions\nare cached, all others are propagated immediately.\n\n.. code-block:: python\n\n    >>> from cache_memoize import cache_memoize\n\n    >>> class invalidparameter(exception):\n    ...     pass\n\n    >>> @cache_memoize(1000, cache_exceptions=(invalidparameter, ))\n    ... def run_calculations(parameter):\n    ...     # something something time consuming\n    ...     raise invalidparameter\n\n    >>> run_calculations(1)\n    traceback (most recent call last):\n    ...\n    invalidparameter\n\n    # run_calculations will now raise invalidparameter immediately\n    # without running the expensive calculation\n    >>> run_calculations(1)\n    traceback (most recent call last):\n    ...\n    invalidparameter\n\n``cache_alias``\n~~~~~~~~~~~~~~~\n\nthe ``cache_alias`` argument allows you to use a cache other than the default.\n\n.. code-block:: python\n\n    # given settings like:\n    # caches = {\n    #     'default': {...},\n    #     'other': {...},\n    # }\n\n    @cache_memoize(1000, cache_alias='other')\n    def myfunc(start, end):\n        return random.random()\n\n\ncache invalidation\n~~~~~~~~~~~~~~~~~~\n\nwhen you want to \"undo\" some caching done, you simply call the function\nagain with the same arguments except you add ``.invalidate`` to the function.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(100, 200)\n    121\n    >>> exensive_function.invalidate(1, 100)\n    >>> expensive_function(1, 100)\n    89\n    >>> expensive_function(100, 200)\n    121\n\nan \"alias\" of doing the same thing is to pass a keyword argument called\n``_refresh=true``. like this:\n\n.. code-block:: python\n\n    # continuing from the code block above\n    >>> expensive_function(100, 200)\n    121\n    >>> expensive_function(100, 200, _refresh=true)\n    177\n    >>> expensive_function(100, 200)\n    177\n\nthere is no way to clear more than one cache key. in the above example,\nyou had to know the \"original arguments\" when you wanted to invalidate\nthe cache. there is no method \"search\" for all cache keys that match a\ncertain pattern.\n\n\ncompatibility\n=============\n\n* python 3.8, 3.9, 3.10 & 3.11\n\n* django 3.2, 4.1 & 4.2\n\ncheck out the `tox.ini`_ file for more up-to-date compatibility by\ntest coverage.\n\n.. _`tox.ini`: https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini\n\nprior art\n=========\n\nhistory\n~~~~~~~\n\n`mozilla symbol server`_ is written in django. it's a web service that\nsits between c++ debuggers and aws s3. it shuffles symbol files in and out of\naws s3. symbol files are for c++ (and other compiled languages) what\nsourcemaps are for javascript.\n\nthis service gets a lot of traffic. the download traffic (proxying requests\nfor symbols in s3) gets about ~40 requests per second. due to the nature\nof the application most of these gets result in a 404 not found but instead\nof asking aws s3 for every single file, these lookups are cached in a\nhighly configured `redis`_ configuration. this redis cache is also connected\nto the part of the code that uploads new files.\n\nnew uploads are arriving as zip file bundles of files, from mozilla's build\nsystems, at a rate of about 600mb every minute, each containing on average\nabout 100 files each. when a new upload comes in we need to quickly be able\nfind out if it exists in s3 and this gets cached since often the same files\nare repeated in different uploads. but when a file does get uploaded into s3\nwe need to quickly and confidently invalidate any local caches. that way you\nget to keep a really aggressive cache without any stale periods.\n\nthis is the use case ``django-cache-memoize`` was built for and tested in.\nit was originally written for python 3.6 in django 1.11 but when\nextracted, made compatible with python 2.7 and as far back as django 1.8.\n\n``django-cache-memoize`` is also used in `songsear.ch`_ to cache short\nqueries in the autocomplete search input. all autocomplete is done by\nelasticsearch, which is amazingly fast, but not as fast as ``memcached``.\n\n\n.. _`mozilla symbol server`: https://symbols.mozilla.org\n.. _`redis`: https://redis.io/\n.. _`songsear.ch`: https://songsear.ch\n\n\n\"competition\"\n~~~~~~~~~~~~~\n\nthere is already `django-memoize`_ by `thomas vavrys`_.\nit too is available as a memoization decorator you use in django. and it\nuses the default cache framework as a storage. it used ``inspect`` on the\ndecorated function to build a cache key.\n\nin benchmarks running both ``django-memoize`` and ``django-cache-memoize``\ni found ``django-cache-memoize`` to be **~4 times faster** on average.\n\nanother key difference is that ``django-cache-memoize`` uses ``str()`` and\n``django-memoize`` uses ``repr()`` which in certain cases of mutable objects\n(e.g. class instances) as arguments the caching will not work. for example,\nthis does *not* work in ``django-memoize``:\n\n.. code-block:: python\n\n    from memoize import memoize\n\n    @memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this will never be memoized\n        print(count_user_groups(request.user))\n\nhowever, this works...\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this *will* work as expected\n        print(count_user_groups(request.user))\n\n\n.. _`django-memoize`: http://pythonhosted.org/django-memoize/\n.. _`thomas vavrys`: https://github.com/tvavrys\n\n\ndevelopment\n===========\n\nthe most basic thing is to clone the repo and run:\n\n.. code-block:: shell\n\n    pip install -e \".[dev]\"\n    tox\n\n\ncode style is all black\n~~~~~~~~~~~~~~~~~~~~~~~\n\nall code has to be formatted with `black <https://pypi.org/project/black/>`_\nand the best tool for checking this is\n`therapist <https://pypi.org/project/therapist/>`_ since it can help you run\nall, help you fix things, and help you make sure linting is passing before\nyou git commit. this project also uses ``flake8`` to check other things\nblack can't check.\n\nto check linting with ``tox`` use:\n\n.. code:: bash\n\n    tox -e lint-py36\n\nto install the ``therapist`` pre-commit hook simply run:\n\n.. code:: bash\n\n    therapist install\n\nwhen you run ``therapist run`` it will only check the files you've touched.\nto run it for all files use:\n\n.. code:: bash\n\n    therapist run --use-tracked-files\n\nand to fix all/any issues run:\n\n.. code:: bash\n\n    therapist run --use-tracked-files --fix\n\n\n",
  "docs_url": null,
  "keywords": "django,memoize,cache,decorator",
  "license": "mpl-2.0",
  "name": "django-cache-memoize",
  "package_url": "https://pypi.org/project/django-cache-memoize/",
  "project_url": "https://pypi.org/project/django-cache-memoize/",
  "project_urls": {
    "Homepage": "https://github.com/peterbe/django-cache-memoize"
  },
  "release_url": "https://pypi.org/project/django-cache-memoize/0.2.0/",
  "requires_dist": [
    "flake8 ; extra == 'dev'",
    "tox ; extra == 'dev'",
    "twine ; extra == 'dev'",
    "therapist ; extra == 'dev'",
    "black ; extra == 'dev'"
  ],
  "requires_python": ">=3.8",
  "summary": "django utility for a memoization decorator that uses the django cache framework.",
  "version": "0.2.0",
  "releases": [],
  "developers": [
    "mail@peterbe.com",
    "peter_bengtsson"
  ],
  "kwds": "cache_memoize badge django memoized memoize",
  "license_kwds": "mpl-2.0",
  "libtype": "pypi",
  "id": "pypi_django_cache_memoize",
  "homepage": "https://github.com/peterbe/django-cache-memoize",
  "release_count": 12,
  "dependency_ids": [
    "pypi_black",
    "pypi_flake8",
    "pypi_therapist",
    "pypi_tox",
    "pypi_twine"
  ]
}