{
  "classifiers": [
    "development status :: 4 - beta",
    "intended audience :: developers",
    "license :: osi approved :: mit license",
    "programming language :: c++",
    "programming language :: python :: 3 :: only",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.6",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9"
  ],
  "description": "# jsonslicer - stream json parser\n\n<a href=\"https://repology.org/metapackage/python:jsonslicer/versions\">\n\t<img src=\"https://repology.org/badge/vertical-allrepos/python:jsonslicer.svg\" alt=\"jsonslicer packaging status\" align=\"right\">\n</a>\n\n[![ci](https://github.com/amdmi3/jsonslicer/actions/workflows/ci.yml/badge.svg)](https://github.com/amdmi3/jsonslicer/actions/workflows/ci.yml)\n[![codecov](https://codecov.io/gh/amdmi3/jsonslicer/branch/master/graph/badge.svg?token=lubcpfigcr)](https://codecov.io/gh/amdmi3/jsonslicer)\n[![pypi downloads](https://img.shields.io/pypi/dm/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![pypi version](https://img.shields.io/pypi/v/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![pypi pythons](https://img.shields.io/pypi/pyversions/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![github commits (since latest release)](https://img.shields.io/github/commits-since/amdmi3/jsonslicer/latest.svg)](https://github.com/amdmi3/jsonslicer)\n\n## overview\n\njsonslicer performs a **stream** or **iterative**, **pull** json\nparsing, which means it **does not load** whole json into memory\nand is able to parse **very large** json files or streams.  the\nmodule is written in c and uses [yajl](https://lloyd.github.io/yajl/)\njson parsing library, so it's also quite **fast**.\n\njsonslicer takes a **path** of json map keys or array indexes, and\nprovides **iterator interface** which yields json data matching\ngiven path as complete python objects.\n\n## example\n\n```json\n{\n    \"friends\": [\n        {\"name\": \"john\", \"age\": 31},\n        {\"name\": \"ivan\", \"age\": 26}\n    ],\n    \"colleagues\": {\n        \"manager\": {\"name\": \"jack\", \"age\": 33},\n        \"subordinate\": {\"name\": \"lucy\", \"age\": 21}\n    }\n}\n```\n\n```python\nfrom jsonslicer import jsonslicer\n\n# extract specific elements:\nwith open('people.json') as data:\n    ivans_age = next(jsonslicer(data, ('friends', 1, 'age')))\n    # 26\n\nwith open('people.json') as data:\n    managers_name = next(jsonslicer(data, ('colleagues', 'manager', 'name')))\n    # 'jack'\n\n# iterate over collection(s) by using wildcards in the path:\nwith open('people.json') as data:\n    for person in jsonslicer(data, ('friends', none)):\n        print(person)\n        # {'name': 'john', 'age': 31}\n        # {'name': 'ivan', 'age': 26}\n\n# iteration over both arrays and dicts is possible, even at the same time\nwith open('people.json') as data:\n    for person in jsonslicer(data, (none, none)):\n        print(person)\n        # {'name': 'john', 'age': 31}\n        # {'name': 'ivan', 'age': 26}\n        # {'name': 'jack', 'age': 33}\n        # {'name': 'lucy', 'age': 21}\n\n# map key of returned objects is available on demand...\nwith open('people.json') as data:\n    for position, person in jsonslicer(data, ('colleagues', none), path_mode='map_keys'):\n        print(position, person)\n        # 'manager' {'name': 'jack', 'age': 33}\n        # 'subordinate' {'name': 'lucy', 'age': 21}\n\n# ...as well as complete path information\nwith open('people.json') as data:\n    for *path, person in jsonslicer(data, (none, none), path_mode='full'):\n        print(path, person)\n        # ('friends', 0) {'name': 'john', 'age': 31})\n        # ('friends', 1) {'name': 'ivan', 'age': 26})\n        # ('colleagues', 'manager') {'name': 'jack', 'age': 33})\n        # ('colleagues', 'subordinate') {'name': 'lucy', 'age': 21})\n\n# extract all instances of deep nested field\nwith open('people.json') as data:\n    age_sum = sum(jsonslicer(data, (none, none, 'age')))\n    # 111\n```\n\n## api\n\n```\njsonslicer.jsonslicer(\n    file,\n    path_prefix,\n    read_size=1024,\n    path_mode=none,\n    yajl_allow_comments=false,\n    yajl_dont_validate_strings=false,\n    yajl_allow_trailing_garbage=false,\n    yajl_allow_multiple_values=false,\n    yajl_allow_partial_values=false,\n    yajl_verbose_errors=true,\n    encoding=none,\n    errors=none,\n    binary=false,\n)\n```\n\nconstructs iterative json parser. which reads json data from _file_ (a `.read()`-supporting [file-like object](https://docs.python.org/3/glossary.html#term-file-like-object) containing a json document).\n\n_file_ is a `.read()`-supporting [file-like\nobject](https://docs.python.org/3/glossary.html#term-file-like-object)\ncontaining a json document. both binary and text files are supported,\nbut binary ones are preferred, because the parser has to operate on\nbinary data internally anyway, and using text input would require an\nunnecessary encoding/decoding which yields ~3% performance overhead.\nnote that jsonslicer supports both unicode and binary output regardless\nof input format.\n\n_path_prefix_ is an iterable (usually a list or a tuple) specifying\na path or a path pattern of objects which the parser should extract\nfrom json.\n\nfor instance, in the example above a path `('friends', 0, 'name')`\nwill yield string `'john'`, by descending from the root element\ninto the dictionary element by key `'friends'`, then into the array\nelement by index `0`, then into the dictionary element by key\n`'name'`. note that integers only match array indexes and strings\nonly match dictionary keys.\n\nthe path can be turned into a pattern by specifying `none` as a\nplaceholder in some path positions. for instance,  `(none, none,\n'name')` will yield all four names from the example above, because\nit matches an item under 'name' key on the second nesting level of\nany arrays or map structure.\n\nboth strings and byte objects are allowed in path, regardless of\ninput and output encodings.  are automatically converted\nto the format used internally.\n\n_read_size_ is a size of block read by the parser at a time.\n\n_path_mode_ is a string which specifies how a parser should\nreturn path information along with objects. the following modes are\nsupported:\n\n* _'ignore'_ (the default) - do not output any path information, just\nobjects as is (`'friends'`).\n\n  ```python\n  {'name': 'john', 'age': 31}\n  {'name': 'ivan', 'age': 26}\n  {'name': 'jack', 'age': 33}\n  {'name': 'lucy', 'age': 21}\n  ```\n\n  common usage pattern for this mode is\n\n  ```python\n  for object in jsonslicer(...)\n  ```\n\n* _'map_keys'_ - output objects as is when traversing arrays and tuples\nconsisting of map key and object when traversing maps.\n\n  ```python\n  {'name': 'john', 'age': 31}\n  {'name': 'ivan', 'age': 26}\n  ('manager', {'name': 'jack', 'age': 33})\n  ('subordinate', {'name': 'lucy', 'age': 21})\n  ```\n\n  this format may seem inconsistent (and therefore it's not the default),\n  however in practice only collection of a single type is iterated at\n  a time and this type is known, so this format is likely the most useful\n  as in most cases you do need dictionary keys.\n\n  common usage pattern for this mode is\n\n  ```python\n  for object in jsonslicer(...)  # when iterating arrays\n  for key object in jsonslicer(...)  # when iterating maps\n  ```\n\n* _'full_paths'_ - output tuples consisting of all path components\n(both map keys and array indexes) and an object as the last element.\n\n  ```python\n  ('friends', 0, {'name': 'john', 'age': 31})\n  ('friends', 1, {'name': 'ivan', 'age': 26})\n  ('colleagues', 'manager', {'name': 'jack', 'age': 33})\n  ('colleagues', 'subordinate', {'name': 'lucy', 'age': 21})\n  ```\n\n  common usage pattern for this mode is\n\n  ```python\n  for *path, object in jsonslicer(...)\n  ```\n\n_yajl_allow_comments_ enables corresponding yajl flag, which is\ndocumented as follows:\n\n> ignore javascript style comments present in json input.  non-standard,\n> but rather fun\n\n_yajl_dont_validate_strings_ enables corresponding yajl flag, which\nis documented as follows:\n\n> when set the parser will verify that all strings in json input\n> are valid utf8 and will emit a parse error if this is not so.  when\n> set, this option makes parsing slightly more expensive (~7% depending\n> on processor and compiler in use)\n\n_yajl_allow_trailing_garbage_ enables corresponding yajl flag, which\nis documented as follows:\n\n> by default, yajl will ensure the entire input text was consumed\n> and will raise an error otherwise.  enabling this flag will cause\n> yajl to disable this check.  this can be useful when parsing json\n> out of a that contains more than a single json document.\n\n_yajl_allow_multiple_values_ enables corresponding yajl flag, which\nis documented as follows:\n\n> allow multiple values to be parsed by a single handle.  the entire\n> text must be valid json, and values can be seperated by any kind\n> of whitespace.  this flag will change the behavior of the parser,\n> and cause it continue parsing after a value is parsed, rather than\n> transitioning into a complete state.  this option can be useful\n> when parsing multiple values from an input stream.\n\n_yajl_allow_partial_values_ enables corresponding yajl flag, which\nis documented as follows:\n\n> when yajl_complete_parse() is called the parser will check that the\n> top level value was completely consumed.  i.e., if called whilst\n> in the middle of parsing a value yajl will enter an error state\n> (premature eof).  setting this flag suppresses that check and the\n> corresponding error.\n\n_yajl_verbose_errors_ enables verbose yajl errors, with exception\nmessage including the json text where the error occured, along with\nan arrow pointing to the specific char.\n\n_encoding_ may be used to override output encoding, which is derived\nfrom the input file handle if possible, or otherwise set to the\ndefault one as python builtin `open()` would use (usually `'utf-8'`).\n\n_errors_ is an optional string that specifies how encoding and\ndecoding errors are to be handled. defaults to `'strict'`\n\n_binary_ forces the output to be in form of `bytes` objects instead\nof `str` unicode strings.\n\nthe constructed object is as iterator. you may call `next()` to extract\nsingle element from it, iterate it via `for` loop, or use it in generator\ncomprehensions or in any place where iterator is accepted.\n\n## performance/competitors\n\nthe closest competitor is [ijson](https://github.com/isagalaev/ijson),\nand jsonslicer was written to be better. namely,\n\n* it's up to 35x faster depending on ijson backend (starting with 3.0,\n  ijson supports comparable performance via yajl2_c backend), close in\n  performance to python's native `json` module.\n* it supports more flexible paths/patterns specifying which objects\n  to iterate over in json hierarchy and provides consistent interface\n  for iteration over arrays and dictionaries\n\nthe results of bundled benchmark on python 3.8.2 / clang 8.0.1 / `-o2 -dndebug` / freebsd 12.1 amd64 / core i7-6600u cpu @ 2.60ghz.\n\n|                                                 facility |   type |   objects/sec |\n|---------------------------------------------------------:|-------:|--------------:|\n|                                             json.loads() |    str |       1147.6k |\n|                                    json.load(stringio()) |    str |       1139.3k |\n|   **jsonslicer (no paths, binary input, binary output)** |  bytes |       1149.7k |\n|  **jsonslicer (no paths, unicode input, binary output)** |  bytes |       1134.5k |\n|  **jsonslicer (no paths, binary input, unicode output)** |    str |       1012.3k |\n| **jsonslicer (no paths, unicode input, unicode output)** |    str |        996.2k |\n|               **jsonslicer (full paths, binary output)** |  bytes |        763.1k |\n|              **jsonslicer (full paths, unicode output)** |    str |        567.2k |\n|                                            ijson.yajl2_c |  bytes |       1062.0k |\n|                                         ijson.yajl2_cffi |  bytes |         71.6k |\n|                                              ijson.yajl2 |  bytes |         56.4k |\n|                                             ijson.python |    str |         32.0k |\n\n## status/todo\n\njsonslicer is currently in beta stage, used in production in\n[repology](https://repology.org) project. testing foci are:\n\n- edge cases with uncommon encoding (input/output) configurations\n- absence of memory leaks\n\n## requirements\n\n- python 3.6+\n- [yajl](https://lloyd.github.io/yajl/) 2.0.3+ (older versions lack pkgconfig file)\n- pkg-config (build-time)\n- c++ compiler (build-time)\n\n## license\n\nmit license, copyright (c) 2019 dmitry marakasov amdmi3@amdmi3.ru.\n",
  "docs_url": null,
  "keywords": "json,parser,pull,stream",
  "license": "mit",
  "name": "jsonslicer",
  "package_url": "https://pypi.org/project/jsonslicer/",
  "project_url": "https://pypi.org/project/jsonslicer/",
  "project_urls": {
    "Homepage": "https://github.com/AMDmi3/jsonslicer"
  },
  "release_url": "https://pypi.org/project/jsonslicer/0.1.8/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "stream json parser with iterator interface",
  "version": "0.1.8",
  "releases": [],
  "developers": [
    "amdmi3@amdmi3.ru",
    "dmitry_marakasov"
  ],
  "kwds": "jsonslicer json yajl_complete_parse ijson yajl2_cffi",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_jsonslicer",
  "homepage": "https://github.com/amdmi3/jsonslicer",
  "release_count": 9,
  "dependency_ids": []
}