{
  "classifiers": [
    "intended audience :: developers",
    "license :: osi approved :: apache software license",
    "natural language :: english",
    "operating system :: macos",
    "operating system :: microsoft",
    "operating system :: posix",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: internet",
    "topic :: software development",
    "topic :: software development :: libraries",
    "typing :: typed"
  ],
  "description": ".. _documentation: https://aio-pika.readthedocs.org/\n.. _adopted official rabbitmq tutorial: https://aio-pika.readthedocs.io/en/latest/rabbitmq-tutorial/1-introduction.html\n\n\naio-pika\n========\n\n.. image:: https://readthedocs.org/projects/aio-pika/badge/?version=latest\n    :target: https://aio-pika.readthedocs.org/\n    :alt: readthedocs\n\n.. image:: https://coveralls.io/repos/github/mosquito/aio-pika/badge.svg?branch=master\n    :target: https://coveralls.io/github/mosquito/aio-pika\n    :alt: coveralls\n\n.. image:: https://github.com/mosquito/aio-pika/workflows/tests/badge.svg\n    :target: https://github.com/mosquito/aio-pika/actions?query=workflow%3atests\n    :alt: github actions\n\n.. image:: https://img.shields.io/pypi/v/aio-pika.svg\n    :target: https://pypi.python.org/pypi/aio-pika/\n    :alt: latest version\n\n.. image:: https://img.shields.io/pypi/wheel/aio-pika.svg\n    :target: https://pypi.python.org/pypi/aio-pika/\n\n.. image:: https://img.shields.io/pypi/pyversions/aio-pika.svg\n    :target: https://pypi.python.org/pypi/aio-pika/\n\n.. image:: https://img.shields.io/pypi/l/aio-pika.svg\n    :target: https://pypi.python.org/pypi/aio-pika/\n\n\na wrapper around `aiormq`_ for asyncio and humans.\n\ncheck out the examples and the tutorial in the `documentation`_.\n\nif you are a newcomer to rabbitmq, please start with the `adopted official rabbitmq tutorial`_.\n\n.. _aiormq: http://github.com/mosquito/aiormq/\n\n.. note::\n   since version ``5.0.0`` this library doesn't use ``pika`` as amqp connector.\n   versions below ``5.0.0`` contains or requires ``pika``'s source code.\n\n.. note::\n   the version 7.0.0 has breaking api changes, see changelog.md\n   for migration hints.\n\n\nfeatures\n--------\n\n* completely asynchronous api.\n* object oriented api.\n* transparent auto-reconnects with complete state recovery with `connect_robust`\n  (e.g. declared queues or exchanges, consuming state and bindings).\n* python 3.7+ compatible.\n* for python 3.5 users, aio-pika is available via `aio-pika<7`.\n* transparent `publisher confirms`_ support.\n* `transactions`_ support.\n* complete type-hints coverage.\n\n\n.. _transactions: https://www.rabbitmq.com/semantics.html\n.. _publisher confirms: https://www.rabbitmq.com/confirms.html\n\n\ninstallation\n------------\n\n.. code-block:: shell\n\n    pip install aio-pika\n\n\nusage example\n-------------\n\nsimple consumer:\n\n.. code-block:: python\n\n    import asyncio\n    import aio_pika\n    import aio_pika.abc\n\n\n    async def main(loop):\n        # connect with the givien parameters is also valiable.\n        # aio_pika.connect_robust(host=\"host\", login=\"login\", password=\"password\")\n        # you can only choose one option to create a connection, url or kw-based params.\n        connection = await aio_pika.connect_robust(\n            \"amqp://guest:guest@127.0.0.1/\", loop=loop\n        )\n\n        async with connection:\n            queue_name = \"test_queue\"\n\n            # creating channel\n            channel: aio_pika.abc.abstractchannel = await connection.channel()\n\n            # declaring queue\n            queue: aio_pika.abc.abstractqueue = await channel.declare_queue(\n                queue_name,\n                auto_delete=true\n            )\n\n            async with queue.iterator() as queue_iter:\n                # cancel consuming after __aexit__\n                async for message in queue_iter:\n                    async with message.process():\n                        print(message.body)\n\n                        if queue.name in message.body.decode():\n                            break\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.get_event_loop()\n        loop.run_until_complete(main(loop))\n        loop.close()\n\nsimple publisher:\n\n.. code-block:: python\n\n    import asyncio\n    import aio_pika\n    import aio_pika.abc\n\n\n    async def main(loop):\n        # explicit type annotation\n        connection: aio_pika.robustconnection = await aio_pika.connect_robust(\n            \"amqp://guest:guest@127.0.0.1/\", loop=loop\n        )\n\n        routing_key = \"test_queue\"\n\n        channel: aio_pika.abc.abstractchannel = await connection.channel()\n\n        await channel.default_exchange.publish(\n            aio_pika.message(\n                body='hello {}'.format(routing_key).encode()\n            ),\n            routing_key=routing_key\n        )\n\n        await connection.close()\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.get_event_loop()\n        loop.run_until_complete(main(loop))\n        loop.close()\n\n\nget single message example:\n\n.. code-block:: python\n\n    import asyncio\n    from aio_pika import connect_robust, message\n\n\n    async def main(loop):\n        connection = await connect_robust(\n            \"amqp://guest:guest@127.0.0.1/\",\n            loop=loop\n        )\n\n        queue_name = \"test_queue\"\n        routing_key = \"test_queue\"\n\n        # creating channel\n        channel = await connection.channel()\n\n        # declaring exchange\n        exchange = await channel.declare_exchange('direct', auto_delete=true)\n\n        # declaring queue\n        queue = await channel.declare_queue(queue_name, auto_delete=true)\n\n        # binding queue\n        await queue.bind(exchange, routing_key)\n\n        await exchange.publish(\n            message(\n                bytes('hello', 'utf-8'),\n                content_type='text/plain',\n                headers={'foo': 'bar'}\n            ),\n            routing_key\n        )\n\n        # receiving message\n        incoming_message = await queue.get(timeout=5)\n\n        # confirm message\n        await incoming_message.ack()\n\n        await queue.unbind(exchange, routing_key)\n        await queue.delete()\n        await connection.close()\n\n\n    if __name__ == \"__main__\":\n        loop = asyncio.get_event_loop()\n        loop.run_until_complete(main(loop))\n\n\nthere are more examples and the rabbitmq tutorial in the `documentation`_.\n\nsee also\n==========\n\n`aiormq`_\n---------\n\n`aiormq` is a pure python amqp client library. it is under the hood of **aio-pika** and might to be used when you really loving works with the protocol low level.\nfollowing examples demonstrates the user api.\n\nsimple consumer:\n\n.. code-block:: python\n\n    import asyncio\n    import aiormq\n\n    async def on_message(message):\n        \"\"\"\n        on_message doesn't necessarily have to be defined as async.\n        here it is to show that it's possible.\n        \"\"\"\n        print(f\" [x] received message {message!r}\")\n        print(f\"message body is: {message.body!r}\")\n        print(\"before sleep!\")\n        await asyncio.sleep(5)   # represents async i/o operations\n        print(\"after sleep!\")\n\n    async def main():\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n        # creating a channel\n        channel = await connection.channel()\n\n        # declaring queue\n        declare_ok = await channel.queue_declare('helo')\n        consume_ok = await channel.basic_consume(\n            declare_ok.queue, on_message, no_ack=true\n        )\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n    loop.run_forever()\n\nsimple publisher:\n\n.. code-block:: python\n\n    import asyncio\n    from typing import optional\n\n    import aiormq\n    from aiormq.abc import deliveredmessage\n\n    message: optional[deliveredmessage] = none\n\n    async def main():\n        global message\n        body = b'hello world!'\n\n        # perform connection\n        connection = await aiormq.connect(\"amqp://guest:guest@localhost//\")\n\n        # creating a channel\n        channel = await connection.channel()\n        declare_ok = await channel.queue_declare(\"hello\", auto_delete=true)\n\n        # sending the message\n        await channel.basic_publish(body, routing_key='hello')\n        print(f\" [x] sent {body}\")\n\n        message = await channel.basic_get(declare_ok.queue)\n        print(f\" [x] received message from {declare_ok.queue!r}\")\n\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main())\n\n    assert message is not none\n    assert message.routing_key == \"hello\"\n    assert message.body == b'hello world!'\n\nthe `patio`_ and the `patio-rabbitmq`_\n--------------------------------------\n\n**patio** is an acronym for python asynchronous tasks for asyncio - an easily extensible library, for distributed task execution, like celery, only targeting asyncio as the main design approach.\n\n**patio-rabbitmq** provides you with the ability to use *rpc over rabbitmq* services with extremely simple implementation:\n\n.. code-block:: python\n\n   from patio import registry, threadpoolexecutor\n   from patio_rabbitmq import rabbitmqbroker\n\n   rpc = registry(project=\"patio-rabbitmq\", auto_naming=false)\n\n   @rpc(\"sum\")\n   def sum(*args):\n       return sum(args)\n\n   async def main():\n       async with threadpoolexecutor(rpc, max_workers=16) as executor:\n           async with rabbitmqbroker(\n               executor, amqp_url=\"amqp://guest:guest@localhost/\",\n           ) as broker:\n               await broker.join()\n\nand the caller side might be written like this:\n\n.. code-block:: python\n\n    import asyncio\n    from patio import nullexecutor, registry\n    from patio_rabbitmq import rabbitmqbroker\n\n    async def main():\n        async with nullexecutor(registry(project=\"patio-rabbitmq\")) as executor:\n            async with rabbitmqbroker(\n                executor, amqp_url=\"amqp://guest:guest@localhost/\",\n            ) as broker:\n                print(await asyncio.gather(\n                    *[\n                        broker.call(\"mul\", i, i, timeout=1) for i in range(10)\n                     ]\n                ))\n\n\n`propan`_:fire:\n---------------\n\n**propan** is a powerful and easy-to-use python framework for building event-driven applications that interact with any mq broker.\n\nif you need no deep dive into **rabbitmq** details, you can use more high-level **propan** interfaces:\n\n.. code-block:: python\n\n   from propan import propanapp, rabbitbroker\n\n   broker = rabbitbroker(\"amqp://guest:guest@localhost:5672/\")\n   app = propanapp(broker)\n\n   @broker.handle(\"user\")\n   async def user_created(user_id: int):\n       assert isinstance(user_id, int)\n       return f\"user-{user_id}: created\"\n\n   @app.after_startup\n   async def pub_smth():\n       assert (\n           await broker.publish(1, \"user\", callback=true)\n       ) ==  \"user-1: created\"\n\nalso, **propan** validates messages by **pydantic**, generates your project **asyncapi** spec, tests application locally, rpc calls, and more.\n\nin fact, it is a high-level wrapper on top of **aio-pika**, so you can use both of these libraries' advantages at the same time.\n\n`python-socketio`_\n------------------\n\n`socket.io`_ is a transport protocol that enables real-time bidirectional event-based communication between clients (typically, though not always, web browsers) and a server. this package provides python implementations of both, each with standard and asyncio variants.\n\nalso this package is suitable for building messaging services over **rabbitmq** via **aio-pika** adapter:\n\n.. code-block:: python\n\n   import socketio\n   from aiohttp import web\n\n   sio = socketio.asyncserver(client_manager=socketio.asyncaiopikamanager())\n   app = web.application()\n   sio.attach(app)\n\n   @sio.event\n   async def chat_message(sid, data):\n       print(\"message \", data)\n\n   if __name__ == '__main__':\n       web.run_app(app)\n\nand a client is able to call `chat_message` the following way:\n\n.. code-block:: python\n\n   import asyncio\n   import socketio\n\n   sio = socketio.asyncclient()\n\n   async def main():\n       await sio.connect('http://localhost:8080')\n       await sio.emit('chat_message', {'response': 'my response'})\n\n   if __name__ == '__main__':\n       asyncio.run(main())\n\nthe `taskiq`_ and the `taskiq-aio-pika`_\n----------------------------------------\n\n**taskiq** is an asynchronous distributed task queue for python. the project takes inspiration from big projects such as celery and dramatiq. but taskiq can send and run both the sync and async functions.\n\nthe library provides you with **aio-pika** broker for running tasks too.\n\n.. code-block:: python\n\n   from taskiq_aio_pika import aiopikabroker\n\n   broker = aiopikabroker()\n\n   @broker.task\n   async def test() -> none:\n       print(\"nothing\")\n\n   async def main():\n       await broker.startup()\n       await test.kiq()\n\n`rasa`_\n-------\n\nwith over 25 million downloads, rasa open source is the most popular open source framework for building chat and voice-based ai assistants.\n\nwith **rasa**, you can build contextual assistants on:\n\n* facebook messenger\n* slack\n* google hangouts\n* webex teams\n* microsoft bot framework\n* rocket.chat\n* mattermost\n* telegram\n* twilio\n\nyour own custom conversational channels or voice assistants as:\n\n* alexa skills\n* google home actions\n\n**rasa** helps you build contextual assistants capable of having layered conversations with lots of back-and-forth. in order for a human to have a meaningful exchange with a contextual assistant, the assistant needs to be able to use context to build on things that were previously discussed \u2013 **rasa** enables you to build assistants that can do this in a scalable way.\n\nand it also uses **aio-pika** to interact with **rabbitmq** deep inside!\n\nversioning\n==========\n\nthis software follows `semantic versioning`_\n\n\nfor contributors\n----------------\n\nsetting up development environment\n__________________________________\n\nclone the project:\n\n.. code-block:: shell\n\n    git clone https://github.com/mosquito/aio-pika.git\n    cd aio-pika\n\ncreate a new virtualenv for `aio-pika`_:\n\n.. code-block:: shell\n\n    python3 -m venv env\n    source env/bin/activate\n\ninstall all requirements for `aio-pika`_:\n\n.. code-block:: shell\n\n    pip install -e '.[develop]'\n\n\nrunning tests\n_____________\n\n**note: in order to run the tests locally you need to run a rabbitmq instance with default user/password (guest/guest) and port (5672).**\n\nthe makefile provides a command to run an appropriate rabbitmq docker image:\n\n.. code-block:: bash\n\n    make rabbitmq\n\nto test just run:\n\n.. code-block:: bash\n\n    make test\n\n\nediting documentation\n_____________________\n\nto iterate quickly on the documentation live in your browser, try:\n\n.. code-block:: bash\n\n    nox -s docs -- serve\n\ncreating pull requests\n______________________\n\nplease feel free to create pull requests, but you should describe your use cases and add some examples.\n\nchanges should follow a few simple rules:\n\n* when your changes break the public api, you must increase the major version.\n* when your changes are safe for public api (e.g. added an argument with default value)\n* you have to add test cases (see `tests/` folder)\n* you must add docstrings\n* feel free to add yourself to `\"thank's to\" section`_\n\n\n.. _\"thank's to\" section: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#thanks-for-contributing\n.. _semantic versioning: http://semver.org/\n.. _aio-pika: https://github.com/mosquito/aio-pika/\n.. _propan: https://github.com/lancetnik/propan\n.. _patio: https://github.com/patio-python/patio\n.. _patio-rabbitmq: https://github.com/patio-python/patio-rabbitmq\n.. _socket.io: https://socket.io/\n.. _python-socketio: https://python-socketio.readthedocs.io/en/latest/intro.html\n.. _taskiq: https://github.com/taskiq-python/taskiq\n.. _taskiq-aio-pika: https://github.com/taskiq-python/taskiq-aio-pika\n.. _rasa: https://rasa.com/docs/rasa/\n",
  "docs_url": null,
  "keywords": "rabbitmq,asyncio,amqp,amqp 0.9.1,aiormq",
  "license": "apache-2.0",
  "name": "aio-pika",
  "package_url": "https://pypi.org/project/aio-pika/",
  "project_url": "https://pypi.org/project/aio-pika/",
  "project_urls": {
    "Documentation": "https://aio-pika.readthedocs.org/",
    "Homepage": "https://github.com/mosquito/aio-pika",
    "Source": "https://github.com/mosquito/aio-pika",
    "Tracker": "https://github.com/mosquito/aio-pika/issues"
  },
  "release_url": "https://pypi.org/project/aio-pika/9.3.1/",
  "requires_dist": [
    "aiormq (>=6.7.7,<6.8.0)",
    "yarl",
    "typing_extensions ; python_version < \"3.8\"",
    "setuptools ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.7,<4.0",
  "summary": "wrapper around the aiormq for asyncio and humans",
  "version": "9.3.1",
  "releases": [],
  "developers": [
    "dmitry_orlov",
    "me@mosquito.su"
  ],
  "kwds": "rabbitmq rabbitmqbroker aiormq aio_pika _aiormq",
  "license_kwds": "apache-2.0",
  "libtype": "pypi",
  "id": "pypi_aio_pika",
  "homepage": "https://github.com/mosquito/aio-pika",
  "release_count": 201,
  "dependency_ids": [
    "pypi_aiormq",
    "pypi_setuptools",
    "pypi_typing_extensions",
    "pypi_yarl"
  ]
}