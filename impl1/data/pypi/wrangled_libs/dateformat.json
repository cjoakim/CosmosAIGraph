{
  "classifiers": [],
  "description": "        \r\r\n        `dateformat` does two things:  turn `datetime` objects into strings, and turn strings into `datetime` objects.\r\r\n        it's goal is to do these things simply and well, and to satisfy the following criteria:\r\r\n        \r\r\n         * be fast enough (see below for benchmarks)\r\r\n         * handle a variety of date formats from multiple sources\r\r\n         * parse and format dates in many timezones and with many timezone offsets\r\r\n         * represent the expected format in a way that a non-technical person may understand\r\r\n         * be explicit about the expected format to prevent heuristic errors\r\r\n        \r\r\n        > \"but why another date library?\"\r\r\n        \r\r\n        there isn't currently a python library i've been able to find that matches these \r\r\n        requirements well enough for my use-cases.  [`arrow`](http://arrow.readthedocs.io/en/latest/)\r\r\n         comes closest, but still isn't quite suitable performance-wise.\r\r\n        \r\r\n        # usage\r\r\n        \r\r\n        all functionality is based around dateformat() objects:\r\r\n        \r\r\n        ### `def __init__(self, spec, is_24hour=none)`\r\r\n        \r\r\n        create a dateformat object from the provided spec string.\r\r\n        \r\r\n        ```\r\r\n        >>> from dateformat import dateformat\r\r\n        \r\r\n        >>> date_format = dateformat(\"yyyy-mm-dd hh:mm:ss.ssss+hh:mm\")\r\r\n        ```\r\r\n        \r\r\n        if `is_24hour` is not provided, the format will be in 12-hour mode if an am/pm \r\r\n        part is present in the spec, otherwise, dates will be in 24-hour mode.\r\r\n        \r\r\n        dateformat instances have two methods:\r\r\n        \r\r\n        ### `def parse(self, data)`\r\r\n        \r\r\n        parse a string(`data`) containing a date into a datetime object.\r\r\n        \r\r\n        ```\r\r\n        >>> date = date_format.parse(\"2017-06-03 15:32:00.2364-02:00\")\r\r\n        datetime.datetime(2017, 6, 3, 15, 32, 0, 236400, tzinfo=datetime.timezone(datetime.timedelta(-1, 79200)))\r\r\n        ```\r\r\n        \r\r\n        ### `def format(self, date)`\r\r\n        \r\r\n        format the passed in `datetime.datetime` object (`date`) as a string:\r\r\n        \r\r\n        ```\r\r\n        >>> print(date_format.format(date))\r\r\n        2017-06-03 15:32:00.2364-02:00\r\r\n        ```\r\r\n        \r\r\n        ## timezones\r\r\n        \r\r\n        if any part of the format provides a timezone, or utc offset, then parsing \r\r\n        produces dates with a timezone indicating the relevant utc offset.\r\r\n        \r\r\n        likewise, if a dateformat has a timezone part, then dates passed to `.format()`\r\r\n        must include a tzinfo value.\r\r\n        \r\r\n        if pytz is available, then some level of named timezone support is provided.\r\r\n        \r\r\n        ## leading zeros\r\r\n        \r\r\n        all numeric parts of the date format are zero-padded to the number of characters\r\r\n        in the spec.  i.e.  'dd' means that the day of the month is zero-padded to 2-digits.\r\r\n        \r\r\n        during parsing, a missing leading zero is usually ignored, but if there is no separator\r\r\n        between parts (for example:  yyyymmdd), then a missing leading zero will cause an error or bad value.\r\r\n        \r\r\n        currently, all formatted dates are zero-padded, in the future, this may be controllable.\r\r\n        \r\r\n        ## date format specification\r\r\n        | part | example | description |\r\r\n        |---------|---------|---------------|\r\r\n        | `+hhmm` | -0515 | a utc offset provided as a 2-digit hour, and 2-digit minute, with no separator |\r\r\n        | `+hh:mm` | -05:15 | a utc offset provided as a 2-digit hour, and 2-digit minute, with a ':' separator |\r\r\n        | `+hh` | -05 | a utc offset provided as a 2-digit hour only |\r\r\n        | `dddddd` | monday | the full locale-specific day of the week (note, this value is ignored during date parsing, but added during date format) |\r\r\n        | `ddd` | mon | the locale-specific short name for the day of the week (ignored during parsing) |\r\r\n        | `dd` | 05 | the zero-padded day of the month. |\r\r\n        | `mmmmm` | september | month as locale\u2019s full name |\r\r\n        | `mmm` | sep | month as locale\u2019s abbreviated name |\r\r\n        | `yyyy` | 2017 | year with century as a number |\r\r\n        | `yy` | 17 | year without century as a zero-padded number |\r\r\n        | `hh` | 09 | hour as a zero-padded number |\r\r\n        | `mm` | 06 | minute as a zero-padded number |\r\r\n        | `ss` | 45 | second as a zero-padded number |\r\r\n        | `ssssss` | 123456 | microsecond as a zero-padded decimal number |\r\r\n        | `ssss`   | 1234 | 100-microseconds as a zero-padded number |\r\r\n        | `sss` | 123 | milliseconds as a zero-padded number |\r\r\n        | `ss` | 12 | 10-milliseconds as a zero-padded number |\r\r\n        | `am` `am` `am` `pm` `pm` `pm` | am | either am or pm depending on the hour.  `.format()` matches the case of the spec.  if present, the dateformat will default to 12-hour mode |\r\r\n        | `of` | | ignored during parsing, added during formtting |\r\r\n        | `st` | th | the appropriate suffix for the day of the month, for example '1_st_ july', '2_nd_ march' |\r\r\n        | `\u2423` | t | (unicode open box - u+2423) matches either the character 't' or a space ' '.  during formatting, 't' is always used (this is provided to improve flexibility when parsing iso8601 formats) |\r\r\n        | space | | matches one or more spaces during parsing.  during formatting, one space will be output |\r\r\n        | any of `:/-.,tz()` | | ignored during parsing, output as-is during formatting |\r\r\n        \r\r\n        \r\r\n        # examples\r\r\n        \r\r\n        | format                   | example                |\r\r\n        |--------------------------|------------------------|\r\r\n        | `yyyy-mm-ddthh:mm:ss`    | 2017-06-06t09:45:15    |\r\r\n        | `yyyymmddhhmmss`         | 20170606094515         |\r\r\n        | `yyyymmddhhmmss.ssssssz` | 20170606094515.123456z |\r\r\n        | `mm/dd/yy hh:mm+hhmm`    | 06/06/17 09:45-0500    |\r\r\n        \r\r\n        \r\r\n        # library comparison\r\r\n        \r\r\n        ## dateformat \u21c4 datetime (builtin python module)\r\r\n        \r\r\n        dateformat is *not* trying to be a replacement for the builtin datetime module.  `datetime.datetime` objects are used as the input/output to the parsing and formatting methods.\r\r\n        \r\r\n        it is designed as a replacement for the  `datetime.datetime.strftime` and `datetime.datetime.strptime` methods, providing:\r\r\n        \r\r\n         * better timezone handling\r\r\n         * a simpler/more common syntax for specifying the date formats\r\r\n         * slightly faster parsing\r\r\n        \r\r\n        ## dateformat \u21c4 dateutil.parser.parse()\r\r\n        \r\r\n        `dateutil.parser.parse`'s intent is to turn a string in an unknown format into a date.  it does that by using a variety of heuristics to try to figure out the format the date has been expressed in.\r\r\n        \r\r\n        this approach is highly useful, and very flexible, but suffers from a couple of drawbacks that dateformat doesn't have:\r\r\n        \r\r\n         * there is ambiguity about what date will be produced from a given string, there are situations where that risk cannot be accepted, and it's important for the system to only accept a certain date format\r\r\n         * because of all the work that dateutil is doing to work out the format used, it's fairly slow, at just under 10x slower than `strptime`, this is very noticable over 10s - 100s thousands of dates.\r\r\n        \r\r\n        ## dateformat \u21c4 arrow\r\r\n        \r\r\n        arrow is the closest to the way dateformat works, the syntax for describing dates is very similar. unfortunately, arrow constructs its parser every time a date is parsed, creating a significant overhead when parsing each date.\r\r\n        \r\r\n        ## dateformat \u21c4 iso8601 / ciso8601\r\r\n        \r\r\n        ciso8601 is _really_ fast.  unfortunately both these libraries only handle a single date format, so are not useful in this situation.\r\r\n        \r\r\n        # benchmarks\r\r\n        \r\r\n        the `benchmark/` dir contains some simple scripts to show how the relative libraries perform at parsing and formatting dates.\r\r\n        \r\r\n        running on a 2016 macbook pro, on python 3.6.3 gave the following results (best of 3 runs):\r\r\n        \r\r\n        (please note, the parse time chart y-axis has been clamped to 1s, but dateparser took 16s to complete)\r\r\n        \r\r\n        ![chart showing relative date parse performance](https://github.com/stestagg/dateformat/raw/master/benchmark/parse_times.png)\r\r\n        \r\r\n        ![chart showing relative date format performance](https://github.com/stestagg/dateformat/raw/master/benchmark/format_times.png)\r\r\n        \r\r\n        \r\nkeywords: date time parsing formatting datetime\r\nplatform: unknown\r\nclassifier: development status :: 3 - alpha\r\nclassifier: intended audience :: developers\r\nclassifier: topic :: software development :: build tools\r\nclassifier: license :: osi approved :: mit license\r\nclassifier: programming language :: python :: 3\r\nclassifier: programming language :: python :: 3.3\r\nclassifier: programming language :: python :: 3.4\r\nclassifier: programming language :: python :: 3.5\r\nprovides-extra: test\r\n",
  "docs_url": null,
  "keywords": "",
  "license": "mit",
  "name": "dateformat",
  "package_url": "https://pypi.org/project/dateformat/",
  "project_url": "https://pypi.org/project/dateformat/",
  "project_urls": {
    "Homepage": "https://github.com/stestagg/dateformat"
  },
  "release_url": "https://pypi.org/project/dateformat/0.9.7/",
  "requires_dist": [],
  "requires_python": "",
  "summary": "parse and format dates quickly",
  "version": "0.9.7",
  "releases": [],
  "developers": [
    "ste@sta.gg",
    "stephen_stagg"
  ],
  "kwds": "dateformat date_format dateparser format_times dateutil",
  "license_kwds": "mit",
  "libtype": "pypi",
  "id": "pypi_dateformat",
  "homepage": "https://github.com/stestagg/dateformat",
  "release_count": 8,
  "dependency_ids": []
}