{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: zope public license",
    "operating system :: os independent",
    "programming language :: python",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.7",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: python :: implementation :: cpython",
    "programming language :: python :: implementation :: pypy",
    "topic :: internet :: www/http",
    "topic :: software development"
  ],
  "description": "===========================\n ``zope.cachedescriptors``\n===========================\n\n.. image:: https://img.shields.io/pypi/v/zope.cachedescriptors.svg\n        :target: https://pypi.org/project/zope.cachedescriptors/\n        :alt: latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/zope.cachedescriptors.svg\n        :target: https://pypi.org/project/zope.cachedescriptors/\n        :alt: supported python versions\n\n.. image:: https://github.com/zopefoundation/zope.cachedescriptors/actions/workflows/tests.yml/badge.svg\n        :target: https://github.com/zopefoundation/zope.cachedescriptors/actions/workflows/tests.yml\n\n.. image:: https://readthedocs.org/projects/zopehookable/badge/?version=latest\n        :target: http://zopehookable.readthedocs.io/en/latest/\n        :alt: documentation status\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/zope.cachedescriptors/badge.svg?branch=master\n        :target: https://coveralls.io/github/zopefoundation/zope.cachedescriptors?branch=master\n\ncached descriptors cache their output.  they take into account\ninstance attributes that they depend on, so when the instance\nattributes change, the descriptors will change the values they\nreturn.\n\ncached descriptors cache their data in ``_v_`` attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects.\n\npersistent descriptors:\n\n- ``property``\n\n  a simple computed property.\n\n  see ``src/zope/cachedescriptors/property.rst``.\n\n- ``method``\n\n  idempotent method.  the return values are cached based on method\n  arguments and on any instance attributes that the methods are\n  defined to depend on.\n\n  .. note::\n\n     only a cache based on arguments has been implemented so far.\n\n  see ``src/zope/cachedescriptors/method.rst``.\n\n===================\n cached properties\n===================\n\ncached properties are computed properties that cache their computed\nvalues.  they take into account instance attributes that they depend\non, so when the instance attributes change, the properties will change\nthe values they return.\n\ncachedproperty\n==============\n\ncached properties cache their data in ``_v_`` attributes, so they are\nalso useful for managing the computation of volatile attributes for\npersistent objects. let's look at an example:\n\n    >>> from zope.cachedescriptors import property\n    >>> import math\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedproperty('x', 'y')\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = point(1.0, 2.0)\n\nif we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nwe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nthe function isn't called.  if we change one of the attribute the\nradius depends on, it will be recomputed:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\nbut changing other attributes doesn't cause recomputation:\n\n    >>> point.q = 1\n    >>> '%.2f' % point.radius\n    '2.83'\n\nnote that we don't have any non-volitile attributes added:\n\n    >>> names = [name for name in point.__dict__ if not name.startswith('_v_')]\n    >>> names.sort()\n    >>> names\n    ['q', 'x', 'y']\n\nfor backwards compatibility, the same thing can alternately be written\nwithout using decorator syntax:\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n    ...     radius = property.cachedproperty(radius, 'x', 'y')\n\n    >>> point = point(1.0, 2.0)\n\nif we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nwe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nthe function isn't called.  if we change one of the attribute the\nradius depends on, it will be recomputed:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\ndocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. this allows sphinx to extract the documentation.\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedproperty('x', 'y')\n    ...     def radius(self):\n    ...         '''the length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(point.radius.__doc__)\n    the length of the line between self.x and self.y\n    >>> print(point.radius.__name__)\n    radius\n\nit is possible to specify a cachedproperty that has no dependencies.\nfor backwards compatibility this can be written in a few different ways::\n\n    >>> class point:\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedproperty\n    ...     def no_deps_no_parens(self):\n    ...         print(\"no deps, no parens\")\n    ...         return 1\n    ...\n    ...     @property.cachedproperty()\n    ...     def no_deps(self):\n    ...         print(\"no deps\")\n    ...         return 2\n    ...\n    ...     def no_deps_old_style(self):\n    ...         print(\"no deps, old style\")\n    ...         return 3\n    ...     no_deps_old_style = property.cachedproperty(no_deps_old_style)\n\n\n    >>> point = point(1.0, 2.0)\n    >>> point.no_deps_no_parens\n    no deps, no parens\n    1\n    >>> point.no_deps_no_parens\n    1\n    >>> point.no_deps\n    no deps\n    2\n    >>> point.no_deps\n    2\n    >>> point.no_deps_old_style\n    no deps, old style\n    3\n    >>> point.no_deps_old_style\n    3\n\n\nlazy computed attributes\n========================\n\nthe `property` module provides another descriptor that supports a\nslightly different caching model: lazy attributes.  like cached\nproprties, they are computed the first time they are used. however,\nthey aren't stored in volatile attributes and they aren't\nautomatically updated when other attributes change.  furthermore, the\nstore their data using their attribute name, thus overriding\nthemselves. this provides much faster attribute access after the\nattribute has been computed. let's look at the previous example using\nlazy attributes:\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.lazy\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = point(1.0, 2.0)\n\nif we ask for the radius the first time:\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nwe see that the radius function is called, but if we ask for it again:\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nthe function isn't called.  if we change one of the attribute the\nradius depends on, it still isn't called:\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    '2.24'\n\nif we want the radius to be recomputed, we have to manually delete it:\n\n    >>> del point.radius\n\n    >>> point.x = 2.0\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.83'\n\nnote that the radius is stored in the instance dictionary:\n\n    >>> '%.2f' % point.__dict__['radius']\n    '2.83'\n\nthe lazy attribute needs to know the attribute name.  it normally\ndeduces the attribute name from the name of the function passed. if we\nwant to use a different name, we need to pass it:\n\n    >>> def d(point):\n    ...     print('computing diameter')\n    ...     return 2*point.radius\n\n    >>> point.diameter = property.lazy(d, 'diameter')\n    >>> '%.2f' % point.diameter\n    computing diameter\n    '5.66'\n\ndocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. this allows sphinx to extract the documentation.\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.lazy\n    ...     def radius(self):\n    ...         '''the length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(point.radius.__doc__)\n    the length of the line between self.x and self.y\n    >>> print(point.radius.__name__)\n    radius\n\nthe documentation of the attribute when accessed through the\ninstance will be the same as the return-value:\n\n   >>> p = point(1.0, 2.0)\n   >>> p.radius.__doc__ == float.__doc__\n   computing radius\n   true\n\nthis is the same behaviour as the standard python ``property``\ndecorator.\n\nreadproperty\n============\n\nreadproperties are like lazy computed attributes except that the\nattribute isn't set by the property:\n\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.readproperty\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = point(1.0, 2.0)\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\nbut you *can* replace the property by setting a value. this is the major\ndifference to the builtin `property`:\n\n    >>> point.radius = 5\n    >>> point.radius\n    5\n\ndocumentation and the ``__name__`` are preserved if the attribute is accessed through\nthe class. this allows sphinx to extract the documentation.\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.readproperty\n    ...     def radius(self):\n    ...         '''the length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(point.radius.__doc__)\n    the length of the line between self.x and self.y\n    >>> print(point.radius.__name__)\n    radius\n\ncachedin\n========\n\nthe `cachedin` property allows to specify the attribute where to store the\ncomputed value:\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedin('_radius_attribute')\n    ...     def radius(self):\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> point = point(1.0, 2.0)\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\nthe radius is cached in the attribute with the given name, `_radius_attribute`\nin this case:\n\n    >>> '%.2f' % point._radius_attribute\n    '2.24'\n\nwhen the attribute is removed the radius is re-calculated once. this allows\ninvalidation:\n\n    >>> del point._radius_attribute\n\n    >>> '%.2f' % point.radius\n    computing radius\n    '2.24'\n\n    >>> '%.2f' % point.radius\n    '2.24'\n\ndocumentation is preserved if the attribute is accessed through\nthe class. this allows sphinx to extract the documentation.\n\n    >>> class point:\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @property.cachedin('_radius_attribute')\n    ...     def radius(self):\n    ...         '''the length of the line between self.x and self.y'''\n    ...         print('computing radius')\n    ...         return math.sqrt(self.x**2 + self.y**2)\n\n    >>> print(point.radius.__doc__)\n    the length of the line between self.x and self.y\n\n==============\n method cache\n==============\n\ncachedin\n========\n\nthe `cachedin` property allows to specify the attribute where to store the\ncomputed value:\n\n    >>> import math\n    >>> from zope.cachedescriptors import method\n\n    >>> class point(object):\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @method.cachedin('_cache')\n    ...     def distance(self, x, y):\n    ...         \"\"\"compute the distance\"\"\"\n    ...         print('computing distance')\n    ...         return math.hypot(self.x - x, self.y - y)\n    ...\n    >>> point = point(1.0, 2.0)\n\nthe value is computed once:\n\n    >>> point.distance(2, 2)\n    computing distance\n    1.0\n    >>> point.distance(2, 2)\n    1.0\n\n\nusing different arguments calculates a new distance:\n\n    >>> point.distance(5, 2)\n    computing distance\n    4.0\n    >>> point.distance(5, 2)\n    4.0\n\n\nthe data is stored at the given `_cache` attribute:\n\n    >>> isinstance(point._cache, dict)\n    true\n\n    >>> sorted(point._cache.items())\n    [(((2, 2), ()), 1.0), (((5, 2), ()), 4.0)]\n\n\nit is possible to exlicitly invalidate the data:\n\n    >>> point.distance.invalidate(point, 5, 2)\n    >>> point.distance(5, 2)\n    computing distance\n    4.0\n\ninvalidating keys which are not in the cache, does not result in an error:\n\n    >>> point.distance.invalidate(point, 47, 11)\n\nthe documentation of the function is preserved (whether through the\ninstance or the class), allowing sphinx to extract it::\n\n    >>> print(point.distance.__doc__)\n    compute the distance\n    >>> print(point.distance.__name__)\n    distance\n\n    >>> print(point.distance.__doc__)\n    compute the distance\n    >>> print(point.distance.__name__)\n    distance\n\nit is possible to pass in a factory for the cache attribute. create another\npoint class:\n\n\n    >>> class mydict(dict):\n    ...     pass\n    >>> class point(object):\n    ...\n    ...     def __init__(self, x, y):\n    ...         self.x, self.y = x, y\n    ...\n    ...     @method.cachedin('_cache', mydict)\n    ...     def distance(self, x, y):\n    ...         print('computing distance')\n    ...         return math.sqrt((self.x - x)**2 + (self.y - y)**2)\n    ...\n    >>> point = point(1.0, 2.0)\n    >>> point.distance(2, 2)\n    computing distance\n    1.0\n\nnow the cache is a mydict instance:\n\n    >>> isinstance(point._cache, mydict)\n    true\n\n=========\n changes\n=========\n\n5.0 (2023-03-27)\n================\n\n- add support for python 3.11.\n\n- drop support for python 2.7, 3.5, 3.6.\n\n\n4.4 (2022-09-07)\n================\n\n- drop support for python 3.4.\n\n- add support for python 3.7, 3.8, 3.9, 3.10.\n\n\n4.3.1 (2017-12-09)\n==================\n\n- fix test which will break in the upcoming python 3.7 release.\n\n\n4.3.0 (2017-07-27)\n==================\n\n- add support for python 3.6.\n\n- drop support for python 3.3.\n\n\n4.2.0 (2016-09-05)\n==================\n\n- add support for python 3.5.\n\n- drop support for python 2.6 and 3.2.\n\n- the properties from the ``property`` module all preserve the\n  documentation string of the underlying function, and all except\n  ``cachedin`` preserve everything that ``functools.update_wrapper``\n  preserves.\n\n- ``property.cachedproperty`` is usable as a decorator, with or\n  without dependent attribute names.\n\n- ``method.cachedin`` preserves the documentation string of the\n  underlying function, and everything else that ``functools.wraps`` preserves.\n\n4.1.0 (2014-12-26)\n==================\n\n- add support for pypy and pypy3.\n\n- add support for python 3.4.\n\n- add support for testing on travis.\n\n\n4.0.0 (2013-02-13)\n==================\n\n- drop support for python 2.4 and 2.5.\n\n- add support for python 3.2 and 3.3.\n\n\n3.5.1 (2010-04-30)\n==================\n\n- remove undeclared testing dependency on zope.testing.\n\n3.5.0 (2009-02-10)\n==================\n\n- remove dependency on zodb by allowing to specify storage factory for\n  ``zope.cachedescriptors.method.cachedin`` which is now ``dict`` by default.\n  if you need to use btree instead, you must pass it as ``factory`` argument\n  to the ``zope.cachedescriptors.method.cachedin`` decorator.\n\n- remove zpkg-related file.\n\n- clean up package description and documentation a bit.\n\n- change package mailing list address to zope-dev at zope.org, as\n  zope3-dev at zope.org is now retired.\n\n3.4.0 (2007-08-30)\n==================\n\ninitial release as an independent package\n",
  "docs_url": null,
  "keywords": "persistent caching decorator method property",
  "license": "zpl 2.1",
  "name": "zope.cachedescriptors",
  "package_url": "https://pypi.org/project/zope.cachedescriptors/",
  "project_url": "https://pypi.org/project/zope.cachedescriptors/",
  "project_urls": {
    "Homepage": "http://github.com/zopefoundation/zope.cachedescriptors"
  },
  "release_url": "https://pypi.org/project/zope.cachedescriptors/5.0/",
  "requires_dist": [
    "setuptools"
  ],
  "requires_python": ">=3.7",
  "summary": "method and property caching decorators",
  "version": "5.0",
  "releases": [],
  "developers": [
    "zope-dev@zope.dev",
    "zope_foundation_and_contributors"
  ],
  "kwds": "cachedescriptors _cache cachedproperty cache caching",
  "license_kwds": "zpl 2.1",
  "libtype": "pypi",
  "id": "pypi_zope.cachedescriptors",
  "homepage": "http://github.com/zopefoundation/zope.cachedescriptors",
  "release_count": 13,
  "dependency_ids": [
    "pypi_setuptools"
  ]
}