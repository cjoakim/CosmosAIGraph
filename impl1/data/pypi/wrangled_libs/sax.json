{
  "classifiers": [
    "development status :: 3 - alpha",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "operating system :: os independent",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.9",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: physics"
  ],
  "description": "# sax\n\n> s + autograd + xla\n\n![sax logo](docs/source/_static/img/logo.svg)\n\nautograd and xla for s-parameters - a scatter parameter circuit simulator and\noptimizer for the frequency domain based on [jax](https://github.com/google/jax).\n\nthe simulator was developed for simulating photonic integrated circuits but in fact is\nable to perform any s-parameter based circuit simulation. the goal of sax is to be a\nthin wrapper around jax with some basic tools for s-parameter based circuit simulation\nand optimization. therefore, sax does not define any special datastructures and tries to\nstay as close as possible to the functional nature of jax. this makes it very easy to\nget started with sax as you only need functions and standard python dictionaries. let's\ndive in...\n\n## quick start\n\n[full quick start page](https://flaport.github.io/sax/examples/01_quick_start.html) -\n[documentation](https://flaport.github.io/sax).\n\nlet's first import the sax library, along with jax and the jax-version of numpy:\n\n```python\nimport sax\nimport jax\nimport jax.numpy as jnp\n```\n\ndefine a model function for your component. a sax model is just a function that returns\nan 's-dictionary'. for example a directional coupler:\n\n```python\ndef coupler(coupling=0.5):\n    kappa = coupling**0.5\n    tau = (1-coupling)**0.5\n    sdict = sax.reciprocal({\n        (\"in0\", \"out0\"): tau,\n        (\"in0\", \"out1\"): 1j*kappa,\n        (\"in1\", \"out0\"): 1j*kappa,\n        (\"in1\", \"out1\"): tau,\n    })\n    return sdict\n\ncoupler(coupling=0.3)\n```\n\n    {('in0', 'out0'): 0.8366600265340756,\n     ('in0', 'out1'): 0.5477225575051661j,\n     ('in1', 'out0'): 0.5477225575051661j,\n     ('in1', 'out1'): 0.8366600265340756,\n     ('out0', 'in0'): 0.8366600265340756,\n     ('out1', 'in0'): 0.5477225575051661j,\n     ('out0', 'in1'): 0.5477225575051661j,\n     ('out1', 'in1'): 0.8366600265340756}\n\nor a waveguide:\n\n```python\ndef waveguide(wl=1.55, wl0=1.55, neff=2.34, ng=3.4, length=10.0, loss=0.0):\n    dwl = wl - wl0\n    dneff_dwl = (ng - neff) / wl0\n    neff = neff - dwl * dneff_dwl\n    phase = 2 * jnp.pi * neff * length / wl\n    amplitude = jnp.asarray(10 ** (-loss * length / 20), dtype=complex)\n    transmission =  amplitude * jnp.exp(1j * phase)\n    sdict = sax.reciprocal({(\"in0\", \"out0\"): transmission})\n    return sdict\n\nwaveguide(length=100.0)\n```\n\n    {('in0', 'out0'): 0.97953-0.2013j, ('out0', 'in0'): 0.97953-0.2013j}\n\nthese component models can then be combined into a circuit:\n\n```python\nmzi, _ = sax.circuit(\n    netlist={\n        \"instances\": {\n            \"lft\": coupler,\n            \"top\": waveguide,\n            \"rgt\": coupler,\n        },\n        \"connections\": {\n            \"lft,out0\": \"rgt,in0\",\n            \"lft,out1\": \"top,in0\",\n            \"top,out0\": \"rgt,in1\",\n        },\n        \"ports\": {\n            \"in0\": \"lft,in0\",\n            \"in1\": \"lft,in1\",\n            \"out0\": \"rgt,out0\",\n            \"out1\": \"rgt,out1\",\n        },\n    }\n)\n\ntype(mzi)\n```\n\n    function\n\nas you can see, the mzi we just created is just another component model function! to simulate it, call the mzi function with the (possibly nested) settings of its subcomponents. global settings can be added to the 'root' of the circuit call and will be distributed over all subcomponents which have a parameter with the same name (e.g. 'wl'):\n\n```python\nwl = jnp.linspace(1.53, 1.57, 1000)\nresult = mzi(wl=wl, lft={'coupling': 0.3}, top={'length': 200.0}, rgt={'coupling': 0.8})\n\nplt.plot(1e3*wl, jnp.abs(result['in0', 'out0'])**2, label=\"in0->out0\")\nplt.plot(1e3*wl, jnp.abs(result['in0', 'out1'])**2, label=\"in0->out1\", ls=\"--\")\nplt.xlabel(\"\u03bb [nm]\")\nplt.ylabel(\"t\")\nplt.grid(true)\nplt.figlegend(ncol=2, loc=\"upper center\")\nplt.show()\n```\n\n![output](docs/source/_static/img/output_10_0.png)\n\nthose are the basics. for more info, check out the **full**\n[sax quick start page](https://flaport.github.io/sax/examples/01_quick_start.html) or the rest of the [documentation](https://flaport.github.io/sax).\n\n## installation\n\nyou can install sax with pip:\n\n```sh\npip install sax\n```\n\nif you want to be able to run all the example notebooks, you'll need python>=3.10 and\nyou should install the development version of sax:\n\n```sh\npip install 'sax[dev]'\n```\n\n## license\n\ncopyright \u00a9 2023, floris laporte, [apache-2.0 license](https://github.com/flaport/sax/blob/master/license)\n",
  "docs_url": null,
  "keywords": "",
  "license": "",
  "name": "sax",
  "package_url": "https://pypi.org/project/sax/",
  "project_url": "https://pypi.org/project/sax/",
  "project_urls": null,
  "release_url": "https://pypi.org/project/sax/0.10.4/",
  "requires_dist": [
    "black",
    "fastcore",
    "flax",
    "jax",
    "jaxlib",
    "jaxtyping",
    "klujax >=0.2.3",
    "matplotlib",
    "natsort",
    "networkx",
    "numpy",
    "orjson",
    "pydantic",
    "pyyaml",
    "tqdm",
    "autodoc-pydantic ; extra == 'dev'",
    "autograd ; extra == 'dev'",
    "autoimport ; extra == 'dev'",
    "black[jupyter] ; extra == 'dev'",
    "bump2version ; extra == 'dev'",
    "flake8 ; extra == 'dev'",
    "gdsfactory >=0.7.4 ; extra == 'dev'",
    "gplugins ; extra == 'dev'",
    "ipyevents ; extra == 'dev'",
    "ipykernel ; extra == 'dev'",
    "ipympl ; extra == 'dev'",
    "ipywidgets ; extra == 'dev'",
    "isort ; extra == 'dev'",
    "jedi ; extra == 'dev'",
    "myst-nb ; extra == 'dev'",
    "nbstripout ; extra == 'dev'",
    "nlopt ; extra == 'dev'",
    "papermill ; extra == 'dev'",
    "pre-commit ; extra == 'dev'",
    "pytest ; extra == 'dev'",
    "sphinx-book-theme ==1.0.1 ; extra == 'dev'",
    "sphinx-copybutton ==0.5.2 ; extra == 'dev'",
    "sphinx ==5.3.0 ; extra == 'dev'",
    "tmm ; extra == 'dev'"
  ],
  "requires_python": ">=3.9.0",
  "summary": "autograd and xla for s-parameters",
  "version": "0.10.4",
  "releases": [],
  "developers": [
    "floris.laporte@rockleyphotonics.com"
  ],
  "kwds": "jax sax xla photonic simulation",
  "license_kwds": "",
  "libtype": "pypi",
  "id": "pypi_sax",
  "homepage": "",
  "release_count": 36,
  "dependency_ids": [
    "pypi_autodoc_pydantic",
    "pypi_autograd",
    "pypi_autoimport",
    "pypi_black",
    "pypi_bump2version",
    "pypi_fastcore",
    "pypi_flake8",
    "pypi_flax",
    "pypi_gdsfactory",
    "pypi_gplugins",
    "pypi_ipyevents",
    "pypi_ipykernel",
    "pypi_ipympl",
    "pypi_ipywidgets",
    "pypi_isort",
    "pypi_jax",
    "pypi_jaxlib",
    "pypi_jaxtyping",
    "pypi_jedi",
    "pypi_klujax",
    "pypi_matplotlib",
    "pypi_myst_nb",
    "pypi_natsort",
    "pypi_nbstripout",
    "pypi_networkx",
    "pypi_nlopt",
    "pypi_numpy",
    "pypi_orjson",
    "pypi_papermill",
    "pypi_pre_commit",
    "pypi_pydantic",
    "pypi_pytest",
    "pypi_pyyaml",
    "pypi_sphinx",
    "pypi_sphinx_book_theme",
    "pypi_sphinx_copybutton",
    "pypi_tmm",
    "pypi_tqdm"
  ]
}