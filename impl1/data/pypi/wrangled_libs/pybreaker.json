{
  "classifiers": [
    "development status :: 5 - production/stable",
    "intended audience :: developers",
    "license :: osi approved :: bsd license",
    "programming language :: python",
    "programming language :: python :: 3",
    "topic :: software development :: libraries"
  ],
  "description": "\npybreaker\n=========\n\npybreaker is a python implementation of the circuit breaker pattern, described\nin michael t. nygard's book `release it!`_.\n\nin nygard's words, *\"circuit breakers exists to allow one subsystem to fail\nwithout destroying the entire system. this is done by wrapping dangerous\noperations (typically integration points) with a component that can circumvent\ncalls when the system is not healthy\"*.\n\n\nfeatures\n--------\n\n* configurable list of excluded exceptions (e.g. business exceptions)\n* configurable failure threshold and reset timeout\n* support for several event listeners per circuit breaker\n* can guard generator functions\n* functions and properties for easy monitoring and management\n* thread-safe\n* optional redis backing\n* optional support for asynchronous tornado calls\n\n\nrequirements\n------------\n\n* `python`_ 3.7+\n\n\ninstallation\n------------\n\nrun the following command line to download the latest stable version of\npybreaker from `pypi`_::\n\n    $ pip install pybreaker\n\nif you are a `git`_ user, you might want to download the current development\nversion::\n\n    $ git clone git://github.com/danielfm/pybreaker.git\n    $ cd pybreaker\n    $ python setup.py test\n    $ python setup.py install\n\n\nusage\n-----\n\nthe first step is to create an instance of ``circuitbreaker`` for each\nintegration point you want to protect against:\n\n.. code:: python\n\n    import pybreaker\n\n    # used in database integration points\n    db_breaker = pybreaker.circuitbreaker(fail_max=5, reset_timeout=60)\n\n\n``circuitbreaker`` instances should live globally inside the application scope,\ne.g., live across requests.\n\n.. note::\n\n  integration points to external services (i.e. databases, queues, etc) are\n  more likely to fail, so make sure to always use timeouts when accessing such\n  services if there's support at the api level.\n\nif you'd like to use the redis backing, initialize the ``circuitbreaker`` with\na ``circuitredisstorage``:\n\n.. code:: python\n\n    import pybreaker\n    import redis\n\n    redis = redis.strictredis()\n    db_breaker = pybreaker.circuitbreaker(\n        fail_max=5,\n        reset_timeout=60,\n        state_storage=pybreaker.circuitredisstorage(pybreaker.state_closed, redis))\n\n**do not** initialize the redis connection with the ``decode_responses`` set to\n``true``, this will force returning ascii objects from redis and in python3+ will\nfail with:\n\n    `attributeerror: 'str' object has no attribute 'decode'`\n\n\n.. note::\n\n  you may want to reuse a connection already created in your application, if you're\n  using ``django_redis`` for example:\n\n.. code:: python\n\n    import pybreaker\n    from django_redis import get_redis_connection\n\n    db_breaker = pybreaker.circuitbreaker(\n        fail_max=5,\n        reset_timeout=60,\n        state_storage=pybreaker.circuitredisstorage(pybreaker.state_closed, get_redis_connection('default')))\n\n\nevent listening\n```````````````\n\nthere's no need to subclass ``circuitbreaker`` if you just want to take action\nwhen certain events occur. in that case, it's better to subclass\n``circuitbreakerlistener`` instead:\n\n.. code:: python\n\n    class dblistener(pybreaker.circuitbreakerlistener):\n        \"listener used by circuit breakers that execute database operations.\"\n\n        def before_call(self, cb, func, *args, **kwargs):\n            \"called before the circuit breaker `cb` calls `func`.\"\n            pass\n\n        def state_change(self, cb, old_state, new_state):\n            \"called when the circuit breaker `cb` state changes.\"\n            pass\n\n        def failure(self, cb, exc):\n            \"called when a function invocation raises a system error.\"\n            pass\n\n        def success(self, cb):\n            \"called when a function invocation succeeds.\"\n            pass\n\n    class loglistener(pybreaker.circuitbreakerlistener):\n        \"listener used to log circuit breaker events.\"\n\n        def state_change(self, cb, old_state, new_state):\n            msg = \"state change: cb: {0}, new state: {1}\".format(cb.name, new_state)\n            logging.info(msg)\n\n\nto add listeners to a circuit breaker:\n\n.. code:: python\n\n    # at creation time...\n    db_breaker = pybreaker.circuitbreaker(listeners=[dblistener(), loglistener()])\n\n    # ...or later\n    db_breaker.add_listeners(onelistener(), anotherlistener())\n\n\nwhat does a circuit breaker do?\n```````````````````````````````\n\nlet's say you want to use a circuit breaker on a function that updates a row\nin the ``customer`` database table:\n\n.. code:: python\n\n    @db_breaker\n    def update_customer(cust):\n        # do stuff here...\n        pass\n\n    # will trigger the circuit breaker\n    updated_customer = update_customer(my_customer)\n\n\nor if you don't want to use the decorator syntax:\n\n.. code:: python\n\n    def update_customer(cust):\n        # do stuff here...\n        pass\n\n    # will trigger the circuit breaker\n    updated_customer = db_breaker.call(update_customer, my_customer)\n\n\naccording to the default parameters, the circuit breaker ``db_breaker`` will\nautomatically open the circuit after 5 consecutive failures in\n``update_customer``.\n\nwhen the circuit is open, all calls to ``update_customer`` will fail immediately\n(raising ``circuitbreakererror``) without any attempt to execute the real\noperation. if you want the original error to be thrown when the circuit trips,\nset the ``throw_new_error_on_trip`` option to ``false``:\n\n.. code:: python\n\n    pybreaker.circuitbreaker(..., throw_new_error_on_trip=false)\n\n\nafter 60 seconds, the circuit breaker will allow the next call to\n``update_customer`` pass through. if that call succeeds, the circuit is closed;\nif it fails, however, the circuit is opened again until another timeout elapses.\n\noptional tornado support\n````````````````````````\na circuit breaker can (optionally) be used to call asynchronous tornado functions:\n\n.. code:: python\n\n    from tornado import gen\n\n    @db_breaker(__pybreaker_call_async=true)\n    @gen.coroutine\n    def async_update(cust):\n        # do async stuff here...\n        pass\n\nor if you don't want to use the decorator syntax:\n\n.. code:: python\n\n    @gen.coroutine\n    def async_update(cust):\n        # do async stuff here...\n        pass\n\n    updated_customer = db_breaker.call_async(async_update, my_customer)\n\n\nexcluding exceptions\n````````````````````\n\nby default, a failed call is any call that raises an exception. however, it's\ncommon to raise exceptions to also indicate business exceptions, and those\nexceptions should be ignored by the circuit breaker as they don't indicate\nsystem errors:\n\n.. code:: python\n\n    # at creation time...\n    db_breaker = circuitbreaker(exclude=[customervalidationerror])\n\n    # ...or later\n    db_breaker.add_excluded_exception(customervalidationerror)\n\n\nin that case, when any function guarded by that circuit breaker raises\n``customervalidationerror`` (or any exception derived from\n``customervalidationerror``), that call won't be considered a system failure.\n\nso as to cover cases where the exception class alone is not enough to determine\nwhether it represents a system error, you may also pass a callable rather than\na type:\n\n.. code:: python\n\n    db_breaker = circuitbreaker(exclude=[lambda e: type(e) == httperror and e.status_code < 500])\n\nyou may mix types and filter callables freely.\n\n\nmonitoring and management\n`````````````````````````\n\na circuit breaker provides properties and functions you can use to monitor and\nchange its current state:\n\n.. code:: python\n\n    # get the current number of consecutive failures\n    print(db_breaker.fail_counter)\n\n    # get/set the maximum number of consecutive failures\n    print(db_breaker.fail_max)\n    db_breaker.fail_max = 10\n\n    # get/set the current reset timeout period (in seconds)\n    print db_breaker.reset_timeout\n    db_breaker.reset_timeout = 60\n\n    # get the current state, i.e., 'open', 'half-open', 'closed'\n    print(db_breaker.current_state)\n\n    # closes the circuit\n    db_breaker.close()\n\n    # half-opens the circuit\n    db_breaker.half_open()\n\n    # opens the circuit\n    db_breaker.open()\n\n\nthese properties and functions might and should be exposed to the operations\nstaff somehow as they help them to detect problems in the system.\n\n\n.. _python: http://python.org\n.. _jython: http://jython.org\n.. _release it!: https://pragprog.com/titles/mnee2/release-it-second-edition/\n.. _pypi: http://pypi.python.org\n.. _git: http://git-scm.com\n",
  "docs_url": null,
  "keywords": "design,pattern,circuit,breaker,integration",
  "license": "bsd",
  "name": "pybreaker",
  "package_url": "https://pypi.org/project/pybreaker/",
  "project_url": "https://pypi.org/project/pybreaker/",
  "project_urls": {
    "Homepage": "http://github.com/danielfm/pybreaker"
  },
  "release_url": "https://pypi.org/project/pybreaker/1.0.3/",
  "requires_dist": [
    "typing-extensions >=3.10.0 ; python_version < \"3.8\""
  ],
  "requires_python": ">=3.7",
  "summary": "python implementation of the circuit breaker pattern",
  "version": "1.0.3",
  "releases": [],
  "developers": [
    "daniel.tritone@gmail.com",
    "daniel_fernandes_martins"
  ],
  "kwds": "pybreaker __pybreaker_call_async circuitbreaker breaker circuitbreakererror",
  "license_kwds": "bsd",
  "libtype": "pypi",
  "id": "pypi_pybreaker",
  "homepage": "http://github.com/danielfm/pybreaker",
  "release_count": 22,
  "dependency_ids": [
    "pypi_typing_extensions"
  ]
}