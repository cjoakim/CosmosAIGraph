{
  "classifiers": [
    "development status :: 5 - production/stable",
    "environment :: console",
    "intended audience :: developers",
    "intended audience :: education",
    "intended audience :: science/research",
    "license :: osi approved :: apache software license",
    "license :: other/proprietary license",
    "operating system :: os independent",
    "programming language :: python :: 3",
    "programming language :: python :: 3.10",
    "programming language :: python :: 3.11",
    "programming language :: python :: 3.12",
    "programming language :: python :: 3.8",
    "programming language :: python :: 3.9",
    "programming language :: unix shell",
    "topic :: database :: database engines/servers",
    "topic :: internet :: www/http :: indexing/search",
    "topic :: multimedia :: video",
    "topic :: scientific/engineering",
    "topic :: scientific/engineering :: artificial intelligence",
    "topic :: scientific/engineering :: image recognition",
    "topic :: scientific/engineering :: mathematics",
    "topic :: software development",
    "topic :: software development :: libraries",
    "topic :: software development :: libraries :: python modules"
  ],
  "description": "<p align=\"center\">\n<img src=\"https://github.com/docarray/docarray/blob/main/docs/assets/logo-dark.svg?raw=true\" alt=\"docarray logo: the data structure for unstructured data\" width=\"150px\">\n<br>\n<b>the data structure for multimodal data</b>\n</p>\n\n<p align=center>\n<a href=\"https://pypi.org/project/docarray/\"><img src=\"https://img.shields.io/pypi/v/docarray?style=flat-square&amp;label=release\" alt=\"pypi\"></a>\n<a href=\"https://bestpractices.coreinfrastructure.org/projects/6554\"><img src=\"https://bestpractices.coreinfrastructure.org/projects/6554/badge\"></a>\n<a href=\"https://codecov.io/gh/docarray/docarray\"><img alt=\"codecov branch\" src=\"https://img.shields.io/codecov/c/github/docarray/docarray/main?&logo=codecov&logocolor=white&style=flat-square\"></a>\n<a href=\"https://pypistats.org/packages/docarray\"><img alt=\"pypi - downloads from official pypistats\" src=\"https://img.shields.io/pypi/dm/docarray?style=flat-square\"></a>\n<a href=\"https://discord.gg/wamp6pvpgr\"><img src=\"https://dcbadge.vercel.app/api/server/wamp6pvpgr?theme=default-inverted&style=flat-square\"></a>\n</p>\n\n> **note**\n> the readme you're currently viewing is for docarray>0.30, which introduces some significant changes from docarray 0.21. if you wish to continue using the older docarray <=0.21, ensure you install it via `pip install docarray==0.21`. refer to its [codebase](https://github.com/docarray/docarray/tree/v0.21.0), [documentation](https://docarray.jina.ai), and [its hot-fixes branch](https://github.com/docarray/docarray/tree/docarray-v1-fixes) for more information.\n\n\ndocarray is a python library expertly crafted for the [representation](#represent), [transmission](#send), [storage](#store), and [retrieval](#retrieve) of multimodal data. tailored for the development of multimodal ai applications, its design guarantees seamless integration with the extensive python and machine learning ecosystems. as of january 2022, docarray is openly distributed under the [apache license 2.0](https://github.com/docarray/docarray/blob/main/license) and currently enjoys the status of a sandbox project within the [lf ai & data foundation](https://lfaidata.foundation/).\n\n\n\n- :fire: offers native support for **[numpy](https://github.com/numpy/numpy)**, **[pytorch](https://github.com/pytorch/pytorch)**, **[tensorflow](https://github.com/tensorflow/tensorflow)**, and **[jax](https://github.com/google/jax)**, catering specifically to **model training scenarios**.\n- :zap: based on **[pydantic](https://github.com/pydantic/pydantic)**, and instantly compatible with web and microservice frameworks like **[fastapi](https://github.com/tiangolo/fastapi/)** and **[jina](https://github.com/jina-ai/jina/)**.\n- :package: provides support for vector databases such as **[weaviate](https://weaviate.io/), [qdrant](https://qdrant.tech/), [elasticsearch](https://www.elastic.co/de/elasticsearch/), [redis](https://redis.io/)**, and **[hnswlib](https://github.com/nmslib/hnswlib)**.\n- :chains: allows data transmission as json over **http** or as **[protobuf](https://protobuf.dev/)** over **[grpc](https://grpc.io/)**.\n\n## installation\n\nto install docarray from the cli, run the following command:\n\n```shell\npip install -u docarray\n```\n\n> **note**\n> to use docarray <=0.21, make sure you install via `pip install docarray==0.21` and check out its [codebase](https://github.com/docarray/docarray/tree/v0.21.0) and [docs](https://docarray.jina.ai) and [its hot-fixes branch](https://github.com/docarray/docarray/tree/docarray-v1-fixes).\n\n## get started\nnew to docarray? depending on your use case and background, there are multiple ways to learn about docarray:\n \n- [coming from pure pytorch or tensorflow](#coming-from-pytorch)\n- [coming from pydantic](#coming-from-pydantic)\n- [coming from fastapi](#coming-from-fastapi)\n- [coming from jina](#coming-from-jina)\n- [coming from a vector database](#coming-from-a-vector-database)\n- [coming from langchain](#coming-from-langchain)\n\n\n## represent\n\ndocarray empowers you to **represent your data** in a manner that is inherently attuned to machine learning.\n\nthis is particularly beneficial for various scenarios:\n\n- :running: you are **training a model**: you're dealing with tensors of varying shapes and sizes, each signifying different elements. you desire a method to logically organize them.\n- :cloud: you are **serving a model**: let's say through fastapi, and you wish to define your api endpoints precisely.\n- :card_index_dividers: you are **parsing data**: perhaps for future deployment in your machine learning or data science projects.\n\n> :bulb: **familiar with pydantic?** you'll be pleased to learn\n> that docarray is not only constructed atop pydantic but also maintains complete compatibility with it!\n> furthermore, we have a [specific section](#coming-from-pydantic) dedicated to your needs!\n\nin essence, docarray facilitates data representation in a way that mirrors python dataclasses, with machine learning being an integral component:\n\n\n```python\nfrom docarray import basedoc\nfrom docarray.typing import torchtensor, imageurl\nimport torch\n\n\n# define your data model\nclass mydocument(basedoc):\n    description: str\n    image_url: imageurl  # could also be videourl, audiourl, etc.\n    image_tensor: torchtensor[1704, 2272, 3]  # you can express tensor shapes!\n\n\n# stack multiple documents in a document vector\nfrom docarray import docvec\n\nvec = docvec[mydocument](\n    [\n        mydocument(\n            description=\"a cat\",\n            image_url=\"https://example.com/cat.jpg\",\n            image_tensor=torch.rand(1704, 2272, 3),\n        ),\n    ]\n    * 10\n)\nprint(vec.image_tensor.shape)  # (10, 1704, 2272, 3)\n```\n\n<details markdown=\"1\">\n  <summary>click for more details</summary>\n\nlet's take a closer look at how you can represent your data with docarray:\n\n```python\nfrom docarray import basedoc\nfrom docarray.typing import torchtensor, imageurl\nfrom typing import optional\nimport torch\n\n\n# define your data model\nclass mydocument(basedoc):\n    description: str\n    image_url: imageurl  # could also be videourl, audiourl, etc.\n    image_tensor: optional[\n        torchtensor[1704, 2272, 3]\n    ] = none  # could also be ndarray or tensorflowtensor\n    embedding: optional[torchtensor] = none\n```\n\nso not only can you define the types of your data, you can even **specify the shape of your tensors!**\n\n```python\n# create a document\ndoc = mydocument(\n    description=\"this is a photo of a mountain\",\n    image_url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n)\n\n# load image tensor from url\ndoc.image_tensor = doc.image_url.load()\n\n\n# compute embedding with any model of your choice\ndef clip_image_encoder(image_tensor: torchtensor) -> torchtensor:  # dummy function\n    return torch.rand(512)\n\n\ndoc.embedding = clip_image_encoder(doc.image_tensor)\n\nprint(doc.embedding.shape)  # torch.size([512])\n```\n\n### compose nested documents\n\nof course, you can compose documents into a nested structure:\n\n```python\nfrom docarray import basedoc\nfrom docarray.documents import imagedoc, textdoc\nimport numpy as np\n\n\nclass multimodaldocument(basedoc):\n    image_doc: imagedoc\n    text_doc: textdoc\n\n\ndoc = multimodaldocument(\n    image_doc=imagedoc(tensor=np.zeros((3, 224, 224))), text_doc=textdoc(text='hi!')\n)\n```\n\nyou rarely work with a single data point at a time, especially in machine learning applications. that's why you can easily collect multiple `documents`:\n\n### collect multiple `documents`\n\nwhen building or interacting with an ml system, usually you want to process multiple documents (data points) at once.\n\ndocarray offers two data structures for this:\n\n- **`docvec`**: a vector of `documents`. all tensors in the documents are stacked into a single tensor. **perfect for batch processing and use inside of ml models**.\n- **`doclist`**: a list of `documents`. all tensors in the documents are kept as-is. **perfect for streaming, re-ranking, and shuffling of data**.\n\nlet's take a look at them, starting with `docvec`:\n\n```python\nfrom docarray import docvec, basedoc\nfrom docarray.typing import anytensor, imageurl\nimport numpy as np\n\n\nclass image(basedoc):\n    url: imageurl\n    tensor: anytensor  # this allows torch, numpy, and tensor flow tensors\n\n\nvec = docvec[image](  # the docvec is parametrized by your personal schema!\n    [\n        image(\n            url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n            tensor=np.zeros((3, 224, 224)),\n        )\n        for _ in range(100)\n    ]\n)\n``` \n\nin the code snippet above, `docvec` is **parametrized by the type of document** you want to use with it: `docvec[image]`.\n\nthis may look weird at first, but we're confident that you'll get used to it quickly!\nbesides, it lets us do some cool things, like having **bulk access to the fields that you defined** in your document:\n\n```python\ntensor = vec.tensor  # gets all the tensors in the docvec\nprint(tensor.shape)  # which are stacked up into a single tensor!\nprint(vec.url)  # you can bulk access any other field, too\n```\n\nthe second data structure, `doclist`, works in a similar way:\n\n```python\nfrom docarray import doclist\n\ndl = doclist[image](  # the doclist is parametrized by your personal schema!\n    [\n        image(\n            url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n            tensor=np.zeros((3, 224, 224)),\n        )\n        for _ in range(100)\n    ]\n)\n```\n\nyou can still bulk access the fields of your document:\n\n```python\ntensors = dl.tensor  # gets all the tensors in the doclist\nprint(type(tensors))  # as a list of tensors\nprint(dl.url)  # you can bulk access any other field, too\n```\n\nand you can insert, remove, and append documents to your `doclist`:\n\n```python\n# append\ndl.append(\n    image(\n        url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n        tensor=np.zeros((3, 224, 224)),\n    )\n)\n# delete\ndel dl[0]\n# insert\ndl.insert(\n    0,\n    image(\n        url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n        tensor=np.zeros((3, 224, 224)),\n    ),\n)\n```\n\nand you can seamlessly switch between `docvec` and `doclist`:\n\n```python\nvec_2 = dl.to_doc_vec()\nassert isinstance(vec_2, docvec)\n\ndl_2 = vec_2.to_doc_list()\nassert isinstance(dl_2, doclist)\n```\n\n</details>\n\n## send\n\ndocarray facilitates the **transmission of your data** in a manner inherently compatible with machine learning.\n\nthis includes native support for **protobuf and grpc**, along with **http** and serialization to json, jsonschema, base64, and bytes.\n\nthis feature proves beneficial for several scenarios:\n\n- :cloud: you are **serving a model**, perhaps through frameworks like **[jina](https://github.com/jina-ai/jina/)** or **[fastapi](https://github.com/tiangolo/fastapi/)**\n- :spider_web: you are **distributing your model** across multiple machines and need an efficient means of transmitting your data between nodes\n- :gear: you are architecting a **microservice** environment and require a method for data transmission between microservices\n\n> :bulb: **are you familiar with fastapi?** you'll be delighted to learn\n> that docarray maintains full compatibility with fastapi!\n> plus, we have a [dedicated section](#coming-from-fastapi) specifically for you!\n\nwhen it comes to data transmission, serialization is a crucial step. let's delve into how docarray streamlines this process:\n\n\n```python\nfrom docarray import basedoc\nfrom docarray.typing import imagetorchtensor\nimport torch\n\n\n# model your data\nclass mydocument(basedoc):\n    description: str\n    image: imagetorchtensor[3, 224, 224]\n\n\n# create a document\ndoc = mydocument(\n    description=\"this is a description\",\n    image=torch.zeros((3, 224, 224)),\n)\n\n# serialize it!\nproto = doc.to_protobuf()\nbytes_ = doc.to_bytes()\njson = doc.json()\n\n# deserialize it!\ndoc_2 = mydocument.from_protobuf(proto)\ndoc_4 = mydocument.from_bytes(bytes_)\ndoc_5 = mydocument.parse_raw(json)\n```\n\nof course, serialization is not all you need. so check out how docarray integrates with **[jina](https://github.com/jina-ai/jina/)** and **[fastapi](https://github.com/tiangolo/fastapi/)**.\n\n## store\n\nafter modeling and possibly distributing your data, you'll typically want to **store it** somewhere. that's where docarray steps in!\n\n**document stores** provide a seamless way to, as the name suggests, store your documents. be it locally or remotely, you can do it all through the same user interface:\n\n- :cd: **on disk**, as a file in your local filesystem\n- :bucket: on **[aws s3](https://aws.amazon.com/de/s3/)**\n- :cloud: on **[jina ai cloud](https://cloud.jina.ai/)**\n\nthe document store interface lets you push and pull documents to and from multiple data sources, all with the same user interface.\n\nfor example, let's see how that works with on-disk storage:\n\n```python\nfrom docarray import basedoc, doclist\n\n\nclass simpledoc(basedoc):\n    text: str\n\n\ndocs = doclist[simpledoc]([simpledoc(text=f'doc {i}') for i in range(8)])\ndocs.push('file://simple_docs')\n\ndocs_pull = doclist[simpledoc].pull('file://simple_docs')\n```\n\n## retrieve\n\n**document indexes** let you index your documents in a **vector database** for efficient similarity-based retrieval.\n\nthis is useful for:\n\n- :left_speech_bubble: augmenting **llms and chatbots** with domain knowledge ([retrieval augmented generation](https://arxiv.org/abs/2005.11401))\n- :mag: **neural search** applications\n- :bulb: **recommender systems**\n\ncurrently, document indexes support **[weaviate](https://weaviate.io/)**, **[qdrant](https://qdrant.tech/)**, **[elasticsearch](https://www.elastic.co/)**,  **[redis](https://redis.io/)**, and **[hnswlib](https://github.com/nmslib/hnswlib)**, with more to come!\n\nthe document index interface lets you index and retrieve documents from multiple vector databases, all with the same user interface.\n\nit supports ann vector search, text search, filtering, and hybrid search.\n\n```python\nfrom docarray import doclist, basedoc\nfrom docarray.index import hnswdocumentindex\nimport numpy as np\n\nfrom docarray.typing import imageurl, imagetensor, ndarray\n\n\nclass imagedoc(basedoc):\n    url: imageurl\n    tensor: imagetensor\n    embedding: ndarray[128]\n\n\n# create some data\ndl = doclist[imagedoc](\n    [\n        imagedoc(\n            url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n            tensor=np.zeros((3, 224, 224)),\n            embedding=np.random.random((128,)),\n        )\n        for _ in range(100)\n    ]\n)\n\n# create a document index\nindex = hnswdocumentindex[imagedoc](work_dir='/tmp/test_index')\n\n\n# index your data\nindex.index(dl)\n\n# find similar documents\nquery = dl[0]\nresults, scores = index.find(query, limit=10, search_field='embedding')\n```\n\n---\n\n## learn docarray\n\ndepending on your background and use case, there are different ways for you to understand docarray.\n\n### coming from docarray <=0.21\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nif you are using docarray version 0.30.0 or lower, you will be familiar with its [dataclass api](https://docarray.jina.ai/fundamentals/dataclass/).\n\n_docarray >=0.30 is that idea, taken seriously._ every document is created through a dataclass-like interface,\ncourtesy of [pydantic](https://pydantic-docs.helpmanual.io/usage/models/).\n\nthis gives the following advantages:\n- **flexibility:** no need to conform to a fixed set of fields -- your data defines the schema\n- **multimodality:** at their core, documents are just dictionaries. this makes it easy to create and send them from any language, not just python.\n\nyou may also be familiar with our old document stores for vector db integration.\nthey are now called **document indexes** and offer the following improvements (see [here](#store) for the new api):\n\n- **hybrid search:** you can now combine vector search with text search, and even filter by arbitrary fields\n- **production-ready:** the new document indexes are a much thinner wrapper around the various vector db libraries, making them more robust and easier to maintain\n- **increased flexibility:** we strive to support any configuration or setting that you could perform through the db's first-party client\n\nfor now, document indexes support **[weaviate](https://weaviate.io/)**, **[qdrant](https://qdrant.tech/)**, **[elasticsearch](https://www.elastic.co/)**, **[redis](https://redis.io/)**,  exact nearest neighbour search and **[hnswlib](https://github.com/nmslib/hnswlib)**, with more to come.\n\n</details>\n\n### coming from pydantic\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nif you come from pydantic, you can see docarray documents as juiced up pydantic models, and docarray as a collection of goodies around them.\n\nmore specifically, we set out to **make pydantic fit for the ml world** - not by replacing it, but by building on top of it!\n\nthis means you get the following benefits:\n\n- **ml-focused types**: tensor, torchtensor, embedding, ..., including **tensor shape validation**\n- full compatibility with **fastapi**\n- **doclist** and **docvec** generalize the idea of a model to a _sequence_ or _batch_ of models. perfect for **use in ml models** and other batch processing tasks.\n- **types that are alive**: imageurl can `.load()` a url to image tensor, texturl can load and tokenize text documents, etc.\n- cloud-ready: serialization to **protobuf** for use with microservices and **grpc**\n- **pre-built multimodal documents** for different data modalities: image, text, 3dmesh, video, audio and more. note that all of these are valid pydantic models!\n- **document stores** and **document indexes** let you store your data and retrieve it using **vector search**\n\nthe most obvious advantage here is **first-class support for ml centric data**, such as `{torch, tf, ...}tensor`, `embedding`, etc.\n\nthis includes handy features such as validating the shape of a tensor:\n\n```python\nfrom docarray import basedoc\nfrom docarray.typing import torchtensor\nimport torch\n\n\nclass mydoc(basedoc):\n    tensor: torchtensor[3, 224, 224]\n\n\ndoc = mydoc(tensor=torch.zeros(3, 224, 224))  # works\ndoc = mydoc(tensor=torch.zeros(224, 224, 3))  # works by reshaping\n\ntry:\n    doc = mydoc(tensor=torch.zeros(224))  # fails validation\nexcept exception as e:\n    print(e)\n    # tensor\n    # cannot reshape tensor of shape (224,) to shape (3, 224, 224) (type=value_error)\n\n\nclass image(basedoc):\n    tensor: torchtensor[3, 'x', 'x']\n\n\nimage(tensor=torch.zeros(3, 224, 224))  # works\n\ntry:\n    image(\n        tensor=torch.zeros(3, 64, 128)\n    )  # fails validation because second dimension does not match third\nexcept exception as e:\n    print()\n\n\ntry:\n    image(\n        tensor=torch.zeros(4, 224, 224)\n    )  # fails validation because of the first dimension\nexcept exception as e:\n    print(e)\n    # tensor shape mismatch. expected(3, 'x', 'x'), got(4, 224, 224)(type=value_error)\n\ntry:\n    image(\n        tensor=torch.zeros(3, 64)\n    )  # fails validation because it does not have enough dimensions\nexcept exception as e:\n    print(e)\n    # tensor shape mismatch. expected (3, 'x', 'x'), got (3, 64) (type=value_error)\n```\n\n</details>\n\n### coming from pytorch\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nif you come from pytorch, you can see docarray mainly as a way of _organizing your data as it flows through your model_.\n\nit offers you several advantages:\n\n- express **tensor shapes in type hints**\n- **group tensors that belong to the same object**, e.g. an audio track and an image\n- **go directly to deployment**, by re-using your data model as a [fastapi](https://fastapi.tiangolo.com/) or [jina](https://github.com/jina-ai/jina) api schema\n- connect model components between **microservices**, using protobuf and grpc\n\ndocarray can be used directly inside ml models to handle and represent multimodaldata.\nthis allows you to reason about your data using docarray's abstractions deep inside of `nn.module`,\nand provides a fastapi-compatible schema that eases the transition between model training and model serving.\n\nto see the effect of this, let's first observe a vanilla pytorch implementation of a tri-modal ml model:\n\n```python\nimport torch\nfrom torch import nn\n\n\ndef encoder(x):\n    return torch.rand(512)\n\n\nclass mymultimodalmodel(nn.module):\n    def __init__(self):\n        super().__init__()\n        self.audio_encoder = encoder()\n        self.image_encoder = encoder()\n        self.text_encoder = encoder()\n\n    def forward(self, text_1, text_2, image_1, image_2, audio_1, audio_2):\n        embedding_text_1 = self.text_encoder(text_1)\n        embedding_text_2 = self.text_encoder(text_2)\n\n        embedding_image_1 = self.image_encoder(image_1)\n        embedding_image_2 = self.image_encoder(image_2)\n\n        embedding_audio_1 = self.image_encoder(audio_1)\n        embedding_audio_2 = self.image_encoder(audio_2)\n\n        return (\n            embedding_text_1,\n            embedding_text_2,\n            embedding_image_1,\n            embedding_image_2,\n            embedding_audio_1,\n            embedding_audio_2,\n        )\n```\n\nnot very easy on the eyes if you ask us. and even worse, if you need to add one more modality you have to touch every part of your code base, changing the `forward()` return type and making a whole lot of changes downstream from that.\n\nso, now let's see what the same code looks like with docarray:\n\n```python\nfrom docarray import doclist, basedoc\nfrom docarray.documents import imagedoc, textdoc, audiodoc\nfrom docarray.typing import torchtensor\nfrom torch import nn\nimport torch\n\n\ndef encoder(x):\n    return torch.rand(512)\n\n\nclass podcast(basedoc):\n    text: textdoc\n    image: imagedoc\n    audio: audiodoc\n\n\nclass pairpodcast(basedoc):\n    left: podcast\n    right: podcast\n\n\nclass mypodcastmodel(nn.module):\n    def __init__(self):\n        super().__init__()\n        self.audio_encoder = encoder()\n        self.image_encoder = encoder()\n        self.text_encoder = encoder()\n\n    def forward_podcast(self, docs: doclist[podcast]) -> doclist[podcast]:\n        docs.audio.embedding = self.audio_encoder(docs.audio.tensor)\n        docs.text.embedding = self.text_encoder(docs.text.tensor)\n        docs.image.embedding = self.image_encoder(docs.image.tensor)\n\n        return docs\n\n    def forward(self, docs: doclist[pairpodcast]) -> doclist[pairpodcast]:\n        docs.left = self.forward_podcast(docs.left)\n        docs.right = self.forward_podcast(docs.right)\n\n        return docs\n```\n\nlooks much better, doesn't it?\nyou instantly win in code readability and maintainability. and for the same price you can turn your pytorch model into a fastapi app and reuse your document\nschema definition (see [below](#coming-from-fastapi)). everything is handled in a pythonic manner by relying on type hints.\n\n</details>\n\n\n### coming from tensorflow\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nlike the [pytorch approach](#coming-from-pytorch), you can also use docarray with tensorflow to handle and represent multimodal data inside your ml model.\n\nfirst off, to use docarray with tensorflow we first need to install it as follows:\n\n```\npip install tensorflow==2.12.0\npip install protobuf==3.19.0\n```\n\ncompared to using docarray with pytorch, there is one main difference when using it with tensorflow:\nwhile docarray's `torchtensor` is a subclass of `torch.tensor`, this is not the case for the `tensorflowtensor`: due to some technical limitations of `tf.tensor`, docarray's `tensorflowtensor` is not a subclass of `tf.tensor` but rather stores a `tf.tensor` in its `.tensor` attribute. \n\nhow does this affect you? whenever you want to access the tensor data to, let's say, do operations with it or hand it to your ml model, instead of handing over your `tensorflowtensor` instance, you need to access its `.tensor` attribute.\n\nthis would look like the following:\n\n```python\nfrom typing import optional\n\nfrom docarray import doclist, basedoc\n\nimport tensorflow as tf\n\n\nclass podcast(basedoc):\n    audio_tensor: optional[audiotensorflowtensor] = none\n    embedding: optional[audiotensorflowtensor] = none\n\n\nclass mypodcastmodel(tf.keras.model):\n    def __init__(self):\n        super().__init__()\n        self.audio_encoder = audioencoder()\n\n    def call(self, inputs: doclist[podcast]) -> doclist[podcast]:\n        inputs.audio_tensor.embedding = self.audio_encoder(\n            inputs.audio_tensor.tensor\n        )  # access audio_tensor's .tensor attribute\n        return inputs\n```\n\n</details>\n\n### coming from fastapi\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\ndocuments are pydantic models (with a twist), and as such they are fully compatible with fastapi!\n\nbut why should you use them, and not the pydantic models you already know and love?\ngood question!\n\n- because of the ml-first features, types and validations, [here](#coming-from-pydantic)\n- because docarray can act as an [orm for vector databases](#coming-from-a-vector-database), similar to what sqlmodel does for sql databases\n\nand to seal the deal, let us show you how easily documents slot into your fastapi app:\n\n```python\nimport numpy as np\nfrom fastapi import fastapi\nfrom docarray.base_doc import docarrayresponse\nfrom docarray import basedoc\nfrom docarray.documents import imagedoc\nfrom docarray.typing import ndarray, imagetensor\n\n\nclass inputdoc(basedoc):\n    img: imagedoc\n    text: str\n\n\nclass outputdoc(basedoc):\n    embedding_clip: ndarray\n    embedding_bert: ndarray\n\n\napp = fastapi()\n\n\ndef model_img(img: imagetensor) -> ndarray:\n    return np.zeros((100, 1))\n\n\ndef model_text(text: str) -> ndarray:\n    return np.zeros((100, 1))\n\n\n@app.post(\"/embed/\", response_model=outputdoc, response_class=docarrayresponse)\nasync def create_item(doc: inputdoc) -> outputdoc:\n    doc = outputdoc(\n        embedding_clip=model_img(doc.img.tensor), embedding_bert=model_text(doc.text)\n    )\n    return doc\n\n\ninput_doc = inputdoc(text='', img=imagedoc(tensor=np.random.random((3, 224, 224))))\n\nasync with asyncclient(app=app, base_url=\"http://test\") as ac:\n    response = await ac.post(\"/embed/\", data=input_doc.json())\n```\n\njust like a vanilla pydantic model!\n\n</details>\n\n### coming from jina\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\njina has adopted docarray as their library for representing and serializing documents.\n\njina allows to serve models and services that are built with docarray allowing you to serve and scale these applications\nmaking full use of docarray's serialization capabilites. \n\n```python\nimport numpy as np\nfrom jina import deployment, executor, requests\nfrom docarray import basedoc, doclist\nfrom docarray.documents import imagedoc\nfrom docarray.typing import ndarray, imagetensor\n\n\nclass inputdoc(basedoc):\n    img: imagedoc\n    text: str\n\n\nclass outputdoc(basedoc):\n    embedding_clip: ndarray\n    embedding_bert: ndarray\n\n\ndef model_img(img: imagetensor) -> ndarray:\n    return np.zeros((100, 1))\n\n\ndef model_text(text: str) -> ndarray:\n    return np.zeros((100, 1))\n\n\nclass myembeddingexecutor(executor):\n    @requests(on='/embed')\n    def encode(self, docs: doclist[inputdoc], **kwargs) -> doclist[outputdoc]:\n        ret = doclist[outputdoc]()\n        for doc in docs:\n            output = outputdoc(\n                embedding_clip=model_img(doc.img.tensor),\n                embedding_bert=model_text(doc.text),\n            )\n            ret.append(output)\n        return ret\n\n\nwith deployment(\n    protocols=['grpc', 'http'], ports=[12345, 12346], uses=myembeddingexecutor\n) as dep:\n    resp = dep.post(\n        on='/embed',\n        inputs=doclist[inputdoc](\n            [inputdoc(text='', img=imagedoc(tensor=np.random.random((3, 224, 224))))]\n        ),\n        return_type=doclist[outputdoc],\n    )\n    print(resp)\n```\n\n</details>\n\n### coming from a vector database\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nif you came across docarray as a universal vector database client, you can best think of it as **a new kind of orm for vector databases**.\ndocarray's job is to take multimodal, nested and domain-specific data and to map it to a vector database,\nstore it there, and thus make it searchable:\n\n```python\nfrom docarray import doclist, basedoc\nfrom docarray.index import hnswdocumentindex\nimport numpy as np\n\nfrom docarray.typing import imageurl, imagetensor, ndarray\n\n\nclass imagedoc(basedoc):\n    url: imageurl\n    tensor: imagetensor\n    embedding: ndarray[128]\n\n\n# create some data\ndl = doclist[imagedoc](\n    [\n        imagedoc(\n            url=\"https://upload.wikimedia.org/wikipedia/commons/2/2f/alpamayo.jpg\",\n            tensor=np.zeros((3, 224, 224)),\n            embedding=np.random.random((128,)),\n        )\n        for _ in range(100)\n    ]\n)\n\n# create a document index\nindex = hnswdocumentindex[imagedoc](work_dir='/tmp/test_index2')\n\n\n# index your data\nindex.index(dl)\n\n# find similar documents\nquery = dl[0]\nresults, scores = index.find(query, limit=10, search_field='embedding')\n```\n\ncurrently, docarray supports the following vector databases:\n\n- [weaviate](https://www.weaviate.io/)\n- [qdrant](https://qdrant.tech/)\n- [elasticsearch](https://www.elastic.co/elasticsearch/) v8 and v7\n- [redis](https://redis.io/)\n- [milvus](https://milvus.io)\n- exactnnmemorysearch as a local alternative with exact knn search.\n- [hnswlib](https://github.com/nmslib/hnswlib) as a local-first ann alternative\n\nan integration of [opensearch](https://opensearch.org/) is currently in progress.\n\nof course this is only one of the things that docarray can do, so we encourage you to check out the rest of this readme!\n\n</details>\n\n\n### coming from langchain\n\n<details markdown=\"1\">\n  <summary>click to expand</summary>\n\nwith docarray, you can connect external data to llms through langchain. docarray gives you the freedom to establish \nflexible document schemas and choose from different backends for document storage.\nafter creating your document index, you can connect it to your langchain app using [docarrayretriever](https://python.langchain.com/docs/modules/data_connection/retrievers/integrations/docarray_retriever).\n\ninstall langchain via:\n```shell\npip install langchain\n```\n\n1. define a schema and create documents:\n```python\nfrom docarray import basedoc, doclist\nfrom docarray.typing import ndarray\nfrom langchain.embeddings.openai import openaiembeddings\n\nembeddings = openaiembeddings()\n\n# define a document schema\nclass moviedoc(basedoc):\n    title: str\n    description: str\n    year: int\n    embedding: ndarray[1536]\n\n\nmovies = [\n    {\"title\": \"#1 title\", \"description\": \"#1 description\", \"year\": 1999},\n    {\"title\": \"#2 title\", \"description\": \"#2 description\", \"year\": 2001},\n]\n\n# embed `description` and create documents\ndocs = doclist[moviedoc](\n    moviedoc(embedding=embeddings.embed_query(movie[\"description\"]), **movie)\n    for movie in movies\n)\n```\n\n2. initialize a document index using any supported backend:\n```python\nfrom docarray.index import (\n    inmemoryexactnnindex,\n    hnswdocumentindex,\n    weaviatedocumentindex,\n    qdrantdocumentindex,\n    elasticdocindex,\n    redisdocumentindex,\n)\n\n# select a suitable backend and initialize it with data\ndb = inmemoryexactnnindex[moviedoc](docs)\n```\n\n3. finally, initialize a retriever and integrate it into your chain!\n```python\nfrom langchain.chat_models import chatopenai\nfrom langchain.chains import conversationalretrievalchain\nfrom langchain.retrievers import docarrayretriever\n\n\n# create a retriever\nretriever = docarrayretriever(\n    index=db,\n    embeddings=embeddings,\n    search_field=\"embedding\",\n    content_field=\"description\",\n)\n\n# use the retriever in your chain\nmodel = chatopenai()\nqa = conversationalretrievalchain.from_llm(model, retriever=retriever)\n```\n\nalternatively, you can use built-in vector stores. langchain supports two vector stores: [docarrayinmemorysearch](https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/docarray_in_memory) and [docarrayhnswsearch](https://python.langchain.com/docs/modules/data_connection/vectorstores/integrations/docarray_hnsw). \nboth are user-friendly and are best suited to small to medium-sized datasets.\n\n</details>\n\n\n## see also\n\n- [documentation](https://docs.docarray.org)\n- [docarray<=0.21 documentation](https://docarray.jina.ai/)\n- [join our discord server](https://discord.gg/wamp6pvpgr)\n- [donation to linux foundation ai&data blog post](https://jina.ai/news/donate-docarray-lf-for-inclusive-standard-multimodal-data-model/)\n- [roadmap](https://github.com/docarray/docarray/issues/1714)\n\n> docarray is a trademark of lf ai projects, llc\n> \n",
  "docs_url": null,
  "keywords": "docarray,deep-learning,data-structures cross-modal multi-modal, unstructured-data, nested-data,neural-search",
  "license": "apache 2.0",
  "name": "docarray",
  "package_url": "https://pypi.org/project/docarray/",
  "project_url": "https://pypi.org/project/docarray/",
  "project_urls": {
    "Documentation": "https://docs.docarray.org",
    "Homepage": "https://docs.docarray.org/",
    "Repository": "https://github.com/docarray/docarray"
  },
  "release_url": "https://pypi.org/project/docarray/0.40.0/",
  "requires_dist": [
    "pydantic (>=1.10.8)",
    "numpy (>=1.17.3)",
    "protobuf (>=3.20.0) ; extra == \"proto\" or extra == \"hnswlib\" or extra == \"full\"",
    "torch (>=1.0.0) ; extra == \"torch\"",
    "orjson (>=3.8.2)",
    "pillow (>=9.3.0) ; extra == \"image\" or extra == \"full\"",
    "types-pillow (>=9.3.0.1) ; extra == \"image\" or extra == \"full\"",
    "trimesh[easy] (>=3.17.1) ; extra == \"mesh\" or extra == \"full\"",
    "typing-inspect (>=0.8.0)",
    "types-requests (>=2.28.11.6)",
    "av (>=10.0.0) ; extra == \"video\" or extra == \"full\"",
    "fastapi (>=0.100.0) ; extra == \"web\"",
    "rich (>=13.1.0)",
    "hnswlib (>=0.7.0) ; extra == \"hnswlib\"",
    "lz4 (>=1.0.0) ; extra == \"proto\" or extra == \"full\"",
    "pydub (>=0.25.1,<0.26.0) ; extra == \"audio\" or extra == \"full\"",
    "pandas (>=1.1.0) ; extra == \"pandas\" or extra == \"full\"",
    "weaviate-client (>=3.17,<3.18) ; extra == \"weaviate\"",
    "elasticsearch (>=7.10.1) ; extra == \"elasticsearch\"",
    "smart-open[s3] (>=6.3.0) ; extra == \"aws\"",
    "jina-hubble-sdk (>=0.34.0) ; extra == \"jac\"",
    "elastic-transport (>=8.4.0,<9.0.0) ; extra == \"elasticsearch\"",
    "qdrant-client (>=1.4.0) ; (python_version < \"3.12\") and (extra == \"qdrant\")",
    "pymilvus (>=2.2.12,<3.0.0) ; extra == \"milvus\"",
    "redis (>=4.6.0,<5.0.0) ; extra == \"redis\"",
    "jax (>=0.4.10) ; extra == \"jax\" or extra == \"full\"",
    "pyepsilla (>=0.2.3) ; extra == \"epsilla\""
  ],
  "requires_python": ">=3.8,<4.0",
  "summary": "the data structure for multimodal data",
  "version": "0.40.0",
  "releases": [],
  "developers": [
    "docarray"
  ],
  "kwds": "docarray multimodaldata _docarray docarray_hnsw image_doc",
  "license_kwds": "apache 2.0",
  "libtype": "pypi",
  "id": "pypi_docarray",
  "homepage": "https://docs.docarray.org/",
  "release_count": 740,
  "dependency_ids": [
    "pypi_av",
    "pypi_elastic_transport",
    "pypi_elasticsearch",
    "pypi_fastapi",
    "pypi_hnswlib",
    "pypi_jax",
    "pypi_jina_hubble_sdk",
    "pypi_lz4",
    "pypi_numpy",
    "pypi_orjson",
    "pypi_pandas",
    "pypi_pillow",
    "pypi_protobuf",
    "pypi_pydantic",
    "pypi_pydub",
    "pypi_pyepsilla",
    "pypi_pymilvus",
    "pypi_qdrant_client",
    "pypi_redis",
    "pypi_rich",
    "pypi_smart_open",
    "pypi_torch",
    "pypi_trimesh",
    "pypi_types_pillow",
    "pypi_types_requests",
    "pypi_typing_inspect",
    "pypi_weaviate_client"
  ]
}