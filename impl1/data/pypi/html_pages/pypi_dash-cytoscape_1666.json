{
  "libtype": "pypi",
  "libname": "dash-cytoscape",
  "url": "https://dash.plotly.com/cytoscape",
  "html": "<!DOCTYPE html><html><head>    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">      <meta charset=\"UTF-8\">      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">    <title>Dash Cytoscape | Dash for Python Documentation | Plotly</title>        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">    <meta name=\"description\" content=\"Dash Cytoscape is our network visualization component. It offers a declarative and pythonic interface to create beautiful, customizable, interactive and reactive network graphs.\">    <meta name=\"google-site-verification\" content=\"EgLBLquJuqD_NR96F-pKLhTy9ZKQlWIoQlexW_OVKrM\" />    <title>Dash Cytoscape | Dash for Python Documentation | Plotly</title>    <link rel=\"icon\" type=\"image/x-icon\" href=\"/assets/favicon.ico?m=1709327477.0\">    <link href=\"https://esm.sh/@markprompt/css@0.18.0?css\" rel=\"stylesheet\" />    <link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/ddk-all.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/bootstrap_build.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/_dash-component-suites/dash_design_kit/fa-ddk.v1_10_0m1709327510.css\"><link rel=\"stylesheet\" href=\"/assets/ag-grid-examples-css.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/azure.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/base.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/daq.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/dashbio.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/ddk.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/dosis.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/loading.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/local-css-example.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/markprompt_override.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/open-sans.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/override.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/percy.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/table.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/tabs-styled-with-classes.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/typography.css?m=1709327478.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/docs.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/gallery-style.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/react-resizable.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/dash-design-kit/report.css?m=1709327554.0\"><link rel=\"stylesheet\" href=\"/assets/font-awesome/css/fontawesome.min.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/font-awesome/css/solid.min.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/highlight/styles/default.css?m=1709327477.0\"><link rel=\"stylesheet\" href=\"/assets/highlight/styles/dm-mono.css?m=1709327477.0\">    <!-- Google Tag Manager Tag --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-N6T2RXG');</script>    <style type=\"text/css\">.placeholder-content{will-change:transform;animation:placeHolderShimmer 1s linear infinite forwards;-webkit-backface-visibility:hidden;background:#e6e6e6;background:linear-gradient(90deg,#eee 8%,#ddd 18%,#eee 33%);background-size:800px 104px;height:100%;position:relative}.placeholder-content *{color:transparent!important;opacity:0}@keyframes placeHolderShimmer{0%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:-468px 0;opacity:.7}45%{opacity:.8}75%{opacity:1}100%{-webkit-transform:translateZ(0);transform:translateZ(0);background-position:468px 0;opacity:.7}}@keyframes placeholderAnimate{0%{background-position:-650px 0}100%{background-position:650px 0}}.preload{position:fixed;top:0;left:0;right:0;bottom:0;transition:all ease .3s;z-index:99999;background-color:#fff}.preload *{box-sizing:border-box}.preload .pre-sidebar{position:absolute;top:0;left:0;bottom:0;width:300px;background-color:#fafafa}.preload .pre-content{position:absolute;top:0;left:300px;bottom:0;right:0;padding:0 0 0 90px;z-index:999;background-color:#fff}.preload .pre-brand{padding:35px 10px 20px 20px;display:flex;align-items:center;justify-content:space-between}.preload .pre-logo{width:100px;height:30px;flex-shrink:0;border-radius:6px}.preload .pre-switch{display:inline-flex !important;justify-content:flex-end;}.preload .pre-switch .pre-dot{flex-shrink:0;width:20px;height:20px;border-radius:20px;margin:0px !important;}.preload .pre-switch .pre-large{width:45px;height:20px;border-radius:20px;flex-shrink:0;margin:0 6px}.preload .pre-search{height:38px;width:223px;margin:10px 0 40px 36px;border-radius:30px}.preload .pre-line{width:100px;height:15px;margin:0 0 30px 30px;border-radius:3px}.preload .pre-line1{width:125px}.preload .pre-line2{width:135px}.preload .pre-line3{width:145px}.preload .pre-line4{width:245px}.preload .pre-line5{width:225px}.preload .pre-line6{width:235px}.preload .pre-line7{width:150px}.preload .pre-line8{width:180px}.preload .pre-line9{width:190px}.preload .pre-line10{width:120px}.preload .pre-menu{padding:20px 20px 0 0;text-align:right}.preload .pre-menu div{width:100px;display:inline-block;height:20px;border-radius:2px;margin:0 0 0 30px}.preload .pre-wrap{max-width:850px}.preload .pre-headline{height:30px;width:400px;margin:100px 0 70px 2px;border-radius:2px}.preload .pre-subhead{height:23px;width:180px;margin:0 0 28px 0;border-radius:2px}.preload .pre-subhead2{margin:70px 0 28px 0}.preload .pre-box-row{display:flex;flex-wrap:wrap;margin:0 -16px}.preload .pre-box-col{width:33.333%;margin:0 0 20px 0;padding:0 16px}.preload .pre-box{height:112px;width:100%;border-radius:2px}</style></head><body>  <div class=\"preload\">    <div class=\"pre-wrap\">      <div class=\"pre-sidebar\">        <div class=\"pre-brand\">          <div class=\"pre-logo placeholder-content\">          </div>        </div>        <div class=\"pre-search placeholder-content\">        </div>        <div class=\"pre-line pre-line1 placeholder-content\">        </div>        <div class=\"pre-line pre-line2 placeholder-content\">        </div>        <div class=\"pre-line pre-line3 placeholder-content\">        </div>        <div class=\"pre-line pre-line4 placeholder-content\">        </div>        <div class=\"pre-line pre-line5 placeholder-content\">        </div>        <div class=\"pre-line pre-line6 placeholder-content\">        </div>        <div class=\"pre-line pre-line7 placeholder-content\">        </div>        <div class=\"pre-line pre-line8 placeholder-content\">        </div>        <div class=\"pre-line pre-line9 placeholder-content\">        </div>        <div class=\"pre-line pre-line10 placeholder-content\">        </div>      </div>      <div class=\"pre-content\">        <div class=\"pre-menu\">          <div class=\" placeholder-content\">          </div>          <div class=\"pre-switch\">            <div class=\"pre-dot placeholder-content\">            </div>            <div class=\"pre-large placeholder-content\">            </div>            <div class=\"pre-dot placeholder-content\">          </div>          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>          <div class=\" placeholder-content\">          </div>        </div>        <div class=\"pre-wrap\">          <div class=\"pre-headline placeholder-content\">          </div>          <div class=\"pre-subhead placeholder-content\">          </div>          <div class=\"pre-box-row\">            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>          </div>          <div class=\"pre-subhead pre-subhead2 placeholder-content\">          </div>          <div class=\"pre-box-row\">            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>            <div class=\"pre-box-col\">              <div class=\"pre-box placeholder-content\">              </div>            </div>          </div>        </div>      </div>    </div>  </div>    <!-- Google Tag Manager Tag --><noscript><iframe src=\"https://www.googletagmanager.com/ns.html?id=GTM-N6T2RXG\"height=\"0\" width=\"0\" style=\"display:none;visibility:hidden\"></iframe></noscript>    <div id=\"react-entry-point\">        <div class=\"ssr-dash-core-components-markdown\"><h1 id=\"dash-cytoscape\"><img alt=\"\" src=\"/assets/images/language_icons/python_50px.svg\" /> Dash Cytoscape</h1><p>&lt;iframe&gt;<br />&lt;iframe&gt;</p><blockquote><p>Dash Cytoscape is a graph visualization component for creating easily<br />customizable, high-performance, interactive, and web-based networks. It<br />extends and renders <a href=\"http://js.cytoscape.org\">Cytoscape.js</a>, and<br />offers deep integration with Dash layouts and callbacks, enabling the<br />creation of powerful networks in conjunction with the rich collection of Dash components<br />, as well as established computational biology and network<br />science libraries such as Biopython and networkX.</p></blockquote><h2 id=\"quickstart\">Quickstart</h2><pre><code class=\"shell\">pip install dash-cytoscape==0.2.0</code></pre></div><div style=\"position:relative\"><div class=\"ssr-dash-core-components-clipboard\" style=\"position:absolute; right:10px; top:10px; height:50px\"></div> <div class=\"ssr-dash-core-components-markdown\"><pre><code class=\"python\">from dash import Dash, htmlimport dash_cytoscape as cytoapp = Dash(__name__)app.layout = html.Div([    cyto.Cytoscape(        id='cytoscape-two-nodes',        layout={'name': 'preset'},        style={'width': '100%', 'height': '400px'},        elements=[            {'data': {'id': 'one', 'label': 'Node 1'}, 'position': {'x': 75, 'y': 75}},            {'data': {'id': 'two', 'label': 'Node 2'}, 'position': {'x': 200, 'y': 200}},            {'data': {'source': 'one', 'target': 'two'}}        ]    )])if __name__ == '__main__':    app.run(debug=True)</code></pre></div></div><div class=\"example-container\" style=\"\"><div><div id=\"cytoscape-two-nodes\" class=\"ssr-dash-cytoscape-cytoscape\" style=\"width:100%; height:400px\"></div></div></div><div class=\"ssr-dash-core-components-markdown\"><blockquote><p>Dash Cytoscape graphs are interactive! Scroll to zoom and drag on<br />the canvas to move the entire graph around. You can move nodes by<br /><em>dragging</em> it, or by <em>clicking, holding, and moving your mouse</em><br />to the desired location (and click again to release).</p><p>This also work in mobile! Tap-and-hold on a node to move it, or on<br />the canvas to move the entire graph. Pinch your fingers outwards to<br />zoom in, or pinch them together to zoom out.</p></blockquote><h2 id=\"dash-cytoscape-user-guide\">Dash Cytoscape User Guide</h2><p><a href=\"/cytoscape/reference\">Reference</a></p><p>A comprehensive list of all of the Cytoscape properties.</p><p><a href=\"/cytoscape/elements\">Basic Usage &amp; Elements</a></p><p>Overview of element declaration and manipulation.</p><p><a href=\"/cytoscape/layout\">Layouts</a></p><p>Description of built-in layouts, and how to modify their properties. These include:</p><ul><li>Display Methods</li><li>Fine-tuning the Layouts</li><li>Physics-based Layouts</li><li>Loading External Layout</li></ul><p><a href=\"/cytoscape/styling\">Styling</a></p><p>Methods to style elements with a CSS-like syntax. These include:</p><ul><li>The <code>stylesheet</code> parameter</li><li>Basic selectors and styles</li><li>Comparing data items using selectors</li><li>Styling edges</li><li>Displaying Images</li></ul><p><a href=\"/cytoscape/callbacks\">Callbacks</a></p><p>Methods to combine Dash callbacks to update your Cytoscape object. These include:</p><ul><li>Changing Layouts</li><li>Interactively update styles</li><li>Adding and removing elements</li></ul><p><a href=\"/cytoscape/events\">Events and User Interactions</a></p><p>Overview of user-interaction events that trigger callbacks in Dash, and how to use them to update the Cytoscape component.</p><ul><li>Simple callback construction</li><li>Click, tap and hover</li><li>Selecting multiple elements</li><li>Advanced usage of callbacks</li></ul><p><a href=\"/cytoscape/biopython\">Biopython Examples</a></p><p>Examples of applications in bioinformatics using Biopython. These include:</p><ul><li>Parsing the Phylo object</li><li>Defining layout and stylesheet</li><li>Layout and Callbacks</li></ul><p><a href=\"/cytoscape/images\">Exporting Images</a></p><p>This example shows how to export your Cytoscape graphs as images (jpg, png, svg).</p><p><a href=\"/cytoscape/responsive\">Making responsive graphs</a></p><p>This example shows how to build a responsive Cytoscape graph.</p></div>    </div>    <footer>        <script id=\"_dash-config\" type=\"application/json\">{\"url_base_pathname\":null,\"requests_pathname_prefix\":\"\\u002f\",\"ui\":false,\"props_check\":false,\"show_undo_redo\":false,\"suppress_callback_exceptions\":true,\"update_title\":null,\"children_props\":{\"dash_core_components\":{\"Checklist\":[\"options[].label\"],\"Clipboard\":[],\"ConfirmDialog\":[],\"ConfirmDialogProvider\":[],\"DatePickerRange\":[],\"DatePickerSingle\":[],\"Download\":[],\"Dropdown\":[\"options[].label\"],\"Geolocation\":[],\"Graph\":[],\"Input\":[],\"Interval\":[],\"Link\":[],\"Loading\":[],\"Location\":[],\"LogoutButton\":[],\"Markdown\":[],\"RadioItems\":[\"options[].label\"],\"RangeSlider\":[],\"Slider\":[],\"Store\":[],\"Tab\":[],\"Tabs\":[],\"Textarea\":[],\"Tooltip\":[],\"Upload\":[]},\"dash_html_components\":{\"A\":[],\"Abbr\":[],\"Acronym\":[],\"Address\":[],\"Area\":[],\"Article\":[],\"Aside\":[],\"Audio\":[],\"B\":[],\"Base\":[],\"Basefont\":[],\"Bdi\":[],\"Bdo\":[],\"Big\":[],\"Blink\":[],\"Blockquote\":[],\"Br\":[],\"Button\":[],\"Canvas\":[],\"Caption\":[],\"Center\":[],\"Cite\":[],\"Code\":[],\"Col\":[],\"Colgroup\":[],\"Content\":[],\"Data\":[],\"Datalist\":[],\"Dd\":[],\"Del\":[],\"Details\":[],\"Dfn\":[],\"Dialog\":[],\"Div\":[],\"Dl\":[],\"Dt\":[],\"Em\":[],\"Embed\":[],\"Fieldset\":[],\"Figcaption\":[],\"Figure\":[],\"Font\":[],\"Footer\":[],\"Form\":[],\"Frame\":[],\"Frameset\":[],\"H1\":[],\"H2\":[],\"H3\":[],\"H4\":[],\"H5\":[],\"H6\":[],\"Header\":[],\"Hgroup\":[],\"Hr\":[],\"I\":[],\"Iframe\":[],\"Img\":[],\"Ins\":[],\"Kbd\":[],\"Keygen\":[],\"Label\":[],\"Legend\":[],\"Li\":[],\"Link\":[],\"Main\":[],\"MapEl\":[],\"Mark\":[],\"Marquee\":[],\"Meta\":[],\"Meter\":[],\"Nav\":[],\"Nobr\":[],\"Noscript\":[],\"ObjectEl\":[],\"Ol\":[],\"Optgroup\":[],\"Option\":[],\"Output\":[],\"P\":[],\"Param\":[],\"Picture\":[],\"Plaintext\":[],\"Pre\":[],\"Progress\":[],\"Q\":[],\"Rb\":[],\"Rp\":[],\"Rt\":[],\"Rtc\":[],\"Ruby\":[],\"S\":[],\"Samp\":[],\"Script\":[],\"Section\":[],\"Select\":[],\"Shadow\":[],\"Slot\":[],\"Small\":[],\"Source\":[],\"Spacer\":[],\"Span\":[],\"Strike\":[],\"Strong\":[],\"Sub\":[],\"Summary\":[],\"Sup\":[],\"Table\":[],\"Tbody\":[],\"Td\":[],\"Template\":[],\"Textarea\":[],\"Tfoot\":[],\"Th\":[],\"Thead\":[],\"Time\":[],\"Title\":[],\"Tr\":[],\"Track\":[],\"U\":[],\"Ul\":[],\"Var\":[],\"Video\":[],\"Wbr\":[],\"Xmp\":[]},\"dash_table\":{\"DataTable\":[]},\"dash_design_kit\":{\"App\":[],\"Block\":[],\"Card\":[],\"CardFooter\":[],\"CardHeader\":[],\"CollapsibleMenu\":[\"title\"],\"ControlCard\":[],\"ControlItem\":[],\"DataCard\":[],\"DataTable\":[],\"Footer\":[\"tags\"],\"FullScreen\":[\"cardRef\"],\"Graph\":[\"insights.title\",\"insights_conversation[].answer\"],\"Header\":[],\"Hero\":[\"tags\",\"primary_controls\",\"secondary_controls\"],\"Icon\":[],\"Logo\":[],\"Menu\":[],\"Modal\":[\"cardRef\"],\"Notification\":[],\"Page\":[],\"PageFooter\":[],\"PageHeader\":[],\"Report\":[],\"Row\":[],\"SectionTitle\":[],\"Sidebar\":[],\"SidebarCompanion\":[],\"Tag\":[],\"Title\":[],\"_CopyText\":null},\"dash_bootstrap_components\":{\"Accordion\":[],\"AccordionItem\":[],\"Alert\":[],\"Badge\":[],\"Breadcrumb\":[],\"Button\":[],\"ButtonGroup\":[],\"Card\":[],\"CardBody\":[],\"CardFooter\":[],\"CardGroup\":[],\"CardHeader\":[],\"CardImg\":[],\"CardImgOverlay\":[],\"CardLink\":[],\"Carousel\":[],\"Collapse\":[],\"DropdownMenu\":[\"label\"],\"DropdownMenuItem\":[],\"Fade\":[],\"Form\":[],\"FormFeedback\":[],\"FormFloating\":[],\"FormText\":[],\"Label\":[],\"Checkbox\":[\"label\"],\"Checklist\":[\"options[].label\"],\"Input\":[],\"InputGroup\":[],\"InputGroupText\":[],\"RadioButton\":[\"label\"],\"RadioItems\":[\"options[].label\"],\"Select\":[],\"Switch\":[\"label\"],\"Textarea\":[],\"Col\":[],\"Container\":[],\"Row\":[],\"Stack\":[],\"ListGroup\":[],\"ListGroupItem\":[],\"Modal\":[],\"ModalBody\":[],\"ModalFooter\":[],\"ModalHeader\":[],\"ModalTitle\":[],\"Nav\":[],\"NavItem\":[],\"NavLink\":[],\"Navbar\":[],\"NavbarBrand\":[],\"NavbarSimple\":[\"brand\"],\"NavbarToggler\":[],\"Offcanvas\":[\"title\"],\"Pagination\":[],\"Placeholder\":[],\"Popover\":[],\"PopoverBody\":[],\"PopoverHeader\":[],\"Progress\":[],\"Spinner\":[],\"Table\":[],\"Tab\":[],\"Tabs\":[],\"Toast\":[\"header\"],\"Tooltip\":[]},\"dash_user_guide_components\":{\"PageMenu\":[],\"Sidebar\":[]},\"dash_bio\":{\"AlignmentChart\":null,\"Circos\":null,\"FornaContainer\":null,\"Ideogram\":null,\"Igv\":null,\"Jsme\":null,\"Molecule2dViewer\":null,\"Molecule3dViewer\":null,\"NeedlePlot\":null,\"NglMoleculeViewer\":null,\"OncoPrint\":null,\"Pileup\":null,\"SequenceViewer\":null,\"Speck\":null},\"dash_cytoscape\":{\"Cytoscape\":null},\"dash_embedded\":{\"ConsumerContext\":[],\"ConsumerFunction\":[]},\"dash_ag_grid\":{\"AgGrid\":[]},\"components\":{\"Header\":[],\"NavLinks\":[],\"QuickSettings\":[],\"ShareDialog\":[]},\"dash_iconify\":{\"DashIconify\":null},\"dash_mantine_components\":{\"Accordion\":[\"chevron\"],\"AccordionControl\":[\"chevron\",\"icon\"],\"AccordionItem\":[],\"AccordionMultiple\":[\"chevron\"],\"AccordionPanel\":[],\"AppShell\":[\"navbar\",\"aside\",\"header\",\"footer\"],\"Aside\":[],\"Footer\":[],\"Header\":[],\"Navbar\":[],\"Avatar\":[],\"AvatarGroup\":[],\"Button\":[\"leftIcon\",\"rightIcon\"],\"ButtonGroup\":[],\"Card\":[],\"CardSection\":[],\"Checkbox\":[\"label\"],\"CheckboxGroup\":[\"label\",\"description\",\"error\"],\"Chip\":[],\"ChipGroup\":[],\"HoverCard\":[],\"HoverCardDropdown\":[],\"HoverCardTarget\":[],\"BackgroundImage\":[],\"Image\":[\"placeholder\",\"caption\"],\"List\":[\"icon\"],\"ListItem\":[\"icon\"],\"Menu\":[],\"MenuDivider\":[],\"MenuDropdown\":[],\"MenuItem\":[\"icon\",\"rightSection\"],\"MenuLabel\":[],\"MenuTarget\":[],\"Radio\":[\"label\"],\"RadioGroup\":[\"label\",\"description\",\"error\"],\"MultiSelect\":[\"nothingFound\",\"label\",\"description\",\"error\",\"icon\",\"rightSection\"],\"Select\":[\"nothingFound\",\"label\",\"description\",\"error\",\"icon\",\"rightSection\"],\"RangeSlider\":[\"marks[].label\",\"thumbChildren\"],\"Slider\":[\"marks[].label\",\"thumbChildren\"],\"Stepper\":[\"completedIcon\",\"progressIcon\"],\"StepperCompleted\":[],\"StepperStep\":[\"icon\",\"completedIcon\",\"progressIcon\",\"label\",\"description\"],\"Tab\":[\"rightSection\",\"icon\"],\"Tabs\":[],\"TabsList\":[],\"TabsPanel\":[],\"JsonInput\":[\"validationError\",\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"NumberInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"PasswordInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"TextInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"Textarea\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"Timeline\":[],\"TimelineItem\":[\"title\",\"bullet\"],\"FloatingTooltip\":[\"label\"],\"Tooltip\":[\"label\"],\"ActionIcon\":[],\"Affix\":[],\"Alert\":[\"title\",\"icon\"],\"Anchor\":[],\"Badge\":[\"leftSection\",\"rightSection\"],\"Blockquote\":[\"icon\",\"cite\"],\"Breadcrumbs\":[\"separator\"],\"Burger\":[],\"Center\":[],\"Code\":[],\"Col\":[],\"ColorPicker\":[],\"Container\":[],\"Divider\":[\"label\"],\"Drawer\":[\"title\"],\"Grid\":[],\"Group\":[],\"Highlight\":[],\"Indicator\":[\"label\"],\"Kbd\":[],\"Loader\":[],\"LoadingOverlay\":[\"loader\"],\"MantineProvider\":[],\"Mark\":[],\"MediaQuery\":[],\"Modal\":[\"title\"],\"NavLink\":[\"label\",\"description\",\"icon\",\"rightSection\"],\"Pagination\":[],\"Paper\":[],\"Prism\":[],\"Progress\":[\"sections[].tooltip\"],\"RingProgress\":[\"label\",\"sections[].tooltip\"],\"ScrollArea\":[],\"SegmentedControl\":[],\"SimpleGrid\":[],\"Skeleton\":[],\"Space\":[],\"Spoiler\":[],\"Stack\":[],\"Switch\":[\"label\",\"offLabel\",\"onLabel\",\"thumbIcon\"],\"Table\":[],\"Text\":[],\"ThemeIcon\":[],\"Title\":[],\"TransferList\":[],\"DatePicker\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"DateRangePicker\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"TimeInput\":[\"icon\",\"rightSection\",\"label\",\"description\",\"error\"],\"DemoSegmentedControl\":[],\"DemoSlider\":[],\"Notification\":[\"icon\",\"title\",\"message\"],\"NotificationsProvider\":[]},\"dash_canvas\":{\"DashCanvas\":null},\"dash_player\":{\"DashPlayer\":[]},\"dash_vtk\":{\"Algorithm\":null,\"Calculator\":null,\"CellData\":null,\"DataArray\":null,\"FieldData\":null,\"GeometryRepresentation\":null,\"GlyphRepresentation\":null,\"ImageData\":null,\"Mesh\":null,\"PointCloudRepresentation\":null,\"PointData\":null,\"PolyData\":null,\"Reader\":null,\"ShareDataSet\":null,\"SliceRepresentation\":null,\"View\":null,\"Volume\":null,\"VolumeController\":null,\"VolumeDataRepresentation\":null,\"VolumeRepresentation\":null},\"dash_vega_components\":{\"Vega\":[]}},\"serve_locally\":true}</script>        <script src=\"/_dash-component-suites/dash/deps/polyfill@7.v2_15_0m1709327518.12.1.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/react@16.v2_15_0m1709327518.14.0.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/react-dom@16.v2_15_0m1709327518.14.0.min.js\"></script><script src=\"/_dash-component-suites/dash/deps/prop-types@15.v2_15_0m1709327518.8.1.min.js\"></script><script src=\"/_dash-component-suites/dash_design_kit/dash_design_kit.v1_10_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_daq/dash_daq.v0_5_0m1709327515.min.js\"></script><script src=\"/_dash-component-suites/dash_bootstrap_components/_components/dash_bootstrap_components.v1_5_0m1709327513.min.js\"></script><script src=\"/_dash-component-suites/dash_user_guide_components/dash_user_guide_components.v0_0_8m1709327477.min.js\"></script><script src=\"/_dash-component-suites/dash_bio/bundle.v1_0_2m1709327509.js\"></script><script src=\"/_dash-component-suites/dash_cytoscape/dash_cytoscape.v0_2_0m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_embedded/dash_embedded.v2_7_0m1709327520.min.js\"></script><script src=\"/_dash-component-suites/dash_ag_grid/dash_ag_grid.v31_0_0m1709327512.min.js\"></script><script src=\"/_dash-component-suites/dash_enterprise_libraries/dash_renderer/dash_renderer/dash_renderer.v1_1_0m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_enterprise_libraries/components/components/components.v1_1_0m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_iconify/dash_iconify.v0_1_2m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_mantine_components/dash_mantine_components.v0_12_1m1709327508.js\"></script><script src=\"/_dash-component-suites/dash_canvas/dash_canvas.v0_1_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_player/dash_player.v1_1_0m1709327510.min.js\"></script><script src=\"/_dash-component-suites/dash_vtk/dash_vtk.v0_0_9m1709327508.min.js\"></script><script src=\"/_dash-component-suites/dash_vega_components/dash_vega_components.v0_8_0devm1709327518.min.js\"></script><script src=\"/assets/clientside_example.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridClientsideCallbacks.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridComponentFunctions.js?m=1709327477.0\"></script><script src=\"/assets/dashAgGridFunctions.js?m=1709327477.0\"></script><script src=\"/assets/loading.js?m=1709327478.0\"></script><script src=\"/assets/tooltip.js?m=1709327478.0\"></script><script src=\"/assets/dash-design-kit/print-handler.js?m=1709327554.0\"></script><script src=\"/_dash-component-suites/dash/dash-renderer/build/dash_renderer.v2_15_0m1709327517.min.js\"></script><script src=\"/_dash-component-suites/dash/dcc/async-markdown.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/dcc/dash_core_components.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/dcc/dash_core_components-shared.v2_13_0m1709327518.js\"></script><script src=\"/_dash-component-suites/dash/html/dash_html_components.v2_0_16m1709327518.min.js\"></script><script src=\"/_dash-component-suites/dash/dash_table/bundle.v5_2_9m1709327517.js\"></script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9b23397fa4d6430b1216471d79a04c4b\"] =     function(){        console.log(dash_clientside.callback_context);        const triggered_id = dash_clientside.callback_context.triggered_id;        return \"triggered id: \" + triggered_id    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"ec11c9ccf34e0f96b162e9b47e54bb54\"] =     function () {                     var printContents = document.getElementById('grid-print-area').innerHTML;         var originalContents = document.body.innerHTML;         document.body.innerHTML = printContents;         window.print();         document.body.innerHTML = originalContents;               location.reload()                                      return window.dash_clientside.no_update    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c68d712a9cfa59d0b000a0950f687e5f\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer1) window._slicer_slicer1 = {};            let private_state = window._slicer_slicer1;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"57e6fbe4bdf13b209addea6f23cf0ca0\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer1) window._slicer_slicer1 = {};            let private_state = window._slicer_slicer1;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer1-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"0bba8ae99f6075e92a2fd156897a54a1\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer2) window._slicer_slicer2 = {};            let private_state = window._slicer_slicer2;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"028dc7f444313744b07134cb8cec421a\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer2) window._slicer_slicer2 = {};            let private_state = window._slicer_slicer2;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer2-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c4ff0d7cabb1720d6259fcf465dbac6d\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer3) window._slicer_slicer3 = {};            let private_state = window._slicer_slicer3;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9227fe57c4a565dbcf8caa3e6608b68b\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer3) window._slicer_slicer3 = {};            let private_state = window._slicer_slicer3;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer3-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"1c59926d9fc28df84b9726d49ca31aa5\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer4) window._slicer_slicer4 = {};            let private_state = window._slicer_slicer4;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f9c881fde82e3997c3cbf5cd5ce113b4\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer4) window._slicer_slicer4 = {};            let private_state = window._slicer_slicer4;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer4-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"9cabb076d11534d2070aaa0f9b21c669\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer5) window._slicer_slicer5 = {};            let private_state = window._slicer_slicer5;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a9f1f38c2210c56952ab32639b940da3\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer5) window._slicer_slicer5 = {};            let private_state = window._slicer_slicer5;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer5-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"35b9b18168ee414534aeabab6384ece9\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer6) window._slicer_slicer6 = {};            let private_state = window._slicer_slicer6;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a0410a4f15683e04a7953ff7171d6322\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer6) window._slicer_slicer6 = {};            let private_state = window._slicer_slicer6;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer6-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"75e6bc3a3199ab8d1fdbbdf4bed9710c\"] =         function update_setpos_from_click(data, index, info) {            if (data && data.points && data.points.length) {                let point = data[\"points\"][0];                let xyz = [point[\"x\"], point[\"y\"]];                let depth = info.offset[2] + index * info.stepsize[2];                xyz.splice(2 - info.axis, 0, depth);                return xyz;            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"8f964b8aef121a06417ed5639bf46b86\"] =         function update_slider_value(positions, cur_index, info) {            for (let trigger of dash_clientside.callback_context.triggered) {                if (!trigger.value) continue;                let pos = trigger.value[2 - info.axis];                if (typeof pos !== 'number') continue;                let index = Math.round((pos - info.offset[2]) / info.stepsize[2]);                if (index == cur_index) continue;                return Math.max(0, Math.min(info.size[2] - 1, index));            }            return dash_clientside.no_update;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"27b81951a337a3d83b9ce234413b9537\"] =         function update_rate_limiting_info(index, relayoutData, n_intervals) {            if (!window._slicer_slicer7) window._slicer_slicer7 = {};            let private_state = window._slicer_slicer7;            let now = window.performance.now();            // Get whether the slider was moved, layout was changed, or timer ticked            let slider_value_changed = false;            let graph_layout_changed = false;            let timer_ticked = false;            for (let trigger of dash_clientside.callback_context.triggered) {                if (trigger.prop_id.indexOf('slider') >= 0) slider_value_changed = true;                if (trigger.prop_id.indexOf('timer') >= 0) timer_ticked = true;                if (trigger.prop_id.indexOf('graph') >= 0) {                    for (let key in relayoutData) {                        if (key.startsWith(\"xaxis.range\") || key.startsWith(\"yaxis.range\")) {                            graph_layout_changed = true;                        }                    }                }            }            // Set timeout and whether to disable the timer            let disable_timer = false;            if (slider_value_changed) {                private_state.timeout = now + 200;            } else if (graph_layout_changed) {                private_state.timeout = now + 400;  // need longer timeout for smooth scroll zoom            } else if (!n_intervals) {                private_state.timeout = now + 100;  // initialize            } else if (!private_state.timeout) {                disable_timer = true;            }            return disable_timer;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"fed84ee9b4fc95d53195903d1c09d104\"] =         function update_state(n_intervals, index, info, figure) {            if (!window._slicer_slicer7) window._slicer_slicer7 = {};            let private_state = window._slicer_slicer7;            let now = window.performance.now();            // Ready to apply and stop the timer, or return early?            if (!(private_state.timeout && now >= private_state.timeout)) {                return dash_clientside.no_update;            }            // Give the plot time to settle the initial axis ranges            if (n_intervals < 5) {                return dash_clientside.no_update;            }            // Disable the timer            private_state.timeout = 0;            // Calculate view range based on the volume            let xrangeVol = [                info.offset[0] - 0.5 * info.stepsize[0],                info.offset[0] + (info.size[0] - 0.5) * info.stepsize[0]            ];            let yrangeVol = [                info.offset[1] - 0.5 * info.stepsize[1],                info.offset[1] + (info.size[1] - 0.5) * info.stepsize[1]            ];            // Get view range from the figure. We make range[0] < range[1]            let xrangeFig = figure.layout.xaxis.range            let yrangeFig = figure.layout.yaxis.range;            xrangeFig = [Math.min(xrangeFig[0], xrangeFig[1]), Math.max(xrangeFig[0], xrangeFig[1])];            yrangeFig = [Math.min(yrangeFig[0], yrangeFig[1]), Math.max(yrangeFig[0], yrangeFig[1])];            // Add offset to avoid the corner-indicators for THIS slicer to only be half-visible            let plotSize = [400, 400];  // This estimate results in ok results            let graphDiv = document.getElementById('slicer7-graph');            let plotDiv = graphDiv.getElementsByClassName('js-plotly-plot')[0];            if (plotDiv && plotDiv._fullLayout)                plotSize = [plotDiv._fullLayout.width, plotDiv._fullLayout.height];            xrangeFig[0] += 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            xrangeFig[1] -= 2 * (xrangeFig[1] - xrangeFig[0]) / plotSize[0];            yrangeFig[0] += 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            yrangeFig[1] -= 2 * (yrangeFig[1] - yrangeFig[0]) / plotSize[1];            // Combine the ranges            let xrange = [Math.max(xrangeVol[0], xrangeFig[0]), Math.min(xrangeVol[1], xrangeFig[1])];            let yrange = [Math.max(yrangeVol[0], yrangeFig[0]), Math.min(yrangeVol[1], yrangeFig[1])];            // Create new state            let new_state = {                index: index,                index_changed: false,                xrange: xrange,                yrange: yrange,                zpos: info.offset[2] + index * info.stepsize[2],                axis: info.axis,                color: info.color,            };            if (index != private_state.last_index || info.infoid != private_state.infoid) {                private_state.last_index = index;                new_state.index_changed = true;            }            private_state.infoid = info.infoid;  // infoid changes on hot reload            return new_state;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a289fc0e674267642125023ad1cc5623\"] =         function update_image_traces(index, server_data, overlays, thumbnails, info, current_traces) {            // Prepare traces            let slice_trace = {                type: 'image',                x0: info.offset[0],                y0: info.offset[1],                dx: info.stepsize[0],                dy: info.stepsize[1],                hovertemplate: '(%{x:.2f}, %{y:.2f})<extra></extra>'            };            let overlay_trace = {...slice_trace};            overlay_trace.hoverinfo = 'skip';            overlay_trace.source = overlays[index] || '';            overlay_trace.hovertemplate = '';            let new_traces = [slice_trace, overlay_trace];            // Use full data, or use thumbnails            if (index == server_data.index) {                slice_trace.source = server_data.slice;            } else {                slice_trace.source = thumbnails[index];                // Scale the image to take the exact same space as the full-res                // version. Note that depending on how the low-res data is                // created, the pixel centers may not be correctly aligned.                slice_trace.dx *= info.size[0] / info.thumbnail_size[0];                slice_trace.dy *= info.size[1] / info.thumbnail_size[1];                slice_trace.x0 += 0.5 * slice_trace.dx - 0.5 * info.stepsize[0];                slice_trace.y0 += 0.5 * slice_trace.dy - 0.5 * info.stepsize[1];            }            // Has the image data even changed?            if (!current_traces.length) { current_traces = [{source:''}, {source:''}]; }            if (new_traces[0].source == current_traces[0].source &&                new_traces[1].source == current_traces[1].source)            {                new_traces = dash_clientside.no_update;            }            return new_traces;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"f339c51ca4326e401d37debce3ca77f7\"] =         function update_indicator_traces(states, info, thisState) {            let traces = [];            for (let state of states) {                if (!state) continue;                let zpos = [state.zpos, state.zpos];                let trace = null;                if        (info.axis == 0 && state.axis == 1) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 0 && state.axis == 2) {                    trace = {x: zpos, y: state.xrange};                } else if (info.axis == 1 && state.axis == 2) {                    trace = {x: zpos, y: state.yrange};                } else if (info.axis == 1 && state.axis == 0) {                    trace = {x: state.xrange, y: zpos};                } else if (info.axis == 2 && state.axis == 0) {                    trace = {x: state.yrange, y: zpos};                } else if (info.axis == 2 && state.axis == 1) {                    trace = {x: zpos, y: state.yrange};                }                if (trace) {                    trace.line = {color: state.color, width: 1};                    traces.push(trace);                }            }            // Show our own color around the image, but only if there are other            // slicers with the same scene id, on a different axis. We do some            // math to make sure that these indicators are the same size (in            // scene coordinates) for all slicers of the same data.            if (thisState && info.color && traces.length) {                let fraction = 0.1;                let lengthx = info.size[0] * info.stepsize[0];                let lengthy = info.size[1] * info.stepsize[1];                let lengthz = info.size[2] * info.stepsize[2];                let dd = fraction * (lengthx + lengthy + lengthz) / 3;  // average                dd = Math.min(dd, 0.45 * Math.min(lengthx, lengthy, lengthz));  // failsafe                let x1 = thisState.xrange[0];                let x2 = thisState.xrange[0] + dd;                let x3 = thisState.xrange[1] - dd;                let x4 = thisState.xrange[1];                let y1 = thisState.yrange[0];                let y2 = thisState.yrange[0] + dd;                let y3 = thisState.yrange[1] - dd;                let y4 = thisState.yrange[1];                traces.push({                    x: [x1, x1, x2, null, x3, x4, x4, null, x4, x4, x3, null, x2, x1, x1],                    y: [y2, y1, y1, null, y1, y1, y2, null, y3, y4, y4, null, y4, y4, y3],                    line: {color: info.color, width: 4}                });            }            // Post-process the traces we created above            for (let trace of traces) {                trace.type = 'scatter';                trace.mode = 'lines';                trace.hoverinfo = 'skip';                trace.showlegend = false;            }            if (thisState) {                return traces;            } else {                return dash_clientside.no_update;            }        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"020a8f1ee482480054891b1e4caea2b7\"] =         function update_figure(img_traces, indicator_traces, extra_traces, info, ori_figure) {            // Collect traces            let traces = [];            for (let trace of img_traces) { traces.push(trace); }            for (let trace of extra_traces) { traces.push(trace); }            for (let trace of indicator_traces) { if (trace.line.color) traces.push(trace); }            // Update figure            let figure = {...ori_figure};            figure.data = traces;            return figure;        }        ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"737b17422cfe7391f1bcd969e8d43b81\"] =     function(title, path, params, hash, refreshPage) {        // trigger a pagemenu rerender and set the document title        window.history.replaceState(null, null, path + params + hash);        if (title) { document.title = title; }        return [\"\", path, refreshPage];    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"1de45535074f9ee92c79a2354a307227\"] =     function(refreshPage) {    if (refreshPage===true) {        window.location.reload();    }    return \"\";    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"6acc23bd4fd7c6ce7608cc6fe7b7202c\"] =     function(data, scale) {        return {            'data': data,            'layout': {                 'yaxis': {'type': scale}             }        }    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"fd1b4f76c8ff11908312c46c223af06a\"] =     function(figure, scale) {        if(figure === undefined) {            return {'data': [], 'layout': {}};        }        const fig = Object.assign({}, figure, {            'layout': {                ...figure.layout,                'yaxis': {                    ...figure.layout.yaxis, type: scale                }             }        });        return fig;    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"a78481a4f6c719909e97053e789187ab\"] =     async function(value) {    const response = await fetch(value);    const data = await response.json();    return data;    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"441278594b1bf51cecc22b131679c5ad\"] =     function show_tooltip(hoverData) {        if(!hoverData) {            return [false, dash_clientside.no_update];        }        var pt = hoverData.points[0];        return [true, pt.bbox];    }    ;</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"44390b7a6fa5102bd9f74b36a1c0fa9f\"] = async function (changedCell, forceRefresh) {        gridApi = await dash_ag_grid.getApiAsync('styling-cells-other-col')        forceRefresh.length != 0 && gridApi.refreshCells({force: true, columns: ['employee']})        return window.dash_clientside.no_update        };</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"578761413470259ceb606b75a880ed53\"] = function (rowId) {        if (rowId) {            grid = dash_ag_grid.getApi(\"grid-scroll-to-pagination\")                    rowIndex = grid.getRowNode(rowId).rowIndex                    pageTarget = Math.floor(rowIndex / grid.paginationGetPageSize())            grid.paginationGoToPage(pageTarget)        }        return {\"rowId\": rowId.toString()}    };</script><script>var clientside = window.dash_clientside = window.dash_clientside || {};var ns = clientside[\"_dashprivate_clientside_funcs\"] = clientside[\"_dashprivate_clientside_funcs\"] || {};ns[\"c49927592154cdef683f73b893ca3711\"] = function (rowId) {        if (rowId) {            grid = dash_ag_grid.getApi(\"grid-scroll-to-group\")            grid.setRowNodeExpanded(grid.getRowNode(rowId), true, true)        }        return {\"rowId\": rowId.toString()}    };</script>        <script id=\"_dash-renderer\" type=\"application/javascript\">var renderer = new DashRenderer();</script>    </footer>    <div id=\"markprompt\" />    <script>  window.onUsersnapCXLoad = function(api) {    api.init();  }  var script = document.createElement('script');  script.defer = 1;  script.src = 'https://widget.usersnap.com/global/load/c591243c-ea62-42c1-9af3-a1829dfb78cc?onload=onUsersnapCXLoad';  document.getElementsByTagName('head')[0].appendChild(script);</script>          <script type=\"module\">        // References URL link formatter        const getHref = (result) => {          var path = result.file.path;          // If the source is not plotly.com/python, then it should be a relative path          if (!path.startsWith(\"https://plotly.com/python\")) {            var urlObject = new URL(path);            path = urlObject.pathname;          }          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.id) {            path = (path + \"#\" + result.meta.leadHeading.id);          }          if (result && result.meta && result.meta.leadHeading && result.meta.leadHeading.value) {            path =  (path + \"#\" + result.meta.leadHeading.slug);          }          return path;        };        const getLabel = (reference) => {         var label = reference.meta?.leadHeading?.value || reference.file?.title;          label = label.replace(/[^\\x00-\\x7F]/g, \"\");          while (label.includes(\"plotly-logomark\")) {              label = label.replace(\"plotly-logomark\", \"\");          }          return label;        };        const setCookie = (name, value, days) => {         const expires = new Date();         expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);         document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;        };        const getCookie = (name) => {            const cookies = document.cookie.split(';');            for (let i = 0; i < cookies.length; i++) {                const cookie = cookies[i].trim();                if (cookie.startsWith(name + '=')) {                    return cookie.substring(name.length + 1);                }            }        return null;        };        const getUniqueID = () => {            const storedID = getCookie(\"plotly-chatbot-cookie\");            if (storedID) {                return storedID;            } else {                const newID = generateUniqueID();                setCookie(\"plotly-chatbot-cookie\", newID, 365);                return newID;            }        };        const generateUniqueID = () => {            return Date.now().toString();        };      window.markprompt = {        projectKey: 'pk_0upevf7bcscej8JQMALYiqmXoWQkltw3',        container: '#markprompt',        options: {        sticky: true,        close: { hasIcon: true },          chat: {            systemPrompt: \"- You are an enthusiastic company representative from Plotly who loves to help people!\\- Never give code examples which are not provided in the docs, and don't give code examples in other languages than Python.\",            defaultView: {              message: \"Welcome to Plotly's AI Assistant\",              promptsHeading: 'Popular questions',              prompts: [                'How can I get started with Dash?',                'How can I customize the layout in Dash?',                'How can I change the color of graph labels?',                'How do I move the legend to the top of the graph?',              ],            },              conversationMetadata: {                \"userid\": getUniqueID(),                \"source\": \"dash-docs\",                },            enabled: true,            model: 'gpt-3.5-turbo',            maxTokens: 2000,            errorText: \"Sorry, I'm having some connection issues. Please try again in a few minutes.\",          },          search: {            enabled: false,            getHref: getHref          },          references: {            heading: 'References',            getHref: getHref,            getLabel: getLabel          },          feedback: {            enabled: true          },          trigger: {            buttonLabel: 'Ask AI',            iconSrc: '/assets/markprompt_chat.svg'          },          branding: {            type: 'text'          }        }      }    </script>        <script type=\"module\" src=\"https://esm.sh/@markprompt/web@0.24.0/init\"></script></body></html>",
  "embeddings": []
}