{
  "libtype": "pypi",
  "libname": "docopt",
  "url": "http://docopt.org",
  "html": "<!doctype html><html><head>    <meta charset=\"utf-8\">    <title>docopt\u2014language for description of command-line interfaces</title>    <link rel=\"stylesheet\" href=\"normalize.css\" media=\"screen\">    <link rel=\"stylesheet\" href=\"style.css\" media=\"screen\">    <link rel=\"stylesheet\" href=\"printable.css\" media=\"print\"></head><body>    <a href=\"https://github.com/docopt/\"><img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\" alt=\"Fork me on GitHub\"></a>    <h1>docopt</h1>    <script>        document.getElementsByTagName('h1')[0].className =        ['dashdash', 'ellipsis', 'brackets', 'angular', 'parens', 'upper', '']        [Math.floor(Math.random() * 7)];    </script>    <h2>Command-line interface description language</h2><iframe width=\"800\" height=\"450\"src=\"http://www.youtube.com/embed/pXhcPJK5cMc?rel=0\"frameborder=\"0\" allowfullscreen></iframe><p><code>docopt</code> helps you:</p><ul><li>define the interface for your command-line app, and</li><li>automatically generate a parser for it.</li></ul><p><code>docopt</code> is based on conventions that have been used for decades in help messages andman pages for describing a program's interface.  An interface descriptionin <code>docopt</code> <em>is</em> such a help message, but formalized.  Here is an example:</p><pre><code>Naval Fate.Usage:  naval_fate ship new &lt;name&gt;...  naval_fate ship &lt;name&gt; move &lt;x&gt; &lt;y&gt; [--speed=&lt;kn&gt;]  naval_fate ship shoot &lt;x&gt; &lt;y&gt;  naval_fate mine (set|remove) &lt;x&gt; &lt;y&gt; [--moored|--drifting]  naval_fate -h | --help  naval_fate --versionOptions:  -h --help     Show this screen.  --version     Show version.  --speed=&lt;kn&gt;  Speed in knots [default: 10].  --moored      Moored (anchored) mine.  --drifting    Drifting mine.</code></pre><p>The example describes the interface of executable <code>naval_fate</code>, which can beinvoked with different combinations of <em>commands</em> (<code>ship</code>, <code>new</code>, <code>move</code>,etc.), <em>options</em> (<code>-h</code>, <code>--help</code>, <code>--speed=&lt;kn&gt;</code>, etc.)  and positionalarguments (<code>&lt;name&gt;</code>, <code>&lt;x&gt;</code>, <code>&lt;y&gt;</code>).</p><p>The example uses brackets \"<code>[ ]</code>\", parens \"<code>( )</code>\", pipes \"<code>|</code>\" and ellipsis\"<code>...</code>\" todescribe <em>optional</em>, <em>required</em>, <em>mutually exclusive</em>, and <em>repeating</em>elements.  Together, these elements form valid <em>usage patterns</em>, each startingwith program's name <code>naval_fate</code>.</p><p>Below the usage patterns, there is a list of options with descriptions.They describe whether an option has short/long forms (<code>-h</code>, <code>--help</code>), whetheran option has an argument (<code>--speed=&lt;kn&gt;</code>), and whether that argument has adefault value (<code>[default: 10]</code>).</p><p>A <code>docopt</code> implementation will extract all that information and generate acommand-line arguments parser, with the text of the interface description as thehelp message shown when the program is invoked withthe <code>-h</code> or <code>--help</code> options.</p><h2>Usage patterns</h2><p>Text occuring between keyword <code>usage:</code> (case-<em>in</em>sensitive) and a <em>visibly</em>empty line is interpreted as list of usage patterns.  The first word after<code>usage:</code> is interpreted as the program's name.  Here is a minimal example forprogram that takes no command-line arguments:</p><pre><code>Usage: my_program</code></pre><p>Program can have several patterns listed with various elements used todescribe the pattern:</p><pre><code>Usage:  my_program command --option &lt;argument&gt;  my_program [&lt;optional-argument&gt;]  my_program --another-option=&lt;with-argument&gt;  my_program (--either-that-option | &lt;or-this-argument&gt;)  my_program &lt;repeating-argument&gt; &lt;repeating-argument&gt;...</code></pre><p>Each of the elements and constructs is described below.We will use the word \"<em>word</em>\" to describe a sequence of characters delimitedby either whitespace, one of \"<code>[]()|</code>\" characters, or \"<code>...</code>\".</p><h3>&lt;argument> ARGUMENT</h3><p>Words starting with \"<code>&lt;</code>\", ending with \"<code>&gt;</code>\" and upper-case words areinterpreted as positional arguments.</p><pre><code>Usage: my_program &lt;host&gt; &lt;port&gt;</code></pre><h3>-o --option</h3><p>Words starting with one or two dashes (with exception of \"<code>-</code>\", \"<code>--</code>\"by themselves) are interpreted as short (one-letter) or long options,respectively.</p><ul><li>Short options can be \"stacked\" meaning that <code>-abc</code> is equivalent to<code>-a -b -c</code>.</li><li>Long options can have arguments specified after space or equal \"<code>=</code>\" sign:<br><code>--input=ARG</code> is equivalent to <code>--input ARG</code>.</li><li>Short options can have arguments specified after <em>optional</em> space:<br><code>-f FILE</code> is equivalent to <code>-fFILE</code>.</li></ul><p>Note, writing <code>--input ARG</code> (as opposed to <code>--input=ARG</code>) is ambiguous, meaningit is not possible to tell whether <code>ARG</code> is option's argument or a positionalargument.  In usage patterns this will be interpreted as an option with argument<em>only</em> if a description (covered below) for that option isprovided.  Otherwise it will be interpreted as an option and separatepositional argument.</p><p>There is the same ambiguity with the <code>-f FILE</code> and <code>-fFILE</code> notation. In the lattercase it is not possible to tell whether it is a number of stacked shortoptions, or an option with an argument.  These notations will be interpreted as anoption with argument <em>only</em> if a description for the option is provided.</p><h3>command</h3><p>All other words that do <em>not</em> follow the above conventions of <code>--options</code> or<code>&lt;arguments&gt;</code> are interpreted as (sub)commands.</p><h3>[optional elements]</h3><p>Elements (options, arguments, commands) enclosed with square brackets \"<code>[ ]</code>\"are marked to be <em>optional</em>.  It does not matter if elements are enclosedin the same or different pairs of brackets, for example:</p><pre><code>Usage: my_program [command --option &lt;argument&gt;]</code></pre><p>is equivalent to:</p><pre><code>Usage: my_program [command] [--option] [&lt;argument&gt;]</code></pre><h3>(required elements)</h3><p><em>All elements are required by default</em>, if not included in brackets \"<code>[ ]</code>\".However, sometimes it is necessary to mark elements as required explicitlywith parens \"<code>( )</code>\".For example, when you need to group mutually-exclusive elements (see nextsection):</p><pre><code>Usage: my_program (--either-this &lt;and-that&gt; | &lt;or-this&gt;)</code></pre><p>Another use case is when you need to specify that <em>if one element is present,then another one is required</em>, which you can achieve as:</p><pre><code>Usage: my_program [(&lt;one-argument&gt; &lt;another-argument&gt;)]</code></pre><p>In this case, a valid program invocation could be with either no arguments,or with 2 arguments.</p><h3>element|another</h3><p>Mutually-exclusive elements can be separated with a pipe \"<code>|</code>\" as follows:</p><pre><code>Usage: my_program go (--up | --down | --left | --right)</code></pre><p>Use parens \"<code>( )</code>\" to group elements when <em>one</em> of the mutually exclusivecases is required.  Use brackets \"<code>[ ]</code>\" to group elements when <em>none</em> of themutually exclusive cases is required:</p><pre><code>Usage: my_program go [--up | --down | --left | --right]</code></pre><p>Note, that specifying several patterns works exactly like pipe \"<code>|</code>\", that is:</p><pre><code>Usage: my_program run [--fast]       my_program jump [--high]</code></pre><p>is equivalent to:</p><pre><code>Usage: my_program (run [--fast] | jump [--high])</code></pre><h3>element...</h3><p>Use ellipsis \"<code>...</code>\" to specify that the argument (or group of arguments)to the left could be repeated one or more times:</p><pre><code>Usage: my_program open &lt;file&gt;...       my_program move (&lt;from&gt; &lt;to&gt;)...</code></pre><p>You can flexibly specify the number of arguments that are required.Here are 3 (redundant) ways of requiring zero or more arguments:</p><pre><code>Usage: my_program [&lt;file&gt;...]       my_program [&lt;file&gt;]...       my_program [&lt;file&gt; [&lt;file&gt; ...]]</code></pre><p>One or more arguments:</p><pre><code>Usage: my_program &lt;file&gt;...</code></pre><p>Two or more arguments (and so on):</p><pre><code>Usage: my_program &lt;file&gt; &lt;file&gt;...</code></pre><h3>[options]</h3><p>\"<code>[options]</code>\" is a shortcut that allows to avoid listing all options(from list of options with descriptions) in a pattern.  For example:</p><pre><code>Usage: my_program [options] &lt;path&gt;--all             List everything.--long            Long output.--human-readable  Display in human-readable format.</code></pre><p>is equivalent to:</p><pre><code>Usage: my_program [--all --long --human-readable] &lt;path&gt;--all             List everything.--long            Long output.--human-readable  Display in human-readable format.</code></pre><p>This can be useful if you have many options and all of them are applicableto one of patterns. Alternatively, if you have both short and longversions of options (specified in option description part),you can list either of them in a pattern:</p><pre><code>Usage: my_program [-alh] &lt;path&gt;-a, --all             List everything.-l, --long            Long output.-h, --human-readable  Display in human-readable format.</code></pre><p>More details on how to write options' descriptions will follow below.</p><h3>[--]</h3><p>A double dash \"<code>--</code>\", when not part of an option, is often used as a conventionto separate options and positional arguments, in order to handle cases when,e.g., file names could be mistaken for options.  In order to support thisconvention, add \"<code>[--]</code>\" into your patterns before positional arguments.</p><pre><code>Usage: my_program [options] [--] &lt;file&gt;...</code></pre><p>Apart from this special meaning, \"<code>--</code>\" is just a normal command, so you canapply any previously-described operations, for example, make it required(by dropping brackets \"<code>[ ]</code>\")</p><h3>[-]</h3><p>A single dash \"<code>-</code>\", when not part of an option, is often used by conventionto signify that a program should process <code>stdin</code>, as opposed to a file.If you want to follow this convention add \"<code>[-]</code>\" to your pattern.\"<code>-</code>\" by itself is just a normal command, which you can use with any meaning.</p><h2>Option descriptions</h2><p>Option descriptions consist of a list of options that you put below yourusage patterns.  It is optional to specify them if there is no ambiguityin usage patterns (described in the <code>--option</code> section above).</p><p>An option's description allows to specify:</p><ul><li>that some short and long options are synonymous,</li><li>that an option has an argument,</li><li>and the default value for an option's argument.</li></ul><p>The rules are as follows:</p><p>Every line that starts with \"<code>-</code>\" or \"<code>--</code>\" (not counting spaces)is treated as an option description, e.g.:</p><pre><code>Options:  --verbose   # GOOD  -o FILE     # GOODOther: --bad  # BAD, line does not start with dash \"-\"</code></pre><p>To specify that an option has an argument, put a word describing thatargument after a space (or equals \"<code>=</code>\" sign) as shown below. Followeither <code>&lt;angular-brackets&gt;</code> or <code>UPPER-CASE</code> convention for options' arguments.You can use a comma if you want to separate options. In the example below, bothlines are valid, however it is recommended to stick to a single style.</p><pre><code>-o FILE --output=FILE       # without comma, with \"=\" sign-i &lt;file&gt;, --input &lt;file&gt;   # with comma, without \"=\" sign</code></pre><p>Use two spaces to separate options with their informal description.</p><pre><code>--verbose MORE text.    # BAD, will be treated as if verbose                        # option had an argument MORE, so use                        # 2 spaces instead-q        Quit.         # GOOD-o FILE   Output file.  # GOOD--stdout  Use stdout.   # GOOD, 2 spaces</code></pre><p>If you want to set a default value for an option with an argument, put itinto the option's description, in the form <code>[default: &lt;the-default-value&gt;]</code>.</p><pre><code>--coefficient=K  The K coefficient [default: 2.95]--output=FILE    Output file [default: test.txt]--directory=DIR  Some directory [default: ./]</code></pre><h2><a href=\"http://try.docopt.org\">Try <code>docopt</code> in your browser</a></h2><h2>Implementations</h2><p><code>docopt</code> is available in numerous programming languages.Official implementations are listed under the <a href=\"https://github.com/docopt\">docopt organization on GitHub</a>.</p><p><br></p>    <script>        var _gaq=[['_setAccount','UA-15242420-3'],['_trackPageview']];        (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];        g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';        s.parentNode.insertBefore(g,s)}(document,'script'));    </script></body></html>",
  "embeddings": []
}